SelfConsciousness: | # your fish brain
    n FishBrain
    
    n Houp
    n Koul

FishBrain: | # beginning middle and end superimposed on J's state
    u i
    s: %acgt:c sc
        sayyl "oscillating!";
        $A = G&A,s=>0=>$c,$sc;
        # s could order a particular ground
        
        # ground has been completed, pos revamping sleepybits from drain
        my $g = A.ground || die "noground";
             gs&J eq A.1 || die "ground sJ not A1";
        my $ch = g.t;
        
        # ground -> drain
        my $d = 1s&drains.>$ch = G&hup,$g;
        ds&z = [@{ds&z}];
        
        # brain is ongoing, one per ground
        A&s = $C = 1s&brains.>$ch ||= G&Ct,[$ch=>1=>{}=>{J=>A.1}];
        
        # o in - to map the drain and OC the changes
        #   climbing in/next/z to produce OC feedable clones,
        #   C that are attributes it keeps/diffs but doesn't OC
        # the oinD is origin in drain
        # the oinC is our copy of it
        # the OC is another copy, which the oiD gets
        
        # where we'd want to forget $d, the drain itself...
        my $o = A&in = G&o,$d,{liveon=>$C,t=>'in',yoff=>'OC'};
        # Core is changes
        my @O = map { G&A,O=>2=>_.c,_.sc } @{os&Core};
        
        # O - only changes and their parents
        # < tug for .1 progress
        # < with an A=Os for all
        G&A,$_,8 for @O;
        
        # < wOrms, in-wormholes
        #   where thing is our part of some sharing of truth
        # is one-ish with:
        # < waves of language solvents
        # all basically generating ongoing job lists
        # usually pumping so-classified things through some filter
        # everything moving comes classified as some elvis
        #   so s&of encodings happen now
        #   and W doings on other hosts emit through Op
        #   W doing might be updating it on the news...
        
        # another use for o be the upping/downing of indexes
        # amongst sources that may not all be awake.
        
        # Cora is Core with unchanged stuff too,
        #   which will have its last awake .y.OC
        #   slight possibility of zombies if you topy&OCs&qua++
        #     will news themselves until oinD quashes changes
        my $r = 1s&root || die "how to hold many";
        $r = r.y.OC || die "root didn't OC";
        # put this stuff in the idea of itself
        rs&z = [ grep{ $_ ne $r } map{ _.y.OC } @{os&Cora} ];
        
        # o ou - to finalise ourselves and OK changes
        $o = A&ut = G&o,$r,{liveon=>$C,t=>'ut',yoff=>'KC',gen=>'lv'};
        my @K = map { G&A,K=>2=>_.c,_.sc } @{os&Core};
        
        # K - only changes and their parents
        #   <6 becomes things for s&top, s&tv, etc
        #   >6 comps for writing Lines
        # < an A=Ks would map out AWritering
        #     pointing to objects already on the ground
        G&A,$_,8 for @K;
        
        # pick up on r.y.OK and jump down Wormhole
        # -> W
    #     watching the K diverge as a way to get input is interesting
    # self servers (Dogu/-lookin eg) wants to see out-changes as in-changes

Houp: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        my $D = A&s;
        # y:
        #   oinD - in drain
        #   oinC - oinD's copy via o ($D now)
        #   OC - the whole new this to run through oscillation
        # so D knows the OC it turned into
        $C =
        A&s =
        D.y.OC =
        C.y.OC = G&hup,A&s;
        # < using o to do ^ that for us, to preserve all wiring
        
        # so D knows nothing about its being photographed?
        # C here is OC, OC.y.oinD = D, OC.y.oinC = D's copy via o
        # and D's copy is C.y.oiC
        
        
        
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = $C = G&hup,A&from;
        # C is (was) the l from zip
        my $x = a&x = C.y.x || die "OC no yx: ".ki$C;
        if (my $J = s&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
        T.not = 1 if C.sc.not eq '1';
        # G&hup,
    O 2:
        C.y.A = $A;
        #return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of', 'js') {
            if (my $Wt = C.sc.>$W) {
                my $W = $W eq 'js' ? 'javascript' : $W;
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        
        # indexed ground within universals
        if (my $J = !s&noii && s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.ii; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scii D.t no in";
                    while ($S) {
                        a&swim.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W";
                        $S = S.y.next;
                    }
                    $D = D.y.over
                }
            }
        }
        
        if (my $sel = 1s&sels) {
            while (my ($k,$els) = each %$sel) {
                exists C.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    A&el eq $el || A&el eq '2' && $el eq '1' ||
                    $el eq '5' && A&el < 4 || next;
                    $do->($A,$C,$G,$T);
                }
            }
        }
    
    O 5:
        return unless A.ii.S;
        local A.cv = 0.4999;
        local A.ov = 0.5999;
        G&throat,'S';
    
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv, 
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
Koul: | # clarify changes to string
    u a
    # might be making Lines in here?
    # might be doing some C's whole picture (1) and lv diff (7)
    #   as two Cs? make encoding instructions pop in
    K 1:
        A&from = shift @$s; # us
        A&s = $C = G&hup,A&from;
        my $l = a&l = C.y.l || die "No KC yl: ".ki$C;
        my $x = a&x = l.y.x || die "KCyl no yx: ".ki$l;
        if (my $J = ls&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        my $l = a&l;
        delete c&Jo if ls&W || ls&qz;
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = a&J || die "No sJ for Jo K: ".ki$l;
            my $x = a&x;
            my $lo = xc&Jo;
            if ($lo ne c&Jo) {
                my $s = a&ys;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = xc&Jowil || 1;
                my $conti = sc&imp eq xc&Joimp && $lv eq xc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                xc&Jolv = $lv;
                xc&Joimp = sc&imp;
                xc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                delete c&s if Js&tv; # has inside
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
    # set Js&Kels.sending.3 = $s to G&h,$cb for sc.sendings el3ing
    K 3:
        my $l = a&l;
        my $r = l.y.r || die "no lyr";
        rc&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            my $up = l.y.up;
            if ($up && up.y.cv eq 0.9) {
            while (my ($k,$els) = each %$sel) {
                exists l.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    rc&el eq $el || rc&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
            }
        }
    K 4:
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE' && $nk ne 'sc';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
        
    D 2:
        # reverse it
    

