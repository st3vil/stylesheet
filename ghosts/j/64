SelfConsciousness: | # your fish brain
    n FishBrain
    
    n Houp
    n Koul
Testmo: |
    n SirKill
    
    
    my ($o) = G&op,'sof:i';
    (T.op) = G&op,'cW:of';
    
    my $ub = &C{
        join "\n","C.t C.y.cv   ".ki(C.sc),
          grep /while|each/,
          split "\n", c&s
    };
    my @e = G&ind,T.op,$ub;
    saybl @e;
    my @l = G&op;
    1 && sayyl "_.t _.y.cv: ".ki(_.sc),
        grep /while|each/,
        grep /ref/,
        split "\n", _c&s
        for @l;
    each nk,gk,v $C {
        say "Yer $nk $gk is $v"
    }}
    my $c = G&t,w=>'CoBabbler';
    1 && sayre "For c.t c.y.cv ".ki(c.sc),
        grep /nonref/,
        split "\n", cc&s;
Tanigle: |
    u i
    bol:
        each nk,gk,v $C {
            say "Yer $nk $gk is $v"
        }}
FishBrain: | # beginning middle and end superimposed on J's state
    u i
    s: %acgt:c sc
        sayyl "oscillating!";
        $A = G&A,s=>0=>$c,$sc;
        # s could order a particular ground
        
        # ground has been completed, pos revamping sleepybits from drain
        my $g = A.ground || die "noground";
             gs&J eq A.1 || die "ground sJ not A1";
        my $ch = g.t;
        
        # ground -> drain
        my $d = 1s&drains.>$ch = G&hup,$g;
        ds&z = [@{ds&z}];
        
        # brain is ongoing, one per ground
        A&s = $C = 1s&brains.>$ch ||= G&Ct,[$ch=>1=>{}=>{J=>A.1}];
        
        # o in - to map the drain and OC the changes
        #   climbing in/next/z to produce OC feedable clones,
        #   C that are attributes it keeps/diffs but doesn't OC
        # the oinD is origin in drain
        # the oinC is our copy of it
        # the OC is another copy, which the oiD gets
        
        # where we'd want to forget $d, the drain itself...
        my $o = A&in = G&o,$d,{liveon=>$C,t=>'in',yoff=>'OC'};
        # Core is changes
        my @O = map { G&A,O=>2=>_.c,_.sc } @{os&Core};
        
        # O - only changes and their parents
        # < tug for .1 progress
        # < with an A=Os for all
        G&A,$_,8 for @O;
        
        # < wOrms, in-wormholes
        #   where thing is our part of some sharing of truth
        # is one-ish with:
        # < waves of language solvents
        # all basically generating ongoing job lists
        # usually pumping so-classified things through some filter
        # everything moving comes classified as some elvis
        #   so s&of encodings happen now
        #   and W doings on other hosts emit through Op
        #   W doing might be updating it on the news...
        
        # another use for o be the upping/downing of indexes
        # amongst sources that may not all be awake.
        
        # Cora is Core with unchanged stuff too,
        #   which will have its last awake .y.OC
        #   slight possibility of zombies if you topy&OCs&qua++
        #     will news themselves until oinD quashes changes
        my $r = 1s&root || die "how to hold many";
        $r = r.y.OC || die "root didn't OC";
        # put this stuff in the idea of itself
        rs&z = [ grep{ $_ ne $r } map{ _.y.OC } @{os&Cora} ];
        
        # o ou - to finalise ourselves and OK changes
        $o = A&ut = G&o,$r,{liveon=>$C,t=>'ut'};
        my @K = map { G&A,K=>2=>_.c,_.sc } @{os&Core};
        
        # K - only changes and their parents
        #   <6 becomes things for s&top, s&tv, etc
        #   >6 comps for writing Lines
        # < an A=Ks would map out AWritering
        #     pointing to objects already on the ground
        G&A,$_,8 for @K;
        
        # pick up on r.y.OK and jump down Wormhole
        # -> W
    #     watching the K diverge as a way to get input is interesting
    # self servers (Dogu/-lookin eg) wants to see out-changes as in-changes
SirKill: | # crawl datastructure
    u i
    o: %acgt:s c sc
        saygr "Do o: ".ki $s;
        $A = G&A,o=>0=>$c,$sc;
        my $on = A&liveon || die "live where";
        my $o = A&s = $on.>A&t ||= {t=>A&t};
        my $name = 'o'.o.t; # eg oin
        oc&ysource = $name.'D'; # oinD, in drain
        oc&clones = [$name.'C','lv','OC']; # oinC on record
        oc&sourcey = 'OC'; # OC thrown into process, drained C links to that
        my $isC = &C{
            defined C.t && C.y && C.c && C.sc
        };
        # many A=o hold cs=C
        my $io = {t=>'o',up=>$o,c=>{s=>$s},sc=>{}};
        my @L = io.y = $io;
        my @R;
        # builds up from z/in/tw/tv
        while (@L || @R) {
            @L = reverse @R if !@L;
            my $A = shift(@L);
            my $C = A&s;
            # < give these A/C to T for blowingup locator?
            (Gc&B.sc.aA, Gc&B.sc.aC) = ($A,$C) if Gc&B;
            snooze 1300;
            1 && sayre "V ".join('',('  ') x A&ind)." ".ki $C;
            1 && sayyl "Asck: ".join', ', sort keys %{A.sc};
            unless (A&last) { #c last reoccurs
                1 && saybl "0 last";
                # but first
                $isC->($C) || die "notC: ".ki$C;
                A&ipi ||= 0; # increment per child
                if (A&comp eq 'tv') {
                    A&last = ups&tv.>C.t.>C.y.cv || {};
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                elsif (A.up eq $o) {
                    # io has an A
                    A&last = os&lastA;
                }
                else {
                    A&ext || die "how to file";
                    A&last = ups&Tv.>A&ext || {};
                }
                # for "attach to the above"
                a&tv = {}; # t/cv join
                a&Tv = {}; # nk/gk join
                # < different namespacing? crunch function?
            }
            unless (A&insides) { #c insides
                1 && saybl "1 insides";
                my $st = {}; # same inside may appear many places
                # Scuttle should tell ways in
                # < checking that everything is found via each way
                #   mostly it will be filling up the connection of
                #   chucked together any way bits
                # < should know all y/c/sc that look C or [C+]
                my @at;
                each nk,gk,v $C {
                    next if 'y'eq$nk; # distracto or handled
                    if (ref $v eq 'HASH') {
                        $isC->($v) || next;
                        push @at, ["$nk $gk",[$v],{nk=>$nk,gk=>$gk}];
                    }
                    elsif (ref $v eq 'ARRAY') {
                        next if $nk eq 'sc' && $gk eq 'z'; # handled
                        next unless @$v == grep {
                            ref $_ eq 'HASH' && $isC->($_) } @$v;
                        push @at, ["$nk $gk",$v,{isTv=>1,nk=>$nk,gk=>$gk}];
                    }
                    else {
                    }
                }}
                A&insides = [ # A inner
                    map {
                        my ($t,$z,$c) = @$_;
                        map {
                            my $Y = $_;
                            Yc&ext = $t;
                            Yc&zip = A&ipi++;
                            Yc&ind = A&ind+1;
                            Y.c.>$_ = $c.>$_ for keys %{$c||{}};
                            my $s = "Yc&s";
                            push @{$st.>$s ||= []}, $Y;
                            _.y = $Y;
                        } map {
                            {t=>'o',up=>$A,c=>{s=>$_},sc=>{}}
                        } @$z
                    }
                    @at, # attributes we can see
                    # these all mean "inside", are in tv competition:
                    map { $_->[2] = {comp=>'tv'}; $_ }
                    grep{defined}
                    (C.y.in ? do {
                        my @S = my $S = C.y.in;
                        push @S, $S while $S = S.y.next;
                        ['y in', \@S]
                    } : undef),
                    (C.y.tw ? do {
                        ['y tw',[values %{C.y.tw}]]
                    } : undef),
                    (C.y.tv ? do {
                        ['y tv',[map{values %$_} values %{C.y.tv}]]
                    } : undef),
                    (C.sc.z ? do {
                        ['sc z',C.sc.z]
                    } : undef),
                ];
                # check $st for duplicate s
                each s,z $st {
                    @$z > 1 || next;
                    my @z = @$z;
                    @$z = pop @z;
                    A&Atrm.>$_ ++ for @z;
                }
                @{A&insides} = grep { !A&Atrm.>$_ } @{A&insides}
                    if A&Atrm;
                
                # so we know which values are things
                #   with their own differencing A
                A&ways_in = {};
                push @{A&ways_in.>_c&ext ||= []}, $_ for @{A&insides};
                
                # attach to the above, possibly many
                if (A&comp eq 'tv') {
                    push @{ups&tv.>C.t.>C.y.cv ||= []}, $A;
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                elsif (A.up eq $o) {
                    # io has an A
                    #A&last = os&lastA;
                }
                else {
                    A&ext || die "how to file";
                    push @{ups&Tv.>A&ext ||= []}, $A;
                }
                
                1 && saygr " C.t has ".@{A&insides}." insides";
                push @L, @{A&insides};
                push @R, $A;
                next;
            }
            unless (A&diff) { #c difference, in reverse, insidest first
                1 && saybl "2 diff";
                # last A, compare a&ng
                my $d = A&last;
                my $D = A&diff = {};
                Ds&allnew = 1 if !dc&el;
                # Ds&neg - changed values nk/gk = q
                # Ds&pos - changed things index/$index = Y
                
                # the values
                # maintain Ds&ng nk/gk
                # change of Ds&neg nk/gk
                #  - this each Bablar will next on !ref t
                #  and avoid y, t/cv we write in
                each nk,gk,v $C {
                    # not things that will change superficially
                    next if $nk eq 'y';
                    next if A&ways_in->{"$nk $gk"};
                    
                    a&ng.>$nk.>$gk = $v;
                    if (ds&ng.>$nk.>$gk ne $v) {
                        my $q = Ds&neg.>$nk.>$gk = {t=>$gk,c=>{s=>$v}};
                        qc&new = 1 if !exists ds&ng.>$nk.>$gk;
                        qc&was = ds&ng.>$nk.>$gk if !qc&new;
                    }
                }}
                each nk,gk,v ds&ng {
                    exists $C.>$nk.>$gk && next;
                    Ds&neg.>$nk.>$gk = {t=>$gk,c=>{was=>$v}};
                }}
                
                # the yin change Ds&pos (tv nk/gk | Tv exp)
                # tv and Tv are indexes that may flatten the many
                each t,cv,Y a&tv {
                    # last one wins
                    push @{a&many.tv.>$t.>$cv ||= []}, shift @$Y
                        while @$Y > 1;
                    $Y = shift @$Y;
                    a&tv.>$t.>$cv = $Y; # count it
                    
                    Yc&el eq '8' && next; # sleep
                    Ds&pos.tv.>$t.>$cv = $Y;
                }}
                each t,cv,Y ds&tv {
                    a&tv.>$t.>$cv && next;
                    Yc&el eq '9' && next;
                    Yc&el = '9';
                    delete Ys&ord;
                    delete Ys&ready;
                    a&tv.>$t.>$cv = # remover to sort in?
                    Ds&pos.tv.>$t.>$cv = $Y;
                }}
                
                # values that were things
                # - transport intact
                # its A works out its sleeping el=8
                # set value in a&ng as handled things skip
                each ext,v a&Tv {
                    push @{a&many.Tv.>$ext ||= []}, shift @$v
                        while @$v > 1;
                    $v = shift @$v;
                    a&Tv.>$ext = $v; # count it
                    
                    # set value/transport intact
                    vc&nk && vc&gk || die "No ext nkgk: $ext: ".ki $v;
                    a&ng.>vc&nk.>vc&gk = vc&s;
                    
                    vc&el eq '8' && next; # sleep
                    # < no el=3 possible?
                    Ds&neg.>vc&nk.>vc&gk = {t=>vc&gk,c=>{s=>vc&s}};
                }
                each ext,v ds&Tv {
                    a&Tv.>$ext && next;
                    vc&nk && vc&gk || die "No ext nkgk: $ext: ".ki $v;
                    # deletes the value
                    Ds&neg.>vc&nk.>vc&gk = {t=>vc&gk,c=>{was=>vc&s}};
                }
                
                # may not need to move
                A&el = '8' unless Ds&neg || Ds&pos;
            }


            
            unless (a&clones) { #c generate replacable bodies, rev/insidest first
                1 && saybl "3 clones";
                my $d = A&last;
                my $D = A&diff;
                # a&ng is nk/gk = $v ground as is
                #   attributes including Tv things, they skipped diffing initially
                # Ds&neg is nk/gk = change C:
                #   c.s = $v if present, c.was if past
                #   be only trace of attribute/Tv thing if gone
                #   
                
                # a&tv.>$t.>$cv = $Y insides
                # Ds&pos.tv.>$t.>$cv = $Y also
                #   would be only trace of thing if gone,
                #     but needing to sort in the remover with a&tv
                #     should skip the Yc&el='9' when wiring non-lv
                #     but pop them out disconnected in Core
                
                # make clones, usu
                # - one to keep on record to diff
                # - one to give to processes unknown
                # - more? parallel
                # o is where ref integrity is most unlost/buried
                # < knowing all refs on $o, wire Cgen, pointerise lv
                for my $t (@{oc&clones}) {
                    my $E = {t=>C.t,y=>{cv=>C.y.cv}};
                    
                    if (A&el eq '8') {
                        $E = a&clones.>$t = ds&clones.>$t
                            || die "el8 had no clone $t";
                    }
                    elsif (A&el eq '9') {
                        # never happens:
                        #  - Tv goners are Ds&neg-ations
                        #  - tv goners are a&tv.>$t.>$cv = old $Y
                        #    will be brought back into play with a&ord
                        #    but shouldn't emit non-lv objects
                    }
                    else {
                        A&el = Ds&allnew ? '1' : '3';
                    
                    }
                    if ($t eq 'lv') {
                        Ec&el = A&el if !defined Ec&el;
                    }
                    if (my $ys = oc&ysource) {
                        # oinD = in drain C
                        E.y.>$ys = $C;
                    }
                    if (my $sy = oc&sourcey) {
                        # in drain C.y.OC = $OC
                        C.y.>$sy = $E if $sy eq $t;
                    }
                    
                    if (A&isTv && $t ne 'lv') {
                        # if we are a Tv, transport intact?
                        # ups&ng will overwrite this anyway?
                        #   will find it through os&refs, be the same
                        #   but could change as this clone
                        $E = $C;
                    }
                    # the clone can see its A
                    E.y.A = $A;
                    
                    a&clones.>$t = $E;
                }
                
                # then sort in from first
                push @R, $A if A.up eq $o;
                next;
            }
            unless (a&ord) { #c ordering, gathering
                1 && saybl "4 ord";
                # gathering refs, we already in order
                # first A's clones win pointing to
                # < is depth first tho...
                my $r = os&refs.>$C ||= {};
                push @{rs&Ys||=[]}, $A;
                
                # should know if v is:
                #   referenced somewhere else, for lv pointers
                #   a cloned C, to point to relevant clone
                #     dont y.out etc if trying to transport intact C
                each nk,gk,v a&ng {
                    ref $v || next;
                    my $r = os&refs.>$v ||= {};
                    a&whererefis.>$v = [$nk,$gk];
                    push @{rs&Ys||=[]}, $A;
                }}
                
                # now create more of that ^ order
                my @l;
                if (a&Tv) {
                    # eg Tv C masters yin C, unless Scuttled to hup
                    push @l, map { a&Tv.>$_ } sort keys %{a&Tv};
                }
                if (a&tv) {
                    # then cv/t
                    my $yttv;
                    each t,cv,Y a&tv {
                        $yttv.>$cv.>$t = $Y;
                    }}
                    for my $cv (sort keys %$yttv) {
                        my $tw = $yttv.>$cv;
                        for my $t (sort keys %$tw) {
                            my $Y = $tw.>$t;
                            push @l, $Y;
                        }
                    }
                    # sleepables here? refs compet should still work
                }
                a&ord = 'sure';
                # do these things before our next thing
                # to keep our order - unshift for @l would reverse it
                unshift @L, @l;
                # or our next us
                push @L, $A;
                next;
            }
            unless (a&ready) { #c set new values
                1 && saybl "5 ready";
                if (A.up eq $o) {
                    # sort through the single pile of refs
                    my @nop;
                    each ref,r os&refs {
                        @{rs&Ys} > 1 || push(@nop, $ref) && next;
                        my $Y = rs&Ys->[0];
                        # becomes the definitive source of that ref
                        # may be its C for Tv/tv, some Cnkgk for ng
                        # so lv can be perfect
                        rs&Y = $Y;
                    }
                    # leaves only doubled things
                    delete os&refs.>$_ for @nop;
                }
                
                my $d = A&last;
                my $D = A&diff = {};
                
                # assign the correct refs
                # same order as refs won, so they should exist where pointed
                for my $t (@{oc&clones}) {
                    my $E = a&clones.>$t;
                    
                    # plot entanglements amidst assigning values
                    #   unless we're to transport intact
                    #   the right thing will be in Ys&clones by now
                    #
                    each nk,gk,v a&ng {
                        $E.>$nk.>$gk = $v;
                        my $r = ref $v && os&refs.>$v || next;
                        my $Y = rs&Y;
                        next if $A eq $Y;
                        # other has the one thing
                        #  < link C that knows where either one is
                        #    keeping refs on the yonder A will do
                        if (my $nkgk = Ys&whererefis.>$v ) {
                            my $V = Yc&s;
                            my ($nk,$gk) = @$nkgk;
                            $V.>$nk.>$gk eq $v
                                || die "Refwasnotat ".ki[$v,$nkgk,$V];
                            $V = Ys&clones.>$t || die "noclone nkgk $t";
                            # may differ if Scuttled to...
                            $v = $V.>$nk.>$gk;
                        }
                        elsif ($v eq Yc&s) {
                            # is Tv implanting
                            #   or something in a ty somewhere
                            # should transport intact ref as clone
                            $v = Ys&clones.>$t || die "noclone $t";
                            # for an lv to tell of encoded properties
                            a&haveC.>$nk.>$gk = $v;
                        }
                        else {
                            die "TheresnorefonY ".ki[$v,$Y];
                        }
                    }}
                    if ($t eq 'lv') {
                        my $neg = Ds&neg;
                        # lv: t y el=9, no detail (in up z tho)
                        $neg = {} if A&el eq '9';
                        # which are already there
                        each nk,gks $E {
                            ref $gks || next;
                            delete $E.>$nk.>$_ for
                                grep { !$neg.>$nk.>$_ } keys %$gks;
                        }
                        # to drop universals named in Ec&ds, etc
                        my $dn = {};
                        each nk,gk,q $neg {
                            if (!exists qc&s) {
                                $dn.>$nk.>$gk = 1;
                            }
                            else {
                                $E.>$nk.>$gk eq q.c.s || die "wasnt neg/ng"
                                    .ki[[$nk,$gk],$q,$E];
                            }
                        }}
                        # encoding this may need json
                        each nk,gks $dn {
                            $nk = 's' if $nk eq 'sc';
                            E.c->{"d$nk"} = join ' ', sort keys %$gks;
                        }
                        # the lv may a&haveC, locating C attr
                        #   and explaining their encoding
                        
                        # moment of life its for
                        Ec&el = A&el;
                        # the clone can (still) see its A
                        E.y.A = $A;
                    }
                    
                    # put for wiring to tv
                    if (!A&isTv && A.up ne $o) {
                        my $U = ups&clones.>$t || die "no upclone $t";
                        push @{Us&z||=[]}, $E;
                    }
                }
                a&ready = 1;
                push @L, $A;
                
            }
            unless (a&wiring) { #c link together, wants to do in reverse
                1 && sayre "6 Wiring A&ind  ".ki $C;
                # to hoist the list of everything:
                #   Cora is where everything sorts into a flat list
                #   Core is same order with A&el=9 (removals) added
                #     and A&el=8 removed as far as order of everything is implied
                # then K makes a .prev if it's not Cora-order?
                for my $t (@{oc&clones}) {
                    my $E = a&clones.>$t;
                    # share clones their Cor(e|a) hoisty lists
                    my $net = a&clonet.>$t = {};
                    
                    if (Ec&z) {
                        # wire the tv plane
                        my $ra = []; # everything still there
                        my $re = []; # everything changing
                        my $la; # what to put before things in lv
                        for my $i (@{Ec&z}) { # this clone's 
                            my $Y = i.y.A; # their A
                            my $wet = Yc&clonet.>$t;
                            
                            if (Yc&el ne '9') {
                                # the non-lv tv plane
                                push @$ra, $i;
                                # and load Cora
                                push @{net.Cora||=[]}, $i, @{wet.Cora||[]};
                            }
                            
                            # only re matters to lv, sparse negating C
                            # each y could link to tv reals
                            if (Yc&el ne '8') {
                                if ($la && $t eq 'lv' && Yc&el ne '3' && Yc&el ne '9') {
                                    # throw in el=8 for the thing before
                                    push @$re, $la if $ra->[-1] ne $la;
                                }
                                push @$re, $i;
                                push @{net.Core||=[]}, $i, @{wet.Core||[]};
                            }
                            $la = $i;
                        }
                        # lv wants to wire everything changing togehter
                        my $wi = $t eq 'lv' ? $re : $ra;
                        undef $la;
                        for my $i (@$wi) {
                            E.y.in ||= $i;
                            i.y.out = $E;
                            if ($la) {
                                la.y.next = $i;
                                i.y.prev = $la;
                            }
                            $la = $i;
                        }
                        Ec&z = $wi;
                    }
                    
                    # last clone (OC?) becomes A&s, or C if you steal this A's c/sc
                    A&s = $E;
                    # assume everything's parent will be active at the last hop
                    # so A&Core is everything changed and the top, nested in flat list
                    # look at C
                    A&Core = [$E,@{net.Core||[]}];
                    A&Cora = [$E,@{net.Cora||[]}];
                }
                a&wiring = 1;
            }
        }
        
        1 && sayre "Finished ".ki $o;
        # export some io sc to o
        o.sc.>$_ = io.sc.>$_ for qw'Core Cora';
        #@{os&Core} = # everything changed
        #@{os&Cora} = # everything
        os&lastA = $io;
        
        $o;
Houp: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        my $D = A&s;
        # y:
        #   oinD - in drain
        #   oinC - oinD's copy via o ($D now)
        #   OC - the whole new this to run through oscillation
        # so D knows the OC it turned into
        $C =
        A&s =
        D.y.OC =
        C.y.OC = G&hup,A&s;
        # < using o to do ^ that for us, to preserve all wiring
        
        # so D knows nothing about its being photographed?
        # C here is OC, OC.y.oinD = D, OC.y.oinC = D's copy via o
        # and D's copy is C.y.oiC
        
        
        
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = $C = G&hup,A&from;
        # C is (was) the l from zip
        my $x = a&x = C.y.x || die "OC no yx: ".ki$C;
        if (my $J = s&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
        T.not = 1 if C.sc.not eq '1';
        # G&hup,
    O 2:
        C.y.A = $A;
        #return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of', 'js') {
            if (my $Wt = C.sc.>$W) {
                my $W = $W eq 'js' ? 'javascript' : $W;
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        
        # indexed ground within universals
        if (my $J = !s&noii && s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.ii; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scii D.t no in";
                    while ($S) {
                        a&swim.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W";
                        $S = S.y.next;
                    }
                    $D = D.y.over
                }
            }
        }
        
        if (my $sel = 1s&sels) {
            while (my ($k,$els) = each %$sel) {
                exists C.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    A&el eq $el || A&el eq '2' && $el eq '1' ||
                    $el eq '5' && A&el < 4 || next;
                    $do->($A,$C,$G,$T);
                }
            }
        }
    
    O 5:
        return unless A.ii.S;
        local A.cv = 0.4999;
        local A.ov = 0.5999;
        G&throat,'S';
    
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv, 
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
Koul: | # clarify changes to string
    u a
    # might be making Lines in here?
    # might be doing some C's whole picture (1) and lv diff (7)
    #   as two Cs? make encoding instructions pop in
    K 1:
        A&from = shift @$s; # us
        A&s = $C = G&hup,A&from;
        my $l = a&l = C.y.l || die "No KC yl: ".ki$C;
        my $x = a&x = l.y.x || die "KCyl no yx: ".ki$l;
        if (my $J = ls&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        my $l = a&l;
        delete c&Jo if ls&W || ls&qz;
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = a&J || die "No sJ for Jo K: ".ki$l;
            my $x = a&x;
            my $lo = xc&Jo;
            if ($lo ne c&Jo) {
                my $s = a&ys;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = xc&Jowil || 1;
                my $conti = sc&imp eq xc&Joimp && $lv eq xc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                xc&Jolv = $lv;
                xc&Joimp = sc&imp;
                xc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                delete c&s if Js&tv; # has inside
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
    # set Js&Kels.sending.3 = $s to G&h,$cb for sc.sendings el3ing
    K 3:
        my $l = a&l;
        my $r = l.y.r || die "no lyr";
        rc&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            my $up = l.y.up;
            if ($up && up.y.cv eq 0.9) {
            while (my ($k,$els) = each %$sel) {
                exists l.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    rc&el eq $el || rc&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
            }
        }
    K 4:
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE' && $nk ne 'sc';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
        
    D 2:
        # reverse it
    

