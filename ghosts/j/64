SelfConsciousness: | # your fish brain
    n FishBrain
    
    n Houp
    n Koul

FishBrain: | # beginning middle and end superimposed on J's state
    u i
    s: %acgt:c sc
        sayyl "oscillating!";
        $A = G&A,s=>0=>$c,$sc;
        # s could order a particular ground
        
        # ground has been completed, pos revamping sleepybits from drain
        my $g = A.ground || die "noground";
             gs&J eq A.1 || die "ground sJ not A1";
        my $ch = g.t;
        
        # ground -> drain
        my $d = 1s&drains.>$ch = G&hup,$g;
        ds&z = [@{ds&z}];
        
        # brain is ongoing, one per ground
        A&s = $C = 1s&brains.>$ch ||= G&Ct,[$ch=>1=>{}=>{J=>A.1}];
        
        # o in - to map the drain and OC the changes
        #   climbing in/next/z to produce OC feedable clones,
        # < C that are attributes it keeps/diffs but doesn't OC
        # the oinD is origin in drain
        # the oinC is our copy of it
        # the OC is another copy, which the oiD gets
        # < see enough interior of Js with map function
        #   o being FactorEase's backend, ideally
        
        # where we'd want to forget $d, the drain itself...
        my $o = A&in = G&o,$d,{liveon=>$C,t=>'in',yoff=>'OC'};
        # Core is changes
        A&OCs = [map { G&A,O=>0=>_.c,_.sc } @{os&Core}];
        
        my $r = 1s&root || die "how to hold many";
        $r = r.y.OC || die "root didn't OC";
        # O - only changes and their parents
        # < tug for .1 progress
        # < with an A=Os for all
        G&A,$_,8,{r=>$r} for @{A&OCs};
        
        # < wOrms, in-wormholes
        #   where thing is our part of some sharing of truth
        # is one-ish with:
        # < waves of language solvents
        # all basically generating ongoing job lists
        # usually pumping so-classified things through some filter
        # everything moving comes classified as some elvis
        #   so s&of encodings happen now
        #   and W doings on other hosts emit through Op
        #   W doing might be updating it on the news...
        
        # another use for o be the upping/downing of indexes
        # amongst sources that may not all be awake.
        
        # Cora is Core with unchanged stuff too,
        #   which will have its last awake .y.OC
        #   slight possibility of zombies if you topy&OCs&qua++
        #     will news themselves until oinD quashes changes
        
        # the I, injected into r.y.tv, so z clobbers it,
        #   be releasing local modulation not absolute truth
        Rw PostO $o $r;
        # we shall make s&I from what looks like it in K
        
        # put this stuff in the idea of itself
        rs&z = [ grep{ $_ ne $r } map{ _.y.OC } @{os&Cora} ];
        
        # o ou - to finalise ourselves and OK changes
        $o = A&ut = G&o,$r,{liveon=>$C,t=>'ut',yoff=>'KC',gen=>'lv'};
        my @K = map { G&A,K=>0=>_.c,_.sc } @{os&Core};
        $r = r.y.KC || die "root OC didn't KC";
        
        # K - only changes and their parents
        #   <6 becomes things for s&top, s&tv, etc
        #   >6 comps for writing Lines
        # < an A=Ks would map out AWritering
        #     pointing to objects already on the ground
        G&A,$_,8,{r=>$r} for @K;
        
        Rw PostK $o $r;
        
        # hangs brain up on the J
        1s&s = $C;
        
        A.1.sc.>$_ = C.sc.$_ || undef for qw'I tv top tw';
        # top is 9's KC
        
        # -> W
        
    # watching the K diverge as a way to get input is interesting
    # self servers (Dogu/-lookin eg) wants to see out-changes as in-changes
PostK: |
    my @aK = map { _.y.KA || die "NoOC: ".ki$_ } @{os&Cora};
    
    # scoop up I every time
    # clobber here into the many I cv or different positions on the thing,
    # even with same cv, from around this vector, someday
    s&I = {map { _.t=>$_ } grep { _c&W } map { _c&s } @aK};
    
    # deletes I unless values I
    delete s&I unless values %{s&I};
    
    s&tv = r.y.tv;
    s&top = $r;
    s&tw = r.y.tw;
    
PostO: | # make O's a&swim elvises happen, feed into r.y.tv
    # all current O, even asleep/A&el=8
    my @aO = map { _.y.OA || die "NoOC: ".ki$_ } @{os&Cora};
    
    # take Os&swom (via J), Os&swim (from C) through concludoors
    # in usual yt order, may be dupey,
    # to clobber in o ut
    # < the elvising (of,javascript) to have more sense
    #   about whether we should already o things to it,
    #   depending on weight...
    # - but code might appreciate having competitors compiled?
    
    # swom things are lower priority than swim things
    for my $O (@aO) {
        my $c = Oc&s;
        my $swom = Os&swom || next;
        each W,Wt,Wcv,Dt,Dcv,D $swom {
            Os&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv ||= $D;
        }}}}}
    }
    
    for my $O (@aO) {
        my $c = Oc&s;
        my $swim = Os&swim || next;
        each W,Wt,Wcv,Dt,Dcv,D $swim {
            if (my $i = a&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv ) {
                my $d = i.c.s;
                saygr G&sn ." c.t c.y.cv overs $Wt/$Dt $Dcv from d.t d.y.cv";
            }
            a&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv = $O;
        }}}}}
    }
    
    each W,Wt,Wcv,Dtv a&swim {
        # sleep based on each set's sources being stable
        # < stuff hoisted via J is already encoded
        my $move = 1;
        if (my $his = s&swim.>$W.>$Wt.>$Wcv ) {
            $move--;
            each Dt,Dcv,O $Dtv {
                Oc&el ne '8' && $move++;
                my $o = $his.>$Dt.>$Dcv;
                $o && oc&s.t eq Oc&s.t 
                && oc&s.y.cv eq Oc&s.y.cv || $move++;
            }}
            each Dt,Dcv,o $his {
                my $O = $Dtv.>$Dt.>$Dcv;
                $o && oc&s.t eq Oc&s.t 
                && oc&s.y.cv eq Oc&s.y.cv || $move++;
            }}
        }
        unless ($move) {
            a&swum.>$Wcv.>$Wt = s&swum.>$Wcv.>$Wt || die "no swum $Wcv $Wt";
            sayre G&sn ."Seems to be the same... $W $Wt $Wcv";
            # elvis checks his stuff is still at the hut
        }
        else {
            my $z = [];
            for my $O (@aO) {
                my $Dtv = Os&swim && Os&swim.>$W.>$Wt.>$Wcv || next;
                # random order here, o ut will sort
                each Dt,Dcv,D $Dtv {
                    # D pushed thing, clone if C
                    $D = G&hup,$D if $D eq Oc&s;
                    push @$z, $D;
                }}
            }
            die "Nothing ordered $W $Wt $Wcv?" if !@$z;
            # todo elvising
            my $w = a&We.>$Wcv.>$Wt;
            my $W = a&We.>$Wcv.>$Wt = G&Ct,[$Wt=>$Wcv,{W=>$W}];
            Wc&nogro = 1; # ?
            my $e = Wc&e = G&Ct,[Swim=>3];
            ec&z = $z;
            
            $w && die "We already: ".ki($w)."\nvs: ".ki$c;
        }
    }
    
    # extra z goes after/over OCs
    # sort what to do could get smaller if we go by aO
    for my $Wcv (sort keys %{a&We}) {
        my $Wts = a&We.>$Wcv;
        for my $Wt (sort keys %$Wts) {
            my $W = $Wts.>$Wt;
            # sends to the particular language workshop
            # nomem = its J (of,javascript) won't hang around
            $W = G&elph,\'nomem',$W;
            # makes a cW=of
            my $D = G&Ct,[$Wt=>$Wcv,{W=>Ws&W}];
            # compilations come back
            Ds&z = Ws&z;
            Ds&z ||= Wc&e.c.z;
            Ds&z || sayre "W no z ".ki$W;
            
            a&swum.>$Wcv.>$Wt = $D;
        }
    }
    
    # add them under root 9
    # z clobber them...
    each Wcv,Wt,D a&swum {
        my $w = r.y.tv.>$Wt.>$Wcv;
        r.y.tv.>$Wt.>$Wcv = $D;
        1 && saygr G&sn ." D: ".ki($D)."\n\n $Wt $Wcv probably swum over by ".ki$w;
    }}
    
    # live on the live on-er
    s&swum = a&swum;
    s&swim = a&swim;
    # stuff gets noticed in K
    
Houp: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        # is OC
        if (my $J = s&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
        
        my $o = C.y.A;
        o.t eq 'o' || die "No oA: ".ki $o;
        
        A&el = oc&el;
        # A&r = root.y.OC
        
        # put O
        C.y.OA = $A;
        
        # < more recur?
        
        
        # < making this stick...
        T.not = 1 if C.sc.not eq '1';
        
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of', 'js') {
            if (my $Wt = C.sc.>$W) {
                my $W = $W eq 'js' ? 'javascript' : $W;
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        
        # indexed ground within universals
        if (my $J = !s&noii && s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.I; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scI D.t no in";
                    while ($S) {
                        a&swom.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W";
                        $S = S.y.next;
                    }
                    $D = D.y.over; # the next ii?
                }
            }
        }
        
        # do when el is so
        if (my $sel = 1s&sels) {
            # limited to those under 9?
            $sel = {} unless C.y.up eq A&r;
            each k,els $sel {
                exists C.sc.>$k || next;
                each el,do $els {
                    A&el eq $el || A&el eq '2' && $el eq '1' ||
                    $el eq '5' && A&el < 4 || next;
                    G&h,$do;
                }
            }
        }
    
    # S leads to Style
    O 5:
        return unless A.I.S;
        local A.cv = 0.4999;
        local A.ov = 0.5999;
        G&throat,'S';
    
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv,
    # Scuttle
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
Koul: | # clarify changes to string
    u a
    # might be making Lines in here?
    # might be doing some C's whole picture (1) and lv diff (7)
    #   as two Cs? make encoding instructions pop in
    K 1:
        # is KC
        if (my $J = s&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
        
        my $o = C.y.A;
        o.t eq 'o' || die "No oA: ".ki $o;
        # A&r = root.y.KC
        A&el = oc&el;
        # keep an unsquished version
        a&l = C.y.C;
        # last K
        A&K = C.y.KA if C.y.KA;
        # has continual bit of C
        # < or name g, share with O?
        a&n = A&K.sc.l || {};
        # put K
        C.y.KA = $A;
        
        # < making this stick...
        T.not = 1 if C.sc.not eq '1';
        
        
    
    # a&n continues as long as C doesn't move
    # a&l is the original C we are squishing
    
    # c&Jo = J version
    K 2:
        my $l = a&l;
        my $n = a&n;
        
        delete c&Jo if s&W || s&qz;
        
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = s&J || die "No sJ for Jo K: ".ki$l;
            # < have a whole C for a version label
            #   c imp,wil,mat etc versioning
            #   sc forms
            my $lo = nc&Jo;
            if ($lo ne c&Jo) {
                # < pick the right page
                my $s = Js&s;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = nc&Jowil || 1;
                my $conti = sc&imp eq nc&Joimp && $lv eq nc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                nc&Jolv = $lv;
                nc&Joimp = sc&imp;
                nc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                # quiet for insides, should remain with qs
                delete c&s if Js&tv;
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
    # set Js&Kels.sending.3 = $s to G&h,$cb for sc.sendings el3ing
    K 3:
        my $l = a&l;
        A&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            # limited to those under 9?
            $sel = {} unless l.y.up eq A&r;
            each k,els $sel {
                exists l.sc.>$k || next;
                each el,do $els {
                    A&el eq $el || A&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
        }
    K 4:
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE' && $nk ne 'sc';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
        

