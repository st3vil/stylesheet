SelfConsciousness: | # your fish brain
    n FishBrain
    
    n Houp
    n Koul
FishBrain: | # beginning middle and end superimposed on J's state
    u i
    s: %acgt:c sc
        sayyl "oscillating!";
        $A = G&A,s=>0=>$c,$sc
        # s could order a particular ground
        
        # ground has been completed, pos revamping sleepybits from drain
        my $g = A.ground || die "noground";
             gs&J eq A.1 || die "ground sJ not A1";
        my $ch = g.t;
        
        # ground -> drain
        my $d = 1s&drains.>$ch = G&hup,$g;
        ds&z = [@{ds&z}];
        
        # brain is ongoing, one per ground
        A&s = $C = 1s&brains.>$ch ||= G&Ct,[$ch=>1=>{}=>{J=>A.1};
        
        # o in - to map the drain and OC the changes
        #   climbing in/next/z to produce OC feedable clones,
        #   C that are attributes it keeps/diffs but doesn't OC
        # the oinD is origin in drain
        # the oinC is our copy of it
        # the OC is another copy, which the oiD gets
        
        # where we'd want to forget $d, the drain itself...
        my $o = A&in = G&o,$d,{liveon=>$C,t=>'in',yoff=>'OC'};
        # Core is changes
        my @O = map { G&A,O=>2=>_.c,_.sc } @{os&Core};
        
        # O - only changes and their parents
        # < tug for .1 progress
        # < with an A=Os for all
        G&A,$_,8 for @O;
        
        # < wOrms, in-wormholes
        #   where thing is our part of some sharing of truth
        # is one-ish with:
        # < waves of language solvents
        # all basically generating ongoing job lists
        # usually pumping so-classified things through some filter
        # everything moving comes classified as some elvis
        #   so s&of encodings happen now
        #   and W doings on other hosts emit through Op
        #   W doing might be updating it on the news...
        
        # another use for o be the upping/downing of indexes
        # amongst sources that may not all be awake.
        
        # Cora is Core with unchanged stuff too,
        #   which will have its last awake .y.OC
        #   slight possibility of zombies if you topy&OCs&qua++
        #     will news themselves until oinD quashes changes
        my $r = 1s&root || die "how to hold many";
        $r = r.y.OC || die "root didn't OC";
        # put this stuff in the idea of itself
        rs&z = [ grep{ $_ ne $r } map{ _.y.OC } @{os&Cora} ];
        
        # o ou - to finalise ourselves and OK changes
        $o = A&ut = G&o,$r,{liveon=>$C,t=>'ut'};
        my @K = map { G&A,K=>2=>_.c,_.sc } @{os&Core};
        
        # K - only changes and their parents
        #   <6 becomes things for s&top, s&tv, etc
        #   >6 comps for writing Lines
        # < an A=Ks would map out AWritering
        #     pointing to objects already on the ground
        G&A,$_,8 for @K;
        
        # pick up on r.y.OK and jump down Wormhole
        # -> W
    #     watching the K diverge as a way to get input is interesting
    # self servers (Dogu/-lookin eg) wants to see out-changes as in-changes
SirKill: | # crawl datastructure
    u i
    o:
        saygr "Do o: ".ki $s;
        $A = G&A,o=>0=>$c,$sc;
        my $on = A&liveon || die "live where";
        $C = $on.>A&t ||= {};
        my $isC = &C{
            defined C.t && C.y && C.c && C.sc
        };
        # always a C
        # loop limbs$
        my @L = (map{ _.y = $_ } {t=>'o',up=>$C,c=>{s=>$s},sc=>{}});
        my @R;
        # builds up from z/in/tw/tv
        while (@L || @R) {
            # give these A/C to T for blowingup locator
            @L = reverse @R if !@L;
            my $A = shift(@L);
            my $C = A&s;
            unless (A&last) { #c last reoccurs
                # but first
                $isC->($C) || die "notC: ".ki$C;
                A&ipi ||= 0; # increment per child
                if (A&comp eq 'tv') {
                    A&last = ups&tv.>C.t.>C.y.cv || {};
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                else {
                    A&ext || die "how to file";
                    A&last = ups&Tv.>A&ext || {};
                }
                # for "attach to the above"
                a&tv = {}; # t/cv join
                a&Tv = {}; # nk/gk join
                # < different namespacing? crunch function?
            }
            
            unless (A&insides) { #c insides
                my $st = {}; # same inside may appear many places
                # Scuttle should tell ways in
                # < checking that everything is found via each way
                #   mostly it will be filling up the connection of
                #   chucked together any way bits
                # < should know all y/c/sc that look C or [C+]
                my @at;
                each nk,gk,v $C {
                    next if 'y'eq$nk; # distracto or handled
                    if (ref $v eq 'HASH') {
                        $isC->($v) || next;
                        push @at, ["$nk $gk",[$v]];
                    }
                    elsif (ref $v eq 'ARRAY') {
                        next if $nk eq 'sc' && $gk eq 'z'; # handled
                        next unless @$v == grep {
                            ref $_ eq 'HASH' && $isC->($_) } @$v;
                        push @at, ["$nk $gk",$v];
                    }
                    else {
                    }
                }
                A&insides = [ # A inner
                    map {
                        _c&ind = A&ind+1;
                        _.y = $_
                    }
                    map {
                        my ($t,$z) = $_->[0];
                        map {
                            _c&ext = $t;
                            _c&zip = A&ipi++;
                            _c&ind = A&ind+1;
                            my $s = "_c&s";
                            push @{$st.>$s ||= []}, $_;
                            _.y = $_;
                        } map {
                            {t=>'o',up=>$A,c=>{s=>$_},sc=>{}}
                        } @$z
                    }
                    @at, # attributes we can see
                    # these all mean "inside", are in tv competition:
                    map { $_->[2] = {comp=>'tv'} }
                    grep{defined}
                    (C.y.in ? do {
                        @S = my $S = C.y.in;
                        push @S, $S while $S = S.y.next;
                        ['y in', \@S]
                    } : undef),
                    (C.y.tw ? do {
                        ['y tw',[values %{C.y.tw}]]
                    } : undef),
                    (C.y.tv ? do {
                        ['y tv',[map{values %$_} values %{C.y.tv}]]
                    } : undef),
                    (C.sc.z ? do {
                        ['sc z',C.sc.z]
                    } : undef),
                ];
                # check $st for duplicate s
                each sz $st {
                    @$z > 1 || next;
                    my @z = @$z;
                    @$z = pop @z;
                    A&Atrm.>$_ ++ for @z;
                }
                @{A&insides} = grep { !A&Atrm.>$_ } @{A&insides}
                    if A&Atrm;
                
                # so we know which values are things
                #   with their own differencing A
                A&ways_in = {};
                push @{A&ways_in.>_c&ext ||= []}, $_ for @{insides};
                
                # attach to the above, possibly many
                if (A&comp eq 'tv') {
                    push @{ups&tv.>C.t.>C.y.cv ||= []}, $A;
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                else {
                    A&ext || die "how to file";
                    push @{ups&Tv.>A&ext ||= []}, $A;
                }
                
                push @L, @{A&insides};
                push @R, $A;
                next;
            }
            
            unless (A&diff) { #c difference in reverse
                # last A, compare a&ng
                my $d = A&last;
                # to have Ds&neg - changed values nk/gk = q
                # and Ds&pos - changed things index/$index = v
                my $D = A&diff = {};
                # t will be nexted by Bablar
                
                # the values change Ds&neg nk/gk
                each nk,gk,v $C {
                    # not things that will change superficially
                    next if $nk eq 'y';
                    next if A&ways_in->{"$nk $gk"};
                    
                    ds&ng.>$nk.>$gk = $v;
                    if (ds&ng.>$nk.>$gk ne $v) {
                        my $q = Ds&neg.>$nk.>$gk = {t=>$gk,c=>{s=>$v}};
                        qc&new = 1 if !exists ds&ng.>$nk.>$gk;
                        qc&was = ds&ng.>$nk.>$gk if !qc&new;
                    }
                }
                each nk,gk,v ds&ng {
                    exists $C.>$nk.>$gk && next;
                    Ds&neg.>$nk.>$gk = {t=>$gk,c=>{was=>$v}};
                };
                
                # the yin change
                # tv and Tv are indexes to one the many falls against here
                each t,cv,v a&tv {
                    push @{a&many.tv.>$t.>$cv ||= []}, shift @$v
                        while @$v > 1;
                    $v = shift @$v;
                    a&tv.>$t.>$cv = $v;
                    vc&el eq '8' && next;
                    Ds&pos.tv.>$t.>$cv = $v;
                }
                each t,cv,v ds&tv {
                    a&tv.>$t.>$cv && next;
                    vc&el eq '9' && next;
                    vc&el = '9';
                    a&tv.>$t.>$cv = # remover to sort in?
                    Ds&pos.tv.>$t.>$cv = $v;
                }
                
                # values that were things
                each ext,v a&Tv {
                    push @{a&many.Tv.>$ext ||= []}, shift @$v
                        while @$v > 1;
                    $v = shift @$v;
                    a&Tv.>$ext = $v;
                    vc&el eq '8' && next;
                    # sets the value
                    Ds&neg.>$nk.>$gk = {t=>$gk,c=>{s=>$v}};
                }
                each ext,v ds&Tv {
                    a&Tv.>$ext && next;
                    my ($nk,$gk,$no) = split ' ', $ext;
                    $nk && $gk && !$no || die "Much ext: $ext";
                    # deletes the value
                    Ds&neg.>$nk.>$gk = {t=>$gk,c=>{was=>$v}};
                }
                
                unless (Ds&neg || Ds&pos) {
                    # resume/copy
                    A&el = '8';
                    c&s = ds&s;
                }
                else {
                    $C = c&s = {t=>C.t,y=>{cv=>C.y.cv}};
                    # put everything there
                    each nk,gk,v a&ng {
                        $C.>$nk.>$gk = $v
                    }
                    each nk,gk,v a&Tv {
                        $C.>$nk.>$gk = $v
                    }
                }
                
                push @R, $A;
                next;
            }
            
        }
        # going innexz (following y.in/y.next and s&z)
        # leaves sayable data dump,
        # 
        # things cloned and wired as they were
        
        @{os&Core} = # everything changed
        @{os&Cora} = # everything
Houp: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        my $D = A&s;
        # y:
        #   oinD - in drain
        #   oinC - oinD's copy via o ($D now)
        #   OC - the whole new this to run through oscillation
        # so D knows the OC it turned into
        $C =
        A&s =
        D.y.OC =
        C.y.OC = G&hup,A&s;
        # < using o to do ^ that for us, to preserve all wiring
        
        # so D knows nothing about its being photographed?
        # C here is OC, OC.y.oinD = D, OC.y.oinC = D's copy via o
        # and D's copy is C.y.oiC
        
        
        
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = $C = G&hup,A&from;
        # C is (was) the l from zip
        my $x = a&x = C.y.x || die "OC no yx: ".ki$C;
        if (my $J = s&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
        T.not = 1 if C.sc.not eq '1';
        # G&hup,
    O 2:
        C.y.A = $A;
        #return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of', 'js') {
            if (my $Wt = C.sc.>$W) {
                my $W = $W eq 'js' ? 'javascript' : $W;
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        
        # indexed ground within universals
        if (my $J = !s&noii && s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.ii; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scii D.t no in";
                    while ($S) {
                        a&swim.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W";
                        $S = S.y.next;
                    }
                    $D = D.y.over
                }
            }
        }
        
        if (my $sel = 1s&sels) {
            while (my ($k,$els) = each %$sel) {
                exists C.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    A&el eq $el || A&el eq '2' && $el eq '1' ||
                    $el eq '5' && A&el < 4 || next;
                    $do->($A,$C,$G,$T);
                }
            }
        }
    
    O 5:
        return unless A.ii.S;
        local A.cv = 0.4999;
        local A.ov = 0.5999;
        G&throat,'S';
    
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv, 
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
Koul: | # clarify changes to string
    u a
    # might be making Lines in here?
    # might be doing some C's whole picture (1) and lv diff (7)
    #   as two Cs? make encoding instructions pop in
    K 1:
        A&from = shift @$s; # us
        A&s = $C = G&hup,A&from;
        my $l = a&l = C.y.l || die "No KC yl: ".ki$C;
        my $x = a&x = l.y.x || die "KCyl no yx: ".ki$l;
        if (my $J = ls&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        my $l = a&l;
        delete c&Jo if ls&W || ls&qz;
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = a&J || die "No sJ for Jo K: ".ki$l;
            my $x = a&x;
            my $lo = xc&Jo;
            if ($lo ne c&Jo) {
                my $s = a&ys;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = xc&Jowil || 1;
                my $conti = sc&imp eq xc&Joimp && $lv eq xc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                xc&Jolv = $lv;
                xc&Joimp = sc&imp;
                xc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                delete c&s if Js&tv; # has inside
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
    # set Js&Kels.sending.3 = $s to G&h,$cb for sc.sendings el3ing
    K 3:
        my $l = a&l;
        my $r = l.y.r || die "no lyr";
        rc&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            my $up = l.y.up;
            if ($up && up.y.cv eq 0.9) {
            while (my ($k,$els) = each %$sel) {
                exists l.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    rc&el eq $el || rc&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
            }
        }
    K 4:
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE' && $nk ne 'sc';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
        
    D 2:
        # reverse it
    

