Sound: |
    # arecord -f dat -D hw:3,0 eo.wav

    # mix down to mono:
    # mplayer     -ao pcm:fast:waveheader:file=output.wav     -af pan=1:0.5:0.5     -vo null -vc null     onecha.wav
    
    # into flac:
    # arecord -f dat -D hw:3,0 | flac - -o MorganSophie9.flac
    
    # to 19twok ogg:
    # $arecording | oggenc - -q 6 -r -o MorganSophie4.ogg
    
    # for spectrograms:
    # apt-get install spek
    sayyl "Your:\t". sjson([gab=>"zoy\tblab"])
    
    # and find keys:
    # xmodmap -pke | less
    # 232
    # xmodmap -e "keycode 232 ="
    
    # and webcam:
    # ffmpeg -f video4linux2 -s 320x240 -t 3 -i /dev/video0 out.mpg
ejc: | # set Jc.>c.t = ec&us.s
    J.c.>c.t = ec&us.s || 1;
Lis: | # speculate on Gigs
    #4s&reGt = G.t; # same nameity
    Rw GiveTime;
    Gc&Glan = 'Elan' if G.d;
    # Lst W 5s and show/organise updatables
    Rw Tiot;
    Rw IET;
    # push soft and hard,
    #   soft to stick the update button down
    # knows about some Co
    
    # FactorEase - assemblages
    my $ts = Rw fi/sembla bay g add;
    
    my $gd = "Jc&bay/Jc&g";
    
    n $gd=>-lis=>{s=>$gd,add=>delete(Jc&add)||'NutMachine'}
    
    $ts->();
    
    
fi/sembla: | # dropdown selectable (cultivatable?) location/path-shaped options
    my $M = [];
    my $i = 5;
    for (@{ar.m}) {
        my $d =
        m $_=>($i++ / 100)
        # set from C to J, and defaulty
        J.c.>$_ = C.c.>$_ if exists C.c.>$_;
        dc&s = J.c.>$_ ||=
            $_ eq 'bay' ? Gc&bay || die "nobay" :
            $_ eq 'g' ? 'ju'
            : undef;
        my $fit = "fi_$_";
        my $def = J.sc.>$fit if exists J.sc.>$fit;
        ds&sel = join'-',grep{$_} (
            $def ? @$def :
            $_ eq 'g' ? split("\n",''.`ls -1ct Jc&bay`) :
            $_ eq 'add' ? qw"HaMachine Stylehut TheStatics" :
            ''), '?';
        if (defined dc&s) {
            dc&s = "dc&s/";
        }
        else {
            dc&s = ":".d.t;
            ds&hs = 398;
            ds&fs = 6;
        }
        ds&ma = 0.1;
        ds&fs ||= 8;
        ds&dos = 'listype';
        ds&Jc = 1;
    }
    n $_ for @$M;
    
    # time the whole thing - can cause feedback
    #   if it is aware of its own motion
    my $eh = hitime();
    return &{
        my $ts = hitime() - $eh;
        my $delta = Rw mass $s:ts;

        n tripes=>o4=>$delta,'fs:6,hs:399'
    };
    
listype: | # type commands to Lis
    my $s = ec&us.s;
    if (my $t = cs&Jc) {
        $t = c.t if $t eq '1';
        J.c.>$t = $s;
    }
    else {
        die "listype where ".ki $c;
    }
pi/lis: | # for a given s=$gd (GG/G directory for W)
    my $gd = c&gd || c&s;
    Jc&ETmode = 2;
    
    n lies=>-lise_1=>"$gd/*/5",'%qz,fs'
    
    if (!G&op) {
        my @f = grep {length} split "\n", ''.`ls -1ct $gd` if -d $gd;
        n nthing=>11=>"nothing".(@f && " but:"),dis
        @f &&
        n but=>12=>join("\n",@f),'fs:6,hs:384,lh:0.7'
        #return;
    }
    #n lies=>-lies_11=>"$gd/*/5",'%qz'
    
    
    
    # 2: lay out web of dependencies
    n waved=>-jackpole_2=>{s=>T.op},'%qz'
    
    # 3: see updatables
    n edge=>-respec_3=>{s=>T.op},'%qz,open'
    
    # 4: pile with desire
    # the action:
    my $act = [Gig=>[$gd=>-Gdo=>{}]];
    my $c = {};
    # to start tops:
    c.add = c&add if c&add;
    
    n pile=>-lenot_4=>{s=>T.op,%$c},{runs=>$act}
    
    # next things take some pi as input
    # and continue/redo branches of thinking
    # until some action comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down
    
    # < get only changed, redome parts
    # < know history to W
    # < sets most-W-owning, ordering
    # < more than one parent, 
    
    
Gig: | # do Gig - initiates W to store somewhere
    Rw Tiot;
    # as G?
    # or mere storage inheritor
    
    # to be, for code stitch/branch
    #   G ionvolk.
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    # awareness of G gou in G gou is feedback
    
    =pod
    
    super
    soft
    ''
    hard
    far
    
    with a why exuder (female) and death circuitty
    terminal input, flying hold (tripany);
    the place says T
    
    TODO
    
    the code has lost its 
    catch it in the throat maker
    
    =cut
    
    Js&ein.pi.Gdo.sMJ = &sMJjeTC{
        G&give,Budge=>[Jigzen=>''=>{s=>$e}];
        #return
        # e.t = 'bay/via'
        # ec&s = 'commit message'
        # es&z = [W items]
        # do them, thaw/sleep the non-itemic
        m $e
    };
    S
    # flush the queue of -Gdo
    my @t = @{Js&M||=[]};
    @{Js&M} = ();
    if (@t) {
        Js&results = [];
        
        for my $W (@t) {
            my ($bay,$g) = split '/', W.t, 2;
            sayyl "J.t: ".ki $W;
            $bay eq Gc&bay || die "bay not our bay? Gc&bay / W.t";

            # set in-G branch (g)
            local 5s&stores = [
                G&e,$g=>-mine=>{}=>'otherwise:thaw,if:A-gigging,nif:A-clusping' ,
                @{5s&stores},
            ];
            
            # the many
            my @todo; # W steps
            my $tw; # which W to sleep
            my $aw; # which W to awake everything under
            for my $t (@{Ws&z}) {
                push @todo, $t;
                $tw.>t.t = $t;
                # to regenerate already J, Ang
                delete 4s&Jtv.>t.t;
            }
            undef $tw if Ws&everything;
            $aw.>$_ ++ for grep{$_} split ',', Ws&everything_under;
            
            my $l = [];
            sayyl "=","= La $bay $g gets ".ki(Ws&z),"=";
            
            # - put wrapper on any W
            local 4c&foursleep_W_cb = &acgt{
                return if A.clusping;
                my $ay = $A;
                my @A = $ay;
                push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
                my $Ats = join' ',reverse map{_.t}@A;
                push @$l, G&aC,$C . "\t" . $Ats;

                if ($aw.>C.t) {
                    1 && sayyl "Gigeverything under C.t";
                    A.gigeverything = 1;
                }

                if (!$tw || delete($tw.>C.t ) || A.gigeverything) {
                    A&want.wake = 6;
                }
            };
            
            # is a depth first hierarchy of things to get,
            # assuming one branch/toplevel
            # < become sleepy if ha same,
            #     for a G N to do, wake fronts...
            for my $t (reverse @todo) {
                $tw && !$tw.>t.t && 
                    saygr("J.t: Already got to t.t")
                    && next;
                #next unless $t =~ /^P/;
                my $eh = hitime();
                {
                local A.gigging = $A;
                my $c =
                n $t
                # so we can web ourselves, will cancel Jing if too early
                # do in a dome marked "other"
                c.sc.not = 1;
                }
                my $tr = T.op;

                my $ts = hitime() - $eh;
                my $delta = Rw mass $s:ts;
                my @bunch = G&op;
                @bunch = "massive lot of things" if T.op.sc.massive;
                my @l = (T.op,"took: $delta");
                
                my $M = [];
                m tr.t=>-od=>{dl=>2,s=>\@l}
                push @{Js&results}, @$M;
            }
        }
    }
    
    m $_ for reverse @{Js&results||[]};
    
    undef $l; # untrip
    saybl "J.t Done!";
    #$not && exit; # dont hang around with all this memory
Jig: | # initiates W to store somewhere
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # to be, for code stitch/branch
    #   G ionvolk.
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    # awareness of G gou in G gou is feedback
    
    =pod
    
    super
    soft
    ''
    hard
    far
    
    with a why exuder (female) and death circuitty
    terminal input, flying hold (tripany);
    the place says T
    
    TODO
    
    the code has lost its 
    catch it in the throat maker
    
    =cut
    
    Js&ein.pi.Gdo.sMJ = &sMJjeTC{
        #G&give,Budge=>[Jigzen=>''=>{s=>$e}];
        # e.t = 'bay/via'
        # ec&s = 'commit message'
        # es&z = [W items]
        # do them, T.H/impart the non-itemic
        m $e
    };
    S
    # flush the queue of -Gdo
    my @t = @{Js&M||[]};
    @{Js&M} = ();
    @t || return
        n no=>1=>"Nothing doing (send -Gdo from Lize)"
    die "many Gdo" if @t > 1;
    
    my @todo; # W steps
    my $tw; # which W to sleep
    my $aw; # which W to awake everything under
    for my $y (@t) {
        my ($bay,$gd) = y.t =~ /^(G.c.bay)\/(.+)$/;
        $bay || die "bay not our bay? G.c.bay / y.t";
        A.7.t = $gd; # or branch
        A.6.t = $gd;
        for my $t (@{ys&z}) {
            push @todo, $t;
            $tw.>t.t = $t;
            # to regenerate already J, Ang
            delete 4s&Jtv.>t.t;
        }
        undef $tw if ys&everything;
        $aw.>$_ ++ for grep{$_} split ',', ys&everything_under;
    }
    
    
    
    # - put wrapper on any W
    my $l = [];
    my @wake;
    G&elph,Trips=>[tripany=>$_] for &acgt{
        return unless $l;
        # avoid W for the mind or the oscillator
        # deals with land itself
        return if A.clusping || A.up.t =~ /^(u|s)$/;
        # nor the Storage or any other agents
        return if C.t =~ /^(Stro)$/;
        
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        push @$l, G&aC,$C . "\t" . $Ats;
        
        if ($aw.>C.t) {
            # wake everything under here
            push @wake, $A;
            T.H = 0;
        }
        elsif (grep { Ac&sip =~ /^_c&sip/ } @wake) {
            # is subnetically within an all-awaker
            1 && saygr " --- C.t awake within";
            T.H = 0;
        }
        elsif ($tw && !$tw.>C.t) {
            #sayre "Uncared C.t";
            my $f = G&Locate_read,C.t;
            my $d = G&Beach,"$f/1" if $f;
            if ($d) {
                ($d) = @$d;
                c&pretend = $d;
                # get Hosthing's thawJ to do the c&parts, T.Z.7ing
                # doesn't seem to work directly from here (early?)
                T.H = 1;
            }
            else {
                #sayre "Unknown C.t";
                T.H = 0;
            }
        }
        
        # before method wrapper, returning $d to c&phind
        c&phin = 'Experience';
    };
    
    # - the Jig invokes Experience/writing into bay
    # supplement that with a linier storage format
    Rw AWriter;
    my $not = 1;
    
    for my $t (@todo) {
        #next unless $t =~ /^P/;
        my $eh = hitime();
        n $t
        my $tr = T.op;

        my $ts = hitime() - $eh;
        my $delta = Rw mass $s:ts;
        my @bunch = G&op;
        @bunch = "massive lot of things" if T.op.sc.massive;
        my @l = ("took: $delta", @bunch );
        $not ||
        n tr.t=>-od=>{dl=>2,s=>\@l}
    }
    # the -od must overwrite the W so we can web ourselves
    #@$M = reverse @$M;
    undef $l; # untrip
    saybl "Done!";
    $not && exit; # dont hang around with all this memory
Lize: | # watch ghost/wormhole watcher TODO
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    Jc&save = 'W';
    Rw Impsev;
    =head DESCRIPTION
    
    see and affect stylehouse openness/movingness
    
    =pod TODO
    
    have AWriter copy some 9 sc (in 4) to 5
        so eg the s&massive LeMachine never gets mixed
        since startups can do it quickly
    
    Scuttle hops attributes across borders
      needs two I, for the gk and the border
    
    have many piles, one unified field of ways to watch
      all change should start in some way
    
    W starting -tin
    
    W ordering
    
    fix button - smooth out the edge
    
    ghost editor sync/tie down the fix button
    n Besider
    see latest them
    
    =cut
    
    Rw AWriter;
    
    Jc&bay = c&bay if c&bay;
    my $bay = Jc&bay || Gc&bay || die "No bay";
    Jc&g = c&g if c&g;
    my $g = Jc&g || 'new' || die 'No g';
    
    my $add = c&add || ''; # put Wt to start tops
    
    my $gd = "$bay/$g";
    
    my $eh = hitime();
    
    n $gd=>-lize=>{s=>$gd,add=>$add}
    
    # if c&bay we must be serving this to Dogu or someone...
    # < each $gd is a page of Lize
    #   all want to take clicks at any time
    c&quiet && delete Jc&tape;
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    n tripes=>o4=>" $gd - took: $delta"
    
    
pi/lize: | # for a given s=$gd (GG/G directory for W)
    my $gd = c&gd || c&s;
    
    # 1: the watcher
    n lies=>-lies_1=>"$gd/*/5",'%qz'
    
    # static 2 if ^ steady
    
    # 2: lay out web of dependencies
    n waved=>-jackpole_2=>{s=>T.op},'%qz'
    
    # 3: see updatables
    n edge=>-respec_3=>{s=>T.op},'%qz'
    
    # static 4 if ^ steady
    
    # 4: pile with desire
    # the action:
    my $act = [Jig=>[$gd=>-Gdo=>{}]];
    my $c = {};
    # to start tops:
    c.add = c&add if c&add;
    
    n pile=>-lenot_4=>{s=>T.op,%$c},{runs=>$act}
    
    # next things take some pi as input
    # and continue/redo branches of thinking
    # until some action comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down
    
    # < get only changed, redome parts
    # < know history to W
    # < sets most-W-owning, ordering
    # < more than one parent, 
    
    
letsclick: | # click pile
    sayyl "Have lets: ".ki e&us;
    # < presenting these potential actions
    #   so gesturing at the frontend is free to evolve
    my @h = e&_hC;
    my @n;
    my ($p) = grep { _s&pi eq 'pile' } reverse @h;
    push @n, shift @h until $h[0] eq $c;
    
    # the dos-ing's casement
    # (J that made C above the 9)
    my $o = $n[-1];
    my $i = $h[-1];
    # click name to go
    # can wire the button down for some G
    # exhausting for the edge of development
    my $com = &s,sc{
                my @y = $o; # deep
                while ($o && os&ml) {
                    $o = o.y.prev || last;
                    my $l = $y[-1];
                    # skip 22 in 1222(3)
                    os&depth < ls&depth || next;
                    push @y, $o;
                }
                # top..deep
                @y = reverse @y;
                ($o) = (@y); # highest caretaker of o
                # < along @y may be tests wanting
                my ($run) = grep{$_} map {_s&runs} reverse @n;
                # fill out the form for action
                my $R = G&Ct,$run;
                my $E= Rc&e || die "run form not elvis";
                
                Ec&s = $s || "An Update";
                
                # runs deepest first for fast compile check
                # then the rest in the same process
                # < J sleeping (wants to check G&t deps)
                Es&z = [map{ G&Ct,[_.t] }reverse @y];
                
                G&hoh,E.sc,$sc if $sc;
                saygr "For ".ki($sc)." Over ".ki E.sc;
                
                Rw Wudder $s:R;
    };
    if (os&pi eq 'lets') {
        # is an edge
        if (i.t eq 't') {
            if ( us&S ) {
                G&give:Budge=>"Add o.t to batch";
            }
            else {
                my $sc = {};
                sc.everything_under = o.t if us&C ->{C};
                $com->('',$sc);
            }
        }
        else {
            if ( us&S ) {
                G&give:Budge=>"Ignore o.t's i.t change?";
            }
            else {
                G&give:Budge=>"Get interested in o.t's i.t change";
            }
        }
    }
    else {
        $o = $i; # the very end of it is t=$W
        # general ghost/Wsitch interest in something
        # or pushing the key that didn't necessarily want to be pushed
        if ( us&S ) {
            my $sc = {};
            # everything under the toplevel
            sc.everything = 1 if us&C ->{C};
            $com->("Entirety",$sc);
            #G&give:Budge=>"Rise out of i.t";
            # or wind backward?
        }
        elsif ( us&C ->{C}) {
            my $sc = {};
            sc.everything_under = o.t if us&C ->{C};
            $com->("Especially",$sc);
        }
        else {
            G&give:Budge=>["Get interested in i.t",1,{s=>[$o,$i]}];
            # or wind forwards?
        }
    }
    
    #
    #exit;
    saybl " - ".G&aC,$_ for e&_hC;
    T.pos = 0;
pi/lets: | # bitular suggestion
    y.at.dos = 'letsclick';
    n t=>o1=>C.t,'%fw:4,fs:14'
    s&hs = 798;
    
    my $R = c&R || return;
    
    my $nex;$nex = &C{
        $C, C.y.next ? $nex->(C.y.next) : ();
    };
    
    my @sug;
    for my $r ($nex->(R.y.in)) {
        for my $t ($nex->(r.y.in)) {
            my $d = tc&s;
            # the changed object ^
            # we have s&(ha/dige)_was on t
            # depending on thing, chase difference
            push @sug, "r.t t.t";
            m "r.t t.t"=>''=>" r.t t.t "
        }
    }
    # so the -lenot has lots of info for others to borrow
    s&problems = join ", ", @sug if @sug;
    
    
lenotclick: | # poking around the pile
    Rw letsclick + $not=1;
pi/lenot: | # make pile of something
    my $d = G&Experience;
    y.at.dos = 'lenotclick';
    s&fs = 8;
    my $z = [
        map{ G&Ct,[_.t=>{R=>$_,cv=>1}] }
        sort {a.t cmp b.t} 
        values %{s.y.tw}
    ];
    my $tw = {map{ _.t=>$_ }@$z};
    my $got;
    for my $C (@$z) {
        my $R = C.y.R;
        my @in = map { $tw.>$_ || die "nosuchW $_" }
            split ',', Rs&inside;
        if (@in > 1) {
            1 && sayre join "\n", "many ".G&aC,$R ." in:",
                map { " - ".G&aC,$_ } @in;
        }
        my $i = 0;
        for my $W (@in) {
            $got.>C.t ++;
            my ($C) = $i++ ? grep{ _s&another = 1 } G&hup,$C : $C;
            push @{Ws&z}, $C;
            $i++;
        }
    }
    my @tops = grep { !$got.>_.t } @$z;
    die "No tops: ".ki$z if !@tops && @$z;
    
    my @l = map { G&ind,$_ } @tops;
    my $have;
    for my $I (@l) {
        $have.>I.t ++;
        my $R = I.y.D.y.R;
        my $K = G&Ct,[I.t=>''=>{s=>I.t}];
        if (Ic&ind) {
            # depth to stay a number for later
            Ks&depth = Ks&ml = Ic&ind;
        }
        Ks&dis = 1; # one line
        if (exists Rs&z) {
            Kc&pi = 'lets';
            Kc&R = $R;
        }
        m $K
    }
    if (my @dont = grep { !$have.>_.t } @$z) {
        my $me = "(circular mounting?) Dont have "
            .ki\@dont;
        warn $me;
        n ohno=>o5=>"!! $me",'dis:1,hs:577'
    }
    
    m $_=>-lets=>$_ for grep{my$s=$_;!grep{_.t eq $s}@$M}
                        grep{$_} split ',', c&add;
    for my $C (@$M) {
        s&hs = '744' if s&another;
    }
pi/respec: | # compare w/W situations, make pile
    my $d = G&Experience;
    my $rs = {}; # what is
    my $tr = {}; # what is trouble
    # FactorEase w/* etc (G&ind follows thing's next)
    # this is probably where to start growing FactorEase
    my $nex;$nex = &C{
        $C, C.y.next ? $nex->(C.y.next) : ();
    };
    # at C was D - y&tw + s&z welder
    my $atwz = &CD{
        $D = G&Ct,$D if ref $D ne 'HASH';
        # ! tw of SirKill/wiring keeps last not first
        C.y.tw.>D.t ||= do {
            push @{s&z||=[]}, $D;
            $D
        };
    };
    for my $k (qw'w W K') {
        my $n = s.y.tw.>$k || next;
        $rs.>$k = [$nex->(n.y.in || next)];
    }
    
    # check way used vs now
    for my $w (@{rs.w||[]}) {
        my $y = G&wops,w.t;
        if (ws&dige ne ys&dige) {
            # w/$w/$W
            my $r = tr.w ||= G&Ct,[w=>1];
            
            my $t = G&Ct,[w.t=>1]; # way difference
            ts&dige = ys&dige;
            ts&z = [$nex->(w.y.in)]; # affected W
            _s&dige_was = ws&dige for @{ts&z};
            push @{rs&z||=[]}, $t;
        }
    }
    
    # check W's W included vs W now (K)
    my $K = { map { _.t => $_ }@{rs.K||[]} };
    for my $W (@{rs.W||[]}) {
        my @l = $nex->(W.y.in || next);
        for my $l (@l) {
            my $k = $K.>l.t;
            if (ls&ha ne ks&ha) {
                # W/$Wunder/$W
                my $r = tr.W ||= G&Ct,[W=>1];
                # each l/W may appear in many W
                my $L = $atwz->($r,[l.t=>1]);
                my $t = G&Ct,[W.t=>1]; # W difference
                Ls&ha = ks&ha;
                ts&ha_was = ls&ha;
                push @{Ls&z||=[]}, $t;
            }
        }
    }
    
    # all W
    my $tw = { map { _.t => G&Ct,[_.t,{K=>$_,cv=>1}] } values %$K };
    
    # distribute trouble to W
    # s&z problems type(w/W) / $w/$W
    each kv $tr {
        for my $p (@{vs&z}) {
            # the thing causing imbalance
            for my $t (@{ps&z}) {
                # ourselves and our end of the situation
                my $W = $tw.>t.t || sayre("noWtw prob=p.t W=t.t") && next;
                # our this kind (w/W) of probs
                my $k = $atwz->($W,[$k=>1]);
                # the thing causing ($p) is the flame
                # but put it in sc so this can be stored
                my $y = {cv=>2,cause=>$p};
                $atwz->($k,[p.t=>$y=>{},t.sc]);
            }
        }
    }
    
    # s&inside = $Wover
    for my $Wo (@{rs.W||[]}) {
        my @l = $nex->(Wo.y.in || next);
        for my $l (@l) {
            my $W = $tw.>l.t || sayre("noWtw Wo=Wo.t W=l.t") && next;
            Ws&inside = join',',grep{$_} Wo.t, Ws&inside;
        }
    }
    
    if (0) {
        my $ub = &Cd{ G&aC };
        
        saybl "\t$_" for G&ind,tr.w,$ub,{nohup=>1};
        saygr "\t$_" for G&ind,tr.W,$ub,{nohup=>1};
        my $y = G&Ct,[y=>1];
        ys&z = [sort {a.t cmp b.t} values %$tw];

        sayre "\t$_" for G&ind,$y,$ub,{nohup=>1};
    }
    
    n $_ for values %$tw;
    # all yK = jackpole's K/$W with cs = the 5ile, 5's 9 sc
    
pi/jackpole: | # map bay/$W/5 to $W and collect w/W outputs
    # to 5ile, way, W in, W out
    my $types = {};
    my $in = &KCD{
        my $K = $types.>$K ||= G&Ct,[$K=>2];
        my $B = K.y.tw.>C.t ||= $C; # known/w
        # Bs&* == Cs&*, except z
        # < more than one version of something? FactorEase
        return unless $D;
        my $E = B.y.tw.>D.t ||= $D; # unknown/W
    };
    T.op = $s;
    for my $D ( G&op ) {
        Dc&s || die "Nos, hard work?";
        my $N = G&Beas,Dc&s;
        my ($F) = @$N;
        my $t = F.t;
        
        my $K = G&Ct,[$t=>1=>{s=>D.t}=>{%{F.sc}}];
        delete Ks&z;
        $in->(K=>$K);
        
        for my $d (@{Fs&z}) {
            for my $B (@{ds&z}) {
                $B = G&hup,$B;
                my $C = G&Ct,[$t=>1];
                if (d.t eq 'W') {
                    # our version of it under us
                    $in->(W => $C => $B );
                }
                else {
                    # us under it
                    $in->(d.t => $B => $C );
                }
            }
        }
    }
    
    # tw to zs
    my $twz = &C{
        my @z = sort {a.t cmp b.t} values %{delete(C.y.tw)||{}};
        s&z = \@z if @z;
        @z
    };
    my $ub = &Cd{ ki $C };
    each kC $types {
        $twz->($_) for $twz->($C);
        #saybl "$k\t$_" for G&ind,$C,$ub,{nohup=>1};
        n $C
    }
    
    # so now
    # K is for each W:
    #   cs where it came from, sc (-z) copied from its 9
    
    # W is each W including other W (one piece hierarchy)
    #   the s&ha/version there needs checked against K, what it is now
    
    # w is each way with s&dige being used by other W
    #   usually the pin
pi/lies: | # watch wormhole (mtimes) GONER to -lise
    local A.V = 0;
    Jc&save = 'W';
    # page i increases in flood
    # stretches out lim to keep reading until it hits old news
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = $s;
        c.s = "C.t/$s" if $s =~ /^\W/;
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &s{
        my $sc = {};
        (sc.size,sc.mtime) = (stat $s)[7,9];
        sc.link = readlink $s if -l $s;
        $s=>1=>{},$sc
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = G&Experience;
    
    # osc changing atom loads contents
    @$M = Rw Modulim $d $list $forms;
    
    1s&sels.mtime.5 = &acgt{
        if (s&size > 2000 && s&large <  2) {
            s&large = 1;
            return;
        }
        1 && sayre "Read happens: C.t";
        c&s = read_file(C.t);
    };
    
    # imparting to self again, next thing will require version bump
    # since there is no hashing the reverse of travel yet
    
 
Higg: | # see Lize
    Jc&tape = 'Dejo';
    n Lize=>V
    n Lize=>-beli=>{s=>T.op}
pi/beli: | # wormhoe
    T.op = $s;
    my $ub = &Cd{ G&aC };
    my @stu = G&ind,$s,$ub,{nohup=>1};
    n beli=>-pud=>{dl=>6,s=>\@stu}
    #[ G&op ]}
    
Budge: | # throw data off the edge of the map
    Rw Tiot;
    Rw Elationist;
    S
    my $c = Jc&es;
    n c.t=>-od=>{dl=>3,%{c.c}}
    

