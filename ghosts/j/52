GiveTime: | # release from reading input
    Gc&clockon = sub {
        1 && saybl "GiveTime: G.t";
        # turns Udder read loop into Baye read loop
        Gc&freetime = 1;
        n Baye
        Mojo::IOLoop->is_running || Mojo::IOLoop->start;
    };
AKnow: | # last pole, putting read/writes to place
    # configurable...
Wudder: | # send little C to a G through $G/in (start W as fork from Udder)
    $s = G&Ct,$s if ref $s eq 'ARRAY';
    $s = G&Ct,[$s] if !ref $s;
    my $to = ar.to || "Udder";
    my $bay = ar.bay || Gc&bay;
    if ($bay eq Gc&bay && $to eq G.t) { # subnet and number
        sayyl "Delvisering self: ".ki $s;
        G&elph,$s;
        return;
    }
    my $in = "$bay/p/$to/in";
    sayyl "Writing $in For ".ki $s;
    write_file($in,{append=>1},sjson($s)."\n");
BayFishing: | # become Op/Ud node, see 822
    my $p = $$;
    $| = 1; # autoflush output channel
    Gc&tapescontinue = 1;
    # mkoJ called by Wout, sends lines with Ilan on Opper
    # Opper Ilan $f elvised by Ualve on Udders
    #     Ilan unifies names/routes points by elvising Win
    G.mkoJ = &Wc{
        c.holst = $W; # geoplace on desk section
        my $Y = Gc&B.sc.A;
        c.Y = $Y; # A coming from
        G&elph,NetPut=>[out=>1=>$c]
    };
    
    A.7.t ||= 'neu';
    # < remove only non-links
    #   for T room to decide start-withs
    /^\w+$/ || die "Comp Gc&bay/A.7.t" for Gc&bay, A.7.t;
    
    
    # $bay passed through
    town: `rm -rf Gc&bay/A.7.t/*`;
    my $to = Rw ElvisYou;
    return sayre "< ElvisYou $p vs $$" unless $p eq $$;
    
    sleep 1;
    
    my $op;
    my $f = "$to/p/Opper";
    sayre "... $f ";
    sleep 1 until -l $f;
    $op = readlink $f;
    saygr "Waiting fr $op $f";
    waitpid($op,0);
    sayyl "Done! $op on $$";
    if (readlink("$f/will") =~ /restart/) {
        sayre "$f wills restart";
        goto town;
    }
    sayre "will restart..?";
    <STDIN>;
    goto town;

