PostK: |
    my @aK = map { _.y.KA || die "NoOC: ".ki$_ } @{os&Cora};
    
    # scoop up I every time
    # clobber here into the many I cv 
    #  or different positions on the thing,
    #  even with same cv, from around this vector, someday
    # we hold A.I as most executable, use OC for it
    s&I = {map { _.t=>$_ }
        # the shape of being an I thing (yup==9?)
        # take outC, which is:
        #   clone of OC
        #   not the clone KC, which is breaking down code for Lineing
        map {
            my $c = _s&clones || die "KAnoclones";
            c.outC || die "Has no outC"
        }
        map { _.y.KA || die "No KCyKA" }
        grep { _c&W && !_s&W }
        map { _c&s || die "KC no cs=KC" } 
        @aK};
    
    my $la;
    # KC find lv
    my @lvre;
    for my $C (@{os&Core}) {
        next if A.1.t ne 'Tvin';
        my $Y = C.y.A;
        my $ind = join('',('  ')x Y.c.ind);
        # C KC fully, _ lv
        my $v = Ys&clones.lv;
        # what changed
        my $d = Yc&diff;
        # previous (amongst everything now) lv should clue gap/ordering
        my $p = C.y.prev;
        my $l = p.y.A.sc.clones.lv if $p;
        # insert it in the over lv sz
        my $i = C.y.up;
        my $L = i.y.A.sc.clones.lv if $i;
        
        if ($p && $p ne $la && Yc&el < 3) {
            push @lvre, $l;
            $L && Ls&z || die "Noup need prevl: ".ki $C;
            @{Ls&z} = map { $_ eq $v ? ($l,$v) : $_ } @{Ls&z};
        }
        push @lvre, $v;
        
        $la = $C;
    }
    for my $v (@lvre) {
        my $Y = v.y.A;
        my $ind = join('',('  ')x Y.c.ind);
        1 && say "Yc&el $ind - ".G&aC,$v ."  ( "
            .ki(v.c)."    %  ".ki v.sc;
    }
    
    # deletes I unless values I
    delete s&I unless values %{s&I};
    
    s&tv = r.y.tv;
    s&top = $r;
    s&tw = r.y.tw;
    

Tveing: |
    #A.V = 1;
    n Tvin
    #A.V = 0;
    n Tvin

Tvin: |
    Js&bowls ||
    n first=>4=>'first'
    Js&bowls &&
    n first=>3=>'non'
    m $_=>''=>($_ > 8 && Js&bowls++).' o','%oth:er,st:uff' for 1..14;
    
    
    
Koul: | # clarify changes to string
    u a
    # might be making Lines in here?
    # might be doing some C's whole picture (1) and lv diff (7)
    #   as two Cs? make encoding instructions pop in
    K 1:
        # is KC
        my $o = C.y.A;
        o.t eq 'o' || die "No oA: ".ki $o;
        # A&r = root.y.KC
        A&el = oc&el;
        # keep an unsquished version
        a&l = C.y.C;
        # last K
        A&K = C.y.KA if C.y.KA;
        # has continual bit of C
        # < or name g, share with O?
        a&n = A&K.sc.l || {};
        # put K
        C.y.KA = $A;
        
        # < making this stick...
        T.not = 1 if C.sc.not eq '1';
        
        
    
    # a&n continues as long as C doesn't move
    # a&l is the original C we are squishing
    
    # c&Jo = J version
    K 2:
        my $l = a&l;
        my $n = a&n;
        
        delete c&Jo if s&W || s&qz;
        
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = s&J || die "No sJ for Jo K: ".ki$l;
            # < have a whole C for a version label
            #   c imp,wil,mat etc versioning
            #   sc forms
            my $lo = nc&Jo;
            if ($lo ne c&Jo) {
                # < pick the right page
                my $s = Js&s;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = nc&Jowil || 1;
                my $conti = sc&imp eq nc&Joimp && $lv eq nc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                nc&Jolv = $lv;
                nc&Joimp = sc&imp;
                nc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                # quiet for insides, should remain with qs
                delete c&s if Js&tv;
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
    # set Js&Kels.sending.3 = $s to G&h,$cb for sc.sendings el3ing
    K 3:
        my $l = a&l;
        A&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            # limited to those under 9?
            $sel = {} unless l.y.up eq A&r;
            each k,els $sel {
                exists l.sc.>$k || next;
                each el,do $els {
                    A&el eq $el || A&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
        }
    # like Line
    K 4:
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE' && $nk ne 'sc';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
        
