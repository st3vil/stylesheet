FishBrains: |
    # etc
        
        # ground has been completed, pos revamping sleepybits from drain
        my $g = A.ground || die "noground";
             gs&J eq A.1 || die "ground sJ not A1: ".ki(gs&J)."\n\nA1: ".ki A.1;
        my $ch = g.t;
        
        # ground -> drain
        my $d = 1s&drains.>$ch = G&hup,$g;
        ds&z = [grep { 
            my $Y = _.y.A;
            !$Y || !Y.c.T.not || do {
                sayre "Dropping yATnot from drain:";
                sayre "   C=".ki $_;
                0;
            };
        } @{ds&z}];
        
        # brain is ongoing, one per ground
        A&s = $C = 1s&brains.>$ch ||= G&Ct,[$ch=>1=>{}=>{J=>A.1}];
        
        
        local A.V = 0;
        # o in - to map the drain and OC the changes
        #   climbing in/next/z to produce OC feedable clones,
        # <? C that are attributes it keeps/diffs but doesn't OC
        # OC.y.C = origin C, C.y.OC = OC
        # 
        # the OC is another copy, which the oiD gets
        # < see enough interior of Js with map function
        #   o being FactorEase's backend, ideally
        my $m = G&Ct,[J_Shade=>''];
        ms&any = &acgt{
            $_ eq 's' || delete C.c.>$_ for keys %{C.c}
        };
        ms&nkgk.sc.J = &acgts{
            ref $s eq 'HASH' && s.y || return sayre "NotJ:".ki$s;
            c&Jo = ss&Jo;
        };
        
        my $o = A&in = G&o,$d,{liveon=>$C,t=>'in',yoff=>'OC',map=>$m};
        
        # where we'd want to forget $d, the drain itself...
        # < d.y.in.y.up too
        A&Core = [grep {_.y.C ne $d} @{os&Core}];
        A&Cora = [grep {_.y.C ne $d} @{os&Cora}];
        
        
        # Cora is full state
        #   which will have its last awake .y.OC
        # Core is changing state, of OC
        #   may include the last OC, with 
        A&OAs = [map { G&A,O=>0=>_.c,_.sc } map { _.y.A } @{A&Core}];
        
        my $r = 1s&root || die "how to hold many";
        $r = r.y.OC || die "root didn't OC";
        
        # O - only changes and their parents
        # < tug for .1 progress
        # < with an A=Os for all
        G&A,$_,8,{r=>$r} for @{A&OAs};
        
        
        # Core is changing state
        
        #   slight possibility of zombies if you topy&OCs&qua++
        #     will news themselves until oinD quashes changes
        
        # the I, injected into r.y.tv, so z clobbers it,
        #   be releasing local modulation not absolute truth
        Rw PostO $o $r;
        # we shall make s&I from what looks like it in K
        
        # put this stuff in the idea of itself
        rs&z = [ grep{ $_ ne $r } @{A&Cora} ];
        
        delete rc&M;
        
        # o ou - to finalise ourselves and OK changes
        $o = A&ut = G&o,$r,{liveon=>$C,t=>'ut',yoff=>'KC',gen=>'lv'};
        
        #saybl join('', ('  ') x _.y.A.c.ind) ." - _.t _.y.cv" for @{os&Core};
        
        # some vectors may want KC on top, no KAing
        # default
        # K<6 some may want KC tidied, shaded c
        #     the shade bits of c may cache somewhere for S
        # K>5 some want the above as incremental changes
        
        # < shading C like A.map, but for keeping things from a&ng
        
        # K<6 compresses/tidies changed to save whole
        #   putting tidy s&top = 9, the output
        #   awake by lv-ish difference-only, but
        #   using and setting (r.y.KC) wholes
        # mostly shades C.c for reinput through reversaliser
        
        A&KAs = [map { G&A,K=>0=>_.c,_.sc } map { _.y.A } @{os&Core}];
        
        # K>5 fills out (with parts of K) changes only, to log
        #   putting more stringifying
        
        $r = r.y.KC || die "root OC didn't KC";
        
        
        # K - only changes and their parents
        #   <6 becomes things for s&top, s&tv, etc
        #   >5 comps for writing Lines
        # < an A=Ks would map out AWritering
        #     pointing to objects already on the ground
        G&A,$_,59,{r=>$r} for @{A&KAs};
        
        Rw PostK $o $r;
        
        # hangs brain up on the J
        1s&s = $C;
        
        A.1.sc.>$_ = C.sc.>$_ || undef for qw'I tv top tw';
        # top is 9's KC
        
        # -> W
        
        $C
        
    # watching the K diverge as a way to get input is interesting
    # self servers (Dogu/-lookin eg) wants to see out-changes as in-changes
PostK: |
    # KA version of everything
    my @aK = map { _.y.KA || die "NoKA: ".ki$_ } @{os&Cora};
    
    # scoop up I every time
    # clobber here into the many I cv 
    #  or different positions on the thing,
    #  even with same cv, from around this vector, someday
    # we hold A.I as most executable, use OC for it
    s&I = {map { _.t=>$_ }
        # the shape of being an I thing (yup==9?)
        # take outC, which is:
        #   clone of OC
        #   not the clone KC, which is breaking down code for Lineing
        map {
            my $c = _s&clones || die "KAnoclones";
            c.outC || die "Has no outC"
        }
        map { _.y.KA || die "No KCyKA" }
        grep { _c&W && !_s&W }
        map { _c&s || die "KC no cs=KC" } 
        @aK};
    
    
    # Cora CK, fully
    #   needs KA-ing to squish whole picture
    my $h =
    3c&save &&
        Rw PostTV;
    
    # lvre, difference
    #   needs KA-ing to squish and hoist other lv
    3c&tape &&
        Rw PostLV + $h;
    
    # if neither we can 
    
    # deletes I unless values I
    delete s&I unless values %{s&I};
    
    s&tv = r.y.tv;
    s&top = $r;
    s&tw = r.y.tw;
    
PostTV: | # make 1-5, whole C
    my ($f,$gd) = G&Locate_write;
    # from KA c&s (aka KC), for el=8 they replace last KC and sleep
    # this would dodge out the wiring..? safe-ish for flatlist
    #   should probably clone c/sc from sleeping KC
    my $N = [map{ _c&s || die "noC: ".ki$_ }
         map { _.y.KA || die "NoKA: ".ki$_ } @{os&Cora}];
    
    $C = $N->[0];
    
    1 && saygr "saving ".G&sn ." to $f";
    
    Rw Writer $gd $f $C $N 1 2 3 4 5;
    
PostLV: | # make 7
    my $la;
    
    # get KC lv clone, fill in unimplied placement order
    my @lvre;
    for my $C (@{os&Core}) {
        my $Y = C.y.A;
        my $ind = join('',('  ')x Y.c.ind);
        # C KC fully, _ lv
        my $v = Ys&clones.lv;
        # what changed
        my $d = Yc&diff;
        # previous (amongst everything now) lv should clue gap/ordering
        my $p = C.y.prev;
        my $l = p.y.A.sc.clones.lv if $p;
        # insert it in the over lv sz
        my $i = C.y.up;
        my $L = i.y.A.sc.clones.lv if $i;
        
        if ($p && $p ne $la && Yc&el < 3) {
            push @lvre, $l;
            $L && Ls&z || die "Noup need prevl: ".ki $C;
            @{Ls&z} = map { $_ eq $v ? ($l,$v) : $_ } @{Ls&z};
        }
        push @lvre, $v;
        
        $la = $C;
    }
    1 && saygr "In LV for ".G&sn;
    # further K for lv
    # holding the lv clone
    A&VAs = [map {
        my $Y = _.y.A;
        G&A,K=>1=>{%{Y.c},s=>$_},Y.sc;
    } @lvre];
    
    # V is K 1, 5-8
    # K usually 1-59
    _.y.cv = 0.49 for @{A&VAs};
    _.V = 1 for @{A&VAs};
    A.V = 1;
    G&A,$_,8,{r=>$r} for @{A&VAs};
    
    
    for my $Y (@{A&VAs}) {
        my $v = Yc&s;
        my $ind = join('',('  ')x Yc&ind);
        1 && say "Yc&el $ind - ".G&aC,$v ."  ( "
            .ki(v.c)."    %  ".ki v.sc;
    }
    
    my ($f,$gd) = G&Locate_write;
    my $N = [map { _c&s } @{A&VAs} ];
    $C = $N->[0];
    1 && saygr "Would note ".G&sn ." to $f";

    Rw Writer + $gd $f $C $N 7;
    
Tveing: |
    A.7.t = 'glang';
    saybl map {G&aC,$_ } @{ A.I.K.sc.z };
    #exit;
    #A.V = 1;
    n Tvin
    #A.V = 0;
    n Tvin
Tvin: |
    Jc&tape = 'W';
    Jc&save = 'W';
    
    Js&bowls ||
    n first=>4=>'first',{doge=>{ela=>3}}
    Js&bowls &&
    n first=>3=>'non'
    m $_=>''=>($_ > 8 && Js&bowls++).' o','%oth:er,st:uff' for 1..14;
    sayyl "Pinned";
    
    
    n table=>-tabul=>{vl=>Js&bowls}
    
pi/tabul: |
    n t=>''=>C.t
    m random=>''=>"virtual" for 1..c&vl;
Koul: | # clarify changes to string
    u a
    # might be making Lines in here?
    # might be doing some C's whole picture (1) and lv diff (7)
    #   as two Cs? make encoding instructions pop in
    K 1:
        # is KC
        my $o = C.y.A;
        o.t eq 'o' || die "No oA: ".ki $o;
        # A&r = root.y.KC
        A&el = oc&el;
        # keep an unsquished version
        a&l = C.y.C;
        # last K
        A&K = C.y.KA if C.y.KA;
        # has continual bit of C
        # < or name g, share with O?
        a&n = A&K.sc.l || {};
        # put K
        C.y.KA = $A;
        
        # < making this stick...
        T.not = 1 if C.sc.not eq '1';
        sayyl "Komp A&el: ".ki $C;
        
        
    
    # a&n continues as long as C doesn't move
    # a&l is the original C we are squishing
    
    K 2:
        # are we being aware of nothing or disappearing
        A&el || die "No el K";
        if (A&el eq '8') {
            1 && sayyl "Same sleeps! ".G&aC,$C;
            # use the encoded one (for wholeness)
            $C = A&s = A&K.c.s;
            C.y.A = $A;
            1 && saybl "Same sleeps! ".G&aC,$C;
            return T.Z.8 = $A;
        }
        A&el  eq '9' # is last KC
             && return T.Z.9 = $A;
            
        
    
    # hook Js&Kels.sending.3 = $s to G&h,$cb for sc.sendings el3ing
    K 3:
        my $l = a&l;
        A&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            # limited to those under 9?
            $sel = {} unless l.y.up eq A&r;
            each k,els $sel {
                exists l.sc.>$k || next;
                each el,do $els {
                    A&el eq $el || A&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
        }
    #c K55 figure Line encoding
    #   whole pictures + change want derefing here
    #   
    K 55:
        my $l = a&l;
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                # quiet for insides, should remain with qs
                delete c&s if Js&tv;
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
        
        s&Kseen++;
        
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE' && $nk ne 'sc';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
    #c K6 lv/from within
    # c&Jo = J version
    K 6:
        my $l = a&l;
        my $n = a&n;
        
        # they can look it up
        delete c&Jo if s&W || s&qz;
        
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = s&J || die "No sJ for Jo K: ".ki$l;
            # < have a whole C for a version label
            #   c imp,wil,mat etc versioning
            #   sc forms
            my $lo = nc&Jo;
            if ($lo ne c&Jo) {
                # < pick the right page
                my $s = Js&s;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = nc&Jowil || 1;
                my $conti = sc&imp eq nc&Joimp && $lv eq nc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                nc&Jolv = $lv;
                nc&Joimp = sc&imp;
                nc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
Writer: | # to make 12345, 7
    # types <= 5 show whole instant
    #   good for still code, absolute data
    #   shows would be an extending ladder of what is and when
    # 7 shows lv progressing change
    #   good for streaming tiny code changes to remotes
    #   shows are a pool of what is that evolves
    #     which could still have timing
    #     
    # 6 forks
    # 7 entanglements/joins
    ar.m || die "send m=list,of,types";
    $gd # the bay/G, where to find sibling W
    && $f || die "Sendbits";
    1 && saygr "W A.1.t ($f) @{ar.m}";
    
    # types wanted: lines pooled
    my $w = {map{$_=>[]}@{ar.m}};
    # ha pooled (once lines written)
    #  eg 2 can't know about 3 because 3 has to know about 2
    my $h = ar.h || {};
        
    # not s but the top/9
    $C = G&hup,$C;
        
    # storage the bits: h/$hash = content
    my $st = &st{
        $s = join "\n", @$s,'' if ref $s eq 'ARRAY';
        my $ha = slm 9, dig $s;
        `mkdir -p $f/h` if !-d "$f/h";
        my $hf = "h/$ha";
        write_file("$f/$hf", $s);
        if ($t) {
            `unlink $f/$t` if -e "$f/$t";
            `ln -s h/$ha $f/$t`;
        }
        $ha
    };
    
    # for G&ind'ing Cthing to flat lists like $N
        my $ub = &Cd{
            delete s&z;
            my $y = C.y;
            my $Y = y.A;
            my $el = $Y && Yc&el;
            local C.y = {cv=>C.y.cv};
            1 && saybl "For $el ".G&aC,$C;
            G&Line,$C;
        };
        
        # append C's Line s to list, indented
        my $in = &NCs{
            my $Y = C.y.A;
            my $ind = join('',('  ')x Y.c.ind);
            $s = [split "\n", $s];
            push @$N, join "\n", map{"$ind$_"} @$s;
        };
        
    # take meta off the 9, put ha on any W
        # < meta?
        my $meta;
        for my $C (@$N) {
            # the 9 has this old meta bunch
            # helped impart itself to s
            if (my $m = delete s&meta) {
                $meta && die "doublemeta";
                $meta = $m;
            }
            # assume W is in G as well
            # < have another kind of link
            #   bridgy, for Ang, sort-of inclusion, etc...
            if (my $t = s&W) {
                $t =~ s/\W+/-/gs;
                my $d = "$gd/$t";
                -d $d || die "unstored W in $f: $d";
                my $ha = readlink "$d/1";
                $ha =~ s/^h\///;
                s&ha = $ha;
            }
        }
    
    #c writ frequencies
    my $W;
    if (w.4) {
        # the 4: has 9, gist of first t/y
        # add some sc{shape,stringth,c,sc,etc}
        # < histogram and group like things
        # < compress styles
        # and collect W joins for 5
        $W = G&Ct,['W',1];
        for my $C (@$N) {
            my $Y = C.y.A;
            return undef if Yc&ind > 1;
            if (s&W) {
                my $D = G&Ct,[C.t,C.y.cv];
                Ds&W = s&W;
                Ds&ha = s&ha || die "W without ha: ".ki $C;
                push @{Ws&z||=[]}, $D;
            }
            my $D = G&Ct,[C.t,C.y.cv];
            # assuming gk is safe to join with -
            # < imply the style's encoding for FactorEase
            # like we can do for Line's
            for my $k (qw'c sc') {
                my $v = $C.>$k || {};
                keys %$v || next;
                D.sc.>$k = join'-',sort keys %$v;
            }
            # seem to prefer ytv than z connection
            # < both
            Ds&zs = @{s&z||[]} if s&z;
            Ds&zs = map{values %$_} values %{C.y.tv} if C.y.tv;
            # < more shape, classify language
            Ds&slines = split "\n", c&s if c&s;
            
            Ds&W = s&W if s&W && s&W ne C.t;
            Ds&ha = s&ha if s&ha;
            
            if (!Yc&ind && C.y.cv == 0.9) {
                Ds&ha = 'HAHAR';
            }
            $in->(w.4,$C, G&Line,$D );
        }
    }
    if (w.1) {
        # 1/everything
        for my $C (@$N) {
            my $S = $C;
            my @p;
            push @p, "_.t-_.y.cv" while $S = S.y.up;
            my $p = join "/", @p;
            
            my $l = eval { $ub->($C) };
            $@ && die "For $p:\n  C: ".ki($C)."\n$@";
            
            $in->(w.1,$C, $l);
        }
    }
    #c pointpile
    
    if (w.1) {
        # point to object: 1 -> h/$hash
        h.1 = $st->(w.1,'1');
    }
    # meta/5cience behind it: 5
    my $i = G&Ct,[C.t,C.y.cv] if w.5;
    if (w.4) {
        h.1 || die "4 without 1";
        # lum feeling: 4 ~= content, 
        w.4->[0] =~ s/HAHAR/h.1/;
        h.4 = $st->(w.4,'4');
        
        # < Scuttle copy various light things from 9
        is&ha = h.1;
    }
    if (w.5) {
        # 5's belief structure dependagey
        # < modernise
        my $xo = meta.A.xo;
        my $z = [];
        if (my $way = xo.way) {
            my $w = G&Ct,[w=>1];
            my $wz = ws&z = [];
            for my $pin (sort keys %$way) {
                my $p = G&Ct,[$pin,1];
                push @$wz, $p;
                my $v = $way.>$pin;
                if (keys %$v > 1) {
                    pc&s = $v;
                    ps&way_variants = keys %$v;
                    next;
                }
                (ps&dige,ps&used) = %$v;
                # could be a map to where/who it was used from?
                delete ps&used if ps&used eq 1;
            }
            push @$z, $w if @$wz;
        }
        
        # other meta stuff
        delete $xo.>$_ for qw'way o sWo';
        if (keys %$xo) {
            push @$z, G&Ct,[xo=>1=>{s=>$xo}]
        }
        
        # other W and their ha
        push @$z, $W if @{Ws&z||[]};
        
        is&z = $z if @$z;
        @{w.5} = G&ind,$i,$ub;
        h.5 = $st->(w.5,'5');
    }
    if (w.2) {
        # small status check point: 2 versions 1,4,5
        my $t = G&Ct,[C.t,C.y.cv];
        ts&1 = h.1;
        ts&4 = h.4;
        ts&5 = h.5;
        @{w.2} = G&ind,$t,$ub;
        h.2 = $st->(w.2,'2');
        
        # changelog/tree: 3 -> 2, last 3...
        my $r = G&Ct,[C.t,C.y.cv];
        (my $was = readlink "$f/3") =~ s/^h\///
            if -s "$f/3";
        # < was's 2 may eq twha, when no change, no commit?
        rs&parent = $was if $was;
        rs&2 = h.2;
        @{w.3} = G&ind,$r,$ub;
        h.3 = $st->(w.3,'3');
    }
    if (w.7) {
        # 7/changes
        # < log rotating along
        (my $was = readlink "$f/7") =~ s/^h\///
            if -s "$f/7";
        s&parent = $was if $was;
        s&3 = h.3 if h.3; # corresp. histree of wholeness
        s&1 = h.1 if h.1; # chistree of wholeness
        for my $C (@$N) {
            my $S = $C;
            my @p;
            push @p, "_.t-_.y.cv" while $S = S.y.up;
            my $p = join "/", @p;
            
            my $l = eval { $ub->($C) };
            $@ && die "For $p:\n  C: ".ki($C)."\n$@";
            
            $in->(w.7,$C, $l);
        }
        h.7 = $st->(w.7,'7');
    }
    $h

