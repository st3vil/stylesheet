TripDeck: | # note vortex, holder of diverse brief moments, bakes patterns into info
    $h = G&heading,'55';
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # piling stuff up
    =head
      TD
      to start raying together ghost/wormholes and travel
      so change becomes a crawling shadow,
        io doing it,
        also (a simpler)? io bringing in the first bunch of code
        being non-throaty
        maybe thro/G&U
      
      taking errors, runs
      and io lugging the outyrageous warm shadow
        finding tests to run,
        depending on the concentricism of W around it
      
      would be worth finishing these tests tho...
        have to have pressurised angles to find breaking points
      
      ten it should bes, 11 would bes, 12 could bes?
        search/find and plant on memories forever more?
      
      hammering facts, talking heads
      and now was a good time to stop
      but, varta
      bit seeker while bits restart about
      
      
      to be a sort of terminal... fuzzing trees, pushing
      want some key aiming,
        G should freeze time and give then fairly safely to A.4,
          who has moments to respond before A.5 blows it away to try again
        and all those Elvis vector things...
        following requests all the way through
    
    =BunchCrunch
      #msgs is getting composted in -rogram
        sequentia shall io make
      Duning and Doming are the same thing...
        Duning implies sleep when still, but so could Doming if !number
        either wants S !domeproper for iteration:
        S o queue/:w
          $w one by one code
        shall indented S be subnetted? ya. make em fractions.
          redo Doming with objects, step+1 doesnt clever
        
      S 5 desire changes
        # etc
        that should be able to handle doing jobs interrupted
        everything A:oing what might be changing
          the generosity/paranoia of those wake/sleep diff scans
          is very test-honed
        M y cvs 0.300dome00sequ ..?
          find out how to overload in js, many-decimal points that ><-
      
      and geometry! through io/F
      
      way that Babz locally (on 4),
        or do just the most weighty Babz there
      
      the way is fundamentally about how to hold the stuff that code was
        as its use changes, it is born in a magma holder, to drain mystery,
        cell-divide and grow into a known I thing, probably
      
      so run a little way village with io...
        virtualise some dream to do so
      
        
      
      
    
      teach perl/js via Thangers on:
        t.rows.indexOf(t.row)+' . '+t.i+'  '+ki(t.ar,6.23)+'        '+ki(t.next,2)
      watching is a goof, a drunk, a nun and a young programmer
        perl:   say =~ s/^\{|\}$/sg;
        js:     say = say.replace(/^\{|\}$/g,'');
      
    =Babz
    
       - do some stuff in javascript! the messiest and easiest things
       - n... wants loose t that concats $vars, so we can type endlessly
         until:
         since cv is always -jod or \d (or W)
         y can say :W instead of W, one c&thing == C.t could odify like that
           maybe more if the boundary is not text but a bubble
           when everything similarity matches itself
             and stretches tendons of divergence
      
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        NotInIf
      ; matters much for no reason
      brackets also
      filigree?
      
      =cut
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
StayToSleep: | # gentleness scan
    # 
t/ool: | # the usual io check maker
    G&heading;
    $io = G&way,'iooia';
    #1s&step = 2;
    G&way,'Doming',ar;
    
    $show = {};
    show.talk = 1;
    $a = &talk,t,params{
        t === '' && !talk and return m space   %fs:120%,hue:170deg,width:100%,height:3em,dis:block
        t == 'bug' and return m bugreport  $s:talk %fs:120%,hue:170deg,dis:block
        t == '9' and return m speech  $s:talk %hue:100deg,dis:block,fs:140%
        # normal test title
        t == '8' and return m thistest  $s:talk %fs:160%,hue:120deg,dis:block
        if (t == '7' || t == '6') {
            # right hand hanging talk
            $c =
            m talk  $s:talk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
            cs&fs = '420%';
            delete cs&float;
            return;
        }
        t && io[t](talk,params||[],{})
        t = io.nz();
        
        $iis;
        $findtalk = &S{
            $i = 5;
            while (S && !S.is && i-- > 0) { S = S.plumb }
            S = S.is && S;
            iis = S;
            S and return S.is+' '+S.talk
        };
        
        if (show.talk) {
            # i chainlinked behind lastfuncs
            $bits = [findtalk(t)];
            # o chainlinked behind firstfuncs
            iis && iis.plumb and bits.push(findtalk(iis.plumb));
            $tk = bits.join(' ');
            m talk  $s:tk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
        }
        
        m thistest  $s:talk %fs:160%,hue:120deg,dis:block
        
        show.t &&
        m iter  $s:t,dl:9.26
        
        !show.impartial and t.partial = 1;
        #c describe Cpath (ind) and nkgk (toLines)
        $whereindis = &{
            $balk = '';
            if (t.vind) { # amongst Cs
                balk += " on "+t.vind.map(&s{
                    return isC(s) ? s.t : ki(s,2)
                }).join('/');
            }
            $nkgk = T.eny_nkgk; delete T.eny_nkgk;
            if (nkgk) { # in C
                # from G&toLines via T, if thrown from its eny()
                balk += "'s "+nkgk.join('.');
            }
            return balk
        };
        $anyprobs = 0;
        $probs = []; # many message+whereindis,catch?
        $atchprobs = &t{
            t == 'one' && show.probspermany and return
            anyprobs += probs.length;
            return G&intag:'>6 '+"\n"+probs.splice(0).join("\n")+"\n"
        };
        $cb = &s,t{
            $text;
            if (isC(s)) {
                $code = sc&code;
                delete sc&code;
                G.enybug and debugger;
                if (!show.nocatch) {
                    # so we receive munted encodes + warnings
                    T.eny_catch = [];
                    T.enj_catch = [];
                }
                
                text = G&toLines,s;
                
                code and sc&code = code
                if (!show.nocatch) {
                    # attach warnings
                    ['eny','enj'].map(&t{
                        $ca = T[t+'_catch'];
                        delete T[t+'_catch'];
                        !ca.length and return
                        probs.push(t+" warning"+whereindis())
                        ca.map(&s{ probs.push('  '+s) });
                    });
                }
            }
            else {
                text = "GARB: "+ki(s);
                probs.push("nonC"+whereindis());
            }
            if (t.objects && t.objects.indexOf(s) >= 0) {
                # highlight t.objects (that doof matched)
                # < chucking rows with any object on matching
                # iterate objects if that's all you want
                text = G&intag:'>1 '+text
            }
            if (show.y) {
                # attach y, which hides most first
                $say = ki(s.y,6.24);
                say = say.replace(/^\{|\}$/g,'');
                text += "\t"+G&intag:'>3 '+say;
            }
            probs.length and text += atchprobs('one');
            
            a.ind_one and text = a.ind_one(text,s,t);
            
            return text;
        };
        $s;
        try { s = t.ind(cb).join("\n") }
        catch(er) {
            $balk = "Error calling ind()"+whereindis();
            m error_calling_ind  $s:balk %hue:100deg,dis:block,fs:140%
            m indBANG  $s:er.message %fs:130%,hue:170deg,dis:block
            m error_tc  $s:er.tc
            return
        }
        a.ind_many and s = a.ind_many(s,t);
        probs.length and s += atchprobs('many');
        if (anyprobs) {
            $say = ">6 !"+anyprobs+" problems!";
            s = G&intag,say +"\n"+s
        }
        s += "\n";
        m inds  $s:s,ht:1 %hue:120deg,ws:pre,dis:block
        # could do a node count or so?
        t.p and t.p = 'snip';
        return t
    };
    $nz = &show,{
        $t = io.nz();
        t.partial = 1;
        t.ungrouped = 1;
        while (show && t.more()) {
            m apull  $s:t.sc,dl:8.26
            m srow  $s:t.row,dl:8.26
        }
        return t
    };
    a.nz = nz;
    a.show = show;
    #c add
    $indent = &s,ind,prefix,indstring{
        prefix ||= '';
        indstring ||= '  ';
        ind < 0 and throw "negative ind for "+s
        $inds = ''; while (ind > 0 && ind--) { inds += indstring }
        return s.split("\n").map(&s{ return prefix+inds+s }).join("\n");
    };
    # incremental ind
    a.d = &talk,t,opt{
        $d = a.d.d;
        if (!d || t && t.constructor == Array) {
            # init
            d = a.d.d = {vals:[],texts:[],vinds:[]};
            d.params = t;
            t = opt;
            d.talk = talk;
            !(d.talk && d.params) and throw "a.d must init with talk/params"
        }
        1s&additioner = d;
        
        # looks again
        io.o(d.talk,d.params.slice());
        $op = t || {};
        typeof op != 'object' and throw "op/t not"
        $t = io.nz();
        
        # for each ind() callback
        #   each v remembers its path & readLines encode
        $n = {vals:[],texts:[],vinds:[]};
        a.ind_one = &text,s,t{
            n.vals.push(s);
            n.texts.push(text);
            n.vinds.push(t.vind.slice());
            return text
        };
        # for new them (n.vals) against old them (d.vals)
        # vals/texts/vinds/gone i all lign up, amongst new or old
        # < do we notice if something just moves around?
        #   relying on it not, and refs being the same every time...
        # < should look for same t in parent at least
        a.ind_many = &{
            $gone = (d.vals||[]).slice(); # gone i is d.vals i
            n.was = []; # n.vals i -> d.vals i
            each is n.vals {
                $gi = gone.indexOf(s);
                gi >= 0 and gone[gi] = null; n.was[i] = gi;
            }
            $gonetips = []; # gone i -> parent in n.vals i
            $goners = []; # gone i -> parent in gone i
            each is gone {
                !s and continue
                i == 0 and throw "first atom changed ref"
                $p = d.vinds[i];
                $pi = p.length-2;
                p[pi+1] != s and throw "last vind not us"
                $parent = p[pi];
                !parent and throw "no parent"
                # parent may still be around
                # < try match looser than ==, C.t/C.y.cv/overall look
                $ni = n.vals.indexOf(parent);
                ni >= 0 and gonetips[i] = ni; continue
                # parent also gone, some ancestor will still be around
                $di = gone.indexOf(parent);
                di >= 0 and goners[i] = di; continue
                $here = ki(s,2)+" ("+ki(parent,2)+"?)";
                throw "parent of "+here+" is nowhere"
            }
            
            $textdiff = &neu,old,ind{
                $s = '';
                old == neu and return indent(neu,ind,'=')
                if (old && neu && neu.match(/\n/)) {
                    # < use diff()
                    old = old.split("\n");
                    neu = neu.split("\n");
                    while (old.length || neu.length) {
                        s.length and s += "\n"
                        s += textdiff(neu.shift(),old.shift(),ind);
                    }
                    return s
                }
                old and s += indent(old,ind,'-')
                neu && old and s += "\n";
                neu and s += indent(neu,ind,'+')
                return s
            };
            $bits = []; # [now i?,gone i?,ind_number,textdiff]
            $sg = [];
            $gonerism = &i,ind{
                bits.push([null,i,ind,textdiff(null,d.texts[i],ind)]);
                each ii,gi goners[i] {
                    sg.push(gi);
                    gonerism(gi,ind+1);
                }
            };
            $sgt = [];
            each is n.vals {
                $neu = n.texts[i];
                $di = n.was[i];
                $old = d.texts[di]; # may not be
                
                $p = n.vinds[i];
                $ind = p.length-1;
                bits.push([i,null,ind,textdiff(neu,old,ind)]);
                
                each ii,gi gonetips[di] {
                    # vanished immediate children recurse further
                    sgt.push(gi);
                    gonerism(gi,ind+1);
                }
            }
            # sanity
            $usg = goners.filter(&i{ return sg.indexOf(i) >= 0 });
            $usgt = gonetips.filter(&i{ return sgt.indexOf(i) >= 0 });
            usg.length and throw "unseen goners: "+ki(usg)
            usgt.length and throw "unseen gonetips: "+ki(usgt)
            # commit
            ex(d,n);
            # reduce/conjoin
            $bits = bits.map(&w{ return w[3] });
            bits = a.reduce(bits);
            return bits.join("\n")+"\n"
        };
        T.o = t;
        a(talk);
        delete a.ind_one;
        delete a.ind_many;
    };
    # keep knowing between domes
    a.d.d = 1s&additioner;
    
    #c rediff
    # bunch of "+  ..." get properly diff()'d and html tagged
    # eg:
    # L = ["=house","+  shed","=  hut"+]
    #  house gets a (subatomic) shed, snip huts after 3
    # < can't see gone whitespace
            $rediff = &L,opt{
                $old = [];
                $neu = [];
                each il L {
                    $sym = l.substr(0,1);
                    l = l.substr(1);
                    sym == '-' and old.push(l)
                    else
                    sym == '+' and neu.push(l)
                    else {
                        old.push(l); neu.push(l)
                    }
                }
                $d = diff(old.join("\n"),neu.join("\n"));
                $N = [];
                $nl;
                each in d {
                    i *= 1;
                    if (n.t == 'same') {
                        $L = nc&s.split("\n");
                        $key = opt && opt.snipnotfirst ? L.shift()+"\n" : null;
                        $context = 3;
                        $needs = context * (d[i-1] && d[i+1] ? 2 : 1);
                        if (L.length > needs) {
                            # squish after thing before
                            $nL = [];
                            d[i-1] and nL[0] = L.splice(0,context).join("\n")
                            d[i+1] and nL[2] = L.splice(-context).join("\n")
                            $inds; L.find(&s{
                                $m = s.match(/^(\s*)/);
                                return m && (inds = m[1])
                            });
                            nL[1] = inds+ (nL[0]?"...":'')+
                                L.length+" more"+
                                (nL[2]?"...":'')
                            nc&s = key+nL.join("\n");
                        }
                    }
                    # these colours expect to hue+120deg
                    $co = n.t == 'new' ? 0 : n.t == 'gone' ? 9 : null;
                    co != null and nc&s = G&intag:'>'+co+' '+nc&s; 
                    N.push(nc&s);
                }
                return N.join("")
            };
    #c reduce
    # < rewrite with F/etc and its temporary hierarchy mapintoism
    #   it as lines, groups of lines, bits of change all as one
    #   regexp/map/alterations working on any partism of the whole
    a.reduce = &bits,{
        $N = bits.slice();
        # reduce to difference with context:
        #   parents of changes as just t
        # < t siblings if the pool of them is <10 and >0.5 change
        #   blows the algorithm, diff to be done real good somewhere...
        $M = [];
        # a stack of things above here not in M, their depth
        $parents = [];
        $parinds = []; # ind -> parents i
        # put just t as parent while children may need them
        $vaguely = &ind,s{ // }}
            $out = [];
            while (ind <= Object.keys(parinds).slice(-1)[0]) {
                # indent reduces
                $i = parinds.pop();
                # pop undefs if gappy (shouldn't be)
                i == null and continue
                parents.splice(i)
            }
            $i = parents.push(indent(s,ind,''))-1;
            !(ind > Object.keys(parinds).slice(-1)[0]) and parinds[ind] = i
        };
        # add a must-see, also any parents
        $tothis = &s{
            #a.debog and debugger;
            !parinds.length and M.push(s); return []
            parinds.splice(0);
            parents.splice(0).map(&s{ M.push(s) });
            M.push(s);
        };
        # find such indent
        $just = &l,atleast{
            $ind;
            $re = !atleast ? /^\S(\s*)(\S.*)(\t|:)/
                # BQvals indented yay much, maybe more
                : RegExp('^\\S((  ){'+atleast+'})');
            $ind = l.match(re);
            !ind and debugger; throw "Lin not ("+gtind+"): "+l, es
            return ind[1].length / 2
        };
        # false if nothing in L changes
        $anych = &L{
            each il L {
                l[0] != '=' and return 1
            }
        };
        each is N {
            # strings for each atom, each line of which is:
            #   (+/-/=)(  indent)(toLinesing)
            ind = s.match(/^\S(\s*)(\S.*?)(\t|:)/);
            !ind and throw "lin not "+s
            $t = ind[2];
            ind = ind[1].length / 2;
            
            $L = s.split("\n");
            # simple, get gone (until becoming parent of action)
            !anych(L) and vaguely(ind,t); continue;
            
            # partitions of L lines: atom, BQ*
            $es = [[]];
            # ind shall wander up by 1 to BQ keys, 2 for BQ value...
            $find = ind;
            $l;
            while (L.length) {
                l = L.shift();
                # match atoms and their BQ keys
                $ind = just(l);
                $dif = ind - find;
                # atoms
                dif == 0 and es[0].push(l); continue
                dif != 1 and debugger; throw "BQkey indjump "+l, es
                # step BQ keys and their lines
                L.unshift(l);
                $at;
                while (L.length && just(L[0],ind)) {
                    $kl = L.shift();
                    !at and at = []; es.push(at); ind += 1;
                    at.push(kl);
                }
            }
            $atomt;
            $change = [];
            each iL es {
                if (i == 0) { # the atom
                    !anych(L) and atomt = indent(t,find,''); continue
                    change.push(rediff(L));
                }
                else { # BQ branches therein
                    !anych(L) and continue;
                    # < show first line of each new indent above change
                    #   to have not this wacky option that keeps BQkey:
                    change.push(rediff(L,{snipnotfirst:1}));
                }
            }
            # should have known up at anych(L)
            !change.length and debugger; vaguely(find,t); continue;
            atomt and change.unshift(atomt.substr(1));
            
            $string = change.join("\n");
            #a.debog && string.includes('jit') and debugger;
            tothis(string);
        }
        return M
    };
    a.fin = &{
        each in M {
            ns&hue || ns&pi and continue
            nc&pi = 'fod';
            ns&dos = 'grow';
            nc&dl ||= 12;
        }
    };
    return a
t/encodings: | # test yaml
    'Doming iooia'.split(' ').map(&s{ G&waylay,s });
    $a = G&way,'t/ool',ar;
    $io = A&io;
    $t = &title,ty{ a(title,ty||8) }
    a.show.nocatch = 1;
    
    $tryeny = &s{
        $err;
        $yam;
        try{ yam = eny(s,T) }
        catch(er) {
            err = er;
        }
        if (err) {
            m eny_error  $s:ki(err)
            err.tc &&
            m error_tc  $s:err.tc
        }
        
        m eny_encoded  $s:ki(yam)
        
        yam &&
        m dey_eny  $s:dey(yam)
        
        empty_catch();
        return yam
    };
    
    S 1 encoding functions
    
    $anray = &tsl{
        each in s {
            $tio = t+"["+i+"]";
            l and n = n.join(',');
            m $tio  $s:n
        }
    };
    $empty_catch = &{
        $t = T.eny_catch ? "T.eny_catch" :
            T.enj_catch ? "T.enj_catch" : '';
        !t and return
        $s = T.enj_catch || T.eny_catch;
        delete T.enj_catch; delete T.eny_catch;
        anray(t,s);
    };
    
    t('json',7);
    # used by ind()/G&toLines for small things
    
    $h = G&Cye,['lem',3];
    i $h/incida/Lapt
    $La = ays&s[0];
    Lac&code = &coin{ 1 + 4 };
    Las&dol = {fe:3,go:{la:{pic:&coin{ 1 + 4 }}}};
    o $h/**
    a("no T.enj_catch, simply vanishes");
    
    T.enj_catch = [];
    a("T.enj_catch gets warning, last bit of path");
    empty_catch();
    
    
    t('yaml',7);
    #   catch/T.eny_catch=[] pushed Function warnings
    
    i $h/-incida
    i $h/beolo
    $be = ays&s[0];
    bes&zo = [{P:1},[null,null,['re',{thing:&s{ 2 }}]]];
    o $h/**
    a("no T.eny_catch, blows up");
    T.eny_catch = [];
    a("T.eny_catch, returned munt");
    empty_catch();
    
    
    
    a('','');
    
    t("eny() no T.eny_catch, 2 troubles, blows up");
    bes&doubley = &be{ 2 };
    tryeny(be);
    
    t("eny() T.eny_catch, 3 troubles, returned munt");
    bes&trippple = &be{ 2 };
    $satch = T.eny_catch = [];
    tryeny({Steve:{was:{here:be}}});
    
    T.eny_catch and throw "catch still"
    T.eny_catch = satch;
    t("eny() T.eny_catch must start empty");
    tryeny({more:be});
    
    #   skipCode                Functions vanish
    T.eny_catch and throw "catch still"
    T.eny_opt = {skipCode:1};
    t("eny() T.eny_opt passes skipCode, Functions vanish");
    tryeny({za:2,za:be,ohbythe:'null'});
    
    #   culdesacs=[]         many path=[k+] to tips
    # < would be better in that nz format...
    $cul = [];
    T.eny_opt = {skipCode:1,culdesacs:cul};
    t("eny() skipCode + culdesacs");
    tryeny({za:2,za:be,ohbythe:[2,2,[{sal:'ia'}]],be});
    anray('culdesac',cul,1);
    
    1s&be = be;
    1s&huh = h;
    a('','');
    
    #c lim
    S 2 (node|depth)_limit
    
    $be = 1s&be;
    !be and throw "losing marbles"
    
    #   dryrun                 recon only, fast size check
    #     returns internal $state, with .node_count and .depth_max
    t("eny() dryrun");
    $state = eny(be,0,{dryrun:1});
    m node_count  $s:state.node_count
    m depth_max  $s:state.depth_max
    m deepest_path  $s:state.deepest_path.join(',')
    
    $neg = &nl,dl,desc{
        t("limit of "+(nl?"nl="+nl:"")+" "+(dl?"dl="+dl:"")+
            (desc?" - "+desc:"")
        );
        T.eny_opt = {skipCode:1,dl:dl,nl:nl};
        $err;
        $res;
        try{ res = eny(be,T) }
        catch(er){ err = er }
        if (err) {
            m eny_error  $s:ki(err)
            err.tc &&
            m error_tc  $s:err.tc
        }
        else {
            !res and throw "no error or result?"
        }
    };
    
    #   dl/nl                depth/node limit
    #window.enybug = 1;
    neg(0,0,'no limit');
    neg(0,7,'plenty depths');
    neg(10,0,'plenty nodes');
    neg(9,6,'just enough of both');
    #debugger;
    neg(0,5,'not enough depths');
    neg(5,0,'not enough nodes');
    neg(55,5,'plenty of nodes, not enough depth');
    neg(4,55,'plenty of depth, not enough nodes');
    
    a('','');
    
    t("a()/ind()'s built in warning system");
    delete a.show.nocatch;
    o 1s&huh/**
    a("limitation from leftover T.eny_opt");
    delete T.eny_opt;
    a("encoding wobblies");
    delete bes&doubley;
    i 1s&huh/afore
    i $be/lala
    i 1s&huh/zafter
    ays&s[0].sc.geo = 43;
    a("add some C, i zafter misses trouble");
    o 1s&huh/**
    a("encoding wobblies less");
    
    
    
    
    S 0
    a.fin();
t/BuildACastle: | # test Duning and io
    'Doming iooia'.split(' ').map(&s{ G&waylay,s });
    $a = G&way,'t/ool',ar;
    $io = A&io;
    io.dotw = 1;
    
    S 1 setup, first
    $h = A.R = 1s&ooo = G&Cye,['how'];
    $ghos = 'jit inc room'.split(' ');
    S Ghsot: i ghost/@#$ghos
        if (ghos.t == 'jit') {
            ghosc&s = <<'';
            g.n('sheep',3,{},'hue:54deg,fs:200%');
            g.n('loge',4,{},'hue:154deg,fs:230%');
            // hereish
        
            ghoss&dige = dig(ghosc&s);
        }
        # etc
    S
    
    i travel/room
    
    i wormhole/room
    
    $g = 1s&ggg = {};
    g.n = &t,y,c,sc{
        g.perc[g.who].push(G&Cye,[t,y,c,sc])
    };
    g.t = &s,t{
        $thing = s+'/'+t;
        # < keeping up to date with a remote
        if (s == 'w') {
            # < should look in W ghost and its 
            $w = h.y.tw.ghost.y.tw[t];
            if (!w) {
                g.who != 'ope' and return g.be('ope',t);
                throw "no ope, no "+thing
            }
            # we eval, they cache, trust (s,dige) <-> (code,dige)
            $code = wc&code && wc&dige == ws&dige && wc&code;
            if (!code) {
                $pin = t.replace(/\W/g,'')+ws&dige;
                code = 'wc&code = function '+pin+"(A,C,G,T,g){\n"+wc&s+"}";
                try{ eval(code) }
                catch(er){
                    # eval(lacode) on the console to see the line...
                    window.lacode = code;
                    # nice coupling of ghost<->explosion
                    g.er = ['compile',w,er];
                }
                !g.er and wc&dige = ws&dige;
            }
            return w
        }
        else {
            throw "What other t s? "+s
        }
    };
    g.out ||= {}; # everyone t's themselves
    g.err = []; # complaints
    g.be = &se{
        $was = g.who; # stack
        g.who = s; # its being the J
        g.perc ||= []; # in progress
        $N = g.perc[g.who] = []; # ground
        # > networked names: land.names.self
        $t = g.who.match(/([\/\w]+)$/)[0];
        # J5 - G&t/compile
        $w = g.t('w',t);
        # J6 - doing dome(s)
        if (!g.er) {
            try{ wc&code(A,C,G,T,g) }
            catch(er){ g.er = ['J6',w,er] }
        }
        # J7 - (s)ituation oscillates
        if (!g.er) {
            # the oscillator - put on 9, think?, store
            $nine = G&Cye,[t,9,{},{z:g.perc[g.who]}];
            
            try{ g.oscthink && g[g.oscthink](nine) }
            catch(er){ g.er = ['J7',w,er] }
            g.out[g.who] = nine;
        }
        # J8 - what happened/blewup
        if (g.er) {
            # make [where,way,er] into C for unification
            # < re travel
            $ti = g.who+' @ '+g.er[0];
            $er = G&Cye,[ti,8,{s:g.er[2]+''},{w:g.er[1],er:g.er[2]}];
            g.err.push(er);
            delete g.er;
        }
        # J9 - go back outside
        g.who = was;
    };
    #c and...
    a.d('**',[]);
    #a("Fresh instance")
    
    # < not to be reindexed, compulsory upstream to z/etc
    #   be other than tw with the same shape
    # < inflate nonC in it?
    i wormhole/stdout
    ays&s[0].y.tw = g.out;
    # < not to be transferred to tv....
    i travel/stderr
    ays&s[0].sc.z = g.err;
    
    
    g.be('jit');
    $i = g.out.jit;
    a.debog = 1;
    a.d("Ohlook, jit & stderr/out turned up");
    #   < io should z's
    #   < 9 should c&s ascii art
    #     separation of style/content about keeping crypto
    # < J5 most (knowable) asyncing/res-readying
    
    # 
    S 2 figura
    #   < make a T.../T thing a try enveloper
    $h = A.R = 1s&ooo;
    # < to be ar set by local remem
    $g = 1s&ggg;
    o ghost/jit
    
    $j = ays&s[0];
    jc&s = jc&s.replace(/\/\/ hereish\n/,"There's bits\n// hereish\n");
    
    $i = g.out.jit;
    #debugger;
    a.d("Anything?");
    
    
    S 0
    a.fin();
    
    
    
    
    
    
    
    
    # environ a thing Duning (non sequence) sequence
    # osc domes, concat them into this J
    # here be test data and... floots
t/BAC: | # alana
    # shunt system, maniable
    $io = G&way,'iooia';
    $F = io.F;
    
    
    
    # do thinking
    
    # jig new language
    
    # show G&t into 1s&in properly
    
    
    
    
    
    
    
    
    
    
    
    
    # 
PseudoF: | # to develop limbs to G&F
    # see also fe/fi ...
        $m;
        $p = &r{
            m = d.match(r);
            !m and return
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        $dstart = d;
        $v;
        
        # all Array of items, assume the spec also de-arrays it
        s.constructor == Object and s = [s];
        
        if (p(/^\* ?/)) {
            $S = s;
            s = [];
            each in S {
                if (ns&J) {
                    $j = ns&J;
                    !j and continue
                    $os = js&s;
                    !os and continue;
                    # skips over 9
                    $t = oss&top;
                    !t || !ts&z and continue;
                    ts&z.map(&z{
                        s.push(z);
                    });
                }
                else {
                    continue
                }
            }
        }
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ 
                s && s[nk] && s[nk][gk] != null and v = s[nk][gk]; return 1
            });
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s
        

