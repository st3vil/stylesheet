TripDeck: | # note vortex, holder of diverse brief moments, bakes patterns into info
    $h = G&heading,'55';
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # piling stuff up
    =head
      TD
      to start raying together ghost/wormholes and travel
      so change becomes a crawling shadow,
        io doing it,
        also (a simpler)? io bringing in the first bunch of code
        being non-throaty
        maybe thro/G&U
      
      taking errors, runs
      and io lugging the outyrageous warm shadow
        finding tests to run,
        depending on the concentricism of W around it
      
      would be worth finishing these tests tho...
        have to have pressurised angles to find breaking points
      
      ten it should bes, 11 would bes, 12 could bes?
        search/find and plant on memories forever more?
      
      hammering facts, talking heads
      and now was a good time to stop
      but, varta
      bit seeker while bits restart about
      
      
      to be a sort of terminal... fuzzing trees, pushing
      want some key aiming,
        G should freeze time and give then fairly safely to A.4,
          who has moments to respond before A.5 blows it away to try again
        and all those Elvis vector things...
        following requests all the way through
    
    =BunchCrunch
      #msgs is getting composted in -rogram
        sequentia shall io make
      Duning and Doming are the same thing...
        Duning implies sleep when still, but so could Doming if !number
        either wants S !domeproper for iteration:
        S o queue/:w
          $w one by one code
        shall indented S be subnetted? ya. make em fractions.
          redo Doming with objects, step+1 doesnt clever
        
      S 5 desire changes
        # etc
        that should be able to handle doing jobs interrupted
        everything A:oing what might be changing
          the generosity/paranoia of those wake/sleep diff scans
          is very test-honed
        M y cvs 0.300dome00sequ ..?
          find out how to overload in js, many-decimal points that ><-
      
      and geometry! through io/F
      
      way that Babz locally (on 4),
        or do just the most weighty Babz there
      
      the way is fundamentally about how to hold the stuff that code was
        as its use changes, it is born in a magma holder, to drain mystery,
        cell-divide and grow into a known I thing, probably
      
      so run a little way village with io...
        virtualise some dream to do so
      
        
      
      
    
      teach perl/js via Thangers on:
        t.rows.indexOf(t.row)+' . '+t.i+'  '+ki(t.ar,6.23)+'        '+ki(t.next,2)
      watching is a goof, a drunk, a nun and a young programmer
        perl:   say =~ s/^\{|\}$/sg;
        js:     say = say.replace(/^\{|\}$/g,'');
      
    =Babz
    
       - do some stuff in javascript! the messiest and easiest things
       - n... wants loose t that concats $vars, so we can type endlessly
         until:
         since cv is always -jod or \d (or W)
         y can say :W instead of W, one c&thing == C.t could odify like that
           maybe more if the boundary is not text but a bubble
           when everything similarity matches itself
             and stretches tendons of divergence
      
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        NotInIf
      ; matters much for no reason
      brackets also
      filigree?
      
      =cut
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
StayToSleep: | # gentleness scan
    # 
t/ool: | # the usual io check maker
    G&heading;
    $io = G&way,'iooia';
    #1s&step = 2;
    G&way,'Doming',ar;
    
    $show = {};
    show.talk = 1;
    $a = &t,talk,params{
        if (t === '' && !talk) {
            m space   %fs:120%,hue:170deg,width:100%,height:3em,dis:block
            return
        }
        if (t == 'bug') {
            m bugreport  $s:talk %fs:120%,hue:170deg,dis:block
            return;
        }
        if (t == '9') {
            m speech  $s:talk %hue:100deg,dis:block,fs:140%
            return;
        }
        if (t == '7') {
            # right hand hanging talk
            m talk  $s:talk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
            return;
        }
        t && io[t](talk,params||[],{})
        t = io.nz();
        
        $iis;
        $rowtalk = &S{
            $i = 5;
            while (S && !S.is && i-- > 0) { S = S.plumb }
            S = S.is && S;
            iis = S;
            S and return S.is+' '+S.talk
        };
        
        if (show.talk) {
            # i chainlinked behind lastfuncs
            $bits = [rowtalk(t)];
            # o chainlinked behind firstfuncs
            iis && iis.plumb and bits.push(rowtalk(iis.plumb));
            $tk = bits.join(' ');
            m talk  $s:tk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
        }
        
        m thistest  $s:talk %fs:160%,hue:120deg,dis:block
        
        show.t &&
        m iter  $s:t,dl:9.26
        
        !show.impartial and t.partial = 1;
        $s = t.ind(&s,t{
            $text = io.isC(s) ? G&toLines,s : "GARB: "+ki(s);
            if (t.objects && t.objects.indexOf(s) >= 0) {
                # highlight t.objects (that doof matched)
                # < chucking rows with any object on matching
                # iterate objects if that's all you want
                text = G&intag:'>1 '+text
            }
            if (show.y) {
                # attach y, which hides most first
                $say = ki(s.y,6.24);
                say = say.replace(/^\{|\}$/g,'');
                text += "\t"+G&intag:'>3 '+say;
            }
            return text;
        }).join("\n");
        s += "\n";
        m inds  $s:s,ht:1 %hue:120deg,ws:pre,dis:block
        # lum for dumping state
        t.p = 'usual';
        return d
    };
    $nz = &show,{
        $t = io.nz();
        t.partial = 1;
        t.ungrouped = 1;
        while (show && t.more()) {
            m apull  $s:t.sc,dl:8.26
            m srow  $s:t.row,dl:8.26
        }
        return t
    };
    a.nz = nz;
    a.show = show;
    
    a.fin = &{
        each in M {
            ns&hue || ns&pi and continue
            nc&pi = 'fod';
            ns&dos = 'grow';
            nc&dl ||= 12;
        }
    };
    return a
t/BuildACastle: | # test Duning and io
    'Doming iooia'.split(' ').map(&s{ G&waylay,s });
    $a = G&way,'t/ool';
    $io = A&io;
    io.dotw = 1;
    
    S 1 setup, first
    $h = 1s&ooo = G&Cye,['how'];
    debugger;
    $ghos = 'jit inc room'.split(' ');
    S Ghsot: i $h/ghost/@#$ghos
        if (ghos.t == 'jit') {
            ghosc&s = <<'';
                g.n('sheep',3,{},'&hue:54deg,fs:200%');
        
            ghoss&dige = dig(ghosc&s);
        }
        # etc
    S
    
    i $h/travel/room
    
    i $h/wormhole/room
    
    $g = {};
    g.n = &t,y,c,sc{
        g.perc[g.who].push(G&Cye,[t,y,c,sc])
    };
    g.be = &se{
        $was = g.who; # stack
        g.is ||= {}; # everyone
        $er = null; # any emergency
        g.who = s; # its being the J
        g.perc ||= []; # in progress
        $N = g.perc[g.who] = []; # ground
        # > networked names: land.names.self
        $t = g.who.match(/([\/\w]+)$/)[0];
        # G&t and compile
        $w = h.y.tw.ghost.y.tw[t];
        !w && g.who != 'ope' and return g.be('ope',t);
        # we eval, they cache, trust (s,dige) <-> (code,dige)
        $code = wc&code && wc&dige == ws&dige && wc&code;
        if (!code) {
            $pin = t.replace(/\W/g,'')+ws&dige;
            code = 'wc&code = function '+pin+"(A,C,G,T,g){\n"+wc&s+"}";
            try{ eval(code) }
            catch(er){
                # eval(lacode) on the console to see the line...
                window.lacode = code;
                # nice coupling of ghost<->explosion
                g.er = ['compile',w,er];
            }
            if (!g.er) {
                wc&dige = ws&dige;
                code = wc&code;
            }
        }
        if (!er) {
            # the dome!
            try{ code(A,C,G,T,g) }
            catch(er){ g.er = ['J6',w,er] }
        }
        if (!er) {
            # the oscillator - put on 9, think?, store
            $nine = G&Cye,[t,9,{},{z:g.perc[g.who]}];
            
            try{ g.oscthink && g[g.oscthink](nine) }
            catch(er){ g.er = ['J7',w,er] }
            g.is[g.who] = nine;
        }
        g.er and (g.ers ||= []).push(g.er); delete g.er;
        g.who = was;
    };
    # and take the first look
    g.be('jit');
    $i = g.is.jit;
    o $i/**
    a(0,"Ohlook")
    # < io should z's
    # < 9 should c&s ascii art
    #     separation of style/content about keeping crypto
    
    S 2
    # < make a T.../T thing a try enveloper
    
    o $i/**
    a(0,"Ohlook")
    
    
    S 0
    a.fin();
    
    
    
    
    
    
    
    
    # environ a thing Duning (non sequence) sequence
    # osc domes, concat them into this J
    # here be test data and... floots
t/BAC: | # alana
    # shunt system, maniable
    $io = G&way,'iooia';
    $F = io.F;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # 
PseudoF: | # to develop limbs to G&F
    # see also fe/fi ...
        $m;
        $p = &r{
            m = d.match(r);
            !m and return
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        $dstart = d;
        $v;
        
        # all Array of items, assume the spec also de-arrays it
        s.constructor == Object and s = [s];
        
        if (p(/^\* ?/)) {
            $S = s;
            s = [];
            each in S {
                if (ns&J) {
                    $j = ns&J;
                    !j and continue
                    $os = js&s;
                    !os and continue;
                    # skips over 9
                    $t = oss&top;
                    !t || !ts&z and continue;
                    ts&z.map(&z{
                        s.push(z);
                    });
                }
                else {
                    continue
                }
            }
        }
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ 
                s && s[nk] && s[nk][gk] != null and v = s[nk][gk]; return 1
            });
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s
        

