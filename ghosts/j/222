TripDeck: | # note vortex, holder of diverse brief moments, bakes patterns into info
    $h = G&heading,'55';
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # piling stuff up
    =head
      TD
      to start raying together ghost/wormholes and travel
      so change becomes a crawling shadow,
        io doing it,
        also (a simpler)? io bringing in the first bunch of code
        being non-throaty
        maybe thro/G&U
      
      taking errors, runs
      and io lugging the outyrageous warm shadow
        finding tests to run,
        depending on the concentricism of W around it
      
      would be worth finishing these tests tho...
        have to have pressurised angles to find breaking points
      
      ten it should bes, 11 would bes, 12 could bes?
        search/find and plant on memories forever more?
      
      hammering facts, talking heads
      and now was a good time to stop
      but, varta
      bit seeker while bits restart about
      
      
      to be a sort of terminal... fuzzing trees, pushing
      want some key aiming,
        G should freeze time and give then fairly safely to A.4,
          who has moments to respond before A.5 blows it away to try again
        and all those Elvis vector things...
        following requests all the way through
    
    =BunchCrunch
      #msgs is getting composted in -rogram
        sequentia shall io make
      Duning and Doming are the same thing...
        Duning implies sleep when still, but so could Doming if !number
        either wants S !domeproper for iteration:
        S o queue/:w
          $w one by one code
        shall indented S be subnetted? ya. make em fractions.
          redo Doming with objects, step+1 doesnt clever
        
      S 5 desire changes
        # etc
        that should be able to handle doing jobs interrupted
        everything A:oing what might be changing
          the generosity/paranoia of those wake/sleep diff scans
          is very test-honed
        M y cvs 0.300dome00sequ ..?
          find out how to overload in js, many-decimal points that ><-
      
      and geometry! through io/F
      
      way that Babz locally (on 4),
        or do just the most weighty Babz there
      
      the way is fundamentally about how to hold the stuff that code was
        as its use changes, it is born in a magma holder, to drain mystery,
        cell-divide and grow into a known I thing, probably
      
      so run a little way village with io...
        virtualise some dream to do so
      
        
      
      
    
      teach perl/js via Thangers on:
        t.rows.indexOf(t.row)+' . '+t.i+'  '+ki(t.ar,6.23)+'        '+ki(t.next,2)
      watching is a goof, a drunk, a nun and a young programmer
        perl:   say =~ s/^\{|\}$/sg;
        js:     say = say.replace(/^\{|\}$/g,'');
      
    =Babz
    
       - do some stuff in javascript! the messiest and easiest things
       - n... wants loose t that concats $vars, so we can type endlessly
         until:
         since cv is always -jod or \d (or W)
         y can say :W instead of W, one c&thing == C.t could odify like that
           maybe more if the boundary is not text but a bubble
           when everything similarity matches itself
             and stretches tendons of divergence
      
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        NotInIf
      ; matters much for no reason
      brackets also
      filigree?
      
      =cut
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
StayToSleep: | # gentleness scan
    # 
t/ool: | # the usual io check maker
    G&heading;
    $io = G&way,'iooia';
    #1s&step = 2;
    G&way,'Doming',ar;
    
    $show = {};
    show.talk = 1;
    $a = &talk,t,params{
        if (t === '' && !talk) {
            m space   %fs:120%,hue:170deg,width:100%,height:3em,dis:block
            return
        }
        if (t == 'bug') {
            m bugreport  $s:talk %fs:120%,hue:170deg,dis:block
            return;
        }
        if (t == '9') {
            m speech  $s:talk %hue:100deg,dis:block,fs:140%
            return;
        }
        if (t == '8') { # normal test title
            m thistest  $s:talk %fs:160%,hue:120deg,dis:block
            return;
        }
        if (t == '7' || t == '6') {
            # right hand hanging talk
            $c =
            m talk  $s:talk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
            cs&fs = '420%';
            delete cs&float;
            return;
        }
        t && io[t](talk,params||[],{})
        t = io.nz();
        
        $iis;
        $rowtalk = &S{
            $i = 5;
            while (S && !S.is && i-- > 0) { S = S.plumb }
            S = S.is && S;
            iis = S;
            S and return S.is+' '+S.talk
        };
        
        if (show.talk) {
            # i chainlinked behind lastfuncs
            $bits = [rowtalk(t)];
            # o chainlinked behind firstfuncs
            iis && iis.plumb and bits.push(rowtalk(iis.plumb));
            $tk = bits.join(' ');
            m talk  $s:tk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
        }
        
        m thistest  $s:talk %fs:160%,hue:120deg,dis:block
        
        show.t &&
        m iter  $s:t,dl:9.26
        
        !show.impartial and t.partial = 1;
        $cb = &s,t{
            $text;
            if (isC(s)) {
                $code = sc&code;
                delete sc&code;
                # definitely need a munt beacon + warning
                G.enybug and debugger;
                text = G&toLines,s;
                code and sc&code = code
            }
            else {
                text = "GARB: "+ki(s);
            }
            if (t.objects && t.objects.indexOf(s) >= 0) {
                # highlight t.objects (that doof matched)
                # < chucking rows with any object on matching
                # iterate objects if that's all you want
                text = G&intag:'>1 '+text
            }
            if (show.y) {
                # attach y, which hides most first
                $say = ki(s.y,6.24);
                say = say.replace(/^\{|\}$/g,'');
                text += "\t"+G&intag:'>3 '+say;
            }
            return text;
        };
        $s;
        try { s = t.ind(cb).join("\n") }
        catch(er) {
            $balk = "Error calling ind()";
            m error_calling_ind  $s:balk %hue:100deg,dis:block,fs:140%
            m indBANG  $s:er.message %fs:130%,hue:170deg,dis:block
            m error_tc  $s:er.tc
            return
        }
        s += "\n";
        m inds  $s:s,ht:1 %hue:120deg,ws:pre,dis:block
        # could do a node count or so?
        t.p and t.p = 'snip';
        return t
    };
    $nz = &show,{
        $t = io.nz();
        t.partial = 1;
        t.ungrouped = 1;
        while (show && t.more()) {
            m apull  $s:t.sc,dl:8.26
            m srow  $s:t.row,dl:8.26
        }
        return t
    };
    a.nz = nz;
    a.show = show;
    
    a.fin = &{
        each in M {
            ns&hue || ns&pi and continue
            nc&pi = 'fod';
            ns&dos = 'grow';
            nc&dl ||= 12;
        }
    };
    return a
t/encodings: | # test yaml
    'Doming iooia'.split(' ').map(&s{ G&waylay,s });
    $a = G&way,'t/ool',ar;
    $io = A&io;
    $t = &title,ty{ a(title,ty||8) }
    
    $tryeny = &s{
        $err;
        $yam;
        try{ yam = eny(s,T) }
        catch(er) {
            err = er;
        }
        if (err) {
            m eny_error  $s:ki(err)
            err.tc &&
            m error_tc  $s:err.tc
        }
        
        m eny_encoded  $s:ki(yam)
        
        yam &&
        m dey_eny  $s:dey(yam)
        
        empty_catch();
        return yam
    };
    
    S 1 encoding functions
    
    $anray = &tsl{
        each in s {
            $tio = t+"["+i+"]";
            l and n = n.join(',');
            m $tio  $s:n
        }
    };
    $empty_catch = &{
        $t = T.eny_catch ? "T.eny_catch" :
            T.enj_catch ? "T.enj_catch" : '';
        !t and return
        $s = T.enj_catch || T.eny_catch;
        delete T.enj_catch; delete T.eny_catch;
        anray(t,s);
    };
    
    t('json',7);
    # used by ind()/G&toLines for small things
    
    $h = G&Cye,['lem',3];
    i $h/incida/Lapt
    $La = ays&s[0];
    Lac&code = &coin{ 1 + 4 };
    Las&dol = {fe:3,go:{la:{pic:&coin{ 1 + 4 }}}};
    o $h/**
    a("no T.enj_catch, simply vanishes");
    
    T.enj_catch = [];
    a("T.enj_catch gets warning, last bit of path");
    empty_catch();
    
    
    t('yaml',7);
    #   catch/T.eny_catch=[] pushed Function warnings
    
    i $h/-incida
    i $h/beolo
    $be = ays&s[0];
    bes&zo = [{P:1},[null,null,['re',{thing:&s{ 2 }}]]];
    o $h/**
    a("no T.eny_catch, blows up");
    T.eny_catch = [];
    a("T.eny_catch, returned munt");
    empty_catch();
    
    
    
    a('','');
    
    t("eny() no T.eny_catch, 2 troubles, blows up");
    bes&doubley = &be{ 2 };
    tryeny(be);
    
    t("eny() T.eny_catch, 3 troubles, returned munt");
    bes&trippple = &be{ 2 };
    $satch = T.eny_catch = [];
    tryeny({Steve:{was:{here:be}}});
    
    T.eny_catch and throw "catch still"
    T.eny_catch = satch;
    t("eny() T.eny_catch must start empty");
    tryeny({more:be});
    
    #   skipCode                Functions vanish
    T.eny_catch and throw "catch still"
    T.eny_opt = {skipCode:1};
    t("eny() T.eny_opt passes skipCode, Functions vanish");
    tryeny({za:2,za:be,ohbythe:'null'});
    
    #   culdesacs=[]         many path=[k+] to tips
    $cul = [];
    T.eny_opt = {skipCode:1,culdesacs:cul};
    t("eny() skipCode + culdesacs");
    tryeny({za:2,za:be,ohbythe:[2,2,[{sal:'ia'}]],be});
    anray('culdesac',cul,1);
    
    1s&be = be;
    a('','');
    
    #c (node|depth)_limit
    S 2 (node|depth)_limit
    
    $be = 1s&be;
    !be and throw "losing marbles"
    
    #   dryrun                 recon only, fast size check
    #     returns internal $state, with .node_count and .depth_max
    t("eny() dryrun");
    $state = eny(be,0,{dryrun:1});
    m node_count  $s:state.node_count
    m depth_max  $s:state.depth_max
    m deepest_path  $s:state.deepest_path.join(',')
    
    $neg = &nl,dl,desc{
        t("limit of "+(nl?"nl="+nl:"")+" "+(dl?"dl="+dl:"")+
            (desc?" - "+desc:"")
        );
        T.eny_opt = {skipCode:1,dl:dl,nl:nl};
        $err;
        $res;
        try{ res = eny(be,T) }
        catch(er){ err = er }
        if (err) {
            m eny_error  $s:ki(err)
            err.tc &&
            m error_tc  $s:err.tc
        }
        else {
            !res and throw "no error or result?"
        }
    };
    
    #   dl/nl                depth/node limit
    #window.enybug = 1;
    neg(0,0,'no limit');
    neg(0,7,'plenty depths');
    neg(10,0,'plenty nodes');
    neg(9,6,'just enough of both');
    #debugger;
    neg(0,5,'not enough depths');
    neg(5,0,'not enough nodes');
    neg(55,5,'plenty of nodes, not enough depth');
    neg(4,55,'plenty of depth, not enough nodes');
    
    S 0
    a.fin();
t/BuildACastle: | # test Duning and io
    'Doming iooia'.split(' ').map(&s{ G&waylay,s });
    $a = G&way,'t/ool',ar;
    $io = A&io;
    io.dotw = 1;
    ys&ml = '1em';
    
    S 1 setup, first
    $h = 1s&ooo = G&Cye,['how'];
    $ghos = 'jit inc room'.split(' ');
    S Ghsot: i $h/ghost/@#$ghos
        if (ghos.t == 'jit') {
            ghosc&s = <<'';
            g.n('sheep',3,{},'hue:54deg,fs:200%');
            g.n('loge',4,{},'hue:154deg,fs:230%');
            throw "aparty"
        
            ghoss&dige = dig(ghosc&s);
        }
        # etc
    S
    
    i $h/travel/room
    
    i $h/wormhole/room
    
    $g = 1s&ggg = {};
    g.n = &t,y,c,sc{
        g.perc[g.who].push(G&Cye,[t,y,c,sc])
    };
    g.t = &s,t{
        $thing = s+'/'+t;
        # < keeping up to date with a remote
        if (s == 'w') {
            # < should look in W ghost and its 
            $w = h.y.tw.ghost.y.tw[t];
            if (!w) {
                g.who != 'ope' and return g.be('ope',t);
                throw "no ope, no "+thing
            }
            # we eval, they cache, trust (s,dige) <-> (code,dige)
            $code = wc&code && wc&dige == ws&dige && wc&code;
            if (!code) {
                $pin = t.replace(/\W/g,'')+ws&dige;
                code = 'wc&code = function '+pin+"(A,C,G,T,g){\n"+wc&s+"}";
                try{ eval(code) }
                catch(er){
                    # eval(lacode) on the console to see the line...
                    window.lacode = code;
                    # nice coupling of ghost<->explosion
                    g.er = ['compile',w,er];
                }
                !g.er and wc&dige = ws&dige;
            }
            return w
        }
        else {
            throw "What other t s? "+s
        }
    };
    g.ers = [];
    g.be = &se{
        $was = g.who; # stack
        g.is ||= {}; # everyone
        g.who = s; # its being the J
        g.perc ||= []; # in progress
        $N = g.perc[g.who] = []; # ground
        # > networked names: land.names.self
        $t = g.who.match(/([\/\w]+)$/)[0];
        # J5 - G&t/compile
        $w = g.t('w',t);
        # J6 - doing dome(s)
        if (!g.er) {
            try{ wc&code(A,C,G,T,g) }
            catch(er){ g.er = ['J6',w,er] }
        }
        # J7 - (s)ituation oscillates
        if (!g.err) {
            # the oscillator - put on 9, think?, store
            $nine = G&Cye,[t,9,{},{z:g.perc[g.who]}];
            
            try{ g.oscthink && g[g.oscthink](nine) }
            catch(er){ g.er = ['J7',w,er] }
            g.is[g.who] = nine;
        }
        # J8 - what happened/blewup
        if (g.er) {
            # make [where,way,er] into C for unification
            # < re travel
            $ti = g.who+' @ '+g.er[0];
            $er = G&Cye,[ti,8,{s:g.er[2]+''},{w:g.er[1],er:g.er[2]}];
            g.ers.push(er);
            delete g.er;
        }
        # J9 - go back outside
        g.who = was;
    };
    # and take the first look
    g.be('jit');
    $i = g.is.jit;
    o $i/**
    a("Ohlook, jit")
    # < io should z's
    # < 9 should c&s ascii art
    #     separation of style/content about keeping crypto
    # < J5 most (knowable) asyncing/res-readying
    
    # 
    S 2
    # < make a T.../T thing a try enveloper
    $h = 1s&ooo;
    $g = 1s&ggg;
    # < not to be reindexed
    #   be other than tw with the same shape
    i $h/wormhole/g_is
    ays&s[0].y.tw = g.is;
    # < not to be transferred to tv....
    i $h/travel/g_ers
    ays&s[0].sc.z = g.ers;
    S
    $i = g.is.jit;
    #debugger;
    o $h/**
    a("Entirety")
    
    
    S 0
    a.fin();
    
    
    
    
    
    
    
    
    # environ a thing Duning (non sequence) sequence
    # osc domes, concat them into this J
    # here be test data and... floots
t/BAC: | # alana
    # shunt system, maniable
    $io = G&way,'iooia';
    $F = io.F;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # 
PseudoF: | # to develop limbs to G&F
    # see also fe/fi ...
        $m;
        $p = &r{
            m = d.match(r);
            !m and return
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        $dstart = d;
        $v;
        
        # all Array of items, assume the spec also de-arrays it
        s.constructor == Object and s = [s];
        
        if (p(/^\* ?/)) {
            $S = s;
            s = [];
            each in S {
                if (ns&J) {
                    $j = ns&J;
                    !j and continue
                    $os = js&s;
                    !os and continue;
                    # skips over 9
                    $t = oss&top;
                    !t || !ts&z and continue;
                    ts&z.map(&z{
                        s.push(z);
                    });
                }
                else {
                    continue
                }
            }
        }
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ 
                s && s[nk] && s[nk][gk] != null and v = s[nk][gk]; return 1
            });
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s
        

