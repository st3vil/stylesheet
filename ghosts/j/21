NutSeq: | # self
    n NutAye
    n NutSea
    n NutTub
NutAye: | # A without tubeyness
    u j
    n \'of:eye'
    # begin being, A
    # they can take over names within their network
    #   // slopa, as def NutCore
    #   A.om ||= A;
    #   A.om == A.up and A.mo = A;
    #   but such a name may need update as B (sub calls) revamp
    # also drops A.V for verbose, use T
    Aye: %acgt:s ov c sc
        if (s && typeof s == 'object') {
            A = s;
        }
        else {
            $V = A;
            A = $.extend({},A);
            A.t = s;
            A.y = A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            
            A.up = V;
            A&ip = (upA&ip||[]).slice(0);
            upA&ipi ||= 0;
            A&ip.push(upA&ipi++);
            A&sip = A&ip.join(' ');
            
            // trip A
        }
        c and $.extend(A.c,c);
        sc and $.extend(A.sc,sc);
        
        if (ov && ov*1 == ov) {
            A&ov = G&sca,ov;
            G&thro;
        }
        return A
    
    # utils/inlineables
    #  is cv=0 allowed?
    sca: %acgt:s precision
        s && s*1 != s and return
        while (s >= 1)
            s /= 10
        return s.toPrecision(precision || 4)
    
    # descript/mapself
    
    
NutSea: | # line etc into C
    u j
    n \'of:eye'
    # 
    # ReadLines, G&m? G&A?
    # guess s={} = C
    # guess s=[] t y c sc, like n t y c sc
    # guess c='Line' or c.s='Line' c.as='z' c.from=upC, 
    #   so lines can have normalcy/decompression
    # the enclosure adds to the C,
    # with respect to the thing holding it, upC, C.y.up
    # putting in its ytv etc
    # C.t != null
    # where should C.y.cv ||= 0.1?
    # doesn't y.A=A, n 1 does
    Cye: %acgt:s c
        $C = {};
        if (s.constructor == Object) {
            if (null != s.t && s.y && s.c && s.sc) {
                C.t = s.t;
                C.y={};C.c={};C.sc={};
                $.extend(C.y,s.y);
                $.extend(C.c,s.c);
                $.extend(C.sc,s.sc);
                return C
            }
            else {
                throw "Unhandle hash C: ", s
            }
        }
        else
        if (s.constructor == Array) {
            C.t = s[0];
            C.y = s[1];
            C.c = s[2];
            C.sc = s[3];
            typeof C.c  === 'string' and C.c =  G&peel,C.c
            typeof C.sc === 'string' and C.sc = G&peel,C.sc
            // < extra -pi
        }
        
        !typeof C.t === 'string' and throw "Non string t: ", C;
        
        if (typeof C.y == 'string' || typeof C.y == 'number') {
            C.y * 1 != C.y and throw "Non number y left: ", C
            C.y = {cv: C.y };
        }
        C.y.cv < 0 and C.y.cv *= -1;
        C.y.cv > 1 and C.y.cv = G&sca,C.y.cv;
        
        C.c ||= {};
        
        C.sc ||= {};
        return C;
    
    # utils/inlineables
    # peel, xo/xoh
    
    # and a bit of xotila
NutTub: | # A tubeyness
    u j
    n \'of:eye'
    
    # subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO Gc&B stacking
    # TODO G.i.* = A.I.i.y.tw.*.c.code
    hhh: %acgt:s so st sh sf si
        $z = s;
        typeof s === 'string' and z = G.t(A,C,G,T,'i',s);
        typeof s === 'string' && !z and z = G.t(A,C,G,T,'eye',s);
        !z and throw "No way: "+s;
        T.D = z;
        return z.c.code(A,C,G,T,so,st,sh,sf,si);
    
    # do I for C (A&s): go, stop, mode
    # jog job through embryo A.t
    # up to ov
    thro: %acgt:ov sC
        $T = A&T = A&T || {};
        T.not and return
        ov and A&ov = G&sca,ov;
        sC and A&s = sC;
        C = A&s = A&s || {t:'',y:{A:A},c:{},sc:{}};
        $t = G&t,A.t;
        !t and throw "thro no t: "+A.t, A;
        
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            T.not and break
            var D = z;
            z = z.y.next;
            $Acv = A.cv;
            
            A.cv > D.y.cv and continue
            C = A&s;
            if (!D.sc.any) {
                D.sc.nk and !C[D.sc.nk] and continue;
                D.sc.gk and !C[D.sc.nk][D.sc.gk] and continue;
            }
            $es;
            D.sc.gk and es = C[D.sc.nk][D.sc.gk];
            D.sc.s and es = D.sc.s;
            G.h(A,C,G,T,D,es);
            T.N and A.cv = 1; 1s&N
            T.not == '2' and return delete T.not;
            Acv == A.cv and A.cv = D.y.cv;
        }
        return !T.not;
    

