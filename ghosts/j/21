NutSeq: | # self
    n NutAye
    n NutSea
    n NutTub
NutAye: | # A without tubeyness
    u j
    n \'of:eye'
    # begin being, A
    # they can take over names within their network
    #   // slopa, as def NutCore
    #   A.om ||= A;
    #   A.om == A.up and A.mo = A;
    #   but such a name may need update as B (sub calls) revamp
    # also drops A.V for verbose, use T
    Aye: %acgt:s ov c sc
        if (s && typeof s == 'object') {
            A = s;
        }
        else {
            $V = A;
            A = $.extend({},A);
            A.t = s;
            A.y = A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            
            A.up = V;
            A&ip = (upA&ip||[]).slice(0);
            upA&ipi ||= 0;
            A&ip.push(upA&ipi++);
            A&sip = A&ip.join(' ');
            
            // trip A
        }
        c and $.extend(A.c,c);
        sc and $.extend(A.sc,sc);
        
        if (ov && ov*1 == ov) {
            A&ov = G&sca,ov;
            G&thro;
        }
        return A
    
    # utils/inlineables?
    # descript/mapself?
    
    
NutSea: | # line etc into C
    u j
    n \'of:eye'
    # 
    # ReadLines, G&m? G&A?
    # guess s={} = C
    # guess s=[] t y c sc, like n t y c sc
    # guess c='Line' or c.s='Line' c.as='z' c.from=upC, 
    #   so lines can have normalcy/decompression
    # the enclosure adds to the C,
    # with respect to the thing holding it, upC, C.y.up
    # putting in its ytv etc
    # C.t != null
    # where should C.y.cv ||= 0.1?
    # doesn't y.A=A, n 1 does
    Cye: %acgt:s c
        $C = {};
        if (s.constructor == Object) {
            if (null != s.t && s.y && s.c && s.sc) {
                $C = {y:{},c:{},sc:{}};
                C.t = s.t;
                $.extend(C.y,s.y);
                $.extend(C.c,s.c);
                $.extend(C.sc,s.sc);
                return C
            }
            else {
                throw "Unhandle hash C: ", s
            }
        }
        else
        if (s.constructor == Array) {
            C.t = s[0];
            C.y = s[1];
            C.c = s[2];
            s.length == 1 and C.c = {W:C.t}
            C.sc = s[3];
            typeof C.c  === 'string' and C.c =  G&peel,C.c
            typeof C.sc === 'string' and C.sc = G&peel,C.sc
            // < extra -pi
        }
        
        !typeof C.t === 'string' and throw "Non string t: ", C;
        
        C.c ||= {};
        
        C.sc ||= {};
        
        if (typeof C.y == 'string' || typeof C.y == 'number') {
            $i = 1
            while (C.y * 1 != C.y) {
                i++ > 5 and throw "MAAANY";
                # to W other than C.t? call extra parsers?
                $t   = /^([a-z0-9\/]+)($|_)/i;
                $pi = /^-([a-z0-9\/]+)($|_)/i;
                if (C.y.match(t)) {
                    c&W = C.y.match(t)[1];
                    c&W == 'W' and c&W = C.t;
                    C.y = C.y.replace(t,'');
                }
                else
                if (C.y.match(pi)) {
                    c&pi = C.y.match(pi)[1];
                    C.y = C.y.replace(pi,'');
                }
                else { throw "Non number y left: "+4s&ki(C) }
            }
            C.y = {cv: C.y };
        }
        C.y ||= {};
        C.y.cv < 0 and C.y.cv *= -1;
        C.y.cv > 1 and C.y.cv = G&sca,C.y.cv;
        
        return C;
    
    # utils/inlineables
    # peel, xo/xoh
    
    # and a bit of xotila

    # that is? recurse?
    # checks s for being [] or [['']]
    datam: %acgt:s c
        typeof c == 'string' and c = {s:c};
        c.d ||= 1;
        c.d > 3 and throw "large datam";
        # read the question
        $after = c.s;
        if (c.s.match('^\\[')) {
            after = c.s.replace(/^\[|\]$/g, '');
            c.array = 1
        }
        if (c.s.match("^'")) {
            c.eq = c.s.replace(/^'|'$/g, '');
            after = ''
        }
        c.s = after;
        # make an answer
        if (c.array) {
            !(typeof s == 'object' && s.constructor == Array) and return
        }
        if (c.eq != null) {
            !(typeof s == 'string' || typeof s == 'number') and return
            c.eq != '*' && s != c.eq and return
        }
        !c.s and return 1
        # more inside
        $ss = c.s.split(',');
        # check the size of the next set in
        if (s.length != ss.length) {
            #~diflen: s, ss
            return
        }
        # check each thing
        for (var si in ss) {
            $oc = ss[si];
            $os = s[si];
            oc = {s:oc,d:c.d+1};
            $re = G&datam,os,oc;
            if (!re) {
                #~subfa: os, oc
                return
            }
        }
        return 1
        
NutTub: | # A tubeyness
    u j
    n \'of:eye'
    
    # do I for C (A&s): go, stop, mode
    # jog job through embryo A.t
    # up to ov
    # T.N=2 or T.N.2=? sets A.cv = 2 and 1s&N queue
    thro: %acgt:ov sC
        ov && typeof ov == 'object' and A = ov; ov = null;
        sC && typeof sC == 'number' and ov = sC; sC = null;
        $T = A&T = A&T || {};
        T.not and return
        ov and A&ov = G&sca,ov;
        sC and A&s = sC;
        C = A&s = A&s || {t:'',y:{A:A},c:{},sc:{}};
        $t = G&t,A.t;
        !t and throw "thro no t: "+A.t;
        
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            T.not and break
            $D = z;
            z = z.y.next;
            
            A.cv > D.y.cv and continue
            T.once && A.cv == D.y.cv and continue
            # seek refinds I, resuming from the same D, sub-cv
            T.seek && (T.seek.t != D.t || T.seek.y.cv != D.y.cv) and continue
            else { delete T.seek }
            $Acv = A.cv;
            
            T.N ||= {};
            C = A&s;
            
            if (!D.sc.any) {
                D.sc.nk and !C[D.sc.nk] and continue;
                D.sc.gk and !C[D.sc.nk][D.sc.gk] and continue;
            }
            $es;
            D.sc.gk and es = C[D.sc.nk][D.sc.gk];
            D.sc.s and es = D.sc.s;
            
            # temp? until A.cv decided to be set before doing?
            T.thro = D;
            
            Gc&bugt and debugger;
            G.h(A,C,G,T,D,es);
            
            typeof T.N == 'object' && Object.keys(T.N).length == 0 and delete T.N
            T.N != null and G&TN,T.N; delete T.N
            T.not == '2' and return delete T.not
            Acv == A.cv and A.cv = D.y.cv;
            
            T.whack || T.not || T.seek != null and break
        }
        if (T.seek != null) {
            T.seek == '' and T.seek = z
            else
            T.seek != 0 and A.cv = G&sca,T.seek
            // A.t probably changed, become new personality
            typeof T.seek != 'object' and delete T.seek;
            return G&thro;
        }
        delete T.whack;
        return delete T.not;
    
    #c joinery, interleaving
    # T.seek = '' re-thro to get new mind from now on
    # T.seek = 0 same but repeat this step/A.cv
    #   and so eg 6 starts again,
    #     but doesn't T.seek away when its ready to continue
    # or the same 3 is taken when A:ev finds J to switch to become A:e from
    # T.N = 0 should also leave A.cv==D.y.cv the T.N came from,
    #   and T.N.0 = 3 means event should have worked by the time of 3,
    #   or do the same thing again, making the asyncronous calls cache
    #   map the gazing of code with such, make it exponial?
    #   
    
    # throat thing T.N=1 do stuff from 1 later...
    # 1s&N queue for later
    # T.not lets go
    TN:
        1s&N.push(A);
        
        if (typeof s == 'object') {
            # take T.N.$tocv = $time,
            # or T.N = $tocv
            $tocv;
            $time;
            $.each(s, &k,v{
                tocv != null and throw "com TN{}"
                tocv = 0+k;
                time = 0+v;
                // check back/rerequest/slomo time
            });
            s = tocv;
            # does the identity as eg 3 remain?
            time and a&due = G&time + time;
        }
        typeof s != 'number' and throw "com TN";
        
        T.not = 1;
        # first number sets A.cv
        s != 0 and A.cv = G&sca,s; T.not = 2;
        # exit before Acv == A.cv we set, eg when 6 did T.N=6
        s != 0 and T.not = 2;
        # second number is time due
    
    # going async with a throw,
    # when stack beyond your G&thro is full of stuff that
    #   can't continue yet,
    #   so you can't get back to the G&thro to T.N etc.
    #   (unless you can)
    # eg the A:u's just T.N on their way out, clients half
    #  but G&way or G&clusp have to suddenly vanish
    
    # < once testable, can A.cv be set before the G&h in G&thro?
    # the J.2 (probably Four) should wake the 1s&N,
    #   resuming the throat, which keeps its A.cv and A&ov
    # this whatever, probably a J 6, shall come again
    TuneTimeMachine:
        1s&N.push(A);
        # to detangle - make sure A.1 is stashed elsewhere
        A&Jupstash and A&Jupstash();
        # probably like a T.nose with instant doming abort
        $D = T.thro;
        A.cv = D.y.cv;
        # make a little view of the A/B stacks?
        $per = A.t+'@'+A.cv;
        throw "async "+per+": "+s
    
NutPhonica: | # practicalities
    n NutSock
    n NutPhone
    n NutCons
NutPhone: | # adapt to the universe
    u j
    n \'of:eye'
    
    # TIME
    
    # unmanaged delays may miss their chance to happen more ontime before ...
    # delay in seconds
    delay: %acgt:delay cb
        setTimeout(cb, delay * 1000);
    # delay in ms
    yl: %acgt:delay cb
        setTimeout(cb, delay);
    
    # 4dp unix timestamp
    time: %acgt:time delta
        $now = Date.now() / 1000;
        # delta as ttl
        time && delta and return time + delta > now
        # time since time, 4dp (floating float?)
        time and return G&desca,now-time
        # time
        return now
    # say s/ms if possible
    # < c/86 mass knows weeks/days/etc
    thime:
        s < 1 and return (s * 1000)+'ms';
        return s+'s';
    
    # keyjamming, lossy event surge control
    # can tolerate notmany initially
    jam: %acgt:Hz notmany
        Hz ||= 5
        $ms = 1000 / Hz;
        
        $t = A.t;
        $jams = 1s&jams = 1s&jams || {};
        $jam = jams[t];
        jam and return jam()
        
        $times = 1;
        $msg;
        jams[t] = &{
            times++ < notmany and return 0
            if (!msg) { msg =
                ~>38 jam: A.1.t, t, '>37:times', '>'+Hz+'Hz'
            }
            msg.set('times',times++);
            return 1
        };
        G&yl:ms,&{ delete jams[t] };
        return 0
    
    
    
    # HUMAN MIND
    
    # understand one expanse, as C.y.cv is
    #   fraction in 0-1, eg 333 -> 0.333
    #  is cv=0 allowed?
    sca: %acgt:s precision
        s && s*1 != s and return
        while (s >= 1)
            s /= 10
        return +s.toPrecision(precision || 4)
    
    # put decimal places
    desca: %acgt:s precision
        precision ||= 4;
        $mul = '1e'+precision;
        return (s * mul).toFixed() / mul
    
    
    
    # JAVASCRIPT
    
    # get function args
    arfgunc:
        typeof s != 'function' and return
        $m = s.toString().match(/^function \((.+?)\)/);
        return m && m[1]
    
    # limit list, calling callback for each removal
    lim: %acgt:s lim cb
        var len = s.length;
        lim ||= 9;
        var rev;
        lim < 0 and rev = 1; lim *= -1;
        var rem = [];
        while (len > lim) {
            var v;
            rev and v = s.pop()
            else {  v = s.shift() }
            cb and cb(v);
            rem.push(v);
            len--;
        }
        rem.length and return rem
    
    # RESOLUTIONS
    
    # hash into ke,ys string
    ks:
        var ks = [];
        for (var k in s) {
            ks.push(k);
        }
        return ks.join(',');
    
    # hash into ke:va,ys:lue string
    kes:
        # ?
    
    # ke:va,ys:lue string into hash
    # < mere,this -> mere === undefined, etc
    #   should be mere=1,this=1  see el.333/s&atr
    peel:
        var c = {};
        !s.length and return c
        $m = s.split(',');
        each in m {
            n = n.split(':');
            $k = n[0];
            $v = n[1];
            v && v.match(/^-?\d+\.\d+$/) and v = v * 1
            v == null and v = 1
            c[k] = v;
        }
        return c
    
NutCons: | # arcade-era interaction, logging
    u j
    n \'of:eye'
    
    # make buttons
    headi: %acgt:s t
        t ||= s
        
        $('body h2').filter(&i,v{
            v.innerHTML.match('^'+s) and v.remove()
        });
        
        $func = "G.h(A,C,G,T,'"+t+"',this)";
        $('<h2 id="'+t+'" onclick="'+func+'">'+s+'</h2>')
            .appendTo('body')
    
    # with a leading ">34:bob" means 3:yellow, 4:60%, <bob>
    # ... unicode? you have a palette handy?
    # should work same system as throw, l.t should be SyntaxError etc.
    intag:
        $M = [s];
        if (typeof s == 'object') {
            # TODO apply s[0] around s[*], ref s[n] and s[n] = G&intag,s[n]
        }
        s = M[0];
            s = ''+s;
            $num = /^>(\d+)?(?::(\w*))? */;
            $m = s.match(num);
            if (m) {
                s = s.replace(num,'');
                $style = '';
                if (m[1]) {
                    $col = m[1].substr(0,1);
                    $siz = m[1].substr(1,1);
                    if (col) {
                        # 0 red, 3 yellow, 6 blue, 9 purple
                        # the 2-3 and 5-6 is hard to discern
                        $lig = col == 3 || col == 6 ? '30' : '60';
                        style += "color:hsl("+(col*30)+", 90%, "+lig+"%);";
                    }
                    if (siz) {
                        style += "font-size:"+(siz*15)+"%;";
                    }
                }
                $tag = m[2] || 'n';
                s = '<'+tag+(style.length ? ' style="'+style+'"' : '')+'>'
                    + s + '</'+tag+'>';
            }
            return s
        
    
    # #msgs console message
    c: %acgt:s M
        M ||= [];
        $l = G&Cye,['',1,{},{M:M}];
        l.t ||= s;
        ls&now = G&time;
        
        $L = A[4];
        Ls&log ||= [];
        Ls&log.unshift(l);
        G&lim,Ls&log,-9;
        # human readable
        $format = &s{ return G&intag,s };
        
        $says = [];
        each iv M {
            $say = typeof v == 'number' || typeof v == 'string' ? v 
                : '%'+typeof v;
            says.push(format(say));
        }
        says.length and s += ': '+says.join(' ');
        
        $it =
        $('#msgs').prepend("<m>"+format(s)+"</m>\n").children()[0];
        # and links? make J? know #msgs?
        ls&A = A;
        # ls&B = Gc&B
        it.log = l;
        it.set = &t,s{
            s = format(s); #}
            $el = t == '$' ? it : $(it).find(t)[0];
            el == it and s = el.innerHTML + s
            !el and throw "unknown set: "+t, it
            el.innerHTML = s;
        };
        return it
    

