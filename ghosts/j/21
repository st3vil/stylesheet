NutSeq: | # self
    n NutAye
    n NutSea
    n NutTub
NutAye: | # A without tubeyness
    u j
    n \'of:eye'
    # begin being, A
    # they can take over names within their network
    #   // slopa, as def NutCore
    #   A.om ||= A;
    #   A.om == A.up and A.mo = A;
    #   but such a name may need update as B (sub calls) revamp
    # also drops A.V for verbose, use T
    Aye: %acgt:s ov c sc
        if (s && typeof s == 'object') {
            A = s;
        }
        else {
            $V = A;
            A = $.extend({},A);
            A.t = s;
            A.y = A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            
            A.up = V;
            A&ip = (upA&ip||[]).slice(0);
            upA&ipi ||= 0;
            A&ip.push(upA&ipi++);
            A&sip = A&ip.join(' ');
            
            // trip A
        }
        c and $.extend(A.c,c);
        sc and $.extend(A.sc,sc);
        
        if (ov && ov*1 == ov) {
            A&ov = G&sca,ov;
            G&thro;
        }
        return A
    
    # utils/inlineables
    #  is cv=0 allowed?
    sca: %acgt:s precision
        s && s*1 != s and return
        while (s >= 1)
            s /= 10
        return s.toPrecision(precision || 4)
    
    # descript/mapself
    
    
NutSea: | # line etc into C
    u j
    n \'of:eye'
    # 
    # ReadLines, G&m? G&A?
    # guess s={} = C
    # guess s=[] t y c sc, like n t y c sc
    # guess c='Line' or c.s='Line' c.as='z' c.from=upC, 
    #   so lines can have normalcy/decompression
    # the enclosure adds to the C,
    # with respect to the thing holding it, upC, C.y.up
    # putting in its ytv etc
    # C.t != null
    # where should C.y.cv ||= 0.1?
    # doesn't y.A=A, n 1 does
    Cye: %acgt:s c
        $C = {};
        if (s.constructor == Object) {
            if (null != s.t && s.y && s.c && s.sc) {
                $C = {y:{},c:{},sc:{}};
                C.t = s.t;
                $.extend(C.y,s.y);
                $.extend(C.c,s.c);
                $.extend(C.sc,s.sc);
                return C
            }
            else {
                throw "Unhandle hash C: ", s
            }
        }
        else
        if (s.constructor == Array) {
            C.t = s[0];
            C.y = s[1];
            C.c = s[2];
            C.sc = s[3];
            typeof C.c  === 'string' and C.c =  G&peel,C.c
            typeof C.sc === 'string' and C.sc = G&peel,C.sc
            // < extra -pi
        }
        
        !typeof C.t === 'string' and throw "Non string t: ", C;
        
        if (typeof C.y == 'string' || typeof C.y == 'number') {
            C.y * 1 != C.y and throw "Non number y left: ", C
            C.y = {cv: C.y };
        }
        C.y ||= {};
        C.y.cv < 0 and C.y.cv *= -1;
        C.y.cv > 1 and C.y.cv = G&sca,C.y.cv;
        
        C.c ||= {};
        
        C.sc ||= {};
        return C;
    
    # utils/inlineables
    # peel, xo/xoh
    
    # and a bit of xotila

    # that is? recurse?
    # checks s for being [] or [['']]
    datam: %acgt:s c
        typeof c == 'string' and c = {s:c};
        c.d ||= 1;
        c.d > 3 and throw "large datam";
        $zc = [];
        # read the question
        $after = c.s;
        if (c.s.match('^\\[')) {
            after = c.s.replace(/^\[|\]$/g, '');
            c.array = 1
        }
        if (c.s.match("^'")) {
            c.eq = c.s.replace(/^'|'$/g, '');
            after = ''
        }
        c.s = after;
        # make an answer
        if (c.array) {
            !(typeof s == 'object' && s.constructor == Array) and return
        }
        if (c.eq != null) {
            !(typeof s == 'string' || typeof s == 'number') and return
            c.eq != '*' && s != c.eq and return
        }
        !c.s and return 1
        # more inside
        $ss = c.s.split(',');
        # check the size of the next set in
        if (s.length != ss.length) {
            #~diflen: s, ss
            return
        }
        # check each thing
        for (var si in ss) {
            $oc = ss[si];
            $os = s[si];
            oc = {s:oc,d:c.d+1};
            $re = G&datam,os,oc;
            if (!re) {
                #~subfa: os, oc
                return
            }
        }
        return 1
        
NutTub: | # A tubeyness
    u j
    n \'of:eye'
    
    # subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO Gc&B stacking
    # TODO G.i.* = A.I.i.y.tw.*.c.code
    hhh: %acgt:s so st sh sf si
        $z = s;
        typeof s === 'string' and z = G.t(A,C,G,T,'i',s);
        typeof s === 'string' && !z and z = G.t(A,C,G,T,'eye',s);
        !z and throw "No way: "+s;
        T.D = z;
        return z.c.code(A,C,G,T,so,st,sh,sf,si);
    
    # do I for C (A&s): go, stop, mode
    # jog job through embryo A.t
    # up to ov
    # T.N=2 or T.N.2=? sets A.cv = 2 and 1s&N queue
    thro: %acgt:ov sC
        ov && typeof ov == 'object' and A = ov; ov = null;
        sC && typeof sC == 'number' and ov = sC; sC = null;
        $T = A&T = A&T || {};
        T.not and return
        ov and A&ov = G&sca,ov;
        sC and A&s = sC;
        C = A&s = A&s || {t:'',y:{A:A},c:{},sc:{}};
        $t = G&t,A.t;
        !t and throw "thro no t: "+A.t, A;
        
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            T.not and break
            $D = z;
            z = z.y.next;
            
            A.cv > D.y.cv and continue
            $Acv = A.cv;
            T.N ||= {};
            C = A&s;
            if (!D.sc.any) {
                D.sc.nk and !C[D.sc.nk] and continue;
                D.sc.gk and !C[D.sc.nk][D.sc.gk] and continue;
            }
            $es;
            D.sc.gk and es = C[D.sc.nk][D.sc.gk];
            D.sc.s and es = D.sc.s;
            
            G.h(A,C,G,T,D,es);
            
            typeof T.N == 'object' && Object.keys(T.N).length == 0 and delete T.N
            T.N != null and G&TN,T.N; delete T.N
            T.not == '2' and return delete T.not
            Acv == A.cv and A.cv = D.y.cv;
            
            T.whack || T.not || T.seek != null and break
        }
        if (T.seek != null) {
            T.seek == '' and T.seek = z.y.cv
            T.seek != 0 and A.cv = G&sca,T.seek
            // A.t probably changed, become new personality
            delete T.seek;
            return G&thro;
        }
        return delete T.not;
    
    
    # T.seek = '' re-thro to get new mind from now on
    # T.seek = 0 same but repeat this step/A.cv
    #   and so eg 6 starts again,
    #     but doesn't T.seek away when its ready to continue
    # or the same 3 is taken when A:ev finds J to switch to become A:e from
    # T.N = 0 should also leave A.cv==D.y.cv the T.N came from,
    #   and T.N.0 = 3 means event should have worked by the time of 3,
    #   or do the same thing again, making the asyncronous calls cache
    #   map the gazing of code with such, make it exponial?
    #   
    
    # throat thing T.N=1 do stuff from 1 later...
    # 1s&N queue for later
    # T.not lets go
    TN:
        1s&N.push(A);
        
        if (typeof s == 'object') {
            # take T.N.$tocv = $time,
            # or T.N = $tocv
            $tocv;
            $time;
            $.each(s, &k,v{
                tocv != null and throw "com TN{}"
                tocv = 0+k;
                time = 0+v;
                // check back/rerequest/slomo time
            });
            s = tocv;
            # does the identity as eg 3 remain?
            time and a&due = G&time + time;
        }
        typeof s != 'number' and throw "com TN";
        
        T.not = 1;
        # first number sets A.cv
        s != 0 and A.cv = G&sca,s; T.not = 2;
        # exit before Acv == A.cv we set, eg when 6 did T.N=6
        s != 0 and T.not = 2;
        
        # second number is time due
        
        
    

