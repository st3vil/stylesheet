Fividy: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    window.reverse = &s{ return s.slice().reverse() };

    # hash stash
    window.ah = &th{
        !isC(t) and throw "!C"
        $M = [... arguments].slice(2);
        $h = t.sc[h] ||= {};
        while (M.length) {
            $k = M.shift();
            M.length > 1 and h = h[k] ||= {}
            else {
                $re = h[k];
                h[k] = M.shift();
                return re;
            }
        }
    };
    # hashes are identical
    window.heq = &sd{
        !hakd(s,d).length
    };
    # keys of differing values
    window.hakd = &sd{
        $dif = {};
        each kv s {
            !hak(d,k) || d[k] != v and dif[k] = 1
        }
        each kv d {
            !hak(s,k) || s[k] != v and dif[k] = 1
        }
        $ks = [];
        each ko dif {
            ks.push(k)
        }
        return ks
    };

    # array match
    # if M, returns [not], puts M[matched]
    #  eg N = arou(N,'acty',actyN) separates actyN from N
    # else, returns [matched]
    window.arou = &NyM{
        $matched = M || [];
        if (isst(y)) {
            $k = y;
            y = &n{ return n.sc[k] };
            if (k[0] == '!') {
                $cb = y;
                k = k.substr(1);
                y = &s{ return !cb(s) }
            }
        }
        if (M && !isar(M)) {
            # for an Nx.$k=N tape splitter
            !k and throw "dunno Nx k",M
            matched = M[k] ||= []
        }
        $not = [];
        each in N {
            y(n) ? matched.push(n) : not.push(n)
        }
        return M ? not : matched
    };
    # match N into one of several groups
    window.aroh = &Nc{
        c ||= {};
        isst(c) and c = G&peel,c
        $h = {};
        each kn c {
            # matcher n is &s{} or a scgk
            n == '1' and n = k
            $M = [];
            N = arou(N,k,M);
            h[k] = M
        }
        h.N = N;
        return h
    }
    
    #c C-ish
    # < G&C, babz: = C yadda @3
    #   and to parse args for eg opeolo
    #   has a lot to do with:
    window.isnu = &s{ return typeof s == 'number' };
    window.isfu = &s{ return typeof s == 'function' };
    window.isst = &s{ return typeof s == 'string' };
    window.isar = &s{ return s && s.constructor == Array };
    window.isha = &s{ return s && typeof s == 'object' && !isC(s) };
    window.isob = &s{ return s && typeof s == 'object' };
    window.isR = &s{ return isC(s) && sy&R == s };
    window.Cye = &s{
        s = G&Cye,s;
        s.y = {cv:s.y.cv};
        delete ss&z;
        return s
    };
    # make fraction of 1
    window.sca = &s{
        s *= 1;
        while (s >= 1) { s = s / 10 }
        return s;
    };
    # round to decimal places
    window.dec = &s,precision{
        null == precision and precision = 4;
        $mul = '1e'+precision;
        return (s * mul).toFixed() / mul
    };
    # ac() also replacing nc&b with n
    #  as Cupon %down=[], recycled selves
    window.bac = &Rkr{
        $N = R.sc[k] ||= [];
        $b = rc&b;
        if (b) {
            $bi = N.indexOf(b);
            bi >= 0 and return N[bi] = r
        }
        $ni = N.indexOf(b);
        ni >= 0 and return N[ni] = r
        N.push(r)
    };

    # read spacey t, or insert C = y()
    window.fio = &qty{
        !isC(q) and throw "NotC"
        qs&z ||= [];
        qy&tw ||= {};
        y != null && y == 0 and $readonly = 1
        y == '9' and $deletes = 1; y = null
        typeof t == 'object' and $obj = y = t; t = null
        $ar = y && y.constructor == Array;
        y && t == null and t = ar ? y [0] : y.t
        y != null && y == 0 and $readonly = 1
        
        $s = qy&tw[t];
        # allow removing from qs&z
        #  without tw if deleting given C
        $si = obj && deletes ? qs&z.indexOf(obj)
            : s && qs&z.indexOf(s);
        si < 0 and s = null
        if (deletes) {
            si < 0 and return
            qs&z.splice(si,1);
            delete qy&tw[t];
            return
        }
        if (!s && !readonly) {
            s = y ? ar ? G&Cye,y : y : G&Cye,[t,1];
            qs&z.push(s);
            qy&tw[t] = s;
        }
        s and ss&z ||= [];
        return s
    };
    
    # C usu sort by cv,t
    window.tvsortz = &z{
        z.sort(&ab{
            return (ay&cv||0)*1-(by&cv||0)*1
                || ('' + a.t).localeCompare(b.t)
        });
        return z
    }
    window.vsortz = &z{
        z.sort(&ab{
            return (ay&cv||0)*1-(by&cv||0)*1
        });
        return z
    }
    
    
Twoism: | # js the way in, fetching into an eval
    # non-G&way way: fetch into an eval 
    $way = &ty{
        $.ajax('way/'+t).done(&s{
            $f;
            eval(['f = function (ar) {',s,'}'].join("\n"));
            $re = f({});
            y and y(re);
        });
    };
    
    $ch = &s{
        $("<p>").appendTo(document.body).text(s);
    };
    # load $t.js to C with s&I
    window.Cyeblong = &v{
        return {t:v[0], y:{cv:v[1]||0.1}, c:v[2]||{}, sc:v[3]||{}};
    };
    $loadI = &t{
        $tocfunc = t+'_current';
        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
        $toc = window[tocfunc]();
        
        $W = Cyeblong([t]);
        Ws&I = {};
        
        $D;
        each iv toc {
            $ind = v.shift();
            $C = Cyeblong(v);
            if (ind == '') {
                D = Ws&I[C.t] = C;
                D.y.tw = {};
                D.y.tv = {};
                Ds&z ||= [];
            }
            else if (ind == '  ') {
                D.t != s&js and throw "Csjs not last D", C, D;
                c&code = window[s&name];
                typeof c&code != 'function' and throw "Cccode not function", C, D;
                # grow I
                D.y.tv[C.t] ||= {};
                D.y.tv[C.t][C.y.cv] = C;
                D.y.tw[C.t] = C;
                $l = Ds&z.slice(-1);
                l[0] and l[0].y.next = C;
                Ds&z.push(C);
                D.y.in ||= C;
                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                    G[C.t] = c&code;
                }
            }
            else {
                throw "deep C: "+t, v
            }
        }
        return W
    };
    
    # Automation
    A = window.A = Cyeblong(['top']);
    A.y = A;
    A.1 = A.2 = A.3 = A.4 = A.5 = A;
    1s&N = [];
    # GOING - gev insists on A.4.up while finding path in
    $Y = A.up = Cyeblong(['outside']);
    Y.y = Y;
    Y.2 = A;
    
    # Culture
    $C = Cyeblong(['Top']);
    # Grind
    window.G = Cyeblong(['Gee']);
    G.y = G;
    # Telomena
    $T = {};
    
    # mind as I
    $M = 'Hunt'.split(' ').map(t => loadI(t));
    $W = M[0];
    A.I = Ws&I;
    4c&ttl = 3600;
    
    # mind as me
    $me = 4c&me = window.me = {};
    me.Ja = {}; # pins
    me.timestamp = &{ return(new Date).toISOString() };
    A&me = me;
    # from all these epochs of development
    $list = ('NutGravy iooia '+
        'Soogle Coffle Packle Foogla Fividy Fourism')
        .split(' ');
    $however = 1;
    $someend = &{
        however--
        however == 0 and way('Threeism')
    };
    $morelist = &i{
        $t = list[i];
        !t and return someend();
        way(t,&r{
            t == 'iooia' and me.io = r
            morelist(i+1);
        });
    };
    morelist(0);
    
    # also since they are not G&way:
    # A5Iw shall know these, ghost updates begin
    'Soogle Packle Coffle Foogla EleMento EleVisAn Fourism'.split(' ').map(&t{
        however++; G&way,t,{},someend
    });
    
Threeism: |
    # lots from somewheres...
    $C = G&Cye,['Elevat',2];
    
    # the right side
    $('body div.v8').remove();
    A.on = $('body')[0];
    $el = 4s&starlane = $('<div class="v8" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:55%;height:20%;width:43%">')
    .appendTo('body')[0];
    # the left
    4s&planelane = $('<div class="v9" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:0%;width:43%">')
    .appendTo('body')[0];
    
    
    # to named A.4
        # GOING:
        el.A = A;
    $dns = G.DNS = G.DNS || {};
    $old = dns[A.4.t];
    dns[A.4.t] = A.4;
    
    # drive units
    G.clon = &{ $(window).on("click", &ev,{ G&gev,ev }) };
    G.keon = &{ $(window).on("keydown", &ev,{ G&gev,ev }) };
    G.clof = &{ $(window).off("click") };
    G.keof = &{ $(window).off("keydown") };
    G.togwid = &m,fr,to{
        if ($(m).attr('togwid') == to)
            to = fr
        $(m).attr('togwid', to)
        $(m).css('width', to);
    };
    
    # says
    $msgs = $(A.on).find('> #msgs')[0];
    msgs ||= $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
    4s&msgs = msgs;
    
    $originA = A.4;
    # error handling
    #  get A as it was last G&h
    window.BamonG = &{ 
        $B = Gc&B;
        return B && Bs&A || BoriginA
    };
    window.onerror = &msg,url,lineNo,colNo,error{
        $A = BamonG();
        A&ev and A&ev.preventDefault();
        A&bang and return
        A&bang = 1;
        G&Ban,error,msg,url,lineNo,colNo,error;
        delete A&bang;
        return
    };
    
    
    me.start = &{
        4s&NormalI = A.I;
        # in favour of dispatch table towards 4:
        # inits and continues methods on me
        # unco:
        4s&N = [];
        document.title = 'hoot';
        A.on = el;
        A.on.A = A;
        T = {y:{},c:{},sc:{}};
        #me.star(A,C,G,T);
        me.plane(A,C,G,T);
    };
    
    G.clon(); G.keon();
    
    #c hacks
    A.I.i.y.tw.way.c.code = &acgtt,ar,cb,noop{
        $w = typeof t == 'object' ? t : G&t,'w',t;
        $ttl = 4c&ttl || 5;
        !(w && ws&now && G&time,ws&now,ttl) and w = null
        noop == 'nottl' and w = null
        
        if (!w) {
            cb == 'noop' and cb = &{};
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            $get = '/way/'+t;
            $is_done;
            $done = &s,how,c{
                is_done = 1;
                how != 'success' and throw "Failed request: "+how, c;
                $dige = c.getResponseHeader('Dige');
                $w = G&Cye,[t,1,{s:s},{of:'w',dige:dige}];
                A.5.I ||= {};
                $D = A.5.I.w = A.5.I.w || G&Cye,['w','',{},{z:[]}];
                D.y ||= {};
                D.y.tw ||= {};
                D.y.tw[t] = w;
                ws&now = G&time;
                # < check it compiles? but we don't know its args,
                #   unless they are vaguely known by bumping into compile errors
                #   awaiting better field recording (MelTest frontier of)
                a&ready = 1;
                #~w!: t
                if (cb) {
                    if (G&arfgunc,cb == "s") {
                        # wants its return value with given ar...
                        #~w cb s: t
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the w back?
                        #~w cb: t
                        cb(t,ar,w);
                    }
                }
            };
            $r = $.ajax(get);
            r.done(done);
            $checks = 5;
            $check = &{
                is_done and return;
                if (!r.statusText) {
                    checks-- > 0 and return G&yl,150,check;
                    console.log("Long wait going to: "+get)
                    checks > -3 and return G&yl,666,check;
                    return
                }
                r.statusText == 'Not Found' and throw "No way: "+t
                r.statusText != 'OK' and throw "Weird ajaxtus: "+r.statusText
                #~>57 waylo: t
                done(r.responseText, 'success', r);
            };
            check();
            #~w?: t
            !cb and G&TuneTimeMachine,'w:'+t
            return
        }
        
        ar ||= {};
        $args = G&ks,ar;
        args != wc&code_args and delete wc&code;
        # code is already JaBabz'd
        # < CoArgulate for ar, put as knowable source file?
        # < make it c.code and G&h for a B?
        if (!wc&code) {
            $name = 'w_'+w.t+'_'+ws&dige+'_'+args;
            name = name.replace(/\W+/g,'_');
            $ways = A.5.I.w;
            wayss&namedcode ||= {};
            $code = wayss&namedcode[name];
            if (code) {
                wc&code = code;
            }
            else {
                $tar = 'ar';
                args and tar += ','+args;
                # help Ban find its source
                Gc&B.sc.way = w;
                $code = 'wc&code = function '+name+"(A,C,G,T,"+tar+"){\n"+wc&s+"}";
                try{
                    window.code = code;
                    eval(code);
                }
                catch(er){
                    # eval this on the console to see source...
                    window.lacode = code;
                    throw er
                }
                # now compiled, we are not "in" it until run
                delete Gc&B.sc.way;
                wayss&namedcode[name] = wc&code;
            }
            args and wc&code_args = args;
        }
        noop || cb == 'noop' and return
        $arm = [];
        $ark = args.split(',');
        each ik ark {
            arm.push(k);
        }
        $so = ar[arm[0]];
        $st = ar[arm[1]];
        $sh = ar[arm[2]];
        $sf = ar[arm[3]];
        $si = ar[arm[4]];
        
        # help Ban find its source
        Gc&B.sc.way = w;
        return wc&code(A,C,G,T,ar,so,st,sh,sf,si);
    }


    me.start();
    
    
Fourism: |
    # new road to R without J!
    #  from me.planet instead of wobulus?
    # breaks too much just now: Teing, A.n
    #  when 1s&ein has sockets that R-times peel off
    me.Fourismo = &acgt{
        # knowing
        $El = 1s&elvisory ||= Cyeblong(['El']);
        # GOING need for J having it
        1s&Te = El;
        # GOING need to na&Teelone, El%ball
        A.n = A;
        # being that top level (not A.1.t)
        # < here only
        s&Te = El;

        s&mune = 1;

        $I = me&Resurrect,'I',1s&s;
        Iy&J = A.4;
        me&J,'Fourier','W';

        $D = me&ballRom,I,C;

        1s&s = I;
        return;
        $on = D.y.Display.sc.on;
        if (!4s&on.contains(on)) {
            ~>5 On: C.t
            on.A ||= A;
            4s&on.appendChild(on)
        }
        1s&s = I;
    };

    # NutEl
    A.I.i.y.tw.gev.c.code = &acgt,ev,J{
        ev ||= event;
        ev.target.tagName == 'H2' and return
        # locate A:top of A:4
        #debugger;
        if (!ev.target) {
            A&event_A and A = A&event_A;
        }
        elsif (ev.target == document.body) {

        }
        else {
            $S = ev.target;
            while (S && !(S.A && S.A.4)) {
                S = S.parentNode;
            }
            # must be clicking <body>, <html>
            #   or something above .A element space
            !S and return
            A = S.A.4;
            !A and throw "out of cone";
            A&event_A = A;
        }
        if (A&event_A) {
            A&event_A != A and ~innerA: A.4.t
            A = A&event_A;
        }
        G&Aye,'ev',9,{ev:ev}
    };

    #c ambient synapse
    4c&framerate = 0.3;
    # when without G&h
    window.Gtime = &d{ return G&time,d };

    # loop comebacks between attentions
    $lastwas = 0;
    me.plane = &acgts{
        #A.on = 4s&planelane;
        A != window.A and throw "How there A"
        !A.on.ownerDocument.contains(A.on) and return ch("unplugged");
        $me = A&me;
        $starts = G&time;
        lastwas and 4s&nonms = G&time,lastwas;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&framerate;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000

        # < route G&gev to me.plane sometimes?
        #   they are different A.4s really
        #   and 4c&callback
        4c&callback ||= &s{ me.plane(Y,C,G,T,s) };
        $sing = 4c&callback.singly = {};
        G&yl:frames,&{ sing == 4c&callback.singly && 4c&callback() };

        4s&thinking = 1;
        try { me&planet,s }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }
        4s&thinking = 0;

        $ends = G&time,starts;
        4s&ms = ends;
        lastwas = G&time;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    # cast gazet
    # this is a bag of marbles, they are free and together
    # < plane should throttle e
    me.wantpause = &acgtRs{
        $was = 4s&paused;
        $is = 4s&paused = s == 'tog' ? !4s&paused : s
        $say = is ? "off" : "on";
        was != is and ~>7 Ambient wake: '>5 '+say
        return is
    };
    me.planet = &acgts{
        4s&paused && !s and return
        $A = 4s&thinking = G&Aye,'planet';
        $B = Gc&B;
        B and 'collect?'
        B = Gc&B = G&Cye,[A.t,''];
        Bs&A = A;
        Bs&z = [];
        A&time = Gtime();
        $g = 4c&s = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        !me.inita.ed and me&inita

        # 1/10th attend
        A&sip.slice(-1)[0] == 0 and me&otherandcontinue

        4s&Jays = 0;

        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        #me&J,'Fourier','W'; !
        4s&Fourieronlynow and delete 4s&Fourieronlynow; throw "async Fourier only"
        s and gc&e = s
        $j = me&J,['Planet','W',{el:el},{timing:0}]
        j = js&J;
        !js&on.ownerDocument.contains(js&on) and A.on.appendChild(js&on)
        # < me.do_main does any $el/*%J
    };
    me.Ja.Planet = &acgts{
        me&Gomp;
        s&timing = 1;
        #debugger;
        n Har   %rovo:Domebegin
        #s&ab = 1;
        #s&wi = '44%';
    };
    #c Elvisingness - sleeping is possible
    me.Elvisingness = &acgt{ return [
        ['Slei','278',&acgtRs{
            !(Rs&ball || Rs&Gens) and delete Rs&Slei; return
            ac(R,'inheritsc','Slei');
            Rs&Gens and return
            $p = Ry&up;
            Rc&timelab ||= R;
            R.t == 'Sleigh' and Rs&Flaring = 1
            ps&Flaring and Rs&Timeding = 1
            ps&Timeding and Rs&Timedin = 1
        },'ift,D'],
        ['Slei+ball','2781',&acgtRs{
            Rs&Flaring ? me&sipi,R : me&sipi,R,Ry&up
        },'ift,D,sleeping'],
        &{
        # increment protocol
        me.sipi = &acgtsf{
            if (f) {
                !fc&ip and throw "from !ip", s, f
                sc&ip = fc&ip.slice();
                fc&ipi ||= 0;
                sc&ip.push(fc&ipi++);
            }
            else {
                $was = sc&b && sc&b.c.ip;
                was && was.length > 1 and throw "ip start long"
                sc&ip = [was ? was[0]+1 : 0]
            }
            sc&sip = sc&ip.join(' ');
        };
        },

        ['Timeding','89',&acgtRs{
            $ti = {};
            each in Rs&z {
                $N = ti[n.t] ||= []
                N.push(n);
            }
            each tN ti {
                N.length == 1 and continue
                me&nu,"Dupes_in_"+R.t,N
            }
        },'ift,D,sleeping'],
        # above everything, scan scenario
        ['Flaring','89',&acgtRs{
            # to get R%sleeping to hit eg ball+sleeping
            ah(R,'reawakens','Slei',{
                rollbs:'ball,Flaring,Slei,Timeding,Timedin',
            });

            $Sl = me&ioty,R,'Timeding' [0];
            #me&nu,"Sl",Sl;
            Sls&z.length > 3 and 4s&Slsz = Sls&z.slice();
            each ir Sls&z {
                i = i+' '+(Rc&N.indexOf(r)>=0 ? "wake" : "s");
                me&tsc,i,i+":"+r.t .sc.dis = 1;
            }
        },'ift,D'],

        # the sleeper
        ['Timeding','2781',&acgtRs{
            $c = me&rollcounty,R,'lupe';
            $rfromN = &r{
                $i = Rc&N.indexOf(r);
                i < 0 and return
                Rc&N.splice(i,1);
                each in rs&z {
                    rfromN(n)
                }
            };

            $fl = me&tsc,'%Codon','flar:'+cs&count,'g';
            me.nto(R,fl,&sT{
                Rs&wakinext = 1;
            });
            Rs&countis = cs&count;
            me&rollbs,R,'incount';
            Rs&incount ||= 0;
            Rs&incount++;

            if (0 && cs&count >= 4) {
                cs&count >= 5 and cs&count = 0
                Rs&sleeping = 1;
                $v = me&ollbs,R,'Vawake';
                v and me&Ret,R,{t:v.t,s:vc&s,ball:1};
                # < become %sleeping after @28
                #   is to be avoided
                #me&recycleRbitXz,R;
                each in Rs&z {
                    #rfromN(n)
                }
            }
        },'ift,D'],
        ['Timeding','4',&acgtRs{
            if (me&ollbs,R,'wakinext' ) {
                $first = 1;
                me&ioty,R,'Timedin' .map(&r{
                    first and first = 0; return
                    me&ioty,r,'Timedin' .map(&n{
                        !ns&ball and return
                        me&elvis,R,'flarke',{wake:n}
                    });
                });
            }
        },'ift,D'],
        #c Slei-testing
        # t =~ /^sleeping/ only if sleeping, sc either
        ['sleeping+Timeding','28',&acgtRs{
            me&rollbs,R,'lupe,countis,incount,Vawake';
        },'ift,D'],
        ['Timeding','89',&acgtRs{
            $t = Rs&sleeping ? "sleeping" : "w";
            $oc = me&ollbs,R,'countis';
            $oic = me&ollbs,R,'incount';
            #~>5 Timeding: t, oc,'->',Rs&countis, oic,'->',Rs&incount
        },'ift,D,sleeping'],

        # as child, sometimes unreached etc
        ['sleeping+Timedin','28',&acgtRs{
            me&rollbs,R,'country,luope';
        },'ift,D'],
        ['ball+Timedin','29',&acgtRs{
            ac(R,'inheritsc','Timedin');
            $c = me&rollcounty,R,'luope';
            me&tsc,'%Codon','floupe:'+cs&count,'g';

            Rs&country = me&rollbs,R,'country' || 0;
            Rs&country++;
            me&tsc,'%Codon','byb:'+Rs&country,'G';
            # cs&count == 10 and throw "wobble"

            $dat = [];
            while (dat.length < 32) { dat.push([1,2,3]) }
            #s.t == 'Vame2' and me&nu,dat

            $p = me.cbu(R,'Timeding');
            s.t == 'Vame3' and ps&Vawake = R

            if (ss&bath == Rs&country) {
                me&elvis,R,'wakuba',{wake:R}
            }
            $tun = me.cbu(R,'tunneling');
            $tune = tun && tuns&tunneling;
            tune && tune.t == 'wakuba' and me&tsc,"GOT!";
        },'ift,D'],
        #c elvis()
        # see elvis()
        # put near being its own R... (SCA)

        # - R%sleeping is its b the next time,
        #    must roll everything it wants to keep
        #   the R%sleeping/** don't happen,
        #    but if they do, Display them

        # bugs:
        # ! occasional 'nonb along', why is it from thence?
        # ! can't boost right after creating a %ball
        # !? similar after R%JRom nonmain pause
        #    that's the %tunneling avoider,
        #      since Rom packages c inside a %JRom
        #    %JRom/me&Rom sleep involves a Display if r%sleeping
        #    suppose R%down will recycle if we R%sleeping
        # ! 

        # %Slei - test suite:
        # < want to replay testily,
        #   look at various angles ... while...
        #   < %Zavmo for X
        #   < show how X is when not recycled,
        #    unrecycled, errored, etc
        #   < double handling: JRom resets RbitX,
        #      Re does a little to not apply if not applyRbitX

        # other
        # < %directDisplay should force Cupon same %on
        #   small chance of new thing not being nested
        # < specify non-history-creating mode
        #   how to add futures at depth...
        #   passing X, not inflating Rs to get it
        #    might be better, a begin where sleep wakes 
        #      wasn't: throw while tunneling breaks history (later)

        &{
        # to the thing
        #  handlers generating ec&wake
        me.elvis = &acgtRec{
            $E = 4s&Elvacts ||= Cye(['Elvacts',1]);
            c ||= {wake:R};
            # store time/e
            $Ein  = &c{
                $t = Cye([me.timestamp(),{y:R}]);
                ty&R = R;
                ty&A = A;
                tc&time = Gtime();
                4s&thinking and ty&F = 4s&thinking
                ex(t.sc,c||{});
                ac(E,'z',t);
                ac(t,'z',e);
            };
            if (c.in == 4) {
                # receptive/do mode
                T.msg =
                ~>8 e: '>3:IS','>7:pathin','>3:ts '+4c&s.t.substr(-5)
                Ein({direction:'i'});

                # slope %med=cra -> slope %elvis=Gazel
                !es&edone && ec&slope and me&slopemed,R,e
                # sort pools
                !es&edone && ec&pack and me&unpacke,R,e
                # all other unsolved elvis
                !es&edone && !ec&wake and me&domisce,R,e
                # go to it
                ec&wake and me&ewake,R,e
            }
            else {
                isst(e) && !isC(c) and e = Cye([e,1,c||{},{}])
                else {
                    throw "long form elvis plant"
                }
                # current Ring act
                es&act = T.act;
                es&R = R;
                # probably waking itself
                !haks(e.c) and ec&wake = R

                Ein({direction:'o'});
                if (4s&thinking) {
                    # messages want collecting
                    $JR = me.cbu(Ry&up,'JRom');
                    ac(JR,'elvoids',e);
                }
                else {
                    # message delivered
                    G&yl,0.001,&{4c&callback(e)};
                }
            }
        };
        },
        #c elvoids unpacke from/to depths
        # JRoms hoist elvising
        ['JRom+elvoids','314',&acgtRs{
            # < cancellable everything
            Rs&error and return
            $e = Cye(['elvoids',8,{pack:R}]);
            es&z = Rs&elvoids.slice();
            $JR = me.cbu(Ry&up,'JRom');
            if (JR) {
                each in es&z {
                    ~>7 Je: R.t, e.t
                }
                ac(JR,'elvoids',e);
            }
            else {
                ~>7 E: e.t
                G&yl,0.001,&{4c&callback(e)}
            }
        },'ift,D'],
        &{
        # makes a tree of ec&wakes a single diverging tunnel
        # < what if outer wakes and inners wake?
        me.unpacke = &acgtRe{
            $flat = &e{
                !ec&pack and return [e]
                $N = [];
                each in es&z {
                    N.push(... flat(n))
                }
                return N
            };
            $N = flat(e);
            $M = N.map(&n{
                $r = nc&wake;
                !r and debugger;
                !isR(r) and r = ns&R
                !isR(r) and throw "wake!R", n
                return me.cby(r)
            });
            es&flatup = M;
            # < io's grouping col/row
            # for the deepest JRoms first, splitting time
            #  incorporating more e from those times
            #   etc
            $dep = &jM{
                $N = [];
                $dif = [];
                # unique
                each in M {
                    $r = n[j];
                    !r and continue
                    $ri = dif.indexOf(r);
                    ri < 0 and dif.push(r);
                    $ri = dif.indexOf(r);
                    $z = N[ri] ||= [];
                    z.push(n);
                }
                # group many, inline if 1
                $path = [];
                each iz N {
                    $eg = z[0][j];
                    z.length > 1 && eg != z[1][j] and throw "wob"
                    $ins = dep(j+1,z);
                    $bit = [ me&yfuture,eg,0,{merged:1} ];
                    path.push(bit);
                    !ins.length and continue
                    # may be a [r,r,r] or [r,[[r,r],[r,r]]]
                    ins.length == 1 and bit.push(... ins[0])
                    else { bit.push(ins) }
                }
                return path
            };
            $path = dep(0,M); 
            4s&Slsz = path;
            path.length > 1 and throw "unpacke multi path"
            ec&wake = path[0];



            es&edone = 'unpacke';
        };
        },
        #c emisc handlers
        # < to all go in R:e,
        #   < Ring T-checker
        #   < ch() say smoke
        #  me&handelvis - %medo
        #   =modeen, play R, < dom
        # in planet/elvis():
        #  me&slopemed - %med
        #   =cra, solveR etc slope-finds %elvis
        #     =Gazel, say/boost/drag

        # generally T.wake to ec&wake
        #   after they complete (es&done=...)
        # but could be going in there to deliver the change
        #  and wait until ready to wander back to ...
        #  security of thems
        &{
        me.slopemed = &acgtRe{
            if (e.t == 'says') {
                if (ec&type == 'blur') {
                    # ec&ev.relatedTarget is where it's going,
                    #  for codemirror, .tagName == 'TEXTAREA'
                    #  and .parentNode()+ to something we know
                    if (ec&s == '') {
                        es&edone = 'sayvague';
                        Rs&sleeping = 1;
                        return
                    }
                }
            }
            $sl = ec&slope.slice().reverse();
            each in sl {
                # ns&medo is handled without 4c&callback
                $m = ns&med;
                !m and continue;
                # not in C or A.
                $D = C;
                $C = e;
                $s = ec&s;
                me&$m,s;
                C = D;
                T.ok = 1;
                break
            }
            !T.ok and T.msg.set('IS','NODICE')
            else {
                delete T.ok;
                es&edone = 'med';
                T.msg.set('IS','ok')
                $w = T.wake;
                if (w) {
                    # < spec in %reawakens?
                    ws&Cit || ws&Cee and w = wy&up;
                    ec&wake = w
                }
            }
        };
        me.domisce = &acgtRe{
            if (e.t == 'A') {
                me&wantpause,R,'tog' and Rs&sleeping = 1
            }
            elsif (e.t == 'C+click') {
                debugger;
                ec&wake = 1
            }
            elsif (e.t == 'V') {
                ec&wake = 1
            }
            elsif (e.t == 'E') {
                ec&wake = 4s&Elvact;
            }
            else {
                ~>8: Otherev: '>5 '+e.t
                # don't happen
                Rs&sleeping = 1;
            }
        };
        },
        #c ewake along the way to, tunneling:
        &{
        #  to find some strategy for sneaking in
        #   past R%sleeping to the wakers
        #   re-argumenting it re strategy,
        #    in artificial generation
        #     so it gets to eg sleeping+ball @28
        #    such that it might work
        #     < could Ring-wait the outsiders until
        #       inners are certain they don't need
        #       their surroundings after doing stuff
        me.printpath = &acgtli{
            i != null and l = l.slice(0,i+1)
            return l.map(n=>isar(n) ? '*'+n.length : n.t).join('/');
        };
        me.ewake = &acgtRe{
            # pointer
            $r = ec&wake;
            # wake everything modes
            !Rc&b || r == 1 and return
            if (isar(r)) {
                # multipath from unpacke, already yfuture
                es&tunnel = l = r
                #debugger;
            }
            else {
                !isR(r) and throw "non-R ecwake"

                # the latest maybe %sleeping parents of r
                #  applyRbitX updated y&up of recycled Rs&z
                $l = me.cby(r);
                # R(c&b)+ - historical R they pointed to
                es&tunnel_raw = l;
                # Rc&b - last R to happen
                #  yfuture can climb to unapplied X.newz
                es&tunnel = l = l.map(n => me&yfuture,n,0,{merged:1} );
            }
            
            # this R
            me&tunnelArrive,R,e;

            $froml = l.slice(es&tunneli);
            es&path = me&printpath,froml;
            T.msg.set('pathin',es&path);
            es&beawake and return

            # < J sync Te/X, jump to
            # assume tunneling between JRoms is safe
            froml.shift();
            $JR;
            each in froml {
                isar(n) and throw "multipath before JRom"
                ns&JRom and JR = n; break
            }
            l[es&tunneli+1] != JR and throw "JR!next"
            !JR and return

            # %icate() is like R:e suggesting N to do at A.4
            #   it is a Rom here with %tunneling to do
            Rs&sleeping = 1;

            Rs&icate = &{
                # make something to happen
                me&tunnelJRom,R,JR,e;
                JR.t == 'Elfor' and 4s&pathout = e
            };
            es&edone ||= "wake"
        };
        },
        # let sleeping+Utilis @28
        ['sleeping+mune+icate','3',&acgtRs{
            Rs&icate();
            # merges the branch, keeps them to Rc&b
            me&applyRbitX,R;
        },'ift,D'],
        #c e 3 tunneling
        # climb path
        # CONFUSION
        #  with tunneling+JRom?
        ['Elfor','13',&acgtRs{
            Rs&Timefrom = 4c&s.t.substr(-5);
        },'ift,D,sleeping'],
        &{
        me.tunnelArrive = &acgtRec{
            c ||= {};
            $l = es&tunnel;
            !Rc&b and throw "NOb"
            !l and throw "no l"
            $p = Ry&up;
            # %tunneling jumps through %JRom
            ps&JRom and me&tunnelArrive,p,e,{toJR:1};

            $pat = &li{ return me&printpath,l,i };
            # start/onward ideally knowing the last R
            $li = l.indexOf(Rc&b);
            if (li < 0 && !es&tunneli) {
                # matching t from the top
                $ln = me.cby(p);
                each in ln {
                    $u = l[i];
                    u.t != n.t and throw "not tunn in", pat(l,i), n.t
                    es&tunneli = i
                }
                ~>4 nonb top: pat(l,i)
            }
            if (li < 0) {
                $lin = es&tunneli+1;
                $exp = l[lin];
                !exp and return es&beawake ||= {shortpath:R}
                # matching t)
                exp.t != R.t and throw "not tun", pat(l,i), R.t
                li = lin;
                ~>4 nonb along: pat(l,lin)
            }
            # li is decided
            es&tunneli && es&tunneli != li-1 and throw "irreg"
            es&tunneli = li;
            c.toJR and return

            # tunnel begins
            es&tunnelin == null and es&tunnelin = es&tunneli
            $next = l[es&tunneli+1];
            # tunnel ends
            !next and return es&beawake ||= {nonpath:R}

            # %tunneling builds tunnel_now
            $ln = es&tunnel_now ||= [];
            ln[li] = R;

            !l[es&tunneli+1] and return es&beawake ||= {pathend:R}
        };
        # make child
        me.tunnelJRom = &acgtRbe{
            !bs&JRom and throw "b!%JRom"
            $c = ex({},bs&JRom);

            $l = es&tunnel;
            # beyond this R/r%JRom
            $froml = es&tunnel.slice(es&tunneli+2);
            $next = froml[0];
            # must be another JRom, or reawakens
            #  to leave tunnel mid-JRom with correct sc
            delete c.pause;
            delete c.neednt;
            if (!me&ioty,froml,'JRom' .length) {
                if (next && bs&returns && bs&returns != next
                    && next.t != bs&returns.t) {
                    # not for the main thing of the JRom
                    #~>7 nonmain: next.t, bs&returns.t
                    c.pause = 1
                }
                elsif (!me&ioty,froml,'reawakens' .length) {
                    # a !%reawakens main thing in the JRom
                    es&beawake ||= {wandRom:R}
                }
            }

            !c.pause and c.tunneling = e

            c.Recb = &r{ ac(e,'JRs',r) };
            $r = me&Rom,R,c;
            return r
        };
        },
        #c e 6 tunneling individua
        # impersonate the last awake sc fuller
        #  now that we won't be switching things on
        #  eg inheritsc can't be trusted
        ['sleeping+tunneling','94',&acgtRs{
            each kv Rc&b.sc {
                R.sc[k] ||= v;
            }
        },'ift,D'],
        # to put a JRom to sleep, such that ^ happens
        ['neednt','18',&acgtRs{
            #Rs&tunneling = Rs&neednt;
            #Rs&sleeping = 1;
            ~>5 neednt but did: R.t
        },'ift,D'],
        ['tunneling','18',&acgtRs{
            $e = Rs&tunneling;
            Rs&sleeping and debugger;
            es&beawake and return
            #Rs&Citop and return

            me&tunnelArrive,R,e;
            es&beawake and return es&tunnelout = R

            $lin = es&tunneli+1;
            $N = es&tunnel[lin];
            # < join many involves separating the es&tunnel
            #   want to use X
            !isar(N) and N = [N]
            $M = [];
            each ib N {
                $c = {};
                c.tunneling = e;
                if (isar(b)) {
                    $en = Cye(['divaw',8]);
                    eny&top = ey&top || e;
                    eny&up = e; ac(e,'divawz',en);
                    ens&tunnel = es&tunnel.slice();
                    # a tunnel[ ends in one multiplicity
                    ens&tunnel.length != lin+1 and throw "multimultipath"
                    ens&tunnel.splice(lin,1,...b);
                    ens&tunneli = es&tunneli;
                    ens&tunnelin = es&tunnelin;
                    #eny&top == eny&up and debugger;
                    b = b[0];
                    c.tunneling = en;
                }

                Rc&N.indexOf(b) >= 0 and throw "b current"
                c.t = b.t;
                M.push(c);
                # < subtly repoint s with slep
                c.s = bc&s;

                # it knows {$gk:{use}}
                # strategy for a widely held gk
                #  eg %Slei, %Codon, %ball
                # for rolling their other sc
                $aw = bs&reawakens;
                aw and c.reawakens = aw
                else {
                    # others inherit if of type
                    aw = me.cbu(R,'reawakens');
                    aw = aw && aws&reawakens;
                }
                if (aw) {
                    # see if strategy is for this R
                    $use = 0;
                    each tw aw {
                        b.sc[t] and use = w
                    }
                    if (use) {
                        # < babz this 'each, k use.rollbs'
                        if (use.rollbs) {
                            use.rollbs.split(',').map(&k{
                                hak(b.sc,k) and c[k] = b.sc[k]
                            });
                        }
                        use.sc and ex(c,use.sc)
                    }
                    bs&ball and c.ball = 1
                    bs&tightly and c.tightly = 1
                    aw.wake_parent && !es&tunnel[lin+1] and c.wakeasparent = 1
                }
                else {
                    # %reawakens implies %tunneling to it is ok
                }
                # general
                ['Gens','Zuctto'].map(&k{
                    b.sc[k] and c[k] = b.sc[k]
                });
                # JRom skip %tunneling
                if (bs&JRom) {
                    # < to sleeping+JRom/%Domeds,
                    #   as opposed to the JRom%returns
                    #    see also es&beawake = {nonmain:R}
                    c.JRom = bs&JRom;
                }
                else
                !c.reawakens && aw && !use and c.noreawakens = 1
                c.b = b
            }
            #c doing, depending on awakeness theory
            $bailifany = &k{
                $dont = M.filter(c => c[k]);
                !dont.length and return
                $l = markt(M,dont,&{ return '%'+k });
                ~>5 t5out: '>3 '+R.t, ...l
                es&tunnelout = R;
                $be = es&beawake = {};
                be[k] = R;
                return 1
            };
            $markt = &MNy{
                $l = [];
                N ||= [];
                y ||= &c{};
                each ic M {
                    l.push(c.t);
                    N.includes(c) and l.push('>7 '+y(c))
                }
                return l
            };

            # last yay many R should be awake sometimes
            bailifany('wakeasparent') and return
            # R wakes to generate r out of strategy
            # < other children may sleep?
            #   intervening very early (Ret?)
            #   or once they S that it is still
            #    < a mode of ambient awareness
            #   near: which parent to T.wake
            #    after A:eing something somewhere
            bailifany('noreawakens') and return

            # and doesn't
            Rs&sleeping = 1;
            # recycle before children arrive is ideal
            me&recycleRbitXz,R;

            # or inflates individuals with %tunneling
            each ic M {
                $b = delete c.b;
                if (c.JRom) {
                    $r = me&tunnelJRom,R,b,e;
                }
                else {
                    $r = me&Ret,R,c;
                    Rs&z.filter(n => n == r).length != 1 and debugger;
                    me&zN,r;
                    Rc&N.filter(n => n == r).length != 1 and debugger;
                }
            }
        },'ift,D'],
    ] };
    #c Fourismness Elfor=Codon|Slei
    me.Fourismness = &acgt{ return [
        ... me&Zavingness ,
        ... me&Elvisingness ,
        ['Domebegin','278',&acgtRs{
            $C = G&Cye,['Vubd',1,{},{mune:1,impausible:1}];
            $D = me&ballRom,R,C;
        },'ift,D'],

        ['mune','278',&acgtRs{
            me&walla,'hu:7';
            Rs&Utilis = 1;
            # we may have a request
            # from 4c&callback(e) 
            $g = A.up.ground;
            $e = gc&e;
            !e and return
            $c = {in:4};
            me&elvis,R,e,c;
        },'ift,D'],

        ['mune','3',&acgtRs{
            # Codon/experiment
            me&Rom,R,'Elfor';
            # wash
            me&Rom,R,'Evelse';
        },'ift,D'],

        ['Elfor','291',&acgtRs{
            # write code
            n Flar  R %Codon,ting:W,Gens
            # lingo patch panel
            #n ForThe  R %ting:W,Gens,tingspot
            # test sleep
            #n Sleigh  R %Slei,ting:W,Gens,tingspot
        },'ift,D'],
        #c %Evelse, nto
        ['Evelse','291',&acgtRs{
            Rs&rowish = 1;
            $p = Ry&up;
            if (!ps&Evelse) {
                4s&Elvact = R;
                s&mb = 20;
                # input/output piles:
                $el = 4s&Elvacts;
                $so = Rc&s = me&rollbsc,R,'sorted';
                sos&z ||= [];
                sos&inc ||= 1;

                $ftime = &Ls{
                    $l = L.slice();
                    if (s) {
                        # say each bit of timestamp different
                        $dif = [];
                        each id l {
                            s [i] != d || dif.length and dif.push(d)
                        }
                        l = dif;
                    }
                    $ms = l.pop();
                    ms == null and ms = L.slice(-1)[0]
                    ms.length <3 and l.push(ms); ms = null
                    $times = l.slice(-3);
                    $dates = l.slice(-6,-3);
                    $s = "";
                    dates.length and s += dates.join('-')+' '
                    times.length and s += times.join(':')
                    ms and s += "."+ms
                    return s
                };
                # group into time
                $timegap = 4;
                me&ioty,el .map(&n{
                    if (!ny&sorted) {
                        ny&sorted = so;
                        each ie ns&z {
                            # ignore e into W:Evelse
                            each ij es&JRs {
                                js&Te == Rs&Te and return
                            }
                        }

                        # i $so/%now<>nc&time<3
                        $co = sos&z.slice(-1)[0];
                        if (!co || coc&timetil+timegap < nc&time)
                            co = fio(so,"#"+sos&inc++)
                        coc&time ||= nc&time;
                        coc&timetil = nc&time;
                        $ch = fio(co,n,0);
                        if (ch) {
                            chy&seria ||= '';
                            chy&seria += 'a';
                            n.t += chy&seria;
                        }
                        fio(co,n);

                        # formatted timestamp key
                        $times = n.t.split(/\D+/).slice(0,-1);
                        if (!sos&last_time) {
                            sos&last_time = times.slice(0,-1);
                            sos&in_time = ftime(sos&last_time)
                        }
                        ns&in_time = ftime(times,sos&last_time);
                        sos&last_time = times;
                    }
                });

                # header
                !sos&z.length and return

                $se = me&case,2;
                $to = sey&can('o','tooli');
                tos&dis = 3;
                $eo = toy&can('c','tools');
                $trunc = me&mtsc,eo,'trunc',0,'y'
                $truncate = &{
                    # truncate elvis log
                    me&ioty,el .map(&n{
                        Gtime(nc&time) > 60 and fio(el,n,9)
                    });
                    me&ioty,so .map(&n{
                        Gtime(nc&timetil) > 60 and fio(so,n,9)
                    });
                    ~>6 truncated:
                };

                me.nto(R,trunc,truncate);

                $N = me&ioty,so;
                each in N {
                    n $n.t  $s:n,R %Evelse:2,Timegroup
                }
                i > 9 and truncate();
                T.nN.reverse();

                # footer
                $se = me&case,7;
                sey&can('i',sos&in_time);
                #me&tsc,'intime',sos&in_time,'G' .y.cv = 0.8;

                n Elvito  R %Tool

                #n Teing  $s:Rs&Te,R %ball,tightly
            }
            elsif (Rs&Timegroup) {
                me&domesticate,R
                if ((Rs&boost||0)<=-1) {
                    $p = Ry&up;
                    fio(pc&s,Rc&s,9);
                    n deleted  s:deleted %fs:6,hs:594
                    return
                }
                me&ioty,s .map(&m{
                    n $m.t  $s:m,R %Evelse:2,Timebit
                });
                T.nN.reverse();
            }
            #c %Evelse%Timebit...
            elsif (Rs&Timebit) {
                # < Abodisish align subrows across %Timegroups
                # timestamp key
                #me&domesticate,R
                me&tsc,'in_time',ss&in_time,'b'
                me&tsc,'direction',ss&direction,'y','fs:22,lh:0.5,ma:0.2,hs:339'

                each ie ss&z {
                    me&tsc,'i'+eti,e.t,'y','fs:18,lh:0.5,hue:33'

                    $eti = i+':'+e.t;
                    if ((Rs&boost||0)>0) {
                        n $eti  $s:e,R %Evelse:2,Elvisbit
                    }
                    else {
                        es&R and me&tsc,'es&R','R:'+es&R.t,'b'

                    }
                }
                (Rs&boost||0)>0 &&
                    n Timebit  $s:s,R %Evelse:2,Elvisgroup
            }
            elsif (Rs&Elvisgroup) {
                me&tsc,'t',R.t,'y','fs:12,lh:0.5,hue:33'
                (Rs&boost||0)<=0 and return
                sy&R and me&nu,"R",sy&R;
                me&nu,"Timebit",s
            }
            elsif (Rs&Elvisbit) {
                Rs&Elvisbit > 1 and me&walla,'b:3.2,hu:-3';
                Rs&Elvisbit > 2 and me&walla,'hu:3';
                me&tsc,'t',s.t,'y','fs:18,lh:0.5,hue:33'


                sc&type and me&tsc,'sc&type',sc&type,'g'

                sc&pack and me&tsc,'sc&pack','pack@'+sc&pack.t,'g'
                ss&act and me&tsc,'ss&act','act@'+ki(ss&act,2),'g','hs:999'
                ss&R and me&tsc,'ss&R','R:'+ss&R.t,'b'

                sc&wake && !isar(sc&wake) &&
                    me&nu,'sc&wake',sc&wake
                ss&edone and me&tsc,'ss&edone',ss&edone,'g'
                each kv ss&beawake {
                    me&tsc,'sc&pack','beawake:'+k+'@'+v.t,'g'
                }
                $se = me&case,'vlal';
                if (ss&flatup) {
                    $fl = sey&can('i','%flatup');
                    if (fls&ope) {
                        $co = sey&can('c','%flatups');
                        each iN ss&flatup {
                            $ro = sey&can('w','flat'+i);
                            each in N {
                                ss&tunnel && ss&tunnel[i*1+2] and continue
                                $ol = roy&can('c','col'+i);
                                $be = me&mtsc,ol,'tunnel'+i,n.t,'y';
                                me&walls,be,'b:3.2';
                            }
                        }

                    }
                }
                sey&notifempty();

                if (ss&tunnel_now) {
                    $l = (ss&tunnel||[]).slice(ss&tunneli||0);
                    me&tsc,'tunnel',0,'y';
                    each in ss&tunnel_now {
                        $be = me&tsc,'tunnel'+i,n.t,'y';
                        me&walls,be,'b:3.2';
                        ns&error and me&tsc,'error',ki(ns&error,2),'B'
                    }
                }
                each ie ss&z {
                    $eti = i+':'+e.t;
                    n $eti  $s:e,R %Evelse:2,Elvisbit:2
                }
                each ie ss&divawz {
                    $eti = i+':'+e.t;
                    n $eti  $s:e,R %Evelse:2,Elvisbit:3
                }
                (Rs&boost||0)<=0 and return
                me&nu,"elvisy",s
            }
            else {
                me&tsc,'t',R.t,'y','fs:18,lh:0.5,hue:33'
                #me&domesticate,R
                # some time, more details
                me&nu,'detail',{s:Rc&s}

            }
            ah(R,'reawakens','Evelse',{
                rollbs:'Evelse,Timegroup,Timebit,Elvisgroup,Elvisbit',
            });
            #me&introqua,[R,'A'],{boost:1}
            #me&zu,"4s&pathout",4s&pathout;
            #me&zu,"4s&Slsz",4s&Slsz;

            #me&zu,"A",A.4;

            # %ball transfigurations (move,copy,etc)
            #n Elviso  $s:4s&elvisory %R:ball
        },'ift,D'],
        #c unihab
        ['sleeping+Utilis','28',&acgtRs{
            if (!me&ollbs,R,'Inn' ) {
                # wake up (after error?)
                ~7 lost Inn:
                delete Rs&icate;
                delete Rs&sleeping;
                return
            }
            me&rollbs,R,'Inn,Incremento';
        },'ift,D'],
        ['Utilis','291',&acgtRs{
            # window/A.4 goes to sleep
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });

            # this toplevel-ish R may take ages
            Rs&timetopause = 3418;

            # spending time in/out of the callback
            $g = me&opeolo,'plane';
            $ti = gy&can('n','time');
            me&mtsc,ti,'timein',4s&ms,'6' .sc.fs = 12;
            me&mtsc,ti,'timeof','/','g'
            me&mtsc,ti,'timeout',4s&nonms,'6'

            # %ball activations (just %R -> JRom)
            Rs&playsheet = {
                ball: &acgtR{
                    me&Bear,R,Rc&s,'play'
                },
                fix: &acgtR{  },
            };

            # remotes
            # news from the editor
            me&Rom,R,'GhodigWap';
            # newsroom behind all %tings
            Rs&Inn = me&Rom,R,'Search';

            # one variety of walking around names
            #  climbing X, < other structures
            #  invent linguistic surface bubbler
            me.upsit = &acgtRt{
                $z = me.cby(R).reverse();
                each in z {
                    $X = nc&X;
                    $oX = X && X.x && X.x[t];
                    oX && oX.z and return oX.z[0]
                }
            };
            me&rollbs,R,'Incremento';
            Rs&Incremento = (Rs&Incremento||0)+1;
            if (Rs&Incremento == 2) {
                ['GhodigWap','Search'].map(&t{
                    $r = me&upsit,R,t;
                    r && me&introqua,r,'boost:-1';
                })
            }
            # another thing-ink dripper:
            #        $he = Rc&N[0];
            #        $i = hes&inti = (hes&inti||0)+1;
            #        me&tsc,'%Zave',i+'th','y';
            #        i == 2 and debugger
            # the first few %settings are usually important:
            #    me&tsc,'%Zave',haks(R.sc).slice(0,10).join(','),'y';

        },'ift,D'],
        #c func eCsc, remember, Dispon
        &{
        # zap in css sc, so it stays there
        # also returns callback to apply css to an element
        me.eCsc = &acgtRtc,weakly{
            # they persist
            $was = Rs&eCsc && Rs&eCsc[t];
            # keep the later wave of style
            was && weakly and return
            isst(c) and c = G&peel,c
            # realise work is done
            was && heq(c,was) and return &{}
            
            ah(R,'eCsc',t,c);
            # returns hash of css
            $ctocss = &c{
                $C = Cye([t+'-style',1]);
                ex(C.sc,c)
                $st = 4s&styler ||= me&styler;
                $css = {};
                st(C,css);
                return css
            };
            return &el,{
                $css = ctocss(c);
                was and was = ctocss(was)
                each kv was {
                    css[k] and continue
                    $(el).css(k,'');
                }
                was = null;
                $(el).css(css)
            };
        }
        # R's element
        me.Dispon = &acgtR{
            $r = me&Disp,R;
            return r && rs&on
        };
        me.Disp = &acgtR{
            Ry&Display and $D = Ry&Display
            D && Ds&on and return D;
            $b = Rc&b;
            b && by&Display and $D = by&Display
            D && Ds&on and return D;
        };

        # < harness such datastructure for %Zave!
        # save/resume L%k = C(t y)+
        me.remember = &acgtLk{
            $d = L.sc[k];
            !Lc&W and throw "!cW"
            $store = 'remember/'+Lc&W+'/'+k;
            if (d) {
                delete dc&thaw;
                $more = &d{
                    $l = [d.t,d.y.cv];
                    each in ds&z {
                        l.push(more(n))
                    }
                    return l
                };
                localStorage[store] = enj(more(d));
            }
            else {
                $s = localStorage[store];
                !s and return L.sc[k] = Cye([k,1])
                $more = &l{
                    $d = Cye([l.shift(),l.shift()]);
                    each in l {
                        fio(d,more(n))
                    }
                    return d
                };
                d = L.sc[k] = more(dej(s))
                dc&thaw = 1
            }
            return d
        };
        },
        #c %Codon
        # < leading the way

        # cloud of %Codon and related types inheriting
        ['Codo','2901',&acgtRs{
            # %Codon not inherited through %JRom
            Rs&Codon = 1;
            # %Codo inherited through %Gens to first %ball,
            #  leading back here to %Codon it
            Rs&Gens and ac(R,'inheritsc','Codo');
        },'ift,D'],
        ['Codon','291',&acgtRs{
            $p = Ry&up;
            # non-%Codons
            Rs&fix && ps&Code && ps&ball and Rs&Cofix = 1
            !(Rs&ball || Rs&Gens) and delete Rs&Codon; return
            ac(R,'inheritsc','Codon');
            ah(R,'reawakens','Codon',{
                rollbs:'Codon,Codo,Codoor,Codin,Code,Cofix'
                    +',Gens,self,Here,Zaving'
                    +',Abodo,eCsc,Codinner',
            });

            !Rs&ball and return
            me&rollbs,R,'eCsc';

            $c = me&tsc,'%Codon','C','B';

            # %Codon dives:
            #  %Abodo/%Codoor/%JRom/%Codo%Gens
            #    /%Codo%Codin/%Code
            # the %JRom and %Gens are !%ball
            $Codo = me.cbub(R,&r{ return rs&Codo && rs&ball },'Gens');
            if (!Codo) {
                $Abodo = me.cbu(R,'Abodo');
                # screenful %Codon
                !Abodo || Abodo == R and Rs&Abodo = 1
                else {
                    # to JRom
                    Rs&Codoor = 1
                }
            }
            else {
                # first Codo
                Codo == R and Rs&Codin = 1
                else {
                    Rs&Code = 1
                }

            }
        },'ift,D'],

        # an out%ball sprouts JRom:Codo
        # < feed openness
        ['ball+Codo','33',&acgtRs{
            $h = me&tsc,'%Codo','ball+Codo','6'
            me.nto(R,h,&{ Rs&Doop = 1 });
            me&ollbs,R,'Doop' and Rs&z.map( r => me&elvis,R,'Dooping',{wake:r} );
        },'ift,D'],
        ['Codoor','296',&acgtRs{
            # the latest %ball%Codin hangs out:
            me&rollbs,R,'Codinner';
            me&rollbs,R,'incount';
            Rs&incount ||= 0;
            Rs&incount++;

            me&tsc,'%Codo','bout-'+Rs&incount,'6'

            $c = {};
            c.Doming = 3;
            c.Codon = 1;
            c.Codo = 1;
            # avoid JRom ...
            $e = Rs&tunneling;
            (!e || !es&beawake) && Rc&b and c.neednt = 1
            $r = me&ballRom,R,s,c;

            # was:
            # auto %play any %R=Codo|Code
            #  similar to $t%W=nott, nott being a pin to decode it through
            #   future is decoding W with other W
            # < use the in/out %ball for openness/thumbnailing
        },'ift,D'],

        ['Gens+Codon','293',&acgtRs{
            $c = me&tsc,'%Codon','Gedo','g';
            # %Zaving instead of Gens+ting
            Rs&Zaving = "mem,W";
            delete Rs&ting;
        },'ift,D'],
        #c Abodo..Codo
        # entire lab
        ['ball+Abodo','297',&acgtRs{
            # position:fixed leaves its parent
            s&po = 3;
            s&left = '0';
            s&top = 0;
            s&width = '55%';
            s&height = '100%';
            s&over = 'scroll';
            s&attr = {class:'fathandle'};
            #s&bgi = '/i/IMG_3524.JPG';
            Rs&rowish = 0;

            $init = !me&rollbs,R,'incount';
            Rs&incount ||= 0;
            Rs&incount++;
            $c = me&tsc,'%Codon','Abodo-'+Rs&incount,'g';

            # as well as reawakens:Codon,
            ah(R,'reawakens','Abodo',{rollbs:'Abodo,Alooseion'});
            # allows attention in Abodis while sleeping Abodo
            me&rollbs,R,'Alooseion';

            if (init) {
                $(4s&msgs).css('left','55%').css('width','45%')
                    .css('background','#000');
            }
        },'ift,D'],

        ['NinetySixer','96',&acgtRs{
            $N = Rs&NinetySixer;
            each t,cb N {
                cb('NinetySixer');
            }
        },'ift,D,sleeping'],
        # for any tunneling through %Abodo
        # < should be when the elements are on screen
        #   requiring all R^^ to Display,
        #    then Cupon posthooks etc
        #    they a kind of elvis?
        ['Alooseion','98',&acgtRs{
            $Al = Rs&Alooseion;
            each t,cb Al {
                cb('Alooseion');
            }
        },'ift,D,sleeping'],

        ['ball+Abodo','38',&acgtRs{
            n Codap  R %Codap
        },'ift,D'],
        ['ball+Abodo','6',&acgtRs{
            $N = me&ioty,R,'ball';
            each in N {
                $c = ns&C;
                # will be undone when %Abodis heightens everything
                # pl:14 =~ ab,left:14,height:...
                ns&ball and me&eCsc,n,'Abodo','ml:14',1
            }
        },'ift,D'],
        ['Codap','38',&acgtRs{
            # < TEST why such extravagant memory loss
            #   without this %reawakens, clicks here wakes %Abodo
            #   then its %Codoors c.neednt badly,
            #   < JRom post-error/pre-history better
            ah(R,'reawakens','Codap',{rollbs:'Codap,Loc'});
            
            s&dis = 1;
            s&po = 3;
            s&top = '5%';
            s&height = '90%';
            s&width = 14;
            #s&left = '5em';
            s&over = 'scroll';
            me&walla,'b:2.2,bg:3423';
            Rs&rowish = 0;

            $Abodo = me.cbu(R,'Abodo');
            # to sample attention from
            $Loc = me&rollbsc,R,'Loc';
            Locc&W = Abodo.t;
            
            #c Codap extends Abodis
            # accumulating to f.*, which we receive
            #  f.hatch($t,$arg) may be used to call them
            # or if f isnt around, eg from nto:
            #  Rs&fengi($otherT,$t,$arg) entrances
            # the f.o.* are hatched along the feng()
            #   able to T.waits to break
            
            # animal of these handlers
            n Abodis  R %Abodis
            
            # init f, once per R:Abodis
            $f;
            ah(R,'Abodish','o',1,&tT{
                f = t;
                $at = f.at;
                $on = ats&on;
                $con = ats&con;

                $wasleft;
                window.lon = on;
                on.onscroll = &ev,{
                    # == Gtime()
                    f.com.scrolltime = ev.timeStamp / 1000;
                    # < interface for formula watching
                    if (wasleft != on.scrollLeft) {
                        wasleft = on.scrollLeft;
                        $(con).css('left','-'+wasleft+'px');
                        $re = con.getBoundingClientRect();
                        re.right < 0 and 'sleep'
                    }
                };
                f.hatch('trailstyle');
                # e->f entry, eg nto callback, hatch with arg
                Rs&fengi = &TtO{
                    f = f.com.f;
                    f.hatch(t,O);
                    T.wake ||= 'not';
                };
            });
            # delays calls until replaced on init
            Rs&fengi = &TtO{
                T.lotsfengi ||= 0;
                T.lotsfengi++ > 3 and throw "!init fengi"
                G&delay,0.02,&{Rs&fengi(T,t,O)}
                T.wake = 'not';
            };
            
            # handle things todo, from things just rendered
            ah(R,'Abodish','o',22,&fT{
                Abodo = f.Abodo;
                
                each tO Abodos&fengtodo {
                    O == 'not' and continue
                    f.hatch(t,O) and return
                    Abodos&fengtodo[t] = 'not' 
                }
                delete Abodos&fengtodo;
                
                Rs&seekto and f.hatch('Codon_point',Rs&seekto)
            });
            
            #c center keeps
            
            # < flying into the one thing, its environment piling in
            #   as we know it's /ghost/such first,
            #   winding up Gensetc in the background,
            #   merging preemptive R with the native
            
            # seekto resume Loc%center
            $c = me&remember,Loc,'center';
            cc&thaw and Rs&seekto ||= c
            # others may set this
            me&rollbs,R,'seekto'
            
            # notice where center of view is
            #  as fractions of %Codin(/%Code)
            ah(R,'Abodish','o',71,&fT{
                $din = f.Codepointer();
                !din and return
                #~>3 center: ki(din,2), ki(ner,2)
                Locs&center = din;
            });
            
            # scroll to counteract repositioning
            ah(R,'Abodish','o',6,&fT{
                # see where we're looking
                $at = f.at;
                # select one at center to keep scroll to
                $din = f.Codepointer();
                !din and return f.heighten();
                # one Codin|Code, before|after
                $da = f.Codeba(din);
                f.heighten();
                $ba = f.Codeba(din);
                !ba and return
                dac&R != bac&R and throw "din!ba R"
                
                $move = das&top - bas&top;
                $abso = ats&top - move;
                atc&s = ba.t+" "+move+": "+abso;
                
                f.on.scrollTop = abso
            });
            
            #c %Code acts
            
            # %Code that wants typing into (%initCode)
            ah(R,'Abodish','o','Codon_curse',&fTr{
                r = me&yfuture,r;
                $cm = rs&cm;
                !cm and ~>6 lost cm: r.t
                !cm and return
                
                ~>6 Into cm: r.t
                cm.focus();
                cm.execCommand('goLineEnd');
                # < seekto it, ideally...
                G&yl:6,&{ cm.scrollIntoView() };
            });
            
            # Codap%seekto=din to go there
            ah(R,'Abodish','o','Codon_point',&f,T,din{
                # < specify seekto is the intent,
                #   drop on fail/success
                # < seekto as %loca, any depth/describitude
                #    as SCA ring
                dinc&ttl ||= 5;
                if (--dinc&ttl == 0) {
                    # might be things on trail no longer in W
                    # < loose bits of uncommitted W to reintro
                    delete Rs&seekto;
                    ~>2 seekto gives up:
                    return
                }
                T.waits = 'seekto';
                ~>2 seekto:
                f.heighten();
                
                $c = {};
                $thing = f.Codeba(din,c);
                $fora = c.fora;
                if (!thing) {
                    # elvises unopen path (without %Codinner=%Codin)
                    T.waits and return
                    # or it cancels the go
                    return delete Rs&seekto
                }

                $at = f.at;
                $on = f.on;
                
                $scroll = on.scrollTop + things&top;
                if (foray&cv != 0.1) {
                    # put center
                    scroll -= ats&gapy / 2;
                    # yay far down
                    scroll += things&height * foray&cv
                }
                on.scrollTop = dec(scroll);
                ~>7 sunk: ki(fora,2)
                delete Rs&seekto;
            });
            
            # Loc/** to %seekto
            ah(R,'Abodish','o','Codon_click',&fTO{
                $D = Oy&up;
                D == Loc and D = null
                !D and D = O; O = null
                $seek = Cye([D.t,1]);
                O and $onto = fio(seek,O.t)
                $t = Locs&trail;
                if (onto && t) {
                    $la;
                    each in ts&z {
                        la and break
                        n.t != D.t and continue
                        each ij ns&z {
                            j.t != O.t and continue
                            
                        }
                    }
                    la and ontoy&cv = lay&cv
                }
                # note exactly where we leave
                f.hatch('casual','doit');
                Rs&seekto = seek;
                ~>2 Seek: ki(seek,2)
                # as very fast 
                T.feng = 1;
            });
            
            #c pointers: gapy<->ba<->din
            # din from gapy
            # < redo "pointer", f.ind thing
            ah(R,'Abodish','Codepointer',&point,{
                $at = f.at;
                point ||= ats&gapy / 2;
                # for %Codoor
                $din = f.atpoint(point);
                    $oor = dinc&R;
                    !oors&Codinner and return
                $N = f.balls(oors&Codinner);
                !N and ~>6 noseeingcenter:
                !N and return
                # for %Code
                $ner = f.atpoint(point,N,'exactly');
                ner and fio(din,ner);
                return din;
            });
            
            # din to ba, space item amongst f.balls
            ah(R,'Abodish','Codeba',&din,c{
                c ||= {};
                # din/ner is sheer openness, two layers
                #  < good shape of thing to stream space solvitude around
                #  < should be ind magic, use cases are here
                
                # for %Codoor
                $v = f.M.filter(n=>din.t==n.t)[0];
                !v and ~>2 seek!found: din.t
                !v and return
                    # which links into itself like s&Js&top
                    $Codoor = vc&R;
                    $Codin = Codoors&Codinner;
                    if (!Codin) {
                        me&elvis,R,'seekto',{wake:Codoor};
                        T.waits = 'seektowake:'+Codoor.t
                        return
                    }
                
                # for %Code, maybe
                $cn = (dins&z||[])[0];
                if (cn) {
                    $n = f.balls(Codin,cn.t)[0];
                    !n and return
                        # which must look ready < know Zave/waits
                        $nr = n && nc&R;
                        $s = nr && nrc&s;
                        !s || ss&string == null and n = null
                        !n and ~>6 waitseek: din.t, cn.t
                        !n and return
                }

                $at = f.at;
                $on = f.on;
                $thing = n || v;
                c.fora = cn || din;
                return thing
            });
            
            #c grow trail
            me&remember,Loc,'trail';
            $muchdif = &ab{
                a *= 1;
                b *= 1;
                return b > a + 0.05
                    || b < a - 0.05
            };
            $muchpoint = &din,don{
                $nir = (dins&z||[])[0];
                $nor = (dons&z||[])[0];
                return din.t != don.t || nir.t != nor.t
                    || muchdif(diny&cv,dony&cv)
                    || muchdif(niry&cv,nory&cv)
            };
            # to casually be somewhere
            # location accumulator
            ah(R,'Abodish','o','casual',&f,T,doit{
                # trail wanders along
                $t = Locs&trail;
                !t and throw "noitime"
                ts&z ||= [];
                $don = ts&z[0];
                # we are on it
                $din = Locs&center;
                $ner = (dins&z||[])[0];
                $nor = (don&&dons&z||[])[0];
                # don't trail 1-pointers
                !ner and return
                
                doit = doit || !don || muchpoint(din,don);
                !doit and return
                doit== 'doit' and ~>7 doing leave: ner.t
                # add a place we were
                $tr = Cye(din);
                trs&z = dins&z.slice();
                ts&z.unshift(tr);
                f.hatch('trailstyle');
                # slow down
                ts&changey ||= 0;
                ts&changey++;
                ts&changey < 5 and return
                delete ts&changey;
                
                blurtrail(t);
                
                me&remember,Loc,'trail';
                
                $ner = (dins&z||[])[0];
                ~>3 strail: ki(din,2), ki(ner,2)
            });
            # trail/$Codin+/$Code+ pointers smush down
            # < scaling up, grouping into each other
            $blurtrail = &t{
                $tend = 30;
                $ima = 100;
                while (ts&z.length > 5 && ima-- > 0) {
                    $tw = {};
                    $not = [];
                    each in ts&z {
                        $m = delete tw[n.t];
                        # for two %Codin
                        !m and tw[n.t] = n; continue
                        not.push(n);
                        each il ns&z {
                            # leave more recent Code fraction
                            ms&z.filter(L => L.t == l.t).length and continue
                            fio(m,l)
                        }
                    }
                    each in not {
                        $ni = ts&z.indexOf(n);
                        ni < 0 and throw "notnot"
                        ts&z.splice(ni,1);
                    }
                }
                while (ts&z.length > 30) {
                    # we gradually blur into time,
                    #  easiest to exclude (eg a curve) first
                    ~>2 blurtrail truncates:
                    ts&z.pop();
                }
            };
            
            
            #c stylepile!!!
            # < center changes faster
            # < to unify all waits-ing, sparkles of activity
            # < pointers through !O%ope should ...
            
            # rebuilds r:Abodo/** to O:Loc/**
            $sch = {
                schinf:['Codin','Code'],
                # really Abodo/Codoor/.../Codin/Code
                # < handle being for the %Codoor until let in
                schifat:{Codoor:{scto:'Codinner'}},
                # links each Oc&R=r, Rs&Org=O
                O:'Org',
            };
            $Org = me&indother,Abodo,Loc,sch;
            $se = me&case,2;
            ses&fs = 16;
            
            # map drawn
            # ! d.d > 3 (Code/Code) causes e loop
            # ! cant seekto a Code!string
            # < ind a floppy case
            $ma =
            n map   %bg:033,dis,ws:0
            delete mac&s;
            $selfs = Org.self(&rOds{
                # Oc&n = map modulat
                $se = d.se;
                # n/{t,...,z/...}
                se and $ze = fio(se,'z'); zes&ml = 1;
                $n = fio((ze||ma),s.t);
                d.se = Oc&n = n;
                nc&forgk = ds&gk;
                
                ns&ma = 0.3;
                ns&hue = 70;
                
                $t = ny&label = me&mtsc,n,'t',s.t,'g';
                # wraps to keeps whole
                ts&dis = 2;
                ts&fs = 12;
                d.d == 2 and ts&fs = 18; ns&dis = 1;
                # clicks in the map
                me.nto(R,n,&sTe{
                    ~>4 selfs: n.t, e.t
                    Rs&fengi(T,'Codon_click',O);
                    T.wake = 'not';
                });
                # clicks on their label (dont boost)
                Oc&nto_label = &sTe{
                    ~>4 others: n.t, e.t
                    
                    T.wake = 'not';
                };
                
                return O
            });
            
            
            $shut = sey&can('n','shut');
            shutc&s = '';
            me.nto(R,shut,&sT{
                Locs&trail = Cye(['trail',1]);
                # and delete the explicit tinkering
                selfs.map(O => Os&ope = 0);
            });
            
            #me&tsc,'selfs',selfs,'b' .sc.dis = 1;
            
            #c map styled!
            # O-memorised c-styling n-modulat
            $apply = &Onc{
                $modon = me&Dispon,n;
                me&eCsc,O,'trailstyle',c (modon);
            };
            ah(R,'Abodish','o','trailstyle',&fT{
                # apply styles to Loc/*/* map
                ~>7 trailstyle!:
                
                # start using that pointer
                # < to steer around (d.not=1)
                $cent = me&doint,'center',Locs&center;
                $tra = me&doint,'trail',Locs&trail,{};
                # looking for the center
                # < look at center and any Rversioned since,
                #   and the last path we thought it was
                
                
                Org.other({y:&rOds{
                    $sc = {};
                    $n = Oc&n;
                    $l = ny&label;
                    
                    cent(s,d) and sc.deco = 1
                    # points over time (which is lost)
                    # < ind reducing/knowing reduced,
                    #   could keep nulls in between
                    tra(s,d) and sc.bri = 1.2
                    
                    # init
                    Os&ope == null && haks(sc) and Os&ope = 1
                    # explicit tinkering
                    Os&ope and sc.fs = 14
                    
                    if (rs&Code) {
                        $cm = rs&cm;
                        if (cm) {
                            # < some Org styling should lead to f.heighten()
                            #  < %height that knows to apply to cm,
                            #    and join it into this geometry quest
                            #cm.heighten(55);
                        }
                    }
                    
                    apply(O,l,sc);
                },anycha:&chad,{
                    each id chad {
                        $go = ds&cha;
                        ~Othigone: d.ind, d.s.t, ki(go,4.23)
                    }
                    # < hierarchy to tunnel
                    me&elvis,R,'Orgup'
                }});
            });
            
            
            # random printouts!!
            $se = me&case;
            $i = 0;
            each tv Loc.sc {
                !isC(v) and continue
                i++;
                $ca = sey&can('m',t);
                !cas&ope and continue
                cas&dis = 1;
                
                $y = &sd{
                    return d.d == 2 ? s.t : ki(s,2)
                };
                $s = me&ind,v,y;
                $d = me&mtsc,ca,t,s;
                ds&hue = i * 60;
                ds&dis = 1;
            }
        },'ift,D'],
        #c indother!!!
        &{
        
        # surf into S, not S itself
        #  
        me.indother = &acgtSOd{
            $initc = &y{
                $c = ex({},d);
                isha(y) and ex(c,y); c.yy = delete c.y
                else { c.yy = y }
                return c
            };
            $topO = O;
            return {
                self: &y{
                    $c = initc(y);
                    c.y = &rds{
                        # i Loc/...
                        d.O ||= topO;
                        O = d.O = me&syncup,d.O,s;

                        # Oc&R=r, rs&Org=O
                        c.O and me&futlink,O,c.O,r
                        
                        # middle
                        $re = c.yy ? c.yy(r,O,d,s) : r;
                        return re;
                    };
                    c.finaly = &rds{
                        $gone = me&syncdown,d.O,(ds&z||[]).map(d=>d.O);
                        gone.length and ~>5 Orggone: ki(gone,4.23)
                    };
                    return me&indo,S (c)
                },
                other: &y{
                    $c = initc(y);
                    c.schexcuse = 1;
                    c.y = &Od{
                        # Oc&R=r yfutures, rs&Org=O
                        $r = d.S = me&futlink,O,c.O
                        r && isC(r) and $s = rc&s
                        
                        # middle
                        $re = c.yy ? c.yy(r,O,d,s) : r;
                        return re;
                    };
                    $chad = [];
                    c.finaly = &Od{
                        # can now trust d.S beyond
                        #  to be the latest r inside r
                        $r = d.S;
                        # r/* not in O/*
                        #  as sch would filter it
                        $Z = (rs&z||[])
                            .map(r => c.schableto(r,null,d.d+1))
                            .filter(r => r);
                        $neu = me&syncdown,Z,(ds&z||[]).map(d=>d.S),'noop';
                        
                        # O/* not in r/*
                        $gone = me&syncdown,O,(rs&z||[]).map(r=>r.sc[c.O]),'noop';
                        
                        $cha = [...neu,...gone];
                        !cha.length and return
                        
                        # gone will be always be O, neu always S
                        # < hierarchy to tunnel
                        ds&gone = gone;
                        ds&neu = neu;
                        ds&cha = cha;
                        chad.push(d);
                    };
                    $re = me&indo,topO (c);
                    chad.length && c.anycha and c.anycha(chad)
                    return re
                },
            }
        };
        
        #c indo-f
        
        # climb pointer C
        #  returns callback to test in middle
        me.doint = &acgtknc{
            !isC(n) and throw "pointer !C";
            c ||= {tw:1};
            c.tw && ns&z && !ny&tw and throw "pointer C!tw"
            k = "p_"+k;
            $topn = n;
            return &sd{
                $h = d[k];
                n = topn;
                # they match s.t unless:
                !n and return
                h == 'not' and return
                if (c.tw) {
                    # default, begins matching n
                    if (!h) {
                        n.t == s.t and h = n
                    }
                    else {
                        h = fio(h,s.t,0);
                    }
                }
                else {
                    $N = [];
                    # begins matching n/*
                    if (!h) {
                        N = ns&z || []
                    }
                    else {
                        each in h {
                            !isC(n) and throw "inpointz !C", n
                            N.push(...ns&z)
                        }
                    }
                    h = N.filter(n => n.t == s.t);
                    h = h.length && h
                }
                !h and d[k] = 'not'
                else {
                    d[k] = h
                }
                return h
            };
        };
        
        # make/keep Oc&R=r, rs&Org=O
        me.futlink = &acgtOtr{
            r and Oc&R = r
            !Oc&R and return
            r = Oc&R = me&yfuture,Oc&R;
            r.sc[t] = O;
            return r
        };
        
        # replication
        # i going in
        me.syncup = &acgtDs,noop{
            $S = fio(D,s.t,0);
            noop and return !S
            S and return S
            S = fio(D,s.t);
            Sy&up = D;
            return S
        };
        # o coming out
        me.syncdown = &acgtDz,noop{
            !isar(z) and throw "z=[s+]"
            isar(D) && !noop and throw "D=[] !noop"
            $Z = isar(D) && D || Ds&z || [];
            $gone = Z.filter(&s{
                # refs not names
                return !z.includes(s)
            });
            noop and return gone
            each is gone {
                $S = fio(D,s.t,0);
                S != s and throw "inexactly"
                fio(D,s.t,9)
            }
            return gone
        };
        
        #c indo
        # < BAB me&ind,v,...{\n should let us close the bracket
        # me&indo,r ({sch:['Types'],y:&rds{ ...
        #  supposing rc&s=s
        me.indo = &ACGTsd{
            d ||= {};
            # callback r before r/**, still depth first
            d.cbfirst ||= 1;
            return &y{
                $N = [];
                $ay = &yrd{
                    $s = isC(r) && rc&s;
                    return y (r,d,s)
                };
                if (isha(y)) {
                    $c = y;
                    c.schinf and c.sch = c.schinf
                    if (c.sch) {
                        c.beyond ||= 1;
                        c.schableto = &r,d,depth{
                            if (!d) {
                                # middle may call schableto(somer,null,depth
                            }
                            else {
                                # avoided for the other
                                c.schexcuse and return r
                            }
                            depth ||= d.d;
                            $schi = depth - 2;
                            # < climb to it: inheriting, opening
                            $gk = c.sch[schi];
                            !gk && c.schinf and gk = c.sch.slice(-1)[0];
                            !isC(r) and return
                            $fail = !r.sc[gk];
                            
                            if (fail && c.schifat) {
                                # for switching d.s into a link
                                each kv c.schifat {
                                    # if we're a %Codoor
                                    !r.sc[k] and continue
                                    !v.scto and throw "!scto"
                                    # with a %Codinner
                                    $or = r.sc[v.scto];
                                    !or and continue
                                    # that is %Codin, as it were
                                    !or.sc[gk] and continue
                                    r = or;
                                    fail = 0;
                                    break
                                }
                            }
                            fail and return
                            # sometimes hypothetical, no d yet
                            if (d) {
                                ds&gk = gk
                            }
                            return r
                        };
                    }
                    y = &rd{
                        d.sc = {};
                        # for those inside s
                        c.beyond && d.d <= c.beyond and return
                        if (c.sch && d.d > 1) {
                            r = c.schableto(r,d);
                            !r and return d.not = 1
                            # < should be re-2'd (SCA)
                            r != d.s and d.s = r
                        }
                        $re = c.y ? ay(c.y,r,d) : r;
                        if (!d.not) {
                            # flat list, depth first
                            N.push(d);
                            # each ds&z = [d+]
                            ac(d.up,'z',d);
                        }
                        return re
                    };
                }
                $re = me&ind,s,y,d;
                if (c) {
                    c.finaly and N.map(d => ay(c.finaly,d.s,d))
                }
                return re
            };
        };
        
        #c ind climb C
        # from 26:NutCertainty
        me.ind = &acgtsyd{
            # setup
            d ||= {};
            if (!d.refs) {
                d.refs = []; # all things
                d.refid = {}; # those indices to d
            }
            y ||= &s{ return s }
            if (typeof y == 'string') {
                if (y.slice(0,2) == 'ki') {
                    $dl = y.slice(2);
                    y = &s{ return ki(s,dl) }
                }
                else { 
                    throw "ind y named", y
                }
            }
            
            $i = {};
            # dedupe (s always an Object)
            i.refin = &ds{
                $ri = d.refs.indexOf(s);
                if (ri < 0) {
                    ri = d.refs.push(s) - 1;
                    d.refid ||= {};
                    d.refid[ri] = d;
                    return 1
                }
                else {
                    $od = d.refid[ri];
                    # dupe seeing very interesting for -jod
                    return;
                }
            };
            !i.refin(d,s) and return

            if (d.hup) {
                # clone each thing, not repointing tw/tv/z etc
                # < a separate object, a map to the result of the map this is
                #d.infolate == null and d.infolate = 1;
                $D = s;
                s = G&Cye,s;
                s.y.D = D;
            }

            $dd = &d{
                d = ex({},d);
                d.path = (d.path||[]).slice();
                return d
            };
            $up = d.out && d;
            d = dd(d);
            up and d.up = up
            d.s = s;
            $pi = d.path.push(s.t+' '+s.y.cv)-1;
            # accumulates on every depth's return of a string
            d.ind = d.ind == null ? '' : d.ind+'  ';
            d.d ||= 0;
            d.d++;
            # depth limit vs depth
            d.dl && d.dl < d.d and return;

            $out = d.out = [];
            $one;
            $my = [];

            d.cbfirst and one = y(s,d)
            d.not and return
            d.nofurther and return one
            
            if (d.s != s) {
                !i.refin(d,d.s) and throw "switched s dup ref"
                s = d.s;
                d.path[pi] = s.t+' '+s.y.cv;
            }

            # )
            #c the ways to go deep, should be all? will dedup
            # user throws something on any way
            if (ss&z) {
                $z = ss&z.filter(&s{ return 1 && s });
                d.zort and d.zort(z,s,d);
                each iD z {
                    out.push( me&ind,D,y,d );
                }
            }

            if (s.y.in) {
                out.push( me&ind,s.y.in,y,d );
            }

            if (s.y.tw) {
                each tD s.y.tw {
                    out.push( me&ind,D,y,d );
                }
            }

            if (s.y.tv) {
                each tvD s.y.tv {
                    out.push( me&ind,D,y,d );
                }}
            }

            out = out.filter(&s{ return 1 && s });
            # flatten a bit, G&ind returns js arrays
            $oute = []; 
            out.map(&s{
                s.constructor == Array ? 
                    s.map(&s{ oute.push(s) })
                : oute.push(s)
            });
            out = oute;

            out = out.filter(&s{ return 1 && s }).map(&s{
                if (typeof s == 'string')
                    return s.split("\n").map(&s{ return '  '+s }).join("\n")

                if (typeof s.constructor == Object) {
                    if (d.infolate) {
                        if (!sc&ind) {
                            # (once) write where things are
                            # on the things themselves
                            sc&ind = d.d;
                            sc&inds = '';
                            $i = 0; # to d.d==1 for the first level
                            while (i++ < d.d)
                                sc&inds += '  ';
                            sc&inside = d.path;
                        }
                    }
                    my.push(s);
                }
                return s
            });

            if (s.y.next && !d.nonext) {
                $od = dd(d);
                od.path.pop();
                od.d--;
                out.push( me&ind,s.y.next,y,od );
            }

            !d.cbfirst and one = y(s,d)
            d.not and return
            out.unshift(one);

            out = out.filter(&s{ return 1 && s });
            !out.length and return
            $retrefs = out.filter(&s{ return typeof s != 'string' }).length > 0;

            if (d.d == 1 && !retrefs) {
                d.wantarray and return out
                return out.join("\n");
            }
            else {
                # an N with insidenesses, has been organised, located...
                # put insides (s&z,yin) in a z on the outside
                my.length && typeof one == Object and ones&z = my
                # return every C in N, each G&ind leaves [] to dissolve
                $flat = [];
                each is out {
                    s.constructor != Array and flat.push(s); continue
                    each IS s {
                        flat.push(S);
                    }
                }
                return flat
            }
        };
        },
        #c Abodis clockworks geometries
        # adjust scroll after we redraw to keep focus
        ['Abodis','292',&acgtRs{
            me&walla,'b:2.4,h:7';
            # can generate elvis for anywheres
            $cb = &{ me&elvis,R,'Dooping',{wake:R} };
            $del = Rc&b ? 5.3 : 0.01;
            #G&delay,del,cb;
            #!Rc&b and return
            
            ~BLapa
            $Abodo = me.cbu(R,'Abodo');
            $Codap = me.cbu(R,'Codap');
            $f = {};
            f.com = me&rollbs,R,'comf',{};
            f.com.f = f;
            f.init = 1;
            
            each tv f.com {
                Rc&Verbose and me&nu,t,v
            }
            # for any tunneling through %Abodo
            ah(Abodo,'Alooseion','Abodis',&{ f.shui() });
            
            f.hatch = &tO{
                $T = {};
                $cb = f.o[t] || f[t];
                !cb and return
                cb(f,T,O);
                T.feng and G&delay,0.001,&{f.shui()}
                T.waits and return 1
            };
            f.o = {};
            $minds = [Codap];
            each in minds {
                $uf = ns&Abodish;
                !uf and continue
                $o = ex(f.o,uf.o);
                ex(f,uf);
                f.o = o;
            }
            f.shui = &mode,{
                $began = Gtime();
                # < Abodo knowing better its outoftime function waterfallery
                Abodo = f.Abodo = me&yfuture,Abodo;
                Codap = f.Codap = me&yfuture,Codap;
                f.com.f != f and return
                f.on && !f.on.ownerDocument.contains(f.on) and return
                # to shui not in a hurry since the last shui
                # < may never happen if you shui faster than this delay
                $cb = me&sccb,R,'shui_casual',&{f.shui('casual')};
                G&delay,2.14,cb;
                
                # try to avoid doing while scrolling
                # < A.4 etc using these things,
                #   everyone pooling timestyles,
                #    esp on drag, everyone holds breath
                $ro = f.com.scrolltime;
                ro && Gtime(ro) < 0.5 and return G&yl,444.04,&{f.shui(mode)}
                
                # f.at - view, also f.on/f.con
                $at = f.at = f.where();
                if (!(ats&on && ats&con)) {
                    ~>2 muntedaton:
                    return G&yl,444.04,f.shui
                }
                if (ats&gapy < 500) {
                    ~>2 skinty: ats&gapy
                    return G&yl,444.04,f.shui
                }
                # f.M - Codoors
                f.M = f.balls(Abodo);
                
                # check dom semi arrived
                $N = f.M && f.M.filter(m => (ms&height||0) < 22) || [];
                if (!f.M || N.length) {
                    ~>2 heightholes: N.map(n=>n.t).join(',')
                    return G&yl,144.04,f.shui
                }
                
                # wait for the Abodo to be done
                # elvis shunting awake cn
                # which we can rely on %Alooseion to reactivate us after
                $JR = me.cbu(Abodo,'JRom');
                if (JRs&elvoids) {
                    f.com.beenwaiting ||= 0;
                    $i = f.com.beenwaiting++;
                    ~>2 stashed?: i
                    return
                }
                if (f.com.beenwaiting) {
                    ~>2 Ready: f.com.beenwaiting
                    delete f.com.beenwaiting
                    return G&yl,0.01,f.shui
                }
                
                if (f.init) {
                    f.hatch(1) and return
                    delete f.init
                }
                f.hatch(22) and return
                
                # sleepytime same geo
                $is = [ats&left,ats&top,
                    ...f.M.map(m=>ms&top+':'+ms&height)]
                    .join(",");
                $still = is == f.com.was;
                f.com.was = is;
                
                if (!still) {
                    f.hatch(6) and return

                    f.hatch(71) and return

                    mode && f.hatch(mode) and return
                }
                ~>2 shui: Gtime(began), mode||'...', still?"still":""
            };
            
            #c Abodis...
            # measure each|one r/*%ball
            f.balls = &rt{
                $M = [];
                $N = me&ioty,r,'ball';
                each in N {
                    t && t != n.t and continue
                    $ba =
                    m $n.t  $R:n
                    bas&on = me&Dispon,n;
                    !bas&on and return
                    $re = bas&on.getBoundingClientRect();
                    bas&height = re.height;
                    bas&top = re.top;
                }
                return M
            };
            
            # the view
            f.where = &{
                $at = Cye(['attend','']);
                $on = f.on = ats&on = me&Dispon,Abodo;
                $con = f.con = ats&con = me&Dispon,Codap;
                !on and return at
                # position of the view
                ats&top = on.scrollTop;
                ats&left = on.scrollLeft;
                # size of the view
                ats&gapx = on.offsetWidth;
                ats&gapy = on.offsetHeight;
                # scrollable ground (> view)
                ats&width = on.scrollWidth;
                ats&height = on.scrollHeight;
                return at
            };

            # apply absolute positioning
            f.heighten = &M{
                M ||= f.M;
                $sum = 0;
                each i,ba M {
                    $r = bac&R;
                    # < skip dis:0 - the recently open
                    $css = 'po,left:14,width:100%,top:'+dec(sum)+'px';
                    # overwrites the other eCsc Abodo
                    $apply = me&eCsc,r,'Abodo',css;
                    apply(bas&on);
                    sum += bas&height;
                }
                f.M = f.balls(Abodo);
            };
            
            # make C = t, fraction, {R,at}
            #  for point in ats&gapy
            f.atpoint = &point,M,exactly{
                M ||= f.M;
                $la;
                $precisely = 0;
                each i,ba M {
                    la = ba;
                    bas&top + bas&height < point and continue
                    bas&top > point and continue
                    precisely = 1;
                    break;
                }
                # tries to return something if !exactly
                exactly && !precisely and return
                $ba = la;
                $prog = point - bas&top;
                $frac = dec(prog / bas&height);
                frac < 0.001 and frac = 0.001
                frac > 0.999 and frac = 0.999
                return Cye([ba.t,frac,{R:bac&R,ba:ba}])
            };
        },'ift,D'],
        #c Codo inside
        ['ball+Codin','296',&acgtRs{
            $c = me&tsc,'%Codon','Codin','g';
            me&walla,'hu:17';
            # is left outside
            #  is JRom's s&Js&top
            $oor = me.cbu(R,'Codoor');
            oors&Codinner = R;
            s&bgh = '111';

            #n saying   %e,fs:8,bgh:010,ma:1,pa:1,va
            $n = me&quainto,'add-ghost';
            ns&fs = 12;
            $say = me&Tie,R,'add-ghost',1;
            say and me&input,R,say .sc.initCode = 1;

            # < feed openness
            #Rs&beopen ||= 1;
        },'ift,D'],

        # fixturism
        ['ball+Code','293',&acgtRs{
            # W becomes worth saving
            $Ge = me.cbu(R,'Gens');
            (me&ollbs,Ge,'onceinhabited' || [])
                .map(y => y ());

            me&rollbs,R,'incount';
            Rs&incount ||= 0;
            Rs&incount++;

            $c = me&tsc,'%Codon','Code-'+Rs&incount,'g';

            4s&thecode = R;
            Rs&Zaving = "tmp,ghost";
            Rs&compLines = &D{
                # < %size of it, texture, headings
                # < %ghost=dig(%string)
                delete Ds&string
            };
            Rs&initCode and ss&string = "# "
        },'ift,D'],

        ['fix+Cofix','296',&acgtRs{
            #$c = me&tsc,'%Codon','Cofix','g';

            # < feed openness
            Rs&beopen ||= 1;
            $p = Ry&up;
            !ps&Code and throw "Cofix^!Code"
            R.t == 'string' and Rs&hoistcm = p
            
        },'ift,D'],
        
        &{
        # erase labels etc
        me.mowthing = &acgtR{
            if (Rs&ball) {
                [['','%Codon'],['Be','clicktoplay']]
                    .map(l => me&Mwty,R,...l ).filter(n=>n)
                    .map(n => n.c.not = 1);
                $t = me&Mwty,R,'ball','t';
                delete ts&deco;
                # let the map hook label clicks
                # < defer to what would happen (^^R%elvis) if modeening unsatisfied
                #    inc trying to push a value past its maximum,
                #     which would inc. maxed value adjustment
                me.nto(R,t,&sTe{
                    # < ind various kinds of d.matter, io.input etc
                    #   which has some this should be C,
                    #    C up should down it, etc observables
                    $O = Rs&Org;
                    !O and return ~>7 no O yet: R.t
                    $y = Oc&nto_label;
                    !y and return ~>7 nto_label missing: R.t
                    y and y (...arguments)
                });
            }
            else {
            
            }
            $N = me&Mwty,R,'','','';
            each in N {
                ns&va == null and ns&va = 1
            }
            return t
        };
        },
        ['ball+Codin','4',&acgtRs{
            $t = me&mowthing,R;
            ts&fs = 55;
            s&bgh = 331;
            s&pl = 0;
            delete s&bo;
        },'ift,D'],
        
        ['ball+Code','88',&acgtRs{
            $t = me&mowthing,R;
            ty&cv = 0.1;
            ts&fs = 55;
            
            $p = Ry&up;
            s&bgh = '311';
            !ps&Code and s&pl = 0
            delete s&bo;
            
            # < io doing: {} easy, ^^ efforty
            # i {ah:fengtodo:Codon_curse} o ^^%Abodo/$R%initCode
            if (Rs&initCode) {
                $Abodo = me.cbu(R,'Abodo');
                ah(Abodo,'fengtodo','Codon_curse',R)
            }
        },'ift,D'],
        
        ['fix+Cofix','4',&acgtRs{
            R.t == 'string' and me&Mwty,R,'fix','k' .c.not = 1
        },'ift,D'],
    ]};
    #Fiveplan#######################################c 

    =editor
        make way into /G/$cat/$way
        organised by /W/$cat of $way+
      will be
        network of %Gens%Codon

      monday:
        fold markers
          < upload to ball or hide on the first line?
        discover new Loc/** per new R:Abodo
         ind revival unlimits pointers
      tuesday:
       style map
      wenesday:  #####################
       style %Codes, remove %bo
       cm.heighten()
       
       < feed openness
         start closedish depending on Loc%*
         
         
       < user, goes SCA, they pull via Search, etc
          would planet but not Planet?
      v goo tuner ^
       < interactive widgets want tiny Displays,
         eg for the map to redraw,
         knobby adjustables
         
     %Codap
       map:
        names change colour accordingly, fast collapse
        lessthink if not on screen
        know git trouble centrally
       pointers:
         should me&ind more,
          know cm and line,ch
       
      wednesday:
       fixed multi-tunneling: non-first doesnt Display
         because me&ing iterated Rs&z while it unrecycles
          as seen by Lafr/a not e:init-pull,
           f.seek seeing !ms&height
       %Abodo starts (%elvoids?)
        resumes point, unless you give it extra wakes:
         seek waits while ^^%elvoids only
         < know of outstanding %elvoids for ^^%JRom
           seek a bit, then more/finally
            all the loose ends of the Codon would generate some e
            as such was stylehouses first life
           would break off after 0.2...
      
      thursday:
        separate %Codap/%Abodis
        resumes point in last many %Codes per %Codin
         trail/$t%Codin+/$t%Codes squishy log
          < grind time, sweet genes
            collapsing into the unified samepoint
            as finding the coherent several diffs
            along a trail of string evolution
      friday:
        trail the leaving
      sat:
        cm.focus should pause 4
        style %Code
        
      ideologies:
        < Zaving 67-7 'e preempt and group other e'
        < learn a slep scan to reduce into Cit
          from the in-pile, applying schemas, noticing freaks
          presenting normalisable (into Cit) structure
           the receptive phenomenon
          oscillator application
        < convert to names, replay for testing




     # elvising
        #  < talks to JRom of A.4
        #     from inside A.4, brokering async
        #     moves e towards completion
        #  < callback() is able to lose e
        #    set down e, check they complete
        #    plane should throttle, delay e
    #c moreplan
       editor:
        %Abodo
        re-scrollto the %Codin,
          is about hosting many pos:ab together
           using their computed height/width
           harnessing them with foldways
          scroll to keep the view same when rearranging

        %Codo openness map
          not %Te
           > deciding limbs of it are abandonable
             time-separated limbs
          list of t at depths
           draw current viewport over it
           attention/change history
          with empty space to defocus, to allow:
          typing into space puts search through:
        %Codo search
          preventDefault a C+F event?
         prioritised by where we are
          then knowing all %Codo/%Code/%Zave=mem
           then /ghostack/
         presenting them as %Codo around us
          disjointed, to be pulled in
           as dependencies/further reading

        re-undohistory the %Codes

      sleep
       < 4s&pause while %busy
         %busy while cm.focus
         %busy near typing/scrolling/mouse waving
          e want to now or later
       < modulats awaking as a faster layer of change
         those 82-4ish pile sorters give one M

      random:
       < %Search (centralised %tings)
        < delivering updates
        < trust /digwaypoll/ for /ghost/
         the %Idoubleyou ($Way to %Ghostway)
          should be defining seeketh/seekend
          so %Search can ting them,
           group for consumers T.wake=%ting

     tumeke
       cm.blur makes e:say, should be enough
        < /tmp/ faster (while typing)
          cm.focus starts 5s timers
           e:mutter -> %Code (around %busy)
            the %Zave=ghost only listening to e:say
          involves some:
        < %Here tricks:
          < different %Heres per %Zave
          < %differ switching up %self and collecting %Here
          < when/how to encode:
          < avoid re-%Lines depending on slep,
            or by accounting for all change

      unfolding labby mess, way too many dimensions:
       and bring some automation over the top
       saving opennesses, stacking their difference:
         < such that it can be relied upon by others
           who includes it is security over time
           time = distance over the network

        %Code%Zaving:
          o - overall com dot, clicking in
          (~|-| |!) inside/next to o
          for (wild|got|still|err)
           relationships to their stores/consumers
            probably having one each (G/W)
          < which are G - space for belief
           G store:
             wild - tmp stored (recent keystrokes)
             got - fully stored (available to consumers)
             err - compiletime errors
              may not know args of way
               they could be made up from error messages
           G consumer:
             wild - ghost updating
             got - runtime ok
             err - runtime errors

         < chase 'Kn-burst' error, boosting a medo%fix 
           while Km:Display(Kn:Mw) is there, not zuctedto
           < forward escape &KnowSmush

    =cut
    #c %Zaving %Codons
    me.Zavingness = &acgt{ return [
        # watch the game, sequence pushes
        # by timing/commit policy
        # to these locations
        ['Zaving','294',&acgtRs{
            if (Rs&Gens && !Rs&self) {
                # Gens @25:
                #  rollbs %self
                #Rs&self = G&Cye,[R.t,'',{},{}];
                # Gens+self @31:
                #  Rings %Here = R self)%ball
            }
            $lo = Rs&Zaving.split(',');
            Rs&Zaving = {};
            each il lo {
                i *= 1;
                $t = R.t +' Zaves '+ l;
                $n =
                n $t  $Zave:l,R

                if (l.length == 3) {
                    # tmp%ting%directory = AutoSave/ghost/$t
                    $next = lo[i+1];
                    next and ns&AutoSave = next
                }
            }
        },'ift,D'],
        # overseeing our data's particular ...
        ['Zaving','67',&acgtRs{
            $allready = 1;
            $allnine = 1;
            each tn Rs&Zaving {
                $h = me&Rsc,n,'Here';
                $t = me&Rsc,n,'Saveting';
                $Q = t && ts&Q;
                $P = Q && Qs&P;
                !P || !Pc&el and allready = 0
                else
                Pc&el != 9 and allnine = 0
            }
            if (Rs&Code) {
                if (!ss&string) {
                    if (!allready || !allnine) {
                        # let it arrive
                    }
                    else {
                        $t = me&tsc,'init-string','+string?','B';
                        me.nto(R,t,&sT{
                            ah(R,'nextlifesc','initCode',1)
                        });
                        Rs&LetGrow = 1;
                    }
                }
                ss&string == '# ' && allnine and Rs&LetGrow = 1
            }
            elsif (Rs&Gens) {
                # to reset a %Gens, put %self
                if (allready && allnine && !Rs&self) {
                    Rs&self = Cye([s.t,1]);
                    me&elvis,R,'init-self';
                }
            }
            if (!allready) {
                # < e preempt and group other e
                #   with a ledger of e to Search
                #me&elvis,R,'tingback',{wake:R,delay:0.3,W:Search};
            }
            if (Rs&LetGrow) {
                # centralised pause 
                $old = me&tsc,'LetGrow-pause','..?','d';
                olds&fs = 16;
            }
        },'ift,D'],
        #c %Zaving 7 - unify autogits
        # see overall com dot
        # lum=
        #  0: disappear
        #  1: sym+%Zave, some modulat
        #  2: everything
        # < parameters?
        #   volume - how much to say about changes
        #   pause - no acting (%Unsure currently?)
        #   rewind - to a point (see %differ switching up)
        #   speed - push while typing, etc
        ['Zaving','7',&acgtRs{
            # displaycase room
            s&dis = 1;

            $g = me&case,5;

            $de = gy&can('o','describe');

            $sym = dey&can('c','sym');
            $l = symy&can('i','output','s:o,fs:22');

            $gi = gy&can('c','gits');
            $allope = 0;
            each tn Rs&Zaving {
                $na = ns&Zavingna = giy&can('c','git-'+t);
                nas&dis = 1;
                me&zuct,na,n;
                ns&waits and allope = 1
            }
            # < amb wake waits until settled
            #    delay/drum machine
            # < e preempt and group other e
            #    the waits might log to e already
            #    invalidated by eg e:tingback
            #allope and me&elvis,R,'waitsing',{wake:R,delay:2};
            # lum=2 - leave cases open
            allope || ls&ope and return
            # lum=0 - nothing
            $allzen = 1;
            each tn Rs&Zaving {
                ns&wants || ns&summary and allzen = 0
            }
            if (1 && allzen) {
                each tn Rs&Zaving {
                    ns&noDisplay = 1
                }
                return
            }
            # lum=1 - somewhat: minidmo + wants
            each tn Rs&Zaving {
                $na = ns&Zavingna;
                # should look at patch
                ns&wants && ns&Unsure and continue
                # wants to look at patch (click summary)
                me&rollbs,R,'Lookat_'+t and continue
                #me.nto(R,na,&{ R.sc['Lookat_'+t] = 1 });

                ns&noDisplay = 1;
                # have a tiny id
                each im ns&minidmo {
                    delete ms&dis;
                    fio(na,m)
                }
                $su = ns&summary;
                su and fio(na,su); sus&fs = 7; sus&lh = 0.3;
                each im ns&wants {
                    !su and throw "wants !summary"
                    fio(na,m)
                }
            }

        },'ift,D'],
        #c %Zave - saving thing tricks!!!
        # aft %Gens 25:
        # %Zaves collect
        ['Zave','291',&acgtRs{
            $p = Ry&up;
            ah(p,'Zaving',Rs&Zave,R)

            $ting = Rs&Saveting ||=
                n $p.t  $ting:Rs&Zave,R

            if (Rs&AutoSave) {
                tings&directory = "AutoSave/" +
                    (Rs&AutoSave != 1 ? Rs&AutoSave+'/' : '')
            }

        },'ift,D'],
        # %Zave <-> %Save completes
        ['Zave','32',&acgtRs{
            $p = Ry&up;
            if (ps&Gens) {
                # %Here = s%string)%ball
                # Gens @25 rolls %self,
                # Gens+self @31 makes %Here
                $h = Rs&Here = me&Rsc,p,'Here';
                if (me&rollbs,R,'Describing' ) {
                    !h and return me&waits,'!h@32'
                    hs&Lines = 3
                }
            }
            elsif (ps&Code) {
                # %Here = %ball(s%string
                Rs&Here = pc&s;
                me&rollbs,R,'Describing' and 'conjoin'
            }
        },'ift,D'],

        # also these tiny details
        ['Zave','292',&acgtRs{
            $p = Ry&up;
            $ting = me&Rsc,R,'Saveting';

            if (Rs&Zave == 'ghost') {
                # filed under se%Codin: G/$se/$t
                $din = me.cbu(R,'Codin');
                !din and delete Rs&Zave; return me&waits,'no^^%Codin'
                tings&section = din.t;
                # fixes !section on initCode commit
                $Q = tings&Q;
                Q and Qs&section = din.t;
            }

            # they cache each other
            me&ollbs,R,'Settled' and return
            Rs&AutoSave and return
            each tn ps&Zaving {
                R == n and continue
                # < this climb should be a couple of sc
                $tting = me&Rsc,n,'Saveting';
                $tQ = tting && ttings&Q;
                # sync %ting can happen
                if (!tQ && tting) {
                    ns&AutoSave and me&Ring,R,{und:tting,ov:314}
                    else {
                        # past would do
                        tQ = me&ollbs,tting,'Q';
                    }
                }
                $tQ = tting && ttings&Q;
                tting && !tQ and me&tsc,"tmp!Q"
                $tP = tQ && tQs&P;
                if (tP && tPs&dige) {
                    !tPs&string and throw "dige but not string"
                    ah(R,'havediges',tPs&dige,tPs&string)
                }
            }
            Rs&havediges and tings&havediges = Rs&havediges
        },'ift,D'],
        #c Zave autogit
        # and git harness for %Code or %Gens
        # late so %Saveting for %Gens happens
        #  tmp should be ready, ghost will have sent
        #   unless its storage/place is local
        #    within this javascript runtime/elvisability
        #     /insideness
        #    which may have time to process the request
        ['Zave','68',&acgtRs{
            # chop up a displaycase
            s&dis = 1;
            me&rollbs,R,'Described,Committing,Whichto,Unsure';
            $g = me&case,2;
            # can do:!
            #gy&can('ope',&{ while_open() });

            $gi = gy&can('c','git','fs:17');

            $de = gy&can('c','describe');

            $sym = dey&can('c','sym');
            # hoisted by Zaving lum=1
            ac(R,'minidmo',sym);
            ac(R,'minidmo',me&tsc,Cye(['Zave','',{s:Rs&Zave}]),0,'G' );

            # big < and/or > symbols
            $l = symy&can('n','local');
            $r = symy&can('n','remote');
            ly&label = me&mtsc,l,'local','','B';
            ry&label = me&mtsc,r,'remote','','B';
            [l,r].map(&s{ s = sy&label; ss&lh = 0.5 });



            # settings after logic may change them
            $and_finally = &{
                # we have eg to,from = l,r
                #  where 'pull' == (Rs&Wantsto || Rs&Whichto)
                # <> control/show flow
                #  extra clicking makes Unsure
                #   and could open the git log etc
                if (!Rs&Whichto || (Rs&Wantsto && Rs&Amountto < 2)) {
                    # <> flop direction of the patch
                    $Wantingto = &s{
                        Rs&Wantsto == s and return Rs&Unsure = 1
                        Rs&Wantsto = s
                    };
                    me.nto(R,l,&s{ Wantingto('pull') });
                    me.nto(R,r,&s{ Wantingto('push') });
                }
                else {
                    # single < once pulled
                    froms&dis = 0;
                    # tampering with < makes Unsure
                    me.nto(R,to,&s{ Rs&Unsure = 1 });
                }

                if (Rs&Whichto) {
                    # direction it was going
                    $was = Rs&Whichto == 'pull' ? l : r;
                    wass&bri = 1.7
                }

                if (Rs&Unsure) {
                    # resume autopush, various causes
                    $un = me&mtsc,sym,'Unsure-re-autogit','i'
                    me.nto(R,un,&s{ Rs&Unsure = 0; });
                }
            };

            # where the patch etc may live
            $co = gy&can('c','commit','zi:30,po:2');

            $en = gy&can('c','enter');

            $re = eny&can('c','remote');
            Rs&waits_modopt = re;
            me&walls,re,'b:2.2h866';
            res&bgh = '010';

            # and then put this situation in it
            $p = Ry&up;
            $h = me&Rsc,R,'Here';
            $t = me&Rsc,R,'Saveting';
            !t and return me&waits,"Z!ting"
            me&zuct,re,t

            $Q = ts&Q;
            $P = Q && Qs&P;
            !P and return Rc&b && me&waits,"Z!P"
            !Pc&el and return me&waits,"Z!Pel"

            # now on to entering it
            Rs&waits_modopt = en;
            #c timing

            # neighbours - help save time/space
            $neighbours = [];
            each in ps&Zaving {
                R != n and neighbours.push(n)
            }

            # particular types, when & how to git them
            if (ps&Code) {
                # hs&string is always
                $pull = &{ hs&string = Ps&string };
            }
            elsif (ps&Gens) {
                $pull = &{
                    # to reset a %Gens, put %self
                    # see Gens+ting @31
                    $s = ps&self = me&Copy,R,Pc&s .c.s;
                    sy&Pfrom = P;
                    Rs&Describing = 1;
                };
                $old = me&mtsc,co,'Describe','','d';
                olds&fs = 16;

                if (!Rs&Described) {
                    # borrow
                    neighbours.map(&r{
                        !rs&Described and return
                        Rs&Described = rs&Described;
                    });
                }
                if (h) {
                    if (!Rs&Described && !Rs&Describing) {
                        if (ps&Gens && !hc&b) {
                            # init picture from %Gens's ting string
                            # so heads can be compared
                            $s = ps&self;
                            $P = sy&Pfrom;
                            ps&stringguess = P && Ps&string;
                        }
                        if (!ps&stringguess) {
                            oldc&s = '...';
                            old.t += '-awaits';
                            olds&hs = 555;
                            me.nto(R,old,&{ Rs&Describing = 1 });
                            # Code want their Codin saved
                            ac(p,'onceinhabited',&{ Rs&Describing = 1 });
                            gs&fs = 7;
                            # can't think until got
                            return;
                        }
                    }
                    if (Rs&Describing || ps&stringguess) {
                        !h and debugger
                        delete Rs&Describing;
                        # keep a false %Here
                        $De = Cye(h);
                        # < never happens?
                        ps&stringguess and ~stringguess: R.t
                        ps&stringguess and Des&string = ps&stringguess
                        Des&now = Gtime();
                        Rs&Described = De;
                        Dey&Zave = R;
                        !Des&string and debugger
                    }
                }
                $De = Rs&Described;
                if (De) {
                    # the DZ = Dey&Zave = R that made De
                    Dey&Zave and Dey&Zave = me&yfuture,Dey&Zave
                    $DZ = Dey&Zave || R;
                    # not transaction safe:
                    #  current R for a permanence should be set via X
                    Rc&N.indexOf(DZ) < 0 and DZ = R
                    # keep borrowing new De from DZ
                    De != DZs&Described and De = Rs&Described = DZs&Described
                    # we trust the (earlier) neighbour to calc time
                    # then they will look equal
                    DZ == R and DZs&age = Gtime(Des&now)
                    if (DZs&age > 0) {
                        me&mtsc,old,'howold',DZs&age+'s' .sc.fs = 5
                    }
                    $refresh = &{
                        me&elvis,p,'reDescribing';
                        DZs&Describing = 1;
                    };
                    # can be clicked
                    me.nto(R,old,refresh);
                    # lights up when done
                    De != me&ollbs,R,'Described' and olds&bri = 1.7
                    # do when old
                    DZ == R && DZs&age > 20 and refresh()
                    # < when slep/ball/etc wants to
                }
                Rs&Zave == 'W' and Rs&Unsure = 1
            }
            #c look
            $De = Rs&Described || h;
            if (!De) {
                if (!Rs&Here && ps&Gens && !ps&self) {
                    Rs&Wantsto = 'pull';
                    Rs&Amountto ||= 2;
                }
                else {
                    return me&waits,"Z!h"
                }
            }
            if (De) {
                # into time/desire for
                me&rollbs,R,'Settled,Wantsto';
            }

            # wait for changing situation
            $action = neighbours.filter(n =>
                ns&Wantsto == 'pull' && ns&Amountto > 1
            ).length;
            action and return

            if (De) {

            if (!ps&Code) {
                # Code may be Here without string
                Des&string == null and return me&waits,"De!string",0,'B'
            }

            ly&tree = De;
            ry&tree = P;

            # faulter the autocommit
            Rs&Settled != Ps&dige and delete Rs&Settled

            # centralised pause
            ps&LetGrow and return gs&fs = 7

            # init kinda thing
            if (Des&string == null && Ps&string != null) {
                !ps&Code and throw "init pull !Code"
                hs&string = Ps&string;
                me&elvis,R,'auto-pull',{wake:p};
                Rs&Whichto = 'pull';
            }

            # notice situation
            $Settle = &{
                Rs&Settled = Ps&dige;
                delete Rs&Wantsto;
                delete Rs&Amountto;
                Rs&Whichto ||= 'pull';
                if (Rs&Committing) {
                    delete Rs&Committing;
                    me&mtsc,en,'made-commit',"pushed",'B';
                    Rs&Whichto = 'push';
                    me&elvis,R,"pushed",{wake:R,delay:0.4};
                }
            };
            # De may change since push
            Rs&Committing && Rs&Committing == Ps&string && Settle()
            # and separately:
            De && Des&string == Ps&string and Settle()
            else {
                if (Rs&Settled || Qc&el == 9) {
                    # we sync, they follow
                    Rs&Amountto ||= 2;
                    Rs&Wantsto ||= 'push';
                }
                else {
                    # start different or their updates
                    Rs&Amountto = 1;
                    $someSettled = neighbours.filter(n => ns&Settled).length;
                    someSettled and Rs&Wantsto ||= 'push';
                    Rs&Wantsto ||= 'pull';
                }
            }

            if (Rs&Wantsto) {
                Rs&Amountto ||= 1
                Rs&Unsure and Rs&Amountto = 1
            }

            }

            $goingto = Rs&Wantsto || Rs&Whichto;
            $redirection = goingto != Rs&Whichto;
            $to = goingto == 'pull' ? l : r;
            $from = to == l ? r : l;
            #c patch
            Rs&Wantsto == 'pull' && Ps&string == null and delete Rs&Wantsto
            if (Rs&Wantsto) {
                Rs&Amountto ||= 1;

                tos&sha = '3 3 3 777';

                # < patch chunk pluck
                # < commit with message, put somewhere
                #   and other ways to convene to key states
                $pa = coy&can('c','patch','fs:14');
                me&walls,pa,'b:2.2h666';
                pas&bgh = '010';
                pas&zi = 30;


                if (Ps&string == null) {
                    # < Zif could say new
                    Rs&summary = me&tsc,'summary','new!','B'
                }
                elsif (De) {
                    # < attention upgrades to JRom
                    $c = {t:'Zif',Zif:1,neighbours};
                    c.got = fromy&tree;
                    c.exp = toy&tree;
                    $di = me&Ret,R,c;
                    me&zN,di;
                    me&Ring,di,{und:di,ov:314};
                    me&zuct,pa,di;
                    each in dis&waits {
                        ac(R,'waits',n)
                    }
                    Rs&summary = dis&summary;
                }

                $says = Rs&Wantsto;
                $ma = me&mtsc,en,'make-commit',says,'B';
                $commit = &{
                    # wakes this
                    me&elvis,R,Rs&Wantsto,{wake:p};
                    if (Rs&Wantsto == 'pull') {
                        # depends on the thing
                        pull();
                        Rs&Whichto = 'pull';
                    }
                    else {
                        # awaits ack
                        Rs&Committing and mac&s += '..'; return
                        Ps&string == null && Qc&el != '9' and return me&waits,'!ready'
                        !Des&string and return me&waits,'!string'
                        if (Qc&el == '9' && !Rs&Committing) {
                            # wake $Codin on new $Code
                            # < committing subtrees
                            # ! for some reason it doesn't have %Zaving
                            #   find with %Gens for now..
                            $r = me.cbu(R,'Gens')
                            r and me&elvis,R,'1up',{wake:r}
                        }
                        if (Rs&Zave == 'ghost') {
                            Qs&section = me.cbu(R,'Codin').t
                        }
                        
                        Rs&Committing = Qs&string = Des&string;
                        ts&_ting(Q)
                    }
                };

                Rs&waits and '...'
                else
                if (Rs&Amountto == 1) {
                    # clickable talk
                    mac&s += "?";
                    #!di and throw "no %Zif @ Amountto=1"
                    # hoisted by Zaving 7 lum=1
                    # shall be given nto that lum=2s it
                    # keeps nto that commits
                    ac(R,'wants',ma);
                    me.nto(R,ma,&sT{
                        commit();
                        # wakes %ball%Code%Zaving
                        #  and innards (R%Zave)
                        ~>6 waking: p.t
                        T.wake = p;
                    });
                }
                else {
                    commit();
                }

                # remote cell smoodge
                res&po = 2;
                res&left = -2;
                res&pl = 2;
            }
            else {
                #Rs&Zave == 'tmp' && !me&ollbs,R,'crushed' and Rs&crushed = me&mtsc,en,'!crush'
            }
            and_finally();
        },'ift,D'],
        #c Zif
        ['Zif','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            s&ma = 0.2;
            s&pa = 0.3;
            s&lh = 1;

            $g = Rs&got;
            $x = Rs&exp;
            !gs&string and return me&waits,'g!string'
            !xs&string and return me&waits,'x!string'

            $ob =
            n $R.t 13 s:~ %fs:29,lh:0.1
            gs&string == xs&string and return obc&s = '=='
            Rs&boost < 0 and return

            me&rollbs,R,'Digs,Diff,CompN,Comp';
            # < view entirety
            # < switch chunk: word/line
            $c = {chunk:'word',fold:1};
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;
            each in Rs&neighbours {
                $z = me&ioty,n,'Zif'
                    .filter(z => zs&Digs == Rs&Digs)[0];
                if (z) {
                    $su = zs&summary;
                    n $su
                    me&tsc,'as-bove',""+ns&Zave,'G' .sc.fs = 20
                    # < put dupe R with Mlimits,
                    #   to simple api for others, eg:
                    # %Zaving 7 expects this if %wants
                    Rs&summary = su;
                    # < behaviour melts away with lum
                    #   or any customising the patch
                    #   like cell division of the %Zifs
                    #   becoming for particular targets
                    return
                }
            }

            $N = Rs&Diff ||= diff(xs&string||'',gs&string||'',c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }
            me&diffproximate,R;
            $su = Rs&summary =
            n summary  
            sus&z = delete Rs&Mw.diffproximate;


            $p =
            n patch   %max-height:7,over,dis
            ps&z = [...Rs&Comp];
        },'ift,D'],

    #c Zavmo - exercise in surfing modulata
        ['Zavmo','3',&acgtRs{
            Rs&rowish = 1;
            $p = Ry&up;
            if (!ps&Zavmo || Rs&Zavmo > 1) {
                Rs&Zavmo > 1 and me&walla,'bd:3.1h5,hu-7';
                Rs&Zatop = [];
                #s&fs = 12;
                Rs&zoom = 4;
                if (!Rc&b) {
                    # start tiny unless problematic
                    # action awakens to usual degree
                }
                ps&zuctzto and me&zuct,ps&zuctzto,R
                # controls
                $g = me&case,5;

                $de = gy&can('o','describe');

                $l = dey&can('i','local','s:o,fs:12');

                $l = gy&can('m','rolls');
                ls&ope and Rs&opecsc = 1;

            }
            ac(R,'inheritsc','zoom');
            ac(R,'inheritsc','opecsc');
            Rs&zoom ||= 0;
            Rs&boost and Rs&zoom += Rs&boost;
            Rs&zoom -= 0.5;
            $stop;
            Rs&zoom < 0 and stop = 1
            Rs&boost < 0 and stop = 1
            #Rs&zoom < 2 and Rs&opecsc = 0;
            Rs&opecsc ||= 0;
            Rs&opecsc -= 0.5;
            Rs&opecsc < 0 and Rs&opecsc = 0

            (Rs&boost||0) > 0 and Rs&Zatop = []
            $op = me.cbu(R,'Zatop');
            ac(op,'Zatop',R);
            ops&Zatop.length > 22 and stop = 'Zatop-many'

            $g = me&case,5;
            $co = gy&can('c','coordinate');

            # t/y
            Rs&via and me&mtsc,co,'via',Rs&via,'6';

            me&mtsc,co,'t',s.t,'T';
            sy&cv && sy&cv != 0.1 and me&mtsc,co,'cv',sy&cv,'y';
            $scan = Rs&scan = me&scan,s;
            scan.is == 'R' and Rs&isR = 1
            if (scan.is != 'C') {
                $sym = me&mtsc,co,'sym','fs:15,ls:-0.1,zi:-1,hs:4955';
                symc&s = scan.is;
                symy&cv = 0.12;
            }

            # c/sc

            $ca = g;
            # gy&can('c','knowables');
            # unblocks R)%fix
            $Za = cay&can('i','%');
            Zas&ope and Rs&opecsc += 1
            if (Rs&opecsc > 0 && (!Rs&isR || Zas&ope)) {
                me&fixatfour,R,s;
                Rs&Fixturing = ca;
            }

            $cb = ops&Zavmiddle;
            cb and cb(op,R,s,g)
            Rs&stop and stop = Rs&stop

            me&endome,R;
            # & more

            if (Rs&isR) {
                ss&Zavmo and return me&tsc,'loopback','','B' .sc.lh = 0.5;
                # look at modulat inners
                each tin ss&Mw {
                    $z =
                    n $n.t  $s:n %R:Zavmo
                    zs&via = "Mw:"+t
                }}
                each tn ss&M {
                    $z =
                    n $n.t  $s:n %R:Zavmo
                    zs&via = "M"
                }
                return
            }
            else {
                each in ss&z {
                    n $n.t  $s:n %R:Zavmo
                }
            }
            if (stop && T.nN.length) {
                T.nN = [];
                me&tsc,'zoom-in','','B' .sc.lh = 0.5;
            }

        },'ift,D'],
        ['Fixturing','31',&acgtRs{
            me&bewind,R and return
            $ca = Rs&Fixturing;
            $Za = cay&can('i','m');

            me&Knowfix,R,{ca:ca};

            # debug
            Zas&ope &&
                n ZavKnow  $s:ca,R %Zavmo:2,Zavspin

        },'ift,D'],
        ['Zuctto','4',&acgtRs{
            me&zuct,Rs&Zuctto,R
        },'ift,D'],




    ] };
       #c monday?
    =beyondo

        %Codon%Code the contained way
        < concat fragments from %Code/*%Code
         < inside way are hash-c markers, etc
           see cm doc.markText
            so %Code might not have %string,
             once burst into many somethings
         < reordering folded I
         < send patches, of lines & their ranges
            new similar to gone = move
            sub-diff with move abstracted
            # waits for serve.js?


        %Gens starts from out%ball to have in%ball
         < %ino for in feeds out sans s&z
            is a qua muter situation, as is:
             %Lines encoding customs
             %slep deciding where to crawl
             %Te accepting as 'the story'
         < ghost/wormhole happens when in appears
         < %slep for changes, helps %Lines

        room for a tool for composing %slep schema
         < wants to use Zavmo for slep on modulata
         < a wand shedding glow
           pointing for KnowC
           which should be from /W/
           see time above

        slep wanting to be there for most piles
         generating a change awareness (wai)
          we can otherwise effect
           to drive change from/to A something

      thence
        T - phenomenate when going to an aboveness that may not be awake
        G - intelligensiata
        the whole vs. a part
        new git repo, just /G/ and /W/
          ignore, slowly import /wormhole/

      new server
      # generated by `./spot.pl StyleAgent`
      # run `./serve.pl`
        /way/ - compiled code
          sees /G/$se/$way
        /ghost/ - source code
          for /G/$se/$way
          API like /W/
          maintains dige in wormhole/digway/$way
          notifies /digwaypoll/
           < wait 3ms to scoop any batched changes?
            < they come through one %Sock frame
        /digwaypoll/ - code change socket
          watching wormhole/digway/$way

        /W/
          futuristics

        /js/ GONE temporarily?
          needs Beach, etc.
          just host /js/Hunt.js
          comes back when $W has .js file?

    =cut

    # etc
StyleAgent: | # compile serve.pl from Wud + JaBabz
    my $way = sub {
        my $t = shift;
        G.way.>$t || die "No $t";
    };
    my $bab = sub {
        my $s = shift;
        my $C = {t=>'somba',y=>{},c=>{s=>$s}};
        G&CoBabbler;
        C.c.s
    };
    
    my $wab;$wab = sub {
        my $t = shift;
        my $w = $way->($t);
        $t eq 'Wud' && $w =~ s/# insert JaBabz here/$way->('JaBabz')/e;
        $w =~ s/Rw\ JaBabz \$C;/JaBabz(\$C);/sg;
        $bab->($w);
    };
    
    my $f = "serve\.pl";
    my $perl = $wab->('Wud');
    write_file $f, $perl;
    `chmod +x $f`;
    sayre "Done";
Wud: | # restacked Wed server
    #!/usr/bin/perl
    use strict;
    use warnings;
    no warnings qw(uninitialized redefine);
    use FindBin qw($Bin);
    use lib "$Bin/othlia";
    use lib "$Bin/slib";
    use G;
    sub dige { slm(12, Digest::SHA::sha256_hex( encode_utf8(shift) ) ) };
    my ($A,$C,$G,$T);
    my $ar = {};
    
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    # divert mojo log statements from our err channel
    #app->log->path((Gc&ipd || Gc&dir)."/mojo\.log")
    #    if Gc&dir || Gc&ipd;
    
    our $listen = "http://localhost:1422";
    sub starts {
        1 && saybl "Starting     listens: $listen";
        1 && saygr "Appstart: ". app->start('daemon', '--listen' => "$listen");
    }
    sub JaBabz {
        my $C = shift;
        no warnings qw(uninitialized redefine);
        # insert JaBabz here
    }
    get '/' => &c{
        $c->reply->static("two\.html");
    };
    
    #c /digwaypoll/ notifier, see 281 Sevo
    my $poll = {tx=>[],ways=>{}};
    poll.wayt = {}; # pi/name -> pi-name
    poll.wayd = {}; # pi-name -> s&dige
    poll.doing = &o{
        return if $o && poll.one && $o ne poll.one;
        my @ways;
        each pi poll.ways {
            my $t = $p;
            $t = poll.wayt.>$p ||= do { $t =~ s/\W/-/sg; $t };
            my $digway = "wormhole/digway/$t";
            my $dig = readlink $digway;
            sayre "no $digway" if !$dig;
            next if !$dig;
            my $was = poll.wayd.>$t;
            next if $was && $dig eq $was;
            poll.wayd.>$t = $dig;
            $was = 'any';
            $was && push @ways,
                $p.'%dige:'.$dig
        }
        
        if (@ways) {
            # send many d=0 Lines as one message,
            # so receiver can react immediately
            my $s = join"",map{ $_ ."\n" }@ways;
            for my $tx (@{poll.tx}) {
                $tx->send($s);
            }
        }
        
        Mojo::IOLoop->timer(0.3,&{ poll.doing(poll.one = rand()) });
    };
    websocket '/digwaypoll' => &s{
        my $tx = $s->tx;
        poll.doing();
        1 && sayyl "Got digwaypolling";
        
        # complete picture (t/dige) at new listeners
        poll.wayd = {};
        push @{poll.tx}, $tx;
        
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        
        $s->on(message => &M,m{ #}
            die "Not wordy: $m" unless $m =~ /^([\w\-\/]+)(%\w+.*)?$/;
            tx.ways.>$1 ++ || poll.ways.>$1 ++
        });
        
        $s->on(finish => &M,code,reason{
            @{poll.tx} = grep { $_ ne $tx } @{poll.tx};
            each ti tx.ways {
                -- poll.ways.>$t && next;
                delete poll.ways.>$t;
                $t = delete poll.wayt.>$t;
                delete poll.wayd.>$t;
            }
            #1 && sayre "digwaypoll Gone: $addr $code $reason";
        });
    };
    
    #c /W/
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.Wache ||= {};
        
        # read t, write if s
        # all there
        $t = "W/$t";
        # char safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1 etc
        $t =~ s/\/(\d)$//;
        my $species = $1 || '1';
        my $f = "$t/$species";
        
        # returns json:
        my $re = {ok=>0};
        my $nos = 0;
        
        
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($pa && $pa ne $cache.>$f ) {
                re.er = 'not ffwd';
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # the .5 may be in the same request
                my $five = $c->param('fivestring');
                if ($five) {
                    my $ff = "$t/5";
                    write_file("$ff\.1",encode_utf8($five));
                    `mv $ff\.1 $ff`;
                }
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $nos = 1;
            }
        }
        else {
            if (-f $f) {
                $s = decode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            # it should have a dig
            my $dig = slm(12,
                $f =~ m{^W/spot/} ? dig($s)
                :
                dige($s)
            );
            $cache->{$f} = $dig;
            re.dige = $dig;
            re.s = $s;
            # if they know its hash, assume they don't need the string again
            if (my $ha = $c->param('have')) {
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            # or if it was a write
            delete re.s if $nos;
        }
        $c->render(text=>sjson($re));
    };
    
    #c /ghost/
    any '/ghost/*w' => &c{
        my $t = $c->param('w');
        # / in t not meaning directory
        (my $st = $t) =~ s/\W+/-/g;
        my $se = $c->param('se') || '*';
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.ghostache ||= {};
        my @opt = glob "G/$se/$st";
        die "multiple @opt" if @opt > 1;
        my $f = $opt[0] || '';
        my ($cat) = $f =~ /^G\/([^\/]+)\//;
        # < avoid some disking if $have
        my $wig = "wormhole/digway/$st";
        my $digway = readlink($wig);
        
        # returns json:
        my $re = {ok=>0};
        my $was_write = 0;
        
        # hasghost
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($se eq '*') {
                re.er = "!se param: writing G/\$se/\$t";
                $s = '';
            }
            elsif ($pa && $pa ne $cache.>$f ) {
                if (!$cache.>$f ) {
                    re.er = "lookup first";
                    # < or trust digway?
                }
                else {
                    re.er = 'not ffwd';
                }
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                -f $f && `rm $f`;
                re.ok = 'deleted';
            }
            else {
                # non-name is directory
                (my $dir = $f) =~ s/\/[^\/]+$//;
                -d $dir || `mkdir -p $dir`;
                my $new = !-f $f;
                #$s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $was_write = 1;
            }
        }
        else {
            if ($f && -f $f) {
                $s = decode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            my $dig = dige($s);
            $cache->{$f} = $dig;
            if ($dig ne $digway) {
                -l $wig && `unlink $wig`;
                `ln -s $dig $wig`;
            }
            re.dige = $dig;
            die "no cat: $f" if !$cat;
            re.se = $cat;# if $cat ne $se;
            re.s = $s;
            # they know string if:
            if (my $ha = $c->param('have')) {
                # they know its hash
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            if ($was_write) {
                # they just sent it
                delete re.s;
                # speed /digwaypol/
                poll.doing() if poll.ways && poll.ways.>$t;
            }
            
        }
        $c->render(text=>sjson($re));
    };
    
    #c /way/ 4s&waythe way
    # < Accept headers to get the various translations
    get '/way/*way' => &c{
        my $t = $c->param('way');
        $t =~ s/\W+/-/g;
        my $w;
        for ('G/*','wormhole/way') {
            my @opt = glob "$_/$t";
            my $f = shift @opt;
            next if !$f;
            $w = {t=>$t,y=>{}};
            wc&s = decode_utf8(read_file($f));
            ws&dige = slm(12, dig wc&s);
            ws&of = 'w';
            last
        }
        $w || return $c->reply->not_found;
        $c->res->headers->append(Dige => ws&dige);
        
        # < JaBabz is final
        my $babv = readlink("wormhole/digway/JaBabz");
        a&wayjs = {} if a&babv ne $babv;
        a&babv = $babv;
        
        my $have = $c->param('have');
        if ($have && a&wayjs.>w.t.>ws&dige &&
            $have eq ws&dige ) {
            return $c->render(text => '')
        }
        
        
        my $s = a&wayjs.>w.t.>ws&dige ||= do {
            my $C = $w;
            Rw JaBabz $C;
            wc&s
        };
        #$s =~ /^(.+?m\.replace(.+?))$/sgm && sayyl "Fuo:\n $1\n\n";
        $c->render(text => $s);
    };
    
    starts();

