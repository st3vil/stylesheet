Fividy: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    window.reverse = &s{ return s.slice().reverse() };

    # hash stash
    window.ah = &th{
        !isC(t) and throw "!C"
        $M = [... arguments].slice(2);
        $h = t.sc[h] ||= {};
        while (M.length) {
            $k = M.shift();
            M.length > 1 and h = h[k] ||= {}
            else {
                h[k] = M.shift()
            }
        }
    };

    # array match
    # if M, returns [not], puts M[matched]
    #  eg N = arou(N,'acty',actyN) separates actyN from N
    # else, returns [matched]
    window.arou = &NyM{
        $matched = M || [];
        if (isst(y)) {
            $k = y;
            y = &n{ return n.sc[k] };
            if (k[0] == '!') {
                $cb = y;
                k = k.substr(1);
                y = &s{ return !cb(s) }
            }
        }
        if (M && !isar(M)) {
            # for an Nx.$k=N tape splitter
            !k and throw "dunno Nx k",M
            matched = M[k] ||= []
        }
        $not = [];
        each in N {
            y(n) ? matched.push(n) : not.push(n)
        }
        return M ? not : matched
    };
    # match N into one of several groups
    window.aroh = &Nc{
        c ||= {};
        isst(c) and c = G&peel,c
        $h = {};
        each kn c {
            # matcher n is &s{} or a scgk
            n == '1' and n = k
            $M = [];
            N = arou(N,k,M);
            h[k] = M
        }
        h.N = N;
        return h
    }
    
    #c C-ish
    # < G&C, babz: = C yadda @3
    #   and to parse args for eg opeolo
    #   has a lot to do with:
    window.isnu = &s{ return typeof s == 'number' };
    window.isfu = &s{ return typeof s == 'function' };
    window.isst = &s{ return typeof s == 'string' };
    window.isar = &s{ return s && s.constructor == Array };
    window.isha = &s{ return s && typeof s == 'object' && !isC(s) };
    window.isob = &s{ return s && typeof s == 'object' };
    window.Cye = &s{
        s = G&Cye,s;
        s.y = {cv:s.y.cv};
        delete ss&z;
        return s
    };
    window.sca = &s{
        s *= 1;
        while (s >= 1) { s = s / 10 }
        return s;
    };

    # read spacey t, or insert C = y()
    window.fio = &qty{
        !isC(q) and throw "NotC"
        qs&z ||= [];
        qy&tw ||= {};
        typeof t == 'object' and y = t; t = null
        y == '9' and $deletes = 1; y = null
        $ar = y && y.constructor == Array;
        y && t == null and t = ar ? y [0] : y.t
        y != null && y == 0 and $readonly = 1
        
        $s = qy&tw[t];
        # allow removing from qs&z
        $si = s && qs&z.indexOf(s);
        si < 0 and s = null
        if (deletes) {
            si < 0 and return
            qs&z.splice(si,1);
            delete qy&tw[t];
            return
        }
        if (!s && !readonly) {
            s = y ? ar ? G&Cye,y : y : G&Cye,[t,1];
            qs&z.push(s);
            qy&tw[t] = s;
        }
        s and ss&z ||= [];
        return s
    };
    
    # C usu sort by cv,t
    window.tvsortz = &z{
        z.sort(&ab{
            return (ay&cv||0)*1-(by&cv||0)*1
                || ('' + a.t).localeCompare(b.t)
        });
        return z
    }
    
    
Twoism: | # js the way in
    # non-G&way way
    $way = &ty{
        $.ajax('way/'+t).done(&s{
            $f;
            eval(['f = function (ar) {',s,'}'].join("\n"));
            $re = f({});
            y and y(re);
        });
    };
    
    $ch = &s{
        $("<p>").appendTo(document.body).text(s);
    };
    # load $t.js to C with s&I
    $Cye = &v{
        return {t:v[0], y:{cv:v[1]||0.1}, c:v[2]||{}, sc:v[3]||{}};
    };
    $loadI = &t{
        $tocfunc = t+'_current';
        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
        $toc = window[tocfunc]();
        
        $W = Cye([t]);
        Ws&I = {};
        
        $D;
        each iv toc {
            $ind = v.shift();
            $C = Cye(v);
            if (ind == '') {
                D = Ws&I[C.t] = C;
                D.y.tw = {};
                D.y.tv = {};
                Ds&z ||= [];
            }
            else if (ind == '  ') {
                D.t != s&js and throw "Csjs not last D", C, D;
                c&code = window[s&name];
                typeof c&code != 'function' and throw "Cccode not function", C, D;
                # grow I
                D.y.tv[C.t] ||= {};
                D.y.tv[C.t][C.y.cv] = C;
                D.y.tw[C.t] = C;
                $l = Ds&z.slice(-1);
                l[0] and l[0].y.next = C;
                Ds&z.push(C);
                D.y.in ||= C;
                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                    G[C.t] = c&code;
                }
            }
            else {
                throw "deep C: "+t, v
            }
        }
        return W
    };
    ch("Correct");
    
    # Automation
    A = window.A = Cye(['top']);
    A.y = A;
    A.1 = A.2 = A.3 = A.4 = A.5 = A;
    1s&N = [];
    # GOING - gev insists on A.4.up while finding path in
    $Y = A.up = Cye(['outside']);
    Y.y = Y;
    Y.2 = A;
    
    # Culture
    $C = Cye(['Top']);
    # Grind
    window.G = Cye(['Gee']);
    G.y = G;
    # Telomena
    $T = {};
    
    # mind as I
    $M = 'Hunt'.split(' ').map(t => loadI(t));
    $W = M[0];
    A.I = Ws&I;
    4c&ttl = 3600;
    
    # mind as me
    $me = window.me = {};
    me.Ja = {}; # pins
    me.timestamp = &{ return(new Date).toISOString() };
    A&me = me;
    # from all these epochs of development
    $list = ('NutGravy iooia '+
        'Soogle Coffle Packle Foogla Fividy Fourism')
        .split(' ');
    $however = 1;
    $someend = &{
        however--
        however == 0 and way('Threeism')
    };
    $morelist = &i{
        $t = list[i];
        !t and return someend();
        way(t,&r{
            t == 'iooia' and me.io = r
            morelist(i+1);
        });
    };
    morelist(0);
    
    # also since they are not G&way:
    # A5Iw shall know these, ghost updates begin
    'Soogle Packle Coffle Foogla EleMento EleVisAn Fourism'.split(' ').map(&t{
        however++; G&way,t,{},someend
    });
    
Threeism: |
    # lots from somewheres...
    $C = G&Cye,['Elevat',2];
    
    # the right side
    $('body div.v8').remove();
    $el = $('<div class="v8" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:55%;height:20%;width:43%">')
    .appendTo('body')[0];
    
    
    # to named A.4
        # GOING:
        el.A = A;
    $dns = G.DNS = G.DNS || {};
    $old = dns[A.4.t];
    dns[A.4.t] = A.4;
    
    # drive units
    G.clon = &{ $(window).on("click", &ev,{ G&gev,ev }) };
    G.keon = &{ $(window).on("keydown", &ev,{ G&gev,ev }) };
    G.clof = &{ $(window).off("click") };
    G.keof = &{ $(window).off("keydown") };
    G.togwid = &m,fr,to{
        if ($(m).attr('togwid') == to)
            to = fr
        $(m).attr('togwid', to)
        $(m).css('width', to);
    };
    
    # says
    $msgs = $(A.on).find('> #msgs')[0];
    msgs ||= $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
    4s&msgs = msgs;
    
    # error handling
    window.BamonG = &{
        $A = Gc&B.sc.A;
        return A.4
    };
    window.onerror = &msg,url,lineNo,colNo,error{
        A = BamonG();
        A&ev and A&ev.preventDefault();
        A&bang and return
        A&bang = 1;
        G&Ban,error,msg,url,lineNo,colNo,error;
        delete A&bang;
        return
    };
    
    # NutEl
    A.I.i.y.tw.gev.c.code = &acgt,ev,J{
        ev ||= event;
        ev.target.tagName == 'H2' and return
        # locate A:top of A:4
        #debugger;
        if (!ev.target) {
            A&event_A and A = A&event_A;
        }
        elsif (ev.target == document.body) {
        
        }
        else {
            $S = ev.target;
            while (S && !(S.A && S.A.4)) {
                S = S.parentNode;
            }
            # must be clicking <body>, <html>
            #   or something above .A element space
            !S and return
            A = S.A.4;
            !A and throw "out of cone";
            A&event_A = A;
        }
        if (A&event_A) {
            A&event_A != A and ~innerA: A.4.t
            A = A&event_A;
        }
        G&Aye,'ev',9,{ev:ev}
    };
    
    me.start = &{
        4s&NormalI = A.I;
        # in favour of dispatch table towards 4:
        # inits and continues methods on me
        # unco:
        4s&N = [];
        
        document.title = 'hoot';
    
        A.4.on = el;
        el.A = A;
        #C = A&s = {t:me.timestamp(),y:{},c:{},sc:{}};
        #$G = {y:{},c:{},sc:{}};
        T = {y:{},c:{},sc:{}};
        
        me.star(A,C,G,T);
    };
    
    G.clon(); G.keon();

    me.start();
    
    
    ch("Correcto");
    
    
Fourism: |
    # new road to R without J
    #  from me.starc instead of wobulus?
    # breaks too much just now: Teing, A.n
    #  when 1s&ein has sockets that R-times peel off
    me.Fourismo = &acgt{
        # knowing
        $El = 1s&elvisory ||= Cye(['El']);
        # GOING need for J having it
        1s&Te = El;
        # GOING need to na&Teelone, El%ball
        A.n = A;
        # being that top level (not A.1.t)
        # < here only
        s&Te = El;
        
        s&mune = 1;
        
        $I = me&Resurrect,'I',1s&s;
        Iy&J = A.4;
        #        debugger;
        me&J,'Fourier','W';
        
        $D = me&ballRom,I,C;
        
        1s&s = I;
        return;
        $on = D.y.Display.sc.on;
        if (!4s&on.contains(on)) {
            ~>5 On: C.t
            on.A ||= A;
            4s&on.appendChild(on)
        }
        1s&s = I;
    };
    
    me.Fourismness = &acgt{ return [
        ['mune','29',&acgtRs{
            me&walla,'hu:7';
            
            me&tsc,"Bal";
            me&rollbs,R,'Dosh',5;
            $d = Rs&Dosh++;
            me&tsc,"Bal","$"+d,'B';
            #$('body > div').empty();
            
            me&introqua,[R,'A'],{boost:1}
            me&zu,"R",R;
            
            Rs&Utilis = 1;
            
        },'ift,D'],
        
        ['Utilis','291',&acgtRs{
            # going to sleep
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });
            
            # having an other
            n Elvito  R %Tool
            
            # remotes
            # news from the old editor
            me&Rom,R,'GhodigWap';
            # newsroom behind the %ting
            Rs&Inn = me&Rom,R,'Search';
        },'ift,D'],
    ] };
    
    =pod Fiveplan #c
    needs:
      editor
        make way into /G/$cat/$way
        organised by /W/$cat of $way+
      new server
        /way/
          mostly sees /G/$cat/$way
            also wormhole/way/$way
          have a write mode, like /W/
            dig to wormhole/digway/$way
          needs: JaBabz
        /W/
          should work?
          needs: othlia/G.pm
        /digwaypoll/
          watching wormhole/digway/$way
          
        /js/ GONE temporarily?
          needs Beach, etc.
          just host /js/Hunt.js
          comes back when $W has .js file?
      
      old server:
        do eval from the client, to:
        compile serve.pl, from Wud and etc:
          see j/32 Jigdoer
          get JaBabz in pure perl
            it has a Rw JaBabz for <<"" to avoid
            in Wud /way/:
                Rw JaBabz $C:w;
                wc&s
    =cut
    
    # etc
    
Wud: | # restacked Wed server
    #!/usr/bin/perl
    use strict;
    use warnings;
    no warnings qw(uninitialized redefine);
    use FindBin qw($Bin);
    use lib "$Bin/othlia";
    use lib "$Bin/slib";
    use G;
    my ($A,$C,$G,$T);

    saygr "Being Wud in ".(Gc&ipd || Gc&dir);
    
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    # divert mojo log statements from our err channel
    app->log->path((Gc&ipd || Gc&dir)."/mojo\.log")
        if Gc&dir || Gc&ipd;
    
    my $listen = "http://localhost:10222"
    
    # 4s&waythe way
    # < Accept headers to get the various translations
    get '/way/*way' => &c{
        my $t = $c->param('way');
        $t =~ s/\W+/-/g;
        my $w = G&t,w=>$t;
        if (!$w) {
            my @opt = glob "G/*/$t";
            my $f = shift @opt;
            if ($f) {
                $w = {t=>$t,y=>{}};
                wc&s = read_file($f);
                ws&dige = slm(12, dig wc&s);
                ws&of = 'w';
            }
        }
        $w || return $c->reply->not_found;
        $c->res->headers->append(Dige => ws&dige);
        
        my $babv = readlink("wormhole/digway/JaBabz");
        a&wayjs = {} if a&babv ne $babv;
        a&babv = $babv;
        
        if ( a&wayjs.>w.t.>ws&dige &&
            $c->param('have') eq ws&dige ) {
            return $c->render(text => '')
        }
        
        
        my $s = a&wayjs.>w.t.>ws&dige ||= do {
            Rw JaBabz $C:w;
            wc&s
        };
        #$s =~ /^(.+?m\.replace(.+?))$/sgm && sayyl "Fuo:\n $1\n\n";
        $c->render(text => decode_utf8($s));
    };
    #c /digwaypoll/ notifier, see 281 Sevo
    my $poll = {tx=>[],ways=>{}};
    poll.wayt = {}; # pi/name -> pi-name
    poll.wayd = {}; # pi-name -> s&dige
    poll.doing = &o{
        return if $o && poll.one && $o ne poll.one;
        my @ways;
        each pi poll.ways {
            my $t = $p;
            $t = poll.wayt.>$p ||= do { $t =~ s/\W/-/sg; $t };
            my $dig = readlink "wormhole/digway/$t";
            my $was = poll.wayd.>$t;
            next if $dig eq $was;
            poll.wayd.>$t = $dig;
            $was = 'any';
            $was && push @ways,
                $p.'%dige:'.$dig
        }
        
        if (@ways) {
            # send many d=0 Lines as one message,
            # so receiver can react immediately
            my $s = join"",map{ $_ ."\n" }@ways;
            for my $tx (@{poll.tx}) {
                $tx->send($s);
            }
        }
        
        G&timer:0.3,&{ poll.doing(poll.one = rand()) };
    };
    websocket '/digwaypoll' => &s{
        my $tx = $s->tx;
        poll.doing();
        1 && sayyl "Got digwaypolling";
        
        # complete picture (t/dige) at new listeners
        poll.wayd = {};
        push @{poll.tx}, $tx;
        
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        
        $s->on(message => &M,m{ #}
            die "Not wordy: $m" unless $m =~ /^([\w\-\/]+)(%\w+.*)?$/;
            tx.ways.>$1 ++ || poll.ways.>$1 ++
        });
        
        $s->on(finish => &M,code,reason{
            @{poll.tx} = grep { $_ ne $tx } @{poll.tx};
            each ti tx.ways {
                -- poll.ways.>$t && next;
                delete poll.ways.>$t;
                $t = delete poll.wayt.>$t;
                delete poll.wayd.>$t;
            }
            #1 && sayre "digwaypoll Gone: $addr $code $reason";
        });
    };
    
    #c /W/
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.Wache ||= {};
        
        # read t, write if s
        # all there
        $t = "W/$t";
        # char safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1 etc
        $t =~ s/\/(\d)$//;
        my $species = $1 || '1';
        my $f = "$t/$species";
        
        # returns json:
        my $re = {ok=>0};
        my $nos = 0;
        
        
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($pa && $pa ne $cache.>$f ) {
                re.er = 'not ffwd';
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # the .5 may be in the same request
                my $five = $c->param('fivestring');
                if ($five) {
                    my $ff = "$t/5";
                    write_file("$ff\.1",encode_utf8($five));
                    `mv $ff\.1 $ff`;
                }
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $nos = 1;
            }
        }
        else {
            if (-f $f) {
                $s = encode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            # it should have a dig
            my $dig = slm(12,
                $f =~ m{^W/spot/} ? dig($s)
                :
                Digest::SHA::sha256_hex($s)
            );
            $cache->{$f} = $dig;
            re.dige = $dig;
            re.s = $s;
            # if they know its hash, assume they don't need the string again
            if (my $ha = $c->param('have')) {
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            # or if it was a write
            delete re.s if $nos;
        }
        $c->render(text=>sjson($re));
    };
    
    starts();

