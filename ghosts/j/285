Fividy: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    window.reverse = &s{ return s.slice().reverse() };

    # hash stash
    window.ah = &th{
        !isC(t) and throw "!C"
        $M = [... arguments].slice(2);
        $h = t.sc[h] ||= {};
        while (M.length) {
            $k = M.shift();
            M.length > 1 and h = h[k] ||= {}
            else {
                h[k] = M.shift()
            }
        }
    };

    # array match
    # if M, returns [not], puts M[matched]
    #  eg N = arou(N,'acty',actyN) separates actyN from N
    # else, returns [matched]
    window.arou = &NyM{
        $matched = M || [];
        if (isst(y)) {
            $k = y;
            y = &n{ return n.sc[k] };
            if (k[0] == '!') {
                $cb = y;
                k = k.substr(1);
                y = &s{ return !cb(s) }
            }
        }
        if (M && !isar(M)) {
            # for an Nx.$k=N tape splitter
            !k and throw "dunno Nx k",M
            matched = M[k] ||= []
        }
        $not = [];
        each in N {
            y(n) ? matched.push(n) : not.push(n)
        }
        return M ? not : matched
    };
    # match N into one of several groups
    window.aroh = &Nc{
        c ||= {};
        isst(c) and c = G&peel,c
        $h = {};
        each kn c {
            # matcher n is &s{} or a scgk
            n == '1' and n = k
            $M = [];
            N = arou(N,k,M);
            h[k] = M
        }
        h.N = N;
        return h
    }
    
    #c C-ish
    # < G&C, babz: = C yadda @3
    #   and to parse args for eg opeolo
    #   has a lot to do with:
    window.isnu = &s{ return typeof s == 'number' };
    window.isfu = &s{ return typeof s == 'function' };
    window.isst = &s{ return typeof s == 'string' };
    window.isar = &s{ return s && s.constructor == Array };
    window.isha = &s{ return s && typeof s == 'object' && !isC(s) };
    window.isob = &s{ return s && typeof s == 'object' };
    window.isR = &s{ return isC(s) && sy&R == s };
    window.Cye = &s{
        s = G&Cye,s;
        s.y = {cv:s.y.cv};
        delete ss&z;
        return s
    };
    # make fraction of 1
    window.sca = &s{
        s *= 1;
        while (s >= 1) { s = s / 10 }
        return s;
    };
    # ac() also replacing nc&b with n
    #  as Cupon %down=[], recycled selves
    window.bac = &Rkr{
        $N = R.sc[k] ||= [];
        $b = rc&b;
        if (b) {
            $bi = N.indexOf(b);
            bi >= 0 and return N[bi] = r
        }
        $ni = N.indexOf(b);
        ni >= 0 and return N[ni] = r
        N.push(r)
    };

    # read spacey t, or insert C = y()
    window.fio = &qty{
        !isC(q) and throw "NotC"
        qs&z ||= [];
        qy&tw ||= {};
        typeof t == 'object' and y = t; t = null
        y == '9' and $deletes = 1; y = null
        $ar = y && y.constructor == Array;
        y && t == null and t = ar ? y [0] : y.t
        y != null && y == 0 and $readonly = 1
        
        $s = qy&tw[t];
        # allow removing from qs&z
        $si = s && qs&z.indexOf(s);
        si < 0 and s = null
        if (deletes) {
            si < 0 and return
            qs&z.splice(si,1);
            delete qy&tw[t];
            return
        }
        if (!s && !readonly) {
            s = y ? ar ? G&Cye,y : y : G&Cye,[t,1];
            qs&z.push(s);
            qy&tw[t] = s;
        }
        s and ss&z ||= [];
        return s
    };
    
    # C usu sort by cv,t
    window.tvsortz = &z{
        z.sort(&ab{
            return (ay&cv||0)*1-(by&cv||0)*1
                || ('' + a.t).localeCompare(b.t)
        });
        return z
    }
    
    
Twoism: | # js the way in, fetching into an eval
    # non-G&way way: fetch into an eval 
    $way = &ty{
        $.ajax('way/'+t).done(&s{
            $f;
            eval(['f = function (ar) {',s,'}'].join("\n"));
            $re = f({});
            y and y(re);
        });
    };
    
    $ch = &s{
        $("<p>").appendTo(document.body).text(s);
    };
    # load $t.js to C with s&I
    window.Cyeblong = &v{
        return {t:v[0], y:{cv:v[1]||0.1}, c:v[2]||{}, sc:v[3]||{}};
    };
    $loadI = &t{
        $tocfunc = t+'_current';
        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
        $toc = window[tocfunc]();
        
        $W = Cyeblong([t]);
        Ws&I = {};
        
        $D;
        each iv toc {
            $ind = v.shift();
            $C = Cyeblong(v);
            if (ind == '') {
                D = Ws&I[C.t] = C;
                D.y.tw = {};
                D.y.tv = {};
                Ds&z ||= [];
            }
            else if (ind == '  ') {
                D.t != s&js and throw "Csjs not last D", C, D;
                c&code = window[s&name];
                typeof c&code != 'function' and throw "Cccode not function", C, D;
                # grow I
                D.y.tv[C.t] ||= {};
                D.y.tv[C.t][C.y.cv] = C;
                D.y.tw[C.t] = C;
                $l = Ds&z.slice(-1);
                l[0] and l[0].y.next = C;
                Ds&z.push(C);
                D.y.in ||= C;
                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                    G[C.t] = c&code;
                }
            }
            else {
                throw "deep C: "+t, v
            }
        }
        return W
    };
    
    # Automation
    A = window.A = Cyeblong(['top']);
    A.y = A;
    A.1 = A.2 = A.3 = A.4 = A.5 = A;
    1s&N = [];
    # GOING - gev insists on A.4.up while finding path in
    $Y = A.up = Cyeblong(['outside']);
    Y.y = Y;
    Y.2 = A;
    
    # Culture
    $C = Cyeblong(['Top']);
    # Grind
    window.G = Cyeblong(['Gee']);
    G.y = G;
    # Telomena
    $T = {};
    
    # mind as I
    $M = 'Hunt'.split(' ').map(t => loadI(t));
    $W = M[0];
    A.I = Ws&I;
    4c&ttl = 3600;
    
    # mind as me
    $me = 4c&me = window.me = {};
    me.Ja = {}; # pins
    me.timestamp = &{ return(new Date).toISOString() };
    A&me = me;
    # from all these epochs of development
    $list = ('NutGravy iooia '+
        'Soogle Coffle Packle Foogla Fividy Fourism')
        .split(' ');
    $however = 1;
    $someend = &{
        however--
        however == 0 and way('Threeism')
    };
    $morelist = &i{
        $t = list[i];
        !t and return someend();
        way(t,&r{
            t == 'iooia' and me.io = r
            morelist(i+1);
        });
    };
    morelist(0);
    
    # also since they are not G&way:
    # A5Iw shall know these, ghost updates begin
    'Soogle Packle Coffle Foogla EleMento EleVisAn Fourism'.split(' ').map(&t{
        however++; G&way,t,{},someend
    });
    
Threeism: |
    # lots from somewheres...
    $C = G&Cye,['Elevat',2];
    
    # the right side
    $('body div.v8').remove();
    A.on = $('body')[0];
    $el = 4s&starlane = $('<div class="v8" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:55%;height:20%;width:43%">')
    .appendTo('body')[0];
    # the left
    4s&planelane = $('<div class="v9" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:0%;width:43%">')
    .appendTo('body')[0];
    
    
    # to named A.4
        # GOING:
        el.A = A;
    $dns = G.DNS = G.DNS || {};
    $old = dns[A.4.t];
    dns[A.4.t] = A.4;
    
    # drive units
    G.clon = &{ $(window).on("click", &ev,{ G&gev,ev }) };
    G.keon = &{ $(window).on("keydown", &ev,{ G&gev,ev }) };
    G.clof = &{ $(window).off("click") };
    G.keof = &{ $(window).off("keydown") };
    G.togwid = &m,fr,to{
        if ($(m).attr('togwid') == to)
            to = fr
        $(m).attr('togwid', to)
        $(m).css('width', to);
    };
    
    # says
    $msgs = $(A.on).find('> #msgs')[0];
    msgs ||= $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
    4s&msgs = msgs;
    
    $originA = A.4;
    # error handling
    #  get A as it was last G&h
    window.BamonG = &{ 
        $B = Gc&B;
        return B && Bs&A || BoriginA
    };
    window.onerror = &msg,url,lineNo,colNo,error{
        $A = BamonG();
        A&ev and A&ev.preventDefault();
        A&bang and return
        A&bang = 1;
        G&Ban,error,msg,url,lineNo,colNo,error;
        delete A&bang;
        return
    };
    
    
    me.start = &{
        4s&NormalI = A.I;
        # in favour of dispatch table towards 4:
        # inits and continues methods on me
        # unco:
        4s&N = [];
        document.title = 'hoot';
        A.on = el;
        A.on.A = A;
        T = {y:{},c:{},sc:{}};
        #me.star(A,C,G,T);
        me.plane(A,C,G,T);
    };
    
    G.clon(); G.keon();

    me.start();
    
    
Fourism: |
    # new road to R without J!
    #  from me.planet instead of wobulus?
    # breaks too much just now: Teing, A.n
    #  when 1s&ein has sockets that R-times peel off
    me.Fourismo = &acgt{
        # knowing
        $El = 1s&elvisory ||= Cyeblong(['El']);
        # GOING need for J having it
        1s&Te = El;
        # GOING need to na&Teelone, El%ball
        A.n = A;
        # being that top level (not A.1.t)
        # < here only
        s&Te = El;
        
        s&mune = 1;
        
        $I = me&Resurrect,'I',1s&s;
        Iy&J = A.4;
        me&J,'Fourier','W';
        
        $D = me&ballRom,I,C;
        
        1s&s = I;
        return;
        $on = D.y.Display.sc.on;
        if (!4s&on.contains(on)) {
            ~>5 On: C.t
            on.A ||= A;
            4s&on.appendChild(on)
        }
        1s&s = I;
    };
    
    # NutEl
    A.I.i.y.tw.gev.c.code = &acgt,ev,J{
        ev ||= event;
        ev.target.tagName == 'H2' and return
        # locate A:top of A:4
        #debugger;
        if (!ev.target) {
            A&event_A and A = A&event_A;
        }
        elsif (ev.target == document.body) {
        
        }
        else {
            $S = ev.target;
            while (S && !(S.A && S.A.4)) {
                S = S.parentNode;
            }
            # must be clicking <body>, <html>
            #   or something above .A element space
            !S and return
            A = S.A.4;
            !A and throw "out of cone";
            A&event_A = A;
        }
        if (A&event_A) {
            A&event_A != A and ~innerA: A.4.t
            A = A&event_A;
        }
        G&Aye,'ev',9,{ev:ev}
    };
    
    #c ambient synapse
    4c&framerate = 0.3;
    # when without G&h
    window.Gtime = &d{ return G&time,d };
    
    # loop comebacks between attentions
    $lastwas = 0;
    me.plane = &acgts{
        #A.on = 4s&planelane;
        A != window.A and throw "How there A"
        !A.on.ownerDocument.contains(A.on) and return ch("unplugged");
        $me = A&me;
        $starts = G&time;
        lastwas and 4s&nonms = G&time,lastwas;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&framerate;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000
        
        # < route G&gev to me.plane sometimes?
        #   they are different A.4s really
        #   and 4c&callback
        4c&callback ||= &s{ me.plane(Y,C,G,T,s) };
        $sing = 4c&callback.singly = {};
        G&yl:frames,&{ sing == 4c&callback.singly && 4c&callback() };
        
        try { me&planet,s }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }
        
        $ends = G&time,starts;
        4s&ms = ends;
        lastwas = G&time;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    # cast gazet
    # this is a bag of marbles, they are free and together
    me.planet = &acgts{
        4s&paused and return
        $A = G&Aye,'planet';
        $B = Gc&B;
        B and 'collect?'
        B = Gc&B = G&Cye,[A.t,''];
        Bs&A = A;
        Bs&z = [];
        $g = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        !me.inita.ed and me&inita
        
        # 1/10th attend
        A&sip.slice(-1)[0] == 0 and me&otherandcontinue
        
        4s&Jays = 0;
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        #me&J,'Fourier','W'; !
        4s&Fourieronlynow and delete 4s&Fourieronlynow; throw "async Fourier only"
        s and gc&e = s
        me&J,['Planet','W',{el:el},{timing:0}]
        # < me.do_main does any $el/*%J
    };
    me.Ja.Planet = &acgts{
        me&Gomp;
        s&timing = 1;
        #debugger;
        n Har   %rovo:Domebegin
        #s&ab = 1;
        #s&wi = '44%';
    };
    #c Fourismness
    me.Fourismness = &acgt{ return [
        ... me&Zavingness ,
        ['Domebegin','278',&acgtRs{
            $C = G&Cye,['Vubd',1,{},{mune:1}];
            $D = me&ballRom,R,C;
        },'ift,D'],
        
        ['mune','278',&acgtRs{
            me&walla,'hu:7';
            Rs&Utilis = 1;
            # we may have a request
            # from 4c&callback(e) 
            $g = A.up.ground;
            $e = gc&e;
            !e and return
            $emsg =
            ~>8 e: '>3:IS','>7:pathin'
            # ec&wake may be alone, or come from:
            if ((e.t.includes('click')||1) && ec&slope) {
                $sl = ec&slope.slice().reverse();
                each in sl {
                    # ns&medo is handled without 4c&callback
                    $m = ns&med;
                    !m and continue;
                    # not in C or A
                    $D = C;
                    $C = e;
                    $s = ec&s;
                    me&$m,s;
                    C = D;
                    T.ok = 1;
                    break
                }
                !T.ok and emsg.set('IS','NODICE')
                else {
                    delete T.ok;
                    emsg.set('IS','ok')
                    T.wake and ec&wake = T.wake
                }
            }
            if (ec&wake) {
                # pointer
                $r = ec&wake;
                $JR = me.cbu(r,'JRom');
                $l = me.cby(r);
                # concentrate
                JR.t != 'Elfor' and return emsg.set('pathin','<>')
                # R(c&b)+ - historical R they pointed to
                es&tunnelin = l;
                # Rc&b - last R to happen
                es&tunnel = l = l.map(n => me&yfuture,n );
                # this R
                $li = l.indexOf(R);
                li < 0 and throw "noRfut",R,e,l
                l[li] = Rc&b;
                # %tunneling builds tunnel_now
                ac(e,'tunnel',Rc&b,'now',R);
                
                l = l.slice(li);
                emsg.set('pathin',l.map(n=>n.t).join('/'));
                
                # don't happen
                Rs&sleeping = 1;
                # keep non-happening A.3 history
                me&recycleRbitXz,R;
                Rs&icate = &{
                    # make something to happen
                    $c = ex({},JRs&JRom);
                    c.tunneling = e;
                    #~>3 Domewake: ki(e,4.22)
                    $n = me&Rom,R,c;
                    4s&pathin = {path:[...l],n};
                };
            }
        },'ift,D'],
        # let sleeping+Utilis @28
        ['sleeping+mune+icate','3',&acgtRs{
            Rs&icate();
            # merges the branch, keeps them to Rc&b
            me&applyRbitX,R;
        },'ift,D'],
        
        ['tunneling','22',&acgtRs{
            $e = Rs&tunneling;
            $l = es&tunnel;
            $li = l.indexOf(Rc&b);
            li < 0 and throw 'nobtunnel',R,e,l
            ac(e,'tunnel',Rc&b,'now',R);
            # decide to sleep or wake,
            #  generate children for more tunneling
            
        },'ift,D,sleeping'],
        
        ['mune','3',&acgtRs{
            # Codon/experiment
            me&Rom,R,'Elfor';
            # wash
            me&Rom,R,'Evelse';
        },'ift,D'],
        
        # %Evelse, nto
        ['Evelse','291',&acgtRs{
            me&introqua,[R,'A'],{boost:1}
            me&zu,"4s&pathin",4s&pathin;
            
            me&zu,"A",A.4;
            #n Elviso  $s:4s&elvisory %R:ball
        },'ift,D'],
        
        #c unihab
        ['sleeping+Utilis','28',&acgtRs{
            if (!me&ollbs,R,'Inn' ) {
                # wake up (after error?)
                delete Rs&icate;
                delete Rs&sleeping;
                return
            }
            me&rollbs,R,'Inn,Incremento';
        },'ift,D'],
        ['Utilis','291',&acgtRs{
            # window/A.4 goes to sleep
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });
            
            # this toplevel-ish R may take ages
            Rs&timetopause = 3418;
            
            # spending time in/out of the callback
            $g = me&opeolo,'plane';
            $ti = gy&can('n','time');
            me&mtsc,ti,'timein',4s&ms,'6' .sc.fs = 12;
            me&mtsc,ti,'timeof','/','g'
            me&mtsc,ti,'timeout',4s&nonms,'6'
            
            # %ball transfigurations (move,copy,etc)
            n Elvito  R %Tool
            # %ball activations (just %R -> JRom)
            Rs&playsheet = {
                ball: &acgtR{
                    me&Bear,R,Rc&s,'play'
                },
                fix: &acgtR{  },
            };
            
            # remotes
            # news from the editor
            me&Rom,R,'GhodigWap';
            # newsroom behind all %tings
            Rs&Inn = me&Rom,R,'Search';
            
            # one variety of walking around names
            #  climbing X, < other structures
            #  invent linguistic surface bubbler
            me.upsit = &acgtRt{
                $z = me.cby(R).reverse();
                each in z {
                    $X = nc&X;
                    $oX = X && X.x && X.x[t];
                    oX && oX.z and return oX.z[0]
                }
            };
            me&rollbs,R,'Incremento';
            Rs&Incremento = (Rs&Incremento||0)+1;
            if (Rs&Incremento == 2) {
                ['GhodigWap','Search'].map(&t{
                    $r = me&upsit,R,t;
                    r && me&introqua,r,'boost:-1';
                })
            }
            # another thing-ink dripper:
            #        $he = Rc&N[0];
            #        $i = hes&inti = (hes&inti||0)+1;
            #        me&tsc,'%Zave',i+'th','y';
            #        i == 2 and debugger
            # the first few %settings are usually important:
            #    me&tsc,'%Zave',haks(R.sc).slice(0,10).join(','),'y';
            
        },'ift,D'],
        
        #c %Codon
        # < leading the way
        ['Elfor','291',&acgtRs{
            # write code
            #n Flar  R %Codon,ting:W,Gens,tingspot
            # lingo patch panel
            #n ForThe  R %ting:W,Gens,tingspot
            # test sleep
            n Sleigh  R %Slei,ting:W,Gens,tingspot
        },'ift,D'],
        
        # cloud of %Codon and related types inheriting
        ['Codon','291',&acgtRs{
            # inherity settings + %Codon ness
            $p = Ry&up;
            Rs&fix && ps&Code && ps&ball and Rs&Cofix = 1
            !(Rs&ball || Rs&Gens) and delete Rs&Codon; return
            ac(R,'inheritsc','Codon');
            
            Rs&Gens and Rs&Gedo = 1
            !Rs&ball and return
            
            # < creates an inside
            $c = me&tsc,'%Codon','C','B';
            cs&medo = 'fliv';
            
            # diverge into types
            if (ss&R == 'Codo') {
                # an out%ball sprouts JRom:Codo
                # implied by %R=Codo
                # < feed openness
                me&tsc,'%Codo','bout','6'
                ss&Doming = 3;
                ss&Codon = 1;
                Rs&compLines = &D{
                    delete Ds&Doming; 
                    delete Ds&Codon;
                };
                me&Bear,R,s,'play';
            }
            else {
                $p = me.cbu(R,&r{ return rs&Codo && rs&ball });
                # above %Codo
                !p and me&tsc,'%Codo','bove','6'
                # all %Codo/**%Codon !%Codo are %Code
                else
                p != R and Rs&Code = 1
                else {
                    me&tsc,'%Codo','odo..','6'
                }
            }
            
            # auto %play any %R=Codo|Code
            #  similar to $t%W=nott, nott being a pin to decode it through
            #   future is decoding W with other W
            # be an out%ball and in%ball for either
            
            #n Flar  R %Codon,ting:W,Gens,tingspot
            #n ForThe  R %ting:W,Gens,tingspot
            
        },'ift,D'],
        
        ['Codo','2901',&acgtRs{
            #$c = me&tsc,'%Codon','Codo','g';
            # %Codon not inherited through %JRom
            Rs&Codon = 1;
            # becomes inside
            Rs&ball and return Rs&Codin = 1
            
            if (Rs&Gens) {
                # pass %Codo to child of %Gens, then any %ball
                ac(R,'inheritsc','Codo');
            }
            else {
                delete Rs&Codon
            }
        },'ift,D'],
        
        # Codo outside
        ['Gens+Codon','293',&acgtRs{
            $c = me&tsc,'%Codon','Gedo','g';
            Rs&Zaving = "mem,W";
            delete Rs&ting;
            # < %Here's %Lines to /mem/, /W/
        },'ift,D'],
        
        # Codo inside
        ['ball+Codin','296',&acgtRs{
            $c = me&tsc,'%Codon','Codin','g';
            me&walla,'hu:17';
            !me.cbu(Ry&up,'Codin') &&
                me&walla,'wi:1.3';
            s&bgh = '111';
            
            $ag = me&tsc,'add-ghost','';
            ags&hs = "378";
            agc&s = '';
            ags&e = 1;
            me&Tie,R,'sayeth',1;
            $say = Rs&sayeth;
            say and me&input,R,say .sc.initCode = 1;

            # < feed openness
            #Rs&beopen ||= 1;
        },'ift,D'],
        
        # fixturism
        ['ball+Code','293',&acgtRs{
            $c = me&tsc,'%Codon','Code','g';
            4s&thecode = R;
            Rs&Zaving = "tmp,ghost";
            Rs&compLines = &D{
                # < %size of it, texture, headings
                # < %ghost=dig(%string)
                delete Ds&string
            };
            Rs&initCode and ss&string = "# "
        },'ift,D'],
        
        ['fix+Cofix','296',&acgtRs{
            $c = me&tsc,'%Codon','Cofix','g';
            # < feed openness
            Rs&beopen ||= 1;
        },'ift,D'],
        
        #c Slei
        # sleeping is possible
        #  Slei shows it
        # the R%sleeping keeps modulat
        #  is its b the next time,
        #    must roll everything it wants to keep
        #     < specify non-history-creating mode
        #   the R%sleeping/** don't happen,
        #    but if they do, Display them
        
        # also 
        #  Citop's %elvisrefresh allows entry from nowhere
        #    as it knows its own input (argc to %Reis)
        #   by me&Reis,Ry&up
        # < show how X is when not recycled,
        #    unrecycled, errored, etc
        # < %directDisplay should force Cupon same %on
        #    when there isn't a 
        # < %Zavmo for X
        
        # mostly
        #  elvis() talks to JRom of A.4
        #  to find some strategy for sneaking in
        #   past R%sleeping to the wakers
        #   re-argumenting it re strategy,
        #    in artificial generation
        #     so it gets to eg sleeping+ball @28
        #    such that it might work
        #     < could Ring-wait the outsiders until
        #       inners are certain they don't need
        #       their surroundings after doing stuff
        ['Slei','278',&acgtRs{
            !(Rs&ball || Rs&Gens) and delete Rs&Slei; return
            ac(R,'inheritsc','Slei');
            Rs&Gens and return
            $p = Ry&up;
            Rc&timelab ||= R;
            R.t == 'Sleigh' and Rs&Flaring = 1
            ps&Flaring and Rs&Timeding = 1
            ps&Timeding and Rs&Timedin = 1
        },'ift,D'],
        
        # above everything, scan scenario
        ['Flaring','89',&acgtRs{
            # to get R%sleeping to hit eg ball+sleeping
            ah(R,'reawakens','Slei',{
                rollbsc:'ball,Flaring,Slei,Timeding,Timedin',
            });
            
            $Sl = me&ioty,R,'Timeding' [0];
            me&nu,"Sl",Sl;
            each ir Sls&z {
                i = i+' '+(Rc&N.indexOf(r)>=0 ? "wake" : "s");
                me&tsc,i,i+":"+r.t .sc.dis = 1;
            }
        },'ift,D'],
        
        # the sleeper
        ['Timeding','2781',&acgtRs{
            $c = me&rollcounty,R,'lupe';
            $rfromN = &r{
                $i = Rc&N.indexOf(r);
                i < 0 and return
                Rc&N.splice(i,1);
                each in rs&z {
                    rfromN(n)
                }
            };

            me&tsc,'%Codon','flar:'+cs&count,'g';
            Rs&countis = cs&count;
            me&rollbs,R,'incount';
            Rs&incount ||= 0;
            Rs&incount++;

            if (1 && cs&count >= 4) {
                cs&count >= 5 and cs&count = 0
                Rs&sleeping = 1;
                $v = me&ollbs,R,'Vawake';
                v and me&Ret,R,{t:v.t,s:vc&s,ball:1};
                # < become %sleeping after @28
                #   is to be avoided
                #me&recycleRbitXz,R;
                each in Rs&z {
                    #rfromN(n)
                }
            }
        },'ift,D'],
        # t =~ /^sleeping/ only if sleeping, sc either
        ['sleeping+Timeding','28',&acgtRs{
            me&rollbs,R,'lupe,countis,incount,Vawake';
        },'ift,D'],
        ['Timeding','89',&acgtRs{
            $t = Rs&sleeping ? "sleeping" : "w";
            $oc = me&ollbs,R,'countis';
            $oic = me&ollbs,R,'incount';
            #~>5 Timeding: t, oc,'->',Rs&countis, oic,'->',Rs&incount
        },'ift,D,sleeping'],
        
        # as child, sometimes unreached etc
        ['sleeping+Timedin','28',&acgtRs{
            me&rollbs,R,'country,luope';
        },'ift,D'],
        ['ball+Timedin','29',&acgtRs{
            ac(R,'inheritsc','Timedin');
            $c = me&rollcounty,R,'luope';
            me&tsc,'%Codon','floupe:'+cs&count,'g';

            Rs&country = me&rollbs,R,'country' || 0;
            Rs&country++;
            me&tsc,'%Codon','byb:'+Rs&country,'G';
            
            # cs&count == 10 and throw "wobble"
            
            $p = me.cbu(R,'Timeding');
            s.t == 'Vame3' and ps&Vawake = R
        },'ift,D'],
    ]};
        
    #c %Zaving %Codons
    # get + futurise
    # < for y, etc
    me.Rsc = &acgtRtc{
        $r = R.sc[t];
        r and r = me&yfuture,r
        # < Ring throws, with the Rc&N[0]s&clu[Rs&ci].t
        r and R.sc[t] = r
        return r
    };
    me.Zavingness = &acgt{ return [
        # watch the game, sequence pushes
        # by timing/commit policy
        # to these locations
        ['Zaving','294',&acgtRs{
            if (Rs&Gens && !Rs&self) {
                # Gens @25:
                #  rollbs %self
                #Rs&self = G&Cye,[R.t,'',{},{}];
                # Gens+self @31:
                #  Rings %Here = R self)%ball
            }
            $lo = Rs&Zaving.split(',');
            Rs&Zaving = {};
            each il lo {
                $t = R.t +' Zaves '+ l;
                n $t  $Zave:l,R
            }
        },'ift,D'],
        # overseeing our data's particular ...
        ['Zaving','67',&acgtRs{
            $allready = 1;
            $allnine = 1;
            each tn Rs&Zaving {
                $h = me&Rsc,R,'Here';
                $t = me&Rsc,R,'Saveting';
                $Q = t && ts&Q;
                $P = Q && Qs&P;
                !P || !Pc&el and allready = 0
                else
                Pc&el != 9 and allnine = 0
            }
            if (Rs&Code) {
                if (!ss&string) {
                    if (!allready || !allnine) {
                        # let it arrive
                    }
                    else {
                        $t = me&tsc,'init-string','+string?','B';
                        me.nto(R,t,&sT{
                            ah(R,'nextlifesc','initCode',1)
                        });
                        Rs&LetGrow = 1;
                    }
                }
                ss&string == '# ' && allnine and Rs&LetGrow = 1
            }
            if (Rs&LetGrow) {
                # centralised pause 
                $old = me&tsc,'LetGrow-pause','..?','d';
                olds&fs = 16;
            }
        },'ift,D'],
        #c %Zaving 7 - unify autogits
        # see overall com dot
        # lum=
        #  0: disappear
        #  1: sym+%Zave, some modulat
        #  2: everything
        # < parameters?
        #   volume - how much to say about changes
        #   pause - no acting (%Unsure currently?)
        #   rewind - to a point (see %differ switching up)
        #   speed - push while typing, etc
        ['Zaving','7',&acgtRs{
            # displaycase room
            s&dis = 1;
            
            $g = me&case;
            gy&cv = 0.7;
            
            $de = gy&can('o','describe');
            
            $sym = dey&can('c','sym');
            $l = symy&can('i','output','s:o,fs:22');
            
            $gi = gy&can('c','gits');
            $allope = 0;
            each tn Rs&Zaving {
                $na = ns&Zavingna = giy&can('c','git-'+t);
                nas&dis = 1;
                me&zuct,na,n;
                ns&waits and allope = 1
            }
            # lum=2 - leave cases open
            allope || ls&ope and return
            # lum=0 - nothing
            $allzen = 1;
            each tn Rs&Zaving {
                ns&wants || ns&summary and allzen = 0
            }
            if (1 && allzen) {
                each tn Rs&Zaving {
                    ns&noDisplay = 1
                }
                return
            }
            # lum=1 - somewhat: minidmo + wants
            each tn Rs&Zaving {
                $na = ns&Zavingna;
                # should look at patch
                ns&wants && ns&Unsure and continue
                # wants to look at patch (click summary)
                me&rollbs,R,'Lookat_'+t and continue
                #me.nto(R,na,&{ R.sc['Lookat_'+t] = 1 });
                
                ns&noDisplay = 1;
                # have a tiny id
                each im ns&minidmo {
                    delete ms&dis;
                    fio(na,m)
                }
                $su = ns&summary;
                su and fio(na,su); sus&fs = 7; sus&lh = 0.3;
                each im ns&wants {
                    !su and throw "wants !summary"
                    fio(na,m)
                }
            }
            
        },'ift,D'],
        #c %Zave - saving thing tricks
        # aft %Gens 25:
        ['Zave','291',&acgtRs{
            $p = Ry&up;
                
            # %Zaves collect
            ah(p,'Zaving',Rs&Zave,R);
            
            # for %ting=tmp|mem, sync get
            Rs&Zave.length == 3 and Rs&AutoSave = 1
            
            $ting = Rs&Saveting ||=
                n $p.t  $ting:Rs&Zave,R

            Rs&AutoSave and tings&directory = "AutoSave/"
            
        },'ift,D'],
        # %Zave <-> %Save completes
        ['Zave','32',&acgtRs{
            $p = Ry&up;
            if (ps&Gens) {
                # %Here = s%string)%ball
                # Gens @25 rolls %self,
                # Gens+self @31 makes %Here
                $h = Rs&Here = me&Rsc,p,'Here';
                me&rollbs,R,'Describing' and hs&Lines = 3
            }
            elsif (ps&Code) {
                # %Here = %ball(s%string
                Rs&Here = pc&s;
                me&rollbs,R,'Describing' and 'conjoin'
            }
        },'ift,D'],
        
        # also these tiny details
        ['Zave','292',&acgtRs{
            $p = Ry&up;
            $ting = me&Rsc,R,'Saveting';
            
            if (Rs&Zave == 'ghost') {
                # filed under se%Codin: G/$se/$t
                $din = me.cbu(R,'Codin');
                !din and delete Rs&Zave; return me&tsc,'no^^%Codin',0,'B';
                tings&section = din.t;
                # fixes !section on initCode commit
                $Q = tings&Q;
                Q and Qs&section = din.t;
            }
            
            # they cache each other
            me&ollbs,R,'Settled' and return
            Rs&AutoSave and return
            each tn ps&Zaving {
                R == n and continue
                # < this climb should be a couple of sc
                $tting = me&Rsc,n,'Saveting';
                $tQ = tting && ttings&Q;
                # sync %ting can happen
                if (!tQ && tting) {
                    ns&AutoSave and me&Ring,R,{und:tting,ov:314}
                    else {
                        # past would do
                        tQ = me&ollbs,tting,'Q';
                    }
                }
                $tQ = tting && ttings&Q;
                tting && !tQ and me&tsc,"tmp!Q"
                $tP = tQ && tQs&P;
                if (tP && tPs&dige) {
                    !tPs&string and throw "dige but not string"
                    ah(R,'havediges',tPs&dige,tPs&string)
                }
            }
            Rs&havediges and tings&havediges = Rs&havediges
        },'ift,D'],
        
        #c Zave autogit
        # and git harness for %Code or %Gens
        # late so %Saveting for %Gens happens
        #  tmp should be ready, ghost will have sent
        #   unless its storage/place is local
        #    within this javascript runtime/elvisability
        #     /insideness
        #    which may have time to process the request
        ['Zave','68',&acgtRs{
            # chop up a displaycase
            s&dis = 1;
            me&rollbs,R,'Described,Committing,Whichto,Unsure';
            $g = me&case,2;
            # can do:!
            #gy&can('ope',&{ while_open() });
            
            $gi = gy&can('c','git','fs:17');
            
            $de = gy&can('c','describe');
            
            $sym = dey&can('c','sym');
            # hoisted by Zaving lum=1
            ac(R,'minidmo',sym);
            ac(R,'minidmo',me&tsc,Cye(['Zave','',{s:Rs&Zave}]),0,'G' );
            
            # big < and/or > symbols
            $l = symy&can('n','local');
            $r = symy&can('n','remote');
            ly&label = me&mtsc,l,'local','◀','B';
            ry&label = me&mtsc,r,'remote','▶','B';
            [l,r].map(&s{ s = sy&label; ss&lh = 0.5 });
            
            
            
            # settings after logic may change them
            $and_finally = &{
                # we have eg to,from = l,r
                #  where 'pull' == (Rs&Wantsto || Rs&Whichto)
                # <> control/show flow
                #  extra clicking makes Unsure
                #   and could open the git log etc
                if (!Rs&Whichto || (Rs&Wantsto && Rs&Amountto < 2)) {
                    # <> flop direction of the patch
                    $Wantingto = &s{
                        Rs&Wantsto == s and return Rs&Unsure = 1
                        Rs&Wantsto = s
                    };
                    me.nto(R,l,&s{ Wantingto('pull') });
                    me.nto(R,r,&s{ Wantingto('push') });
                }
                else {
                    # single < once pulled
                    froms&dis = 0;
                    me.nto(R,to,&s{ Rs&Unsure = 1 });
                }

                if (Rs&Whichto) {
                    # direction it was going
                    $was = Rs&Whichto == 'pull' ? l : r;
                    wass&bri = 1.7
                }
                
                if (Rs&Unsure) {
                    # resume autopush, various causes
                    $un = me&mtsc,sym,'Unsure-re-autogit','i'
                    me.nto(R,un,&s{ Rs&Unsure = 0; });
                }
            };
            
            # where the patch etc may live
            $co = gy&can('c','commit','zi:30,po:2');

            $en = gy&can('c','enter');
            
            $re = eny&can('c','remote');
            Rs&waits_modopt = re;
            me&walls,re,'b:2.2h866';
            res&bgh = '010';
            
            # and then put this situation in it
            $p = Ry&up;
            $h = me&Rsc,R,'Here';
            $t = me&Rsc,R,'Saveting';
            !t and return me&waits,"Z!ting"
            me&zuct,re,t
            
            $Q = ts&Q;
            $P = Q && Qs&P;
            !P and return Rc&b && me&waits,"Z!P"
            !Pc&el and return me&waits,"Z!Pel"
            
            # now on to entering it
            Rs&waits_modopt = en;
            
            
            #c timing
            
            # neighbours - help save time/space
            $neighbours = [];
            each in ps&Zaving {
                R != n and neighbours.push(n)
            }
            
            # particular types, when & how to git them
            if (ps&Code) {
                # hs&string is always
                $pull = &{ hs&string = Ps&string };
            }
            elsif (ps&Gens) {
                $pull = &{
                    # to reset a %Gens, put %self
                    # see Gens+ting @31
                    $s = ps&self = me&Copy,R,Pc&s .c.s;
                    sy&Pfrom = P;
                    Rs&Describing = 1;
                };
                $old = me&mtsc,co,'Deold','🔁','d';
                olds&fs = 16;
                
                if (!Rs&Described) {
                    # borrow
                    neighbours.map(&r{
                        !rs&Described and return
                        Rs&Described = rs&Described;
                    });
                }
                
                if (!Rs&Described && !Rs&Describing && h) {
                    if (ps&Gens && !hc&b) {
                        # init picture from %Gens's ting string
                        # so heads can be compared
                        $s = ps&self;
                        $P = sy&Pfrom;
                        ps&stringguess = P && Ps&string;
                    }
                    if (!ps&stringguess) {
                        oldc&s = '...';
                        olds&hs = 555;
                        me.nto(R,old,&{ Rs&Describing = 1 });
                        gs&fs = 7;
                        # can't think until got
                        return;
                    }
                }
                if (Rs&Describing || ps&stringguess) {
                    !h and debugger
                    delete Rs&Describing;
                    # keep a false %Here
                    $De = Cye(h);
                    # < never happens?
                    ps&stringguess and ~stringguess: R.t
                    ps&stringguess and Des&string = ps&stringguess
                    Des&now = Gtime();
                    Rs&Described = De;
                    Dey&Zave = R;
                    !Des&string and debugger
                }
                $De = Rs&Described;
                if (De) {
                    # the DZ = Dey&Zave = R that made De
                    Dey&Zave and Dey&Zave = me&yfuture,Dey&Zave
                    $DZ = Dey&Zave || R;
                    # not transaction safe:
                    #  current R for a permanence should be set via X
                    Rc&N.indexOf(DZ) < 0 and DZ = R
                    # keep borrowing new De from DZ
                    De != DZs&Described and De = Rs&Described = DZs&Described
                    # we trust the (earlier) neighbour to calc time
                    # then they will look equal
                    DZ == R and DZs&age = Gtime(Des&now)
                    if (DZs&age > 0) {
                        me&mtsc,old,'howold',DZs&age+'s' .sc.fs = 5
                    }
                    $refresh = &{ DZs&Describing = 1 };
                    # can be clicked
                    me.nto(R,old,refresh);
                    # lights up when done
                    De != me&ollbs,R,'Described' and olds&bri = 1.7
                    # do when old
                    DZ == R && DZs&age > 20 and refresh()
                    # < when slep/ball/etc wants to
                }
                Rs&Zave == 'W' and Rs&Unsure = 1
            }
            
            #c look
            $De = Rs&Described || h;
            if (!De) {
                if (!Rs&Here && ps&Gens && !ps&self) {
                    Rs&Wantsto = 'pull';
                    Rs&Amountto ||= 2;
                }
                else {
                    return me&waits,"Z!h"
                }
            }
            else {
            
            if (!ps&Code) {
                # Code may be Here without string
                Des&string == null and return me&waits,"De!string",0,'B'
            }
            
            # into time/desire for
            me&rollbs,R,'Settled,Wantsto';
            ly&tree = De;
            ry&tree = P;
            
            # faulter the autocommit
            Rs&Settled != Ps&dige and delete Rs&Settled
            
            # centralised pause
            ps&LetGrow and return gs&fs = 7
            
            # init kinda thing
            if (Des&string == null && Ps&string != null) {
                !ps&Code and throw "init pull !Code"
                hs&string = Ps&string;
                Rs&Whichto = 'pull';
            }
            
            # notice situation
            $Settle = &{
                Rs&Settled = Ps&dige;
                delete Rs&Wantsto;
                delete Rs&Amountto;
                Rs&Whichto ||= 'pull';
                if (Rs&Committing) {
                    delete Rs&Committing;
                    me&mtsc,en,'made-commit',"pushed",'B';
                    Rs&Whichto = 'push';
                }
            };
            # De may change since push
            Rs&Committing && Rs&Committing == Ps&string && Settle()
            # and separately:
            Des&string == Ps&string and Settle()
            else {
                if (Rs&Settled || Qc&el == 9) {
                    # we sync, they follow
                    Rs&Amountto ||= 2;
                    Rs&Wantsto ||= 'push';
                }
                else {
                    # start different or their updates
                    Rs&Amountto = 1;
                    $someSettled = neighbours.filter(n => ns&Settled).length;
                    someSettled and Rs&Wantsto ||= 'push';
                    Rs&Wantsto ||= 'pull';
                }
            }

            if (Rs&Wantsto) {
                Rs&Amountto ||= 1
                Rs&Unsure and Rs&Amountto = 1
            }
            
            }
            
            $goingto = Rs&Wantsto || Rs&Whichto;
            $redirection = goingto != Rs&Whichto;
            $to = goingto == 'pull' ? l : r;
            $from = to == l ? r : l;
                
            #c patch
            if (Rs&Wantsto) {
                Rs&Amountto ||= 1;
                
                tos&sha = '3 3 3 777';

                # < patch chunk pluck
                # < commit with message, put somewhere
                #   and other ways to convene to key states
                $pa = coy&can('c','patch','fs:14');
                me&walls,pa,'b:2.2h666';
                pas&bgh = '010';
                pas&zi = 30;
                
                if (h) {
                    # < attention upgrades to JRom
                    $c = {t:'Zif',Zif:1,neighbours};
                    c.got = fromy&tree;
                    c.exp = toy&tree;
                    $di = me&Ret,R,c;
                    me&zN,di;
                    me&Ring,di,{und:di,ov:314};
                    me&zuct,pa,di;
                    dis&waits and dis&waits.map(ac(R,'waits',di))
                }


                $says = Rs&Wantsto;
                $ma = me&mtsc,en,'make-commit',says,'B';
                $commit = &{
                    if (Rs&Wantsto == 'pull') {
                        pull();
                        Rs&Whichto = 'pull';
                    }
                    else {
                        # awaits ack
                        Rs&Committing and mac&s += '..'; return
                        !Qs&ready && Qc&el != '9' and return me&waits,'!ready'
                        !Des&string and return me&waits,'!string'
                        
                        Rs&Committing = Qs&string = hs&string;
                        ts&_ting(Q)
                    }
                };
                Rs&summary = di && dis&summary;

                if (Rs&Amountto == 1) {
                    # clickable talk
                    mac&s += "?";
                    !di and throw "no %Zif @ Amountto=1"
                    # hoisted by Zaving 7 lum=1
                    # shall be given nto that lum=2s it
                    # keeps nto that commits
                    ac(R,'wants',ma);
                    me.nto(R,ma,&sT{
                        commit();
                        # wakes %ball%Code%Zaving
                        #  and innards (R%Zave)
                        T.wake = p;
                    });
                }
                else {
                    commit();
                }
                
                # remote cell smoodge
                res&po = 2;
                res&left = -2;
                res&pl = 2;
            }
            else {
                #Rs&Zave == 'tmp' && !me&ollbs,R,'crushed' and Rs&crushed = me&mtsc,en,'!crush'
            }
            and_finally();
        },'ift,D'],
        #c Zif
        ['Zif','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            s&ma = 0.2;
            s&pa = 0.3;
            s&lh = 1;
            
            $g = Rs&got;
            $x = Rs&exp;
            !gs&string and return me&waits,'g!string'
            !xs&string and return me&waits,'x!string'
            
            $ob =
            n $R.t 13 s:~ %fs:29,lh:0.1
            gs&string == xs&string and return obc&s = '=='
            
            me&rollbs,R,'Digs,Diff,CompN,Comp';
            # < view entirety
            # < switch chunk: word/line
            $c = {chunk:'word',fold:1};
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;
            each in Rs&neighbours {
                $z = me&ioty,n,'Zif'
                    .filter(z => zs&Digs == Rs&Digs)[0];
                if (z) {
                    $su = zs&summary;
                    n $su
                    me&tsc,'as-bove',"♲"+ns&Zave,'G' .sc.fs = 20
                    # < put dupe R with Mlimits,
                    #   to simple api for others, eg:
                    # %Zaving 7 expects this if %wants
                    Rs&summary = su;
                    # < behaviour melts away with lum
                    #   or any customising the patch
                    #   like cell division of the %Zifs
                    #   becoming for particular targets
                    return
                }
            }
            
            $N = Rs&Diff ||= diff(xs&string||'',gs&string||'',c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }
            me&diffproximate,R;
            $su = Rs&summary =
            n summary  
            sus&z = delete Rs&Mw.diffproximate;
            
            
            $p =
            n patch   %max-height:7,over,dis
            ps&z = [...Rs&Comp];
        },'ift,D'],
        
    #c Zavmo - exercise in surfing modulata
        ['Zavmo','3',&acgtRs{
            Rs&rowish = 1;
            $p = Ry&up;
            if (!ps&Zavmo || Rs&Zavmo > 1) {
                Rs&Zavmo > 1 and me&walla,'bd:3.1h5,hu-7';
                Rs&Zatop = [];
                #s&fs = 12;
                Rs&zoom = 4;
                if (!Rc&b) {
                    # start tiny unless problematic
                    # action awakens to usual degree
                }
                ps&zuctzto and me&zuct,ps&zuctzto,R
                # controls
                $g = me&case,5;

                $de = gy&can('o','describe');

                $l = dey&can('i','local','s:o,fs:12');
                
                $l = gy&can('m','rolls');
                ls&ope and Rs&opecsc = 1;
                
            }
            ac(R,'inheritsc','zoom');
            ac(R,'inheritsc','opecsc');
            Rs&zoom ||= 0;
            Rs&boost and Rs&zoom += Rs&boost;
            Rs&zoom -= 0.5;
            $stop;
            Rs&zoom < 0 and stop = 1
            Rs&boost < 0 and stop = 1
            #Rs&zoom < 2 and Rs&opecsc = 0;
            Rs&opecsc ||= 0;
            Rs&opecsc -= 0.5;
            Rs&opecsc < 0 and Rs&opecsc = 0
            
            (Rs&boost||0) > 0 and Rs&Zatop = []
            $op = me.cbu(R,'Zatop');
            ac(op,'Zatop',R);
            ops&Zatop.length > 22 and stop = 'Zatop-many'
            
            $g = me&case,5;
            $co = gy&can('c','coordinate');
            
            # t/y
            
            me&mtsc,co,'t',s.t,'T';
            sy&cv && sy&cv != 0.1 and me&mtsc,co,'cv',sy&cv,'y';
            $scan = Rs&scan = me&scan,s;
            scan.is == 'R' and Rs&isR = 1
            if (scan.is != 'C') {
                $sym = me&mtsc,co,'sym','fs:15,ls:-0.1,zi:-1,hs:4955';
                symc&s = scan.is;
                symy&cv = 0.12;
            }
            
            # c/sc
            
            $ca = g;
            # gy&can('c','knowables');
            # unblocks R)%fix
            $Za = cay&can('i','%');
            Zas&ope and Rs&opecsc += 1
            if (Rs&opecsc > 0 && (!Rs&isR || Zas&ope)) {
                me&fixatfour,R,s;
                Rs&Fixturing = ca;
            }
            
            $cb = ops&Zavmiddle;
            cb and cb(op,R,s,g)
            Rs&stop and stop = Rs&stop
            
            me&endome,R;
            # & more
            
            if (Rs&isR) {
                ss&Zavmo and return me&tsc,'loopback','❮','B' .sc.lh = 0.5;
                # look at modulat inners
                each tin ss&Mw {
                    n $n.t  $s:n %R:Zavmo,via:Mw
                }}
                return
            }
            else {
                each in ss&z {
                    n $n.t  $s:n %R:Zavmo
                }
            }
            if (stop && T.nN.length) {
                T.nN = [];
                me&tsc,'zoom-in','❩','B' .sc.lh = 0.5;
            }
            
        },'ift,D'],
        ['Fixturing','31',&acgtRs{
            me&bewind,R and return
            $ca = Rs&Fixturing;
            $Za = cay&can('i','m');
            
            me&Knowfix,R,{ca:ca};
            
            # debug
            Zas&ope &&
                n ZavKnow  $s:ca,R %Zavmo:2,Zavspin

        },'ift,D'],
        ['Zuctto','4',&acgtRs{
            me&zuct,Rs&Zuctto,R
        },'ift,D'],
        

    
        
    ] };
    #Fiveplan #c
    
    =editor
        make way into /G/$cat/$way
        organised by /W/$cat of $way+
      will be
        network of %Gens%Codon
      
      monday:
       gitify %Code/%Zave
        < %differ switching up %self and collecting %Here etc?
        < avoid re-%Lines depending on slep,
           or by accounting for all change
      tuesday:
      wednesday:
       %Zaving 7 folds up, instead of:
        > %Zavmo (modulata reduce) (gone 8326da06) is too slow
           maybe if slept good
           or otherwise mind reduced - R:rovo is getting big
            < A:u etc.
            via R:rovo: 0.8; R:Zavmo: 0.5
            not at all: 0.25
            so what the hell
      thursday:
       %Zaving 7
       < %Search can trust /digwaypoll/ for /ghost/
         the %Idoubleyou ($Way to %Ghostway)
          should be defining seeketh/seekend
          so %Search can ting them,
           group for consumers T.wake=%ting
         
       importo:
       < elvis(), 
          dispatching to JRoms as an entire planet (4s&callback)
          takes impulse from:
       < T.wake=R, say/mutter wakes just the %Code
         will take a bit of testing. how to sleep good?
       < 4s&pause while cm.focus
          except to /tmp/ it every so often...
      
        < /tmp/ faster (while typing)
         < be sure the codemirror is saved
            as it doesnt &gev while typing
            so we appear from a 5s timer or something,
            check all the %Code)%strings from cm
             ideally elvising that so we can pick up on its looseness
              how surely anyone has said what it is
       < redo callback to insides
         modeening that might T.wake=R
         T.wake=modulat might even work,
          since Ry&Displayc&refs has it?
          and it just wants to Cavon
      
        
      friday:
       editor:
        %Codo openness map
          not %Te
           > deciding limbs of it are abandonable
             time-separated limbs
          list of t at depths
           draw current viewport over it
           attention/change history
          with empty space to defocus, to allow:
          typing into space puts search through:
        %Codo search
          preventDefault a C+F event?
         prioritised by where we are
          then knowing all %Codo/%Code/%Zave=mem
           then /ghostack/
         presenting them as %Codo around us
          disjointed, to be pulled in
           as dependencies/further reading
        
        re-scrollto the %Codin,
         re-undohistory the %Codes
        
      unfolding labby mess, way too many dimensions:
       and bring some automation over the top
       saving opennesses, stacking their difference:
         < such that it can be relied upon by others
           who includes it is security over time
           time = distance over the network
       < make an alternative openness network
         using s&medo=me.$handler,
      

        
        %Code%Zaving:
          o - overall com dot, clicking in
          (~|-| |!) inside/next to o
          for (wild|got|still|err)
           relationships to their stores/consumers
            probably having one each (G/W)
          < which are G - space for belief
           G store:
             wild - tmp stored (recent keystrokes)
             got - fully stored (available to consumers)
             err - compiletime errors
              may not know args of way
               they could be made up from error messages
           G consumer:
             wild - ghost updating
             got - runtime ok
             err - runtime errors
    
    assorted:
         < chase 'Kn-burst' error, boosting a medo%fix 
           while Km:Display(Kn:Mw) is there, not zuctedto
           < forward escape &KnowSmush
        
       #c monday?
       
       < %Search (centralised %tings) delivering updates
        < trusting /digwaypol/ for /way/ and /ghost/ it has
       < slep to scan for changes
        
        %Gens starts from out%ball to have in%ball
         < %ino for in feeds out sans s&z
            is a qua muter situation, as is:
             %Lines encoding customs
             %slep deciding where to crawl
             %Te accepting as 'the story'
         < ghost/wormhole happens when in appears
         < %slep for changes, helps %Lines
         < %autosave/**%Gens every 5s, in:
         < %ting=mem for W in localStorage
        
        %Codon%Code the contained way
        < concat fragments from %Code/*%Code
         < inside way are hash-c markers, etc
           see cm doc.markText
            so %Code might not have %string,
             once burst into many somethings
         < reordering folded I
         < send patches, of lines & their ranges
            new similar to gone = move
            sub-diff with move abstracted
            # waits for serve.js?
        
        there are many /W/$cat competing the same /G/*/$way
          suppose creating %Code ensures singularity
         < %searchpath should order A.4s to talk to about things
        
        room for a tool for composing %slep schema
         < wants to use Zavmo for slep on modulata
         < a wand shedding glow
           pointing for KnowC
           which should be from /W/
           see time above
        
        slep wanting to be there for most piles
         generating a change awareness (wai)
          we can otherwise effect
           to drive change from/to A something
    
        
      thence
        T - phenomenate when going to an aboveness that may not be awake
        G - intelligensiata
        the whole vs. a part
        new git repo, just /G/ and /W/
          ignore, slowly import /wormhole/
        
      new server
      # generated by `./spot.pl StyleAgent`
      # run `./serve.pl`
        /way/ - compiled code
          sees /G/$se/$way
        /ghost/ - source code
          for /G/$se/$way
          API like /W/
          maintains dige in wormhole/digway/$way
          notifies /digwaypoll/
           < wait 3ms to scoop any batched changes?
            < they come through one %Sock frame
        /digwaypoll/ - code change socket
          watching wormhole/digway/$way
        
        /W/
          futuristics
          
        /js/ GONE temporarily?
          needs Beach, etc.
          just host /js/Hunt.js
          comes back when $W has .js file?
      
    =cut
    
    # etc
    
StyleAgent: | # compile serve.pl from Wud + JaBabz
    my $way = sub {
        my $t = shift;
        G.way.>$t || die "No $t";
    };
    my $bab = sub {
        my $s = shift;
        my $C = {t=>'somba',y=>{},c=>{s=>$s}};
        G&CoBabbler;
        C.c.s
    };
    
    my $wab;$wab = sub {
        my $t = shift;
        my $w = $way->($t);
        $t eq 'Wud' && $w =~ s/# insert JaBabz here/$way->('JaBabz')/e;
        $w =~ s/Rw\ JaBabz \$C;/JaBabz(\$C);/sg;
        $bab->($w);
    };
    
    my $f = "serve\.pl";
    my $perl = $wab->('Wud');
    write_file $f, $perl;
    `chmod +x $f`;
    sayre "Done";
Wud: | # restacked Wed server
    #!/usr/bin/perl
    use strict;
    use warnings;
    no warnings qw(uninitialized redefine);
    use FindBin qw($Bin);
    use lib "$Bin/othlia";
    use lib "$Bin/slib";
    use G;
    sub dige { slm(12, Digest::SHA::sha256_hex( encode_utf8(shift) ) ) };
    my ($A,$C,$G,$T);
    my $ar = {};
    
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    # divert mojo log statements from our err channel
    #app->log->path((Gc&ipd || Gc&dir)."/mojo\.log")
    #    if Gc&dir || Gc&ipd;
    
    our $listen = "http://localhost:1422";
    sub starts {
        1 && saybl "Starting     listens: $listen";
        1 && saygr "Appstart: ". app->start('daemon', '--listen' => "$listen");
    }
    sub JaBabz {
        my $C = shift;
        no warnings qw(uninitialized redefine);
        # insert JaBabz here
    }
    
    #c /digwaypoll/ notifier, see 281 Sevo
    my $poll = {tx=>[],ways=>{}};
    poll.wayt = {}; # pi/name -> pi-name
    poll.wayd = {}; # pi-name -> s&dige
    poll.doing = &o{
        return if $o && poll.one && $o ne poll.one;
        my @ways;
        each pi poll.ways {
            my $t = $p;
            $t = poll.wayt.>$p ||= do { $t =~ s/\W/-/sg; $t };
            my $digway = "wormhole/digway/$t";
            my $dig = readlink $digway;
            sayre "no $digway" if !$dig;
            next if !$dig;
            my $was = poll.wayd.>$t;
            next if $was && $dig eq $was;
            poll.wayd.>$t = $dig;
            $was = 'any';
            $was && push @ways,
                $p.'%dige:'.$dig
        }
        
        if (@ways) {
            # send many d=0 Lines as one message,
            # so receiver can react immediately
            my $s = join"",map{ $_ ."\n" }@ways;
            for my $tx (@{poll.tx}) {
                $tx->send($s);
            }
        }
        
        Mojo::IOLoop->timer(0.3,&{ poll.doing(poll.one = rand()) });
    };
    websocket '/digwaypoll' => &s{
        my $tx = $s->tx;
        poll.doing();
        1 && sayyl "Got digwaypolling";
        
        # complete picture (t/dige) at new listeners
        poll.wayd = {};
        push @{poll.tx}, $tx;
        
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        
        $s->on(message => &M,m{ #}
            die "Not wordy: $m" unless $m =~ /^([\w\-\/]+)(%\w+.*)?$/;
            tx.ways.>$1 ++ || poll.ways.>$1 ++
        });
        
        $s->on(finish => &M,code,reason{
            @{poll.tx} = grep { $_ ne $tx } @{poll.tx};
            each ti tx.ways {
                -- poll.ways.>$t && next;
                delete poll.ways.>$t;
                $t = delete poll.wayt.>$t;
                delete poll.wayd.>$t;
            }
            #1 && sayre "digwaypoll Gone: $addr $code $reason";
        });
    };
    
    #c /W/
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.Wache ||= {};
        
        # read t, write if s
        # all there
        $t = "W/$t";
        # char safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1 etc
        $t =~ s/\/(\d)$//;
        my $species = $1 || '1';
        my $f = "$t/$species";
        
        # returns json:
        my $re = {ok=>0};
        my $nos = 0;
        
        
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($pa && $pa ne $cache.>$f ) {
                re.er = 'not ffwd';
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # the .5 may be in the same request
                my $five = $c->param('fivestring');
                if ($five) {
                    my $ff = "$t/5";
                    write_file("$ff\.1",encode_utf8($five));
                    `mv $ff\.1 $ff`;
                }
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $nos = 1;
            }
        }
        else {
            if (-f $f) {
                $s = decode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            # it should have a dig
            my $dig = slm(12,
                $f =~ m{^W/spot/} ? dig($s)
                :
                dige($s)
            );
            $cache->{$f} = $dig;
            re.dige = $dig;
            re.s = $s;
            # if they know its hash, assume they don't need the string again
            if (my $ha = $c->param('have')) {
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            # or if it was a write
            delete re.s if $nos;
        }
        $c->render(text=>sjson($re));
    };
    
    #c /ghost/
    any '/ghost/*w' => &c{
        my $t = $c->param('w');
        # / in t not meaning directory
        (my $st = $t) =~ s/\W+/-/g;
        my $se = $c->param('se') || '*';
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.ghostache ||= {};
        my @opt = glob "G/$se/$st";
        die "multiple @opt" if @opt > 1;
        my $f = $opt[0] || '';
        my ($cat) = $f =~ /^G\/([^\/]+)\//;
        # < avoid some disking if $have
        my $wig = "wormhole/digway/$st";
        my $digway = readlink($wig);
        
        # returns json:
        my $re = {ok=>0};
        my $was_write = 0;
        
        # hasghost
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($se eq '*') {
                re.er = "!se param: writing G/\$se/\$t";
                $s = '';
            }
            elsif ($pa && $pa ne $cache.>$f ) {
                if (!$cache.>$f ) {
                    re.er = "lookup first";
                    # < or trust digway?
                }
                else {
                    re.er = 'not ffwd';
                }
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                -f $f && `rm $f`;
                re.ok = 'deleted';
            }
            else {
                # non-name is directory
                (my $dir = $f) =~ s/\/[^\/]+$//;
                -d $dir || `mkdir -p $dir`;
                my $new = !-f $f;
                #$s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $was_write = 1;
            }
        }
        else {
            if ($f && -f $f) {
                $s = decode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            my $dig = dige($s);
            $cache->{$f} = $dig;
            if ($dig ne $digway) {
                -l $wig && `unlink $wig`;
                `ln -s $dig $wig`;
            }
            re.dige = $dig;
            die "no cat: $f" if !$cat;
            re.se = $cat;# if $cat ne $se;
            re.s = $s;
            # they know string if:
            if (my $ha = $c->param('have')) {
                # they know its hash
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            if ($was_write) {
                # they just sent it
                delete re.s;
                # speed /digwaypol/
                poll.doing() if poll.ways && poll.ways.>$t;
            }
            
        }
        $c->render(text=>sjson($re));
    };
    
    #c /way/ 4s&waythe way
    # < Accept headers to get the various translations
    get '/way/*way' => &c{
        my $t = $c->param('way');
        $t =~ s/\W+/-/g;
        my $w;
        for ('G/*','wormhole/way') {
            my @opt = glob "$_/$t";
            my $f = shift @opt;
            next if !$f;
            $w = {t=>$t,y=>{}};
            wc&s = decode_utf8(read_file($f));
            ws&dige = slm(12, dig wc&s);
            ws&of = 'w';
            last
        }
        $w || return $c->reply->not_found;
        $c->res->headers->append(Dige => ws&dige);
        
        # < JaBabz is final
        my $babv = readlink("wormhole/digway/JaBabz");
        a&wayjs = {} if a&babv ne $babv;
        a&babv = $babv;
        
        my $have = $c->param('have');
        if ($have && a&wayjs.>w.t.>ws&dige &&
            $have eq ws&dige ) {
            return $c->render(text => '')
        }
        
        
        my $s = a&wayjs.>w.t.>ws&dige ||= do {
            my $C = $w;
            Rw JaBabz $C;
            wc&s
        };
        #$s =~ /^(.+?m\.replace(.+?))$/sgm && sayyl "Fuo:\n $1\n\n";
        $c->render(text => $s);
    };
    
    starts();

