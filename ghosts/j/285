Fividy: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    window.reverse = &s{ return s.slice().reverse() };

    # hash stash
    window.ah = &th{
        !isC(t) and throw "!C"
        $M = [... arguments].slice(2);
        $h = t.sc[h] ||= {};
        while (M.length) {
            $k = M.shift();
            M.length > 1 and h = h[k] ||= {}
            else {
                h[k] = M.shift()
            }
        }
    };

    # array match
    # if M, returns [not], puts M[matched]
    #  eg N = arou(N,'acty',actyN) separates actyN from N
    # else, returns [matched]
    window.arou = &NyM{
        $matched = M || [];
        if (isst(y)) {
            $k = y;
            y = &n{ return n.sc[k] };
            if (k[0] == '!') {
                $cb = y;
                k = k.substr(1);
                y = &s{ return !cb(s) }
            }
        }
        if (M && !isar(M)) {
            # for an Nx.$k=N tape splitter
            !k and throw "dunno Nx k",M
            matched = M[k] ||= []
        }
        $not = [];
        each in N {
            y(n) ? matched.push(n) : not.push(n)
        }
        return M ? not : matched
    };
    # match N into one of several groups
    window.aroh = &Nc{
        c ||= {};
        isst(c) and c = G&peel,c
        $h = {};
        each kn c {
            # matcher n is &s{} or a scgk
            n == '1' and n = k
            $M = [];
            N = arou(N,k,M);
            h[k] = M
        }
        h.N = N;
        return h
    }
    
    #c C-ish
    # < G&C, babz: = C yadda @3
    #   and to parse args for eg opeolo
    #   has a lot to do with:
    window.isnu = &s{ return typeof s == 'number' };
    window.isfu = &s{ return typeof s == 'function' };
    window.isst = &s{ return typeof s == 'string' };
    window.isar = &s{ return s && s.constructor == Array };
    window.isha = &s{ return s && typeof s == 'object' && !isC(s) };
    window.isob = &s{ return s && typeof s == 'object' };
    window.isR = &s{ return isC(s) && sy&R == s };
    window.Cye = &s{
        s = G&Cye,s;
        s.y = {cv:s.y.cv};
        delete ss&z;
        return s
    };
    window.sca = &s{
        s *= 1;
        while (s >= 1) { s = s / 10 }
        return s;
    };

    # read spacey t, or insert C = y()
    window.fio = &qty{
        !isC(q) and throw "NotC"
        qs&z ||= [];
        qy&tw ||= {};
        typeof t == 'object' and y = t; t = null
        y == '9' and $deletes = 1; y = null
        $ar = y && y.constructor == Array;
        y && t == null and t = ar ? y [0] : y.t
        y != null && y == 0 and $readonly = 1
        
        $s = qy&tw[t];
        # allow removing from qs&z
        $si = s && qs&z.indexOf(s);
        si < 0 and s = null
        if (deletes) {
            si < 0 and return
            qs&z.splice(si,1);
            delete qy&tw[t];
            return
        }
        if (!s && !readonly) {
            s = y ? ar ? G&Cye,y : y : G&Cye,[t,1];
            qs&z.push(s);
            qy&tw[t] = s;
        }
        s and ss&z ||= [];
        return s
    };
    
    # C usu sort by cv,t
    window.tvsortz = &z{
        z.sort(&ab{
            return (ay&cv||0)*1-(by&cv||0)*1
                || ('' + a.t).localeCompare(b.t)
        });
        return z
    }
    
    
Twoism: | # js the way in, fetching into an eval
    # non-G&way way: fetch into an eval 
    $way = &ty{
        $.ajax('way/'+t).done(&s{
            $f;
            eval(['f = function (ar) {',s,'}'].join("\n"));
            $re = f({});
            y and y(re);
        });
    };
    
    $ch = &s{
        $("<p>").appendTo(document.body).text(s);
    };
    # load $t.js to C with s&I
    window.Cyeblong = &v{
        return {t:v[0], y:{cv:v[1]||0.1}, c:v[2]||{}, sc:v[3]||{}};
    };
    $loadI = &t{
        $tocfunc = t+'_current';
        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
        $toc = window[tocfunc]();
        
        $W = Cyeblong([t]);
        Ws&I = {};
        
        $D;
        each iv toc {
            $ind = v.shift();
            $C = Cyeblong(v);
            if (ind == '') {
                D = Ws&I[C.t] = C;
                D.y.tw = {};
                D.y.tv = {};
                Ds&z ||= [];
            }
            else if (ind == '  ') {
                D.t != s&js and throw "Csjs not last D", C, D;
                c&code = window[s&name];
                typeof c&code != 'function' and throw "Cccode not function", C, D;
                # grow I
                D.y.tv[C.t] ||= {};
                D.y.tv[C.t][C.y.cv] = C;
                D.y.tw[C.t] = C;
                $l = Ds&z.slice(-1);
                l[0] and l[0].y.next = C;
                Ds&z.push(C);
                D.y.in ||= C;
                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                    G[C.t] = c&code;
                }
            }
            else {
                throw "deep C: "+t, v
            }
        }
        return W
    };
    
    # Automation
    A = window.A = Cyeblong(['top']);
    A.y = A;
    A.1 = A.2 = A.3 = A.4 = A.5 = A;
    1s&N = [];
    # GOING - gev insists on A.4.up while finding path in
    $Y = A.up = Cyeblong(['outside']);
    Y.y = Y;
    Y.2 = A;
    
    # Culture
    $C = Cyeblong(['Top']);
    # Grind
    window.G = Cyeblong(['Gee']);
    G.y = G;
    # Telomena
    $T = {};
    
    # mind as I
    $M = 'Hunt'.split(' ').map(t => loadI(t));
    $W = M[0];
    A.I = Ws&I;
    4c&ttl = 3600;
    
    # mind as me
    $me = 4c&me = window.me = {};
    me.Ja = {}; # pins
    me.timestamp = &{ return(new Date).toISOString() };
    A&me = me;
    # from all these epochs of development
    $list = ('NutGravy iooia '+
        'Soogle Coffle Packle Foogla Fividy Fourism')
        .split(' ');
    $however = 1;
    $someend = &{
        however--
        however == 0 and way('Threeism')
    };
    $morelist = &i{
        $t = list[i];
        !t and return someend();
        way(t,&r{
            t == 'iooia' and me.io = r
            morelist(i+1);
        });
    };
    morelist(0);
    
    # also since they are not G&way:
    # A5Iw shall know these, ghost updates begin
    'Soogle Packle Coffle Foogla EleMento EleVisAn Fourism'.split(' ').map(&t{
        however++; G&way,t,{},someend
    });
    
Threeism: |
    # lots from somewheres...
    $C = G&Cye,['Elevat',2];
    
    # the right side
    $('body div.v8').remove();
    A.on = $('body')[0];
    $el = 4s&starlane = $('<div class="v8" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:55%;height:20%;width:43%">')
    .appendTo('body')[0];
    # the left
    4s&planelane = $('<div class="v9" style="position:absolute;'
        +'white-space:pre;font-size:70%;'
        +'top:0%;left:0%;width:43%">')
    .appendTo('body')[0];
    
    
    # to named A.4
        # GOING:
        el.A = A;
    $dns = G.DNS = G.DNS || {};
    $old = dns[A.4.t];
    dns[A.4.t] = A.4;
    
    # drive units
    G.clon = &{ $(window).on("click", &ev,{ G&gev,ev }) };
    G.keon = &{ $(window).on("keydown", &ev,{ G&gev,ev }) };
    G.clof = &{ $(window).off("click") };
    G.keof = &{ $(window).off("keydown") };
    G.togwid = &m,fr,to{
        if ($(m).attr('togwid') == to)
            to = fr
        $(m).attr('togwid', to)
        $(m).css('width', to);
    };
    
    # says
    $msgs = $(A.on).find('> #msgs')[0];
    msgs ||= $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
    4s&msgs = msgs;
    
    $originA = A.4;
    # error handling
    #  get A as it was last G&h
    window.BamonG = &{ 
        $B = Gc&B;
        return B && Bs&A || BoriginA
    };
    window.onerror = &msg,url,lineNo,colNo,error{
        $A = BamonG();
        A&ev and A&ev.preventDefault();
        A&bang and return
        A&bang = 1;
        G&Ban,error,msg,url,lineNo,colNo,error;
        delete A&bang;
        return
    };
    
    
    me.start = &{
        4s&NormalI = A.I;
        # in favour of dispatch table towards 4:
        # inits and continues methods on me
        # unco:
        4s&N = [];
        document.title = 'hoot';
        A.on = el;
        A.on.A = A;
        T = {y:{},c:{},sc:{}};
        #me.star(A,C,G,T);
        me.plane(A,C,G,T);
    };
    
    G.clon(); G.keon();

    me.start();
    
    
Fourism: |
    # new road to R without J!
    #  from me.starc instead of wobulus?
    # breaks too much just now: Teing, A.n
    #  when 1s&ein has sockets that R-times peel off
    me.Fourismo = &acgt{
        # knowing
        $El = 1s&elvisory ||= Cyeblong(['El']);
        # GOING need for J having it
        1s&Te = El;
        # GOING need to na&Teelone, El%ball
        A.n = A;
        # being that top level (not A.1.t)
        # < here only
        s&Te = El;
        
        s&mune = 1;
        
        $I = me&Resurrect,'I',1s&s;
        Iy&J = A.4;
        me&J,'Fourier','W';
        
        $D = me&ballRom,I,C;
        
        1s&s = I;
        return;
        $on = D.y.Display.sc.on;
        if (!4s&on.contains(on)) {
            ~>5 On: C.t
            on.A ||= A;
            4s&on.appendChild(on)
        }
        1s&s = I;
    };
    
    # NutEl
    A.I.i.y.tw.gev.c.code = &acgt,ev,J{
        ev ||= event;
        ev.target.tagName == 'H2' and return
        # locate A:top of A:4
        #debugger;
        if (!ev.target) {
            A&event_A and A = A&event_A;
        }
        elsif (ev.target == document.body) {
        
        }
        else {
            $S = ev.target;
            while (S && !(S.A && S.A.4)) {
                S = S.parentNode;
            }
            # must be clicking <body>, <html>
            #   or something above .A element space
            !S and return
            A = S.A.4;
            !A and throw "out of cone";
            A&event_A = A;
        }
        if (A&event_A) {
            A&event_A != A and ~innerA: A.4.t
            A = A&event_A;
        }
        G&Aye,'ev',9,{ev:ev}
    };
    
    #c ambient synapse
    4c&framerate = 0.3;
    # when without G&h
    window.Gtime = &d{ return G&time,d };
    
    # loop comebacks between attentions
    $lastwas = 0;
    me.plane = &acgt{
        #A.on = 4s&planelane;
        A != window.A and throw "How there A"
        !A.on.ownerDocument.contains(A.on) and return ch("unplugged");
        $me = A&me;
        $starts = G&time;
        lastwas and 4s&nonms = G&time,lastwas;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&framerate;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000
        
        # < route G&gev to me.plane sometimes?
        #   they are different A.4s really
        #   and 4c&callback
        4c&callback ||= &{ me.plane(Y,C,G,T) };
        $sing = 4c&callback.singly = {};
        G&yl:frames,&{ sing == 4c&callback.singly && 4c&callback() };
        
        try { me&planet }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }
        
        $ends = G&time,starts;
        4s&ms = ends;
        lastwas = G&time;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    # cast gazet
    # this is a bag of marbles, they are free and together
    me.planet = &acgt{
        4s&paused and return
        $A = G&Aye,'planet';
        $B = Gc&B;
        B and 'collect?'
        B = Gc&B = G&Cye,[A.t,''];
        Bs&A = A;
        Bs&z = [];
        $g = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        !me.inita.ed and me&inita
        
        # 1/10th attend
        A&sip.slice(-1)[0] == 0 and me&otherandcontinue
        
        4s&Jays = 0;
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        me&J,'Fourier','W';
        4s&Fourieronlynow and delete 4s&Fourieronlynow; throw "async Fourier only"
        
        me&J,['Planet','W',{el:el},{timing:0}]
        # < me.do_main does any $el/*%J
    };
    me.Ja.Planet = &acgts{
        me&Gomp;
        s&timing = 1;
        n Har   %rovo:Domebegin
        #s&ab = 1;
        #s&wi = '44%';
    };
    #c Fourismness
    me.Fourismness = &acgt{ return [
        ... me&Zavingness ,
        ['Domebegin','4',&acgtRs{
            $C = G&Cye,['Vubd',1,{},'mune'];
            $D = me&ballRom,R,C;
        },'ift,D'],
        
        ['mune','29',&acgtRs{
            me&walla,'hu:7';
            Rs&Utilis = 1;
        },'ift,D'],
        
        # universal habitat 
        ['Utilis','291',&acgtRs{
            # window/A.4 goes to sleep
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });
            
            # this toplevel-ish R may take ages
            Rs&timetopause = 3418;
            
            # spending time in/out of the callback
            $g = me&opeolo,'plane';
            $ti = gy&can('n','time');
            me&mtsc,ti,'timein',4s&ms,'6' .sc.fs = 12;
            me&mtsc,ti,'timeof','/','g'
            me&mtsc,ti,'timeout',4s&nonms,'6'
            
            # %ball transfigurations (move,copy,etc)
            n Elvito  R %Tool
            # %ball activations (just %R -> JRom)
            Rs&playsheet = {
                ball: &acgtR{
                    me&Bear,R,Rc&s,'play'
                },
                fix: &acgtR{  },
            };
            
            # remotes
            # news from the editor
            me&Rom,R,'GhodigWap';
            # newsroom behind all %tings
            Rs&Inn = me&Rom,R,'Search';
            
            # one variety of walking around names
            #  climbing X, < other structures
            #  invent linguistic surface bubbler
            me.upsit = &acgtRt{
                $z = me.cby(R).reverse();
                each in z {
                    $X = nc&X;
                    $oX = X && X.x && X.x[t];
                    oX && oX.z and return oX.z[0]
                }
            };
            me&rollbs,R,'Incremento';
            Rs&Incremento = (Rs&Incremento||0)+1;
            if (Rs&Incremento == 2) {
                ['GhodigWap','Search'].map(&t{
                    $r = me&upsit,R,t;
                    r && me&introqua,r,'boost:-1';
                })
            }
            # another thing-ink dripper:
            #        $he = Rc&N[0];
            #        $i = hes&inti = (hes&inti||0)+1;
            #        me&tsc,'%Zave',i+'th','y';
            #        i == 2 and debugger
            # the first few %settings are usually important:
            #    me&tsc,'%Zave',haks(R.sc).slice(0,10).join(','),'y';
            
            # Codon/experiment
            me&Rom,R,'Elfor';
            # wash
            me&Rom,R,'Evelse';
        },'ift,D'],
        
        #c %Codon
        # < leading the way
        ['Elfor','291',&acgtRs{
            n Flar  R %Codon,ting:W,Gens,tingspot
            #n ForThe  R %ting:W,Gens,tingspot
            
        },'ift,D'],
        
        # cloud of %Codon and related types inheriting
        ['Codon','291',&acgtRs{
            # inherity settings + %Codon ness
            $p = Ry&up;
            Rs&fix && ps&Code && ps&ball and Rs&Cofix = 1
            !(Rs&ball || Rs&Gens) and delete Rs&Codon; return
            ac(R,'inheritsc','Codon');
            
            Rs&Gens and Rs&Gedo = 1
            !Rs&ball and return
            
            # < creates an inside
            $c = me&tsc,'%Codon','C','B';
            cs&medo = 'fliv';
            
            # diverge into types
            if (ss&R == 'Codo') {
                # an out%ball sprouts JRom:Codo
                # implied by %R=Codo
                # < feed openness
                me&tsc,'%Codo','bout','6'
                ss&Doming = 3;
                ss&Codon = 1;
                Rs&compLines = &D{
                    delete Ds&Doming; 
                    delete Ds&Codon;
                };
                me&Bear,R,s,'play';
            }
            else {
                $p = me.cbu(R,&r{ return rs&Codo && rs&ball });
                # above %Codo
                !p and me&tsc,'%Codo','bove','6'
                # all %Codo/**%Codon !%Codo are %Code
                else
                p != R and Rs&Code = 1
                else {
                    me&tsc,'%Codo','odo..','6'
                }
            }
            
            # auto %play any %R=Codo|Code
            #  similar to $t%W=nott, nott being a pin to decode it through
            #   future is decoding W with other W
            # be an out%ball and in%ball for either
            
            #n Flar  R %Codon,ting:W,Gens,tingspot
            #n ForThe  R %ting:W,Gens,tingspot
            
        },'ift,D'],
        
        ['Codo','2901',&acgtRs{
            #$c = me&tsc,'%Codon','Codo','g';
            # %Codon not inherited through %JRom
            Rs&Codon = 1;
            # becomes inside
            Rs&ball and return Rs&Codin = 1
            
            if (Rs&Gens) {
                # pass %Codo to child of %Gens, then any %ball
                ac(R,'inheritsc','Codo');
            }
            else {
                delete Rs&Codon
            }
        },'ift,D'],
        
        # Codo outside
        ['Gens+Codon','293',&acgtRs{
            $c = me&tsc,'%Codon','Gedo','g';
            Rs&Zaving = "mem,W";
            delete Rs&ting;
            # < %Here's %Lines to /mem/, /W/
        },'ift,D'],
        
        # Codo inside
        ['ball+Codin','296',&acgtRs{
            $c = me&tsc,'%Codon','Codin','g';
            me&walla,'hu:17';
            !me.cbu(Ry&up,'Codin') &&
                me&walla,'wi:1.3';
            s&bgh = '111';
            
            $ag = me&tsc,'add-ghost','';
            ags&hs = "378";
            agc&s = '';
            ags&e = 1;
            me&Tie,R,'sayeth',1;
            $say = Rs&sayeth;
            say and me&input,R,say .sc.initCode = 1;

            # < feed openness
            #Rs&beopen ||= 1;
        },'ift,D'],
        
        # fixturism
        ['ball+Code','293',&acgtRs{
            $c = me&tsc,'%Codon','Code','g';
            4s&thecode = R;
            Rs&Zaving = "tmp,ghost";
            Rs&compLines = &D{
                # < %size of it, texture, headings
                # < %ghost=dig(%string)
                delete Ds&string
            };
            Rs&initCode and ss&string = "# "
        },'ift,D'],
        
        ['fix+Cofix','296',&acgtRs{
            $c = me&tsc,'%Codon','Cofix','g';
            # < feed openness
            Rs&beopen ||= 1;
        },'ift,D'],
    ]};
        
    #c %Zaving %Codons
    # get + futurise
    # < for y, etc
    me.Rsc = &acgtRtc{
        $r = R.sc[t];
        r and r = me&yfuture,r
        # < Ring throws, with the Rc&N[0]s&clu[Rs&ci].t
        r and R.sc[t] = R.sc[t]
        return r
    };
    me.Zavingness = &acgt{ return [
        # watch the game, sequence pushes
        # by timing/commit policy
        # to these locations
        ['Zaving','294',&acgtRs{
            if (Rs&Gens && !Rs&self) {
                # Gens @25:
                #  rollbs %self
                #Rs&self = G&Cye,[R.t,'',{},{}];
                # Gens+self @31:
                #  Rings %Here = R self)%ball
            }
            $lo = Rs&Zaving.split(',');
            Rs&Zaving = {};
            each il lo {
                $t = R.t +' Zaves '+ l;
                n $t  $Zave:l,R
            }
        },'ift,D'],
        # overseeing our data's particular ...
        ['Zaving','67',&acgtRs{
            $allready = 1;
            $allnine = 1;
            each tn Rs&Zaving {
                $h = me&Rsc,R,'Here';
                $t = me&Rsc,R,'Saveting';
                $Q = t && ts&Q;
                $P = Q && Qs&P;
                !P || !Pc&el and allready = 0
                else
                Pc&el != 9 and allnine = 0
            }
            if (Rs&Code) {
                if (!ss&string) {
                    if (!allready || !allnine) {
                        # let it arrive
                    }
                    else {
                        $t = me&tsc,'init-string','+string?','B';
                        me.nto(R,t,&sT{
                            ah(R,'nextlifesc','initCode',1)
                        });
                        Rs&LetGrow = 1;
                    }
                }
                ss&string == '# ' && allnine and Rs&LetGrow = 1
            }
            if (Rs&LetGrow) {
                # centralised pause 
                $old = me&tsc,'LetGrow-pause','...','d';
                olds&fs = 16;
            }
        },'ift,D'],
        #c %Zaving 7 - unify autogits
        =pod
          seeing only yay much
          fold around together
          share same diffs
          gui
          should shrink right up: o - overall com dot
           (~|-| ) inside/next to o
            cluing sync to both stores:
             o ~ wildness
             o~ tmp stored
             o- fully stored
           o -> % etc unpacks its friends
           %important modulat should float to the top
          parameters
           volume - how much to say about changes
           pause - no acting (%Unsure currently?)
           rewind - to a point (see %differ switching up)
           speed - push while typing, etc
        =cut
        ['Zaving','7',&acgtRs{
            # chop up a displaycase room
            s&dis = 1;
            $g = me&opeolo,'Z';
            gy&cv = 0.7;
            gs&dis = 5;
            gy&label.sc.dis = 0;
            g = gy&can('n','aving');
            gs&dis = 3;
            
            
            $de = gy&can('n','describe');
            des&dis = 4;
            des&va = 1;
            # crushed params/waits from either if closed
            
            $sym = dey&can('n','sym');
            syms&dis = 4;
            # big < and/or > symbols!
            $l = symy&can('n','local');
            ly&label = me&mtsc,l,'local','o','B';
            
            $gi = gy&can('n','gits');
            gis&dis = 4;
            each in Rs&Zaving {
                me&zuct,gi,n;
            }
            
            R.t == 'g' &&
                n zavmo $s:g %R:Zavmo
        },'ift,D'],
        ['Zavmo','3',&acgtRs{
            Rs&rowish = 1;
            $p = Ry&up;
            !ps&Zavmo and s&fs = 8; Rs&zoom = 3
            ac(R,'inheritsc','zoom');
            Rs&zoom ||= 0;
            Rs&boost and Rs&zoom += Rs&boost;
            Rs&zoom -= 0.5;
            
            me&tsc,'t',s.t,'T';
            sy&cv != 0.1 and me&tsc,'cv',sy&cv||"''",'y';
            $scan = Rs&scan = me&scan,s;
            scan.is != 'C' &&
            n sym 12 $s:scan.is %fs:15,ls:-0.1,zi:-1,hs:4955
            
            Rs&play and me&nu,R;
            #Rs&play and $sca = me&scan,s; me&nu,'scan',sca;
            
            Rs&zoom < 0 and return
            
            each in ss&z {
                n $n.t  $s:n %R:Zavmo
            }
        },'ift,D'],
        
        #c %Zave - saving thing tricks
        # aft %Gens 25:
        ['Zave','291',&acgtRs{
            $p = Ry&up;
                
            # %Zaves collect
            ah(p,'Zaving',Rs&Zave,R);
            
            # for %ting=tmp|mem, sync get
            Rs&Zave.length == 3 and Rs&AutoSave = 1
            
            $ting = Rs&Saveting ||=
                n $p.t  $ting:Rs&Zave,R

            Rs&AutoSave and tings&directory = "AutoSave/"
            
        },'ift,D'],
        # %Zave <-> %Save completes
        ['Zave','32',&acgtRs{
            $p = Ry&up;
            if (ps&Gens) {
                # %Here = s%string)%ball
                # Gens @25 rolls %self,
                # Gens+self @31 makes %Here
                $h = Rs&Here = me&Rsc,p,'Here';
                me&rollbs,R,'Describing' and hs&Lines = 3
            }
            elsif (ps&Code) {
                # %Here = %ball(s%string
                Rs&Here = pc&s;
                me&rollbs,R,'Describing' and 'conjoin'
            }
        },'ift,D'],
        
        # also these tiny details
        ['Zave','292',&acgtRs{
            $p = Ry&up;
            $ting = me&Rsc,R,'Saveting';
            
            if (Rs&Zave == 'ghost') {
                # filed under se%Codin: G/$se/$t
                $din = me.cbu(R,'Codin');
                !din and delete Rs&Zave; return me&tsc,'no^^%Codin',0,'B';
                tings&section = din.t;
            }
            
            # they cache each other
            me&ollbs,R,'Settled' and return
            Rs&AutoSave and return
            each tn ps&Zaving {
                R == n and continue
                # < this climb should be a couple of sc
                $tting = me&Rsc,n,'Saveting';
                $tQ = tting && ttings&Q;
                # sync %ting can happen
                if (!tQ && tting) {
                    ns&AutoSave and me&Ring,R,{und:tting,ov:314}
                    else {
                        # past would do
                        tQ = me&ollbs,tting,'Q';
                    }
                }
                $tQ = tting && ttings&Q;
                tting && !tQ and me&tsc,"tmp!Q"
                $tP = tQ && tQs&P;
                if (tP && tPs&dige) {
                    !tPs&string and throw "dige but not string"
                    ah(R,'havediges',tPs&dige,tPs&string)
                }
            }
            Rs&havediges and tings&havediges = Rs&havediges
        },'ift,D'],
        
        #c Zave autogit
        # and git harness for %Code or %Gens
        # late so %Saveting for %Gens happens
        #  tmp should be ready, ghost will have sent
        #   unless its storage/place is local
        #    within this javascript runtime/elvisability
        #     /insideness
        #    which may have time to process the request
        ['Zave','68',&acgtRs{
            # chop up a displaycase
            s&dis = 1;
            $g = me&opeolo,'Z';
            gs&dis = 2;
            $gl = gy&label;
            gls&dis = 0;
            # can do:!
            #gy&can('ope',&{ while_open() });
            
            $gi = gy&can('n','git');
            gis&dis = 4;
            gis&fs = 17;
            
            $de = gy&can('n','describe');
            des&dis = 4;
            
            $sym = dey&can('n','sym');
            syms&dis = 4;
            # big < and/or > symbols
            $l = symy&can('n','local');
            $r = symy&can('n','remote');
            ly&label = me&mtsc,l,'local','<','B';
            ry&label = me&mtsc,r,'remote','>','B';
            [l,r].map(&s{ s = sy&label; ss&lh = 0.5 });
            
            # where the patch etc may live
            $co = gy&can('n','commit');
            cos&dis = 4;
            cos&zi = 30;
            cos&po = 2;

            $en = gy&can('n','enter');
            ens&dis = 4;
            
            $re = eny&can('n','remote');
            res&dis = 4;
            me&walls,re,'b:2.2h866';
            res&bgh = '010';
            
            # and then put this situation in it
            $p = Ry&up;
            $h = me&Rsc,R,'Here';
            $t = me&Rsc,R,'Saveting';
            !t and return me&mtsc,re,"Z!ting";
            me&zuct,re,t
            
            $Q = ts&Q;
            $P = Q && Qs&P;
            !P and return Rc&b && me&mtsc,re,"Z!P";
            !Pc&el and return me&mtsc,re,"Z!Pel";
            
            
            #c timing
            me&rollbs,R,'Described,Committing,Whichto,Unsure';
            # return anywhere ahead to avoid business
            
            # neighbours - help save time/space
            $neighbours = [];
            each in ps&Zaving {
                R != n and neighbours.push(n)
            }
            
            # particular types, when & how to git them
            if (ps&Code) {
                # hs&string is always
                $pull = &{ hs&string = Ps&string };
            }
            elsif (ps&Gens) {
                $pull = &{
                    # to reset a %Gens, put %self
                    # see Gens+ting @31
                    $s = ps&self = me&Copy,R,Pc&s .c.s;
                    sy&Pfrom = P;
                    Rs&Describing = 1;
                };
                $old = me&mtsc,co,'Deold','ðŸ”','d';
                olds&fs = 16;
                
                if (!Rs&Described) {
                    # borrow
                    neighbours.map(&r{
                        !rs&Described and return
                        Rs&Described = rs&Described;
                    });
                }
                
                if (!Rs&Described && !Rs&Describing && h) {
                    if (ps&Gens && !hc&b) {
                        # init picture from %Gens's ting string
                        # so heads can be compared
                        $s = ps&self;
                        $P = sy&Pfrom;
                        ps&stringguess = P && Ps&string;
                    }
                    if (!ps&stringguess) {
                        oldc&s = '...';
                        olds&hs = 555;
                        me.nto(R,old,&{ Rs&Describing = 1 });
                        gs&fs = 7;
                        # can't think until got
                        return;
                    }
                }
                if (Rs&Describing || ps&stringguess) {
                    !h and debugger
                    delete Rs&Describing;
                    # keep a false %Here
                    $De = Cye(h);
                    ps&stringguess and Des&string = ps&stringguess
                    Des&now = Gtime();
                    Rs&Described = De;
                    Dey&Zave = R;
                    !Des&string and debugger
                }
                $De = Rs&Described;
                if (De) {
                    Dey&Zave and Dey&Zave = me&yfuture,Dey&Zave
                    $DZ = Dey&Zave || R;
                    # we trust the (earlier) neighbour to calc time
                    # then they will look equal
                    DZ == R and DZs&age = Gtime(Des&now)
                    if (DZs&age > 0) {
                        me&mtsc,old,'howold',DZs&age+'s' .sc.fs = 5
                    }
                    $refresh = &{ DZs&Describing = 1 };
                    # can be clicked
                    me.nto(R,old,refresh);
                    # lights up when done
                    De != me&ollbs,R,'Described' and olds&bri = 1.7
                    # do when old
                    DZ == R && DZs&age > 20 and refresh()
                    # < when slep/ball/etc wants to
                }
                Rs&Zave == 'W' and Rs&Unsure = 1
            }
            
            #c look
            $De = Rs&Described || h;
            if (!De) {
                if (!Rs&Here && ps&Gens && !ps&self) {
                    Rs&Wantsto = 'pull';
                    Rs&Amountto ||= 2;
                }
                else {
                    return me&tsc,"Z!h";
                }
            }
            else {
            
            if (!ps&Code) {
                # Code may be Here without string
                Des&string == null and return me&mtsc,en,"De!string",0,'B'
            }
            
            # into time/desire for
            me&rollbs,R,'Settled,Wantsto';
            ly&tree = De;
            ry&tree = P;
            # flop direction of the patch
            me.nto(R,l,&s{ Rs&Wantsto = 'pull' });
            me.nto(R,r,&s{ Rs&Wantsto = 'push' });
            
            # faulter the autocommit
            Rs&Settled != Ps&dige and delete Rs&Settled
            
            # centralised pause
            ps&LetGrow and return gs&fs = 7
            
            # init kinda thing
            if (Des&string == null && Ps&string != null) {
                !ps&Code and throw "init pull !Code"
                hs&string = Ps&string;
                Rs&Whichto = 'pull';
            }
            
            # notice situation
            $Settle = &{
                Rs&Settled = Ps&dige;
                delete Rs&Wantsto;
                delete Rs&Amountto;
                Rs&Whichto ||= 'pull';
                if (Rs&Committing) {
                    delete Rs&Committing;
                    me&mtsc,en,'made-commit',"pushed",'B';
                    Rs&Whichto = 'push';
                }
            };
            # De may change since push
            Rs&Committing && Rs&Committing == Ps&string && Settle()
            # and separately:
            Des&string == Ps&string and Settle()
            else {
                if (Rs&Settled || Qc&el == 9) {
                    # we sync, they follow
                    Rs&Amountto ||= 2;
                    Rs&Wantsto ||= 'push';
                }
                else {
                    # start different or their updates
                    Rs&Amountto = 1;
                    $someSettled = neighbours.filter(n => ns&Settled).length;
                    someSettled and Rs&Wantsto ||= 'push';
                    Rs&Wantsto ||= 'pull';
                }
            }

            if (Rs&Wantsto) {
                Rs&Amountto ||= 1
                Rs&Unsure and Rs&Amountto = 1
            }

            if (!Rs&Whichto || (Rs&Wantsto && Rs&Amountto < 2)) {
                # l/r switch patch direction
                # < parameters, eg:
                #Rs&Unsure and tos&bor = '3px dotted black'
            }
            else {
                $goingto = Rs&Wantsto || Rs&Whichto;
                $redirection = goingto != Rs&Whichto;
                $to = goingto == 'pull' ? l : r;
                $from = to == l ? r : l;
                froms&dis = 0;
                
                Rs&Unsure and tos&bob = '3px dotted black'
                me.nto(R,to,&s{
                    Rs&Unsure = Rs&Unsure ? 0 : 1
                    Rs&Unsure and ~Unsure: R.t
                });
            }

            if (Rs&Whichto) {
                # direction it was going
                $to = Rs&Whichto == 'pull' ? l : r;
                tos&bri = 1.7
            }
            }
                
            #c patch
            if (Rs&Wantsto) {
                Rs&Amountto ||= 1;
                $to = Rs&Wantsto == 'pull' ? l : r;
                tos&sha = '3 3 3 777';

                $from = to == l ? r : l;

                # < patch chunk pluck
                # < commit with message, put somewhere
                #   and other ways to convene to key states
                $pa = coy&can('n','patch');
                pas&dis = 4;
                pas&fs = 14;
                me&walls,pa,'b:2.2h666';
                pas&bgh = '010';
                pas&zi = 30;
                
                if (h) {
                    # < attention upgrades to JRom
                    $c = {t:'Zif',Zif:1,neighbours};
                    c.got = fromy&tree;
                    c.exp = toy&tree;
                    $di = me&Ret,R,c;
                    me&zN,di;
                    me&Ring,di,{und:di,ov:314};
                    me&zuct,pa,di;
                }


                $says = Rs&Wantsto;
                $ma = me&mtsc,en,'make-commit',says,'B';
                $commit = &{
                    if (Rs&Wantsto == 'pull') {
                        pull();
                        Rs&Whichto = 'pull';
                    }
                    else {
                        # awaits ack
                        Rs&Committing and mac&s += '..'; return
                        !Qs&ready && Qc&el != '9' and return me&mtsc,en,'!ready'
                        !Des&string and return me&mtsc,en,'!string'
                        
                        Rs&Committing = Qs&string = hs&string;
                        ts&_ting(Q)
                    }
                };

                if (Rs&Amountto == 1) {
                    # clickable talk
                    mac&s += "?";
                    me.nto(R,ma,&sT{
                        commit();
                        # wakes %ball%Code%Zaving
                        #  and innards (R%Zave)
                        T.wake = p;
                    });
                }
                else {
                    commit();
                }
                
                # remote cell smoodge
                res&po = 2;
                res&left = -2;
                res&pl = 2;
            }
        },'ift,D'],
        #c Zif
        ['Zif','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            s&ma = 0.2;
            s&pa = 0.3;
            s&lh = 1;
            
            $g = Rs&got;
            $x = Rs&exp;
            !gs&string and return me&waits,'g!string'
            !xs&string and return me&waits,'x!string'
            
            $ob =
            n $R.t 13 s:~ %fs:29,lh:0.1
            gs&string == xs&string and return obc&s = '=='
            
            me&rollbs,R,'Digs,Diff,CompN,Comp';
            # < view entirety
            # < switch chunk: word/line
            $c = {chunk:'word',fold:1};
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;
            
            $N = Rs&Diff ||= diff(xs&string||'',gs&string||'',c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }
            me&diffproximate,R;
            
            $p =
            n patch   %max-height:7,over,dis
            ps&z = [...Rs&Comp];
        },'ift,D'],
        
        #c %Evelse, nto
        ['Evelse','291',&acgtRs{
            me&introqua,[R,'A'],{boost:1}
            me&zu,"4s&thecode",4s&thecode;
            
            me&zu,"A",A.4;
            #n Elviso  $s:4s&elvisory %R:ball
        },'ift,D'],
    ] };
    # sets up R to respond with y(r:elC) to clicks on n
    me.nto = &Rny{
        n.y == n and throw "A"
        ns&medo = 'modeen';
        ny&modeening = &sT{
            y (s,T);
            # prefer waking this R to 4c&callback
            T.wake ||= R;
        };
        me.modeenery(R);
    };
    #Fiveplan #c
    
    =editor
        make way into /G/$cat/$way
        organised by /W/$cat of $way+
      will be
        network of %Gens%Codon
      
      monday:
        %ting - place to send/receive string
        < %differ switching up %self and collecting %Here etc?
        < avoid re-%Lines depending on slep,
           or by accounting for all change
      tuesday:
        gitify %Code/%Zave
      wednesday:
        streaming %Zave push/pull
        â†¯ at new/gone \n with !\w
      ðŸ”â†µ
      thursday:
        stop using %boost to %Save
        
      friday:
        %Codin creates %Code, ss&string ||= "# \n"
        < %Zaving 7
        
        < /tmp/ faster (while typing)
         < be sure the codemirror is saved
            as it doesnt &gev while typing
            so we appear from a 5s timer or something,
            check all the %Code)%strings from cm
             ideally elvising that so we can pick up on its looseness
              how surely anyone has said what it is
        
        < /ghost/ slowly
          < compile check etc first
      
      unfolding labby mess, way too many dimensions:
       < redo callback to insides
         modeening that might T.wake=R
         T.wake=modulat might even work,
          since Ry&Displayc&refs has it?
          and it just wants to Cavon
      
       and bring some automation over the top
         < saving its own openness from %Te
         < such that it can be relied upon by others
           who includes it is security over time
           time = distance over the network
      
       < make an alternative openness network
         using s&medo=me.$handler,
          dispatching to JRoms as an entire planet (4s&callback)
       
       #c monday?
       
       < %Search (centralised %tings) delivering updates
        < trusting /digwaypol/ for /way/ and /ghost/ it has
       < slep to scan for changes
        
        %Gens starts from out%ball to have in%ball
         < %ino for in feeds out sans s&z
            is a qua muter situation, as is:
             %Lines encoding customs
             %slep deciding where to crawl
             %Te accepting as 'the story'
         < ghost/wormhole happens when in appears
         < %slep for changes, helps %Lines
         < %autosave/**%Gens every 5s, in:
         < %ting=mem for W in localStorage
        
        %Codon%Code the contained way
         %ting=ghost for string
          < send patches, of lines
        < concat fragments from %Code!%string/*%Code
         < inside way are hash-c markers, etc
            so %Code might not have %string,
             once burst into many somethings
        
        there are many /W/$cat competing the same /G/*/$way
          suppose creating %Code ensures singularity
         < %searchpath should order A.4s to talk to about things
        
        room for a tool for composing %slep schema
         < a wand shedding glow
           pointing for KnowC
           which should be from /W/
           see time above
        
        slep wanting to be there for most piles
         generating a change awareness (wai)
          we can otherwise effect
           to drive change from/to A something
    
        
      thence
        T - phenomenate when going to an aboveness that may not be awake
        G - intelligensiata
        the whole vs. a part
        new git repo, just /G/ and /W/
          ignore, slowly import /wormhole/
        
      new server
      # generated by `./spot.pl StyleAgent`
      # run `./serve.pl`
        /way/ - compiled code
          sees /G/$se/$way
        /ghost/ - source code
          for /G/$se/$way
          API like /W/
          maintains dige in wormhole/digway/$way
          notifies /digwaypoll/
           < wait 3ms to scoop any batched changes?
            < they come through one %Sock frame
        /digwaypoll/ - code change socket
          watching wormhole/digway/$way
        
        /W/
          futuristics
          
        /js/ GONE temporarily?
          needs Beach, etc.
          just host /js/Hunt.js
          comes back when $W has .js file?
      
    =cut
    
    # etc
    
StyleAgent: | # compile serve.pl from Wud + JaBabz
    my $way = sub {
        my $t = shift;
        G.way.>$t || die "No $t";
    };
    my $bab = sub {
        my $s = shift;
        my $C = {t=>'somba',y=>{},c=>{s=>$s}};
        G&CoBabbler;
        C.c.s
    };
    
    my $wab;$wab = sub {
        my $t = shift;
        my $w = $way->($t);
        $t eq 'Wud' && $w =~ s/# insert JaBabz here/$way->('JaBabz')/e;
        $w =~ s/Rw\ JaBabz \$C;/JaBabz(\$C);/sg;
        $bab->($w);
    };
    
    my $f = "serve\.pl";
    my $perl = $wab->('Wud');
    write_file $f, $perl;
    `chmod +x $f`;
    sayre "Done";
Wud: | # restacked Wed server
    #!/usr/bin/perl
    use strict;
    use warnings;
    no warnings qw(uninitialized redefine);
    use FindBin qw($Bin);
    use lib "$Bin/othlia";
    use lib "$Bin/slib";
    use G;
    sub dige { slm(12, Digest::SHA::sha256_hex( encode_utf8(shift) ) ) };
    my ($A,$C,$G,$T);
    my $ar = {};
    
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    # divert mojo log statements from our err channel
    #app->log->path((Gc&ipd || Gc&dir)."/mojo\.log")
    #    if Gc&dir || Gc&ipd;
    
    our $listen = "http://localhost:1422";
    sub starts {
        1 && saybl "Starting     listens: $listen";
        1 && saygr "Appstart: ". app->start('daemon', '--listen' => "$listen");
    }
    sub JaBabz {
        my $C = shift;
        no warnings qw(uninitialized redefine);
        # insert JaBabz here
    }
    
    #c /digwaypoll/ notifier, see 281 Sevo
    my $poll = {tx=>[],ways=>{}};
    poll.wayt = {}; # pi/name -> pi-name
    poll.wayd = {}; # pi-name -> s&dige
    poll.doing = &o{
        return if $o && poll.one && $o ne poll.one;
        my @ways;
        each pi poll.ways {
            my $t = $p;
            $t = poll.wayt.>$p ||= do { $t =~ s/\W/-/sg; $t };
            my $dig = readlink "wormhole/digway/$t";
            my $was = poll.wayd.>$t;
            next if $was && $dig eq $was;
            poll.wayd.>$t = $dig;
            $was = 'any';
            $was && push @ways,
                $p.'%dige:'.$dig
        }
        
        if (@ways) {
            # send many d=0 Lines as one message,
            # so receiver can react immediately
            my $s = join"",map{ $_ ."\n" }@ways;
            for my $tx (@{poll.tx}) {
                $tx->send($s);
            }
        }
        
        Mojo::IOLoop->timer(0.3,&{ poll.doing(poll.one = rand()) });
    };
    websocket '/digwaypoll' => &s{
        my $tx = $s->tx;
        poll.doing();
        1 && sayyl "Got digwaypolling";
        
        # complete picture (t/dige) at new listeners
        poll.wayd = {};
        push @{poll.tx}, $tx;
        
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        
        $s->on(message => &M,m{ #}
            die "Not wordy: $m" unless $m =~ /^([\w\-\/]+)(%\w+.*)?$/;
            tx.ways.>$1 ++ || poll.ways.>$1 ++
        });
        
        $s->on(finish => &M,code,reason{
            @{poll.tx} = grep { $_ ne $tx } @{poll.tx};
            each ti tx.ways {
                -- poll.ways.>$t && next;
                delete poll.ways.>$t;
                $t = delete poll.wayt.>$t;
                delete poll.wayd.>$t;
            }
            #1 && sayre "digwaypoll Gone: $addr $code $reason";
        });
    };
    
    #c /W/
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.Wache ||= {};
        
        # read t, write if s
        # all there
        $t = "W/$t";
        # char safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1 etc
        $t =~ s/\/(\d)$//;
        my $species = $1 || '1';
        my $f = "$t/$species";
        
        # returns json:
        my $re = {ok=>0};
        my $nos = 0;
        
        
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($pa && $pa ne $cache.>$f ) {
                re.er = 'not ffwd';
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # the .5 may be in the same request
                my $five = $c->param('fivestring');
                if ($five) {
                    my $ff = "$t/5";
                    write_file("$ff\.1",encode_utf8($five));
                    `mv $ff\.1 $ff`;
                }
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $nos = 1;
            }
        }
        else {
            if (-f $f) {
                $s = decode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            # it should have a dig
            my $dig = slm(12,
                $f =~ m{^W/spot/} ? dig($s)
                :
                dige($s)
            );
            $cache->{$f} = $dig;
            re.dige = $dig;
            re.s = $s;
            # if they know its hash, assume they don't need the string again
            if (my $ha = $c->param('have')) {
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            # or if it was a write
            delete re.s if $nos;
        }
        $c->render(text=>sjson($re));
    };
    
    #c /ghost/
    any '/ghost/*w' => &c{
        my $t = $c->param('w');
        # / in t not meaning directory
        (my $st = $t) =~ s/\W+/-/g;
        my $se = $c->param('se') || '*';
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.ghostache ||= {};
        my @opt = glob "G/$se/$st";
        die "multiple @opt" if @opt > 1;
        my $f = $opt[0] || '';
        my ($cat) = $f =~ /^G\/([^\/]+)\//;
        # < avoid some disking if $have
        my $wig = "wormhole/digway/$st";
        my $digway = readlink($wig);
        
        # returns json:
        my $re = {ok=>0};
        my $was_write = 0;
        
        # hasghost
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($se eq '*') {
                re.er = "!se param: writing G/\$se/\$t";
                $s = '';
            }
            elsif ($pa && $pa ne $cache.>$f ) {
                if (!$cache.>$f ) {
                    re.er = "lookup first";
                    # < or trust digway?
                }
                else {
                    re.er = 'not ffwd';
                }
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                -f $f && `rm $f`;
                re.ok = 'deleted';
            }
            else {
                # non-name is directory
                (my $dir = $f) =~ s/\/[^\/]+$//;
                -d $dir || `mkdir -p $dir`;
                my $new = !-f $f;
                #$s = "$s\n" if $s !~ /\n$/;
                
                write_file("$f\.1",encode_utf8($s));
                `mv $f\.1 $f`;
                
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $was_write = 1;
            }
        }
        else {
            if ($f && -f $f) {
                $s = decode_utf8(read_file($f));
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            my $dig = dige($s);
            $cache->{$f} = $dig;
            if ($dig ne $digway) {
                -l $wig && `unlink $wig`;
                `ln -s $dig $wig`;
            }
            re.dige = $dig;
            die "no cat: $f" if !$cat;
            re.se = $cat;# if $cat ne $se;
            re.s = $s;
            # they know string if:
            if (my $ha = $c->param('have')) {
                # they know its hash
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
            if ($was_write) {
                # they just sent it
                delete re.s;
                # speed /digwaypol/
                poll.doing() if poll.ways && poll.ways.>$t;
            }
            
        }
        $c->render(text=>sjson($re));
    };
    
    #c /way/ 4s&waythe way
    # < Accept headers to get the various translations
    get '/way/*way' => &c{
        my $t = $c->param('way');
        $t =~ s/\W+/-/g;
        my $w;
        for ('G/*','wormhole/way') {
            my @opt = glob "$_/$t";
            my $f = shift @opt;
            next if !$f;
            $w = {t=>$t,y=>{}};
            wc&s = decode_utf8(read_file($f));
            ws&dige = slm(12, dig wc&s);
            ws&of = 'w';
            last
        }
        $w || return $c->reply->not_found;
        $c->res->headers->append(Dige => ws&dige);
        
        # < JaBabz is final
        my $babv = readlink("wormhole/digway/JaBabz");
        a&wayjs = {} if a&babv ne $babv;
        a&babv = $babv;
        
        my $have = $c->param('have');
        if ($have && a&wayjs.>w.t.>ws&dige &&
            $have eq ws&dige ) {
            return $c->render(text => '')
        }
        
        
        my $s = a&wayjs.>w.t.>ws&dige ||= do {
            my $C = $w;
            Rw JaBabz $C;
            wc&s
        };
        #$s =~ /^(.+?m\.replace(.+?))$/sgm && sayyl "Fuo:\n $1\n\n";
        $c->render(text => $s);
    };
    
    starts();

