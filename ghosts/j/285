Fividy: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    window.reverse = &s{ return s.slice().reverse() };

    # hash stash
    window.ah = &th{
        !isC(t) and throw "!C"
        $M = [... arguments].slice(2);
        $h = t.sc[h] ||= {};
        while (M.length) {
            $k = M.shift();
            M.length > 1 and h = h[k] ||= {}
            else {
                h[k] = M.shift()
            }
        }
    };

    # array match
    # if M, returns [not], puts M[matched]
    #  eg N = arou(N,'acty',actyN) separates actyN from N
    # else, returns [matched]
    window.arou = &NyM{
        $matched = M || [];
        if (isst(y)) {
            $k = y;
            y = &n{ return n.sc[k] };
            if (k[0] == '!') {
                $cb = y;
                k = k.substr(1);
                y = &s{ return !cb(s) }
            }
        }
        if (M && !isar(M)) {
            # for an Nx.$k=N tape splitter
            !k and throw "dunno Nx k",M
            matched = M[k] ||= []
        }
        $not = [];
        each in N {
            y(n) ? matched.push(n) : not.push(n)
        }
        return M ? not : matched
    };
    # match N into one of several groups
    window.aroh = &Nc{
        c ||= {};
        isst(c) and c = G&peel,c
        $h = {};
        each kn c {
            # matcher n is &s{} or a scgk
            n == '1' and n = k
            $M = [];
            N = arou(N,k,M);
            h[k] = M
        }
        h.N = N;
        return h
    }
    
    #c C-ish
    # < G&C, babz: = C yadda @3
    #   and to parse args for eg opeolo
    #   has a lot to do with:
    window.isnu = &s{ return typeof s == 'number' };
    window.isfu = &s{ return typeof s == 'function' };
    window.isst = &s{ return typeof s == 'string' };
    window.isar = &s{ return s && s.constructor == Array };
    window.isha = &s{ return s && typeof s == 'object' && !isC(s) };
    window.isob = &s{ return s && typeof s == 'object' };
    window.Cye = &s{
        s = G&Cye,s;
        s.y = {cv:s.y.cv};
        delete ss&z;
        return s
    };
    window.sca = &s{
        s *= 1;
        while (s >= 1) { s = s / 10 }
        return s;
    };

    # read spacey t, or insert C = y()
    window.fio = &qty{
        !isC(q) and throw "NotC"
        qs&z ||= [];
        qy&tw ||= {};
        typeof t == 'object' and y = t; t = null
        y == '9' and $deletes = 1; y = null
        $ar = y && y.constructor == Array;
        y && t == null and t = ar ? y [0] : y.t
        y != null && y == 0 and $readonly = 1
        
        $s = qy&tw[t];
        # allow removing from qs&z
        $si = s && qs&z.indexOf(s);
        si < 0 and s = null
        if (deletes) {
            si < 0 and return
            qs&z.splice(si,1);
            delete qy&tw[t];
            return
        }
        if (!s && !readonly) {
            s = y ? ar ? G&Cye,y : y : G&Cye,[t,1];
            qs&z.push(s);
            qy&tw[t] = s;
        }
        s and ss&z ||= [];
        return s
    };
    
    # C usu sort by cv,t
    window.tvsortz = &z{
        z.sort(&ab{
            return (ay&cv||0)*1-(by&cv||0)*1
                || ('' + a.t).localeCompare(b.t)
        });
        return z
    }
    
    
Twoism: | # js the way in
    $ch = &s{
        $("<p>").appendTo(document.body).text(s);
    };
    # load $t.js to C with s&I
    $Cye = &v{
        return     
    };
    $loadI = &t{
        $tocfunc = t+'_current';
        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
        $toc = window[tocfunc]();
        
        $W = {t:t, y:{cv:0.1}, c:{}, sc:{}};
        Ws&I = {};
        
        $D;
        each iv toc {
            $ind = v.shift();
            $C = {t:v[0], y:{cv:v[1]}, c:v[2], sc:v[3]};
            if (ind == '') {
                D = Ws&I[C.t] = C;
                D.y.tw = {};
                D.y.tv = {};
                Ds&z ||= [];
            }
            else if (ind == '  ') {
                D.t != s&js and throw "Csjs not last D", C, D;
                c&code = window[s&name];
                typeof c&code != 'function' and throw "Cccode not function", C, D;
                # grow I
                D.y.tv[C.t] ||= {};
                D.y.tv[C.t][C.y.cv] = C;
                D.y.tw[C.t] = C;
                $l = Ds&z.slice(-1);
                l[0] and l[0].y.next = C;
                Ds&z.push(C);
                D.y.in ||= C;
                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                    G[C.t] = c&code;
                }
            }
            else {
                throw "deep C: "+t, v
            }
        }
        return W
    };
    ch("Correct");
    
    window.A = {};
    $C = {};
    $G = {};
    $T = {};
    
    $M = 'Hunt'.split(' ').map(t => loadI(t));
    $W = M[0];
    A.I = Ws&I;
    
    
    !window.ki and G&waylay,'NutGravy';

    $io = G&way,'iooia';
    io.iz = 1;
    $me = c&me ||= {};
    me.Ja = {}; # pins
    me.H = &acgttycs{
        typeof t == 'string' and t = ['i',t]
        typeof y == 'object' and c = {args:y}
        c ||= {};
        $sc = s || {};
        c.push and throw "this thing wants to be this thing"
        c.pull and throw "this thing is wanted"
        # < pull also acquired from looking
        
    };
    me.timestamp = &{ return(new Date).toISOString() };
    G&way,'Soogle',{},'noop';
    G&way,'Coffle',{},'noop';
    G&way,'Packle',{},'noop';
    G&way,'Foogla',{},'noop';
    G&way,'Fividy',{},'noop';
    #$w = G&t,'w','Soogle';
    #debugger;
    
    
        A&me = me;
        A.1 = A.3 = A.4 = A;
        
    # lots from somewheres...
    $C = G&Cye,['Elevat',2];
    ch("Correcto");
    
    

