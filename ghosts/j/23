NutJay: | # persistent thing, all usual
    # fling thing
    n NutJayTo
    # thing sequencing things
    n NutJaying
    # thing consciousness
    n NutMind
NutJayTo: |
    u j
    n \'of:eye'
    # quank the repeating part
    
    # TES make the ground/root the same thing: A.r
    
    # each s/page/C context/sphere/drain it has,
    # has an up to dateness, where the other language joins on,
    #   like ws, can push/want updates through
    #   when drain C's yA's a&v (J-ish version) or A&sip changes
    #   or the C could be getting checked/o'd more often the usual
    #   
    #   looking at drain things' A's ip? or its A.c.v-ersion?
    #   or A.4+1's ip being more recent?
    #   want to wind up any A in drain <= 6?
    #   the s's M's As and Cs, the sources of what's on the page, change
    #   so there can be a way to encode a s's source/ingredients as an s
    #  and vaguely the last ip number of A.4+1 being > that remembered
    #    that remembererd ~= encoded as universal view of the A holding stuff
    #   means 
    # the ipi of the A.4+1 on the  
    
    # Js&N - pulls A, then usually oscillates (J8)
    #   depending on the other
    #  J8 then notices Cs&J who Js&N, makes plan to go get it
    #  J8 also notices u and other import/export desire. (W/5)
    
    # s&v will be a version/timestamp
    # t will be Where it is
    # cv some kind of trust/doneness feng shui,
    #   likely to separate many of the same J
    # c/sc ongoing house of definition,
    # the pin/J6/doming, is usually one way:
    #  which is to draw the usual picture,
    #  and define elvising handlers
    #  so as to create services and lingo/policy for others
    #  and physics for interaction, connecting inside with outside
    
    
    # sproutling
    # J, they inherit like a stretchier A
    J: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        $V = A;
        $A = J||A;
        $J = G&Aye,s;
        # on a chain
        J.2 = J.1;
        J.1 = J;
        # pulls A
        Js&N ||= [];
        return J
    
    # contraptions of J
    
    # J's support crew, secondary colours
    # who keep normal
    # may be n'd and s'd
    sJ: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        J.sc[s] and return J.sc[s];
        $j = G&J,J,s;
        J.sc[s] = j;
        j.I = A.4.I;
        return j
    
    #c J's C
    
    # wave of thing, adds to ground
    # returns the A if you give it an ov
    # < sometimes given [C,C,C]?
    # < wrap with async avoider?
    n: %acgt:s ov
        typeof s != 'object' and throw "weird n", s;
        
        #G&clusp;
        
        $C = G&Cye,s;
        $Y = G&Aye,'n',0,C;
        
        try {
            G&thro,Y,ov||8
        }
        catch (e) {
            $async = (e.message || e).match(/^async/);
            $title = "via "+A.1.t+" e "+C.t;
            # top level continues
            !Yc&T.oT and 4s&N.push(Y);
            # throws if not supposed to throw (T.sync)
            #  meaning this must continue, not stuff inside...
            !async || Yc&T.sync and throw title+": "+e
            ~>9 nvoidsync: title
            
            # throw means pin must redo to retrigger this n
            throw e;
            # J7 could find ground yAcv < 8
        }
        
        return ov ? Y : C
    
    # ephemeral/traceless n [C],[s]
    #   s and c&e = s (act)
    # send stuff over there, without:
    #   clusping (resolving mind)
    #   grounding (giving C to s)
    #   asyncing (over-n uninterupted)
    # if C is non-C (not [tycsc] or {tycsc}) it A.c, and C = e
    # you can also spec A.c with non-C for C, C then = e
    
    # < you could also n elvising to reliabilitate it
    #   < osc plays tcp with it
    
    # babs about how to divide sweet notation into two flat C
    # e other: thing: what          -> G&e,['other'],['thing','','what']
    #  then as n [other=>W=>{e:['thing','','what']}]
    
    # e {cstuff:4} this: stiil   -> G&e,{nAcstuff:4},['this','','stiil']
    # so can not put 
    # e C, this: -pi24             C, ['this',0.24,{pi:'this'}]
    # shows C this
    
    #  as an intention for process it can be slowed down when n same
    #  page for every elvising going on wanted,
    #  the script of its activity zoomintoable
    # the sudden datatype
    e: %acgt:c s
        !c || !s and throw "e carefully"
        C = c;
        c = {};
        C.constructor == Array and C = G&Cye,C
        s.constructor == Array and s = G&Cye,s
        # if first C is {} but not C it is A.c spec,
        # and second becomes first: like n with A.c spec
        !(C.y && C.c && C.sc) and c = C; C = s; s = null;
        !C and throw "No C spec"
        
        s and c&e = s
        c.nogro = 1;
        c.s = C;
        
        # < should same say function as J creation
        $et = ''
        s and et = s.t
        ~e: C.t, et
        
        $Y = G&Aye,'n',0,c;
        try {
            G&thro,Y,c.ov||8
        }
        catch (e) {
            $async = (e.message || e).match(/^async/);
            $title = "via "+A.1.t+" e "+C.t;
            !async || Yc&T.sync and throw title+": "+e
            ~>9 evoidsync: title
            # give async e to 4, as their J may not be Jtv'd yet
            4s&N.push(Y);
        }
        Yc&s

    # the usual many things accumulate in $M=[]
    # things given by the way
    # lives on 9c&M, gets n'd end of 6
    # < sometimes given [C,C,C]?
    # < the 9 must n its c&M, while asyncing resumed from J7
    m: %acgt:M s
        typeof s != 'object' and throw "weird M s"+s
        typeof M != 'object' and throw "weird M"+M
        #G&clusp;
        C = G&Cye,s;
        M.push(C);
        return C

    # u like n takes C, but more like m saves it up until:
    # G&clusp causes it to be made into I for A.1
    #   can do an A:u if mix is simple/found enough
    #  G&sJ makes A.I=Normal that hangs out in 1s&u
    # u '' # resets to normal
    u:
        $u = G&sJ,'u';
        uc&N ||= [];
        uc&N.push(s);
        s.constructor == Array && s[0] == '' and G&clusp
    #]
    
    # S marks sections of pin/phase of consciousness
    # likely to mark out domes - might use goto
    # placed after handlers are set up and
    #  before handled stuff is rendered as the J
    S:
        G&clusp;
        A.e && G&thro,A.e,6;
NutJaying: | # A sequences J
    u jc
    n \'of:n'
    
    # A.ground? A.place? ||= 1s&place ||= G&sJ,'place'
    # haul long blogs into long J with many bits of place
    # or page or ...
    # they want to commit or abort, be histree for o
    # and be a collection of in-progress C for slow/scattery J
    n 1: %any
        A.n = A;
        C.y.A ||= A;
        C.y.A != A and throw "wild C: ", C
        
        A&nogro and return
        $g = A.ground;
        !g and return;
        gs&z ||= [];
        gs&z.push(C);
        #~grounds: A.1.t, C.t
    
    # various dynamics to the same basic particle
    pi 12:
        !s and throw "Give pi: ",C;
        c&J = "pi/"+s;
        A&way = 'way';
    
    # just looking for W, maybe retrieve static?
    # < using T.Z somehow to say jump to 8 after 2,
    #   might be useful for always tripping trips
    V 12:
        c&W = s;
        A&twotoeight = 1;
    
    # networkily named thing
    W 12:
        !s || s == '1' and s = c&W = C.t;
        typeof s != 'string' and throw 'ref cW', C
        !s and throw 'non t W', C;
        c&J = s;
        s&W = s;
        A&Jup = A.4;
        A&Jcv = 0.1;
    
    # look it up
    #   the s&J may already be there
    #   the A&Jup is A.1 (becomes A.2) has s&Jtv
    #    unless W, when its 4
    #
    #   the in-T knows the out-T
    #    < this auto when the A.t exists already (A[A.t])
    #      and calling it T.nT etc? if useful?
    #    might become several different T.things, which are
    #    lingo network receivers on other objects in the process
    #    T is a space to make marks
    
    # J encode Ï€ 
    # previous J is A.2, may differ from creator "above" J in J.2
    #  make interesting maps of things tunneling to others
    # esp in W-W situ, their J.2 is A.4/A&Jup
    #  blab channels
    #   !A&nogro && sayyl "J ! C.t".(c&pi && " C.y.cv -".c&pi);
    # 1c&s = C means the particle (J) holds passing wave of culture (C)
    #  what it will be already is interesting
    #   its C.y.A may still be doing,  be many of the self,
    #   when doing small things on yourself, while
    #   doings big things on yourself, so group what to osc so
    #   bigger bits sort themselves out later.
    #   have a churn/sc energy measure in 6!
    # also with the T ^
    #  there's some boundary effect to be pleased out of it
    J 13:
        $upn = A.n.up.n;
        upn && upn.c.T and T.oT = upn.c.T;
        
        s&J and return;
        
        A&Jup ||= A.1;
        A&Jcv ||= C.y.cv;
        
        $J
        if (!A&nomem) {
            # or G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv
            # and so A&Jups&Jtv babs to check each non-nk piece like so:
            $Jtv = A&Jup && A&Jup.sc.Jtv;
            if (Jtv && Jtv[C.t] && Jtv[C.t][A&Jcv])
                J = Jtv[C.t][A&Jcv]
        }
        J and s&J = J;
        
        if (A&twotoeight) {
            T.oT.op = J && Js&s && Js&s.sc.top;
            return T.not = 1;
        }
        
        if (!s&J) {
            s&J = G&J,A&Jup,C.t;
        }
        A.2 = A.1;
        A.1 = s&J;
        c&W and A.3 = s&J.3 = s&J;
        1c&s = C;
        1c&T = T;
    
    
    pi 3:
        s&pi = s;
        1c&d = 2c&d ? 2c&d + 1 : 1;
    
    # W 31 trips
    # W 31 typed - notes W-W connections
    # W 32 Static, if bay/sac/$W forces c&pretend = Beached
    # W 34 thawJ, operates c&pretend
    # e 36 tugs A=E for c&e
    
    #c Jaying J/W/pi universal awakeness hemisphere
    # < doing some W bleed/wander tracking if !sJ
    #   plenty of sW get chewed in the process of displaying W
    # humming - sleepology - osc exports that door us here
    # outside the fully self/u mind
    # can see network protocols of elvis
    # A&E would know if it wants to go in
    # which page we're working on?
    
    0 &&
    J 4:
        my $v = 1s&Tv; # inner surf attracto
        my $ha = 1s&tv; # things
        
        Rw Js&amb $ha $v if !c&e && 1s&amb;
        
        # T wants ha or v wants T (by now, etc)
    
    # xoJ 44 - 1s&xo checks way, attracted by 3Cc&forxo, feeds A&want
    #   forxo given by Matu dispatched stuff
    
    
    # J 45 - A&want calculated
    
    # 5 ^ grinds desires into mode of go
    # may not do the whole pin, G&o inputs
    
    # visit the many domes of this J
    # where we write pages of stuff
    # they should write A&pin and A&page to direct this A
    # a dome is the life of a page.
    # we are all encompassing by default.
    # use T.nose = 6 to T.N = 6
    J 6:
        T.nose and return ~knows: C.t
        
        A&pin ||= c&pin || c&J || s&J.t;
        A&page ||= '';
        
        # be Normal for new J, or for some dome?
        A.I = A.4.I;
        
        # ground and root could be the same thing
        # as long as s knows 9sJ is not foreign
        # nice having yourself
        1s&grounds ||= {};
        1s&grounds[A&page] = A.ground = G&Cye,[A&page,1,{},{J:s&J}];
        A.1[2].c.imping and 1c&imping++ // reset lv
        
        $ise = '';
        c&e and ise = " (e:"+c&e.t+")";
        $de = "("+A&pin+")"+ise;
        A.1.t == A&pin and de = ise
        if (!1s&brains) {
            ~>2 J: A.1.t, de
        }
        else {
            ~>6 J: A.1.t, de
        }
        
        $y = {cv:0.9};
        $c = y.c = {root:1};
        $sc = y.sc = {};
        $r = 1s&root = G&Cye,[A.1.t,y,c,sc];
        G&Aye,'n',0,r;
        # begin 9 n so it hangs on to Normal A.I
        # will be last unless we can nonrethro its 1?
        $ar = c&ar || {};
        $s = ar.s = c&s;
        $M = c.M = ar.M = [];
        ar.y = y;
        ar.J = A.1;
        # if we make an Error can we rethrow it keeping its origin?
        # catch use case:
        #   the throw from G&TuneTimeMachine wants to abort pin/doming,
        #   put this A:n into 1s&N, but A.1 isn't yet in A.4...
        #   it wants to T.nose=6 with instant bail out of the pin...
        # so lets share the Jup stasher
        A&Jupstash = &{
            !A&Jup and throw "Can't save self", A
            A&Jup.sc.Jtv ||= {};
            A&Jup.sc.Jtv[C.t] ||= {};
            A&Jup.sc.Jtv[C.t][A&Jcv] = s&J;
        };
        
        #if (G&t,'i',A&pin ) { # a sub? G&h,A&pin,M }
        G&way,A&pin,ar;
        
        T.nose and return;
        
        A.1[2].c.imping and y.imp = 1
        y.imp and 1c&imping = 1; delete y.imp;
        
        !M.length and delete c.M
        
        G&thro,r,8;
    # inside ^
    # spread out as many things want space resolved in waves
    # cursoring here because n's don't want to be 8ed as siblings catch up?
    #   like A:u's do
    #  so we can go in lots of little steps
    #     they could renegotiate space over time that way tho
    M 2:
        !c&M.length and delete c&M; return
        # cursor to thro, give them yA
        !A&iM and a&iM = 0; c&M.map(&n{ G&Aye,'n',0,n });
        A&tow = &ov{
            while (c&M[A&iM]) {
                $n = c&M[A&iM];
                ~>3 catchuppy: A.1.t, n.t, Y.cv, ov
                G&thro,Y,ov;
                # advance to next n if that worked
                A&iM++;
                # fail/async/retry if Y.cv < ov?
                #  doesn't really mean anything for n?
            }
            # still here? 
            A&iM = 0
        };
        # async happens
        A&tow(8);
    
    
    #c join moment to moment
    J 7:
        # 8 up Js&root, has yA=n, has c&M full of n things never to repeat a step
        G&thro,1s&root,8;
        # also anything looking behind
        grounda&z and grounda&z.map(&Y{ Y.cv < 0.8 && G&thro,Y,8 });
        
        # keep pulling on groundA&
        # say domes are finished (A.ground remaining will do)
        # an empty-ish step here so s can go async and not redo the 6
        if (T.nose != '1') {
            A&Jupstash and A&Jupstash();
            delete A&Jupstash;
        }
        
    # summarise moment, suggest ...
    # J leaves T.op just outside
    # < sJ or cJ should do this
    J 8:
        # T.N sets cv=6 and queues A in 1s&N, which 4 finds via Jtv
        T.nose == '6' and delete T.nose; return T.N = 6;
        T.nose == '2' and T.not = 1
        T.nose == '7' and delete T.nose
        T.nose and return ~knows: C.t
        
        G&s;
        
        # acgt/sMJ/etc hook protocols, and where they go?
        //Rw $_ - $J for @{A&wayght||[]};
        //$_->($J) for @{A&codeght||[]};
        
        T.oT && 1s&s and T.oT.op = 1s&s.sc.top;
    
    sweet_music 8: %any
        # has something to do with comp-letion
    
    # < do til 9?
    
NutMind: | # do as, all difference
    u j
    n \'of:eye'
    
    # see JayTo for G&u enterer
    # this is about the moment we realise our mind together
    #  anything needing mind does a G&clusp whenever, must be async
    # a mix of Normal with whatever may be entered
    
    # call our mind together
    #   contained by A:clusping doing:
    #     A:u for us&minds, doing A:u' for 4s&mind
    # 
    # the two levels of A:u both A.u=A themselves,
    # the W waketion/searchpath should be more relaxed when only in A.u
    #   but should wake up if we want to fork it...
    #    
    # A:u mixes I from the A:u's, without Jing if possible
    #   the A:u's c&js method implants <script> tags,
    #   < W listening to lv would be better,
    #     but then how to hold the code so onerror can see the source?
    # < lots of I.i things only being on 5 so this has less to chew
    # < knowing I.i never needs to know order/y.next... unless stored
    clusp:
        !4s&NormalI and return
        
        # a u still, could lead to not picking it up when elvising?
        1s&u && 1s&u.c.N && 1s&u.c.N.length == 0 and return
        
        $u = G&sJ,'u';
        uc&is = 'mind';
        $J = A.1;
        $I;
        
        $A = G&Aye,'clusping',0;
        A.1 = u;
        A.2 = J;
        
        $N = 1c&N || [];
        # squash the [''], from: u ''
        G&datam,N,"[['']]" and N = [];
        
        1c&N = [];
        
        if (N.length) {
            # local A.trip, A&trip;
            # anyway, check form and name the wave of u
            
            # always assumed to be difference from Normal
            # should be able to get it to wake by s&v++ through 4s&mind.Normal
            # it (A:u' for Normal) would have a lot of a&N
            $Normal = G&Cye,['Normal',1,{I:4s&NormalI}];
            N.unshift(Normal);
            
            $NisWs = 1;
            $con = [];
            each in N {
                n.constructor == Object and con.push(n.t); continue
                G&datam,n,"['*']" and con.push(n[0]); continue
                NisWs = 0;
            }
            !NisWs and throw "Complicated u Cs: ", s
            $uname = a&uname = con.join(',');

            # A:u resyncs
            1s&minds ||= {};
            $newuname = !1s&minds[uname];
            $Y = 1s&minds[uname];
            
            if (Y) {
                # A:u comes back to itself
                # u 8 checks use-by dates of u', which TN=3 if check needed
                #   means it does 3 in this thro,
                #   and come out wanting to go async,
                G&thro,Y,8;
            }
            else {
                $C = G&Cye,[uname,'',{N:N}];
                Y = G&Aye,'u',8,{s:C};
            }
            
            # shelve
            1s&minds[uname] = Y;
            
            # wake us
            Ys&N ||= [];
            Ys&N.push(A);
            
            Y.cv < 0.8 and throw "async clusp: "+Yc&s.t
            
            !Ys&I and throw "No I back", uname, Y
            newuname and ~>5 u!: uname
            I = Ys&I;
        }
        else {
            # clone I?
            # A:u anyway so everything can have depends on Normal?
            I = 4s&NormalI;
        };
        
        J.I = I;
        
        # get this A:n new mind for the next step
        # (seek=0 redoes this step, seek=3 does 3 onward, etc)
        T.seek = '';
    
    # how will this go async? be an A:n of the u with page/uname?
    # an A:n s&N of the clusping its holding up,
    #   to be chased like A:u should?
    0 &&
    for_N_with_J:
        # immitate a J6
        1s&grounds ||= [];
        1s&grounds[uname] = A.ground = G&Cye,[uname=>1=>{},{J=>A.1}];
        1s&root = G&Cye,[uname=>9=>{root=>1}];
        G&A,'n',8,{s:1s&root};
        # feeding in NormalC, has sJsI, needs only a little n
        !4s&NormalC and throw "no 4sNormalC";
        G&A:'n',1,{s:G&Cye,4s&NormalC };
        # entered stuff
        each iu N {
            G&A:'n',8,{s:G&Cye,u };
        }
        $s = G&s;
        !ss&I and throw "No I from ", uname
        a&I = ss&I;
        # and patch through the v etc?
        # the main difference being these things get J'd up in 4,
        # instead of 4s&mind, a type of wormhole scrap to maintain re W news
    #c A:u wave
    u jc
    n \'of:u'
    # 4s&mind[W] = Y has Ys&N += A:clusping
    # should mow/aggregate by A.3 regularly,
    #   also chancing to figure what domes the mind is for?
    
    # u splits many, requests them, they comeback, we unify when all there
    # alternative ways to include mind happens, eg /js/$t
    # as long as it gives the A:u's a&I,
    #   that the Au mixes into its a&I, that the 
    
    #   to go async to collect its mind
    # so the n/J doing the n we wandered wants to go sleepy when
    # that happens, the usual

    # how in-clusp waits will cause all the enclosing
    # control structures (J/pin, each...) to leave with a T.not
    # which thro undoes, 1s&Ning itself into the mix A:u
    u: %any
        A.u = A;
        C.y.A ||= A;
        C.y.A != A and throw "wild C: ", C
    
    # do we already know this A:u, resync that
    # or sprout and tug A:u's
    # tonly is always, until we can do Jing for u
    N 11:
        $N = s;
        # A:u sprouts A:u's
        a&z = [];
        each in N {
            $t;
            if (n.constructor == Object) {
                t = n.t;
            }
            else {
                # just a t means W    # ]
                !G&datam,n,"['*']" and throw "NonWt u: ",n
                t = n[0];
            }
            # A:u's may resync
            4s&mind ||= [];
            $Y = 4s&mind[t];
            
            if (!Y) {
                $C = G&Cye,n;
                # being stylehut means javascript
                !c&I and c&W = 'javascript';
                Y = G&Aye,'u',2,{s:C};
            }
            
            # shelve
            4s&mind[t] = Y;
            
            # wake us
            Ys&N ||= [];
            Ys&N.push(A);
            
            # them
            a&z.push(Y);
        }
        # proceed to succeed
        A.cv = 0.8;
    
    # A:u checks a&z=[A:u's]
    # u 8 checks itself,
    #  by u' 8 checking themselves
    #   (may go async if their cv drop)
    #  if any change:
    #   u 6 mixing
    #  then u 8 again
    N 8:
        $not
        # check u' 8
        each iY a&z {
            # u' 8 checks the linkage/version on some object
            # winds back to 3 if not
            G&thro,Y,8;
            Y.cv < 0.8 and not = 1;
        }
        if (not) {
            # set u < 8, so above knows just like we know u' < 8
            # so u 8 checks again, u 6 mixes when u' 8
            ~>5 u rewind: C.t
            A.cv = 0.7;
            return T.not = 2;
            # they have 4s&N to bring them back,
            # who must also take care of their a&N,
            # bringing back our A:u,
            # and must also take care of that a&N,
            # bringing back A.cluspings,
            # who without a T is gone past/up to:
            # the A:n that wants to thro some more
        }
        # check versions given by u' to what we last took in
        $have = [];
        each iY a&z {
            $D = Yc&s;
            !Ds&v and throw "u' with no version", D
            have.push(D.t+' '+Ds&v);
        }
        have = have.join(', ');
        
        have != a&have and return T.seek = 6;
        
        #
        # be simple
    #
    #c u 6 mixing
    N 6:
        each iY a&z {
        }
        $have = [];
        # write this next bit:
        # the AC in a&z require a&I & s&v: have.push(C.t+' '+s&v)
        each iY a&z {
            # u' 8 should have I
            !Ys&I and throw "No I back"+4s&ki(Y)
            $D = Yc&s;
            !Ds&v and throw "u' with no version", D
            have.push(D.t+' '+Ds&v);
        }
        have = have.join(', ');
        
        #have == a&have and return
        # mix them all together...
        
        $hup = &s{
            $C = {y:{},c:{},sc:{}};
            C.t = s.t;
            C.y.cv = s.y.cv;
            #$.extend(C.y,s.y);
            $.extend(C.c,s.c);
            $.extend(C.sc,s.sc);
            return C
        };
        $I = {}; # t:I with .y.tv for
        # can be t:cv:I?
        each iY a&z {
            !Ys&I and throw "no I on u': ", Y;
            $C = Yc&s;
            #
            each of,W Ys&I {
                $z = Ws&z;
                !z and throw "No items in We", W
                
                c = I[W.t];
                if (c) {
                    cs&contrib += ','+C.t;
                    cs&many_contrib = 1;
                    W = c;
                }
                else {
                    W = hup(W);
                    Ws&z = [];
                    W.y.tv = {};
                    W.y.tw = {};
                    Ws&contrib = C.t;
                    I[W.t] = W;
                }
                each iD z {
                    # dedup (z and many-z/a&z/u order matters)
                    if (W.y.tv[D.t] && W.y.tv[D.t][D.y.cv]) {
                        $was = W.y.tv[D.t] && W.y.tv[D.t][D.y.cv];
                        $rz = [];
                        each iE Ws&z {
                            E != was and rz.push(E);
                        }
                        Ws&z = rz;
                        W.y.tw[D.t] == was and delete W.y.tw[D.t]
                    }
                    W.y.tv[D.t] ||= {};
                    W.y.tv[D.t][D.y.cv] = D;
                    W.y.tw[D.t] ||= D;
                    Ws&z.push(D);
                }
            }
        }
        
        each of,W I {
            # concatenated zs for this W must be sorted
            if (Ws&many_contrib) {
                delete Ws&many_contrib;
                Ws&z = Ws&z.sort(&a,b{
                    return a.y.cv < b.y.cv ? -1 : a.y.cv > b.y.cv ? 1
                    : a.t < b.t ? -1 : a.t > b.t ? 1
                    : 0
                });
            }
            $la = null;
            each iD Ws&z {
                typeof Dc&code != 'function' and throw "no Dccode", W, D
                if (!la) {
                    W.y.in = D;
                }
                else {
                    la.y.next = D;
                    D.y.prev = la;
                }
                la = D;
            }
        }
        
        a&I = I;
        a&have = have;

        
        #c whatif
        if (Y != A) {
            # here u = Js&u, the u J:
            
            # A:u a&N's the A.clusping waiting on it,
            #  for 4s&N when done
            #     or we could put the A.clusping into us&N
            #      u = A.clusping.1, so
            #       us&Ns&N and 3s&N that 1
            #      which it will see is 
            #   for 4 will rethro A:n from the last W,
            #    with (3s&N) intention to get this one A:n finished
            #     or perhaps a couple of A:n inside of each other
            #     but the thing about A:clusping is casually ignored,
            #     trusting the action to find its way through to that
            #     (and succeed immediately)
            #     
            #    which is a non-pin act, some osc? depends where it is,
            #    if it is FactorEase'd into pin process do that
            #    usually we can static update one thing and see how
            #    it mixes up in osc, eg. things swim,
            #    or it might just change a link
            
            # so A:u know A.clusping to get back to Jaction, once:
            
            # A:u's a&N the A:u waiting on it,
            #  so all those A:u's a&N's of A.clusping's are:
            #   sent to their 1s&N 
            #   or their 3s&N, who will be from 4 cos s&N
            #   then it groups the desires in its 1s&N,
            #   like it's receiving codechange to be with,
            #   and the limb of A:n it converns
            
            # a chunk of this ^ should 
            
            # so the 4s&N reader is wanting grouped to 3-
            # it also picks up on Jtv's 3s&N being there,
            # each A is the last in a chain reaction to resume
            #  eg A:n(W:Typ) > A:clusping
            
            # the A:n can be resync'd?
            # the A:n may have A:other then A:clusping,
            
            
            # and 4s&N A grouped by A.3 can become 3s&N,
            # it is a general pay-attention scheme,
            
            # A:n that W make borders/relationabla,
            #   the thing can be figured/resolved below
            #   and push its content to the yonder A:n,
            #    if they really need it, it may be just a link
            #    or it may require pinning,
            #      since FactorEase connected it into a process that
            #      must then be shunted along
            # the A:n upward should correlate to the
            
        }
    
    #c u' know some meta things,
    # be somewhat collective,
    #  one A:u' may wake up many A:u
    #  4 can A:u' a&v++ when it hears about change,
    #    waking it up on top
    #  A:u' wakes all its A:u,
    #  A:u wakes all its A.cluspings on top
    #  who aggregate into an A:n happening like it did before
    #  but when it his this (A:u, A:u') structure again
    #  everything will be ready
    #  
    # and be known to the meta thing pusher, 4:
    #   those A:u may resync s&M 
    #    (pending A:n that should clusp again)
    #     or restart an A:n with the change as elvis saying "try now"
    # 
    #    by pushing Js&N <- A:u
    #    and 1s
    # < slightly trust that 4 will note W change by:
    #     A:u's Cs&v++, and 1s&N = A
    #     
    #       attracting attention to the A:u's 
    #       which might go up to A:u from A:u's that changed
    #         and ask their 1s&N to A:n to recreate the clusp
    #   like W=javascript can be found in /js/
    # whether it's being updated, or has just updated
    W 12:
        if (s == 'javascript') {
            c&js = C.t
        }
    
    # A:u's check themselves
    W 8:
        $ttl = (Gc&ttl || 5) * 2;
        $ok = a&I
            && s&v == a&v
            && a&now && G&time,a&now,ttl;
        if (ok) {
            A.cv < 0.8 and ~>5 u W: C.t
            return
        }
        T.seek = 3;
    
    # a static A:u', eg Normal is [Normal,'',{I:I}]
    I 8:
        a&I = c&I;
        s&v ||= 3; # bring from hut init/jsung?
        a&v = s&v;
        a&now = G&time;
    #c u' 3 part
    # js3 A gets flock of A.I.? made from a W
    # as <script> via NutServe and the /js/$t-$ver handler 
    #  the G of the webserver and /je/ is Where
    # to mix as in u:
    #   several A get this function to fill their A.I somethings
    #   then they all get osc for a J, or A=u for speed
    #   then this sorting together of A.I can be much faster...
    # < a&async || die?
    # we get it first to read the proper Location
    #   so the <script> tag src is exact
    # < dependency/housing
    # its like a storage location (see 4) that can only thaw the s&I portion of reality
    js 3:
        a&I = {};
        # lookup code, come back:
        $get = '/js/'+C.t;
        # T would put this c&v to wind back from bugs
        c&v and get += '-'+c&v;
        $.ajax(get).done(&s,how,c{
            how != 'success' and throw "Failed request: "+how, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            $W = m[1];
            $ver = m[2];
            
            # others can let us know 
            a&v = s&v = ver;
            a&now = G&time;
            
            $callback = &script,e{
                # check for errors from that script?
                $tocfunc = W+'_'+ver;
                $toc = window[tocfunc]();
                $D;
                for (var k in toc) {
                    $v = toc[k];
                    $ind = v[0];
                    $t = v[1];
                    $cv = v[2];
                    $c = v[3];
                    $sc = v[4];
                    $C = {t:t, y:{cv:cv}, c:c, sc:sc};
                    if (ind == '') {
                        D = a&I[t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        # grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t,v
                    }
                }
                
                A.cv = 0.4;
                a&ready = 1;
            };
            
            $have = $('body script[src="'+src+'"]');
            have.length and return callback();
            G&add_script,src,callback;
        });
        
        a&ready = 0;
        4s&N.push(A);
        T.not = 1;
    
        #   fail, chase W startup
        #   uptodate TN8
        
        # get, callback fills in A&v
            # so the bunch assembles on 1s&minds[uname] = A:u with sc.I
            
            # have to use Js if complex, eg T wants to mess with it
            
            # build out of A:u if possible, or doing a J if any C specifics
            # an A:u 6 unifies A:u 3s, and A:u 7s compile it, 5wichboard 4ces
            # present N into A:u
            # another A.u
            

