NutJay: | # persistent thing, all usual
    n NutC
    n NutJayTo
    n NutJaying
NutJayTo: |
    u j
    n \'of:eye'
    # quank the repeating part
    
    
    # each s/page/C context/sphere/drain it has,
    # has an up to dateness, where the other language joins on,
    #   like ws, can push/want updates through
    #   when drain C's yA's a&v (J-ish version) or A&sip changes
    #   or the C could be getting checked/o'd more often the usual
    #   
    #   looking at drain things' A's ip? or its A.c.v-ersion?
    #   or A.4+1's ip being more recent?
    #   want to wind up any A in drain <= 6?
    #   the s's M's As and Cs, the sources of what's on the page, change
    #   so there can be a way to encode a s's source/ingredients as an s
    #  and vaguely the last ip number of A.4+1 being > that remembered
    #    that remembererd ~= encoded as universal view of the A holding stuff
    #   means 
    # the ipi of the A.4+1 on the  
    
    
    # s&v will be a version/timestamp
    # t will be Where it is
    # cv some kind of trust/doneness feng shui,
    #   likely to separate many of the same J
    # c/sc ongoing house of definition,
    # to be sprung out by pin
    #  which is to draw the usual picture,
    #  and define hooks/elvising,
    #  so as to create services and lingo/policy for other morphologies
    #  and physics for interaction
    
    
    # sproutling
    # J, they inherit like a stretchier A
    J: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        $V = A;
        $A = J||A;
        $J = G&Aye,s;
        // on a chain
        J.2 = J.1;
        J.1 = J;
        // that pulls to Nine, like A
        Js&N ||= [];
        return J
    
    # contraptions of J
    
    # J's support crew, secondary colours
    # who keep normal
    # may be n'd and s'd
    sJ: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        J.sc[s] and return J.sc[s];
        $j = G&J,J,s;
        J.sc[s] = j;
        j.I = A.4.I;
        return j
    
    # adds to ground
    # < sometimes given [C,C,C]?
    n:
        typeof s != 'object' and throw "weird n", s;
        
        //G&clusp;
        
        $C = G&Cye,s;
        G&Aye,'n',8,{s:C};
        return C
    
    # the usual many things accumulate in $M=[]
    # things given by the way
    # lives on 9c&M, gets n'd end of 6
    # < sometimes given [C,C,C]?
    m: %acgt:M s
        typeof s != 'object' and throw "weird m", s
        s.constructor == Array and return $.each(M,&i,v{ G&m,$v })
        
        //G&clusp;
        
        $C = G&Cye,s;
        M.push(C);
        return C

    # u like n takes C, but more like m saves it up until:
    # G&clusp causes it to be made into I for A.1
    #   can do an A:u if mix is simple/found enough
    #  G&sJ makes A.I=Normal that hangs out in 1s&u
    # u '' # resets to normal
    u:
        $u = G&sJ,'u';
        uc&N ||= [];
        uc&N.push(s);
        s.constructor == Array && s[0] == '' and G&clusp
    
NutMind: | # do as
    u j
    n \'of:eye'
    
    # see JayTo for G&u enterer
    # this is about the moment we realise our mind together
    #  anything needing mind does a G&clusp whenever, must be async
    # a mix of Normal with whatever may be entered
    
    # call our mind together
    #   contained by A:clusping doing:
    #     A:u for us&minds, doing A:u' for 4s&mind
    # 
    # the two levels of A:u both A.u=A themselves,
    # the W waketion/searchpath should be more relaxed when only in A.u
    #   but should wake up if we want to fork it...
    #    
    # A:u mixes I from the A:u's, without Jing if possible
    #   the A:u's c&js method implants <script> tags,
    #   < W listening to lv would be better,
    #     but then how to hold the code so onerror can see the source?
    # < lots of I.i things only being on 5 so this has less to chew
    # < knowing I.i never needs to know order/y.next... unless stored
    clusp:
        !4s&NormalI and return
        
        # a u still, could lead to not picking it up when elvising?
        1s&u && 1s&u.c.N && 1s&u.c.N.length == 0 and return
        
        $u = G&sJ,'u';
        uc&is = 'mind';
        $J = A.1;
        $I;
        
        $A = G&Aye,'clusping',0;
        A.1 = u;
        A.2 = J;
        
        $N = 1c&N || [];
        # squash the [''], from: u ''
        G&datam,N,"[['']]" and N = [];
        
        1c&N = [];
        
        if (N.length) {
            # local A.trip, A&trip;
            # anyway, check form and name the wave of u
            
            # always assumed to be difference from Normal
            # should be able to get it to wake by s&v++ through 4s&mind.Normal
            # it (A:u' for Normal) would have a lot of a&N
            $Normal = G&Cye,['Normal',1,{I:4s&NormalI}];
            N.unshift(Normal);
            
            $NisWs = 1;
            $con = [];
            each in N {
                n.constructor == Object and con.push(n.t); continue
                G&datam,n,"['*']" and con.push(n[0]); continue
                NisWs = 0;
            }
            !NisWs and throw "Complicated u Cs: ", s
            $uname = a&uname = con.join(',');

            # A:u resyncs
            1s&minds ||= {};
            $Y = 1s&minds[uname];
            
            if (Y) {
                ~mindre: uname
                # A:u comes back to itself
                # u 8 checks use-by dates of u', which TN=3 if check needed
                #   means it does 3 in this thro,
                #   and come out wanting to go async,
                G&thro,Y,8;
            }
            else {
                $C = G&Cye,[uname,'',{N:N}];
                Y = G&Aye,'u',8,{s:C};
            }
            
            # will be thrown out by now...
            # shelve
            1s&minds[uname] = Y;
            
            # wake us
            Ys&N ||= [];
            Ys&N.push(A);
            
            Y.cv < 0.8 and throw "clusp to sleep "+Y.cv, Y
            
            !Ys&I and throw "No I back", uname, Y
            ~u: A.1.t, uname
            I = Ys&I;
        }
        else {
            ~Normal: A.1.t
            # to include in J, need 4s&NormalC,
            #   which has s&Js&I = NormalI
            I = 4s&NormalI;
        };
        
        J.I = I;
        
        # get this A:n new mind for the next step
        # (seek=0 redoes this step, seek=3 does 3 onward, etc)
        T.seek = '';
    
    # how will this go async? be an A:n of the u with page/uname?
    # an A:n s&N of the clusping its holding up,
    #   to be chased like A:u should?
    0 &&
    for_N_with_J:
        # immitate a J6
        1s&grounds ||= [];
        1s&grounds[uname] = A.ground = G&Cye,[uname=>1=>{},{J=>A.1}];
        1s&root = G&Cye,[uname=>9=>{root=>1}];
        G&A,'n',8,{s:1s&root};
        # feeding in NormalC, has sJsI, needs only a little n
        !4s&NormalC and throw "no 4sNormalC";
        G&A:'n',1,{s:G&Cye,4s&NormalC };
        # entered stuff
        each iu N {
            G&A:'n',8,{s:G&Cye,u };
        }
        $s = G&s;
        !ss&I and throw "No I from ", uname
        a&I = ss&I;
        # and patch through the v etc?
        # the main difference being these things get J'd up in 4,
        # instead of 4s&mind, a type of wormhole scrap to maintain re W news
    #c A:u wave
    u jc
    n \'of:u'
    # 4s&mind[W] = Y has Ys&N += A:clusping
    # should mow/aggregate by A.3 regularly,
    #   also chancing to figure what domes the mind is for?
    
    # u splits many, requests them, they comeback, we unify when all there
    # alternative ways to include mind happens, eg /js/$t
    # as long as it gives the A:u's a&I,
    #   that the Au mixes into its a&I, that the 
    
    #   to go async to collect its mind
    # so the n/J doing the n we wandered wants to go sleepy when
    # that happens, the usual

    # how in-clusp waits will cause all the enclosing
    # control structures (J/pin, each...) to leave with a T.not
    # which thro undoes, 1s&Ning itself into the mix A:u
    u: %any
        A.u = A;
        C.y.A ||= A;
        C.y.A != A and throw "wild C: ", C
    
    # do we already know this A:u, resync that
    # or sprout and tug A:u's
    # tonly is always, until we can do Jing for u
    N 11:
        $N = s;
        # A:u sprouts A:u's
        ~mindup: C.t
        a&z = [];
        each in N {
            $t;
            if (n.constructor == Object) {
                t = n.t;
            }
            else {
                # just a t means W    # ]
                !G&datam,n,"['*']" and throw "NonWt u: ",n
                t = n[0];
            }
            # A:u's may resync
            4s&mind ||= [];
            $Y = 4s&mind[t];
            
            if (!Y) {
                $C = G&Cye,n;
                # being stylehut means javascript
                !c&I and c&W = 'javascript';
                Y = G&Aye,'u',2,{s:C};
            }
            
            # shelve
            4s&mind[t] = Y;
            
            # wake us
            Ys&N ||= [];
            Ys&N.push(A);
            
            # them
            a&z.push(Y);
        }
        # proceed to succeed
        A.cv = 0.8;
    
    # A:u checks a&z=[A:u's]
    # u 8 checks itself,
    #  by u' 8 checking themselves
    #   (may go async if their cv drop)
    #  if any change:
    #   u 6 mixing
    #  then u 8 again
    N 8:
        $not
        # check u' 8
        for (var zi in a&z) {
            $Y = a&z[zi];
            # u' 8 checks the linkage/version on some object
            # winds back to 3 if not
            G&thro,Y,8;
            Y.cv < 0.8 and not = 1;
        }
        if (not) {
            # set u < 8, so above knows just like we know u' < 8
            # so u 8 checks again, u 6 mixes when u' 8
            ~u 8 N rewind: C.t
            A.cv = 0.7;
            return T.not = 2;
            # they have 4s&N to bring them back,
            # who must also take care of their a&N,
            # bringing back our A:u,
            # and must also take care of that a&N,
            # bringing back A.cluspings,
            # who without a T is gone past/up to:
            # the A:n that wants to thro some more
        }
        # check versions given by u' to what we last took in
        $have = [];
        each iY a&z {
            $Y = a&z[zi];
            $D = Yc&s;
            !Ds&v and throw "u' with no version", D
            have.push(D.t+' '+Ds&v);
        }
        have = have.join(', ');
        
        have != a&have and return T.seek = 6;
        
        ~u 8 N ok: C.t
        #
        # be simple
    #
    #c u 6 mixing
    N 6:
        for (var zi in a&z) {
            $Y = a&z[zi];
            # u' 8 should have I
            !Ys&I and throw "No I back", uname, Y
        }
        $have = [];
        # write this next bit:
        # the AC in a&z require s&v: have.push(C.t+' '+s&v)
        each iY a&z {
            $Y = a&z[zi];
            $D = Yc&s;
            !Ds&v and throw "u' with no version", D
            have.push(D.t+' '+Ds&v);
        }
        have = have.join(', ');
        
        #have == a&have and return
        # mix them all together...
        
        $hup = &s{
            $C = {y:{},c:{},sc:{}};
            C.t = s.t;
            C.y.cv = s.y.cv;
            #$.extend(C.y,s.y);
            $.extend(C.c,s.c);
            $.extend(C.sc,s.sc);
            return C
        };
        $I = {}; # t:I with .y.tv for
        # can be t:cv:I?
        each iY a&z {
            !Ys&I and throw "no I on u': ", Y;
            $C = Yc&s;
            #
            each of,W Ys&I {
                $z = Ws&z;
                !z and throw "No items in We", W
                
                c = I[W.t];
                if (c) {
                    cs&contrib += ','+C.t;
                    cs&many_contrib = 1;
                    W = c;
                }
                else {
                    W = hup(W);
                    Ws&z = [];
                    W.y.tv = {};
                    W.y.tw = {};
                    Ws&contrib = C.t;
                    I[W.t] = W;
                }
                each iD z {
                    # dedup (z and many-z/a&z/u order matters)
                    if (W.y.tv[D.t] && W.y.tv[D.t][D.y.cv]) {
                        $was = W.y.tv[D.t] && W.y.tv[D.t][D.y.cv];
                        $rz = [];
                        each iE Ws&z {
                            E != was and rz.push(E);
                        }
                        Ws&z = rz;
                        W.y.tw[D.t] == was and delete W.y.tw[D.t]
                    }
                    W.y.tv[D.t] ||= {};
                    W.y.tv[D.t][D.y.cv] = D;
                    W.y.tw[D.t] ||= D;
                    Ws&z.push(D);
                }
            }
        }
        
        each of,W I {
            # concatenated zs for this W must be sorted
            if (Ws&many_contrib) {
                delete Ws&many_contrib;
                Ws&z = Ws&z.sort(&a,b{
                    return a.y.cv < b.y.cv ? -1 : a.y.cv > b.y.cv ? 1
                    : a.t < b.t ? -1 : a.t > b.t ? 1
                    : 0
                });
            }
            $la = null;
            each iD Ws&z {
                typeof Dc&code != 'function' and throw "no Dccode", W, D
                if (!la) {
                    W.y.in = D;
                }
                else {
                    la.y.next = D;
                    D.y.prev = la;
                }
                la = D;
            }
        }
        
        a&I = I;
        a&have = have;

        
        #c whatif
        if (Y != A) {
            # here u = Js&u, the u J:
            
            # A:u a&N's the A.clusping waiting on it,
            #  for 4s&N when done
            #     or we could put the A.clusping into us&N
            #      u = A.clusping.1, so
            #       us&Ns&N and 3s&N that 1
            #      which it will see is 
            #   for 4 will rethro A:n from the last W,
            #    with (3s&N) intention to get this one A:n finished
            #     or perhaps a couple of A:n inside of each other
            #     but the thing about A:clusping is casually ignored,
            #     trusting the action to find its way through to that
            #     (and succeed immediately)
            #     
            #    which is a non-pin act, some osc? depends where it is,
            #    if it is FactorEase'd into pin process do that
            #    usually we can static update one thing and see how
            #    it mixes up in osc, eg. things swim,
            #    or it might just change a link
            
            # so A:u know A.clusping to get back to Jaction, once:
            
            # A:u's a&N the A:u waiting on it,
            #  so all those A:u's a&N's of A.clusping's are:
            #   sent to their 1s&N 
            #   or their 3s&N, who will be from 4 cos s&N
            #   then it groups the desires in its 1s&N,
            #   like it's receiving codechange to be with,
            #   and the limb of A:n it converns
            
            # a chunk of this ^ should 
            
            # so the 4s&N reader is wanting grouped to 3-
            # it also picks up on Jtv's 3s&N being there,
            # each A is the last in a chain reaction to resume
            #  eg A:n(W:Typ) > A:clusping
            
            # the A:n can be resync'd?
            # the A:n may have A:other then A:clusping,
            
            
            # and 4s&N A grouped by A.3 can become 3s&N,
            # it is a general pay-attention scheme,
            
            # A:n that W make borders/relationabla,
            #   the thing can be figured/resolved below
            #   and push its content to the yonder A:n,
            #    if they really need it, it may be just a link
            #    or it may require pinning,
            #      since FactorEase connected it into a process that
            #      must then be shunted along
            # the A:n upward should correlate to the
            
        }
    
    #c u' know some meta things,
    # be somewhat collective,
    #  one A:u' may wake up many A:u
    #  4 can A:u' a&v++ when it hears about change,
    #    waking it up on top
    #  A:u' wakes all its A:u,
    #  A:u wakes all its A.cluspings on top
    #  who aggregate into an A:n happening like it did before
    #  but when it his this (A:u, A:u') structure again
    #  everything will be ready
    #  
    # and be known to the meta thing pusher, 4:
    #   those A:u may resync s&M 
    #    (pending A:n that should clusp again)
    #     or restart an A:n with the change as elvis saying "try now"
    # 
    #    by pushing Js&N <- A:u
    #    and 1s
    # < slightly trust that 4 will note W change by:
    #     A:u's Cs&v++, and 1s&N = A
    #     
    #       attracting attention to the A:u's 
    #       which might go up to A:u from A:u's that changed
    #         and ask their 1s&N to A:n to recreate the clusp
    #   like W=javascript can be found in /js/
    # whether it's being updated, or has just updated
    W 12:
        if (s == 'javascript') {
            c&js = C.t
        }
        s&uname = C.t;
    
    # A:u's check themselves
    W 8:
        $ok = a&I
            && s&v == a&v
            && a&now && G&time,a&now,10;
        if (ok) {
            ~u 8 W ok: C.t
            return
        }
        T.seek = 3;
    
    # a static A:u', eg Normal is [Normal,,{I:I}]
    I 8:
        # is ok
        a&I = c&I;
        s&v ||= 3; # bring from hut init/jsung?
        a&v = s&v;
        a&now = G&time;
    #c u' 3 part
    # js3 A gets flock of A.I.? made from a W
    # as <script> via NutServe and the /js/$t-$ver handler 
    #  the G of the webserver and /je/ is Where
    # to mix as in u:
    #   several A get this function to fill their A.I somethings
    #   then they all get osc for a J, or A=u for speed
    #   then this sorting together of A.I can be much faster...
    # < a&async || die?
    # we get it first to read the proper Location
    #   so the <script> tag src is exact
    # < dependency/housing
    js 3:
        a&I = {};
        # lookup code, come back:
        $get = '/js/'+C.t;
        # T would put this c&v to wind back from bugs
        c&v and get += '-'+c&v;
        $.ajax(get).done(&s,how,c{
            how != 'success' and throw "Failed request: "+how, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            $W = m[1];
            $ver = m[2];
            
            # others can let us know 
            a&v = s&v = ver;
            a&now = G&time;
            
            $callback = &script,e{
                # check for errors from that script?
                $tocfunc = W+'_'+ver;
                $toc = window[tocfunc]();
                $D;
                for (var k in toc) {
                    $v = toc[k];
                    $ind = v[0];
                    $t = v[1];
                    $cv = v[2];
                    $c = v[3];
                    $sc = v[4];
                    $C = {t:t, y:{cv:cv}, c:c, sc:sc};
                    if (ind == '') {
                        D = a&I[t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        # grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t,v
                    }
                }
                
                A.cv = 0.4;
                a&ready = 1;
            };
            
            $have = $('body script[src="'+src+'"]');
            have.length and return callback();
            ~uquired: W, ver
            G&addscript,src,callback;
        });
        
        a&ready = 0;
        4s&N.push(A);
        T.not = 1;
    
        #   fail, chase W startup
        #   uptodate TN8
        
        # get, callback fills in A&v
            # so the bunch assembles on 1s&minds[uname] = A:u with sc.I
            
            # have to use Js if complex, eg T wants to mess with it
            
            # build out of A:u if possible, or doing a J if any C specifics
            # an A:u 6 unifies A:u 3s, and A:u 7s compile it, 5wichboard 4ces
            # present N into A:u
            # another A.u
            
NutDung: | # getting things/I
    u j
    n \'of:eye'
    # bring W and the I's insides together into a namespace
    #    I has I.? and I.?.?
    #    I.? gets talked about by many W, projected by many
    #    though it (eg C.t='i') may not be in Where,
    #    it would be more realistic to mix into A etc from names,
    #    containing personalities
    # so all W-ish things are equal
    # could even find that some remote W contains an I.? thing it wants,
    # and decide to use it
    ting: %acgt:t ver
        // blocking unless a&async
        // get content from
        $get = '/js/'+t;
        ver and get += '/'+ver;
        $.get(get);

    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    # wants to be able to jump up the slope,
    # want a type, like http's Accept header,
    #   so G&ting can upstantiate it
    #   things coming alive because of this will have thresholdia
    #   do you want to trust someone else's version of t,
    #   or do you run all the simulations yourself?
    # 
    # < elvis a J for it
    #   esp. if you can resync when it's downloaded
    t: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
        $D;
        $.each([1,2,3,4,5], &i,v{
            D and return;
            var Y = A[v];
            !Y and return;
            var I = Y.I;
            !I and return;
            D = I[s];
            D and t and D = D.y.tw[t];
        });
        !D and s == 'js' and return G&t_js,c,t
        return D;
    
    # W t means W of t,
    # W:js t means W:js titled t, which is what we deal here...
    #  resourcing quests needing question time
    #   need you to follow them through
    t_js: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
    
    # if G&t of:js t=NutMachine turns up nothing,
    # it can use the /js/ meaniture, storing the resultant thing
    # into 5s&things.js.
    
    entre:
        G&jsung,'NutMachine',null,cb;
    
NutJaying: | # A sequence J
    u jc
    n \'of:n'
    
    # A.ground? A.place? ||= 1s&place ||= G&sJ,'place'
    # haul long blogs into long J with many bits of place
    # or page or ...
    # they want to commit or abort, be histree for o
    # and be a collection of in-progress C for slow/scattery J
    n 1: %any
        A.n = A;
        C.y.A ||= A;
        C.y.A != A and throw "wild C: ", C
        
        A&nogro and return
        $g = A.ground;
        !g and return;
        gs&z ||= [];
        gs&z.push(C);
        #~grounds: A.1.t, C.t
    
    # various dynamics to the same basic particle
    pi 12:
        !s and throw "Give pi: ",C;
        c&J = "pi/"+s;
    
    # just looking for W, maybe retrieve static?
    # < using T.Z somehow to say jump to 8 after 2,
    #   might be useful for always tripping trips
    V 12:
        c&W = s;
        A&twotoeight = 1;
    
    # networkily named thing
    W 12:
        !s || s == '1' and s = c&W = C.t;
        typeof s != 'string' and throw 'ref cW', C
        !s and throw 'non t W', C;
        c&J = s;
        s&W = s;
        A&Jup = A.4;
        A&Jcv = 0.1;
    
    # look it up
    #   the in-T knows the out-T
    #    this auto when the A.t exists already (A[A.t])
    #    might become several different T.things, which are
    #    lingo network receivers on other objects in the process
    #    T is a space to make marks
    #   the s&J may already be there
    #   the A&Jup is A.1 (becomes A.2) has s&Jtv
    #    unless W, when its 4
    J 2:
        $upn = A.n.up.n;
        upn && upn.c.T and T.oT = upn.c.T;
        
        s&J and return;
        
        A&Jup ||= A.1;
        A&Jcv ||= C.y.cv;
        
        $J
        if (!A&nomem) {
            // or G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv
            $Jtv
            A&Jup && A&Jup.sc.Jtv and Jtv = A&Jup.sc.Jtv
            if (Jtv && Jtv[C.t] && Jtv[C.t][A&Jcv])
                J = Jtv[C.t][A&Jcv]
        }
        J and s&J = J;
        
        if (A&twotoeight) {
            T.oT.op = J && Js&s && Js&s.sc.top;
            return T.not = 1;
        }
    
    # J encode π 
    # previous J is A.2, may differ from creator "above" J in J.2
    #  make interesting maps of things tunneling to others
    # esp in W-W situ, their J.2 is A.4/A&Jup
    #  blab channels
    #   !A&nogro && sayyl "J ! C.t".(c&pi && " C.y.cv -".c&pi);
    # 1c&s = C means particle holds passing wave of culture
    #  what it will be already is interesting
    #   its C.y.A may still be doing,  be many of the self,
    #   when doing small things on yourself, while
    #   doings big things on yourself, so group what to osc so
    #   bigger bits sort themselves out later.
    #   have a churn/sc energy measure in 6!
    # also with the T ^
    #  there's some boundary effect to be pleased out of it
    J 3:
        if (!s&J) {
            s&J = G&J,A&Jup,C.t;
        }
        A.2 = A.1;
        A.1 = s&J;
        c&W and A.3 = s&J.3 = s&J;
        1c&s = C;
        1c&T = T;
    
    pi 3:
        s&pi = $pi;
        typeof 2c&d != 'number' and 2c&d = 0;
        1c&d = 2c&d + 1;
    
    # W 31 trips
    # W 31 typed - notes W-W connections
    # W 32 Static, if bay/sac/$W forces c&pretend = Beached
    # W 34 thawJ, operates c&pretend
    # e 36 tugs A=E for c&e
    
    #c Jaying J/W/pi universal awakeness hemisphere
    # < doing some W bleed/wander tracking if !sJ
    #   plenty of sW get chewed in the process of displaying W
    # humming - sleepology - osc exports that door us here
    # outside the fully self/u mind
    # can see network protocols of elvis
    # A&E would know if it wants to go in
    # which page we're working on?
    
    0 &&
    J 4:
        my $v = 1s&Tv; # inner surf attracto
        my $ha = 1s&tv; # things
        
        Rw Js&amb $ha $v if !c&e && 1s&amb;
        
        # T wants ha or v wants T (by now, etc)
    
    # xoJ 44 - 1s&xo checks way, attracted by 3Cc&forxo, feeds A&want
    #   forxo given by Matu dispatched stuff
    
    
    # J 45 - A&want calculated
    
    # 5 ^ grinds desires into mode of go
    # may not do the whole pin, G&o inputs
    
    # visit the many domes of this J
    # where we write pages of stuff
    # they should write A&pin and A&page to direct this A
    # a dome is the life of a page.
    # we are all encompassing by default.
    # use T.nose = 6 to T.N = 6
    J 6:
        T.nose and return ~knows: C.t
        
        A&pin ||= c&pin || c&J || s&J.t;
        A&page ||= '';
        
        # be Normal for new J, or for some dome?
        A.I = A.4.I;
        
        1s&grounds ||= [];
        1s&grounds[A&page] = A.ground = G&Cye,[A&page,1,{},{J:s&J}];
        A.1[2].c.imping and 1c&imping++ // reset lv
        
        $ise = '';
        c&e and ise = " (e:"+c&e.t+")";
        $de = "("+A&pin+")"+ise;
        A.1.t == A&pin and de = ise
        ~J: A.1.t, de
        
        $y = {cv:0.9};
        $c = y.c = {root:1};
        $sc = y.sc = {};
        1s&root = G&Cye,[A.1.t,y,c,sc];
        # begin 9 n so it hangs on to Normal A.I
        # will be last unless we can nonrethro its 1?
        $r = G&Aye,'n',0,{s:1s&root};
        $ar = c&ar || {};
        $s = c&s;
        $M = c.M = [];
        # if we make an Error can we rethrow it keeping its origin?
        # catch use case:
        #   the throw from G&TuneTimeMachine wants to abort pin/doming,
        #   put this A:n into 1s&N, but A.1 isn't yet in A.4...
        #   it wants to T.nose=6 with instant bail out of the pin...
        # so lets share the Jup stasher
        A&Jupstash = &{
            !A&Jup and throw "Can't save self", A
            A&Jup.sc.Jtv ||= {};
            A&Jup.sc.Jtv[C.t] ||= {};
            A&Jup.sc.Jtv[C.t][A&Jcv] = s&J;
        };
            if (A&way == 'way') {
                // Rw A&pin + $J:A.1 $y $M $s;
            }
            else {
                G&h,A&pin,M
            }
        T.nose and return;
        
        A.1[2].c.imping and y.imp = 1
        y.imp and 1c&imping = 1; delete y.imp;
        
        !M.length and delete c.M
        
        G&Aye,r,8;
    
    # join moment to moment
    J 7:
        if (T.nose != '1') {
            A&Jupstash();
            delete A&Jupstash;
        }
        # T.N sets cv=6 and queues A in 1s&N, which 4 finds via Jtv
        T.nose == '6' and delete T.nose; return T.N = 6;
        T.nose == '2' and T.not = 1
        T.nose == '7' and delete T.nose
        T.nose and return ~knows: C.t
        
        G&s;
    
    # J leaves T.op just outside
    # < sJ or cJ should do this
    J 8:
        //Rw $_ - $J for @{A&wayght||[]};
        //$_->($J) for @{A&codeght||[]};
        T.oT && 1s&s and T.oT.op = 1s&s.sc.top;
    
    # < do til 9?
    
ServeC: | # gets for C
    # W as <script> js include
    get '/js/:t' => &c{
        my $t = $c->param('t');
        $t =~ s/\.js$//;
        my $ver = $2 if $t =~ s/^(\w+)-(\w+)$/$1/;
        my $C = G&Ct,[$t,'',{ver=>$ver}];
        my $s = Rw NutServe $C;
        $s || return $c->res->code(404), $c->render(text=>"Not found\n");
        
        my $loca = '/js/'.C.t.'-'.c&ver.'.js';
        #$c->redirect_to($loca);
        $c->res->headers->append(Location => $loca);
        $c->render(text=>$s);
    };
    get '/earer' => &c{
        my $dat = $c->param('data');
        #$dat = djson($dat);
        my $s = G&Ct,[earer=>''=>{s=>$dat}];
        my $el = [give=>''=>{s=>$s}];
        my $W = [Wederr=>$el];
        G&timer:0.1,&{ 4s&toy->({to=>[$W]}) };
        $c->render(text=>"hmm\n");
    };
    get '/do/:get' => &c{
        if (my $get = $c->param('get')) {
            my ($who,$does,$what) = $get =~ /^(\w+)'s (\w+) (\w+)$/;
            #`tail G.t/p/$who`
        }
        else {
            
        }
        $c->render(text=>"hmm\n");
    };
    # the way
    # < Accept headers to get the various translations
    get '/way/:way' => &c{
        my $t = $c->param('way');
        $t =~ s/\W+/-/g;
        my $w = G&t,w=>$t;
        $w || return $c->reply->not_found;
        $c->res->headers->append(Dige => ws&dige);
        my $s = a&wayjs.>w.t.>ws&dige ||= do {
            Rw JaBabz $C:w;
            wc&s
        };
        $c->render(text => $s);
    };
NutC: | # make C
    u j
    n \'of:eye'
    # start, having I
    # s would be the W on the server to try and ws or so
    #   when elvises fail they just return W page
    #   makes a socket hang around, whatever comes across.
    # begins
    # 1s&N are A/C wanting attention/typing in
    Jinthe:
        A&ws ||= 1;
        
        window.onerror = &msg,url,lineNo,colNo,error{
            A&bang and return
            A&bang = 1;
            G&Ban,msg,url,lineNo,colNo,error;
            A&bang = 0;
            return
        };
        
        A.t = 'top';
        $J = A.1 = A.2 = A.3 = A.4 = G&J,'Four';
        J.1 = J.2 = J.3 = J.4 = J;
        $f = G&J,'Five';
        A.5 = J.5 = f.5 = f;
        # call it put 1s&Jtv A.4.t 0.01 A.4
        1s&Jtv ||= {};
        1s&Jtv[A.4.t] ||= {};
        1s&Jtv[A.4.t][0.01] = A.4;
        1s&Jtv[A.5.t] ||= {};
        1s&Jtv[A.5.t][0.01] = A.5;
        # 1s&z etc for showing state
        # 1s&N is A-ction, stuff to do,
        # Jambien everything in 1s&Jtv
        4s&NormalI = A.I;
        
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&gev,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&gev,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        // G&sockneck;
        4s&ws = G&Aye,'ws',9;
        
        G&headi,'A','Jin';
        G&headi,'C','Typ';
        G&headi,'G','begoin';
        G&headi,'T','Tri';
        
        G.clof(); G.keof();
        G.clon(); G.keon()
    

    # G reinits...
    
    # T adjusts net
    
    #c A: run funnel
    # the general J 8, starting from A.4
    Jin:
        A = G&Aye,'seeing';
        A.1.t != 'Four' and ~wherefour
        # thinking
        G&waylay,'AndContinue';
    # an 1s&N happens to A, a&N brings back the process that went async
    
    
    # with an A for looking through the A?
    # they build C of knowing about this
    #   diff multiple A:n C
    # the use case is:
    #   A:n up< A:clusping - A:u - (A:u')
    # getting that A:n to continue,
    #  possibly also the A:u would like to do its work while async?
    # 
    # so it may muck around some more, basically looking for a:
    # target: are they just A[A.t] == A but not clusping?

    # < throw that bundles its arguments
    #   like a G&c that blows up, from the perspective of the caller
    
    # < make G&c objecty, truncate, click items
    #   even a J on a stable G...
    
    
    # C: collect chatter
    # create error, order its fixing
    Typ:
        # becomes J, comes back
        A.1.t != 'Typ' and return G&n,['Typ','',{W:1,on:s}];
        c&on and A.on = c&on;
        
        if (0) {
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        }
        
        G&u,['NutDung'];
        G&clusp;
        G&n,['C','',{cod:1,s:'Hererereere'}];
        
        $.ajax('do/Lis est Ref').done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
        });
    
    # gets its own way, comes back, assum
    Tri:
        # becomes J, comes back
        $pin = 'Tri';
        if (A.1.t != pin) {
            $D = G&n,[pin,'',{W:1,on:s}];
            $Y = D.y.A;
            Y.cv < 0.8 and ~waylay: D.t
            return
        }
        c&on and A.on = c&on;
        
        G&way,pin;
    
    #c way that can happen by itself
    waylay: %acgt:t ar delay cb
        typeof ar != 'object' and delay = ar; ar = {};
        typeof delay == 'function' and cb = delay; delay = 0;
        cb ||= &s{};
        if (delay) {
            # wait and then way
            # < expect download's tiny delay as well?
            G&delay:delay,&{ G&waylay,t,ar,0,cb };
            #~waylayter: t, delay
            return
        }
        #~waylaydo: t
        G&way,t,ar,cb
    
    # fancy subroutine call
    # simple keep downloading fresh code mechanism
    #    async if downloading, uses cb or 1s&N=A && throw
    #  t - name of a way
    #  ar - hash of named arguments
    #  cb - callback containing a sync G&way call 
    #    if cb is &s{...}, give it the return value of the way
    #    if cb is 'noop', do nothing, return 1 if way is ready
    #  no cb 
    #   (going async)
    #   tries to resync the A that needed it via 1s&N
    #   causing a J unprepared for what ways its way depends on,
    #   to resolve one at a time as they occur,
    #   finally downloading the whole codepath
    #  a cb of &{} should run the thing real soon if not immediately
    #  no cb, as most way will be, will resync the J 6
    #    so a way should know what ways you might run into inside it,
    #    so resources can be loaded before J:6, which should sleep
    #     and only happen when it needs to, in tiny ordered parts, etc.
    way: %acgt:t ar cb
        $w = typeof t == 'object' ? t : G&t,'w',t;
        !(w && ws&now && G&time,ws&now,5) and w = null
        
        if (!w) {
            cb == 'noop' and cb = &{};
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            $get = '/way/'+t;
            $.ajax(get).done(&s,how,c{
                how != 'success' and throw "Failed request: "+how, c;
                $dige = c.getResponseHeader('Dige');
                $w = G&Cye,[t,1,{s:s},{of:'w',dige:dige}];
                A.5.I ||= {};
                $D = A.5.I.w = A.5.I.w || G&Cye,['w','',{},{z:[]}];
                D.y ||= {};
                D.y.tw ||= {};
                D.y.tw[t] = w;
                ws&now = G&time;
                
                a&ready = 1;
                #~w!: t
                if (cb) {
                    if (G&arfgunc,cb == "s") {
                        # wants its return value with given ar...
                        #~w cb s: t
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the w back?
                        #~w cb: t
                        cb(t,ar,w);
                    }
                }
            });
            #~w?: t
            !cb and G&TuneTimeMachine
            return
        }
        
        # code is already JaBabz'd
        # < CoArgulate for ar, put as knowable source file?
        # < make it c.code and G&h for a B?
        if (!wc&code) {
            $name = 'w_'+w.t+'_'+ws&dige;
            4s&namedcode ||= {};
            $code = 4s&namedcode[name];
            if (code) {
                wc&code = code;
            }
            else {
                eval('wc&code = function '+name+"(A,C,G,T,ar){\n"+wc&s+"}");
                4s&namedcode[name] = wc&code;
            }
        }
        
        return wc&code(A,C,G,T,ar);
    
        
AndContinue: | # J-in stuff
    # like a female that demands J 6 action when sometime
    # find all 1s&N, A with desire to thro
    
    # full of variables, schemes, like how much to regroup by J/net
    # like Matu, unify environmental/causal concerns
    
    # da (de|gr) (c sip|$func)
    $dedup_by_sip = &N{
        $seen = {};
        $M = [];
        each is N {
            !sc&sip and throw "Has no sip: "+i, s
            seen[sc&sip] and continue
            seen[sc&sip] = s;
            M.push(s);
        }
        return M;
    };
    
    # describe an A
            # < compressed notation for where/what it is from this A
            # and amongst these things
            # and the A:n etc it's for/underneath,
            #   even slowlaned N for the A:n and the A:u, rapido A:u',
            #   made of A:u's having a&N of A:u which a&N the A:n
            #   structure can be seen as directional,
            #   the lower, less pointed to stuff works out first,
            #   then we give attention to what was using it (a&N)
            # then venn diagram of waiting-n >< busy-u
    # return objects that stringify, or regroup
    $sa = &Y{
        
        return Y.t
    };
    # describe an N
    $lim = &{};
    $squa = &{};
    
    
    
    # gather J with J&N
    $Js = [];
    # Four/Five should come first since cv=0.01
    #   (or because they were entered first)
    each tvJ 1s&Jtv {
        $N = Js&N;
        !(N && N.length) and continue;
        Js.push(J);
    }}
    
    # identify who and create a needs object
    # Jin to Jin persist by J.t
    1s&needs ||= {};
    $needs = [];
    each iJ Js {
        # could care/prioritise dup A?
        $N = dedup_by_sip(Js&N);
        
        # persist so ready=0 can be ttl'd,
        $n = 1s&needs[J.t];
        n ||= G&Cye,[J.t,''];
        1s&needs[J.t] = n;
        
        # if ns&N, see what's different?
        $what = [];
        each iY N {
            what.push(sa(Y));
        }
        ns&J = J;
        ns&N = N;
        ns&name = what.join(',');
        needs.push(n);
    }
    
    # order needs by elabourate infinity
    
    $sum = [];
    each in needs {
        sum.push(ns&name);
    }
    sum = sum.join(',');
    ~Jin: sum
    
    # T a flow pauser/queue in here
    # batch[time] = needs
    # good for testing!
    
    #c thro'ing
    $seen = {}; # sip
    each in needs {
        $J = ns&J;
        $N = ns&N;
        $soN = ns&sip_oN = {}; # sip: N # Js&N future?
        each iY N {
            seen[Yc&sip] = Y;
            
            # TODO detect Y-y wander earlier, group same A:n
            $y = Y;
            while (y && !yc&T && y.up) {
                # climb up to something we can sequence
                # would cT if it ever thro'd
                # all items resonate
                y = y.up;
            }
            y != Y and ~Yy: sa(Y), sa(y)
            Y = y;
            
            # try wind it up with its own cv/ov
            G&thro,Y;
            # catch errors? could be the most normal place to
            # notice success?
            
            $oN = Ys&N;
            !(oN && oN.length) and continue
            # get A backlinks every time around
            oN = Ys&N = dedup_by_sip(oN);
            # oN deduped but never tidied up?
            #   want centralised A:u' to remember all the scattered A:u,
            #    who can find where they are in Js, which would point
            #      the desire to a s&mind of the Js&u
            #      the A:u A.2 is J, A.1 is Js&u, which could be found...
            #   A:u u to forget the passing clusping,
            #   although maybe the last copy of it would be good dome resync clues
            #   domes seem like A but structural of J
            # keep if they a&retaiN?
            soN[Yc&sip] = oN;
        }
    }
    
    # delete things we did
    # TODO make into a "drain thingses" thing
    each in needs {
        $J = ns&J;
        $N = [];
        each iY Js&N {
            seen[Yc&sip] and continue
            N.push(Y);
        }
        Js&N = N;
    }
    
    # insert things that emerged from doing
    each in needs {
        $J = ns&J;
        $soN = ns&sip_oN;
        !soN and continue
        each sip,N soN {
            $Y = seen[sip];
            $aliens = [];
            each iy N {
                ~Jinmore: J.t, sa(Y), sa(y)
                # Ys&N should drain sometimes...
                # they could be ongoing wake-parent paths
                # classify being, see above
                !yc&T and aliens.push(i)
                
                Js&N.push(y)
            }
            # remove things this A doesn't permanently N to
            each ai aliens {
                Ys&N.splice(i,1)
            }
        }
    }
    
    # that was an animation frame
    # TODO measure time
    # TODO get machine health
    # TODO make/dedup comeback
NutCode: | # om suvber
    u js
    n \'of:om'
    # 
    
Tri: | # a javascript pin
    # waddley
    G&n,['other',1,{s:"q3qq!"}];
    
    G&n,['something',2,{s:"!!~!@r!"},{fs:'170%',hs:'345'}];
    
    
NutCore: | # doc universals, map room
    return;
    u k
    # a dialect/personality for relationships
    # or boundary effects
    # stuff to one day compile into the throat
    # points for things with scattered use by other things
    # including clues for the likes of -od
    
    # cv is loftiness of use
    
    on 1: %on:A.
        # the html element om el 3 will build in
    on 8: %in:k
        # where/what object can this name be:
        # s        C.sc (default)
        # c        C.c
        # a        A.sc
        # A        A.c
        # A.    in A
        # J        J.sc
        # j        j.c
    in 8:
        # what dialect (u name) this name happens in
        
    
    N: %on:a,J
        # it contains A with desire to thro
        # can nest on any Js&N, most importantly 4s&N
        #   the out-J should resolve any in-Js&N,
        #   put edge to the pile of intention,
        #   before attention drifts away
    
    ready: %on:a
        # bool - is the A ready to resync
        # set to 1 when request is served
        # N groupey A may slightly wait for a consensus of readyness
        # 
    
    # oscillator steps
    u s
    J 4:
        # see if we should listen or if its got news 

