NutJay: | # persistent thing, all usual
    n NutC
    n NutJayTo
    n NutJaying
NutJayTo: |
    u j
    n \'of:eye'
    # quank the repeating part
    
    
    # each s/page/C context/sphere/drain it has,
    # has an up to dateness, where the other language joins on,
    #   like ws, can push/want updates through
    #   when drain C's yA's a&v (J-ish version) or A&sip changes
    #   or the C could be getting checked/o'd more often the usual
    #   
    #   looking at drain things' A's ip? or its A.c.v-ersion?
    #   or A.4+1's ip being more recent?
    #   want to wind up any A in drain <= 6?
    #   the s's M's As and Cs, the sources of what's on the page, change
    #   so there can be a way to encode a s's source/ingredients as an s
    #  and vaguely the last ip number of A.4+1 being > that remembered
    #    that remembererd ~= encoded as universal view of the A holding stuff
    #   means 
    # the ipi of the A.4+1 on the  
    
    
    # s&v will be a version/timestamp
    # t will be Where it is
    # cv some kind of trust/doneness feng shui,
    #   likely to separate many of the same J
    # c/sc ongoing house of definition,
    # to be sprung out by pin
    #  which is to draw the usual picture,
    #  and define hooks/elvising,
    #  so as to create services and lingo/policy for other morphologies
    #  and physics for interaction
    
    
    #c NutJunc
    
    # sproutling
    # J, they inherit like a stretchier A
    J: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        $V = A;
        $A = J||A;
        $J = G&Aye,s;
        // on a chain
        J.2 = J.1;
        J.1 = J;
        // that pulls to Nine, like A
        Js&N ||= [];
        return J
    
    # contraptions of J
    
    # J's support crew, secondary colours
    # who keep normal
    # may be n'd and s'd
    sJ: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        J.sc[s] and return J.sc[s];
        $j = G&J,J,s;
        j.I = A.4.I;
        return j
    
    # adds to ground
    # < sometimes given [C,C,C]?
    n:
        typeof s != 'object' and throw "weird n", s;
        
        //G&clusp;
        
        $C = G&Cye,s;
        G&Aye,'n',8,{s:C};
        return C
    
    # the usual many things accumulate in $M=[]
    # things given by the way
    # lives on 9c&M, gets n'd end of 6
    # < sometimes given [C,C,C]?
    m: %acgt:M s
        typeof s != 'object' and throw "weird m", s
        s.constructor == Array and return $.each(M,&i,v{ G&m,$v })
        
        //G&clusp;
        
        $C = G&Cye,s;
        M.push(C);
        return C
    =pod
    #c NutMinds
    # adds to mind, G&clusp causes it to be made
    # can do an A:u if mix is simple/found enough
    # accumulated on 1s&u=J:u for clusping onto A.1
    u:
        my $u = G&sJ,'u';
        push @{uc&N||=[]}, s;
        if (@Me == 1 && $Me[0] eq '') { 
            # u '' # resets to normal
            return G&clusp;
        }
    
    
    # clasp u
    # 5s&NormalI is default if no u
    # 5s&NormalC is base, it's s&J holding I as usual
    #   O ii hoists faster than entering everything from the start
    # < only elvising altering We things
    # < lots of I.i things only being on 5 so this has less to chew
    # < knowing I.i never needs to know order/y.next... unless stored
    clusp:
        # before 5/House sets up
        return unless 5s&NormalI;
        
        # u unchanged
        if (my $u = 1s&u) {
            return if uc&N && !@{uc&N};
        }
        my $u = G&sJ,'u';
        uc&is = 'mind';
        my $J = A.1;
        
        J.I = A.I = do {
            my $A = G&A,clusping=>0;
            A.clusping = $A;
            A.1 = $u;
            A.2 = $J;
            my $N = 1c&N || [];
            # u '' # resets to normal
            $N = [] if @$N == 1 && @{$N->[0]} == 1 && $N->[0]->[0] eq '';
            1c&N = [];
            if (@$N) {
                local A.trip;
                local A&trip;
                # this may be an alias for speed rather than canonical
                # name should include versions: Normal#3893a73, c#489bc58
                #   being ha, or c#1.42.492 for incremental version
                #   maybe wanting hostnames
                # the 5 might create some W for each mind it makes
                my $uname = slm 15, dig wdump 3, $N;
                1 && saygr G&sn ." u: ".ki $N;
                5s&ucache.>$uname ||= do {
                    1c&is = 'mind'; # static encouraged
                    # enter stuff to form mind
                    
                    my $ch = $uname;
                    1s&grounds.>$ch = A.ground = G&Ct,[$ch=>1=>{},{J=>A.1}];
                    
                    1s&root = G&Ct,[$uname=>9=>{root=>1}];
                    map { G&A,mo=>1=>{s=>$_} }
                    map { G&Ct,$_ }
                        # s&J holding I as usual
                        (5s&NormalC || die "create NormalC");
                    
                    map { G&A,mo=>8=>{s=>$_} }
                        # like a J6
                        1s&root, # must be findable in drain
                    map { G&Ct,$_ }
                        # entered stuff
                        @$N;
                    # 
                    my $s = G&s;
                    ss&I || die "clusp no I, $uname: ".ki $s;
                };
            }
            else {
                my $C = 5s&NormalC || die "nonormalC";
                my $J = s&J || die "nonormalCJ";
                Js&I || die "nonormalCJI";
            }
        };
        # get this J's mo throat to reopen its mind
        T.seek = 1;
    
    #c NutElvis
    # ephemeral n without:
    # - clusping the mind, or
    # - attaching to this ground (usu for c.e)
    # < e could be reliabilitied by grounding and osc work
    # usually n \'of:mo' -> C.c.of=mo
    # but for e it A.c.of=mo, for eg nomem
    elph: %acgt
        G&e,@Me;
    e: %acgt
        @Me == 1 && (!ref $Me[0]
            || ref $Me[0] eq 'SCALAR') &&
            return G&E,@Me;
        pop @Me if $Me[-1] eq '';
        my $c;
        $c = shift @Me if ref $Me[0] eq 'SCALAR';
        $c = $c ? G&peel,$$c : {};
        c.nogro = 1;
        
        $C = G&Ct,\@Me;
        saybl "e: ".ki $C;
        G&A,mo=>8=>{s=>$C,%$c};
        $C
    =cut
    
NutJaying: | # how to sequence a J
    u jc
    n \'of:n'
    
    # A.ground? A.place? ||= 1s&place ||= G&sJ,'place'
    # haul long blogs into long J with many bits of place
    # or page or ...
    # they want to commit or abort, be histree for o
    # and be a collection of in-progress C for slow/scattery J
    n 1:
        A.n = A;
        y&A != A and throw "wild C: ", C
        A&nogro and return
        $g = A.ground;
        !g and return;
        gs&z ||= [];
        gs&z.push(C);
    
    # various dynamics to the same basic particle
    pi 12:
        !s and throw "Give pi: ".ki$C;
        c&J = "pi/$pi";
    
    # just looking for W, maybe retrieve static?
    # < using T.Z somehow to say jump to 8 after 2,
    #   might be useful for always tripping trips
    V 12:
        c&W = s;
        A&twotoeight = 1;
    
    # networkily named thing
    W 12:
        typeof s != 'string' and throw 'ref cW', C
        !s || s == '1' and s = c&W = C.t;
        !s and throw 'non t W', C;
        c&J = s;
        s&W = s;
        A&Jup = A.4;
        A&Jcv = 0.1;
    
    # look it up
    #   the in-T knows the out-T
    #    this auto when the A.t exists already (A[A.t])
    #    might become several different T.things, which are
    #    lingo network receivers on other objects in the process
    #    T is a space to make marks
    #   the s&J may already be there
    #   the A&Jup is A.1 (becomes A.2) has s&Jtv
    #    unless W, when its 4
    J 2:
        $upn = A.n.up.n;
        upn && upn.c.T and T.oT = upn.c.T;
        
        s&J and return;
        
        A&Jup ||= A.1;
        A&Jcv ||= C.y.cv;
        
        $J
        if (!A&nomem) {
            // or G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv
            $Jtv
            A&Jup && A&Jup.sc.Jtv and Jtv = A&Jup.sc.Jtv
            if (Jtv[C.t] && Jtv[C.t][A&Jcv])
                J = Jtv[C.t][A&Jcv]
        }
        J and s&J = J;
        
        if (A&twotoeight) {
            T.oT.op = J && Js&s && Js&s.sc.top;
            return T.not = 1;
        }
    
    # J encode Ï€ 
    # previous J is A.2, may differ from creator "above" J in J.2
    #  make interesting maps of things tunneling to others
    # esp in W-W situ, their J.2 is A.4/A&Jup
    #  blab channels
    #   !A&nogro && sayyl "J ! C.t".(c&pi && " C.y.cv -".c&pi);
    # 1c&s = C means particle holds passing wave of culture
    #  what it will be already is interesting
    #   its C.y.A may still be doing,  be many of the self,
    #   when doing small things on yourself, while
    #   doings big things on yourself, so group what to osc so
    #   bigger bits sort themselves out later.
    #   have a churn/sc energy measure in 6!
    # also with the T ^
    #  there's some boundary effect to be pleased out of it
    J 3:
        if (!s&J) {
            s&J = G&J,A&Jup,C.t;
        }
        A.2 = A.1;
        A.1 = s&J;
        c&W and A.3 = s&J.3 = s&J;
        1c&s = C;
        1c&T = T;
    
    pi 3:
        s&pi = $pi;
        typeof 2c&d != 'number' and 2c&d = 0;
        1c&d = 2c&d + 1;
    
    # W 31 trips
    # W 31 typed - notes W-W connections
    # W 32 Static, if bay/sac/$W forces c&pretend = Beached
    # W 34 thawJ, operates c&pretend
    # e 36 tugs A=E for c&e
    
