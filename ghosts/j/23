NutJay: | # persistent thing, all usual
    n NutC
    n NutEl
    n NutJayTo
    n NutJaying
NutJayTo: |
    u j
    n \'of:eye'
    # quank the repeating part
    
    
    # each s/page/C context/sphere/drain it has,
    # has an up to dateness, where the other language joins on,
    #   like ws, can push/want updates through
    #   when drain C's yA's a&v (J-ish version) or A&sip changes
    #   or the C could be getting checked/o'd more often the usual
    #   
    #   looking at drain things' A's ip? or its A.c.v-ersion?
    #   or A.4+1's ip being more recent?
    #   want to wind up any A in drain <= 6?
    #   the s's M's As and Cs, the sources of what's on the page, change
    #   so there can be a way to encode a s's source/ingredients as an s
    #  and vaguely the last ip number of A.4+1 being > that remembered
    #    that remembererd ~= encoded as universal view of the A holding stuff
    #   means 
    # the ipi of the A.4+1 on the  
    
    
    # s&v will be a version/timestamp
    # t will be Where it is
    # cv some kind of trust/doneness feng shui,
    #   likely to separate many of the same J
    # c/sc ongoing house of definition,
    # to be sprung out by pin
    #  which is to draw the usual picture,
    #  and define hooks/elvising,
    #  so as to create services and lingo/policy for other morphologies
    #  and physics for interaction
    
    
    # sproutling
    # J, they inherit like a stretchier A
    J: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        $V = A;
        $A = J||A;
        $J = G&Aye,s;
        // on a chain
        J.2 = J.1;
        J.1 = J;
        // that pulls to Nine, like A
        Js&N ||= [];
        return J
    
    # contraptions of J
    
    # J's support crew, secondary colours
    # who keep normal
    # may be n'd and s'd
    sJ: %acgt:J s
        typeof J == 'string' and s = J; J = A.1;
        J.sc[s] and return J.sc[s];
        $j = G&J,J,s;
        j.I = A.4.I;
        return j
    
    # adds to ground
    # < sometimes given [C,C,C]?
    n:
        typeof s != 'object' and throw "weird n", s;
        
        //G&clusp;
        
        $C = G&Cye,s;
        G&Aye,'n',8,{s:C};
        return C
    
    # the usual many things accumulate in $M=[]
    # things given by the way
    # lives on 9c&M, gets n'd end of 6
    # < sometimes given [C,C,C]?
    m: %acgt:M s
        typeof s != 'object' and throw "weird m", s
        s.constructor == Array and return $.each(M,&i,v{ G&m,$v })
        
        //G&clusp;
        
        $C = G&Cye,s;
        M.push(C);
        return C
    #c ephemeral n without:
    # - clusping the mind, or
    # - attaching to this ground (usu for c.e)
    # < e could be reliabilitied by grounding and osc work
    # usually n \'of:mo' -> C.c.of=mo
    # but for e it A.c.of=mo, for eg nomem
    
    # babs
    # e other: thing: what          -> G&e,['other'],['thing','','what']
    #  then as n [other=>W=>{e:['thing','','what']}]
    # with A&nogro = 1
    
    # e {cstuff:4} this: stiil   -> G&e,{nAcstuff:4},['this','','stiil']
    # so can not put 
    # e C, this: -pi24             C, ['this',0.24,{pi:'this'}]
    # shows C this
    
    #  as an intention for process it can be slowed down when n same
    #  page for every elvising going on wanted,
    #  the script of its activity zoomintoable
    # the sudden datatype
    e: %acgt:c s
        !c || !s and throw "e carefully"
        C = c;
        c = {};
        C.constructor == Array and C = G&Cye,C
        s.constructor == Array and s = G&Cye,s
        // if first C not C it is A.c, second becomes first
        !(C.y && C.c && C.sc) and c = C; C = s; s = null;
        
        // put second C on first as c&e
        s and c&e = s
        
        c.nogro = 1;
        c.s = C;
        
        $et = ''
        s and et = s.t;
        
        ~e: C.t, et
        
        G&Aye,'n',8,c;
        
        C
NutMind: | # do as
    u j
    n \'of:eye'
    # adds to the A,1's mind, G&clusp causes it to be made
    # can do an A:u if mix is simple/found enough
    # accumulated on 1s&u=J:u for clusping onto A.1
    # u '' # resets to normal
    u:
        $u = G&sJ,'u';
        uc&N ||= [];
        uc&N.push(s);
        s.constructor == Array && s[0] == '' and G&clusp
    # ]
    
    # clasp u
    # 5s&NormalI/A.4.I is default if no u
    # 5s&NormalC is base, it's s&J holding I as usual,
    #   O ii hoists faster than entering everything from the start
    # < only elvising altering We things
    # < lots of I.i things only being on 5 so this has less to chew
    # < knowing I.i never needs to know order/y.next... unless stored
    clusp:
        !4s&NormalI and return
        
        // a u still, could lead to not picking it up when elvising?
        1s&u && 1s&u.c.N && 1s&u.c.N.length == 0 and return
        
        $u = G&sJ,'u';
        uc&is = 'mind';
        $J = A.1;
        $I;
        
        $A = G&Aye,'clusping',0;
        A.clusping = A;
        A.1 = u;
        A.2 = J;
        
        $isar = &s{
            return typeof s == 'object' && s.constructor == Array
        };
        
        $N = 1c&N || [];
        // squash the [''], from: u ''
        N.length == 1 && isar(N[0]) && N[0].length == 1 && N[0][0] == '' and N = [];
        
        1c&N = [];
        
        if (N.length) {
            # local A.trip, A&trip;
            # u splits many, requests them, they comeback, we unify when all there
            # extra in-between trips through 1s&N to the A:u's,
            #   who should do in child/thing then over/unity order,
            # then bringing back the A:n we threw off
            #   to go async to collect its mind
            # so the n/J doing the n we wandered wants to go sleepy when
            # that happens, the usual
            
            # how in-clusp waits will cause all the enclosing
            # control structures (J/pin, each...) to leave with a T.not
            # which thro undoes, 1s&Ning itself into the mix A:u
            
            $C = G&Cye,['','',{N:N}];
            A G&Aye,'u',8,{s:C};
            
        }
        else {
            my $C = 5s&NormalC || die "nonormalC";
            my $J = s&J || die "nonormalCJ";
            Js&I || die "nonormalCJI";
            }
        };
        // T.seek = '' makes A:n (or so) thro to get new mind from now on
        // T.seek = 0 same but repeat this step/A.cv
        T.seek = '';
    
    #c Au
    u jc
    n \'of:eye'
    
    start: %any
        C.y.A = A;
            
            # anyway
            # name the bunch of names that is a wave of u
            $NisWs = 1;
            $con = [];
            $.each(N, &k,v{
                isar(v) && v.length == 1 && typeof v[0] == 'string' and return con.push(v[0]);
                NisWs = 0;
            });
            !NisWs and throw "Complicated u Cs: ", N
            
            $uname = con.join(',');
            ~mindup: uname
            
            # find the sc.I haver
            $i = 1s&minds[uname];
            i ||= 4s&minds[uname];
            if (!i) {
                i = G&Aye,'u';
                $C = i.c.s;
                C.t = uname;
                c&N = N;
                1s&minds[uname] =
                4s&minds[uname] = i;
            }
            # should satisfy uptodateness by reading along to the 4s
            G&Aye,'i',8;
            
            # so the bunch assembles on 1s&minds[uname] = A:u with sc.I
            
            # have to use Js if complex, eg T wants to mess with it
            
            # build out of A:u if possible, or doing a J if any C specifics
            # an A:u 6 unifies A:u 3s, and A:u 7s compile it, 5wichboard 4ces
            # present N into A:u
            # another A.u
            
            my $uname = slm 15, dig wdump 3, $N;
            1 && saygr G&sn ." u: ".ki $N;
            5s&ucache.>$uname ||= do {
                1c&is = 'mind'; # static encouraged
                # enter stuff to form mind
                    
                    my $ch = $uname;
                    1s&grounds.>$ch = A.ground = G&Ct,[$ch=>1=>{},{J=>A.1}];
                    
                    1s&root = G&Ct,[$uname=>9=>{root=>1}];
                    map { G&A,mo=>1=>{s=>$_} }
                    map { G&Ct,$_ }
                        # s&J holding I as usual
                        (5s&NormalC || die "create NormalC");
                    
                    map { G&A,mo=>8=>{s=>$_} }
                        # like a J6
                        1s&root, # must be findable in drain
                    map { G&Ct,$_ }
                        # entered stuff
                        @$N;
                    # 
                    my $s = G&s;
                    ss&I || die "clusp no I, $uname: ".ki $s;
                };
NutDung: | # getting things/I
    u j
    n \'of:eye'
    # bring W and the I's insides together into a namespace
    #    I has I.? and I.?.?
    #    I.? gets talked about by many W, projected by many
    #    though it (eg C.t='i') may not be in Where,
    #    it would be more realistic to mix into A etc from names,
    #    containing personalities
    # so all W-ish things are equal
    # could even find that some remote W contains an I.? thing it wants,
    # and decide to use it
    ting: %acgt:t ver
        // blocking unless a&async
        // get content from
        $get = '/js/'+t;
        ver and get += '/'+ver;
        $.get(get);

    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    # wants to be able to jump up the slope,
    # want a type, like http's Accept header,
    #   so G&ting can upstantiate it
    #   things coming alive because of this will have thresholdia
    #   do you want to trust someone else's version of t,
    #   or do you run all the simulations yourself?
    # 
    # < elvis a J for it
    #   esp. if you can resync when it's downloaded
    t: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
        $D;
        $.each([1,2,3,4,5], &i,v{
            z and return;
            var Y = A[v];
            !Y and return;
            var I = Y.I;
            !I and return;
            D = I[s];
            t and D = D.y.tw[t];
        });
        !D and s == 'js' and return G&t_js,c,t
        return D;
    
    # W t means W of t,
    # W:js t means W:js titled t, which is what we deal here...
    t_js: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
    
    # if G&t of:js t=NutMachine turns up nothing,
    # it can use the /js/ meaniture, storing the resultant thing
    # into 5s&things.js.
    
    entre:
        G&jsung,'NutMachine',null,cb;
    
    # A gets flock of A.I.? made from a W
    # as <script> via NutServe and the /js/$t-$ver handler 
    #  the G of the webserver and /je/ is Where
    # to mix as in u:
    #   several A get this function to fill their A.I somethings
    #   then they all get osc for a J, or A=u for speed
    #   then this sorting together of A.I can be much faster...
    # < a&async || die?
    # we get it first to read the proper Location
    #   so the <script> tag src is exact
    # < dependency/housing
    jsung: %acgt:t ver cb
        $get = '/js/'+t;
        ver and get += '-'+ver;
        $.ajax(get).done(&s,how,c{
            how != 'success' and throw "Failed request: "+how, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            $W = m[1];
            $ver = m[2];
            $callback = &script,e{
                $tocfunc = W+'_'+ver;
                console.log("Have a toc: ",tocfunc);
                $toc = window[tocfunc]();
                $D;
                $.each(toc, &k,v{
                    $ind = v[0];
                    $t = v[1];
                    $cv = v[2];
                    $c = v[3];
                    $sc = v[4];
                    $C = {t:t, y:{cv:cv}, c:c, sc:sc};
                    if (ind == '') {
                        D = A.I[t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        // grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t,v
                    }
                });
                cb(t,ver,script,e); 
            };
            $have = $('body script[src="'+src+'"]');
            have.length and return callback();
            ~acquired: t, ver
            G&addscript,src,callback;
        });
    
    addscript: %acgt:src cb
        var script = document.createElement('script');
        script.setAttribute('src', src);
        script.setAttribute('type', 'text/javascript');
        cb and script.onload = &e{ cb(script,e) };
        A.on.appendChild(script);
NutJaying: | # A sequence J
    u jc
    n \'of:n'
    
    # A.ground? A.place? ||= 1s&place ||= G&sJ,'place'
    # haul long blogs into long J with many bits of place
    # or page or ...
    # they want to commit or abort, be histree for o
    # and be a collection of in-progress C for slow/scattery J
    n 1: %any
        A.n = A;
        C.y.A ||= A;
        C.y.A != A and throw "wild C: ", C
        A&nogro and return
        $g = A.ground;
        !g and return;
        gs&z ||= [];
        gs&z.push(C);
        ~grounds: A.1.t, C.t
    
    # various dynamics to the same basic particle
    pi 12:
        !s and throw "Give pi: ",C;
        c&J = "pi/"+s;
    
    # just looking for W, maybe retrieve static?
    # < using T.Z somehow to say jump to 8 after 2,
    #   might be useful for always tripping trips
    V 12:
        c&W = s;
        A&twotoeight = 1;
    
    # networkily named thing
    W 12:
        !s || s == '1' and s = c&W = C.t;
        typeof s != 'string' and throw 'ref cW', C
        !s and throw 'non t W', C;
        c&J = s;
        s&W = s;
        A&Jup = A.4;
        A&Jcv = 0.1;
    
    # look it up
    #   the in-T knows the out-T
    #    this auto when the A.t exists already (A[A.t])
    #    might become several different T.things, which are
    #    lingo network receivers on other objects in the process
    #    T is a space to make marks
    #   the s&J may already be there
    #   the A&Jup is A.1 (becomes A.2) has s&Jtv
    #    unless W, when its 4
    J 2:
        $upn = A.n.up.n;
        upn && upn.c.T and T.oT = upn.c.T;
        
        s&J and return;
        
        A&Jup ||= A.1;
        A&Jcv ||= C.y.cv;
        
        $J
        if (!A&nomem) {
            // or G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv
            $Jtv
            A&Jup && A&Jup.sc.Jtv and Jtv = A&Jup.sc.Jtv
            if (Jtv && Jtv[C.t] && Jtv[C.t][A&Jcv])
                J = Jtv[C.t][A&Jcv]
        }
        J and s&J = J;
        
        if (A&twotoeight) {
            T.oT.op = J && Js&s && Js&s.sc.top;
            return T.not = 1;
        }
    
    # J encode Ï€ 
    # previous J is A.2, may differ from creator "above" J in J.2
    #  make interesting maps of things tunneling to others
    # esp in W-W situ, their J.2 is A.4/A&Jup
    #  blab channels
    #   !A&nogro && sayyl "J ! C.t".(c&pi && " C.y.cv -".c&pi);
    # 1c&s = C means particle holds passing wave of culture
    #  what it will be already is interesting
    #   its C.y.A may still be doing,  be many of the self,
    #   when doing small things on yourself, while
    #   doings big things on yourself, so group what to osc so
    #   bigger bits sort themselves out later.
    #   have a churn/sc energy measure in 6!
    # also with the T ^
    #  there's some boundary effect to be pleased out of it
    J 3:
        if (!s&J) {
            s&J = G&J,A&Jup,C.t;
        }
        A.2 = A.1;
        A.1 = s&J;
        c&W and A.3 = s&J.3 = s&J;
        1c&s = C;
        1c&T = T;
    
    pi 3:
        s&pi = $pi;
        typeof 2c&d != 'number' and 2c&d = 0;
        1c&d = 2c&d + 1;
    
    # W 31 trips
    # W 31 typed - notes W-W connections
    # W 32 Static, if bay/sac/$W forces c&pretend = Beached
    # W 34 thawJ, operates c&pretend
    # e 36 tugs A=E for c&e
    
    #c thinging also happens to any C, which J
    # assume everything wants to element itself
    0 &&
    zum 31: %any
        c&el ||= '1';
        
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    0 &&
    om 4: %any
        // recur W, where A.b starts
        $W = A.on.thing = A.on.thing || {};
        A.W = W;
        
        // do om, depth of A:n
        T.d = (T.oT && T.oT.d) + 1;
        $A = G&Aye,'om';
        A.om ||= A;
        A.om == A.up and A.mo = A;
        
        s and C = s;
        $C = G&Cye,C;
        C.y.A = A;
        
        A&T = T;
        G&thro,2,C;
        T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
        s&css ||= {};
        s&anc ||= {};
        G&thro,7;
    
        
    
    #c Jaying J/W/pi are now set up in the universal hemisphere
    # < doing some W bleed/wander tracking if !sJ
    #   plenty of sW get chewed in the process of displaying W
    # humming - sleepology - osc exports that door us here
    # outside the fully self/u mind
    # can see network protocols of elvis
    # A&E would know if it wants to go in
    # which page we're working on?
    
    0 &&
    J 4:
        my $v = 1s&Tv; # inner surf attracto
        my $ha = 1s&tv; # things
        
        Rw Js&amb $ha $v if !c&e && 1s&amb;
        
        # T wants ha or v wants T (by now, etc)
    
    # xoJ 44 - 1s&xo checks way, attracted by 3Cc&forxo, feeds A&want
    #   forxo given by Matu dispatched stuff
    
    
    # J 45 - A&want calculated
    
    # 5 ^ grinds desires into mode of go
    # may not do the whole pin, G&o inputs
    
    # visit the many domes of this J
    # where we write pages of stuff
    # they should write A&pin and A&page to direct this A
    J 6:
        T.nose and return ~knows: C.t
        
        A&pin ||= c&pin || c&J || s&J.t;
        A&page ||= '';
        
        // be Normal for new J, or immediate known domes?
        A.I = A.4.I;
        
        1s&grounds ||= [];
        1s&grounds[A&page] = A.ground = G&Cye,[A&page,1,{},{J:s&J}];
        A.1[2].c.imping and 1c&imping++ // reset lv
        
        $ise = '';
        c&e and ise = " (e:"+c&e.t+")";
        $de = "("+A&pin+")"+ise;
        A.1.t == A&pin and de = ise
        ~J: A.1.t, de
        
        $y = {cv:0.9};
        $c = y.c = {root:1};
        $sc = y.sc = {};
        1s&root = G&Cye,[A.1.t,y,c,sc];
        // begin 9 mo now to give it a Normal A.I
        $r = G&Aye,'n',1,{s:1s&root};
        $ar = c&ar || {};
        $s = c&s;
        $M = c.M = [];
        if (A&way == 'way') {
            // Rw A&pin + $J:A.1 $y $M $s;
        }
        else {
            G&h,A&pin,M
        }
        T.nose and return;
        
        A.1[2].c.imping and y.imp = 1
        y.imp and 1c&imping = 1; delete y.imp;
        
        !M.length and delete c.M
        
        G&Aye,r,8;
    
    # join moment to moment
    J 7:
        if (T.nose != '1') {
            !A&Jup and throw "Can't save self", A
            A&Jup.sc.Jtv ||= {};
            A&Jup.sc.Jtv[C.t] ||= {};
            A&Jup.sc.Jtv[C.t][A&Jcv] = s&J;
        }
        T.nose == '2' and T.not = 1
        T.nose == '7' and delete T.nose
        T.nose and return ~knows: C.t
        
        G&s;
    
    # J leaves T.op just outside
    # < sJ or cJ should do this
    J 8:
        //Rw $_ - $J for @{A&wayght||[]};
        //$_->($J) for @{A&codeght||[]};
        T.oT && 1s&s and T.oT.op = 1s&s.sc.top;
    
    # < do til 9?
    
ServeC: | # gets for C
    # W as <script> js include
    get '/js/:t' => &c{
        my $t = $c->param('t');
        $t =~ s/\.js$//;
        my $ver = $2 if $t =~ s/^(\w+)-(\w+)$/$1/;
        my $C = G&Ct,[$t,'',{ver=>$ver}];
        my $s = Rw NutServe $C;
        $s || return $c->res->code(404), $c->render(text=>"Not found\n");
        
        my $loca = '/js/'.C.t.'-'.c&ver.'.js';
        #$c->redirect_to($loca);
        $c->res->headers->append(Location => $loca);
        $c->render(text=>$s);
    };
    get '/earer' => &c{
        my $dat = $c->param('data');
        #$dat = djson($dat);
        my $s = G&Ct,[earer=>''=>{s=>$dat}];
        my $el = [give=>''=>{s=>$s}];
        my $W = [Wederr=>$el];
        G&timer:0.1,&{ 4s&toy->({to=>[$W]}) };
        $c->render(text=>"hmm\n");
    };
    get '/do/:get' => &c{
        if (my $get = $c->param('get')) {
            my ($who,$does,$what) = $get =~ /^(\w+)'s (\w+) (\w+)$/;
            #`tail G.t/p/$who`
        }
        else {
            
        }
        $c->render(text=>"hmm\n");
    };
NutC: | # make C
    u j
    n \'of:eye'
    # start, having I
    # s would be the W on the server to try and ws or so
    #   when elvises fail they just return W page
    #   makes a socket hang around, whatever comes across.
    # begins
    # 1s&N are A/C wanting attention/typing in
    Jinthe:
        A&ws ||= 1;
        
        window.onerror = &msg,url,lineNo,colNo,error{
            A&bang and return
            A&bang = 1;
            G&Ban,msg,url,lineNo,colNo,error;
            A&bang = 0;
            return
        };
        
        A.t = 'top';
        $J = A.1 = A.2 = A.3 = A.4 = G&J,'Four';
        J.1 = J.2 = J.3 = J.4 = J;
        // 1s&z etc for showing state
        
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&gev,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&gev,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        // G&sockneck;
        4s&ws = G&Aye,'ws',9;
        
        G&headi,'A','Jin';
        G&headi,'C','Typ';
        G&headi,'G','begoin';
        G&headi,'T','Tri';
        
        G.clof(); G.keof();
        G.clon(); G.keon()
    
    
    # make buttons
    headi: %acgt:s t
        t ||= s
        
        $('body h2').filter(&i,v{
            v.innerHTML.match('^'+s) and v.remove()
        });
        
        $func = "G.h(A,C,G,T,'"+t+"',this)";
        $('<h2 onclick="'+func+'">'+s+'</h2>')
            .appendTo('body')
    

    # G reinits...
    
    # T adjusts net
    
    #c A: run funnel
    Jin:
        // find all 1s&N
        
        G&Aye,A
        ~Jin
    
    # C: collect chatter
    # create error, order its fixing
    Typ:
        // becomes J, comes back
        A.1.t != 'Typ' and return G&n,['Typ','',{W:1,on:s}];
        c&on and A.on = c&on;
        
        
        G&n,['C','',{cod:1,s:'Hererereere'}];
        
        $.ajax('do/Lis est Ref').done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
        });
    
    #c pudding things on could...
    # < clean away use of the drain as the top C
    # < dome system composing them onto the root C directly...
    #   would expose useful tools for playing data...
    s: %acgt:c sc
        $A = G&Aye,'s',0,c,sc;
        
        $g = A.ground;
        
        // ground -> drain, so it can be resupposed
        // < keeping stuff on 9... replace 1s&root with the drained one?
        1s&drains ||= {};
        $d = 1s&drains[g.t] = 1s&drains[g.t] || G&Cye,g;
        $was = ds&z;
        ds&z = $.unique(gs&z).filter(&C,i{
            !C.t || !C.y || !C.c || !C.sc and throw "low on C: ", C
            $Y = C.y.A;
            if (Y && (Yc&T.not || C.sc.not)) {
                return 0
            }
            return 1;
        });
        $r = 1s&root;
        !r and throw "how to hold many"
        
        // brain per ground, ongoing
        1s&brains ||= {};
        $C = A&s = 1s&brains[g.t] = 1s&brains[g.t] || G&Cye,[g.t,1,{},{J:A.1}];
        
        $diff = &di,ff{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            $.each(di, &k,v{
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            });
            $.each(ff, &k,v{
                null == di[k] and wh.gone[k] = {};
            });
            $.each(wh, &k,v{
                v.length and return 1;
            });
        };
        
        $la = s&top;
        $ltv = la && la.y.tv;
        $tw = r.y.tw = {};
        $tv = r.y.tv = {};
        rs&z = [];
        rs&lv = [];
        $.each(ds&z, &i,C{
            // put on tv
            tv[C.t] ||= {};
            tv[C.t][C.y.cv] = C;
            rs&z.push(C);
            
            // diff
            $D = ltv && ltv[C.t] && ltv[C.t][C.y.cv];
            D ||= {};
            $cha = diff(C.t,D.t)
                || diff(C.c,D.c||{})
                || diff(C.sc,D.sc||{});
            
            !cha and return
            
            // make patch
            $s = G&Cye,C;
            s.y.OC = C;
            sc&el = 1;
            rs&lv.push(s);
        });
        la &&
        $.each(la.sc.z, &i,C{
            tv[C.t] && tv[C.t][C.y.cv] and return
            rs&lv.push(G&Cye,[C.t,C.y.cv,{el:9}]);
        });
        
        // consequence change
        s&lv ||= [];
        if (rs&lv.length) {
            $lr;
            $.each(rs&lv, &i,C{
                C.y.OC == r and lr = C
            });
            lr ||= G&Cye,[r.t,{cv:r.y.cv,OC:r},{el:3}];
            lr.sc.z = $(rs&lv).filter(&i,C{
                // and
                return C.y.OC != r
            });
            // delete rs&lv; lets top s&lv its latest change
            delete lr.sc.lv; // is a property out there, lv insides are s&z
            s&lv.push(lr);
        }
        
        s&top = r;
        
        // hangs brain up on the J
        1s&s = C;
        

        
        if (s&lv.length > (s&readlv || 0)) {
            $lv = s&lv.slice(s&readlv || 0);
            s&readlv = s&lv.length;
            G&Hut,lv;
        }
        return C
    
    # send to Hut, the conscruction, give A.on already
    Hut: %acgt:lv
        for (var i = 0; i < lv.length; i++) {
            var v = lv[i];
            // recur W, where A.b starts
            $W = A.on.thing = A.on.thing || {};
            A.W = W;

            // do om, depth of A:n
            T.d = (T.oT && T.oT.d) + 1;
            $A = G&Aye,'om';
            A.om ||= A;
            A.om == A.up and A.mo = A;

            $C = G&Cye,v;
            C.y.A = A;

            A&T = T;
            G&thro,2,C;
            T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
            s&css ||= {};
            s&anc ||= {};
            G&thro,7;
        }
NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    gev: %acgt:ev J
        // J has quick ev respondo?
        G&Aye,'ev',9,{ev:ev}
        
    
    u jc
    n \'of:ev'
    
    # that an event must emerge
    ev 1: %any
        s = c&ev = A&ev;
        ~ev: s.type
        c&type = s.type;
        s&emotion = 3; // down duration

    ev 3:
        // climbs in, makes n elvis
        C.t = "Know";
        $e = C;
        C = A&s = G&Cye,["Typ"];
        c&e = e;
        
        A.t = 'e';
        T.seek = 1;
        
    
    
    n \'of:e'
    # usu has an n of this J going on to make change happen in
    # or if coming from event rather than
    e 1:
        ~e: C.t, s.t, A&sip
    
    

