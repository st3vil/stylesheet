Nonbab: |
    n Stylehut
    
    my $y = &C{ G&aC };
    saybl "US: ", G&ind:T.op,$y;
    
    
Noblar: |
    u i
    tforget: %loose
        "lose"
Yablar: |
    u i
    tforget: %shar
        "find"
Goose: |
    my $c = <<'';
        not &some{ some }
    
    n thi8ng=>-tin for 1..3;
    sayre "Was to : $c";
    
    my $o = G&t,i=>'CoBabbler';
    my ($l) = grep /not-in-blockquote/, split "\n", oc&s;
    saygr "in with: $l";
    
Babblar: | # unpack deceptions in the code for the perl
    # 
    u i
    sheit:
        "hose"
    #c CoArgulate
    CoArgulate:
        s&of || die "No of on ".ki$C;

        s&args ||= join',','A,C,G,T',grep{$_ ne '1'}s&acgt if s&acgt;
        s&args =~ s/[\+ ]/,/sgm;

        s&code && sayre "CoArgu C.t C.y.cv has scode: s&code:\n  ".ki$C;

        my $ara = [];

        exists s&t &&
            Rw conot $C;

        # the nk/gk it wants to wake up
        my $pasn = sub {
            my $v = shift;
            my ($nk,$gk,$more) = $v =~ /^([tycs])?(\S*)(?: (.+))?$/;
            $nk = 'sc' if $nk eq 's';
            $nk ||= 'c';
            $nk && $gk || die"strv:$v -> $nk,$gk from ".ki $C;
            ($nk,$gk);
        };
        (s&nk,s&gk) = $pasn->(s&v) if s&v;
        (s&nnk,s&ngk) = $pasn->(s&v) if s&Nv;

        if (my $nk = s&nk) {
            push @$ara, "my \$".$nk." = C\.".$nk.";";
            if (my $gk = s&gk) {
                # dont remy v=cs in acgts
                my $my = "my " unless s&args =~ /\b$gk\b/;
                warn "Redefined the $gk ($nk\.$gk): ".ki$C if $gk =~ /^[ACGT]$/;
                push @$ara, "$my\$".$gk." = C\.".$nk."\.".$gk.";";
            }
        }

        C.sc.>$_ && die "Given $_: ".ki $C for qw'rg cg';

        s&args ||= 1;
        if (my $args = s&args) {
            #die "wonky C.t   of ".ki $C if C.t =~ /\W/;
            my $gl = "";
            my $und = "_";
            # it becomes something
            my ($sf,$sa) = ('(',')->($A,$C,$G,$T)') if s&subpeel;
            my $sub = "sub {\n";
            if ($args ne '1') {
                my @args;
                my $und = '_';
                if ($args =~ s/^(A,C,G,T,)(?!s$)//) {
                    push @args, 'my ($A,$C,$G,$T,@M)=@_;';
                    $und = 'M';
                }
                push @args, "my (".join(',',map{'$'.$_}
                    split',',$args).',@Me) = @'.$und.";";
                unshift @$ara, @args;
            }
            c&s = $sf
                ."sub {\n"
                .join("",map{"$_\n"} @$ara)
                .c&s
                ."}"
                .$sa
                .";";
        }
    #c CoBabbler
    bitsof_babble:
        my $p;
        p.alive = qr/\$[\w]*[\w\->\{\}]+/;
        p.dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
        p.oing = qr/\w*p.alive|p.dotha|[-\w]{8,}/;
        p.oint = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
        p.mwall = qr/(?:= |if |unless |^\s*)/;
        p.sur = qr/ if| unless| for| when|,?\s*$|;\s*/;
        $p

    CoBabbler: %right
        my $sc; # C.sc.* to be set from this encoding
        my $p = G.sc.bitsof_babble ||= G&bitsof_babble;
        
        my @s;
        my $indbe;
        my $inend;
        my $indun;
        my $angt = '<'.'<';
        for my $l (split "\n", c&s) {
            my $s = $l;
            # things:
            $s =~ s{^(\w+)(?: (-?\w+))?:(?: (%.+))?$}
                {n $1 =>'$2',$angt'',"$3"}smg;
            if ($indbe) {
                if ($indun eq 'NEXT') {
                    $s =~ /^(\s+)/ || die "Must Indunext:\n$s[-1]\n$s";
                    $indun = $1;
                }
                if ($s =~ $indbe) {
                    $s =~ s/^(\s*)\.(\s*)$/$1$2/;
                    $s =~ s/^$indun//
                        if defined $indun;
                    push @s, $s;
                    next;
                }
                else {
                    undef $indbe;
                    undef $indun;
                    if ($s !~ /^\s*$/) {
                        if ($inend) {
                            pop @s  if $s[-1] eq '';
                            push @s, $inend;
                        }
                    }
                    else {
                        $s = $inend if $inend;
                    }
                    undef $inend;
                }
            }
            my $ze = qr/$angt['"](\w*)['"]/;
            if ($s =~ /^(\s*)(?!#)\S.*$ze/) {
                if ($2) {
                    # for <#<'EOD' til ^EOD, etc
                    $indbe = qr/^(?!\Q$1\E)/;
                }
                else {
                    $indbe = qr/^($1\s+|\s*$)/;
                    $indun = 'NEXT';
                    $s =~ s/$ze/$angt.($1?"'$1'":"'STEVE'")/e;
                    $inend = 'STEVE' if !$1;
                }
            }
            
            #c with the not-in-blockquote intelising
            # say things depending on A.V (verbosity)
            my $sw = {};
            $sw.>$_ = 'say' for qw'saygr saybl sayyl sayre say';
            %$sw = () if C.sc.nobasay;
            for (keys %$sw) {
                my $if = $_ ne 'sayre' ? "A\.V && " : "";
                $s =~ s/^(\s*)$_ ([^\n]+?)((?: (?:for|if) .+)?;?)$/${1}${if}G\.h->(\$A,\$C,\$G,\$T,'$sw->{$_}','$_',$2)$3/sgm;
            }

            #
            # 22Cs&blue -> A.2.2.c.s.sc.blue
            for my $l (qw'y c s') {
                my $nk = $l eq 's' ? 'sc' : $l;
                $s =~ s/\b(up|\d+|A\w+?)(C)?$l\&(\w+)/
                    my ($net,$see,$gks) = ($1,$2,$3);
                    if ($net eq 'up') {
                        $net = join'.','A',$net;
                    }
                    elsif ($net =~ m{^A.+}) { # A.L...
                        # TODO split lc like words, know cs is c.s, etc
                        $net = join'.',split'',$net;
                    }
                    else { # numbers
                        $net = join'.','A',split'',$net;
                    }
                    $see = ".c\.s" if $see;
                    $gks = "\.$gks" if $gks ne 'C';
                    "$net$see\.$nk$gks"
                /smeg;
            }

            # s&eo -> C.sc.eo etc
            $s =~ s/\bs\&(\w+)/C\&$1/sgm;
            $s =~ s/\bA\&(\w+)/A\.c\.$1/sgm;
            $s =~ s/\ba\&(\w+)/A\.sc\.$1/sgm;
            $s =~ s/\b((?!u)\w)s\&(\w+)/$1\.sc\.$2/sgm;
            $s =~ s/\b(\w)c\&(\w+)/$1\.c\.$2/sgm;
            $s =~ s/\b(\w)y\&(\w+)/$1\.y\.$2/sgm;
            
            # S / T
            # label-making do or return sleepomatics
            my @num;
            for my $sym ('S','T') {
                # become gotoable, for test frames
                $s =~ s{^(\s*)$sym(?: (\S+.*?))?\s*$}{
                    my $l = $2;
                    (my $label = $l) =~ s/\W+/_/sgm;
                    if ($label eq '' && $sym eq 'S') {
                        $label = $l = 1 + @num;
                        push @num, $label;
                    }
                    $label = $sym."_$label: ";
                    qq[$1${label}G\&$sym,"doming","$l" || return;]
                }sgme;
            }
            sc.num = @num if @num;

            # look for th/$ing in A.?.th.ing and A.c.?.th.ing
            # trip if so
            for my $sym ('trip') {
                $s =~ s{^(\s*)$sym (\S+)\s*$}{
                    my $ind = $1;
                    # 
                    my (@n) = split '/', $2;
                    my @opt = map {
                        my $st = $_;
                        my @lot;
                        join " && ", $st, map {
                            push @lot, $_;
                            $st . join('',map{
                                /^\w+/ && !/\./ ? "\.$_" : "\.>$_";
                            } @lot);
                        } @n;
                    } "A\.$sym", "A\.c\.$sym";
                    my $in = "(".join(" || ", @opt).")";
                    my $quot = join',',map { /^\w+/ && !/\./ ? qq{"$_"} : $_ } @n;
                    "$ind$in && G&"."$sym,$quot;"
                }sgme;
            }

            c&s =~ s/^(\w+:)\s+$/$1/smeg && sayre "Blockquoter whitespace trimmed";

            # little sub maker
            # G may like to track lamda meta in a coderef => $D like way
            #    wants to be a function the sub passes through
            # one word args assumed to be many single letter args
            my $codes = sub {
                my @r = split',',shift;
                my $acgt;
                $acgt = shift(@r) if $r[0] eq 'acgt';
                $acgt = 1 if $r[0] =~ s/^acgt//;
                @r = split '', $r[0] if @r == 1;
                unshift @r, qw'A C G T' if $acgt;
                my $arg = " my (".join(',',map{'$'.$_}@r).") = \@_;"
                    if @r;
                "sub {".$arg
            };
            $s =~ s[(\W)\&(\w+(?:,\w+)*)?\{][$1.$codes->($2)]smeg;

            # each etc $data {    into:
            # while (my ($e,$tv) = each %$data) {
            # while (my ($t,$c) = each %$tv) {
            #   so the value tv is for t-ing into
            # DIY closing brackets
            # could replace with G&chew-ish call if more spec
            # and know indents to close
            my $doi = sub {
                my ($ind,$in,$from) = @_;
                my @in = split ',', $in;
                @in = split '', $in[0] if @in == 1;
                my @open;
                while (@in) {
                    my $s = 'while (my ($'.shift(@in).',$';
                    my $v = @in > 1 ? 
                        $in[0].'v' : shift(@in);
                    $s .= $v;
                    $s .= ') = each %{'.$from.' }) {';
                    $from = '$'.$v;
                    push @open, $s;
                }
                @open = map { $ind.$_ } @open;
                join "\n", @open;
            };
            $s =~ s/^(\s*)each (\w+(,\w+)*) (\S+) \{(\s*)$/
                $doi->($1,$2,$4);
            /smeg;
            #c expect closing brackets and insert J
            
            # n $C etc
            my $gh = "G\.h".'->($A,$C,$G,$T';
            $s =~ s/(p.mwall)(u|n) (.+?)(;| for(\s*$| .+?))?$/
                "${1}$gh,\"$2\",$3=>'')".($4||';')/smeg;
            
            # m $C passes $M
            $s =~ s/(p.mwall)(m) (.+?)(;| for .+?)?$/
                "${1}$gh,\"$2\",\$M,$3=>'')".($4||';')/smeg;
            
            # C&hs = 388 # C.sc.>hs
            $s =~ s/\bC&(\w+)\b/C\.sc\.$1/g;
            $s =~ s/\bc&(\w+)\b/C\.c\.$1/g;
            # e&you -> G&e,"you"
            $s =~ s/\b([e])&(\w+)\b/G\&$1,"$2"/g;
            
            # also e&so -> G&e,"so"...  generalised name pickup
            # spiral slumping. us&hJ works sometimes somehow?
            $s =~ s/ ((?!G)\w+)\&(p.oint)/ G\&$1,"$2"/g;
            
            # G&thing:"with space in args";
            $s =~ s/(p.oing|\w+)\&(p.oint)(:\S+[^\n;]+)(;)?/
                my ($on,$p,$e,$t) = ($1,$2,$3,$4);
                $e =~ s{^:}{,};
                ($on,my$in) = ("G\.h",'$A,$C,$G,$T,')
                    if $on eq 'G';
                my $s = $on."->($in\"$p\"$e)$t";
                $s = '$'.$s if $on !~ m{\.};
                $s
            /smge;
            # G&usi,$s -> G.h->(acgts)
            $s =~ s/(p.oing|\w+)\&(p.oint)(,[^\s;]+)?(;)?/
                my ($on,$p,$e,$t) = ($1,$2,$3,$4);
                ($on,my$in) = ("G\.h",'$A,$C,$G,$T,')
                    if $on eq 'G';
                my $s = $on."->($in\"$p\"$e)$t";
                $s = '$'.$s if $on !~ m{\.};
                $s
            /smge;
            # $sc.>$k -> $sc->{$k}
            $s =~ s/(p.oing)((?:\.>p.oing)+)/
                join '->', $1, map {'{"'.$_.'"}'}
                grep {$_} split m{\.>}, $2;
            /smge;
            
            #c Rw
            while ($s =~ /(Rw (p.oint)(?:(?!p.sur) (.+?))?)p.sur/gsm) {
                my ($old, $op, $oa) = ($1, $2, $3);
                my $g;
                $g ||= '$G';
                
                my $ne = ""; # hidden reverse
                $ne = $1 if $oa =~ s/(p.sur)$//;
                
                my @n;
                my @m;
                # want to mix {m m m %$ar m m} whereever + is
                my $wanr = $oa =~ s/^\+ ?//;
                $wanr = 'stick' if $oa =~ s/^- ?//;
                for (split /\,| |\, /, $oa) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+(:|=))?\S+)$/) {
                        my ($na, $fa, $wa) = ($1, $2, $3);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/(:|=)$//;
                            if ($wa eq '=') {
                                $na = '"'.$na.'"';
                            }
                        }
                        $na = '$'.$na unless
                            $wa eq '=' || $na =~ /^\S+\.\S/;
                        push @n, "$fa=>$na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '$ar' if (!@n || $wanr) && $wanr ne "stick";
                push @n, "m=>[".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                
                my @e;
                push @e, '"'.$op.'"';
                push @e, join(",",@n);
                my $en = join ",", @e;
                
                my $wa = $g.'->{w}->($A,$C,$G,$T,'.$en.')'.$ne;
                $s =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n $s";
            }
            
            # sc.k -> $sc->{k};
            $s =~ s/([A-Za-z_]\w*)((?:\.\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/segm;
            # 
            push @s, $s;
        }
        push @s, $inend if $indbe && $inend;
        c&s = join "\n", @s;
        $sc

