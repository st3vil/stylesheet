Bystand: | # run tests in a container
    G&heading,'Hz:50';
    1s&ein.Exprect = &acgts{
        $d = G&E:'hC -1';
        delete 4s&Jtv.Expect;
        e Expect W $testname:dc&s %
    };
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    #1s&step ||= 1;
    #1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    
    ('LetsOsc Serialise JSTesti '
    +'iooia iooiata iooiatal gref grefcodes '
    +'BuildACastle encodings')
    .split(' ').map(&s{
        s = 't/'+s
        n $s  $s:s %doe:Exprect,ma:1em
    });
    
Fly: | # run tests without container
    G&heading;
    ys&ml = '4em';
    # < pick the last Bystander/dragdrop in
    #G&way,'t/iooiatal',ar;
    G&way,'t/BuildACastle',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];
t/JSTesti: | # some #msgs noise
    G&heading;
    1s&empathy = 4;
    
    # how does it work?
    # a bunch of timers?
    # C-ing
    # have a list of things that have .A, etc.
    # < should be able to high-power -yod to do all this...
        $msgbet = &from,to{
            $msgs = 4s&msgs;
            $mes = $(msgs).children().get();
            if (from) {
                from = mes.indexOf(from);
                from >= 0 and mes = mes.slice(0,from+1);
            }
            if (to) {
                to = mes.indexOf(to);
                to > 0 and mes = mes.slice(to);
            }
            return mes
        };
    
    # get ready to not async
    $see = G&Cye,['starting'];
    n seeup -jod $s:see %
    # but make sure it's samey
    delete 1s&Jtv.seeup;
    
    # put log thing into
    $was = 4s&msgs;
    try {
        4s&msgs = $('<notevenattached>')[0];
        $from = ~From
        
            ~W: ki(G&Cye,['Thumb'] )
            ~W: ki(G&Cye,['Tdhumb','W',{},'flac:please'] )
            ~pi: ki(G&Cye,['Thumb','-lattice_331'] )

            
            $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
            $see = G&Cye,['tango',22,{e:az},{la:'hn',na:3,z:[az]}];

            see.y.A = A.up;

        n seeup -jod $s:see %

        ~>48 glimpe: '>7 lav', '>23:gl sfiafifiafiiaf'

        $to = ~To
    }
    catch(er) {
        4s&msgs = was;
        throw er
    }
    
        $said = msgbet(from,to);
        4s&msgs = was;
    
    said.length > 50 and throw "Too big: "+said.length
    
    $n =
    n said -rogram $s:said %
    #n.sc.not = 1;
    # v should be able to see where n came from...
    G&e,['TripDeck'],['have','',{s:n}];
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
pi/rogram: | # see msgs
    # the log messages emit while program builds itself
    # said is noticable things
    # sew into one big notice, plant
    G&way,'Duning',ar;
    # ^ wants to allow us to work as one
    # < make implicit:
    if (s.constructor == Array) {
        each in s {
            m ro -rogram $s:n %
        }
        return
    }
    
    # < smaller/implicit: F index types
    if (typeof s != 'object' || 
        typeof s.log != 'object' || 
        typeof s.set != 'function') {
        # some kind of run-time cooptable assertion point
        # sudden widening of the type of display
        # shows progressing-ness
        return T.ypco =
        n thing -jod $s:s %
    }
    
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    $l = s.log;
    # has the 'main thing: obj, clue, etc' all as string
    $text = s.textContent;
    # and with styles
    $html = s.innerHTML;
    text.length && !html.length and c&nocolour = 1;
    
    # A - jobby piles
    $sc = ex({},l.sc);
    $Y = sc.A; delete sc.A;
    s&A = Y;
    # < should be ki'd when it happens, for cv
    n A 3 $s:ki(Y,2)
    $Acv = sc.Acv; delete sc.Acv;
    Acv != Y.cv &&
        n scAcv 31 $s:cvf(Acv) %fs:75%,bri:9
    
    n Asip 3 $s:Yc&sip %fs:70%,ma:0.5em
    
    # B - stack of calls
    # this is a pi/Bye minima, into one intag'd C
    $B = sc.B; delete sc.B;
    s&B = B;
    $bit = B.t;
    Bs&way and bit += ':'+Bs&way.t;
    n Bt 4 $s:bit %fs:50%,ab:1,left:0em,mt:-0.5em,hue:-100deg
    
    
    # M of details after the message
    # < explore them in 3d
    # may $use:this $pat:ern to param the G&c ~ thing
    #   to impart styles/names like the >dd:tag stylecode does
    $inter = [];
    each it sc.M {
        if (typeof t == 'string' || typeof t == 'number') {
            # >dd:tag stylecode
            $tee = (''+t).replace(/^>\S+/,''); 
            text.includes(tee) and continue
        }
        inter.push(t);
    }
    delete sc.M;
    
    
    # how much the data is allowed to use its own styles
    # is very important
    if (c&nocolour) {
        n text 1 $s:l.t %hue:60deg,fs:120%
        #l.t == '>48 glimpe' and debugger
        if (l.t != text)
            n nowtext 1 $s:text %hue:180deg
    }
    else {
        n says 1 $s:html,ht:1 %
    }
    
    $ts = sc.now + '';
    n timestamp 6 $s:ts %fs:60%
    delete sc.now;
    # if last in M of many -rograms,
    # turn timestamps into deltas, or hide if <5ms?
    #   sensitivities, language pools
    
    # attach M not included in message
    inter.length &&
        n inM 2 $s:ki(inter) %hue:240deg
    # -jod, a base types-handler,
    #   goes phorensic with leftovers
    Object.keys(l.c).length > 0 &&
        n c -jod_2 $s:l.c %
    Object.keys(sc).length > 0 &&
        n sc -jod_2 $s:sc,dl:4 %ml:0.3em
    
    
    S as last $N
    # ^ gets M of the 9 of the -rogram of many -rograms
    # assume only -rogram in this M...
    
    # top last
    # which direction to go in? replication something?
    N = N.slice().reverse();
    $la;
    each in N {
        $g = n.y.A.ground;
        $t = gs&z.filter(&s{ return s.t == 'timestamp' })[0];
        $delta = la && tc&s - la;
        $interval = delta >= 0 ? delta : delta * -1;
        la = tc&s;
        interval < 0.002 and delta = 0;
        !delta and t.sc.not = 1; continue
        tc&s = G&thime,delta;
        t.t = 'delta';
    }
    
pi/ABf: | # Dune of things s&A and s&B
    ys&dis = 'block';
    
    # is in a many of a $s=C-rogram
    # we want to:
    #  1 re-present the things within it,
    #  2  regroup many of ourselves, while tweaking 1
    #  3 so it can recreate itself as efficiently as possible
    #  ^ that lab
    # M hier etc etc...
    # want to define a schema of atoms so to make a loader of min syntax
    # 
    # history: Matu, the female thingk (s/84?)
    # better is Lis's -pi things (j/83)
    #   passed s 9 before it
    #  Desire to change
    #  Batch doing
    #  Arrangement to
    
    
    # minter, 'mi' W,
    # mutable behavioiur control
    # and intro everything:
    # var ve = [1,2,3,4]; ve.splice(-1,0,[1,2,3]); ve
    
    
    # going in the front door, anywhere along sJ ss stop sz
    #   depending on the fibre the C is made of (z/yin/Js)
    
    # having a pool of atoms, A etc inside the -rogram
    #   introduce everything once, link to it yonderly
    #   the smaller/link representations can be enlarged,
    #   and the pointer from such detail annointments,
    #   given to T the experiments in the other hemisphere
    
    # to get this function to do the many grouping!
    # A&S takeover, throw /^waits/ with T.not=1 from n/J@6
    #   to continue n/M@2 (rc&M=[-rogram+])
    # some sections being registered for attention,
    #   occurring once, to r...
    # interesting list processiona
    
    #n te 01 $s:cev %hue:-90
    #n abf -jod $s:s
    $io = G&way,'iooia';
    $F = io.F;

    # yes, o shall be able to do this, as if 
    $se = F(s,'*');
    
    
    
    
    
    
    #n sel -jod $s:se
    #n onA -jod $s:ss&A
    $Y = ss&A;
    
    ys&ml = Yc&ip.length + 'em';
    # convert Yc&ip.length to indent,
    #   fit col's stuff right aligned in it
    
    #n sip 1 $s:Yc&sip %fs:66%,hue:100deg
    # to persist over a series of itselves, collectivising info
    $m = M = [];
    $col = &Y{
        # in the reoccurring cloud of A attached to messages,
        !Yc&sip and return
        $yi = A.ontula.indexOf(Y);
        if (yi >= 0) {
            # thing in another place
            $K = A.ontula[yi];
            $te = 'had '+Yc&sip;
            n $te 1 $s:ki(K,2) %fs:50%,hue:100deg
        }
        else {
            # thing said for the first time
            $te = 'have '+Yc&sip;
            $labit = Yc&ip.slice(-1)[0];
            $sa = labit+': '+ki(Y,3);
            Yc&s and sa += '  '+G&intag:'>27 '+ki(Yc&s,2)
            
            m $te  $s:sa,ht:1 %dis:block,fs:66%,hue:100deg
            
            A.ontula.push(Y);
            Y.up and Y.up != Y and col(Y.up)
        }
    };
    
    col(Y);
    M = ar.M;
    #debugger;
    each in se {
        #M.length &&
        #    m gap  s:',' %fs:150%,bri:1
        $sa = n.t+' '+n.y.cv;
        #m ism  $s:sa
        # Core light ables
        (n.t == 'says' ||
        n.t == 'Bt' ||
        n.t == 'delta') &&
            m $n
    }
    m.map(&s{ M.push(s) });
pi/Aye: |
    # yaya
    # 
Resz: | # get into automate bystandings...
    # Inside
    G&heading;
        $L = G&e,['Launch'] .sc.J;
        #debugger;
        if (!Ls&child) {
            ~Chilute: C.t
        }
        else {
            $Y = A;
            A = Ls&child;
            if (!Ls&shrank) {
                $(A.on.parentNode).css('top','20%').css('height','')
                .find('#msgs').css('min-height','20em');
                Ls&shrank = 1;
            }
            $r =
            G&e,['Rests'];
            r = rs&J;
            A = Y;
            n Resto -jod $s:r
        }
    # push self once
    !1s&brains && G&yl:700,&{ G&e,['Resz'] };
Rests: | # automate Bystandings
    # yup3
    G&u,['NutIns'];
    G&clusp;
    
    G&heading;
    G&way,'Doming',ar;
    $b = A&beready;
    
    S 1 Get list of tests
    
    $r = A&intv(G&e,['Bystand'] , "from");
    $z = rs&z || [];
    $sz = z.slice().filter(&x{ return xs&doe == 'Exprect' });
    !sz.length and A&til("No Exprects on Bystand")
    1c&testlist = sz;
    1c&testN = [];
    
    S 2
    
    $N = 1c&testN;
    $l = N.slice(-1)[0];
    if (!l || ls&complete) {
        $x = 1c&testlist[N.length];
        x and N.push(l = G&Cye,[x.t,'-runnedtest'] );
    }
    
    each in N {
        n $n
    }
    
    # test completes, we accept minor noises
    if (!ls&started) {
        delete 4s&Jtv.Expect;
        1c&Expect =
        e Expect W $testname:l.t
        ls&started = 1;
        A&slowstep();
        A&til("started")
    }
    elsif (!ls&revisable) {
        #$r = G&e,['Expect'];
        b(1c&Expect, "Expecting");
        
        # cached or random asyncs with throw us
        $r = 1c&Revisit ||= G&e,['Revisit'];
        # will still check it's ready...
        A&intv(r, "resulter");
        $t = A&intv(r, "results for this test", l.t);
        b();
        n forthis -jod $s:t
        
        
        # allow Doming more loops of this step since nested
        A&slowstep();
        
        !t and A&til("wait for our results "+l.t)
        b();
        
        $d = A&intv(t,'result diffrance','diff');
        !t and A&til("waits diff "+l.t)
        b();
        d = A&intv(d,'intoself');
        
        #c now start looking at the difference of result
        # continue only if minor changes
        
        $j = ts&J;
        $line = 1; # first 4 lines are u versions
        $mind_changes; # which is always accepted
        $dq = []; # [[what,s]+];
        $hier = ['body','Inside','Around'];
        
        each in ds&z {
            $what = n.t.split(' ');
            $lines = nc&s.split("\n").length - 1;
            lines and line += lines
            if (line <= 4) {
                what != 'same' and mind_changes = 1
                continue
            }
            $be = dq.slice(-1)[0];
            if (be) {
            $wwhat = be[0];
            $was = be[1];
            
            $known_progression;
            each ih hier {
                $becomes = hier[i+1];
                !becomes and break
                if (wwhat == 'gone' &&
                    (was == h || was == h.slice(0,3))
                && what == 'new' &&
                    (nc&s == becomes || nc&s == becomes.slice(0,3))) {
                    known_progression = 1;
                    break
                }
            }
            known_progression and continue
            
            nc&s == ',on:?[object Object]?' and continue
            nc&s == ':2' and continue
            }
            
            dq.push([what,nc&s]);
        }
        
        
        $dif = {};
        each in dq {
            $what = n[0];
            $s = n[1];
            dif[what] ||= 0;
            dif[what] += s.length;
        }
        
        # major gone sections may indicate a need to reserialise
        if (dif.gone > 150 && dif.new < 50
            && !jc&tried_reStringing) {
            debugger;
            jc&String++;
            jc&tried_reStringing = 1;
            A&til("Needing to reserialise");
        }
        # changes only in the mind, or not at all...
        elsif (!dif.new && !dif.gone) {
            if (mind_changes) {
                debugger;
                # -visit's C, the n Above the root n
                $D = j.sc.root.y.A.up.c.s;
                Ds&pi != 'visit' and throw "Isn't visit"
                $was = D.c.Q.sc.P.c.String;
                $is = js&String;
                was = was.split("\n");
                is = is.split("\n");
                $now = [];
                each iz is {
                    i <= 3 and now.push(z);
                }
                each iz was {
                    i > 3 and now.push(z);
                }
                now = now.join("\n");
                
                $Q =
                js&questi ||=
                G&Cye,[l.t,'',{of:'W',s:now}];
                js&obj ||= [ G&ting,Q ];
                
                # -visit's c&Qs&Pc&String
                # with mind version of js&String
                G&e,['Expect'];
            }
        }
        else {
            # run stops, human intervenes
            debugger;
        }
        # minor changes, update the mind section and commit
        1s&step_tries = 1;
        ls&revisable = 1;
    }
    #elsif (!ls&complete) {
    #    #ls&complete = 1;
    #}
    #else {
    #    !ls&complete and A&til("doing "+l.t)
    #}
    #ls&complete = 1;
    #1c&testlist[N.length] and A&til("More tests...")
    
    
    
    if (0) {
    each it 1c&testlist {
        1c&testN[i] and continue
        n running -jod $s:t
        G&e,['Bystand'],['click','',{p:t.t}];
        $l =
        m t.t -jod s:running
        1c&testN.push(l);
        break
    }
    }
    
    S 3
    n Done 6 s:Done
    S 0
    n hmm 6 s:hmmew
    #G&e,['Revisit'],['click','',{p:"t/LetsOsc\t3\tString\t2"}]
    
    
pi/runnedtest: |
    G&heading;
    # capture results and ...

