Bystand: |
    G&heading,'Hz:50';
    1s&ein.Exprect = &acgts{
        $d = G&E:'hC -1';
        delete 4s&Jtv.Expect;
        e Expect W $testname:dc&s %
    };
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    #1s&step ||= 1;
    #1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    
    't/LetsOsc t/Serialise t/JSTesti'.split(' ').map(&s{
        n $s  $s:s %doe:Exprect,ma:1em
    });
    #G&s;
    n More  s:twoit
    

pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];

t/JSTesti: | # test the JS bits
    G&heading;
    
    # how does it work?
    # a bunch of timers?
    # C-ing
    
    # put log thing into
    $from =
    1s&from ||= G&c,'from...';
    
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Thumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    n seeup -jod $s:see %
    
    ~>48 glimpe: '>7 lav', '>23:gl sfiafifiafiiaf'
    
    $to = G&c,'to...';
    1s&from = G&c,'from...';
    
    $msgbet = &from,to{
        $msgs = 4s&msgs;
        $mes = $(msgs).children().get();
        if (from) {
            from = mes.indexOf(from);
            from >= 0 and mes = mes.slice(0,from+1);
        }
        if (to) {
            to = mes.indexOf(to);
            to > 0 and mes = mes.slice(to);
        }
        return mes
    };
    $said = msgbet(from,to);
    
    $n =
    n said -rogram $s:said %
    n.sc.not = 1;
    G&e,['TripDeck'],['have','',{s:n}];
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
pi/rogram: | # see msgs
    # the log messages emit while program builds itself
    # said is noticable things
    if (s.constructor == Array) {
        each in s {
            m ro -rogram $s:n %
        }
        return
    }
    if (typeof s != 'object' || 
        typeof s.log != 'object' || 
        typeof s.set != 'function') {
        # some kind of run-time cooptable assertion point
        # sudden widening of the type of display
        # shows progressing-ness
        T.ypco =
        n thing -jod $s:s %
    }
    
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    $l = s.log;
    # has the 'main thing: obj, clue, etc' all as string
    $text = s.textContent;
    # and with styles
    $html = s.innerHTML;
    text.length && !html.length and c&nocolour = 1;
    
    # A - jobby piles
    $sc = $.extend({},l.sc);
    $Y = sc.A; delete sc.A;
    s&A = Y;
    # < should be ki'd when it happens, for cv
    n scA 3 $s:ki(Y,2)
    
    n scAsip 3 $s:Yc&sip %fs:60%,ma:0.5em
    
    
    # B - stack of calls
    # to attach
    
    # M of details after the message
    # < explore them in 3d
    # may $use:this $pat:ern to param the G&c ~ thing
    #   to impart styles/names like the >dd:tag stylecode does
    $inter = [];
    each it sc.M {
        if (typeof t == 'string' || typeof t == 'number') {
            # >dd:tag stylecode
            $tee = (''+t).replace(/^>\S+/,''); 
            text.includes(tee) and continue
        }
        inter.push(t);
    }
    delete sc.M;
    
    
    # how much the data is allowed to use its own styles
    # is very important
    if (c&nocolour) {
        n text 1 $s:l.t %hue:60deg,fs:120%
        #l.t == '>48 glimpe' and debugger
        if (l.t != text)
            n nowtext 1 $s:text %hue:180deg
    }
    else {
        n says 1 $s:html,ht:1 %
    }
    
    $ts = sc.now + '';
    n timestamp 6 $s:ts %fs:60%
    delete sc.now;
    # if last in M of many -rograms,
    # turn timestamps into deltas, or hide if <5ms?
    #   sensitivities, language pools
    
    # attach M not included in message
    inter.length &&
        n inM 2 $s:ki(inter) %hue:240deg
    # -jod, a base types-handler,
    #   goes phorensic with leftovers
    Object.keys(l.c).length > 0 &&
        n c -jod_2 $s:l.c %
    Object.keys(sc).length > 0 &&
        n sc -jod_2 $s:sc,dl:4 %ml:0.3em
    
    S 1 many
    
    # the 9 of the -rogram of many -rograms
    $u = A.n.up.c.s;
    # assume only -rogram in this M...
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    if (uc&M.slice(-1)[0] == C) {
        # last one!
        $Me = uc&M.slice();
        Me.reverse();
        $la
        each in Me {
            $g = n.y.A.ground;
            $t = gs&z.filter(&s{ return s.t == 'timestamp' })[0];
            $delta = la && tc&s - la;
            $interval = delta >= 0 ? delta : delta * -1;
            la = tc&s;
            interval < 0.005 and delta = 0;
            !delta and t.sc.not = 1; continue
            tc&s = G&thime,delta;
            t.t = 'delta';
        }
    }
    
TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    n ies -jod_2 $s:se
    se = se.slice(5,15);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.ontula = [];
    # and that they build up awareness bottom up
    yc&reverse = 1;
pi/ABf: |
    ys&dis = 'block';
    $cev = "msg"+C.y.cv;
    #n te 01 $s:cev %hue:-90
    #n abf -jod $s:s
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n sel -jod $s:se
    #n onA -jod $s:ss&A
    $Y = ss&A;
    n sip 1 $s:Yc&sip %fs:66%,hue:100deg
    # to persist over a series of itselves, collectivising info
    $m = M =[];
    $col = &Y{
        $yi = A.ontula.indexOf(Y);
        if (yi >= 0) {
            $K = A.ontula[yi];
            #n had 1 $s:ki(K,2)
        }
        else {
            $te = 'have '+Yc&sip;
            $sa = Yc&sip+': '+ki(Y,2);
            m have  $s:sa %dis:block,fs:66%,hue:100deg
            A.ontula.push(Y);
            Y.up and Y.up != Y and col(Y.up)
        }
    }
    col(Y);
    M = ar.M;
    #debugger;
    each in se {
        #M.length &&
        #    m gap  s:',' %fs:150%,bri:1
        $sa = n.t+' '+n.y.cv
        #m ism  $s:sa
        n.t == 'says' &&
            m $n
    }
    m.map(&s{ M.push(s) });
PseudoF: | # to develop limbs to G&F
        $m;
        $p = &r{
            m = d.match(r);
            !m and return
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        $dstart = d;
        $v;
        
        # all Array of items, assume the spec also de-arrays it
        s.constructor == Object and s = [s];
        
        if (p(/^\* ?/)) {
            $S = s;
            s = [];
            each in S {
                if (ns&J) {
                    $j = ns&J;
                    !j and continue
                    $os = js&s;
                    !os and continue;
                    # skips over 9
                    $t = oss&top;
                    !t || !ts&z and continue;
                    ts&z.map(&z{
                        s.push(z);
                    });
                }
                else {
                    continue
                }
            }
        }
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ 
                s && s[nk] && s[nk][gk] != null and v = s[nk][gk]; return 1
            });
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s
        

