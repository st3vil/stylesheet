Bystand: |
    G&heading,'Hz:50';
    1s&ein.Exprect = &acgts{
        $d = G&E:'hC -1';
        delete 4s&Jtv.Expect;
        e Expect W $testname:dc&s %
    };
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    #1s&step ||= 1;
    #1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    
    't/LetsOsc t/Serialise t/JSTesti t/iooia'.split(' ').map(&s{
        n $s  $s:s %doe:Exprect,ma:1em
    });
    
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];
t/JSTesti: | # some #msgs noise
    G&heading;
    1s&empathy = 4;
    
    # how does it work?
    # a bunch of timers?
    # C-ing
    
    # put log thing into
    $from =
    1s&from ||= G&c,'from...';
    
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Tdhumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    n seeup -jod $s:see %
    
    ~>48 glimpe: '>7 lav', '>23:gl sfiafifiafiiaf'
    
    $to = G&c,'to...';
    1s&from = G&c,'from...';
    
    $msgbet = &from,to{
        $msgs = 4s&msgs;
        $mes = $(msgs).children().get();
        if (from) {
            from = mes.indexOf(from);
            from >= 0 and mes = mes.slice(0,from+1);
        }
        if (to) {
            to = mes.indexOf(to);
            to > 0 and mes = mes.slice(to);
        }
        return mes
    };
    $said = msgbet(from,to);
    said = said.slice(10,30);
    
    $n =
    n said -rogram $s:said %
    #n.sc.not = 1;
    # v should be able to see where n came from...
    G&e,['TripDeck'],['have','',{s:n}];
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
pi/rogram: | # see msgs
    # the log messages emit while program builds itself
    # said is noticable things
    # sew into one big notice, plant
    G&way,'Duning',ar;
    # < make implicit:
    if (s.constructor == Array) {
        each in s {
            m ro -rogram $s:n %
        }
        return
    }
    
    # < smaller/implicit: F index types
    if (typeof s != 'object' || 
        typeof s.log != 'object' || 
        typeof s.set != 'function') {
        # some kind of run-time cooptable assertion point
        # sudden widening of the type of display
        # shows progressing-ness
        return T.ypco =
        n thing -jod $s:s %
    }
    
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    $l = s.log;
    # has the 'main thing: obj, clue, etc' all as string
    $text = s.textContent;
    # and with styles
    $html = s.innerHTML;
    text.length && !html.length and c&nocolour = 1;
    
    # A - jobby piles
    $sc = $.extend({},l.sc);
    $Y = sc.A; delete sc.A;
    s&A = Y;
    # < should be ki'd when it happens, for cv
    n A 3 $s:ki(Y,2)
    $Acv = sc.Acv; delete sc.Acv;
    Acv != Y.cv &&
        n scAcv 31 $s:cvf(Acv) %fs:75%,bri:9
    
    n Asip 3 $s:Yc&sip %fs:70%,ma:0.5em
    
    # B - stack of calls
    # this is a pi/Bye minima, into one intag'd C
    $B = sc.B; delete sc.B;
    s&B = B;
    $bit = B.t;
    Bs&way and bit += ':'+Bs&way.t;
    n Bt 4 $s:bit %fs:50%,ab:1,left:0em,mt:-0.5em,hue:-100deg
    
    
    # M of details after the message
    # < explore them in 3d
    # may $use:this $pat:ern to param the G&c ~ thing
    #   to impart styles/names like the >dd:tag stylecode does
    $inter = [];
    each it sc.M {
        if (typeof t == 'string' || typeof t == 'number') {
            # >dd:tag stylecode
            $tee = (''+t).replace(/^>\S+/,''); 
            text.includes(tee) and continue
        }
        inter.push(t);
    }
    delete sc.M;
    
    
    # how much the data is allowed to use its own styles
    # is very important
    if (c&nocolour) {
        n text 1 $s:l.t %hue:60deg,fs:120%
        #l.t == '>48 glimpe' and debugger
        if (l.t != text)
            n nowtext 1 $s:text %hue:180deg
    }
    else {
        n says 1 $s:html,ht:1 %
    }
    
    $ts = sc.now + '';
    n timestamp 6 $s:ts %fs:60%
    delete sc.now;
    # if last in M of many -rograms,
    # turn timestamps into deltas, or hide if <5ms?
    #   sensitivities, language pools
    
    # attach M not included in message
    inter.length &&
        n inM 2 $s:ki(inter) %hue:240deg
    # -jod, a base types-handler,
    #   goes phorensic with leftovers
    Object.keys(l.c).length > 0 &&
        n c -jod_2 $s:l.c %
    Object.keys(sc).length > 0 &&
        n sc -jod_2 $s:sc,dl:4 %ml:0.3em
    
    
    S as last $N
    # ^ gets M of the 9 of the -rogram of many -rograms
    # assume only -rogram in this M...
    
    # top last
    # which direction to go in? replication something?
    N = N.slice().reverse();
    $la;
    each in N {
        $g = n.y.A.ground;
        $t = gs&z.filter(&s{ return s.t == 'timestamp' })[0];
        $delta = la && tc&s - la;
        $interval = delta >= 0 ? delta : delta * -1;
        la = tc&s;
        interval < 0.002 and delta = 0;
        !delta and t.sc.not = 1; continue
        tc&s = G&thime,delta;
        t.t = 'delta';
    }
    
pi/ABf: | # Dune of things s&A and s&B
    ys&dis = 'block';
    
    # is in a many of a $s=C-rogram
    # we want to:
    #  1 re-present the things within it,
    #  2  regroup many of ourselves, while tweaking 1
    #  3 so it can recreate itself as efficiently as possible
    #  ^ that lab
    # M hier etc etc...
    # want to define a schema of atoms so to make a loader of min syntax
    # 
    # history: Matu, the female thingk (s/84?)
    # better is Lis's -pi things (j/83)
    #   passed s 9 before it
    #  Desire to change
    #  Batch doing
    #  Arrangement to
    
    
    # minter, 'mi' W,
    # mutable behavioiur control
    # and intro everything:
    # var ve = [1,2,3,4]; ve.splice(-1,0,[1,2,3]); ve
    
    
    # going in the front door, anywhere along sJ ss stop sz
    #   depending on the fibre the C is made of (z/yin/Js)
    
    # having a pool of atoms, A etc inside the -rogram
    #   introduce everything once, link to it yonderly
    #   the smaller/link representations can be enlarged,
    #   and the pointer from such detail annointments,
    #   given to T the experiments in the other hemisphere
    
    # to get this function to do the many grouping!
    # A&S takeover, throw /^waits/ with T.not=1 from n/J@6
    #   to continue n/M@2 (rc&M=[-rogram+])
    # some sections being registered for attention,
    #   occurring once, to r...
    # interesting list processiona
    
    #n te 01 $s:cev %hue:-90
    #n abf -jod $s:s
    $io = G&way,'iooia';
    $F = io.F;

    # yes, o shall be able to do this, as if 
    $se = F(s,'*');
    
    
    
    
    
    
    #n sel -jod $s:se
    #n onA -jod $s:ss&A
    $Y = ss&A;
    
    ys&ml = Yc&ip.length + 'em';
    # convert Yc&ip.length to indent,
    #   fit col's stuff right aligned in it
    
    #n sip 1 $s:Yc&sip %fs:66%,hue:100deg
    # to persist over a series of itselves, collectivising info
    $m = M = [];
    $col = &Y{
        # in the reoccurring cloud of A attached to messages,
        !Yc&sip and return
        $yi = A.ontula.indexOf(Y);
        if (yi >= 0) {
            # thing in another place
            $K = A.ontula[yi];
            $te = 'had '+Yc&sip;
            n $te 1 $s:ki(K,2) %fs:50%,hue:100deg
        }
        else {
            # thing said for the first time
            $te = 'have '+Yc&sip;
            $labit = Yc&ip.slice(-1)[0];
            $sa = labit+': '+ki(Y,3);
            Yc&s and sa += '  '+G&intag:'>27 '+ki(Yc&s,2)
            
            m $te  $s:sa,ht:1 %dis:block,fs:66%,hue:100deg
            
            A.ontula.push(Y);
            Y.up and Y.up != Y and col(Y.up)
        }
    };
    
    col(Y);
    M = ar.M;
    #debugger;
    each in se {
        #M.length &&
        #    m gap  s:',' %fs:150%,bri:1
        $sa = n.t+' '+n.y.cv;
        #m ism  $s:sa
        # Core light ables
        (n.t == 'says' ||
        n.t == 'Bt' ||
        n.t == 'delta') &&
            m $n
    }
    m.map(&s{ M.push(s) });














pi/Aye: |
    #

