Bystand: |
    G&heading,'Hz:50';
    1s&ein.Exprect = &acgts{
        $d = G&E:'hC -1';
        delete 4s&Jtv.Expect;
        e Expect W $testname:dc&s %
    };
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    #1s&step ||= 1;
    #1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    
    't/LetsOsc t/Serialise t/JSTesti'.split(' ').map(&s{
        n $s  $s:s %doe:Exprect,ma:1em
    });
    #G&s;
    n More  s:twoit
    

pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];

t/JSTesti: | # test the JS bits
    G&heading;
    
    # how does it work?
    # a bunch of timers?
    # C-ing
    
    # put log thing into
    $from =
    1s&from ||= G&c,'from...';
    
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Thumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    n seeup -jod $s:see %
    
    ~>48 glimpe: '>7 lav', '>23:gl sfiafifiafiiaf'
    
    $to = G&c,'to...';
    1s&from = G&c,'from...';
    
    $msgbet = &from,to{
        $msgs = 4s&msgs;
        $mes = $(msgs).children().get();
        if (from) {
            from = mes.indexOf(from);
            from >= 0 and mes = mes.slice(0,from+1);
        }
        if (to) {
            to = mes.indexOf(to);
            to > 0 and mes = mes.slice(to);
        }
        return mes
    };
    $said = msgbet(from,to);
    
    n said -rogram $s:said %
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
pi/rogram: | # see msgs
    # the log messages emit while program builds itself
    # said is noticable things
    if (s.constructor == Array) {
        each in s {
            m ro -rogram $s:n %
        }
        return
    }
    if (typeof s != 'object' || 
        typeof s.log != 'object' || 
        typeof s.set != 'function') {
        # some kind of run-time cooptable assertion point
        # sudden widening of the type of display
        # shows progressing-ness
        T.ypco =
        n thing -jod $s:s %
    }
    
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    $l = s.log;
    # has the 'main thing: obj, clue, etc' all as string
    $text = s.textContent;
    # and with styles
    $html = s.innerHTML;
    text.length && !html.length and c&nocolour = 1;
    
    # A - jobby piles
    $sc = $.extend({},l.sc);
    $Y = sc.A; delete sc.A;
    s&A = Y;
    # < should be ki'd when it happens, for cv
    n scA 3 $s:ki(Y,2)
    
    n scAsip 3 $s:Yc&sip %fs:60%,ma:0.5em
    
    
    # B - stack of calls
    # to attach
    
    # M of details after the message
    # < explore them in 3d
    # may $use:this $pat:ern to param the G&c ~ thing
    #   to impart styles/names like the >dd:tag stylecode does
    $inter = [];
    each it sc.M {
        if (typeof t == 'string' || typeof t == 'number') {
            # >dd:tag stylecode
            $tee = (''+t).replace(/^>\S+/,''); 
            text.includes(tee) and continue
        }
        inter.push(t);
    }
    delete sc.M;
    
    
    # how much the data is allowed to use its own styles
    # is very important
    if (c&nocolour) {
        n text 1 $s:l.t %hue:60deg,fs:120%
        #l.t == '>48 glimpe' and debugger
        if (l.t != text)
            n nowtext 1 $s:text %hue:180deg
    }
    else {
        n says 1 $s:html,ht:1 %
    }
    
    $ts = sc.now + '';
    n timestamp 6 $s:ts %fs:60%
    delete sc.now;
    # if last in M of many -rograms,
    # turn timestamps into deltas, or hide if <5ms?
    #   sensitivities, language pools
    
    # attach M not included in message
    inter.length &&
        n inM 4 $s:ki(inter) %hue:240deg
    # -jod, a base types-handler,
    #   goes phorensic with leftovers
    Object.keys(l.c).length > 0 &&
        n c -jod_2 $s:l.c %
    Object.keys(sc).length > 0 &&
        n sc -jod_2 $s:sc,dl:4 %ml:0.3em
    
    S 1 many
    
    # the 9 of the -rogram of many -rograms
    $u = A.n.up.c.s;
    # assume only -rogram in this M...
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    if (uc&M.slice(-1)[0] == C) {
        # last one!
        $Me = uc&M.slice();
        Me.reverse();
        $la
        each in Me {
            $g = n.y.A.ground;
            $t = gs&z.filter(&s{ return s.t == 'timestamp' })[0];
            $delta = la && tc&s - la;
            $interval = delta >= 0 ? delta : delta * -1;
            la = tc&s;
            interval < 0.005 and delta = 0;
            !delta and t.sc.not = 1; continue
            tc&s = G&thime,delta;
            t.t = 'delta';
        }
    }
    

