Bystand: |
    G&heading,'Hz:50';
    1s&ein.Exprect = &acgts{
        $d = G&E:'hC -1';
        delete 4s&Jtv.Expect;
        e Expect W $testname:dc&s %
    };
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    #1s&step ||= 1;
    #1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    
    't/LetsOsc t/Serialise t/JSTesti t/iooia'.split(' ').map(&s{
        n $s  $s:s %doe:Exprect,ma:1em
    });
    
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];
t/JSTesti: | # some #msgs noise
    G&heading;
    1s&empathy = 4;
    
    # how does it work?
    # a bunch of timers?
    # C-ing
    
    # put log thing into
    $from =
    1s&from ||= G&c,'from...';
    
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Tdhumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    n seeup -jod $s:see %
    
    ~>48 glimpe: '>7 lav', '>23:gl sfiafifiafiiaf'
    
    $to = G&c,'to...';
    1s&from = G&c,'from...';
    
    $msgbet = &from,to{
        $msgs = 4s&msgs;
        $mes = $(msgs).children().get();
        if (from) {
            from = mes.indexOf(from);
            from >= 0 and mes = mes.slice(0,from+1);
        }
        if (to) {
            to = mes.indexOf(to);
            to > 0 and mes = mes.slice(to);
        }
        return mes
    };
    $said = msgbet(from,to);
    said = said.slice(10,30);
    
    $n =
    n said -rogram $s:said %
    #n.sc.not = 1;
    # v should be able to see where n came from...
    G&e,['TripDeck'],['have','',{s:n}];
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
pi/rogram: | # see msgs
    # the log messages emit while program builds itself
    # said is noticable things
    # sew into one big notice, plant
    G&way,'Duning',ar;
    # < make implicit:
    if (s.constructor == Array) {
        each in s {
            m ro -rogram $s:n %
        }
        return
    }
    
    # < smaller/implicit: F index types
    if (typeof s != 'object' || 
        typeof s.log != 'object' || 
        typeof s.set != 'function') {
        # some kind of run-time cooptable assertion point
        # sudden widening of the type of display
        # shows progressing-ness
        return T.ypco =
        n thing -jod $s:s %
    }
    
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    $l = s.log;
    # has the 'main thing: obj, clue, etc' all as string
    $text = s.textContent;
    # and with styles
    $html = s.innerHTML;
    text.length && !html.length and c&nocolour = 1;
    
    # A - jobby piles
    $sc = $.extend({},l.sc);
    $Y = sc.A; delete sc.A;
    s&A = Y;
    # < should be ki'd when it happens, for cv
    n A 3 $s:ki(Y,2)
    $Acv = sc.Acv; delete sc.Acv;
    Acv != Y.cv &&
        n scAcv 31 $s:cvf(Acv) %fs:75%,bri:9
    
    n Asip 3 $s:Yc&sip %fs:70%,ma:0.5em
    
    # B - stack of calls
    # this is a pi/Bye minima, into one intag'd C
    $B = sc.B; delete sc.B;
    s&B = B;
    $bit = B.t;
    Bs&way and bit += ':'+Bs&way.t;
    n Bt 4 $s:bit %fs:50%,ab:1,left:0em,mt:-0.5em,hue:-100deg
    
    
    # M of details after the message
    # < explore them in 3d
    # may $use:this $pat:ern to param the G&c ~ thing
    #   to impart styles/names like the >dd:tag stylecode does
    $inter = [];
    each it sc.M {
        if (typeof t == 'string' || typeof t == 'number') {
            # >dd:tag stylecode
            $tee = (''+t).replace(/^>\S+/,''); 
            text.includes(tee) and continue
        }
        inter.push(t);
    }
    delete sc.M;
    
    
    # how much the data is allowed to use its own styles
    # is very important
    if (c&nocolour) {
        n text 1 $s:l.t %hue:60deg,fs:120%
        #l.t == '>48 glimpe' and debugger
        if (l.t != text)
            n nowtext 1 $s:text %hue:180deg
    }
    else {
        n says 1 $s:html,ht:1 %
    }
    
    $ts = sc.now + '';
    n timestamp 6 $s:ts %fs:60%
    delete sc.now;
    # if last in M of many -rograms,
    # turn timestamps into deltas, or hide if <5ms?
    #   sensitivities, language pools
    
    # attach M not included in message
    inter.length &&
        n inM 2 $s:ki(inter) %hue:240deg
    # -jod, a base types-handler,
    #   goes phorensic with leftovers
    Object.keys(l.c).length > 0 &&
        n c -jod_2 $s:l.c %
    Object.keys(sc).length > 0 &&
        n sc -jod_2 $s:sc,dl:4 %ml:0.3em
    
    
    S as last $N
    # ^ gets M of the 9 of the -rogram of many -rograms
    # assume only -rogram in this M...
    
    # top last
    # which direction to go in? replication something?
    N = N.slice().reverse();
    $la;
    each in N {
        $g = n.y.A.ground;
        $t = gs&z.filter(&s{ return s.t == 'timestamp' })[0];
        $delta = la && tc&s - la;
        $interval = delta >= 0 ? delta : delta * -1;
        la = tc&s;
        interval < 0.002 and delta = 0;
        !delta and t.sc.not = 1; continue
        tc&s = G&thime,delta;
        t.t = 'delta';
    }
    
pi/ABf: | # Dune of things s&A and s&B
    ys&dis = 'block';
    
    # is in a many of a $s=C-rogram
    # we want to:
    #  1 re-present the things within it,
    #  2  regroup many of ourselves, while tweaking 1
    #  3 so it can recreate itself as efficiently as possible
    #  ^ that lab
    # M hier etc etc...
    # want to define a schema of atoms so to make a loader of min syntax
    # 
    # history: Matu, the female thingk (s/84?)
    # better is Lis's -pi things (j/83)
    #   passed s 9 before it
    #  Desire to change
    #  Batch doing
    #  Arrangement to
    
    
    # minter, 'mi' W,
    # mutable behavioiur control
    # and intro everything:
    # var ve = [1,2,3,4]; ve.splice(-1,0,[1,2,3]); ve
    
    
    # going in the front door, anywhere along sJ ss stop sz
    #   depending on the fibre the C is made of (z/yin/Js)
    
    # having a pool of atoms, A etc inside the -rogram
    #   introduce everything once, link to it yonderly
    #   the smaller/link representations can be enlarged,
    #   and the pointer from such detail annointments,
    #   given to T the experiments in the other hemisphere
    
    # to get this function to do the many grouping!
    # A&S takeover, throw /^waits/ with T.not=1 from n/J@6
    #   to continue n/M@2 (rc&M=[-rogram+])
    # some sections being registered for attention,
    #   occurring once, to r...
    # interesting list processiona
    
    #n te 01 $s:cev %hue:-90
    #n abf -jod $s:s
    $io = G&way,'iooia';
    $F = io.F;

    # yes, o shall be able to do this, as if 
    $se = F(s,'*');
    
    
    
    
    
    
    #n sel -jod $s:se
    #n onA -jod $s:ss&A
    $Y = ss&A;
    
    ys&ml = Yc&ip.length + 'em';
    # convert Yc&ip.length to indent,
    #   fit col's stuff right aligned in it
    
    #n sip 1 $s:Yc&sip %fs:66%,hue:100deg
    # to persist over a series of itselves, collectivising info
    $m = M = [];
    $col = &Y{
        # in the reoccurring cloud of A attached to messages,
        !Yc&sip and return
        $yi = A.ontula.indexOf(Y);
        if (yi >= 0) {
            # thing in another place
            $K = A.ontula[yi];
            $te = 'had '+Yc&sip;
            n $te 1 $s:ki(K,2) %fs:50%,hue:100deg
        }
        else {
            # thing said for the first time
            $te = 'have '+Yc&sip;
            $labit = Yc&ip.slice(-1)[0];
            $sa = labit+': '+ki(Y,3);
            Yc&s and sa += '  '+G&intag:'>27 '+ki(Yc&s,2)
            
            m $te  $s:sa,ht:1 %dis:block,fs:66%,hue:100deg
            
            A.ontula.push(Y);
            Y.up and Y.up != Y and col(Y.up)
        }
    };
    
    col(Y);
    M = ar.M;
    #debugger;
    each in se {
        #M.length &&
        #    m gap  s:',' %fs:150%,bri:1
        $sa = n.t+' '+n.y.cv;
        #m ism  $s:sa
        # Core light ables
        (n.t == 'says' ||
        n.t == 'Bt' ||
        n.t == 'delta') &&
            m $n
    }
    m.map(&s{ M.push(s) });
iooia: | # F > i/o > input/output
    # these will all be G&F, G&o, G&i...
    
    # other possible types of thisness:
    # - G&s for writing notes for itself
    #   using traces left by i/oing etc nearby
    #   doing crazy implicit templating
    #   throwing universal weight around
    #  also s is where situations are strategised on
    
    # F is a culture of grasping syntax on top of o
    # formula
    $F = &s,d{ return G&way,'PseudoF',{s:s,d:d} };
    
    #c parsetalk
    # parse out bits into m
    $parse;
        $m;
        $p = &r{
            m = parse.match(r);
            !m and return
            m.shift();
            parse = parse.replace(r,'');
            return 1
        };
    
    $ta = G.tiestowe = [];
    
    # compile time
    # see j/41/jababio
    # the string is basically a branch/path 
    #   params give values to columns, named with /^[$#]/
    #   vars return or made available somewhere, per column, per row...
    # saving much typing!
    
    # can't really bab 1 line to many to set vars
    # must return N
    #   it's what's expected? (at io (not F?))
    # and put iterator interface on T...
    #   later some way to do cursors,
    #     percolate and collaborate read-need-ness
    
    # but in an S:
    #  S can do io and then be iterating
    #  Babz setting vars inside from T
    
    
    # general branch lingo
    # something for C-together
    # < making sql
    # params written as if string interpolated:
    # they create/read object or some reduced idea of an object:
    # the column will/must have/match the given param's value/identity,
    # $o - value
    # #o - looser/vaguer/processed copy of $o
    #      like spacers, with only C.t=o.t
    # word - spacer of C.t=word
    
    # < want o to find the exact object, not it's identity?
    
    # < unless it names a universal (1s&bareword) or so,
    #   then use that. inner lingosanctum.
    $parsetalk = &talk,vars{
        $d = {};
        parse = talk;
        # do i ... for o ...
        p(/ o (.+)$/) and d.fromo = m[0]
        # absorb the o lop ^
        talk = parse; 
        
        # Babz shall do vars, see 'compile time' ^
        d.path = []; # pa+
        while (p(/^(\S+)\s*/)) {
            $path = m[0].split('/');
            $outer = parse;
            each in path {
                parse = n;
                $pa = {};
                
                # set var from path bit
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                
                # get path bit/value of here from a variable:
                # t-only/squish/shaded clone of C, or
                # C itself
                # when o the C will match itself/navigate onwards
                # or i will input that squished C,
                #   and/or ark/return,
                #   and/or climb past it and input more stuff...
                
                # toy: a name-only sketch of C
                # sheer spacer, made for a C
                #   eg where desired.t == wanted.t
                p(/^#/) and pa.isvar = 1; pa.relative = 1;
                
                # C itself for path bit got from var
                p(/^\$/) and pa.isvar = 1
                
                pa.t = parse;
                
                pa.t == '*' and pa.glob = 1;
                
                # value of here from a:
                if (pa.isvar) { # variable/bind param
                    !vars.length and throw "Not enough vars", pa.t, pa, d
                    pa.v = vars.shift();
                }
                else
                if (pa.glob) {} # anything
                else { # bareword
                    pa.v = G&Cye,[pa.t,1]
                    # words are the lumber of the algorithm
                    pa.word = pa.spacer = 1;
                }
                # namespaceness of something
                if (pa.relative) {
                    pa.o_v = pa.v;
                    pa.v = G&Cye,[pa.v.t,1];
                    # relative spacers hold a name for something
                    pa.spacer = 1;
                }
                
                d.path.push(pa);
            }
            parse = outer;
        }
        parse and throw "Unparsed", parse
        
        if (d.fromo) {
            # parse that talk too, to use up vars
            d.oach = parsetalk(d.fromo,vars);
        }
        
        vars.length and throw "Too many vars", vars
        # maps, greps, sorts
        
        # so now we have a path:
        # i: make it so
        # o: read it out
        return d
    };
    
    #c _o sketches use for A:o:
    # o gets you what you wanted from an intelligised pile
    #   midsection of o is the midsection of n
    #  S titles can use this to define iterators
    # operation of returning results from traversal,
    #   or advancing the A:o of the C, as in dome calmness check
    
    # o may ventually look like n,
    #   and n may eventually have blockquotes hanging on after it,
    #   even T things, grabbing whatever on/over/into Aing thereinout
    
    # there must be more
    # the o d will be... more infinite
    #   particularly grep/sort/map
    #  tal being apply
    $o = &talk,vars,cs{
        $talk = s;
        $vars = d;
        
    };
    $output = &s,d,v{
        if (typeof d == 'string') {
            # z at i level may mean tv, but not here since exponent of tv
            #d == 'z' and d = 'tv';
            d == 'tv' and d = {t:d,our:['y','tv'],path:[v.t,v.y.cv],usu:1}
            else {
                throw "intelligise", d
            }
        }
    };
    
    #c i_ somewhere someway somestuff
    # the dot of the i is somestuff, index the space, trunk way etc.
    
    # shall we use a talky Babz'd params-implied-by-$ thing?
    # or just put thing on thing arguments?
    $i = &talk,vs,cs{
        # values will always be hash?
        each iv vs {
            v.constructor == Array and v = vs[i] = G&Cye,v
        }
        $d = {};
        
        # talk:
        #   'universal keyworded-by $thing'
        # usually a J universal like N,M,1,9, etc.
        # and somethinging to it:
        # talk is 'N $by' should kinda m:N $by,
        #   but with the o kind of universal awareness
        # vs would then be [$by]
        
        # default place is A.r?
        $s = A.r;
        # default placement is tv?
        $d = 'tv';
        # default v is C?
        $v = C;
        # something indefinite trying to climb into a ground and become s
        # is a tiny unit of cobsciousness
        each in d.path {
            $v = n.v;
            input(s,'tv',v);
        }
    };
    
    
    #c incput see,
    # fills in an index with a value
    # total definition of z/tv wiring, which should be one of a few...
    #   < index/join types curated nearby
    #   proto hard-coded...
    # tv:
    #    lots of C via tv can hold anything, just stretched out.
    #      maybe if you're database you want to know things.
    #    < in exact mode should keep z sorted
    #    < in soft mode should not overwrite (el=1)
    #    
    # non-tv index/join types:
    #    I: could be known to be of/ov/t/cv?
    #    x/y/z: what's in space...
    #    beliefs in cv like subnets, having octaves of octaves,
    #      non-linear spaces, klein bottle public netspace
    #      lanes of stripes whipping around a torus, etc.
    #
    # 
    # s = data
    # d = [pa,th], puts at that path
    # d = {path:[pa,th],dup:&s{}}
    # does a single weld, usually C-C
    # carbon joint, some language in each place?
    # ignores the next/last/in/up wiring, let o do once sorted
    #   when it gives a kind of gravity,
    #   linearity to the stage that may not ever be there
    $input = &s,d,v{
        if (typeof d == 'string') {
            # z at i level may mean tv, but not here since exponent of tv
            #d == 'z' and d = 'tv';
            d == 'tv' and d = {t:d,our:['y','tv'],path:[v.t,v.y.cv],usu:1}
            d == 'tw' and d = {t:d,our:['y','tw'],path:[v.t],usu:1}
            d == 'z' and d = {t:d,our:['sc',d]}
            else {
                throw "intelligise", d
            }
        }
        # after the intelligising,
        # d.reintel and return d # having what we know about this index
        # so something can retype/repurpose that data model
        # kind of 2.
        
        # now 3 deals with what really shall be and how we shall create it
        # sheer bunch of keys:
        d.constructor == Array and d = {path:d,usu:1}
        # apply the usual behaviour:
        #  - when duplicate, overwrite
        #    if tv, overwritings become linked lists
        if (d.usu) {
            d.t == 'tv' and d.also ||= ['tw','z']
            # this should be available as around or after method call..
            # or "the usual" that the actual d.dup works with or without
            d.dup = &x{
                # link duped things, new thing gets v.y.$to
                $from;
                $to;
                # make similar index to z to hold dupes, in order
                # as s&z grep !in tv might reveal
                $dupz;
                
                # revision of an item
                d.t == 'tv' and from = 'later'; to = 'earlier'; dupz = 1;
                # revision of name, moving through items
                d.t == 'tw' and from = 'begins'; to = 'continues'; dupz = 1;
                # stuff moves through words
                # these schema should be drawn out
                # become keywords to io
                # io will just work
                
                if (from || to) {
                    # which way is it going: new val stays, new val joins the queue
                    $backwards = from && x.y[from] || d.keep_first; #]
                    if (backwards) {
                        !from and throw "can't go backwards with no from?"
                        # ^ unless use in telling things that missed the spot who beat them
                        !d.keep_first and throw "protocol changed"
                        # we could -1 y&dup_tv index maybe?
                        # or add y&most_$from to the end of the linked list
                        # this should magnify into a huge democratic space for ...
                        # space for 'space for ...'
                        # or follow links:
                        $X = x;
                        # < all while loops should have some limit, spec learned
                        #   badge earned. all code is is bestowment.
                        $i = 100;
                        while (X.y[from]) {
                            i-- < 4 and throw "ixhaust"
                            X = X.y[from];
                        }
                        # now last in the trail:
                        X.y[from] = v;
                        to and v.y[to] = X;
                        # so tv stays something, but .y.later = v extends forever
                    }
                    else {
                        from and x.y[from] = v;
                        to and v.y[to] = x;
                        # now tv sets us.
                    }
                }
                
                # make tv_dup, index as tv but to [] of items at the point
                # the minter will care about such things, T clutter, minor errors, noise
                if (dupz) {
                    !d.our and throw "housing not given"
                    $p = {t:'z'};
                    p.our = d.our.slice();
                    $gk = p.our.pop();
                    p.our.push(gk+'_dup');
                    p.path = d.path.slice();
                    # dup should include the one already there
                    p.zefault = [x];
                    input(s,p,v);
                }
                # return 1 to abort,
                # but we (as eg tv) shall go on to tw and z even dups
                # no information lost!
            };
        }
        #c climb container different? may A?
        # section of o, defined into several places... houses
        # this is the most high speed bit, copying bunches of C,
        # with a little lingeme sensitivity loaded in on the d,
        # which is a lunk for A, C, T rivering the reverberate of revision
        
        # index is: ours (nk/gk) points of index/space, to the value
        $path = d.our || [];
        d.path and d.path.map(&p{ path.push(p) });
        
        $S = s;
        $O;
        each ip path {
            $x = S[p];
            # the last bit of our space: the universal
            d.our && i+1 == d.our.length and O = x
            i+1 >= path.length and continue
            d.path_type and throw "index has types";
            # hash usual
            x == null and x = S[p] = {}
            typeof x != 'object' and throw "index broken"
            S = x;
        }
        
        # x = S[p] now
        # S[p] = v soon
        # except if this is just another pool of stuff to add into:
        if (d.t == 'z') {
            x == null and x = S[p] = d.zefault || [];
            x.constructor != Array and throw "z broken"
            #$xi = x.indexOf(v);
            # exact object ^, also could be claiming a tv had already (up at tv)
            # we shall start simply adding on, mentioning things more than once, etc
            # no information lost!
            # except the time of day, which is easy to find
            # dups constitute weirdness that should be cleaned up...
            #   before the system with it in goes production
            # < z_dup: handled on the o end, as z things not in tv, and tv_dup
            x.push(v);
        }
        else {
            # set thing to thing
            if (x != null) {
                # already
                x == v and return
                # something else, dup returns 1 to cancel the go
                d.dup and d.dup(x) and return
            }
            !d.keep_first and S[p] = v;
        }
        
        # seeds with seed pouches
        if (d.also) {
            each in d.also {
                n == 'tw' and input(s,'tw',v)
                else
                n == 'z' and input(s,'z',v)
                else {
                    throw "What else", n
                }
            }
        }
        
        # returns?
    };
    #c and return
    return {F:F,i:i,o:o,input:input,output:output,parsetalk:parsetalk}
t/iooia: |
    G&heading;
    $io = G&way,'iooia';
    
    # Domes:
    # S test-parsetalk
    
    $a = &t,talk,cetia{
        $vars = cetia ? cetia.split(' ').map(&s{ return G&Cye,[s] }) : [];
        $d = io.parsetalk(talk,vars);
        m talk  $s:d
    };
    a('i','w/*:w');
    a('i','trouble/w:r/#w:t','weeee');
    a('i','$t o $w/*','tea weas');
    # from the story of -respec:
    # o w/*:w
    # if problem with $w:
    #   i trouble/w:r/#w:t
    #   ts&dige = supposedtobe
    #   i $t o $w/*
    
    # so 'i $t' tv's each 'o $w/*:W', like 'i $t $W'+
    # < do d.oach
    
    
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    # S 0
    
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
    
    
Duning: | # avalanche of activatuio
    # S as steps of transformations, some linear?
    # S as moments to do o, sleep/wake culture
    # S as functions to map things inside (M) or outside (N/U) this J
    #  M works on 1's M, what we have
    #  N works on 2's M, where we are
    #  U works on 3's M, Wunity of things we are foorming:
    #   3's M, as A-climbed to its A.r, root9 molecule,
    #    haver of domes, so these in-pi can collaborate
    #    look and respond waves going wide, weaving
    #    with one big object index, etc.
    #    craziness is being joined up on A.3
    
    # < S still for late osc? Swum things?
    #   S 8... could make &{} instead of while wrap
    #     B carefully when calling such
    # could be a nice place to reboot subroutines actually...
    # < S for elvis handle
    
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    
    
    # A-climb, for the right levelled A.r (pool, what)
    # which will eventually be the root and root dome and ground
    # 3's is a big room of stuff,
    #   hmmm
    $Ask = &s,k{
        typeof s != 'number' and throw "Ask for num"
        # climb up
        $Y = A;
        $lim = 30;
        $want = A[s];
        while (Y.1 != want) {
            Y = Y.up;
            !lim-- and throw "Ask huge"
        }
        # 
        k == '' and return Y
        if (k == 'rc&M') {
            $r = Y.r;
            # r R? the soft int
            !(rc&root || rc&dome) and throw "isDome"
            !rc&M and throw "not rcM",r
            return rc&M
        }
        if (k == 'C') {
            !Yc&s and throw "NoC!"
            # isC, when it inlines
            return Yc&s
        }
        throw "What at?", Y
    };
    # arg eater
    # eat args for S
    $meater = &d{
        $m = [];
        m[0] = &r{
            m = d.match(r); # += /(?: |$)/ somehow
            !m and return
            m.shift();
            d = d.replace(r,'');
            return m.length == 1 && m[0] ? m[0] : 1
        };
        return m
    };
        
    
    # sequences/numbered:
    #   could fractionate across A.3, shelved somehow...
    #   having a limb inside J6, wh
    # they diff island on the dome, working on array
    # 
    # Duning S might return a variable, making for iteration
    # < Babz this in somehow
    # or fetching (Ask()) something another M, 3's M is called N
    # < something should be able to takeover which S we want to go for, too...
    
    # for G&Ban to find these subs:
    $way = Gc&B.sc.way;
    A&S = &s,t{
        # B will be i/S
        Gc&B.sc.way = way;
        typeof s == 'number' and throw "doing seq"
        $g = A&doming(s);
        
        # non-iterative dome again?
        !g and return
        $m = meater(s);
        #debugger;
        $p = m[0];
        # $s='as last N'
        if (p(/as /)) {
            $limit = p(/(first|last) /);
            $M = p(/U/) ? Ask(3,'rc&M')
                :p(/N/) ? Ask(2,'rc&M')
                :p(/M/) ? Ask(1,'rc&M')
                : '';
            !M and throw "noM?",s
            if (limit) {
                $C = Ask(1,'C');
                $O = limit == 'first' ? M.slice(0,1)[0]
                    :limit == 'last'  ? M.slice(-1)[0]
                    :'';
                !O and throw "noO?",s
                C != O and return
            }
            return M
        }
        else {
            # T out the other
            #$M = 
            $notes = [s,t];
            m called_S -jod $s:notes
        }
        
        #throw 'edge of reality', [s, t]
        return 1;
    };
    
    #c < shared with Doming:
    # For Duning:
    #  may not ground all domes,
    #  they may be ephemera, even error/message channels
    #  in a spinal nervous system awareness
    #  where hs&z makes for stuff toward rs&z
    #  but we might have hs&Errors, hs&Msgs... other dimensions
    
    #  should A.r be taken over by the current dome? supposedly.
    A&doming = &t{
        # resets a chunk of reality,
        # a group of o that may flatten or hide from s
        # A.ground.sc.z (or A.r.sc.z, or ra&z) is the main wWw
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A.ground = g;
        # soon:
        #!gc&root and throw "root of ground not", g;
        
        # one A&doming gives all the domes to ground
        # < what meaning for Duning?
        #   
        if (1s&domes && !gc&domed) {
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        if (h) {
            # never repeat Duning?
            # depends on the mode,
            # S and C iterator
            return;
            # 
            # reset, o maintains it in the beginning of s, 
            hs&z = [];
        }
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        # Duning doesn't step into the dome, merely holds it
        #A.ground = h;
        #G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
        return h;
    };
    
TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # 
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
Fly: |
    G&heading;
    G&way,'t/iooia',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
grow: | # spraw Js&ope qua
    # there must be a S/C/A clicky scheme attacher somewhere
    $Y = c.y.A.1;
    Ys&ope ||= 0;
    Ys&ope += e.t.includes('C') ? -1 : 1;
    ~Told: ki(Y), ki(Y.3)
pi/fod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # where was above? 2Cc&d was going to do this...
    $u = A.n.up.n.c.s;
    c&d ||= uc&d || 1;
    c&d > 1 and ys&ml = (c&d - 1)+'em'
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    $dl = c&dl || 3;
    1s&ope and dl += 1s&ope;
    
    $es = c&s;
    es = $.extend({},es);
    if (es.path) {
        $p = es.path;
        delete es.path;
        each in p {
            m path -fod $s:n,d:2,dl:7
        }
    }
    if (es.oach) {
        $p = es.oach;
        delete es.oach;
        m oach -fod $s:p,d:3,dl:7
    }
    
    
    
    G&n,['Thing',3,{s:ki(es,dl)}];
pi/Aye: |
    #
PseudoF: | # to develop limbs to G&F
    # see also fe/fi ...
        $m;
        $p = &r{
            m = d.match(r);
            !m and return
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        $dstart = d;
        $v;
        
        # all Array of items, assume the spec also de-arrays it
        s.constructor == Object and s = [s];
        
        if (p(/^\* ?/)) {
            $S = s;
            s = [];
            each in S {
                if (ns&J) {
                    $j = ns&J;
                    !j and continue
                    $os = js&s;
                    !os and continue;
                    # skips over 9
                    $t = oss&top;
                    !t || !ts&z and continue;
                    ts&z.map(&z{
                        s.push(z);
                    });
                }
                else {
                    continue
                }
            }
        }
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ 
                s && s[nk] && s[nk][gk] != null and v = s[nk][gk]; return 1
            });
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s
        

