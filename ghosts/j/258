Bystand: |
    G&heading,'Hz:50';
    1s&ein.Exprect = &acgts{
        $d = G&E:'hC -1';
        delete 4s&Jtv.Expect;
        e Expect W $testname:dc&s %
    };
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    #1s&step ||= 1;
    #1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    
    't/LetsOsc t/Serialise t/JSTesti'.split(' ').map(&s{
        n $s  $s:s %doe:Exprect,ma:1em
    });
    #G&s;
    n More  s:twoit
    

pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];

pi/rogram: | # see msgs
    # the log messages emit while program builds itself
    # said is noticable things
    if (s.constructor == Array) {
        each in s {
            m ro -rogram $s:n %
        }
        return
    }
    if (typeof s != 'object' || 
        typeof s.log != 'object' || 
        typeof s.set != 'function') {
        # some kind of run-time cooptable assertion point
        # sudden widening of the type of display
        # shows progressing-ness
        T.ypco =
        n thing -jod $s:s %
    }
    
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    $l = s.log;
    # has the 'main thing: obj, clue, etc' all as string
    $text = s.textContent;
    # and with styles
    $html = s.innerHTML;
    text.length && !html.length and c&nocolour = 1;
    
    # A - jobby piles
    $sc = $.extend({},l.sc);
    $Y = sc.A; delete sc.A;
    # < should be ki'd when it happens, for cv
    n scA 3 $s:ki(Y,2)
    n scAsip 3 $s:Yc&sip %fs:60%,ma:0.5em
    
    # B - stack of calls
    # to attach
    
    # M of details after the message
    # < explore them in 3d
    # may $use:this $pat:ern to param the G&c ~ thing
    #   to impart styles/names like the >dd:tag stylecode does
    $inter = [];
    each it sc.M {
        if (typeof t == 'string' || typeof t == 'number') {
            # >dd:tag stylecode
            $tee = (''+t).replace(/^>\S+\s+/,''); 
            text.includes(tee) and continue
        }
        inter.push(t);
    }
    delete sc.M;
    
    
    # how much the data is allowed to use its own styles
    # is very important
    if (c&nocolour) {
        n text 1 $s:l.t %hue:60deg,fs:120%
        #l.t == '>48 glimpe' and debugger
        if (l.t != text)
            n nowtext 1 $s:text %hue:180deg
    }
    else {
        n says 1 $s:html,ht:1 %
    }
    
    $ts = sc.now + '';
    n timestamp 6 $s:ts %fs:60%
    delete sc.now;
    # if last in M of many -rograms,
    # turn timestamps into deltas, or hide if <5ms?
    #   sensitivities, language pools
    
    
    # the 9 of the -rogram of many -rograms
    $u = A.n.up.c.s;
    $i = uc&M.indexOf(C);
    # assume only -rogram in this M...
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    if (i+1 == uc&M.length) {
        # last one!
        $Me = uc&M.slice();
        Me.reverse();
        $la
        each in Me {
            $g = n.y.A.ground;
            $t = gs&z.filter(&s{ return s.t == 'timestamp' })[0];
            $delta = la && tc&s - la;
            $interval = delta >= 0 ? delta : delta * -1;
            la = tc&s;
            interval < 0.002 and delta = 0;
            !delta and t.sc.not = 1; continue
            tc&s = G&thime,delta;
            t.t = 'delta';
        }
    }
    #~>49:wig rogram: ki(A.n.up,2), ki(C.y,4)
    
    # attach M not included in message
    if (inter.length)
        n inM 4 $s:ki(inter) %hue:240deg
    # attach sc not understood (M/A/now)
    Object.keys(sc).length &&
        n moresc -jod_7 $s:sc
    
    
    
    if (Object.keys(l.c).length > 0)
        n c -jod_2 $s:l.c %
    
    
    
    if (Object.keys(sc).length > 0)
        n sc -jod_2 $s:sc,dl:4 %ml:0.3em
    
    # here's where -jod goes totally phorensic
    
    
