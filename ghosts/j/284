Foogla: | # Domes prepare to A=A
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    =head1 #prepare to A=A
    
    some goals:
    - efficiently educating on A passage of time
    - J to take < 200ms
    - not noticing anyway
    - Elvising running the shower
    - unpatch, failing, patch, passing in a few seconds
    
    =head3 future of sleep: Doming
    A starts works, D are their completion
    
       C   E
     A   D 
       C   C
    
    A C9[C...] completes D and elvises a clone
     D commits Gs, Es swarm T (*/W/*)
      G wants the resources near-ish
      T returns to the desire resolver
    
    D - the Aing grouping items sprout inside
      z C & A to include C/group A workload
      provide osc-like cha/continuity without osc,
        yet be the atomicness osc uses to commit,
        and load with decor/nativities to make for mediation
          R:I is now being the osc workload gatherer + commit
            which should work on >=1 'pages' of osc at a time
              eg elvising from ...
              or the whole/9er
            rolling the others,
            being able to async progress,
              do work in parallel or not...
    make unities early to sleep/calculate desires better
      eg. when A is @28, the state can be considered D:early
      eg. when Jpin, S makes domes, which can then be known about
    internal buzz. pages of its ground.
      get composited into D:top, C9[C...] post-osc
      which gets hoisted/elvised into J/W timespace elsewhere,
        the macro-J Doming-looking action: hosting stuff.
    so to:
      make arbitrary groups
        for groups sake:
          naming stuff
          handling streams
        to stabilise/refine our sense of activity
      transport C out of time,
        so J>7 can help J<7 (sleep)
        osc-think may play with things outside of osc,
         < holds that state in a dome it hopes to pull in?
      locate them as possible actions,
        as bumping into a S-ection kinda defines it
          < more at compile time
        and elvis handlers... 1s&ein.sayeth = &acgts{
      know inputs in a tracable way
        Elvising pointing in here,
          as Teing is
        giving Desire pathways to trace processes
    
    Domes may iterate X/V or some structure from another Dome,
      it may be important to iterate locally and do remotely,
        they become transactions
    Desire might want to do something,
    as a new elvis pointing into here would
     Teing is a kind of elvising
       and is the float:right upside down triangle of stuff
         the small network-edge pile coming down into
         the big contenty pile of isness
     Schemas too, float their potential/unfoldment
       down holes they start matching
    
    #c sleep/done =head2 sleep tunnel
    
    %slep, a Tool probe
      a way to map their changes fast and sleep
        change of container vs. the values within etc
        can give/take sy&slandige/Ry&Te_slandige
     < could be faster/lessR: callback a huge ==-ish plucker,
        50ms 3%slep could get down to 4ms?
     < unicode everywhere. plants: ðŸ’® ðŸŒ¸ ðŸŒ· ðŸŒ¹  ðŸŒº ðŸŒ» ðŸŒ¼ ðŸ¥€  ðŸŽ• âš˜ ðŸµ ðŸ¶  ðŸŒ± ðŸŒ½ ðŸŒ¾  â¸™ ðŸŒ° ðŸŒ¿ ðŸ€ ðŸ ðŸ‚ ðŸƒ  ðŸŒµ ðŸŒ´  ðŸŽ‹ ðŸŽ„ ðŸŒ² ðŸŒ³
     < Cye takes y=o89 -> ycv=0.089
     < put sdiff and dup etc in 11-ish (dup 1189)
     < C/sc/css compressions, in Line or not
     
    Tool openness
      configures injectoids and transfiguration
      < more timely %differ growing out of it
      real interesting later
    
    < Elvisory re-slaning on %push to it?
       is the elvis delivery mechanism:
        give edifice of deliverableness
         resolve to best case or so:
       if it were a different J:
        enter it, changes input to thisJ
        decide to redome thisJ to involve that,
          or seeing our change come back to us
       Matu-ish out-of-time with %push gravitate reruns
      redo R building on changed elvisory?
      see 'rebuild %push to use e'
       %push currently injects the remote %ball%movingin
         which will not work if its asleep
         but it could be brought around about as fast if:
    < Te the %moves to Elvisory/anywhere
       with a watch for completion and callback/expiry
    < universal vision of rc&ha.dup,
    < replace ravel with Doming and Display2
    < TEST io.i z much
    
    # another
    o rebuild I via Babd ways
     o link G/ to W/G so we can update it ourselves
     o get a Lis rolling nicely
      o tests sign the version as it percolates
    o rebuild jsBab in js
     o fast way changes, lots of test results if you want
     o check against jsBabz for j/2/*
    
    o 'rebuild %push to use e'
      %checkout the tangley varieties of %push
    
    o unify name extrusion (see names extruding)
      like X but with where/when to D,
        alt names and fuzzentations (figure name changes)
          inc. crunchable path descriptions in various datalang
        universal gone/unnoticed system
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
    
    good study.
    perldoc -f study
    # < in general, knowing if the A is for a queue or for right now

    
    #c=head2 Maturation
    
    Gombulus hives elvising going in or coming out
    TX
    hands need to be projected
    
    o a&z toplevel thinker
      and its localised sidecares
        like AndContinue,
          want J structure reengaged
          A might %waitingfor
      a bunch of R not expecting J overhead
      rebuilding on the Co Joinup (W of W)
        having it bring G (map of its dependencies) (see Give)
          as an %H of a different name
            once osc piles of whatever hoisting is?
              not much doc about osc hoisting:
               the W/of/t may W/what/ever/it/takes/t
               for stats/accounting
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    
    o and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and W-contiguous
            the simple funtimes embedded in the page,
            if browser compatible, Wake up and do anything
        I-ing up Sevo, then placing more A-ily,
    
    o names extruding, like X but with:
      connection to a dome:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
            done-ish by %slep
              could describe path or so
        decide once D:in !%more
          D:new == D:old to sleep, or:
          clone D:new to D:out and ...
            becomes someones D:in
              border control
        
    o Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    o elvising coming out or going in on the X
      and transacting the change of it
       as Domes, which have versions of Domes going into them
       an osc that keeps everything it sees would be first
        and be the wandering frontiers of change
     
    o making the R an A.
      compiling ravel into throat?
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further) (%slep)
     ongoing bisection of A
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    # anyway
    
    back to Pass...
    
    # thursday:
      new A4,
        < starts from a single /js/ with
          one screenful of prior knowledge
        A calmly pulls in its deps, sets foot...
    # saturday:
    # friday:
      new I compiled fore-way,
        composited and storaged in Pass
        is a layer of tools on a type of wormhole,
         which we also need to grasp moving around
        the bunch of names, Lis
    #c monday:!
    W&Ha:
      bugs:
        seeI 1.2: is one of the Is Mlimits diags wrong?
        a slep inside a slep has some history issue, keeps spawning?
      W&ledges:
       tests slepology:
         specifically elvis change
       since W&edges is too large
     
     unseparated W&Ha starts taking Rc&N>1000 to check out
      its the elvising:
       < to be lv change only
       < not deLinesing to Wing, wait til Ting
      such shapes par importo A=A
      
    W&large_edges:
      W&edges:
       tests slepology:
         wakes on elvis/data change
         %countlife%aTool shows if its awake
         %differ goes round in circles as data loops
       only just able to complete with the current memory leak
       step 9 shows a bunch of yReal vanishing...
       
      toomuch:
       leading to '< %run/%differ' is desire to ease
         accepting changes, to exp or Te
       are both a little far away? would be nice
         but nearly done with tests until A=R round,
         which is likely to see them built more elegant
        - exp: later %doing to bring earlier accepted change
         see %differ. little far away.
        - Te: %doing brings T/$W back if modified
         also a little far away.
         get both diffing,
         the innermost T...%ball that was ==
          cloning that over itself, 
           pointed enough to apply to later %doing
            that wants to resume that state with more
          with a diff/accept stage
           temporarily projected into the %run by %Tool
         Lines|diff must find R per diffchunk
           Bunchology with the diffchunks != new
       will be:
       < linking T/$W -> W:PuTe or W:City:
          T/$W:edges.y.owner = $W:PuTe
           and $W:edges ~ $W:PuTe/$W:edges
          T/$W:City.y.owner = $W:City,
           and $W:edges is further inside, etc
             find refs for $W:City/*
          possibly need more %Lines gathering points
           or a function to gather them on demand
       < diffing T/$W:edges <-> W:PuTe/$W:edges,
         producing R in T/$W that have the change,
          and those that are merely transporting it
            common Lis sense:
              T is species of edges, as is W:PuTe
         so we know the minimum clone-over move to make,
           and what it should be cloning over
             < lv changes later
       < being a pathy clone-in %Tool to apply to later %doings
      
      random niceups
       %testrun=2 'get ahead of %run'
        until %step with boost
       %run: inventstep clones last step
       
       < %City is noisy, we want:
         %slan to turn miniature diff on the noise
          path to the Rthing, lines changed before next Rthing
      
       < %Cit shrinkgrouping known R props
        < group them by the I producing them
         < coder than dictionaries every property you use
       < %Cit visual cues for:
         R:Dough that %Someflav=C:Dough,
           for eg Rs&C = picture of self
          or C.y.Process = R
           things R has may link back to R with typing
       
       and A=R
       
       #   the curves of this paragraph looks great up close:
       #  this is what A:s-ions will look like
       # state changes
       # with casual causla {}
       # along space wiggle
       < %run:
         < using %differ to:
          < cursor various things to keep branchy,
            and hooks to make the test reset/pause properlike
              %differ becoming the time controller,
              %push%act merely a workflow in it
          < %doing brings T/$W back if modified
            probably into $doing/$W (nab%aTool loses %H)
            causing:
          < later %doing to bring earlier accepted change
            eg. PuTe arrangement before every step,
            has the story of elvis along it
            < must be applied as an lv change,
              sensitive to overwriting anything etc.
          < storing lv changes for consecutive %doings
       
    #c tuesdA:
    new/old ground:
    come back to A, they are like R:
      a&z (A.sc.z) are innards, like Rs&z
       only used in A:u
      a&N are innards anywhere wanting attention
       w:TuneTimeMachine gives A to 1s&N
       w:AndContinue: resumes all 3s&N
    so 1 can know what A it has in progress...
     AndContinue shall come again
      building W&Lis
      ...
    have R that can simply keep Ringing?
     < osc must get us back into whatever Ring:
       init: Ring@1 everything (Graze)
       then: resumes all Is&z
      the cores may fall asleep at random
       and may still percolate a Display anyway
       or lock the dome it was finishing from starting again
    see I and repackage:
       A:u makes .I
         mixed from many .I,
         got from /js/
         with async for update/check
       A.4:
        has loop bits, local culture
        .I:
         is everything, mixed up with StyleHut
         .i is all StyleHut,
          figure out what we need to keep
         never goes async, is trusted to be maintained,
         .w:
          has only this %namedcode thing
       A.5:
         looks neglected
         .w:
          is the spot, y&tw for $way
           they s&dige and s&now, G&way asyncs
           want to digwaypoll them, make sync
          all scooped up by Shovel, per test run
           which can make sync prior
    I.w is totally incidental,
    1s&minds[uname] = A c&N[4s&mind[t]]
     u deals with W via /js/, mixes onto Normal
    G&question (and other asyncers) should provide:
      ttl, ready=1 on callback
     to be useful for testing this stuff efficiently
    
     how it starts:
       html <script> get & eval from /thestart?step=n
        sends it A&loadI and Stylehut
         which includes HutNuts (begoin/jsung)
       G&begoin -> G&jsung,'NutMachine' cb -> G&Jinthe
         jsung looks like A:u but overwrites any A.I[t] = W:of it loads
         Jinthe sets up listeners,
          waylays NutGravy, defines function,
           waylays NutReady, more waylays.
     
     will start:
     < A&loadI a simple A:u@6 etc for basic mind mixing
       gather more mind, global functions, start loop
      should less async, and:
       be totally new ev/e hookup:
        Display:
         lose on.A
          use attr t/cv, attr sip if sJ
          and lookup to the sips of 4s somewhere global
          A.4 must always know about elvising
         lose jQuery,
          moving elements only as needed,
          text inputs not rebuilding every time
       
       ways to keep track of updates...
        make an islanding that can digwaypoll for:
          w change
          W change is regular /W/ with dige...
        know W that contain other W we are watching,
          digwaypoll for notify of W changing?
          could be wired into /W/
           not for the same socket?
         future /W/ storer is an elvising with a route,
          only then demands stringify to get across the net
    
    #c Wednesday
    water cactus
    very thinning impossibleness:
    < s&lv should come from the $main/A.4
       output modes are a T
    < frames
     < ifr:blank.html, inject with <script> etc, save
     < the html we build able to serialise most C
       such that search engines will see it
         $Cs&W.html becomes the href=""
         going to build a lot of piles of <stylehouse>
    < jsBabz should S to an indent, work in R
    
    W:Pass %ball web surfing
     < keep openness from last time - part of:
       provide autosaved W/T from last time
        these could be tracked separately, likely to be mostly garbage
     < testbedding
       < deps: %Gounce - ghost versioning
         knowing exactly each I it ran with
         making cert to help that Gounce get places in W:Lis
     < %play%W more properly,
         see Be, can play out over time...
           minor %R-ish manage what seems to be a situation
         Rsync %gee%ball late,
          checkout fully, same Ring (T.Rq?)
           see about when %gee hits 92 before children done..?
     
        # between
        #   fio(F...) # f tv
        #   fabioty(p..., # R f is for tv
        #   Rc&X, Rs&Te
        #  we have a few ways to gravitate the elvising made
        # < ad hoc continuity:
        #  < mez&rename (now ballrename) takes Rs&Te
        #  < mez&move should takes Rc&X, in some cases?
        #    if the A of it can be trusted to resync
        # something somewhere in the equation of Waltz
        #  knows exactly why things changed,
        #  holds and spreads knowledge of the move
        #  which may be done out there as:
        #    lv with an el:9, el:6 ?
        #     6 implying recycle the last 9,
        #       or some specific one,
        #       or resurrect recently deleted...
        #      similar logic to:
        #      Lc&responsey - expect one receive per send
        #  requiring all these interations to be suspended
        #  over the judders
        
     %play%R starts:
     %Doming:
       building up how to J(.3)
        < have Swim-ish any index hoisting
           mixing/reducing
            ting Merge.js for J, with W:of
        < ting search in %Doming
          building indexes of I when they are required,
          elvising changes:
        
     ballio, Ravelvis are
     %ios:
      < %balls have io/slep sense
        for intended+not changes
       i wanting to happen
       o happened before
        desire/surprise carrier
        < slep/io <-> what Reaction, batched
          eg /seek/ -> %do_Further()
         < via Sectiona, for an atime iterator of /seek/
       quite to do with:
     < one big %ball,
        < some of it grounded
          there are C from/for Activity (osc-levitated)
          and C for being the sticks in the mineshaft
          < have a CdaR (fast) way to diff %balls to themselves
          whatever it takes
        < getting that change to Rsync %balls,
       < even out of sync, to a degree
        < these ch() comments shall Tool down to
          fleeting speechbubbles, beneath the line
        < tree -> table mode as we cross the line,
          smoky action -> seeing office mode
       
     Mwty
       rearranges modulats
       dressing %ball%fixes for being about ...
       eg the attr on a %Rom messes with the %Doming
        and gave/give each other life
     
     %JRom:
       is separating into %Doming
       
         encapsulates activity, Doming in and outs
         parts have error and (1|4)s&N plumbing
         < T plumbing (see control)
         < pausing if time/sheer Ring intensive
           could control infinite loops in the same Ring
             the first Ring inside 4 should ttl when starting Ring
           for progress, may Ring more, when theres time
             sleeping for Display meanwhile?
               Rc&X will wander, merge the eventual completion
             or osc-ing each section as it completes
               like Doming, wants recode with T sense,
                recording the set of args used, etc
         
         < R:Mapper may also have a little e/Mw on each of many,
           hanging up its thinking amongst others language
           
         < folding, taking %noDisplay off chidlren with activity
       
     %mund: de-lies fact piles
       various eg %Ghostways produce stuff
       they each become a Ghost unto further ...
       
       %Ghostways:
         your version checker
          travel agent
         historically:
       %GhodigWap:
         insures /way/$t against %mundws:digwaypoll
         < tractorbeam $Way into Ghost/Way,
           leaving the hoisting to $Way/5Iw up to mund
           this Ghosts best guess for those ways
           and providing data on dupover, etc.
           and helping lay out ref phylogen
         < G&ting/%ting forcing question/remote check
       
       sidenode:
         everything we n ... in R is really an m Rs&M ...
           unless it Cc&R: spawns R, c.* copied to sc.*
         such is a tubeending
      
       
     #c t!!
     t:
      is thing finding
      t looks up A slope of places with things
      t looks in the dome building now...
       and for A-things around the place
        as A needs to find As to A
         t learning how to traverse every index
      # now:
      G.h(acgtt) does $t subroutine (I.i.h does I.i.$t)
       therein looking for $t becomes:
        G.t(acgt'i't) to avoid infinite h<->t loop
      # future
      B/T stack sensitive
        any call may be paused by a variety of reasoning
      G&lathe,3 Babz:
          G(A,C,T,'lathe',3)
      # or perhaps inlined non-inlined sub calls (no B-stack)
          G.i.lathe(A,C,G,T,3)
      # or totally inlined: ({}-scoped lexicals?)
          s&surface-- for 1..$s;
        this will be handy for generating G&throat
         from the dimensional joint protocols the I use
         these will need variants, as me&Ring is
      
      # lots of lang shall compile to lots of G(...)
      #   anywhere we thing stuff
      G = &ACTs{
          # like G.h
          $G = this;
          $args = arguments.slice(4);
          # simply looking for a function, closest A with it
          $i = is_string s ? G.t(acgt'i',s)
              # looking for something crazy,
              #   may even take args about this call
              #    and beyond, to find the right thing
              : G.t(acgts,[M]);
          B/T stacking {
          T.return = i(A,C,G,T, ... args)
          }
          return T.return
      }
      G.t = &acgtM{
          # like G.ting
          # matches whatever W/C/c in M
          #  sequences of them usu mean by z,
          #  array of arrays for resetting cursor
          # can also mean start doing a thing,
          #  nearby doming invites it to keep state
      }
      # further future:
      Babz realising parameters on things:
      G&$Self$Ne:za,$R$s$c:limin,%vang
      packs in the:
        G.t s={Self,Ne} c={R,s,c} 
         looking for (s) $Self and $Ne
          knowing the act (c) if that helps?
           or would it get confused with more itemology
            spose G could decide on the first being WHERE,
             the others being some extra into
             seems like something for doing subroutine calls remotely
        running it %vang mode with named arguments
         %vang could specify output form,
          a style to apply on something inside (G&tsc)
          some T-condition, error/async continance
          or name the object created
           t looks in the dome building now...
      T-condition,
       check it every B-stack (soon to be a lot of them
       error/async continance
    =cut
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #    C.y.R = R:C
    #   sprouts some sc to R:$gk or so
    # < determine, certify version of etc involved
    # we have a village's machinery for progress
    # < teleporting in: knowing you want such sleep pattern
    #    for vibrating values (oscillation)
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c Be.C - group C.*.*
    # see %Cit/KnowC
    # < I, a W of qualities and how to use them
    $Be = me.Be ||= {};
    # < more C
    Be.C = {};
    Be.C.index = {
        scgk:'tw,We',
    };
    Be.C.Cit = {
        scgk:'Cit,fromsitop,scan',
    };
    Be.C.R = {
        ygk:'R',
        cgk:'d,N,X,V,refs,refR,inC',
        scgk:'X,ci',
    };
    Be.C.SC = {
        ygk:'supr,s',
        cgk:'',
        scgk:'',
    };
    Be.C.Rlimits = {
        cgk:'dupl,nl,dl,dubquiet',
        scgk:'boost',
    };
    Be.C.Rplay = {
        scgk:'boost,Te,playsheet,elvis',
    };
    Be.C.History = {
        cgk:'b,V',
    };
    Be.C.Display = {
        scgk:'C,Mw',
    };
    Be.C.fun = {
        scgk:'tightly,inheritsc',
    };
    Be.C.in = {
        ygk:'in,tw,tv',
        scgk:'z,Wind',
        sc: {
            Wind: {path:'t,dige'}
        },
        wanderin:'together',
    };
    Be.C.space = {
        ygk:'cv,ov',
        cgk:'cv,ov',
    };
    
    Be.nks = 'y,c,sc'.split(',');
    me.BeCload = &{
        each K,Kc Be.C {
            Kc.K = K;
            each ik Be.nks {
                k += 'gk';
                !Kc[k] || typeof Kc[k] != 'string' and continue
                Kc[k] = Kc[k].split(',');
            }
        }
    };
    #c Beings arrive, find C.*.*
    me.Bear = &acgtRsk{
        k == 'play' and Be&plays,R,s
        else
        Rs&ball and Be&lums,R,s
        else
        Rs&fix and Be&fix,R,s
        else {
            throw "No Bearing"
        }
    };
    
    # 27%play via %playsheet
    Be.plays = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q )
            .map(D => Be&playit,R,s,D );
    };
    # 3%ball sprawls out
    Be.lums = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q,{ohm:1} )
            .map(D => Be&lumit,R,s,D )
    };
    # 3%fix is a thing
    Be.fix = &acgtRs{
        $p = Ry&up;
        # Be: inherits from %ball's lumit
        #  via %BeX.xtk[$sc][$gk].exRsc.BeD = fixit's D
        #    < should also know lumit's D
        ps&BeX and Be&BeXarrive,R,s,[R.t,'fix']
        $D = Rs&BeD;
        #  or %Be[$sc][$gk] = lumit's D (GOING)
        $be = !D && Be && ps&Be;
        be and D = be[Rs&fix] && be[Rs&fix][R.t];
        # may %viewvia=ki|size to gkness
        # and %inputmode
        # < %fix%play should grow the meaning etc
        D and Be&fixit,R,s,D
    };
    
    # Be about here.*.*
    Be.scan = &acgtRs{
        $M = []; # q+
        each kt Be.sc {
            !hak(s.sc,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        each kt Be.y {
            !hak(s.y,k) and continue
            M.push({tatch:t,nk:'y',gk:k})
        }
        return M
    };
    
    # makes D for q, thing attachment mode specifics
    #  D also gets how to act
    Be.cutch = &acgtRqc{
        $D = G&Cye,[q.tatch,5,c||{}];
        !D.t and throw "!t"
        # sc from matching
        q and ex(D.sc,q)
        # c from matched, the how
        Be[D.t] and ex(D.c,Be[D.t])
        # known properties on %ball%Be
        if (Ds&nk && Ds&gk) {
            # < Rc&X.Be.nk_gk for:   and Dc&b...
            $be = Rs&Be ||= {};
            be = be[Ds&nk] ||= {};
            be[Ds&gk] = D;
        }
        return D
    };
    
        #c BeX getting a %ball/me&lumit's Be-ing to a %fix/me&fixit:
    
    # set properties of children that don't exist yet
    # see RbitX
    Be.BeX = &acgtRsD{
        each kc Dc&BeX {
            $name = D.t+' '+k;
            k = k.split('%');
            $t = k[0];
            k = k[1];
            # cousin of R.c.X/V
            $X = Rs&BeX ||= {};
            $tk = X.xtk ||= {};
            tk[t] ||= {};
            $oX = tk[t][k] ||= {};
            # where .x=[more R.t],.xtk=[more nk/gk]
            # and non-path things apply to the arriving R
            $sc = oX.exRsc ||= {};
            # rogue generation of D
            # < use cutch, make complicated Be[t]s
            sc.BeD = G&Cye,[name,5,c];
        }
    };
    # X.xtk = R.t, R.sc gk
    Be.BeXarrive = &acgtRsl{
        $p = Ry&up;
        $X = ps&BeX;
        !X and return
        # walk a path of x to X
        $x = X.xtk;
        each in l {
            x = x[n];
            !x and return
        }
        Rs&BeX and throw "Already at RsBeX"
        Rs&BeX = x;
        # check in
        x.z ||= [];
        x.z.indexOf(R) < 0 and x.z.push(R)
        # apply
        x.exRsc and ex(R.sc,x.exRsc);
    }
    
    
    
    #c Behave from C.*.*
    # localises & applies Dinstructions
    
    Be.playit = &acgtRsD{
        !Rs&ball and throw "What"
        Dc&play and Dc&play(A,C,G,T,R,s)
        else {
            # vaguely know it, not a c&play-er
            # < later check some Be used the %play
            # < thing's sc wants upgrading mode
            me&tsc,"!play:"
        }
    };
    
    # R%ball
    Be.lumit = &acgtRsD{
        # symbol blocks the way, and leads on
        $c = {k:'clicktoplay',y:&v{
            me&introqua,R,{play:v}
        },Mw:'Be',tsc:'T',relax:1};
        me&rolltog,R,c;
        $n = c.n;
        
        nc&s = Ds&gk;
        Dc&symbol and nc&s = Dc&symbol
        nc&s.length > 5 and Dc&symbolsize ||= -5
        Dc&symbolsize and ns&fs += Dc&symbolsize
        
        # c&nofurther - stop adding R under this one
        #  recursion control
        Dc&exRc and ex(R.c,Dc&exRc);
        $p = Ry&up;
        each kc Dc&ps_Dc {
            p.sc[k] and ex(D.c,c)
        }
        Dc&BeX and Be&BeX,R,s,D
        
        # %play things tend to hide/represent in-%balls
        Dc&ohm && Dc&play and Dc&hbb ||= 1
        # otherwise it costs 1 boost
        # < consumable if Tie remembers
        !Dc&ohm || Rs&boost > 0 and 'open'
        else {
            # tend to hide every R inside...
            !Dc&hbb and Rs&nofurtherDisplay = 1
            # very high level view of what else scans interesting
            ss&z &&
            n withz  s:z %fs:14,hs:966
        }
        Dc&hbb and Rs&hideballsballs = 1
        # do more display?
        # look up for a qua ac?
    };
    
    # R%ball r%fix
    Be.fixit = &acgtrsD{
        $R = ry&up;
        !rs&fix and throw "What"
        !Rs&ball and throw "What"
        # apply styles to r%fix
        $st = 'inputmode viewvia'.split(' ');
        each in st {
            !D.c[n] and continue
            r.sc[n] = D.c[n];
        }
        # < symbol's styles fitting into %fix n t
        #     might be too complex to read
        #       sprout as necessary
        if (Dc&play) {
            # can %play sometimes (via the %ball)
            # likely to show %fix t/s?
            #s == '1' and me&tsc,'onething','=1'
        }
    };
    
    #c Bersonality of C.*.*
    # effect C representation
    # known properties may ... (%ball%play)
    Be.sc = {};
    Be.y = {};
    
    # s&H
    # stored object
    # < boostrap from H:1
    # < know exactly where it is (/G/*)
    # < know history of it across history of s
    # < history of s vs. history of R, getbetween.
    #   values exist somewhere fractionable in Domes,
    #   pinned down every so often from various angles
    #    levels and resolutions, compromises
    #   simply have to play lv in reverse, watching path
    #    lv must play from an el<3
    #    to know it has everything in the situ,
    #     which could be localised to part of the path
    #     < lv requests should serve grep into paths
    #       thence almost-Lines wants to end up in a database
    Be.sc.H = 'sH';
    
    # s&quiet
    # eg a Js&Te doing usual work
    Be.sc.quiet = 'squiet';
    Be.squiet = {symbol:'q'};
    
    # y&lv
    #  boundary to a done thing that will join to us
    #  eg. your %Lines hoists the s.y.lv as itself
    Be.y.lv = 'ylv';
    Be.ylv = {symbolsize:-2,exRc:{nofurther:1}};
    
    # s&of
    # code, generally compiles, /\n$/
    Be.sc.of = 'sof';
    Be.sc.js = 'sof';
    # sets up openable codon on s%fix
    Be.sof = {BeX:{
        's%fix':{inputmode:2,viewvia:'size'}
    }};
    Be.sc.string = 'sstring';
    # sets up openable codon on s%fix
    Be.sstring = {ohm:0,BeX:{
        'string%fix':{inputmode:2,viewvia:'size'}
    }};
    
    #c Beeple of C.*.*, proto s&R
    # s&W
    # < opens that Wormhole in the nearest %gee
    # < located around here:
    #    i ^^%gee/$W y o ^^/G/$W
    #     then %gee late Rsync,
    #      so openness can occur in this ev'd Ring
    #   this would be the stately G&ting
    #    5 could know all the W we use
    #   iter `dig`
    #   < hostinfo
    # < as another J,
    #   managing pause/sleep modes of them
    Be.sc.W = 'sW';
    Be.sW = {play:&acgtRs{
        # becomes signpost leading in
        $l = me.cbu(R,'gee');
        ls&openness.push(R);
    }};
    
    # s&J
    # probably a J:1,
    # make W from the elvisory
    Be.sc.J = 'sJ';
    Be.sJ = {play:&acgtRs{
        ss&J != '1' and throw "nonJ=1"
        # feeds with e
        me&Ravelvis,R,s.t;
        # < unDoming
        ac(R,'unplaycb', &{ me&Ravelvis,R,s.t,9 })
    }};
    
    # s&testrun
    # does a test via W:Co
    # < elvise it
    Be.sc.testrun = 'stestrun';
    Be.stestrun = {play:&acgtRs{
        $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
        Rs&Te && Rs&Te.sc.almost and ls&almost = 1
        me&introqua,l,'boost:2','@1'
    }};
    
    #c Beepingness
    # %play engaged tasks
    # Doming & Beeping will separate
    #   Beeping has empirical noise,
    #   particulars have idealism or more noise
    #   toward being a network stack
    me.Beepingness = &acgtR{ return [
        ... me&KnowCitingness ,
        ... me&Tingingness ,
        ... me&Tongingness ,
        ... me&Socketingness ,
        ... me&Domingness ,
    #c %garbec
    =pod
    garbec%R: garbage collect localStorage
     , regex for %W and %H
      < know %parent, ship everything off to a git
       < as a %Gensing?
         with an %H/differer for the current state of it
         but just be an R, opening bits of net puzzle
         posit deletables, do one last grep for their %H
       good for up to 5MB?
       %H:
         any non-W chunk, storage t=dige -> string from Lines
         must %Lines encode H:... for regex
         < Lines could have many sc, keep first clean looking
       < %H may all hoist to the top, as in w:Writer/Gversioning
         would look like %Has:0294u390;34ui902d;345u209u3;3u8490j
    =cut
        # boost <0 to rescan. >0 to delete
        # < bright future of the backroom
        # < for the enclosing %gee
        ['garbec','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            
            #Rs&somehash = window.fogive ||= ex({},localStorage);
            Rs&somehash ||= localStorage;
            
            (Rs&boost||0) < 0 and 'rescan'
            else
            me&rollbs,R,'figure' and return
            n Pass  R %garbect,viaW
        },'ift,D'],
        ['garbect','3',&acgtRs{
            Rs&noDisplay = 1;
            me&tsc,'nothing';
            $k = R.t;
            $g = me.cbu(R,'garbec');
            # < use $k=Rc&s and Rc&refs to dedup
            $te = gs&garbect_t ||= {};
            te[k] and return
            te[k] = R;
            # order importo par stat hoist
            ac(g,'garbectN',R);
            # read
            $v = gs&somehash[k];
            !v and return Rs&err = "No "+k
            
            $l = v.split("\n");
            each in l {
                # < using Wm[3]: where the match started
                #   and showing the path through this place
                #   %garbect are places/storage points/gravity wells
                $Wm = n.match(/(H):(\w+)\b/);
                if (Wm) {
                    $H = Wm[2];
                    n $H  R %garbect
                    continue
                }
                # the s&W usually 1, encodes to just 'W'
                #  otherwise it's a different W this one must accompany
                #  eg %of is required (eventually) to wake up code
                $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
                if (Wm) {
                    $t = Wm[1];
                    Wm[2] and continue
                    # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                    n $t  R %garbect,viaW
                }
            }
        },'ift,D'],
        ['garbectN','6',&acgtRs{
            $te = Rs&garbect_t;
            Rs&figure and throw "garbectN + figure"
            $d = Rs&figure = {};
            d.to = 0;
            d.total = 0;
            d.disco = [];
            d.discotal = 0;
            each kv localStorage {
                d.to++;
                d.total += v.length;
                te[k] and continue
                d.disco.push(k);
                d.discotal += v.length;
            }
            $N = Rs&garbectN.slice().reverse();
            # < size of Ws sans in-Ws?
            each ir N {
                rs&err and me&tsc,"err",r.t+"_err:"+rs&err
            }
        },'ift,D'],
        ['garbec','7',&acgtRs{
            $d = Rs&figure;
            !d and throw "!figure"
            
            each kv d {
                typeof v == 'object' and v = v.length
                n t  $s:k %hs:999
                typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
                n s  $s:v
                n sp  s:\n
            }
            
            # delete the disconnected
            # < check it's a %H-type key,
            #    deleting W should be harder,
            #    but we can't really tell...
            # < know what hist
            if ((Rs&boost||0) > 0) {
                delete Rs&figure
                each ik d.disco {
                    # check they exist
                    !Rs&somehash[k] and throw "to delete, no: "+k
                }
                each ik d.disco {
                    delete Rs&somehash[k]
                }
            }
            delete Rs&Te.sc.boost;
        },'ift,D'],
    #c t/%lvhashave
    # test Element replacement with minimal add/remove
        ['lvhashave','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '7px dotted green';
            s&hue = -70;
            
            $td = [
                'jus fibre g/twas jus fibre g',
                'jus g/twan jus',
                's van to dich/ze van dich toat to',
                'toad transfer lich/fur lich trom toad',
                'sle sla van to dich/sla van sla dich sla toat to',
                'further towards ye goal goal/no further goal shall goal ye',
                'test data shall/test shall gall data',
                'test to nuf fla flong/fla test flo flong to nuf',
            ].map(&s{ return s.split('/').map(&s{
                    return s.split(' ')
                }) });
            
            
            each in td {
                $got = n[0];
                $exp = n[1];
                
                $D = G&Cye,["case_"+i,''];
                Ds&got = got;
                Ds&exp = exp;
                Ds&V = 1;
                #exp[0] == 'fur' and V = 2;
                
                # 6
                me&lvhashave,D;
                
                # 7
                $space = ' ';
                each in Ds&cha {
                    $tn = Ds&actN[i];
                    tn = tn ? tn.join(' ') : "?";
                    me&tsc,'elementing',n,'1b'
                    me&tsc,'elementfunc','@'+space+tn,'1q'
                }
                
                
                if (!Ds&actN || Ds&fail_elementing) {
                    me&tsc,'started',got.join('-'),'1d';
                    me&tsc,'exp',exp.join('-'),'1p';
                    me&tsc,'element',Ds&lvd.join('-'),'1b';
                }
                else {
                    me&tsc,'elementingok','OK.elementing',1
                }
                
                if (!Ds&have || Ds&fail_brute) {
                    me&tsc,'output',Ds&have.join('-'),'1p'
                }
                else {
                    me&tsc,'outputok','OK.brute',1
                }
                
                Ds&fail and me&tsc,'%fail'
                Ds&total_change and me&tsc,'%total_change'
                
                me&tsc,'---',null,'1'
            }
            
            Rs&Sampley and me&Sampley,R
        },'ift,D'],
    ] };
    #c func-Dome
    
    # saves your n ... as joined c&s text
    # some care to \n regularly
    # < unicode embedded colours, see G&intag
    me.Sampley = &acgtR{
        $s = '';
        each in T.nN {
            ns&R || nc&R and continue
            $headed = 0;
            if (n.t.includes('lv') == 0 ||
                n.t.includes('change') == 0) {
                'swathe'
            }
            else {
                s += "\n"+n.t+": ";
                headed = 1;
            }
            s.substr(-1) == "\n" and headed = 1
            ns&dis && !headed and s += "\n";
            nc&s and s += nc&s
            ns&dis and s += "\n";
        }
        s.substr(-1) != "\n" and s += "\n"
        $c = G&Cye,[R.t,'',{sample:s}];
        $l = me&Copy,R,c,{t:'Sampley_lv',ball:0,Lines:3};
        Rs&Sampley and Rs&Sampled = l
        return l
    }
    
    # like G&ind, or Rc&s=C climbing
    #   returning Rc&N.map(Rc&s)
    # and setting yup
    me.sunN = &acgtsdl{
        d ||= 1;
        l ||= 5;
        d > l and return []
        $N = [s];
        each in ss&z {
            ny&up = s;
            N.push( ... me&sunN,n,d+1,l )
        }
        return N
    };
    
    # func Dome t
    # phil somewhere rising
    
    # G&t for this thing
    me.herer = &acgtD{
        $very = arguments.slice(5);
        $s = D;
        each in very {
            typeof n != 'string' and throw "!s"
            # should know where D%in.$tv=C
            #  or D%in=in/C or D/in/C or Dc&X...
            # by the D it's in
            $v = sy&tv $n
            v ||= s.sc[n];
            s = v;
            !v and break
        }
        return s
    };
    
    #c e thingers
    # e as far as ravel goes
    # W: $t/R/[path] of Remote
    # k: mode/act/hook of delivery
    # D: the item to deliver
    # we used to: e $W $D
    #  and got a C that .t=$W, c&e=$D
    # the k not being part of D means D can be more like ec&s:
    #  the item being delivered
    #   which might still be requesty, depending on k
    # k:
    #   M: i 1s&Tes&M/$D
    #     < io param each A.1, 1s&Te & 1s&Tes&M
    #       and mean something
    #   < something like me.RMount
    #     similar/future bunch of things then replace
    #   9: deletes Te
    # < native undo:
    # < when it's
    #    el=1 (creation),
    #    el=2 (more forceful/recreation,
    #      and implies it's the only thing with that t
    #    el<3 implies it's a full copy (to the next %W/H)
    #    el=3 is an update
    #    ...
    #    el=8 keepalive or reference for ordering
    #    el=9 deletes
    # < how it's
    #    coming from a process writing down its deps
    #    something output from osc,
    #     maybe wanting to include those deps ^
    #      as it fits into the store's system
    # < doing all of its procedural thinking via elvis,
    #     and cX state as transactions
    # < everything believed goes through elvis,
    #     then it can be natively from somewhere
    # < el.y.A having 4's being-there consciousness,
    #     partly workable out of frames
    # 
    # e async is ok, n async only if truthgap or sleep/later scheme
    #   your meanings may vary that
    #   eg elvising from G&ting to look up a /js/ would throw async
    #    placing some W:js question,
    #     which could trust cache
    #     look it up in a variety of places:
    #      /W/Somewhere/ju/$t.js for <script>
    #      /W/Compiles/$t is W:$t inc I
    #     or even build it:
    #      make W/Compiles/$t from ghost,
    #      elvising codes to W:js, compiles I
    #        of wants to keep
    me.Ravelvis = &acgtRWkDc{
        # there
        $el = typeof W == 'object' ? me&introqua,W
            : me&stackTe,[W];
        # lives (async awake) (if $Elvisory/$el)
        els&J = 1;
        
        # may be sc
        c and ex(el.sc,c)
        # then cc&el
        c ||= {};
        c.c ||= {};
        # hook
        k == null and 'nothing doing, just async awake'
        elsif (k == '9') {
            i 4s&elvisory/-#$W
        }
        elsif (k == 'M') {
            if (els&M) {
                me&yfuture,els&M;
                els&M.indexOf(D) >= 0 and cc&el = 8
            }
            ac(el,'M',D)
        }
        else {
            throw "elvis?"
        }
    };
    #c Domingness mund ravelabhion straight curvy cellvey
    # < goneRbitX as savepoints
    # < regroup... me&Rom, etc, ways to do things
    #  elvising, everything sleeping until laters wake em,
    #  doming as the flow of signal/control
    #  and physical space, esp code
    #  general linkage to phil somewhere


    # finds r = t/** at depth p
    #  adds to their rs&Mw.rolltog about may:k
    #  returns list of r that are on
    me.iostyle = &acgttpk{
        # < p for path, [y,M] for ioty
        typeof p != 'number' and throw "Set depth p"
        $N = me&ioty,t,p;
        $M = [];
        each ir N {
            if (k == 'Look') {
                # resists mess
                $show = me&rolltog,r,{may:'Look'},0;
                !show and rs&nofurtherDisplay = 1
            }
            else {
                # Rs&$k takes the ball, once?
                $c = {may:k,once:1};
                #k == 'Upload' and delete c.once;
                $doing = me&rolltog,r,c,0;
                doing and M.push(r);
            }
        }
        return M
    };
    
    # i $v/@s o $r/*
    #  complicatedly, using polify/ate
    # can clone-over but keep certain children etc
    #  eg. %Elvisave iostyle's for things to move,
    #   combines them with where they're going,
    #   and uses this to avoid storing/restoring unwanted stuff
    #    eg its own Elvising
    # Elvisoir > mez&clone < e ...
    # the clone-over (or not) usuality,
    #  no taking the top level
    # < pass D to R:Copy to save it needless work
    me.polout = &acgtvr{
        $R = Cy&R;
        $D = G&Cye,['apolout',{R:R}];
        ac(R,'polout_z',D);
        
        $mez = me&ballio,R;

        # r/* is a land cloning into v/*
        me&polify,D,v,r;
        me&ioty,r,'%ball' .map(&s{
            ac(D,'cloned_z',s);
            # < check in to D, do el4/9 better
            $S = mez&clone,v,s;
            ac(D,'clone_z',S);
            me&Rsync,v
        });
        me&polifate,D;
    };
    
    # r/**%balls N=['path','somewhere']
    me.fabioty = &acgtrN{
        return me&ioty,r,N.length,{st:N,zvia:'s'};
    };
    me.ishad = &acgttN{
        # < partial matches
        N = me&fabioty,t,N;
        N.length < 1 and return
        N.length > 1 and throw "many"
        $f = {r:t,N:N};
        # they to where they had it
        f.row = me.cby(N[0],&r{ return r == t });
        return f
    };
    #c polify
    # i $h/* y o $t/*
    # where anyone can have policies for ...
    # eg keeping $t/Elvisforthis only in $t
    # < discover any overlap, hardwire decisions
    me.polify = &acgtDvr{
        Dy&R != Cy&R and throw "D!R";
        !vs&ball and throw "delt!ball"
        !rs&ball and throw "dealing!ball"
        $vr = [v,r];


        each ih vr {
            $t = h == r ? v : r;
            $po = h;
            each kc pos&pol {
                # po always h(ere), where polcify applies
                # h is v going in, r going out
                #   me&clone,v,r flows <--
                # t(heir) is the other
                # has is for h, have for t

                # check for path
                #  hooks may depend on finding stuff here or there
                $fort = c.forTepath.slice();
                $inwhat = '('+fort.join('/');

                # later referred to as f
                $has = me&ishad,h,fort;
                $have = (c.either || c.their) && me&ishad,t,fort;

                !(has || have) and continue

                # adds a polification
                $lo = G&Cye,[k,1,c];
                c&pi = 'polify';
                ac(D,'z',lo);
                # builds an act, for in/around cloning
                # f (has|have), el=s, r? (if!=f.r), callback?
                $sync = me&polsync,lo;

                los&here = h;
                los&has = has;

                los&their = t;
                los&have = have;

                h == r and los&leaving = 1

                if (los&leaving) {
                    # have something, protect them from it?
                if (loc&nonleaving) {
                    # < avoid cloning out things that don't move
                    #   Copy untils, to catch the same tving sesh
                    # they might have something to preserve
                    have && sync(have,4)
                    ||
                    # climb has there and delete
                    has && sync(has,9,t);
                }
                }
                else {
                    # given something, protect us from it?
                if (loc&nonoverwrite) {
                    has && sync(has,4)
                    ||
                    have && sync(have,2,h);
                }
                }
            }
        }
    };
    #c polifate
    me.polsync = &acgt,lo{
        return &fsry{
            loc&sync || loc&el and throw "doublesync"
            !s and throw "no el"
            loc&el = s;
            $sy = loc&sync = {f:f};
            typeof r == 'function' and y = r; r = null
            # this f/row can be tried somewhere it wasn't:
            r and sy.r = r
            y and sy.cb = y
            return 1
        }
    };
    # post-clonial
    me.polifate = &acgtD{
        each i,lo Ds&z {
            $sy = loc&sync;
            if (sy) {
                $f = sy.f;
                $bet = f.row.slice();
                # the thing before
                $v = bet.pop();

                # < code these more positively: $t is= bet.shift()
                f.r != bet.shift() and throw "here not t", "bet.shift()"

                # the thing we change
                $r = sy.r || f.r;
                # walk almost there
                # < many f.rows
                $n = me&fabioty,r,bet.map(t=>tc&s.t) [0];
                if (!n && loc&el == 4) {
                    # rebuild between r and v
                    $rr = r;
                    each it bet {
                        n = me&fabioty,rr,tc&s.t [0];
                        1 && n and rr = n; continue
                        # < input,rr,t recycle/refology/fork
                        n = me&input,rr,tc&s;
                        rr = n;
                    }
                }
                if (n) {
                    # grab what is there now
                    $cs = nc&s;
                    $ks = vc&s;
                    # < should know it's a Copy
                    $si = me&fabioty,n,[ks.t] [0];
                    $is = si && sic&s;
                }

                # do something
                if (loc&el == 2) {
                    ac(lo,'todo',"Accepted over nothing: "+kss&play);
                }
                elsif (loc&el == 4) {
                    !n and throw "Deep 4"
                    # el:4 leaves things,
                    # < may move subjectiver experience
                    # unoverwrite what was there
                    if (is) {
                        los&removed = is;
                        i $cs/-$is
                    }
                    $en = me&input,n,ks;
                    me&Rsync,en;
                    ac(lo,'todo',"Unoverwrite: "+(is&& iss&play)+'->'+kss&play);
                }
                elsif (loc&el == 9) {
                    !n and throw "Deep 9 ok?"
                    # ensure v is deleted once there
                    los&removed = is;
                    i $cs/-$is
                    me&Rsync,n;
                    ac(lo,'todo',["Drops:",r,n,v]);
                }
                else {
                    throw "sync el "+loc&el
                }
            }
        }
    };
    #c Be.sR theory - adjust raised sticks
    # at %ball%play
    =pod
    s&R:
      how to conjoin an other:
    the ground wakes up, doing a J (R for now)
    from a C%ball describing the J
    
     %R=+Save gives %ball%Save
       < separate that kind of thing to %A
      
    if no ^^4%Gens:
     R=Tool makes %ball/r%Tool
       s.sc -> r.sc
       s%z -> r%nz
         is the out %ball cluster continuing inside
           waking up into this layeR
    else:
     R=Tool makes %ball/s.t%Gens%ting/r%Tool
      %Gens creates the thing with memory
       if sc&el=1
         !%ting
       else
         initialises Livec&Tool=1,
           out-s* able to form high level pictures
         Live.c also -> r.sc
    
    %R=1-9 turns into %Doming (the slope)
    
    < %MindInto projects R=... to make thinks into Know/**%ball
      leaving the insphere intermediacies savable
    
    < above may have %methods to continue through our being
      %methods over slopes
    
    %Gens:
      for/in R%ball (usually)
      wakes up R/%Gens/r with its memory
        got via %Gens%ting unless in outs-only mode (sc&el=1)
       < cautiously if no memory:
      < care to authenticate code running by it
    
    %JRom:
      domes it if s&R>=3:
    < elvising (networking)
       %ting consumes stuff from the network
        so people opening the same thing get connected
        and theres a spout for updates/locks
       for acts of change
        to have a formal place
        and they may be 
       see Ravelvis etc
    
    %Gensing:
    < from %Gens, mediates %other <-> %self
      commits a tree in either direction
        syncing pieces required for a coherent there/%other
        as eg the /W/ server would do until all %H are
      
      doing ballio
      
      setting policy
      
      learning qualities
      
      control:
        is an expression separate from data
        
        r%Doming=2, an A.2 slope, unless no ^^4
          levels have many definitions, create slopes
            are points of interest/tingingdoms
        < %whaT to overlay/inject/control
          mucking with I/anything going into it
      
      compression/difference:
        how out%ball -> in%ball
          loading our changes on top of it
          %MindInto out%ball/* are W mixing into it
            in W surfing mode, when you employ %MindInto
        how out%ball <- in%ball
          keeping a vague picture, like %species=4
          %MindInto keeps the 1C only, with $W%H,dig,v,etc
            merging with the Live, which is for notes etc
             mix-figurations
    
    s&W/s&J eventually do this, growing from A.4/A.1
      pinning /way/s.t to define it
    
    'doing from and growing from' will + joints
    
    R=\d+ could mean slopality, instantiatia:
     2: should be remembered
     3: must be Domed
     4: follow children first?
       %MindInto would set this up as its iterating
     5/6: thinkingabout/supposing theyre all processes
    
    < auto %play any %Doming=3/*%R
      supposing theyre all processes,
      not bits of a process
        the for later/someoneelse phenomenon
        the lum, line, probably to do out/in%ball
     < know boundaries, where awareness should end
       usu where %otherstuff begins, or time
       play with making it wake up too hard
    
    < %push/%differ ~s&testrun, less remote
    =cut
    #c Be.sR/ballRom - adjust raised sticks
    Be.sc.R = 'sR';
    me.ballRom = &acgtRs{
        $c = {};
        $sc = ex({},s.sc);
        $k = delete sc.R;
        $z = delete sc.z;
        # R=\d+ could mean slopality
        if (k) {
            k > 1 and c.Doming = k
            else {
                k == 1 and k = '1'
                typeof k != 'string' and throw "refR"
                k = k == '1' ? s.t : k;
                k = k.split('+');
                # R=+Save gives R%Save
                # R=Tool+etc makes r%Tool%etc
                k[0] == '' and k.shift(); c = R.sc
                each i,gk k {
                    c[gk] = sc[gk] != null ? sc[gk] : 1
                }
                c == R.sc and return
            }
        }
        # new being
        # < namestretch over out/9er/in,
        #   making the formers harder to elvis,
        #    is checked in
        c.t = s.t;
        # who knows names
        $Gens = me.cbu(R,'Gens');
        # and history
        $Doming = me.cbu(R,'Doming');
        # s.sc -> r.sc
        ex(c,sc);
        # the outs
        c.other = s;
        # s%z -> r%nz
        ss&z and c.nz = ss&z
        # c carries through Jrom or %Gens
        !Gens and c.Doming ||= 3
        # or via %Gens waiting room
        else {
             c.Gens = 1;
            # c = {t:c.t,Gens:c};
            # < %JRom/%Gens/... 
            c.Doming ||= 1;
            
            # < join some thinking about Doming it 
            # our %Gens%ting will find its %ting
            #  for pathinto (or not if W:thing)
            #  J would wander in and W along
            
            # < something not quite %JRom, concurrent
            # < group time Ringing inside it
            # < lots of weird ways to make callbacks whenever
        }
        
        !Doming and c.Doming = 4
        c.Doming >= 4 and c.task ||= 'rovo'
        
        # packdown from %play
        ac(R,'unplaycb', &{
            each in rs&unDoming {
                n()
            }
        });
        $r;
        # level of Doming...
        # blend ind
        c.Doming <3 and r = me&Ret,R,c
        # another Ringing (Rc&N)
        # instant to the enclosing Ring
        # < unless it makes Arrangements
        # catches throws
        else {
            r = me&Rom,R,c
        }
        return rs&returns || r
    };
    Be.sR = {
    ps_Dc:{Gens:{ohm:0}},
    play: me.ballRom
    };
    #c Rom tries R, catches errors
    # provide headings with pausibles,
    #  errors and s&N coming out
    #  T.* changes and chatter
    # < %Reis with error handlers,
    #   pausible
    # < er + Ring cursor
    me.Rom = &acgtptc{
        typeof t == 'object' and c = t
        !c and c = t
        typeof c == 'string' and c = {t:c}; c[c.t] = 1
        !hak(c,'t') and c.t = t
        if (c.t.substr(0,1) == '%') {
            c.t = c.t.substr(1);
            c[c.t] = 1;
        }
        t = c.t;

        # insist on %JRom enclosure
        !ps&JRom and c = {t:t,JRom:c}

        c.task ||= 'rovo';

        # < explore I by fraction
        c.wantsleep and c.ov = 0.279

        try {
            $r = me&Re,p,c;
            me&Ring,r;
            if (c.wantsleep) {
                if (!rc&b) {
                    #  || !rc&b.y.Display
                    ~nohisttosleep
                }
                else {
                    rs&sleeping = 'wanted';
                    if (1) {
                        # put through the rest of itself,
                        # it may have %sleeping things to do
                        delete rs&ov;
                        me&Ring,r
                    }
                    else {
                        me&Display,r;
                    }
                    #~slept: r.t, r.sc.ci, '>2 '+haks(r.sc).join(",")
                }
            }
        }
        catch (er) {
            $msg = er.message || er+'';
            $async = msg.match(/^async/);
            # can it sleep?
            $b = rc&b;
            if (b && by&Display) {
                # keep last display
                # < warn shadow?
                try {
                    rs&sleeping = 'errors';
                    me&Display,r;
                }
                catch (err) {
                    msg = '!sle! '+msg
                }
            }
            # < packdowns for whatever can't continue,
            #   doming marked through as async?
            #    keep some, G&T/thro may resync from B stack
            
            $n = G&Cye,[Ac&sip,'',{}];
            nc&s = msg;
            nc&er = er;
            # bunch of artifaces, < (t,$s)+
            er.tc and nc&M = er.tc
            
            ns&now = G&time;
            ns&A = A;
            ns&B = Gc&B;
            ns&p = p;
            ns&R = r;
            # to nearest dome with room to think about it
            $JR = me.cbu(p,'erN');
            $erN = JRs&erN;
            erN.push(n);
        }
        return rs&returns || r
    };
    #c Domingness
    me.Domingness = &acgtR{ return [
    # < is really %torun, which is really W:Pass
    # have wanting uphill showing where come
    # set off an experiential perspective:
    # A locality of thing availability!
        ['Doming','3',&acgtRs{
            me&walla,'bd:7.1h5,hu-7';
            if (Rs&Doming >= 3) {
                # W have packdowns
                Rs&unDoming ||= [];
            }
            
            me&tsc,"A."+Rs&Doming;
        },'ift,D'],
        
        #c %Gens save/make automata
        # see Be.sR
        # the part of Jing that is someone elses
        # A tracking its new self down
        ['Gens','25',&acgtRs{
            isC(s) and Rs&other ||= s
            # usu the s)%ball above that %plays
            $s = Rs&other;
            if (s && sc&el == 1) {
                # !%ting
                # ins pulls outs
                s = me&rollbs,R,'self';
                if (!s) {
                    s = Rs&self = G&Cye,Rs&other;
                    # new index at s/*
                    #   modifying original others instantly
                    s.y = {cv:sy&cv};
                    ss&z and ss&z = ss&z.slice();
                }
            }
            else {
                me&rollbs,R,'self';
                # comes from:
                Rs&ting ||= 1;
                # < make toW default behaviour
                #   sproutes have their reason
                Rs&toW = 1;
            }
        },'ift,D'],
        
        ['Gens+ting','31',&acgtRs{
            $Q = Rs&Q;
            $P = Qs&P;
            # download
            if (Qc&el < 3) {
                !P and return me&tsc,'wait%Q%P-only'
                Rs&self = me&Copy,R,Pc&s .c.s;
            }
            if (!Rs&self) {
                if (Qc&el == 9) {
                    # creation
                    Rs&self = G&Cye,[R.t,'',{},{}];
                }
                else {
                    me&tsc,'wait%ting','...'
                }
            }
            Rs&self and Rs&Save = 1
        },'ift,D'],
        
        # %Gens%Here = R:$self%ball
        ['Gens+self','31',&acgtRs{
            $s = Rs&self;
            !s and return
            $c = Rs&Gens;
            c == 1 and c = {ball:1,tightly:1}
            typeof c != 'object' and throw "Gens?"
            c.t = s.t;
            $t = delete c.t;
            c.s and throw "Gens.s!"
            
            $h = Rs&Here =
            n $t  $s:s,R
            # configure inside from out%ball,
            #   which %played s&R, creating us
            #    perhaps with big Doming beforehand
            ex(h.sc,c);
            # set freer
            delete Rc&dubquiet;
            Rc&dupl = 3;
        },'ift,D'],
        
        # general out/in%ball negiator
        ['Gens+Here','4',&acgtRs{
            me&rolltog,R,'%Gensing?',0 &&
                n Gensing  R %Gensing
        },'ift,D'],
        
        ['Gensing','7',&acgtRs{
            $p = Ry&up;
            $N = me&ioty,p
            me&tsc,"Yep"
            me&zu,"GeNN",N
        },'ift,D'],
        
        #c %Save
        # Rs&Q is for saving Rs&Here, which Liness
        ['Save','5',&acgtRs{
            !Rs&Here and return me&tsc,'noHere','!h','B'
            $h = Rs&Here = me&yfuture,Rs&Here;
            
            # want to have a %ting
            if (!Rs&Saveting) {
            Rs&Saveting =
                # %ting%Save itself
                Rs&ting ? R :
                # %Save/%ting
                n $R.t  R %ting:W
            }
            
            Rs&atstage = &s{
                $v = Rs&ForZave ? Rs&Save : (Rs&boost||0)+1;
                return v >= s;
            };
            !Rs&atstage(2) and return
            Rs&noHereEncode and return
            
            # check in
            if (!hs&ball) {
                # the non-%ball process defines another
                # storable in-sphere
                hs&Here and h = Rs&Here = hs&Here
                else {
                    # < errors
                    return me&tsc,"looking-for-in%ball","Here!ball"
                }
            }
            hs&Lines = 3
        },'ift,D'],
        ['Save','71',&acgtRs{
            !Rs&atstage(2) and return
            
            $h = Rs&Described || Rs&Here;
            if (!isC(Rs&Saveting)) {
                me&tsc,'!Sting',null,'G';
                return me&zu,"Savoir",Rs&Saveting;
            }
            $ting = Rs&Saveting = me&yfuture,Rs&Saveting;
            !ting || !tings&ting and return me&tsc,'Save!ting';
            
            $Q = tings&Q;
            $P = Qs&P;
            !P and return me&tsc,'!P'
            !Qs&ready && Qc&el != '9' and return me&tsc,'!ready'
            !h and return me&tsc,'!here'
            
            #me&zu,'here',h;
            #me&zu,'their',P;
            
            !hs&string and return me&tsc,'hs!string'
            
            if (!Rs&Zave) {
                me&introqua,[R,'diff'],'boost','@1';
                me&diffya,R,'diff',h,P;
            }
            
            !Rs&atstage(3) and return
            
            if (!me&rollbs,R,'sent_string' ) {
                Rs&sent_string = Qs&string = hs&string;
                tings&_ting(Q)
            }
            if (Ps&string != hs&string) {
                !Rs&Zave and me&tsc,'pushing'
                return
            }
            !Rs&Zave and me&tsc,'pushed'
            delete Rs&Te.sc.boost
            Rs&Save = 7;
        },'ift,D'],
        
        #c %Elvisave sense grabber
        ['Elvisave','3',&acgtRs{
            Rs&rowish = 1;
            delete Rc&dubquiet;
            Rc&dupl = 3;
            
            # < o ^^%Gens^^%Gens(%Te)
            #   knowing %Te can be made
            $p = Rs&upward = me.cbu(Ry&up.y.up,'Gens');
            $el = me&introqua,p;
            pp = py&up;
            !pp and throw '!pp'
            $L = me&introqua,pp;
            
            me&bal,'Their',L;
            
            me&bal,'Here',s;
        },'ift,D'],
        
        
        ['Elvisave','4',&acgtRs{
            $t = Rs&Their;
            $h = Rs&Here;
            
            # make auto keep this thing's elvising
            # Their/.../Rs&Te is coming in here,
            # make it not part of *load

            # climb atop %ball/%Gens/R, of the same t
            $r = R;
            $N = me.cby(R,&r{ return ry&up && ry&up.t != r.t });
            # then up to the R%upward(%Te -> Their) we capture
            N = me.cby(N[0],&r{ return r == Rs&upward });
            # and make it a non-overwritable,non-leaver
            ts&pol = {
                carefullyTe: {
                    # this path in either t/h
                    forTepath: N.map(r => r.t),
                    either: 1,
                    # will cause t to have
                    nonleaving: 1,
                    nonoverwrite: 1,
                    # which could go as far as nonewt
                    #  to force talking about existing things
                    #  or onlynewt to make first-in locks
                }
            };
            
            # Their
            me&iostyle,t,0,'Look';
            me&iostyle,t,0,'Download' .map(&r{
                $v = me&input,h,'Thus';
                me&polout,v,r;
            });
            # Here
            me&iostyle,h,1,'Look';
            me&iostyle,h,1,'Upload' .map(&r{
                me&polout,t,r;
            });
            
            # keeps knowing last move,
            # < more via NzR
            $lo = Rs&loaded = Rs&polout_z || me&rollbs,R,'loaded',[];
            each iD lo {
                each i,lo Ds&z {
                    me&zu,'lo',lo,'';
                }
            }
        },'ift,D'],
        


        
        #c %iotest sense grabber
        # < wants to store an Elvising for itself,
        #   to be revamped by %Gens
        ['iotest','3',&acgtRs{
            Rs&rowish = 1;
            
            window.iodebug = 1;
            
            $c = me&tsc,"Double"
            i $c/van
            i $c/two
            i $c/two
            $t = me&tsc,"Three"
            i $c/$t
            i $c/$t
            $t = me&tsc,"Three"
            i $c/$t
            
            window.iodebug = 0;
            
            me&zu,c;
        },'ift,D'],
        
        
        #c JRom - safe/pausible R,
        #  handled errors and s&N
        ['JRom','3',&acgtRs{
            me&walla,'bd:2.1h5';
            me&domesticate,R;
            
            # 1 wave matter
            $c = Rs&JRom;
            
            # 2 self, from 
            $D = G&Cye,[R.t,1,{},{}];
            $j = me.cbu(R,'JRomD');
            $b;
            if (!j) {
                $b = me&rollbs,R,'JRomD';
            }
            else {
                j = js&JRomD;
                jy&tw ||= {};
                $b = jy&tw[R.t];
                jy&tw[R.t] = D;
            }
            Rs&JRomD = D;
            
            b and Dc&b = b
            b && by&tw and Dy&tw = by&tw
            Ds&amongst = b && bs&amongst || [];
            Ds&amongst.unshift(D);
            Ds&count = (b && bs&count || 0) + 1;
            D.t = ''+Ds&count;
            
            # 3 what doing
            if ((Rs&boost||0) < -1) {
                delete Rs&Te.sc.boost;
                me&tsc,'JRom-reset','reset','6';
                s&boc = '858';
                c.igV = 1;
            }
            elsif ((Rs&boost||0) < 0 || c.pause) {
                me&tsc,'JRom-paused','paused','6';
                s&boc = '888';
                s&bg = '#002';
                Rs&play and c.hidey = 1;
                Dc&b and c.wantsleep = 1
            }
            c.hidey and s&mah = 30; s&over = 2
            
            # 4 map matters for before/after
            # < down to the gate, know enough to know
            #   everything else (eg e does any further)
            $emto = {sN1:1s&N,sn4:4s&N};
            each kv emto {
                $har = Ds&watchar ||= {};
                har[k] = v.slice();
            }
            
            # 5 partition explosion collection
            $erN = Rs&erN = [];
            
            # 6 do innard
            $began = G&time;
            
            $r = me&Rom,R,'Rom',c;
            # out me&Rom returns in me&Rom
            Rs&returns = r;
            
            # pause if slow
            $max = rs&timetopause || 2.5;
            $delta = G&time,began;
            each tn Dy&tw {
                ns&delta and delta -= ns&delta
            }
            if (delta > max) {
                me&tsc,"("+delta+">"+max+")";
                me&introqua,R,{boost:-1}
            }
            Ds&delta = delta
            Ds&R = r;
            
            # 7
            # s&N
            each kv emto {
                $har = Ds&watchar ||= {};
                $was = har[k];
                $outi = [];
                $N = [];
                each in v {
                    was.includes(n) and continue
                    outi.push(i);
                    N.push(n);
                }
                !N.length and delete har[k]; continue
                # take, for nearest JRom only
                outi.reverse().map(i => v.splice(i,1));
                har[k] = N;
            }
            !hak(Ds&watchar) and delete Ds&watchar
            erN.length and Ds&erN = erN;
            
            # all but topmost should tend to sleep...
            me&Rom,R,'Domeds',{s:Ds&amongst,NzR:'Domed',glamp:9};
            
            # < A-ing slowly: order then consciousness
            #   for summary up the top
            Rs&down && Rs&down.reverse();
        },'ift,D'],
        #c Domed visually Jing R
        # < froth away lots of %balls
        ['Domed','3',&acgtRs{
            me&walla,0,'b:3.1';
            $t = me&domesticate,R;
            ts&hs = '635';
            Rs&sym = "";
            $p = Ry&up;
            # p%NzR cs=[D%Domed+]
            $D = s;
            $r = Ds&R;
            
            # 3 gauge of gauge
            # only latest or Te'd open
            if (Rs&glampi != null &&
                Rs&glampi > 0 && !Rs&Te.c) {
                $b = Rc&b;
                $sym = !b ? "-" : bs&sym || "?";
                tc&s = Rs&sym = sym;
                 return
            }
            # boost<0 and delete (if Te.d)
            if ((Rs&boost||0) < 0) {
                $Di = pc&s.indexOf(D);
                Di < 0 and throw "Di"
                pc&s.splice(Di,1);
                n deleted  s:deleted %fs:6,hs:594
                return
            }
            # Te'd stops delete
            Rs&Te.c and Rs&keeper = 1; me&tsc,'keeper','k','6';
            
            # 4 items of interest
            if (Ds&watchar) {
                # As&N we noticed grow
                Rs&sym += '^'
                each kv Ds&watchar {
                    n $k  $s:v,R %NzR:Attend
                }
            }
            
            if (Ds&delta && Ds&delta > 0.04) {
                $say = G&thime,Ds&delta ;
                me&tsc,'delta',say,6
            }
            
            # errors we caught!!!
            if (Ds&erN) {
                Rs&sym += '!';
                n Errors  $s:Ds&erN,R %NzR:Error
            }
            # oberve limits
            rc&N[0] != r and throw "not h"
            rc&ha and me&zu,'rc\&ha',rc&ha
            
            rs&sleeping && rs&sleeping != 'errors' and Rs&sym += 'á›'
            
            Rs&sym ||= '.'
        },'ift,D'],
        
        ['Attend','4',&acgtRs{
            $Y = s;
            
            $nth = Y.t == 'n' && Y.y.cv == 0.13;
            nth && Yc&s.t == 'Pass' and Rs&nthirteen = 1
            !Rs&nthirteen and Rs&keeper = 1
            
            n Y  $self:Y %R:Cit
        },'ift,D'],

        ['Error','4',&acgtRs{
            #Rs&rowish = 1;#
            $skull = 'â˜ ';
            $bigger = me&rolltog,R,{may:skull,tsc:'D',once:1},0;
            
            me&tsc,'message',sc&s,'d';
            
            each in sc&M {
                $n = me&zu,i+1,n;
            }
            
            (Rs&boost||0) > 0 || !bigger and return
            me&introqua,R,{boost:1}
            
            s&fs = 13
            
            n er  $self:s %R:Cit
            
        },'ift,D'],
        

        
        #c NzR, expirez
        # spread Rc&s=N[n+] to many rc&s=n
        #  they have a type that helps NzR or the thing above it
        #  do expirez
        ['NzR','4',&acgtRs{
            Rs&dubquiet = 1;
            # trims to 30s timeframe, not %keepers
            Rs&glamp and Rs&expirez = 30
            $t = me&domesticate,R;
            Rs&NzR+'s' == R.t and Rs&qt = 1
            Rs&qt and t.c.not = 1
            
            $p = Ry&up;
            $outi = [];
            each iY s {
                $t = Y.y == Y ? Yc&sip : Y.t;
                $z =
                n $t  $s:Y,R
                z.sc[Rs&NzR] = 1;
                # inners like a log tail
                Rs&glamp and zs&glampi = i;
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
            
            !z and ts&fs = 7
            0 < i && !Rs&qt and Rs&rowish =  1
        },'ift,D'],
        
        # expiry of care about old A
        # < kind of time we can pause
        # R(cs=[n+]) with r(cs=n)+ self-cleaning
        ['expirez','7',&acgtRs{
            $outi = [];
            each in s {
                $r = Rs&z && Rs&z.filter(r=>rc&s==n)[0];
                !r and continue
                # are %keepers
                rs&keeper and continue
                
                # give %began
                rs&began = me&rollbs,r,'began' || G&time;
                $much = G&time,rs&began;
                
                # things time out or overpopulate
                $out = much - Rs&expirez;
                $over = Rs&glamp && i >= Rs&glamp;
                over && out < 0 and out = Rs&expirez
                out < 0 and continue
                
                # < relative scales into styles
                $C = rs&C;
                out < Rs&expirez/4 and s&fs = 8; s&sat = 0.4
                out < Rs&expirez/3 and s&fs = 6; s&sat = 0.2
                out < Rs&expirez/2 and continue
                
                $Yi = s.indexOf(n);
                Yi < 0 and me&tsc,'nofindY'
                else { outi.push(Yi) }
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
        },'ift,D'],
        
        #c %WestCases
        ['WestCases','3',&acgtRs{
            me&walla,'bd:3.1h5';
            
            $n = Rs&Inn = me&Rom,R,'Search';
            Rs&_ting = ns&_ting;
            
            
            $Q = me&rollbs,R,'Quest';
            n t/lvhashave  R %ting:W,Quploadsc:Quest
            
            $c = {};
            me&rollbs,R,'Sampled';
            # while checking in, 
            me&rolltog,R,'Checkin',0 and c.Sampley = 2
            else { delete Rs&Sampled }
            Rs&Sampled and c.pause = 1; c.hidey = 1;
            
            $r = !c.pause && me&Rom,R,'%lvhashave',c;
            
            
            # r.sc will not roll when pause/sleep
            r && rs&Sampled and Rs&Sampled = rs&Sampled
            
            if (Rs&Sampled && Q) {
                $P = Qs&P;
                $h = Rs&Sampled;
                
                n here  $self:h,R %Cit
                n Pull  $self:P,R %Cit
                !P and return me&tsc,'P...'
                !h and return me&tsc,'h...'
                #me&introqua,[R,'diff'],'boost','@1';
                me&diffya,R,'diff',h,P;

                !me&rolltog,R,'Push?',0 and return

                if (!me&rollbs,R,'sent_string' ) {
                    Rs&sent_string = Qs&string = hs&string;
                    Rs&_ting(Q)
                }
                Ps&string != hs&string and return me&tsc,'pushing'
                me&tsc,'pushed';
                delete Rs&Te.sc.boost;
            }
        },'ift,D'],
        
       ##c wedness do next!
    =head1
    flav
       %ting:
         a search or put, any type
         explains G&ting
         < ting both sides of it:
           (/G/Wway=/W/way)/$wcs would G&way
           (/spot/ja=/W/js)/$W would /js/
           then poll Wormhole for everything
         get (< put) .4/5, highly surfable
          < unify for an area
           < become the living someone via /W/
         < are name claims, applying or retrieving
           what of/directory selfs, .t others
       everything is, look at it in stylehouse to edit
       
       < %ball format more
         all %string hidden
         < inheritable & auto Tie/roll
         < c&s protruded
         < c % sc division
       
       < merge %torun/%mund, convert %garbec
       the %mund is posting things around,
         including its own insides,
         see 'one big %ball, some of it grounded' ^
       
       tracks stored compilings, eg:
        /W/way/$w -> /W/Comp/$w
         or -> some collection of ways
           a g/(\w+)/(\d+) is such, looks like kv yaml
           is really lots of n $t  $s:... %of:way,%comment:...
       < bringing it back via G&ting /js/ or /way/
        < read our /W/Comp/$w_$dige.js
       
       primarily for:
        using %oph to build I
         < having Babz already done to blockquoted things
           by /wayz/, otherwise like /way/
         < including %Give deps, versions of way/W going into it
         < storage-specific metadata, see w:Writer
           could simply be in the local W:Office
           things to see changing out there to awake
       
       but also:
        translating old -> new ghosts:
          io.*, me.* into W with of:W but not W:of
           such are the new ghost objects
            as g/\w+/\d+ but with a 9,
            thence all of io is in one tidy packet,
            its source compiles out closer to you,
            its tests compile into Tests
          NutMachine probably wants conversion
            perl builds it atm,
             /js/j for acgts, etc
             using 1C&of=js instead of the n \'of:js'
       
       'specifically' for leaving 'GhoNut'
        !
        others involved:
     %Give - ghost versioning
       knowing exactly each I it ran with
       see W&Lis
     W&Lis
      magical W access syntax, via t
    =cut
    #c %mund = GhoNut / ForThe(MindInto) + ChangeInto
    # wensdine, generalise to 4
    # just ForThe new infrastructure,
    # then ForThe becomes Composited from what desires:
    # < provide specifics (ForThe) layout from W,
    # < Pass and Domingness
        # the 5
        ... (me.Fourismness ? me&Fourismness : []),
        
        ['mund','29',&acgtRs{
            me&walla,'hu:7';
            Rs&timetopause = 3418;
            # remotes
            # news from the old editor
            me&Rom,R,'GhodigWap';
            # newsroom behind the %ting
            Rs&Inn = me&Rom,R,'Search';
            # for that constant EleMento async
            Gc&ttl = 3600;
            # runtime
            me&Rom,R,'GhoNut';
            
            # etc
            #me&Rom,R,'WestCases';
            #me&Rom,R,'JRomnotes';
            # here-genera looking
            me&Rom,R,'Loscba';
            
            
        },'ift,D'],
        
        ['Loscba','3',&acgtRs{
            # watch for errors from that lv thing
            4s&hashavefail &&
                n hashavefail  $self:4s&hashavefail %R:Cit
            
            # sidechaining also ju compiles,
            #   A:u testing how we J-J mix I
            n A4smind  $self:A.4.sc.mind %R:Cit
            $f = A.5[4];
            n A54er  $self:f %R:Cit
            n A545er  $self:f.5 %R:Cit
        },'ift,D'],
        
        # the 4
        ['GhoNut','3',&acgtRs{
            me&walla,'hu:17,wi:1.7';
            s&bgh = '111';
            
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });
            n Elvito  R %Tool
            
            # user
            # < sums diges
            Rs&forth = me&Rom,R,'ForThe';
            
            # remix
            me&Rom,R,'ChangeInto';
        },'ift,D'],
        
        # make a bunch of %tings!
        # < all hoisting into ForThe, transport workbench
        ['ForThe','3',&acgtRs{
            #Rs&tingspot = 1;
            
            n ForThe  R %ting:W,Gens,tingspot
            #,MoreForThe
        },'ift,D'],
        ['MoreForThe','3',&acgtRs{
            n Stylehut  R %ting:W,directory:spot/je/
            n NutMachine  R %ting:W,directory:spot/ju/
            n Foogla  R %ting:w
            # random
            n Pass  R %ting:W
            
            # destinations are 5
            #  for /way/
            #   to start Rs&_ting from an eval
            n WayInto  R %ting:W,directory:Rew/
            #  for /js/ that must hack up a bit
            #   sweep eye into i
            n MindInto  R %ting:W,directory:Rejs/
            # < get that done now, to 6
            #S /@6
        },'ift,D'],
        
        
        
        # for a bunch of %tings
        # < and their %More ... %tings
        ['ForThe','4',&acgtRs{
            $N = me&ioty,R,'%ting' .map(n => ns&Q);
            # like G&ting,of,t
            # < usable from, is a known interface
            Rs&tin = &st{
                each in N {
                    nc&of == s && n.t == t and return nc&s
                }
            };
            # like A 8, returning a .5 (things depended)
            Rs&eight = &{
                $C = G&Cye,[R.t,''];
                each in N {
                    i $C/#nc&of/#$n:s
                    yas&dige = ns&dige
                }
            };
        },'ift,D'],
        ['Elvising','4',&acgtRs{
            me&tsc,"4Elvising",0,'B'
            me&zu,4s&elvising;
        },'ift,D'],
        
    #c 4 MindInto->SupplyChai will/what to mix+how
    =pod
    %Gens forms a %MindInto
     tools to Mix Stylehut + NutMachine + more
      with sessions of map building on top
      selects what to include
      or edit, or delete
      knowing how it mixes already
    =cut
        # %SupplyChai Composer
        ['MindInto','30101',&acgtRs{
            # wait for R/*%ball to kinda happen
            #me&bewind,R and return
            
            me&rolled,'SupplyChai';
            
            $g = me&opeolo,'MindInto';
            # zuct not (notes) in there ^ 
            me&ioty,R,'','not' .map(&r{
                $m = gy&can('n','not');
                ms&dis = 1;
                me&zuct,m,r
            });
            
            # look for R/r(%SC to be about
            me&ioty,s,'SC','' .map(&z{
                $t = zs&SC;
                $c = gy&can('m','SC-able');
                $n = cy&can('n',t,{label:1});
                
                ny&can('ope',&{
                    R.sc[t] = 1;
                    Rs&SupplyChai = 1;
                    # need to pick an SC-able drops
                    $ml = cy&label;
                    mls&fs = 6;
                });
            });
        },'ift,D'],
    
        # SupplyChai ~ as osc would have it
        =awaits
        
        intro object, runs doming + waigh-sense
         with a bunch of tools for ...
          that nk,gk is meant to use the same piece as t,y
        
        =pod
        ['SupplyChai','305',&acgtRs{
            T.Mw = 'SC';
            # wait for R/*%ball to kinda happen
            #me&bewind,R and return
            
            # phases: to be minding the steps
            
            $SC = me&SCs;
            # steps congealed
            $s = me&SCA,SC,{},1;
            #debugger;
            $s = me&SCA,SC,{},9;
            
            #me&nu,'SC',SC;
            #me&nu,'SCminds',me.SCminds;
            
            s&boc = 588;
        },'ift,D'],
        
        #c SC-etc
        
        # the %eph and its /** become %supr
        #  and %$sy&supr - suprise puts that
        ['ball+supr','291',&acgtRs{
            sy&R = R;
            # children get %supr in time to get here
            ac(R,'inheritsc','supr');
            # our %ball/%fix appear after @4
            Rs&fixatfour = 1;
            # %supr only becomes %$supr if a node:
            #  me&suprise mostly just transfers it
            #   to sy&supr on entering a node
            sy&supr and R.sc[sy&supr] = 1
            # see Y:Steps about %nextlifesc %nottilund
        },'ift,D'],
        
        # < say how many whats are in there
        ['folder','29',&acgtRs{
            T.Mw = 'folder';
            $c = {may:'unfold',s:'+',tsc:'L'};
            $v = me&rolltog,R,c;
            $n = c.n;
            ny&cv = 0.01;
            ns&fs = 23;
            $wa = C;
            !v and s&fs = 8; Rs&nofurtherDisplay = 1;
            me&walla,'b:2.2';
        },'ift,D'],
        
        
        # ordering peers
        # do Some:n/First:m before Later:n/Some:m
        # < supposing they emerged as changing all at once
        # probably in order already
        # may hang, choose to start:
        # < smallest changes and/or deepest/widest inclusion first
        # < include back and forth until settled?
        #   if inclusion changes behaviour of W its in,
        #   once we start compiling u for processes out there
        #   esp. n a using u a to define itself
        ['Omplateau','312',&acgtRs{
            $inside = &s{
                aha(sy&R,'wou') ('mot:later,fro:inside,ste',s)
            };
            # < [s, ... map{zy&N} ss&z]
            $N = me&ioty,s,[''];
            $h = {};
            each is N {
                !sy&supr and throw "los"
                $b = h[s.t];
                h[s.t] = s;
                b and inside(s);
                each in sy&N {
                    $b = h[n.t];
                    h[n.t] ||= n;
                    b and inside(n)
                }
            }
        },'ift,D'],
        
        ... me&Chaiingness ,
    ]};
    # has a ting for itself (signpost for island)
    # eg ForThe/Know/tings%ting, usu 404, mainly to:
    #  %folder the rest of the %tings inside
    me.tingsfolder = &acgtRr{
        $S = me&bal,'tings',{R:r,eph:1,folder:1};
        Ss&ting = 'W';
        # < imply %dir=F/K/ inwards but be F/K ourselves
        #   the kind of %ting that draws pointing inside
        #   its dir/t becoming the implied dir yonder
        #   a gravity of the wormhole
        # puts **%tings in ForThe/Know/*
        Ss&directory = R.t+'/'+r.t+'/';
        return S
    };
    
    #c SC-f
    # climb up
    me.aplup = &sy{
        me.cbu(sy&up,&s{
            me&yfuture,sy&R,R; # sanity
            $j = sy&R;
            $ha = jy&ha;
            !ha and throw "aplup syup!yha"
            y(ha,j,s)
        })
    };
    # < distant future G&t along y-ers to it,
    #   remembers what it saw/thought mattered
    me.supry = &acgtstvc{
        c ||= {};
        # gets yf
        $nk = t.substr(0,1);
        $gk = t.substr(1);
        # travel via yl
        $nv = v.substr(0,1);
        $gv = v.substr(1);
        $first = s;
        $h = me.cby(s,
            &s{ return s != first && s[nk][gk] },
            &s{ return s[nv][gv] }
        )[0];
        $vo = h && h[nk][gk];
        c.fat && !vo and throw "no "+nk+"&"+gk+"-ward "+nv+"&"+gv+" from "+s.t
        return vo
    };
    
    # GONER
    # could become about the different waves of same t?
        # y&f brought to it - design flaw
        # Comal@31 wants to grab f of Know + That
        #   then know either change unto 32
    # percolate eg ry&f from r(y&l)+y&f
    # return 1 if non-init change
    me.supread = &acgtsc{
        c.via ||= 'l';
        $change = 0;
        each nk,gk,v c.bring {
            $h = me.cby(s,
                &s{ return s[nk][gk] },
                &s{ return s.y[c.via] }
            )[0];
            $vo = h && h[nk][gk];
            !vo and throw "no "+c.via+"-ward "+nk+"&"+gk+" from "+s.t
            $cha = me&persis,s,nk,gk,vo,{changeok:1};
            cha and change = 1
        }}
        return change
    };
    
    # sets eg sy&f and then checks it doesn't change
    # unless c.changeok: returns 1 if change (once set)
    me.persis = &acgts,nk,gk,v,c{
        c ||= {};
        $ov = s[nk][gk];
        $change = 0;
        !ov and 'new'
        else
        if (ov != v) {
            change = 1
            !c.changeok and throw "!persis: "+s.t+"'s "+nk+"&"+gk
        }
        s[nk][gk] = v;
        return change
    };
    #c SCAing
    # start Aing as a way to find C about how to A
    # we have the t
    me.SCAing = &acgtRsc,sc,SC{
        # incv - allows doing Ycv==tcv
        #  usu so many at == cv all happen
        $incv = delete c.ashocks&&c.cv;
        # awareness may already be in sy&Y,
        #  which will already be:
        $Y = delete c.Y;
        Y ||= Cye(['A:'+c.t,'']);
        # A:$t cv-ov are life + time to be
        # < see me&tempwind undoing some of this, 
        ex(Y.c,c);
        Yc&ov and Yc&ov = sca(Yc&ov)
        Yc&cv and Yc&cv = sca(Yc&cv)
        # its quest for a specific etc
        ex(Y.sc,sc);
        # of this routine
        Yc&N = me&SCmind,Yc&t;
        $il = 30;
        while (1) {
            il-- < 0 and throw "ManySCAing"
            $ci = t ? Yc&N.indexOf(t) : -1;
            $t = Yc&N[ci+1];
            !t and break
            ty&cv > Yc&ov and break
            ty&cv <= Yc&cv && incv != ty&cv and continue
            incv = ty&cv;
            # to the insides from s=SC
            $M = Yc&M || [s];
            each in M {
                # t act, n ground
                # can't always trust whatever these might be:
                #$r = ny&R || sy&R || Cy&R;
                # R is from the SCA above (R%SC)
                # < elabourate argumentation
                tc&s(A,C,G,T,R,Y,n,SC);
                Yc&cv = ty&cv;
            }
        }
        # so Y looks @2, if last ty&cv < 2
        Yc&cv = Yc&ov;
        Yc&M and Yc&M.map(s => sy&Y = Y)
        return Y
    };
    #c SCA - to be Aing SC**
    # $s = me&SCA $s(y&Y) $mind? {Y.sc intro} $ov||=9
    me.SCA = &acgtstc,ov{
        $R = Cy&R;
        isob(t) and ov = c; c = t; t = null
        # ov='o2' -> @02
        isst(ov) && ov.substr(0,1) == 'o' and ov = ov.substr(1)/100
        ov ||= 0.9;
        
        # may be inside SC
        # < slope sy&up and know stuff, part of wider Aing
        $dive = me.cby(s);
        $SC = dive[0];
        
        # init a possibility
        #   they may resume their previous cv/ov after
        # s may have sy&Y to continue,
        # or begin:
        #  forks@01 - alters Yc&M=[s]
        #   the ground/world/atoms we want to be,
        #   may structure them itself, eg:
        #     $h = me&SCA,SC,'Schema',{t:t},1
        #   makes $SC/Schema/$h named $t with hy&Y = Y
        #   or if still Yc&M=[s], sy&Y = Y
        # or resync:
        #   if sy&R is not current
        #  on@02 - join macro A (eg R)
        #   so it can give/take grounds there
        
        $diffR = sy&R && me&yfuture,sy&R != sy&R;
        $Y = sy&Y;
        
        
        $difft = t && Y && Yc&t != t;
        if (!Y || diffR || difft || ov <= 0.1) {
            # s may look like the mind its expecting
            t ||= Y && Yc&t || ss&of || s.t;
            # start/resync the Y
            if (Y && Yc&t != t) {
                # going to fork a different Y,
                #  happens as we SCA,SC,'Schema',... when SCy&Y
                # < knowing we came from this Y (is in sy&up)
                Y = null;
                # < some Aing of Y to use a different mind
                #   wouldn't go here
                #  it's a different Y...
                #   a layer projecting C alterations into te pipeline
                #   Y:Comste has Y:Encode travelling
                #    such Y:Nodes from Y:Step
            }
            
            # about this vector if init:
            $gen = {cv:0,ov:0.1};
            if (ov <= 0.1) {
                # low ov takes init temporality,
                if (!Y || (Yc&cv||0) < ov) {
                    # from (after) current low cv, to this low ov
                    gen.cv = Y && Yc&cv || 0;
                    gen.ov = ov;
                }
                else {
                    # including cv=ov, to 0.1 as usual
                    c.ashocks = 1;
                    gen.cv = ov;
                    gen.ov = 0.1;
                }
            }
            
            # here's the Yc&t - SCmind to have
            gen.t ||= t;
            if (Y) {
                $wascv = Yc&cv;
                # put cv/ov back where they were after
                $cb = me&tempwind,Y.c,gen;
                # may skip forks@0.01 if sy&Y
                gen.Y = Y;
                gen.cv ||= 0.01;
            }
            
            Y = me&SCAing,R,s,gen,c,SC;
            
            $thencv = Yc&cv;
            cb && cb();
            # keep a progressed cv
            #  if cb() wound back as expected
            if (wascv < thencv && wascv == Yc&cv)
                Yc&cv = thencv
        }
        
        # Yc&M would be different if it was complicated forks@01
        # < persis this
        Yc&M ||= [s];
        (Yc&M||[]).length == 1 && Yc&M[0] == s and sy&Y = Y
        
        # < Aing >1 may now sc=c
        #  until sc.ov etc conduces a decision to etc
        Yc&cv < ov and Y = me&SCAing,R,s,{Y:Y,ov:ov},c,SC
        
        # sy&Y to say "needs /schema/*"
        return Ys&returns || (Yc&M||[])[0]
    };
    
    #c SCA-f process composition
    
    # each school (of thought) eg %KnowThat
    # gets mixed/attached/progressed
    # With: local knowledge about certain names etc
    me.SC = {};
    me.SC.A = &acgt{ [
        ['on',0.02,&acgtRYs,SC{
            s != SC and throw "should init the one"
            sy&R = R;
            sy&Y = Y;
            # list of atoms to loop, default:
            # Yc&M = [s]
        },'ift,D'],
    ] };
    
    # get I = me.SC.$t
    me.SCminds = {};
    me.SCmind = &acgtt{
        !t and throw "SCmind!t"
        $N = me.SCminds[t];
        N and return N
        !me.SC[t] and throw "SCmind!t:"+t
        $N = me.SC[t](A,C,G,T);
        N = N.map(n => Cye(n));
        N.map(n => n.c = {s:n.c})
        me.SCminds[t] = N;
        return N
    };
    
    # when SCA about to ex(Y.c,gen)
    # returns function to replace originals
    #  not exception handling, a brittle strategy
    #   maybe it could have a stack of jobs in Y.sc
    #   to be plucked into Y.c, committing to it
    # to allow SCA to temporarily be:
    #   SCAing 0-1 every time we SCA,
    #   is really another A's work,
    #   though it might still present this A (Y)
    #   as the Y to I that don't know the distinction
    me.tempwind = &acgtcs{
        $set = {};
        each kv s {
            hak(c,k) and set[k] = c[k]
        }
        return &{
            each kv set {
                c[k] = set[k]
            }
        }
    };
    
    # ah() for C with A (Y) sense
    # < more than one level
    # < io pipes A to A
    # auto ny&up = s
    me.SCio = &acgtstc{
        c ||= {};
        isnu(c) and c = {el:c}
        # many
        t == '' and return me&ioty,s,[''],['']
        # read only
        $n = fio(s,t,0);
        # 7 must be there, 8 read only
        c.el == 7 && !n and throw "No "+s.t+"/"+t
        c.el == 8 || c.el == 7 and return n
        !n and c.el ||= 1
        else {
            # if we were placing a different object
            isob(t) && n != t and c.el = 1
            # remove the one we found
            c.el == 1 || c.el == 9 and fio(s,t,9)
        }
        if (c.el == 1) {
            $n = fio(s,t);
            # inputting sets y&up
            ny&up = s
        }
        c.Y and ny&Y = c.Y
        return n
    };
    #c SC.SupplyChai
    
    # the oscillator's sense
    # %SC=1 became rolling C
    me.SCs = &acgt{
        $R = Cy&R;
        # causes %SupplyChai to happen later
        $SC = me&rollbsc,R,'SupplyChai';
        return SC;
    };
    me.SC.SupplyChai = &acgt{ return [
        # @1 figure out where things are at every so often
        ['forks',0.01,&acgtRYs,SC{
            # steps etc wai %wou
            $woudef = &c{
                return me&waidef,c,'',{k:'wou'};
            };
            SCy&waia = &jc{
                !j and return &{}
                jy&R and j = jy&R
                c = woudef(c);
                # G already @7, use the one of it
                js&Gracto and delete c.b; c.gh = 'gh'
                return me&waier,j,c || &{}
            };
            SCy&tip = &jc{
                c = woudef(c);
                return me&brackdown,j,c
            };
        },'ift,D'],
        
        # @02 when R%SC relives,
        #  ~SCy&R winds SCy&Y back to here
        ['on',0.02,&acgtRYs,SC{
            s != SC and throw "should be the one"
            sy&R = R;
            sy&Y = Y;
        },'ift,D'],
        
        #  mix Schema/$h/$p into Steps/$p
        # < Schema knowing export to Steps/$p
        #   or sharing as $p:step, and Steps inhales :steps
        ['Schema to Steps',0.021,&acgtRYs,SC{
            $Sch = me&SCio,SC,'Schema',7;
            Schc&compiled and return
            $N = [];
            me&SCio,Sch,'' .map(&h{
                me&SCio,h,'' .map(p => N.push(p))
            });
            tvsortz(N);
            # start new Steps
            #  SCyYct != 'Steps', so will @01
            #   which recreates SC/Steps
            #     if it didn't we could make it:
            #       $was = me&SCio,SC,'Steps',9;
            #   and imports new Steps/$p
            s = Ys&Steps = me&SCA,SC,'Steps',{N:N},'o2';
            
            ~>3 Compi: SC.t
            Schc&compiled = 1;
        },'ift,D'],
        
        # @023 Steps per R%SC
        ['Steps per R',0.023,&acgtRYs,SC{
            # covered by Schema always recompiling
            #me&SCA,Ys&Steps,{},'o2';
        },'ift,D'],
        
        # @023 Steps per walk through Y:SC
        #   pull up a map for this Aing,
        ['Steps per walk',0.03,&acgtRYs,SC{
            me&SCA,Ys&Steps,{},'o3';
        },'ift,D'],
        
        # @023 Steps take walk through Y:SC
        #   pull up a map for this Aing,
        ['Steps walk',0.6,&acgtRYs,SC{
            me&SCA,Ys&Steps,{},9;
        },'ift,D'],
        
    ]};
    
    #c SC.Steps
    # Y:SC/Y:Steps/$p:step
    # @01 downloading from Ys&N (Schema/*/$p)
    # @02 having r and its s
    # @03 runtime oncily
    #   grasps/feeds the whims of the steps
    # for r that might be any of (p,r,s),
    #   find the one we want
    # eg r=p||s, uses yR
    me.yasp = &acgtrk{
        r && r.y [k] and r = r.y [k]
        return r
    };
    
    me.SC.Steps = &acgt{ return [
        # compulsive recreate SC/Y:Steps, give z of Ys&N
        ['forks',0.01,&acgtRYs,SC{
            $s = Ys&returns = me&SCio,SC,'Steps',{el:1,Y:Y};
            sy&Y = Y;
            # a&N[$p:steps flow into @02
            Ys&N .map(p => me&SCio,s,p );
        },'ift,D'],
        
        # per R%SC:
        # @02 as Y:Steps each $p:step has r which has s
        ['steps are',0.02,&acgtRYs,SC{
            $s = Ys&returns;
            sy&R = R;
            # reverse: bal shall adjust Rs&z to flow upwards
            ss&z.slice().reverse().map(&p{
                $n = py&Schema_step;
                # bal inputs to ups%ball, unless %eph
                ns&supr && !ns&tings and ns&eph = 1
                # n.sc -> r.sc
                $r = me&bal,n.t,n.sc;
                $s = rc&s;
                # n.c -> s.sc
                ex(s.sc,n.c);
                py&s = s;
                sy&p = p;
                # < is b
                py&R = sy&R = r;
            });
            # goes on as each SC/Steps/$p
            SCs&steps = Yc&M = ss&z;
            # GOING
            Rs&Lastly = ss&z.slice().pop();
        },'ift,D'],
        
        # still per R%SC:
        # @021 each Steps/(p,r,s) attr init
        ['on',0.021,&acgtRYp,SC{
            $r = py&R;
            $s = py&s;
            
            rs&tings and ss&trac = 'ting'
            # G, storage type of step
            # < non-first G:step may not Gracto immediately
            ss&trac and rs&Gracto = 1
            
            # prefer specific tw, altering supr-isms
            # they seem to have storable ambitions
            # eg including to /W/ ways to use
            #   With/$trick/$hack
            #    + $hack = $trick trick
            #   and SCinway
            ss&tw and rs&tw = ss&tw
            #  allowing calm isolated spacewalks
            rs&gently && rs&Gracto and rs&tw = 1
            
            # enough to have Rs&C, Rc&b, etc
            me&Ring,R,{und:r,ov:0.28};
            
            if (rs&Gracto) {
                # should wake first
                ps&priority = 1;
                # hide networking pile
                #  and imply %directory=$R/$r/
                #  tractings %directory out of being W/$R/$r/$t
                $S = me&tingsfolder,R,r;
                # do %tracting
                ss&trac != 'ting' and throw "othertrac"
                me&tracto,r,'ball','ting',S;
            }
            
            # prevent early %ball etc until we Ring und:it later
            # or grounds might happen too early to %supr@291
            #  works anyway if you don't bewind until here
            #   otherwise the bewind will wait forever
            #rs&supr and rs&nextlifesc = {nottilund:1}
        },'ift,D'],
        
        #c Y:Steps per current walk around
        # < Y:Walk - delivering the goods or not this dome
        #   decides if it's done or to keep going around
        #     like c&e's T.pos/T.el
        #   then Y:Steps decides whether to multiply Walks per Step, etc
        # 
        # @03 each Steps/(p,r,s) wake up, have features
        #  may be different, may be time to something!
        ['on',0.03,&acgtRYp,SC{
            $r = py&R;
            
            # p's current walk around Y:Steps
            $Ob = py&O;
            $O = py&O = Cye([p.t,py&cv]);
            Ob and Oc&b = Ob; delete Obc&b
            
            !rs&supr and return
            
            # < know if this is to sleep, and
            # < avoid suprising to it etc
            #   do it more elvisily
            # so we can suprise anywhere along the chain:
            me&Ring,R,{und:r,ov:0.304};
            
            # %supr puts sy&R, Steps@02 puts {s,p}y&R
            me&yfuture,r,R != r and throw r.t+" yfuted"

            # each step/* is sy&top, has pool sy&N
            #  iterate through here to get:
            #   (j,s) - all %supr things inside/including $p
            # < climb however, refs limited to those in sy&N
            py&nodes = &y{
                me&ioty,r,'ball' .map(&j{
                    me&yfuture,j,R != j and throw j.t+" yfuted"
                    js&folder and return
                    $s = jc&s;
                    # must be used on %supr, or anywhere y&N is?
                    !sy&supr and throw "wandering"
                    sy&N .map(s => y(sy&R,s))
                })
            };
            
            # set by %supr@291
            # also to init from suprised
            !rs&Gracto and py&nodes(&js{ me&persis,s,'y','R',j })
        },'ift,D'],
        
        # as if G has mostly happened,
        #   even if it is the next step @6
        ['Gracto',0.3,&acgtRYp,SC{
            $r = py&R;
            
            !rs&Gracto and return
            
            # ting@5 gets %flook():
            me&Ring,R,{und:r,ov:0.505};
            
            # ball+tracting@51 etcs
            me&Ring,R,{und:r,ov:0.58};
        },'ift,D'],
        
        # steps happen in order
        ['Steps',0.6,&acgtRYp,SC{
            $r = py&R;
            rs&sleeping and return
            # Steps
            $S = Ys&returns;
            $i = Yc&M.indexOf(p);
            i < 0 and throw "nop"
            # $p:step's neighbours, earlier and next
            $l = Yc&M[i-1];
            $n = Yc&M[i+1];
            
            # being three states at once
            # la has happened
            $la = SCy&waia(l);
            $ra = SCy&waia(p,{b:1});
            $na = SCy&waia(n,{b:1});
            
            $g = SCy&tip(r);
            $leaves = &jn{
                if (!n) {
                    me&mtsc,g,"nonext";
                    # at the end, zy&l?
                    return
                }
                ny&R and n = ny&R
                
                ~>5 ready: j.t, '->', n.t
                rs&gently && !me&rolltog,j,{may:'ready>',tsc:'y',once:1} and return
                # builds j** into n/
                me&suprise,j,n
            };
            
            # < Y:step could take it from here
            #   to step 12222112232323343456 in one R%SC
            #   usually we have enough leash to do such runs
            #  and to attach the Gractoids more sidily:
            
            if (rs&Gracto) {
                # G already @7, conclude
                #!l and me&mtsc,g,"noprev"
                $N = ra('ready','r');
                each ij N {
                    # < apply/contest/reverse That change
                    leaves(j,n);
                }
                #!N || N.length < me&ioty,r .length and anyGbusy = 1
                # SCfcommit applies change/Cuploadism as they finish
                return
            }
            #c Y:Walk
            if (0) {
                # anyGbusy && rc&b) {
                ~>7 Geeping: r.t
                #rs&sleeping = 1;
                # seems to have children that keep going already
                #  even if we move the bal to SCenter
                # continue;
            }
            !py&nodes and return me&nu,"Bort-!nodes",p
            py&nodes(&js{
                # y&l change already fatal

                # waigh:wou from last time, feedback loop
                #   experience -> notion, notion -> etc
                jy&sa = SCy&waia(j,{b:1});

                # wai:wou this time enterer
                jy&ha = aha(j,'wou');

                # differ before <-> now
                # < caching sa/za, then:
                #   < versioned X, re-waigh if ha since da
                jy&da = &loose,tight,c{
                    return 1; # too-caching wough
                    c ||= {};
                    # what you want/specifically
                    isst(loose) and loose = G&peel,loose
                    isst(tight) and tight = G&peel,tight
                    $sa = SCy&waia(j,ex({b:1},c));
                    $za = SCy&waia(j,ex({},c));
                    !(sa && za) and return
                    $was = sa(loose);
                    $now = za(loose);
                    # gets zu grounding into j
                    $C = js&C;
                    me&zu,'da',{was,now,tight};
                    $cha = {};
                    each kv tight {
                        # k - the column in either
                        # v - change type/reaction
                        #  ref, slep, in/decrease, growth...
                    }
                    return cha
                };
            });

            # @31 domecheck, from!
            me&Ring,R,{und:r,ov:0.31};

            # wouey is wough before 32
            # < assume everything in 31 sleeps 32
            #waia(r,{gh:'ey'});
            #waia(r,{gh:'ey',b:1});

            me&Ring,R,{und:r,ov:0.32};
            
            
            # wough is finally here!
            $za = SCy&waia(r);
            py&nodes(&js{
                # < insist ready is the first column
                #   so we can simply js&wou.*.ready
                $ja = SCy&waia(j,{gh:'ad'});
                !ja('ready') and return
                # j%wou..ready travel on
                leaves(j,n);
                
                # alphabet layercake
                # all our decisions of how are joined
                #  into an over-realm, a computed individual's unity
                #  so decisions that can't be made by either hand
                #  can be made by that mind
                # and wording that so it applies to force around a structure
                #  the decision being to break or not
                
                # < subtype step:Seq's ready to -> step:Compiling
                #   same way step:Compiling would then -> That..G
                #   That..G wants all parents of the things changing
                # < or step:Apply after seq,
                #   or is it This..G?

            });
            me&walls,g,'b:3.3h9';
        },'ift,D'],
        
        # and again to wake things generated into other steps
        #  ie from inside:r, out to where Ring isn't
        ['Steps may other',0.67,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.31};
        },'ift,D'],
        
        # and again to wake things generated
        ['Trip report',0.7,&acgtRYp,SC{
            $r = py&R;
            rs&sleeping and return
            py&nodes && py&nodes(&js{
                js&wough and throw "Hadwough: "+j.t
                $g = SCy&tip(j);
                me&walls,g,'b:2.2';
            });
        },'ift,D'],
    ]};
    #c SC.Schema
    
    # %*T pronounces how it will be, arranging for SCing:
    # A:SC@1 %SupplyChai=C macro laterer
    #  A:Schema@1 %SCh/$t=C micro schema
    #   ...gets finished:
    #  A:Schema@2 can slep & tell macro
    #   @3 with each other, notice late joiners
    #   @4 patterns emerge
    #   @5 decide how to change the game in progress
    #   @6 Ret (via bal) the step
    # SCing:
    # A:SC@2 inits
    #  A:Schema@6 may be moved in here,
    #   to avoid it Ringing outside the SCing
    
    me.SC.Schema = &acgt{ return [
        # %KnowThat forks SC/Schema/t=KnowThat
        ['forks',0.01,&acgtRYs,SC{
            # organise SC's Ys as of/t:
            $Sch = me&SCio,SC,'Schema';
            $t = Ys&t;
            !t and throw "give t"
            # el:1 recreates, string t makes spacer
            #  and sets sy&Y = Y
            $s = me&SCio,Sch,t,{el:1,Y:Y};
            Yc&M = [s];
            # drop cache # < wake Y:Schema if diff
            delete Schc&compiled;
        },'ift,D'],
        # day, display zone
        ['on',0.02,&acgtRYs,SC{
            sy&R = R;
            
            $g = sy&g = me&opeolo,s.t,{walls:'b:2.2h6',label:{walls:'bg'}};
            Rc&brackuiet = 1;
            gy&can('ope',&{ Rc&brackuiet = 0 });
        },'ift,D'],
        # i $s:schema/$step o T.nN/*:step
        # steps adopted from recent: n ...
        ['steps adopted',0.11,&acgtRYs,SC{
            $N = Ys&N;
            !N and throw "nosteps"
            each in N {
                $p = fio(s,[n.t,n.y.cv||1]);
                py&Schema_step and throw "multi schema step", n
                py&Schema_step = n;
            }
        },'ift,D'],
    ]};
    
    me.SChema = &acgtRtc{
        $SC = me&SCs,R;
        $s = me&SCA,SC,'Schema',{t:t},1;
        # steps adopted from recent: n ...
        sy&domed = &{
            $N = me&ydome;
            me&SCA,s,{N:N},2;
        };
        return s
    };
    
    #c KnowThat@304 process schematics
    =pod
    
    specifies generating new I
     pure javascript they need to start everything
     to get an A clearly built from scratch
     
    I:
     < bits of StyleHut,
     < most of NutMachine,
     < any new I
    #   s/eye/i/
    I.w:
     < I:NutIns/G&ting becoming:
       auto hoist R:Search@4  into /js/$Search:
        G&tingup to make Rs&_ting etc at #runtime
        without io
        needs jquery, isC and G.t for G&time/Cye/thime/c/intag
        G&ting proxies Rs&_ting
        Rs&_ting proxies G&t
     + io and me at #runtime
     + A:n J as me.J is
     + t that looks at me.$i, me.Ja.$w
    =cut
    me.Chaiingness = &acgtR{ return [
        ... me&Comsteingness ,
        ... me&Comalingness ,
        ['KnowThat','304',&acgtRs{
            $h = me&SChema,R,'KnowThat',{};
            
            # where from
            n Know 1  %bri:0.7,tings
            
            # all, knows what's changing
            n Compiling 3  %hue:70,supr:Comal
            
            # just what's changing
            n Seq 5  %hue:110,supr:Comste,Omplateau
            # for %Comste's:
            #  < half-moved things (journaley)
            #    should have some tests pointed at it
            #  < better place for hacks than Know/**?
            #    which will be little trees and codes...
            # currently won't be there to be suprised into
            #n This 67  %hue:140,tings,dropempty
            
            # where to!
            n That 7  %tings
            
            hy&domed()
        },'ift,D'],
    =pod
    hang out at the synthetic campfire
     - see whats there
    deriving hacks
     - of change eye->i
     - compositing ways
    by first adopting a That..G
     to lay into with regexes,
     so Comste can use them
    =cut
        ['WithThat','304',&acgtRs{
            $h = me&SChema,R,'WithThat',{};
            
            # where from
            n Know 1  %tings,gently,bri:0.7
            
            # osmosize interesting Thats into Hacks
            n With 4 tw %supr:Comack,Wither
            
            # have Hacks, their neT side
            n Hacks 5 tw %supr:Complace
            
            # where to
            n That 7  %tings,gently
            
            hy&domed()
        },'ift,D'],
        ['Wither','31',&acgtRs{
            n tw  s:â— %fs:22,medo:modeen
            me&rollbs,R,'thing';
            Rs&modeen = &acgtr{
                # captures the next click
                T.pickel = &acgtr{
                    Rs&thing = rc&s
                };
            };
            me&tsc,"Wither";
            me&nu,"SE",s
            
            # points to a That
            # wants a Know/* that doesn't exist yet
            #  but if it was it would rolltog ready>
            
            $t = Rs&thing;
            !t and return me&tsc,"selecto..."
            
            $f = ty&f;
            !f and return me&tsc,"!f-trac..."
            
            $W = fy&W;
            $L = Ws&Live;
            # random look in
            me&rolltog,R,'&',0 and me&zu,'Thing',L
            
        },'ift,D'],
        ['Comack','31',&acgtRs{
            me&tsc,"COmack";
        },'ift,D'],
    ]};
    #c Comste
    me.Comsteingness = &acgtR{ return [
        ['ball+Comste','31',&acgtRs{
            $l = sy&l;
            sy&f = ly&f;
            # if top, have + ignore src f
            #  see unifiers may have ground
            sy&top == s and sy&f = ly&inf
            else {
                # non-top, must use ouf if non-leaf
                sy&f = ly&leaf ? ly&inf : ly&ouf
            }
        },'ift,D'],
        
        ['ball+Comste','32',&acgtRs{
            T.Mw = 'Comste';
            $sa = Ry&sa; # last waigh
            $ha = Ry&ha; # wai-in aha()()
            $da = Ry&da; # differ last waigh <-> now waigh
            
            $f = sy&f;
            !f and return me&waits,'!f'
            # don't yet have the f for non-leaf nodes
            
            if (sa('redialy')) {
                # status should depend on:
                f && fs&game != 'get' and throw "undialed"
                ha('redialy')
            }
            else {
                # < give fy&G/W some time to have game=...
                #   ensuring it on the way back (Thing?)
                # alters the %ting but supposedly it's ours,
                #  and we will sleep til its ready again
                f and fs&game = 'get'
                return ha('redialy')
            }
            
            # only top %Comste compiles
            sy&top != s and return
            
            # o **!%redialy
            #  very in future
            $N = sy&N.map(s => sy&R).filter(&j{
                return !jy&sa('redialy')
            });
            N.length and return ha('waits:them-redialy')
            
    
            
            #c Comste-ing
            
            # check out n
            $cha = [];
            $Lives = [];
            each in sy&N {
                $j = ny&R;
                $f = ny&f;
                !f and return me&waits,n.t+"-!f"
                # Ws&Live stills
                $W = fy&W;
                $was = me&rollbs,j,'Live';
                Ws&Live != was and cha.push(cha)
                js&Live = Ws&Live;
                # < copy into This/$t/{origin,comp} meanwhile
                #   to externalise to perl to jsbabz it
                #   to apply hacks in waves to it, so differ
                #   to allow processing over many lives
                #    syncing Know/* to resume/complete
                
                # see how the things should mix before hacking?
                #   to reduce the load to:
                # hacking each W as per ...
                # draw attention to hacks on the inside
        
                # any fy&Gc&s.sc.* unknown may be instructions
                # fy&W may have access to:
                # < Search%Mix.W low level tv mixage
                #   should mix %ting=js|W
                #     Ws&I/$of/$C as $W/$of/$C
                #   would be where I needs bootstrapping
                #    from a dozen few-thousand line /js/
                #     to a few dozen thousand line /W/
                #      with some Babzing before it I's too
                #      so we have a bunch of ghost to show for it
                # they want those instructions applied tho
                #   backup system if not simple el=1
                # < bring on holding A.I = W:Isomewhere,
                #   should have all onward
                
                # < G%hacks...
                #   want to be named (for many users)
                #   and inheritable (for js:eye->i everywhere)
                $g = fy&G;
                $hs = me&ioty,g,['hack'];
                hs.length and me&nu,'hacks-'+g.t,hs;
            }
            $Lives = me&ioty,R,'Comste'
                .map(j => js&Live);
            Lives.filter(L=>!L).length and return ha('waits:them-Live')
            
            
            me&rollbs,R,'Ready';
            cha.length and delete Rs&Ready
            
            # this mix in the source
            $D = Rs&Live;
            # < don't need it to be there
            !D and return me&waits,"!live"

            $g = me&opeology,"%Ready",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"redo?"
                res&ope and delete Rs&Ready
            }
            
            if (!Rs&Ready) {
                $Ready = Rs&Ready = me&unifydin,D,Lives;
                !Ready and return me&waits,"unifydin.."
                # we can/should attach s&W from Wind
                $Wi = Readyy&Wind || {};
                each kv Wi {
                    fio(Ready,[k,1,{},{W:k,ha:v}]);
                }
                # the osc that knows about this C
                Readyy&s = s;
            }
            $Ready = Rs&Ready;
            
            $c = {};
            c.closish = Rc&brackuiet && !Rc&brackope;
            me&opeuni,g,Ready,Lives,c;
            
            if (gs&ope) {
                me&nu,'Comste',{Ready,Lives}
            }
            
            # back to Comal
            $l = sy&l;
            $r = ly&R;
            $la = ry&ha;
            la({Ready})
        },'ift,D'],
    ]};
    
    #c unifydin Swims Things
    # Swim N into fresh D
    #  D is not a dome but the old C
    me.unifydin = &acgtDN{
        # the W:HutKitchen
        $ID = Cye(D);
        IDy&tw = {};

        # unifiers may have ground
        $Dnz = me&ioty,D,['']
            .filter(dW => !dWc&W && !dWs&W);
        if (Dnz.length) {
            # would be updated if we way the W,
            #  rather than plumb it indifferently
            # < find mirrors in We, keep over dup
            #   related to updating only Stylating,
            #     without loading siblings HutKichten/*
            me&zu,"extra_ground",Dnz;
            return
        }
        
        # Swimming things lose a layer of separation
        each id N {
            # have We things
            #  cW puts for a W, are their compiled W:of
            #  sW point to what they unified
            $dWz = me&ioty,d,[''] .filter(dW => dWc&W);
            each i,dW dWz {
                $Wt = dW.t;
                $eyei = 0;
                Wt == 'eye' and Wt = eyei = 'i'
                $IW = IDy&tw[Wt] ||= Cye(dW);
                IW.t = Wt;
                IWy&tv ||= {};
                IWy&cv != dWy&cv and ~>8 cvstrange: ID.t, IW.t
                # the of things are tiny:
                IW.y.cv = 0.001;
                
                ac(ID,'z',IW);

                each i,dt dWs&z {
                    $ty = IWy&tv[dt.t] ||= {};
                    $b = ty[dty&cv];
                    b and ac(IW,'overs',b)
                    b and IWs&z.splice(IWs&z.indexOf(b),1)

                    $It = ty[dty&cv] = Cye(dt);
                    dts&z and me&nu,"of/t/*",dt; return
                    ac(IW,'z',It);

                    # the origin of everything is very important
                    $Wa = dts&Wavel;
                    $l = [d.t];
                    if (Wa) {
                        $Waypin = Wa.split('/');
                        $Waypost = Waypin.pop();
                        Waypin.push(... Waypost.split(','));
                        l.push(... Waypin);
                    }
                    
                    eyei and Its&js = 'i'
                    Its&Wavel = l.join('/');
                }
            }
        }
        
        # Wind: ghostymotion with %ting %Live
        each iW N {
            $P = Wy&P;
            !P and continue
            # is a %ting %Live
            $Wi = IDy&Wind ||= {};
            Wi[W.t] = Ps&dige;
        }
        
        # order, hide %overs -> y&overs
        each i,IW IDs&z {
            IWs&overs and IWy&overs = delete IWs&overs
            tvsortz(IWs&z);
        }
        return ID
    };
    #c opeuni
    # looks at a compiled W
    me.opeuni = &acgtgDNc{
        $R = Cy&R;
        c ||= {};
        $Dg = me&opeology,c.t||D.t,{walls:1};
        fio(g,Dg);
        c.closish && !Dgs&ope and return Dg
        
        Dgs&dis = 1;

        if (N) {
            # say sources
            # < make %Wind (for .5)
            $Km = me&opeKm,Dg,'src',{};
            each iW N {
                $P = Wy&P;
                if (P) {
                    # is a %ting %Live
                }
                else {
                    me&waits,"!P:"+W.t;
                    me&mtsc,Km,'hasnoP','!P','G'
                }

                $Kn = me&opeKn,Km,W.t,{label:{}};
                Kns&fs = 7;
            }
        }

        each i,IW Ds&z {
            $Km = me&opeKm,Dg,IW.t,{};
            Kms&fs = 12;
            Kms&hue = 160;
            Kms&bri = 1.4;
            Kms&dis = 1;
            #n $IW.t  $s:IW,R %ball,tightly,reneg,refpool

            tvsortz(IWs&z);

            each i,It IWs&z {
                $Kn = me&opeKn,Km,It.t,{label:{}};
                Kns&fs = 7;
                if (Kns&ope) {
                    Kns&fs = 11;
                    Kns&dis = 1;
                    $dis = me&zu,"It",It;
                    me&zuct,Kn,dis
                }
            }
            each in IWy&overs {
                # < tested
                $Kd = Kmy&overs ||= me&opeKm,Dg,'dup';
                $Kn = me&opeKn,Kd,n.t,{label:{}};
                fio(Kn,['from',2,{s:(ns&Wavel||"?")},{fs:7,deco:1}]);
                if (Kns&ope) {
                    Kns&fs = 11;
                    Kns&dis = 1;
                    $dis = me&zu,"It",It;
                    me&zuct,Kn,dis
                }
            }
        }
        return Dg
    };
    #c Wunifyst s-cached n-Lines
    me.Wunifyst = &acgtRsnk{
        $st = s.y [k];
        st && st.y [k+'ed'] != n and st = null
        if (!st) {
            st = s.y [k] =
                me&Copy,R,n,{ball:9,Lines:3,ov:8};
            st.y [k+'ed'] = n;
            me&fixstringn,st;
            
            # puts .5 of Wind, now we know our %ha (dige)
            $Wi = ny&Wind
            if (Wi) {
                $fi = G&Cye,[n.t,1];
                fis&ha = sts&dige;
                $sW = fio(fi,'W');
                each kv Wi {
                    fio(sW,[k,1,{},{W:k,ha:v}]);
                }
                $fis = sty&fiver = 
                    me&Copy,R,fi,{ball:9,Lines:3,ov:8};
                sty&fivestring = me&fixstringn,fis;
            }
        }
        return st
    };
    # no trailing \n from Lines?
    # < fix everywhere (entire Storage migration?)
    me.fixstringn = &acgt,st{
        !sts&string and throw "!string"
        sts&string.substr(-1) != "\n" and sts&string += "\n"
        sts&dige = dig(sts&string);
        return sts&string
    };
    #c Comal
    me.Comalingness = &acgtR{ return [
        #... me&Comalingness ,
        
        # the pile of codes moving towards That/**$t
        # before
        #  leaf nodes read Know/**$t, write That/**$t
        #  others (can only mix) from and to That/**$t
        ['ball+Comal','31',&acgtRs{
            $sa = Ry&sa; # last waigh
            $ha = Ry&ha; # wai-in aha()()
            $da = Ry&da; # differ last waigh <-> now waigh
            
            # < make these work a bit more varsier
            # Know/**$t
            $inf = me&supry,s,'yf','yl';
            inf and sy&inf = inf; ha({inf})
            
            # That/**$t, if found...
            # That, beyond steps of compilationisms from Comal
            $L = me.cbu(R,'SupplyChai').sc.Lastly;
            L = Ly&R;
            # get sy&fin = That..s
            #  s's mirror in the final A
            # gets sy&ouf to where it will be wanted
            me&supwyth,R,s,'fin',{theys:'l',top:L};
            
            
            $ouf = me&supry,s,'yf','yfin';
            ouf and sy&ouf = ouf; ha({ouf})
            # which one...
            #  later tries to include non-leaf src W 
            #   to check it doesn't have grounds...
            #   < may not exist back there,
            #      since Comal grew it
            # < should be able to have grounds,
            #   yet doing this all with J/ping action
            #   rather than mixing compileds would be better
            $leaf = ! me&ioty,sy&l,[''] .length;
            leaf and sy&leaf = 1;
            sy&f = leaf && inf || ouf || inf;
            
            
            ss&coung ||= 0;
            $le = ss&coung++;
        },'ift,D'],
        ['ball+Comal','32',&acgtRs{
            T.Mw = 'Comal';
            $sa = Ry&sa;
            $ha = Ry&ha;
            $da = Ry&da;
            !sa and return me&waits,'no-sa'
            
            # f ~ref is ok, Comal checks ~Live
            # < test:
            #  to redo work that may depend on it
            #  eg delete rows with dep:yf
            # < wrap ha() with row template
            #   to add such a dependency to each thence
            
            # L=That
            $L = me.cbu(R,'SupplyChai').sc.Lastly;
            L = Ly&R;
            # non-leaf && non-existent That..G
            !sy&leaf && !sy&ouf and ha('mot:no-ouf')
            # fs&changey at either That/Know
            $yf = ['inf','ouf'];
            each ik yf {
                $f = s.y [k];
                !f and continue
                fs&changey and ha('mot:cha,yf:'+k+',f',f)
            }
            # any mot-ivation
            if (Rs&wou && haks(Rs&wou)
                .filter(t=>t.includes('mot'))
                .length) {
                # excites ups
                $mot = {mot:'char'};
                
                # defers ups until Updated
                #  may be not That/$t-changey by their turn
                !ss&Updated and mot.fro = s
                
                # aplup helps ha to a different node
                me.aplup(s,&ha,{ ha(mot) });
            }
            
            # ^ goes around, now fro would be:
            $ready = !sy&leaf && sa('mot') && !sa('fro');
            
            $g = me&opeology,"Comal",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"putready?"
                res&ope and ready = 1
                
                $zu = me&opeKm,g,"zu"
                if (zus&ope) {
                    me&zu,"Comal",s
                }
                
            }
            !sy&leaf && sy&f != sy&ouf and me&mtsc,g,'!oufyet'
            
            #return;
            if (ready) {
                # %SupplyChai finds this, makes into %Comste
                ha('ready');
                Rs&suprise_c = {dl:1};
            }
            
            #c Comal-ing
            # %Comste returns Ready=[C9 with y&s]
            $Ready = sa('Ready',1);
            if (Ready) {
                # find it into That..G
                each in Ready {
                    # W:Something, s)%Comste:
                    $z = ny&s;
                    !isC(z) and throw "no ys"
                    # hop back to s)%Comal:
                    $lz = zy&l;
                    sy&top.y.N.indexOf(lz) < 0 and throw "Nofind zyl",z
                    lz != s and throw "lz nots"
                    
                    # make skinny tree to it, s)%Comal +
                    $stack = me.cby(lz,sy&top);
                    stack[0] != sy&top and throw "stack weird", stack
                    
                    # not suprise
                    $tr = L;
                    each im stack {
                        $r = me&input,tr,m.t;
                        $rs = rc&s;
                        rsy&R = r;
                        my&fin = rs;
                        rsy&l = m; # should persis/compete
                        rs&Thinting = 1;
                        ac(r,'trouble',"Comste-pushish");
                        tr = r;
                    }
                    rs.t != s.t and throw "not our name?",s,'->',r
                    
                    # send ourselves
                    ha('Wup',n);
                    #me&nu,"Readzy",r
                    #me&nu,"fropmtop",stack;
                }
                
                #c Comaloung - Wunifyst
                # meanwhile, generate the upload and await push:
                $Wup = sa('Wup',1);
                if (Wup) {
                Wup.length > 1 and me&tsc,"manyWups"
                each in Wup {
                    # having G/**s:
                    $ts = sy&fin;
                    $t = tsy&R;
                    $f = tsy&f;
                    
                    # %Comste %Ready -> encoding %Lines .1+5
                    $st = me&Wunifyst,R,s,n,'clonn';
                    
                    
                    #me&nu,"ts",ts;
                    #me&nu,"f",f;
                    #me&nu,"n",n;
                    #me&nu,"st",st;
                    
                    # < func for this next bit of code
                    #   it is the quintessential several
                    #   to spread out and help sleep
                    
                    # is all there or 404
                    $fok = f && (ts&tracting_goodin || ts&creatine);
                    # keeps diags, pushes get dekeened if !fok
                    if (sa('Redialy')) {
                        f && fs&game != 'get' and throw "undialed"
                        ha('Redialy')
                    }
                    else {
                        fok and fs&game = 'get'; ha('Redialy')
                        return
                    }
                    
                    !fok and return me&waits,'!fok'
                    # mark as being in That
                    fs&Wupular = 1
                    # now %ting for .1
                    
                    #Rs&tracting_goodin = 1;
                    #Rs&creatine;
                    
                    $W = fy&W;
                    $ge = fy&G;
                    $Q = Ws&Q;
                    $P = Qs&P;
                    $c = {};
                    !P and c.unexpected = 1;
                    !P and me&mtsc,g,'!noP!',0,'p'
                    
                    if (gs&ope) {
                        me&nu,"Comal%Ready",{st}
                    }
                    
                    if (P && Qc&el != 9) {
                        Ps&string == sts&string and me&mtsc,g,'==',0,'p';
                        else { me&diffya,R,'Wover',st,P,c; }
                        
                    }

                    # put it on disk
                    #me&nu,"Wing",fy&G;

                    #me&nu,"Gensup",me.cbub(R,'MindInto')

                    #$Ws = me&ioty,W,['ting'],[te] [0];

                    #$i = ss&z[0];
                    #me&nu,"Sandsz",ss&z[0];
                    # dige is for string
                    #sts&dige != dig(sts&toLines) and throw "Not";
                    
                    $go = me&rolltog,R,{maydo:'Push',once:1,tsc:'B'},0;
                    go ||= sa({Pushable:sts&dige});
                    if (go) {
                        if (!me&rollbs,R,'sent_string' ) {
                            # Q asks
                            Rs&sent_string = Qs&string = sts&string;
                            Ps&dige and Qs&parent = Ps&dige;
                            $five = sty&fivestring;
                            five and Qs&fivestring = five
                            Ws&_ting(Q);
                        }
                        if (Ps&string == sts&string) {
                            me&tsc,'pushed';
                            # it cancels the go
                            go = 0
                            # and the grypes
                            delete ges&grypes;
                            # and the changey
                            delete fs&changey;
                            ss&Updated = 1;
                            
                        }
                        else {
                            me&tsc,'pushing'
                        }
                    }
                    go and ha({Pushable:sts&dige})
                    
                    #c Comalor or when found == + Know cha
                    if (ss&Updated) {
                        if (s == sy&top) {
                            # < all deleted when the top is Updated
                            me&mtsc,g,'Alldone!',0,'p';
                            me&SCfcommit,R,s;
                        }
                        else {
                            $p = sy&up;
                            $pr = py&R;
                            $pa = pry&ha;
                            pa('mot:upd,supr',s);
                            ha('Updated')
                            
                            $re = me&opeKm,g,"Up?"
                            res&ope and fs&commiting = 1
                            
                            zu && zus&ope and me&nu,"p",pr
                            

                        }
                    }
                }
                }
            }
            
            
            
            
            
            ss&count ||= 0;
            $le = ss&count++;
        },'ift,D'],
        ['ball+Thinting','63',&acgtRs{
            sy&R = R;
            
        },'ift,D'],
    ] };
    
    # commit sy&N's f, making Cupload in %ting
    # < me&waits into wai as well,
    #  < modopting into brackdown
    #    as a thumbnail, over the specifics
    #    which could go on joined by ark:waits
    me.SCfcommit = &acgtRs{
        $fs = [];
        each in sy&N {
            ny&inf and fs.push(ny&inf)
            ny&ouf and fs.push(ny&ouf)
        }
        $waifs = [];
        each if fs {
            fs&commiting ||= 1
            fs&commiting <3 and waifs.push(f)
        }
        if (waifs.length) {
            if (fs.length > waifs.length)
                me&nu,'stillf-commiting',waifs
            return me&waits,"G-commits"
        }
        $c = {maydo:'MindSave',once:1,tsc:'B'};
        $go = me&rolltog,R,c,0;
        !go and return
        
        $mi = me.cbu(R,'SupplyChai');
        !mi and throw "No ^^%SupplyChai"
        $mg = me.cbu(R,'Gens');
        !mg and throw "No ^^%SupplyChai^^%Gens"
        
        each in sy&N {
            delete ns&Updated
        }
        # turn off %MindInto
        me&introqua,mi,{play:0};
        # push/diff
        me&introqua,mg,{boost:1};
        me&tsc,"leaving"
    };
    
    #c SC-suprise - cast (tree of) C into the next process
    # C-C tracting-ish by a.y[k] = b, b.y[c.theys] = a
    #  a soft suprise in reverse?
    # eg follow Comal's That's
    #  Comal being suprised from Know%tracting
    # < float down That pile until name found
    me.supwyth = &acgtRskc{
        $S = sy&up;
        $fin = S && S.y [k] || c.top;
        finy&R == fin and fin = finc&s;
        me&ioty,fin,[''],[s.t] .map(&l{
            # < persis/compete for
            s.y [k] = l;
            c.theys and l.y [c.theys] = s;
        });
    };
    # they already %supr=1 (if %eph)
    #  get ys&supr = $supr
    #   which becomes %$supr next time (good slow?)
    # was A:f@4-ish %Compiling** -> %Comal**, etc
    #  got very heavy on the etc.
    # lr - the Know/Stylehut
    # nr - the Compiling
    # linear Know/* -> Compiling/*%Comal -> That/*
    # and sub-SupplyChai:
    #   Compiling%eph/seq%eph/**%Comste,
    #    to do things until %Comals are satisfied
    #      enough to give that thing to That
    #   was:
    #     inject/sync Compiling%eph/$k/$t**
    #     $k was all|seq for Comal|Comste
    me.suprise = &acgt,lr,nr,c{
        c ||= {};
        
        # z-getter per r, for what they want to transmit
        $zget = c.zget || lrs&zget || lrs&tracting && tracin;
        zget ||= &Ry{ me&ioty,R,'ball' .map(y) };
        !zget and throw "no zget"
        !nr and throw "no next"
        
        supr = c.supr || nrs&supr;
        $C = lrs&C;
        !C and throw "suprise lr !Rs&C"
        !supr and return me&tsc,"!%supr-next:"+nr.t
        
        ex(c,lrs&suprise_c||{});
        
        $tops = [];
        $sup;
        sup = &lr,nr,depth{
            # lr now somewhere inside toplr (Know/**)
            # S = itself in previous step
            $S = lrc&s;
            $s = nrc&s;
            # should persist unless new
            me&persis,s,'y','supr',supr;
            me&persis,S,'y','n',s,{changeok:1}
            #  or not into a %supr (%eph-emeral layer)
            #   eg %tings may last several waves of %suprs
            $Sc = !nrs&supr && {changeok:1};
            me&persis,s,'y','l',S,Sc;
            me&persis,s,'y','R',nr;
            
            c.dl && c.dl <= depth and return
            
            # copy the z-move, inputting
            zget(lr,&r{
                rup(r,nr,depth+1);
            });
        };
        $rup;
        $first = 1;
        rup = &r,nr,depth{
            $rn = me&input,nr,r.t;
            
            # S = its parent in this step
            $S = nrc&s;
            $s = rnc&s;
            # top at Compiling/*
            if (first || sy&top == s) {
                first = 0;
                sy&top = s;
                tops.push(s);
            }
            else {
                sy&top = Sy&top;
                sy&up = S;
            }
            # collects them all
            ac(sy&top,'yN',s);

            sup(r,rn,depth);
        };
        rup(lr,nr,0);
        # check no vanishing atoms
        tops .map(&s{
            sy&N .map(&s{
                me&yfuture,sy&R
            })
        });
    };
    #c f-%ball/modulat
    # %ball suggested into/assumed from s)R%ball
    #  how processes create/sync their limbs
    #  the s storable, the R waking
    me.bal = &acgttsc{
        $R ||= Cy&R;
        $gaveC = isC(s);
        !gaveC and c = s; s = null
        c ||= {};
        typeof c == 'string' and c = G&peel,c
        c.R and R = c.R
        
        # r may exist
        $r = me&ioty,R,'ball',t [0];
        
        if (c.dropempty && r && !me&ioty,r,'ball' .length) {
            i Rc&s/-rc&s
            return
        }
        
        # create s
        if (!r && !c.dropempty &&
            (!c.maydo || me&rolltog,R,{maydo:t},0 )) {
            # rolling s if !r the next time, eg c.eph unattached
            s ||= me&rollbsc,R,'bal_tw_s/'+t;
        }
        
        if (s && !r) {
            delete c.dropempty;
            ex(c,{t:t,s:s,ball:1,tightly:1});
            r = me&Ret,R,c;
            if (Rs&ball && !c.eph) {
                me&input,R,rc&s;
                # < i $R/$r
                # < with ballio
            }
            rc&dupl = 5;
            me&zN,r;
        }
        else {
            ex(r.sc,c)
        }
        if (r && gaveC) {
            R.sc[t] = r;
        }
        
        if (r) {
            ac(R,'balz',r);
            # sort ss&z to order of me&likez
            $li = Rs&balz.indexOf(r);
            $ro = Rs&balz[li-1];
            ro and me&zaft,R,ro,r
        }
        return r
    };
    
    # Rs&z moves t after r
    #  if not already somewhere after it
    me.zaft = &acgtRor{
        $roi = Rs&z.indexOf(o);
        $ri = Rs&z.indexOf(r);
        if (roi > ri) {
            Rs&z.splice(ri,1);
            Rs&z.splice(roi,0,r);
            Rs&z[roi] != r and throw "yos"
        }
    }
    
    # r moves into modulat n
    me.zuct = &acgtnr{
        rs&zuctedto = n;
        # represents s
        delete nc&s;
        fio(n,r);
    };
    # n (modulat) lifted from some ground into C:t
    # < combine with zuck/mez/polify for all-regrouping?
    me.modopt = &acgtRmn{
        !n and throw "modopt!n"
        $could = [T.Mw,null,T.nN,Rs&M];
        each it could {
            $M = isar(t) ? t : me&Mw,R,t;
            $ni = M.indexOf(n);
            ni >= 0 and break
        }
        ni < 0 and throw "n not fground", could
        M.splice(ni,1);
        return fio(m,n.t,n);
    };
    # me&tsc into another modulat
    me.mtsc = &acgtmtsc{
        $R = Cy&R;
        $n = me&tsc,t,s,c;
        me&modopt,R,m,n;
        return n
    };
    # i $g/#$k/$d
    me.givi = &acgtgktd{
        isC(t) and d = t; t = d.t
        $hi = fio(g,k);
        $b = fio(hi,t,0);
        if (k == 'history') {
            # puts new top on history
            b and ac(d,'z',b);
        }
        return fio(hi,t,d);
    }
    #c modulata groupology/Km/Kn/label, sizo
    # the usual hierarchy:
    # top/groupr(r(gk))/groupology()/grouping(Km)/groupthing(Kn)acgttc
    # all openable
    # < each a -pi some other time
    
    # provide callback to deliver callbacks
    me.opewires = &acgtg{
        gy&can = &kyc{
            if (isst(k)) {
                k == 'm' and return me&opeKm,g,y,c
                else
                k == 'n' and return me&opeKn,g,y,c
                else
                k == 'nu' and return me&openu,g,y,c
                else 
                g.sc[k] and return y (g)
            }
            else {
                # < generate something
                me&tsc,"Elvis.."
            }
        };
    };
    # the doctor probe
    me.openu = &acgtgtsc{
        isob(t) and s = t; t = 'nu'
        $nu = me&nu,t,s;
        $gu = gy&can('m','Gear');
        me&zuct,gu,nu;
        nuy&Km = gu;
        return nu
    }
    # the general displayable
    me.opeolo = &acgttc{
        $R = Cy&R;
        c ||= {};
        
        # t can be implied from or takes over T.Mw
        isob(t) and c = t; t = null
        t == null and t = T.Mw || C.t;
        !T.Mw and T.Mw = t;
        
        c.walls ||= 1;
        $g = me&opeology,t,c;
        
        me&Mw,R,T.Mw .push(g);
        
        return g
    };
    

    # groupology, openable
    me.opeology = &acgttc{
        $R = Cy&R;
        c ||= {};
        
        $g = G&Cye,[t,2,{},'hue:30'];
        c.walls == 1 and c.walls = 'bd:2.2h5'
        me&applystylec,g,c,{};
        me&opelabel,g,c.label;
        me&opewires,g;
        return g;
    };
    # grouping (Km), openable
    me.opeKm = &acgtgtc{
        $R = Cy&R;
        c ||= {};

        $Km = fio(g,t,[t,1,{},'grouping,ma:0.3,fs:8']);
        Kmy&up = g;
        me&applystylec,Km,c,{walls:'bd:1.4,hu:3'};
        me&opelabel,Km,c.label;
        me&opewires,Km;
        Kmy&up = g;
        return Km
    };
    # groupthing (Kn)
    me.opeKn = &acgtgtc{
        $R = Cy&R;
        c ||= {};
        $Kn = fio(g,t,[t,1,{},'groupthing,ma:0.3,hue:-50']);
        Kny&up = g;
        me&applystylec,Kn,c;
        c.label and me&opelabel,Kn,c.label;
        me&opewires,Kn;
        Kny&up = g;
        return Kn
    };
    
    
    # applies tsc/walls as per c or d(efault)
    # < use for rolltog taking .tsc, 
    me.applystylec = &acgtqcd{
        d ||= {};
        c ||= {};
        ex(d,c);
        d.tsc and me&tsc,q,0,d.tsc
        d.walls and me&walls,q,d.walls
    };
    
    
    me.opelabel = &acgtgc{
        c == 1 and c = {}
        c ||= {};
        c.tsc ||= 'y'
        c.opeg ||= 1;
        return gy&label = me&vlabinto,g,c
    };
    # vertical label in g
    me.vlabinto = &acgtgc{
        $R = Cy&R;
        c ||= {};
        # qualify up g
        $name = me.cby(g) .map(n => n.t) .join("_");
        $q = {may:'label_'+name,s:c.s||g.t};
        c.tsc and q.tsc = delete c.tsc
        $ope = me&rolltog,R,q;
        q = me&modopt,R,g,q.n;
        qy&cv = 0.12;
        qs&ope = ope;
        if (c.opeg) {
            gs&ope = ope;
            if (ope) {
                $Km = me.cbub(g,'grouping');
                Km and delete Kms&fs
            }
        }
        # styles the vertical text, not the spacer it's in
        me&applystylec,qy&label||q,c;
        me&opewires,q;
        return q
    };
    
    
    # size of anything control
    # < link to iteration of V(iew)
    me.opesizup = &acgtgc{
        c ||= {};
        c.opeif1 = 1;
        return me&sizo,g,c;
    };
    me.sizo = &acgtgc{
        $R = Cy&R;
        c ||= {};
        c.opeif1 && c.len == 1 and gs&ope = 'is1'; return
        $s = fio(g,'size');
        ss&label = 1;
        c.len != null && c.len != 1 and sc&s = 'x'+c.len;
        return s
    };
    
    #c f-waiting for...
    # puts modulat talking of %waits
    me.waits = &acgttsc{
        !s and s = t; t = 'waits'
        # < this style could be all we need
        c ||= {};
        typeof c == 'number' and c = ""+c
        if (typeof c != 'object') {
            c.length == 1 and $tsc = c; c = {}
            else
            typeof c == 'string' and c = G&peel,c
        }
        c.tsc and $tsc = delete c.tsc;
        # c can be specifically about the wait
        # 1 key means $scgk:$waittype
        #  eg s&tracupload having .differ, needing .accept
        if (haks(c).length == 1) {
            $k = c.waits_sgk = haks(c)[0];
            c.waits_type = delete c[k];
        }
        $n = me&tsc,t,s,tsc;
        c.waits ||= 1;
        ex(n.sc,c);
        return n
    };
    
    # checks R's modulat talk for %waits
    # < named waves of
    me.beready = &acgtRk{
        $Mw = k || '';
        $N = me&Mwty,R,Mw;
        $Nx = {};

        # %acty:1 starts things, %acty:8 opens dialectic
        N = arou(N,'acty',Nx);

        # everything %waits is important
        # everything else is an error
        Nx.err = arou(N,'waits',Nx);
        delete Nx.err;

        each kv Nx {
            !v.length and delete Nx[k]
        }

        # is ready
        !(Nx.waits || Nx.err) and return 1
        # or not

        if (Nx.waits) {
            $situ = "waits("+Nx.waits.length+")";
            $ope = me&rolltog,R,{may:situ,acty:8,tsc:'y'};
        }

        if (ope || Nx.err) {
            me&zu,'Nx',Nx
            each in Nx.waits {
                me&zu,n
            }
        }
    }
    
    #c f-waitzo/solvent
    # of wait data, 
    #  similar to beready pooling modulat %wait
    
    # gh describes things we're waiting for
    # returns 1 if not waiting (no/empty gh)
    # < reverse that so: waitzo and return
    # < projecting the waits over there like grimp
    me.waitzo = &acgtRc{
        c ||= {beready:1};
        c = me&waidef,c,'k',{k:'waitz'};
        
        $gh = me&waicu,R,c;
        !gh and return 9
        
        # rendered modulata
        $g = me&brackdown,R,c,gh;
        me&walls,g,'b:2.2h3';
        
        gs&ope and me&nu,"Xwai",R.sc[c.k]
        
        c.solvent and me&waisolvent,R,c,gh;
        
        if (c.beready) {
            # any gh causes %waits, returns false
            gs&waits = 1;
            return me&beready,R,T.Mw
        }
        return 1;
    };
    
    # react to the state
    # dscif: {scgk:'tracting_good'},
    # arkfor: {r: {cb:&dr{
    me.waisolvent = &acgtRc,gh{
        gh ||= c.gh || me&waicu,R,c;
        !c.solvent and throw "!c.solvent"
        each i,sol c.solvent {
            $M = [];
            each tk sol.dscif {
                $N = gh.sc[t] && gh.sc[t][k]
                N and M.push(...N)
            }
            each ka sol.arkfor {
                each in M {
                    $v = n.c[k];
                    # eg a tracting_good sharing a row with an r
                    !v and continue
                    # < note in dy&brackdown
                    if (a.cb) {
                        a.cb(gh,v);
                    }
                    else {
                        throw "handle arkfor"
                    }
                }
            }
        }
    };
    
    #c brackdown/waiphil - summarises a pool of data
    # brackdown - explore the dimensions
    # io joins from a display perspective
    # visual interactive group by
    #  is probably an io-sized layer on io,
    #   all about wandering through !C,
    #    many ways in/out of everywhere,
    #    hierarchies that may be
    # < plug in some graph database's visuals
    #   http://projector.tensorflow.org/ words near words in space?
    
    # < more autothink, process knows the types
    #    without clicking into ope/opel
    #     which should divide tangles
    #   use this pile of types to course action
    #   clues for eg. how to get an r to have an scgk,
    #    or what variants of that scgk mean
    #    and whatever other types of things are involved
    #     esp hold/$r defeating changey/$r
    # < inform other k that they ultimately find an r,
    #    and use maths symbols for "complete subset of" etc,
    #     turn into r=twx4=%tracting_good
    #     tw being the way to separate the r
    # < X.ref(R) for mapping values to keyable uniqueness,
    #    refR being for yfuture updating the value persisted
    #    eg Ravelvis M + yfuture, non-string-name persistence
    #    (because RbitX already persisted it)
    # < venn diagrams of how many of this have that
    #   is an io.nz() modulata, making Km/Kn
    # < apart/together levelism of the types,
    #    wandering indexes, conflicts
    
    #c brackdown takes a look
    # < rename scgk %
    # < rename this which?
    # will be very useful for situating crammed meanings
    #  at the very wildest edge of things, where wheres where
    # < opesizup->sizo: func the Km/Kn Kn/w edges
    #   so they may show up to a few C.t,
    #    then expand
    # < fill with hooks, combine with KnowC?
    me.brackdown = &acgtRc,gh{
        $C = Rs&C;
        c = me&waidef,c,'k';
        if (gh && c.gh && gh != c.gh) {
            # < means subset of,
            #   is highlit or layout stuff adding
        }
        gh ||= me&waicu,R,c;
        
        $g = me&opeology,c.t,{label:{walls:'bg',tsc:'l'}};
        me&Mw,R,T.Mw .push(g);
        me&walls,g,'b:2.2h6';
        
        if (!gh) {
            me&mtsc,g,'empty',0,'6';
            return g
        }
        
        gy&waigh = gh;
        ghy&brackdown = g;
        
        $allope = !Rc&brackuiet;
        if (gs&ope) {
            Rc&brackon = 1;
            $Km = me&opeKm,g,"ope";
            me&opelabel,Km;
            Kms&bg = 000;
            if (Kms&ope) {
                me&nu,'waiN',ghy&N;
                me&nu,"waigh",gh;
            }
        }
        Rc&brackon and allope = 1
        
        $nks = ['c','sc'];
        
        if (!allope) {
            # < only changes pop up, fade out
            $ar = {};
            nks.map(nk => ex(ar,{nk:gh[nk]}));
            $op = me&opesizup,g,{len:hak(ar)};
            !(op && ops&ope) and return g
        }
            
        # < not C rebellion
        each i,nk nks {
            each kV gh[nk] {
                # hide fact of paths
                k == 'path' and continue
                # and the 1 in $k:1
                k == 'isness' and continue
                # size, may lead on
                $Km = me&opeKm,g,k;
                me&opesizup,Km,{len:hak(V)};
                
                if (Kms&ope) {
                    fio(Km,['ope',1,{s:":"},'hs:888']);
                    each tn V {
                        $rv = null;
                        if (nk == 'c') {
                            # avoiding ref as key
                            $rv = ghy&refs[t];
                            !rv and throw "invalid Kn refs: "+t
                        }
                        $tee = isC(rv) ? rv.t : t;
                        $Kn = me&opeKn,Km,tee,{label:{tsc:'y'}};
                        
                        $someC = 0;
                        each iw n {
                            # a wai row, eg mot:cha,
                            #  each may have other k
                            # where w.c is like a row:
                            $v = w.c[k];
                            isC(v) and someC++;
                            if (nk == 'c') {
                                rv != v and throw "Kn t(refs) not as wai.c."+k
                            }
                            else {
                                v != t and throw "Kn t not as wai.c."+k, v, t
                            }
                            i > 5 and break
                        }
                        $lab = Kny&label;
                        Knc&sortcv = 1;
                        someC &&
                            fio(Kn,['sym',112,{s:'C'},
                            'label,fs:13,lh:0.8,hs:757']);
                        
                        me&sizo,Kn,{len:hak(n)};
                        
                        
                        Kns&ma = 0.2;
                        if (Kns&ope) {
                            # < light up other k this has
                            each iw n {
                                $na = [g.t,k,t,i].join("'");
                                $wa = me&opeKn,Kn,na;
                                way&cv = 0.2;
                                # concentrate on each wai.c (one row)
                                $s = was&ope ? w : w.c;
                                !was&ope and na += '.c'
                                # has a sprawl limit
                                $nu = me&nu,na,s;
                                # usu. by R Ringing
                                me&zN,nu;
                                me&zuct,wa,nu;
                                was&dis = 1;
                                # see me.endome: if n ...R... that is:
                                #nuc&Rzucto = wa;
                            }
                        }
                    }
                }
            }
        }
        
        return g
    };
    
    #c waigh query
    
    # waier - around waighre, can hist
    #  vary gh:gh to rewaigh
    me.waier = &acgtRc{
        c = me&waidef,c,'';
        
        # from last time
        c.b and $l = me&ollbs,R,c.k+c.gh
        else {
            # or this time
            $l = me&waicu,R,c;
        }
        
        $la = l && me&waighre,l;
        return la
    };
    
    #   $la = waighre(gh)
    #   M[wai+] = la('t:k')
    #      ^ from gh.sc.$t.$k.*:i.*:wai
    #    ie the index t was bitted k by all these wai
    # may return:
    #   M[wai.c.$o] = la('t:k','co')
    #    returns that one column
    #      couldn't include rows without that column
    #   null if !M.length
    
    # < merge gh.c/sc, know here to ..., take ref as input
    # < producing another waigh, of matched
    #  < other sql happenings
    me.waighre = &acgt,gh{
        ghy&waigh != gh and throw "gh !y&waigh"
        $la = &ho{
            $whe = isst(h) ? G&peel,h : h;
            $ok = 1;
            $M = [];
            each tv whe {
                # < nonfirst t must join the Ms
                #   or search within them,
                #    if where's wai/gh indifferent
                $S = gh.sc[t] || gh.c[t] || {};
                each kN S {
                    v != 1 && k != v and continue
                    M.push(...N);
                }
            }
            if (o) {
                o == 1 and o = haks(whe)[0]
                $N = M;
                M = [];
                each i,w N {
                    $v = w.c[o];
                    v == null and continue
                    M.push(v);
                }
            }
            M.length and return M
        };
        return la
    };

    
    #c waigh access, grouping
    
    # interpretation of the c
    # usual names of the X and the gh
    me.waidef = &acgtcko{
        c ||= {};
        if (isst(c)) {
            c == '' and c = G&peel,c
            else {
                $v = c;
                c = {};
                c[k] = v
            }
        }
        (o) and ex(c,ex(o,c))
        c.k ||= 'wai';
        c.gh ||= 'gh';
        # for display
        c.t ||= c.k;
        return c
    };
    
    # %wou -> %wough, reusing %wough
    me.waicu = &acgtRc{
        c = me&waidef,c,'k',{k:'wou'};
        
        $gh = R.sc[c.k+c.gh];
        gh and return gh
        $X = R.sc[c.k];
        !X and return
        
        $N = me&Xwai,X;
        # group by any
        $gh = me&waigh,N,c;
        # which makes it more readable
        R.sc[c.k+c.gh] = gh;
        
        return gh
    }
    
    # wai N[d] -> gh
    #  ds&$ark.$key = N[d] with such
    # how io wants to compress tons of rows
    # but for wai, building k/v=[d+]
    # c usu waicu's, accessor for gh
    me.waigh = &acgtNc{
        c = me&waidef,c,'k';
        
        $gh = G&Cye,[c.t,1];
        ghy&waigh = gh;
        ghy&N = N;
        ghy&refs = [];
        each in N {
            each kv n.c {
                $S = gh.sc ||= {};
                # v sometimes object, d.c groups refs
                if (isob(v)) {
                    $vi = ghy&refs.indexOf(v);
                    vi < 0 and vi = ghy&refs.push(v)-1
                    v = vi;
                    S = gh.c ||= {};
                }
                S[k] ||= {};
                $l = S[k][v] ||= [];
                l.push(n);
            }
        }
        return gh
    };
    
    #c N = Xwai(X = aha(...))
    
    # wai each type of path at X.*
    # eg.
    #   ah(R,'waitz','tw_scgk_r',r.t,'tracting_good',r);
    me.Xwai = &acgtXc{
        $N = [];
        each path,v X {
            N.push(... me&wai,{v:v,k:path,name:'path',path:path} );
        }
        return N
    }
    
    # setter of {names:keys} into X.names = k{e{y=s
    # eg.
    #   aha(R,'waitz')({tw:r.t,scgk:'tracting_good',r:r})
    #
    # < get between R better?
    #   maybe do one big pile at the top,
    #    each r able to enter as such,
    #     perhaps using a template for "cares of r"
    #     debugality (of elvising would do) wants to know
    #     where the data came from
    #      while there is expense to spare
    #      brackdown sends hooks onto X.
    #   then waigh for/into each r
    #     triangling the hopes and dreams of the community
    window.aha = &Rt{
        return &s{
            $args = [... arguments].slice(1);
            isst(s) and s = G&peel,s
            $path = [];
            $bits = [];
            each kv s {
                # (tw:C.t)
                path.push(k);
                # (co:1, $co)
                v == '1' && args.length and v = args.shift();
                bits.push(v);
            }
            bits = [ ... bits, ... args ];
            # refs mean the end
            # < doubling path so X.z = nodes here, X.$path = onward 
            # strings at the end must turn into keys
            # < counters
            isst(bits.slice(-1)[0]) and bits.push(1); path.push('isness');
            
            ah(R,t,path.join("_"), ... bits, ...args)
        };
    };
    

    
    #c wai **{ -> N[d+]
    # deep hash with known paths/rows
    # < just wander in until C
    me.wai = &acgtd{
        $N = [];
        $wai;
        wai = &d,c{
            if (d.d == null) {
                d.d = 0;
                d.z = [];
                d.wholepath = d.path;
                d.path = d.path.split('_');
            }
            else {
                $up = d;
                d = ex({},d);
                c and ex(d,c);
                d.up = up;
                d.z = [];
                up.z.push(d);
                d.d++;
            }
            d > 10 and throw "manywai"
            
            $nextname = d.path[d.d];
            $islast = !d.path[d.d+1];
            if (!islast) {
                $eachable = isha(d.v) || isar(d.v);
                !eachable and throw "index!hash"
                each kv d.v {
                    $c = {k:k,v:v,name:nextname};
                    wai(d,c);
                }
                return
            }
            
            # d.v is beyond the path, as s
            # stack =~ io's row but for d not d.v
            #  since the meaning of here is usually:
            #   the key/params used to get through (d.k)
            #   then the final d.v,
            #     without being another stackbit
            #   < anything could be a value on the way down the path
            #     and be related to the parameters used to get the value
            d.stack = me.cby(d,null,&n{ return n.up });
            # the path as names (arks in io) with values
            d.c = {};
            each in d.stack {
                # the key used at this stackbit
                d.c[n.name] = n.k;
            }
            # last one aka s (ya out of io)
            #  from the same stackbit that found it via d.k
            d.c[nextname] = d.v;
            N.push(d)
        };
        wai(d);
        return N
    };
    
    #c trac Know/...%ball <-> Wild...%ting
    
    # %tracting MindInto/Know/**%ball waking up
    # endless loop of trac & ok <-> dependencies
    #  pulling into a mixage
    #  ghosts knowing wormholes
    # < include the flook/finput methods?
    
    # up/downable essential identity
    # W version
    Be.C.W = {
        scgk: 'dige',
    };
    # how to include it
    Be.C.inc = {
        scgk: 'el',
    };
    # %ting config
    Be.C.ting = {
        scgk: 'ting,directory,species',
        # dont need to %ting=W at the top?
        scdefault: {ting:'W'},
        # %tings nest to imply structure,
        #  these sc inherit from above
        # < cause Ravelvis to recreate if changed
        #   eg %ting must start fresh to add %directory
        scinherit: 1,
        scfor: {ting:{W:{
            # < plug this in to Cloadsc,
            #   < %ting using Cloadsc on its own:
            #      g=R,wp=Ry&up,w=R
            #    < deriving the display
            scdefault: {species:1},
            # look mode (ov<=4) implies:
            sclook: {species:5},
            # then the main %species we need to fully awake:
            scget: {species:1},
        }}},
        # wants 1 over the 4
        #  for the details under the main thing
        #  or does ForThe's %ting index/tooling abstract that?
        #   supposing you ask for Thing.1
        #   or you ask for Thing's %H (%ha/%dige),
        #     Thing.4 could have the answer,
        #      and have a %Ghostway to keep it up to date
        #     ThingsInHere.4 also, a big map
        #      which Lis must update, put forks in? or:
        #     Dev.4 + Dev/$Thing, a searchpath
        #      for who rides the chaos as thing grows
        #       a language weld happening
        #       shows where traits arose
    };
    me&BeCload;
    

    # trac happens via
    # < look more like RbitXing
    #    which wants to have posts of different height...
    # < or connect each %ting on the path
    #   up to a certain distance...
    #    should T.allow about going further than ...
    #   the things up the embryo...
    #   branches of %tings could be skipped?
    #    as far as the insides gravity is independent
    #      may stick around because you saw it once,
    #       culture style,
    #      or be mechanical exactitude eg I,
    #       things vanishing noted but immediately effective
    #     memory compresses, making usual shapes
    
    #c trac a Know/...%ball for MindInto
    
    # < editing the %ball's s.t breaks/vanishes
    #   click %ball reveals (lvhashave?)
    #    same t different %tag?
    #    this'd be a good place to start whaT'ing code:
    #     Xpath the modulat, look for its R:Display,
    #     playing back the scenario of the bug
    #     figure where they think to, turn on lvhashave fullness
    #   while:
    
    # Troom to be the top %tracting
    # local %tings hangout
    me.thespot = &acgtRt{
        $l = [t,'the'];
        $s
        each it l {
            $spot = t+'spot';
            s = me.cbu(R,spot);
            s and return s
        }
        me&waits,'no'+spot,'!t','B'
    };
    
    me.tracto = &acgtRktS{
        # through the spot
        $tracting = 'trac'+t;
        S and S.sc[t+'spot'] = 1
        S ||= me&thespot,R,t;
        !S and throw "nospot"
        $f = S.sc[tracting];
        f and return me&waits,"alreadytrac"+t,"oc:"+f.t+'.G='+f.y.G.t
        
        # we are outside the R:Know but can sc it
        $C = Rs&C;
        me&walla,'ba:2h3';
        # s%trac=ting)%tracting=1
        $s = Rc&s;
        ss&trac = t;
        
        
        # the organiser persists
        $abstracting = 'abs'+tracting;
        $F = me&rollbsc,R,abstracting;
        Fc&tracting = tracting;
        # who art coordinating
        Fy&G = R;
        Fy&W = S;
        # in the S=ForThe%ting is G=ForThe%MindInto
        #  ignore any %ting in there (%Gens)
        $insideW = me.cby(R,S)[1];
        insideW and Fc&traciggy = [insideW]
        Fy&top = F;
        Fc&Gtype = k;
        Fc&Wtype = t;
        R.sc[abstracting] = F;
        
        # so %tings notice upward %tracting
        S.sc[tracting] = F;
        # and so this %ball realises its flook etc.
        R.sc[tracting] = F;
        
        # waking up W or G about %tracting
        Fc&indive = &Rk{
            $f = R.sc[tracting];
            !f and throw "indive!tracting"
            me&ioty,R,'%'+k .map(&n{
                ns&rowish = 2;
                n.sc[tracting] = f;
            });
        };
    };
    
    #c tracarri for the %ting
    
    # W %ting@6 finds ^^%tracting
    #  copies it to its own %tracting
    # long distance inheritsc
    me.tracarri = &acgtRt{
        $S = me&thespot,R,t;
        !S and return
        # climb up to the spot until %tracting
        $tracting = 'trac'+t;
        $S = me.cbub(Ry&up,tracting,Sy&up);
        !S and return
        T.Mw = 'trac';
        $t = S.sc[tracting];
        $F = ty&top;
        each in Fc&traciggy {
            me.cbub(R,n) and return
        }
        
        if (ty&W != S) {
            if (t == Sy&up.sc[tracting]) {
                ~tracarri ahead: S.t
                T.wide = 'tracarri ahead of ^^tracmode';
                return;
            }
            throw "cbub^^%tracting!=fyW", S, t
        }
        
        # t = F at the top, then the previous f
        R.sc[tracting] = t;
    };
    
    
    #c tracintro - A:f for either
    # %trac* - W|G grow f and connect themselves
    
    # %tracting@6 either become, F -> f
    
    #  f starts for the parent or the entire trac-ing
    # and either can introduce the other,
    #  eg W reduces to G, G opens a W
    # we end up with a fy&ov for booting that connection
    #   which is in the domain of the particular G or W system,
    #   eg %ting:W,species:4 while checking out %MindInto/Know
    
    me.tracmode = &acgtRtc{
        $f = me&tracintro,R,t,c;
        
        # not chattery
        !me&beready,R,'trac' and return
        # having f, returned, means ready
        !f and return
        # waits for us to 2->3 it
        if (fc&ov == 0.2) {
            # both here + not chattery
            $readygk = 'trac'+t+'_ready';
            R.sc[readygk] = 1;
            $r = fy&G == R ? fy&W : fy&G;
            !r.sc[readygk] and return
            fc&ov = 0.3;
            # must come back so other lives ov=3 first
            return
        }
        # tracupload constantly, not immediately: waits
        
        return f
    };
    # ^ is a layer on v so we can return whenever
    me.tracintro = &acgtRtc{
        $tracting = 'trac'+t;
        $isting = R.sc[t];
        $k = isting ? 'W' : 'G';
        # t = previous f
        $t = R.sc[tracting];
        !t and return
        T.Mw = 'trac';
        # %tings gathering around somewhere
        # while persisting %tracting=f over (under) t
        $F = me&rollbsy,R,tracting;
        $unity = ty&W == R || ty&G == R;
        if (unity) {
            # tops stay f, creation on such type
            #  eg ForThe%ting or Know%ball
            # unity means "the top" for now
            $f = t;
            fc&ov = 0.3;
            F && t != F and throw "top changed f"
            t != ty&top and throw "unity !top"
        }
        else {
        if (t != F) {
            #~>3 rolling: k, R.t
            # double check via f tv
            $f = fio(t,R.t);
            # since 
            f != F && fy&up == F and me&tsc,'Fwasup:'+F.t;
            if (f != F) {
                Fy&up != t and me&tsc,"fupcha";
                # f may recreate to reset state
                if (F.t == f.t) {
                    me&tsc,'f-changed','*f'
                }
                else {
                    # < F = new fy&up
                    #   f moves in at low ov, aka:
                    #   sync elvising to new context
                    #   see mez&rename
                    me&tsc,'Freplace:'+F.t+'->'+f.t
                }
                F = t
            }
        }
        if (t == F) {
            #~>3 growing: k, R.t
            # grows f from spread F
            $f = fio(t,R.t);
            fy&up = F;
            fy&top = Fy&top;
        }
        }
        # the shared object, about each climbing
        R.sc[tracting] = f;
        
        #c A:f@0 connect either
        
        # keep Rs on f
        ['W','W_exp','G','G_exp'].map(&k{
            $r = f.y [k];
            !r and return
            try {
                r = f.y [k] = me&yfuture,r,R;
            }
            catch (er) {
                er.message.match(/^yfutured .+ not in RcN$/) and return
                throw er
            }
        });
        f.y [k] && f.y [k] != R and me&waits,"already-fy"+k; return
        f.y [k] = R;
        
        $ok = !isting ? 'W' : 'G';
        $F = fy&top;
        $type = F.c[k+'type'];
        $otype = F.c[ok+'type'];
        if (!unity) {
            t != fy&up and throw "t !fyup"
            tc&ov < 0.3 and me&waits,"fyupcov"; return
            # the previous thing on either side
            $op = fy&up.y [ok];
            !op and me&waits,"fyup!"+ok; return
            $p = fy&up.y [k];
            !p and me&waits,"fyup!"+k; return
            # op must be the type we expect,
            #  to look/input more of itselves
            
            #  the tops are sometimes op but never have op
            #$istop = F.y [ok] == op;
            !op.sc[otype] and throw "need "+otype
        }
        
        # f state
        #  usually a step can be made by either W/G
        fc&ov ||= 0;
        
        $yo = f.y [ok];
        # reset state per fy&$ok disappearance
        # < not inside %sleeping
        if (yo && Rc&N.indexOf(yo) < 0) {
            ~>9 disco: k,'->',ok, f.t
            me&waits,'disco:'+ok,0,6;
            # < mez&delete should do the delete-all
            #    el=2 input implies delete-all,
            #    which Ghostway/ing needs
            #   it would Rsync if R or s (finding refR) %ball
            i fy&up/-$f
            return
        }
        # or as usual,
        # W tends to wake first, !fy&G means initialise
        !f.y [ok] and fc&ov = was = 0
        
        # rync when Look/Create finds an r
        $lr;
        $rync = &r,how{
            !r and return
            r == lr and return
            lr = r;
            # eg W can find/create the fyG from fyupyG/f.t
            # which should become fy&[ok]
            $exp = f.y [ok+"_exp"];
            $got = f.y [ok];
            if (got) {
                #~>4 otherready: how, k, '->', ok, f.t
                if (exp) {
                    exp == got and delete f.y [ok+"_exp"]
                    else {
                        throw "not predicted "+ok
                    }
                }
            }
            
            # probably already r%tracting=f spread from upyG
            r.sc[tracting] ||= f;
            $dif = [f,fy&up].indexOf(r.sc[tracting]) < 0;
            dif && how == 'Look' and return 'dif'
            dif and throw "difftracting"
            
            # and is soon to be fy&[ok], where it should stay:
            exp && exp != r and throw "change exp "+ok
            got and got != r and me&waits,"r~got"; return
            #throw "change got "+ok
            !got and f.y [ok+"_exp"] = r
            
            # may be already
            # go to being entered/having been entered
            fc&ov < 0.1 and fc&ov = 0.1
        }
        $tych = &{
            if (ok == 'G') {
                otype != 'ball' and throw "enterG !ball"
            }
            else {
                otype != 'ting' and throw "enterW !ting"
            }
        };
        
        #c A:f@1 look/input for the other
        # < ongoingly also
        if (fc&ov <= 0.2 && !unity) {
            tych();
            # child find
            $flook = ops&flook;
            flook ||= ops&ball && &f,r,ok{
                $N = me&fabioty,op,[f.t];
                N[0] and return N[0]
            };
            !flook and return me&waits,"!flook" && me&zu,"!flook",op
            $r = flook(f,r,ok);
        }
        $dif = rync(r,'Look');
        dif and delete R.sc[tracting]; return me&waits,"^-difftracting-v"
        
        # Click (or so) to other
        if (fc&ov == 0) {
            $ope = fy&up == fy&top
                # from ball+tracting
                || Rs&openey
                || me&rolltog,R,{may:'^trac',acty:1};
            ope and fc&ov = 0.1
        }
        # Creates the other (either)
        #  even if we already see it
        #    must be repeatable (inputs != creates)
        #   to make sure everything happens that can...
        #   so we know all the outbound connections
        # < only want genesised if we really had to create them
        if (fc&ov == 0.1) {
            $direction = (ok == 'G' ? '<-' : '->');
            #~>6 Enter: ok, op.t, direction, k, f.t
            tych();
            fs&game = 'look';
            # child input
            $finput = ops&finput;
            finput ||= ops&ball && &f,r,ok{
                # returns the %ball without any Ringing
                #  which might be lies if ...
                return me&input,op,f.t;
            };
            !finput and throw "no finput"
            
            $r = finput(f,r,ok);
            
            # having from Looking or the input method,
            !r and me&waits,'connecting:'+ok+'%'+otype,'...'
            else {
                fc&ov = 0.2;
            }
            # if we didn't already see it
            !lr and fy&genesised = k;
        }
        #
        rync(r,'Create');
        #c A:f@2 the idealised lifecycled potentials
        
        # check either y$ok and its type
        if (fc&ov >= 0.2) {
            # should be ready
            if (!f.y [ok]) {
                # wait for the other side to have a mind,
                # then put heads together
                fc&ov = 0.2;
                return
            }
            !f.y [k] .sc[type] and throw "f@2 !y"+k+"%"+type
            !f.y [ok] .sc[otype] and throw "f@2 !y"+ok+"%"+otype
        }
        
        # unity will not have p/op around here (skips to 3)
        
        # generalised notions of trac
        if (fc&ov > 0) {
            $con = me&rolltog,R,{may:'trac',tsc:'l',acty:8};
            if (con) {
                Rs&traccon = 1;
                $ab = T.Mw;
                T.Mw = 'trac-control';
                # clicks open to reveal controls
                me&zu,"control-f",f;
                me&rolltog,R,{may:'re2',tsc:'y',once:1} and fc&ov = 0.1
                
                T.Mw = ab;
            }
        }
        
        # each thing not chattery to 0.3
        if (fc&ov == 0.2) {
            # on startup
            #~>2 En2: k, '->', ok, f.t
            # check config
            #   was sent from here with their finput()
            me&tracupload,R,f,k,ok,type,otype;
            # < ongoingly also
            return f
        }
        
        # is off
        fc&ov < 0.3 and return
        
        # ongoing spread to either/* now
        # < in wai, talking of z that could be
        #   such that we can flick it on,
        #     as another wanting a tw,
        #   or Comal looking for trees down to cha,
        #     which could trust the toplevels to be up to date
        #       or This would know about partially integrated pilia
        #     also could trust patching the same looking items
        #       so we only have to load NutMachine + NutC, not others
        # < the With is going to have complex name resolving:
        #   {und:NutMachine} meaning all under NutMachine
        #   which'll want figuring out 
        if (k == 'G') {
            $ft = fy&top;
            $ftG = fty&G;
            $gently = ftGs&gently;
            $go = !gently || ft == f;
            go ||= me&rolltog,R,{may:'in>',tsc:'y'};
            go and Fc&indive(R,type)
        }
        
        # is on
        return f
    };
    #c tracupload info about W to G
    # expression inherits from the last W
    #  eg has only to say the difference
    #   from the last %ting configuration
    # tends to learn what's out there
    # < complain via low-level changzo
    me.tracupload = &acgtRf,k,ok,type,otype{
        # can do it from either end
        #  as if one is prosthetically Awake
        k == 'W' and return
        # at first:
        #  0 = W should give bits to G
        #  1 = W should same bits as G
        #   fatal: out-bitten by another
        #   probably inheriting from ry&up
        # then
        #  asks to give bits
        $load = {f:f};
        # the bits + remarks that matter
        $lasc = fs&tracupload;
        # initial guzzle
        !lasc and load.forming = 1
        # 
        load.forming && fy&genesised == 'G' and load.conform = 1
        # make the change
        # < elvis hoppering acceptance
        load.auto = load.forming || lasc.accepted;
        
        $F = fy&top;
        $ting = Fc&Wtype;
        $tracting = 'trac'+ting;
        load.type = ting;
        
        $g = fy&G;
        $w = fy&W;
        g != R and throw "cup !G"
        !g.sc[type] || !w.sc[otype] and throw "G/W type"
        
        # Thing = whole needs make Thing amongst Stuff about it
        #   Stuff our G/W system (typed %ball/%trac) isn't after
        #  ie ghost is Thinging to really know
        #    embedded in Stuff to know
        #   the Cing of it may not be all Thinging
        #    digitised known bits in a sea of analogue
        #     is how it sees itself and its other
        if (f != fy&top) {
            $p = fy&up;
            !p and throw "no up"
            $gp = gy&up;
            $wp = wy&up;
            # < see variation ^ v # many ghostbits per Thing
            $gp = fy&up.y.G;
            $wp = fy&up.y.W;
            # < see variation ^ v # many tings per Thing etc
            # < g not bound by F/**?
            $gp = me.cbub(gy&up,tracting,F);
            $wp = me.cbub(wy&up,tracting,F);
            !gp.sc[type] || !wp.sc[otype] and throw "cup G/W type"
            
            gp == wp and ~>8 converge: k, '->', ok, p.t+'/'+f.t
            gp == wp and return
        }
        
        # checks it has the non-.t details right
        #   for writing on the ghost
        # %ting inherits them, has explicit ws&$k
        # %ball implies them being inherited
        me&Cloadsc,load,g,wp,w;
        fs&tracupload = load;
    };
    #c Cloadsc for explicit/implicit expression realising
    #  as per wp upward, the last spready instructo
    #  of C.sc.* in a Be.C.$group
    # generating Alets to find completion
    #  g - description/upstream, must have a:
    #   gc&s - whose .sc differs:
    #  w.sc - reality .sc, possibly lies or news
    #  gw - .sc inherits to w.sc
    # scfor plays games after a given k:v
    # < tighten %ting args, entirely by Cloadsc
    # < generalise from sc
    # < show yup%ting <-> %ting difference usually
    #   apart from the .t, isn't in the subtle
    # < worth redoing somewhere... KnowC one-many
    
    me.Cloadsc = &acgtcg,wp,w{
        !c and throw "give c"
        $load = c;
        $f = load.f; # optional
        $s = g && gc&s;
        # bits to give G: nulls for things it needn't
        load.sc ||= {};
        # bits to give W: everything
        load.c ||= {};
        # of this type's group
        # < Wtype:* brings everything,
        #   to where osc watches osc
        $Kc = Be.C[load.type];
        $games = [];
        
        each i,k Kc.scgk {
            # on %ting%$k
            $got = w && w.sc[k];
            # which is inheriting ^^%tracting
            # or not, if many tings per Thing,
            #  needing more explicit bits in recipe
            #  but something weirder might be afoot
            $exp = wp && wp.sc[k];
            # or not if it doesn't do that
            !Kc.scinherit and exp = null
            # weaker exp than inherit
            if (exp == null) {
                $def = Kc.scdefault && Kc.scdefault[k];
                def != null and exp = def
            }
            # f can decide attr, or have them suited to:
            # ephemeral modes of a point in a game
            #  eg look intensely, look casually
            each i,kc games {
                !f and break
                $game = kc['sc'+fs&game];
                if (game && game[k]) {
                    $imp = game[k]
                }
            }
            
            $was = s && s.sc[k];
            # W says everything
            $v = load.c[k] = imp || got || was || exp;
            
            # %ting=W leads to more knowing
            $kc = Kc.scfor && Kc.scfor[k] && Kc.scfor[k][v];
            kc and games.push(kc);
            
            $value = got;
            # G implies what is implied
            if (exp != null && got == exp) {
                # not noted
                !was and value = null
                # or was explicitly something else
                elsif (was != got) {
                    debugger
                    throw k+' implied was !got'
                }
                else {
                    ~>7 redundant: g.t, '%'+load.type
                    value = null;
                }
            }
            # imp acts like exp
            imp && imp == value && imp == got && !was and value = null
            load.sc[k] = value
        }
        
        !s || load.noknow and return load
        
        me&Cloadloadsc,load,g,w;
        
        return load
    };
    #c Cloadloadsc - loads the load
    # {part of,with c=returned from} Cloadsc
    me.Cloadloadsc = &acgtcgw{
        $load = c;
        $s = g && gc&s;
        
        $differs = [];
            each kv load.sc {
            v == null and s.sc[k] != null and differs.push(k)
            else
            v != s.sc[k] and differs.push(k)
        }
        $lies = [];
        each ik differs {
            load.liesok and continue
            load.sc[k] == null and continue
            # we said something, it was something else
            s.sc[k] != null and lies.push(k);
        }
        
        # want extra carevision
        lies.length and load.auto = 0; load.lies = lies
        each ik differs {
            load.was ||= {};
            load.was[k] = s.sc[k];
        }
        
        if (differs.length) {
            load.differs = differs;
            # 
            # < Tool for pulling as branch
            #   something differ can understand
            #   all terrain replication vehicle
            if (load.conform) {
                # should not be changing
                load.auto = 0;
                me&waits,"recipe-doesnt-conform",'exp!',6
            }
            if (load.auto) {
                # enacts change
                each ik differs {
                    me&tsc,'~'+k,0,6;
                    $v = c.sc[k];
                    $was = s.sc[k];
                    if (was != null && v == null) {
                        ~>7 redundant: g.t, '%'+load.type
                    }
                    v == null and delete s.sc[k]
                    else {
                        s.sc[k] = v
                    }
                }
            }
        }
        each ik differs {
            load.is ||= {};
            load.is[k] = s.sc[k];
        }
        return load
    };
    
            

    #c Chavesc helps to groupfixtype
    
    # most simple, hash of those properties or null
    me.Chassc = &acgtts{
        $Kc = Be.C[t];
        !Kc and throw "no Be.C."+t
        $c = {};
        each i,k Kc.scgk {
            $got = s [k];
            got == null and continue
            c[k] = got;
        }
        return hak(c) ? c : null
    };
    
    # like KnowC for %balls
    # sets up Km/Kn modulata
    me.Chavesc = &acgtcw{
        !c and throw "give c"
        $load = c;
        # everything it has:
        load.c ||= {};
        $Kc = Be.C[load.type];
        $Km = load.Km = G&Cye,[load.type,1,{Kc:Kc},'grouping'];
        each i,k Kc.scgk {
            $got = w && w.sc[k];
            got == null and continue
            load.c[k] = got;
            $Kn = fio(Km,k,[k,1,{s:k},'groupthing,fs:9,mar:0.3']);
        }
        !hak(load.c) and delete load.Km
        else {
            $M = Kms&z ||= [];
            $n =
            m KnowC_K 1 $s:Km.t,K:1 %hs:684,fs:7,mt:-1,label
            ny&cv = 0.001;
            M.unshift(M.pop());
            me&walls,Km,'bd:1.4,hu:3'
        }
        
        return load;
    };
    
    me.groupfixtype = &acgtRk{
        !Rs&ball and throw "!ball"
        $s = Rc&s;
        # type group s.sc.*
        $load = {type:k};
        me&Chavesc,load,s;
        $Km = load.Km;
        !Km and return
        $M = me&Mw,R,'trac-attr';
        Kmy&cv = 0.4;
        M.push(Km);
        # adopt their %fix
        $N = me&ioty,R,['fix'];
        each in N {
            ns&fix != 'sc' and continue
            $Kn = fio(Km,n.t,0);
            !Kn and continue
            ns&zuctedto = Kn;
            delete Knc&s;
            $M = Kns&z ||= [];
            M.push(n);
        }
        Kmc&load = load;
        return Km
    };
    #c grype watches %ball/%fix
    me.grype = &acgtRkc{
        c ||= {};
        # %grypes can outlive a %tracting (untested)
        # < lineated to the %balls in-sphere (checked out)
        # < %balls having gear to express this with us
        $g = me&rollbsc,R,'grype/'+k;
        # roll Km per Rfuture
        gy&R != R and delete gc&Km; gy&R = R;
        $Km = gc&Km ||= me&groupfixtype,R,k;
        
        # history/$gk builds up, can be %changey
        if (c.w) {
            # R is auto-changey ghost
            #  eg %ball%tracting reflecting dige
            $load = {type:k,auto:1,liesok:!Rs&liesnotok};
            me&Cloadsc,load,R,null,c.w;
            each ik load.differs {
                $was = load.was[k];
                $is = load.is[k];
                $d = G&Cye,['Thing-has:'+k,1,{s:">"+was},'changey,histgk,fs:8,hue:2,bri:0.7'];
                me&walls,d,'b:2.2h666';
                ds&gk = k;
                if (was == is) {
                    # if waiting to apply the change
                    dc&s = "<"+load.c[k];
                    ds&bri = 1.3;
                }
                # puts new top on history
                me&givi,g,'history',d;
            }
        }
        
        !Km and return
        Kmc&g = g;
        
        # take interesting g/*/*:gk to their Kn(%fix
        # change history
        $N = me&ioty,g,['',''],['history',''];
        each id N {
            $Kn = fio(Km,ds&gk||d.t);
            !Kn and continue
            fio(Kn,d)
            dy&cv = 0.789;
        }
        
        return Km
    };
    #c gromps - projects into yonder grypes
    # without relying on them %tracting yet
    #  eg check child dige, sends trouble
    #  or !exists, input
    me.gromps = &acgtRtks{
        !Rs&ball and throw "!ball"
        # this R project*
        $g = me&rollbsc,R,'grype/proj';
        $reset = !fio(g,'o',0);
        R.t.includes('ick') && reset and ~>4 reset: R.t
        $go = fio(g,'o');
        # this projection
        $gt = fio(go,t);
        
        $ks = k.split(',');
        ks.length != 2 and throw "only 2-spheres"
        ks[0] != 't' and throw "for t,$scgk"
        # one $scgk, many R/$t
        $k = ks[1];

        # match against what we have
        # < should only be (%ting, but is implied
        #   we have no other stuff in the Know yet, but could
        #   supposedly the implications would change,
        #   as u climb
        $have = {};
        me&ioty,R,'ball' .map(&n{
            hak(s,n.t) and have[n.t] = n
        });
        
        $news = [];
        each tv s {
            $r = have[t];
            # < these should be elvised in there
            #   to sleep the pile. write these:
            #   e $r -proj-cha $lc
            $d = G&Cye,[t+"%"+k,1,{s:v},{proj:gt,nk:'sc',gk:k}];
            fio(gt,d);
            dc&R = R;
            if (r) {
                dc&r = r;
                $rs = rc&s;
                !hak(rs.sc,k) and ds&cha = 'new'
                else
                rs.sc[k] != v and ds&cha = 'diff'
                # < gone is dcR != yfuture at the receiving end
                #   with non-fatal not in Rc&N
                $og = me&rollbsc,r,'grype/proj';
                $ogi = fio(og,'i');
                # < Rname:
                me&givi,ogi,R.t,d;
                # >1 them, springs into lies fixing
                ds&cha && !Rs&noprojcha and ac(r,'trouble',d)
            }
            else {
                ds&cha = 'not';
                # create there
                $d = {may:'input_'+t,s:t,tsc:'y'};
                me&rolltog,R,d and me&input,R,t
                me&walls,d.n,'b:2.2h5';
                news.push(d.n);
            }
        }
        if (news.length) {
            # one thing here about the many not there
            $d = {may:'input_*',s:'Unhad:',tsc:'y'};
            if (me&rolltog,R,d ) {
                news.map(d => me&input,R,dc&s );
            }
            $n = d.n;
            ns&fs = 8;
            ny&cv = 0.4;
            news.map(d => me&modopt,R,n,d );
            me&walls,n,'b:2.2h5';
            me&mtsc,n,"\n";
        }
    };
    
    #c grimp - cross-pollinates grypes
    # dialects of R%grype/* conclude into fs&changey
    me.grimp = &acgtR{
        $g = me&rollbsc,R,'grype/proj';
        # i/R.t/$d%proj
        $N = me&ioty,g,['','','proj'],['i','',''];
        each id N {
            $Kn = null;
            # the groupthing.t we're going for
            $t = ds&gk || '?';
            each in Rs&grype {
                n == g and continue
                $Km = nc&Km;
                !Km and continue
                if (ds&nk && ds&gk) {
                    # < generalise from sc
                    ns&nk && ns&nk != ds&nk and continue
                    Kn = fio(Km,ds&gk);
                }
                else {
                    throw "grimp match "+d.t
                }
            }
            if (!Kn) {
                # may not have gk yet:
                #   make extra grype (usually for type groups)
                #   listens to all grypes for %groupthing/%changey
                $ge = me&rollbsc,R,'grype/sc';
                $Km = gec&Km ||= G&Cye,['may',1,{},'almost,grouping'];
                Kn = fio(Km,[d.t,1,{s:t+'!'},'almost,groupthing,fs:7,mar:0.3']);
            }
            Kns&almost and Kns&opa = 0.5
            # noted, might match history of this gk
            $r = dc&R;
            # < want things for fs&changey to be persistent
            $n = G&Cye,["Projected-from-"+r.t,7894,{projin:d},'dis:2'];
            n.t += " to s&"+t;
            me&walls,n,'b:2.2h666';
            fio(Kn,n);
            # < make namepath looking
            #   also if Mlimits dub all ^^^^ means parent loop
            #     make larger recycle symbol
            $up = fio(n,['fromabove',1,{s:'^'},'hs:999']);
            if (ds&cha) {
                # projected difference
                # noticing out of date from our memory
                ns&changey = 1;
                ups&fs = 13;
                fio(n,['projected-from',2,{s:r.t},'fs:6,hue:166,mat:-1']);
                fio(n,['projected-'+t,3,{s:">"+dc&s},'fs:8,dis']);
            }
        };
        Rs&traccon and me&nu,"grype/*",Rs&grype;
        each kn Rs&grype {
            # c&Km are display parts, non-persistent
            $Km = nc&Km;
            !Km and continue
            #Rs&traccon and me&nu,n
            $f = Rs&tracting;
            if (f) {
                # take any Kn/%changey as fs&changey
                $N = me&ioty,Km,['groupthing','changey'];
                each id N {
                    # < want things for fs&changey to be persistent
                    #   see 'these should be elvised in there'
                    if (fs&changey && dy&cv > 0.7) {
                        fs&changey = fs&changey
                            .filter(c => c.t != d.t)
                    }
                    ac(f,'changey',d);
                    # 
                    dy&R = R;
                }
            }
        }
    };
    
    #c know about the Thing independent of the species
    me.lookating = &acgtW{
        $Q = Ws&Q;
        $s = Ws&Live;
        $Thing = G&Cye,[s.t,1,{},{}];
        if (Ws&species == 5) {
            Things&dige = ss&ha;
            o $s/W/*:s
            each in ays&s {
                ah(Thing,'Wind',n.t,ns&ha)
            }
            # < some piles reway, others remix
            #   some are way leading to many
            o $s/w/*:s
            each in ays&s {
                ah(Thing,'wind',n.t,ns&dige)
            }
        }
        elsif (Ws&species == 1 || !Ws&species) {
            # < can do similar for .4
            # < pointings that adjust for its compression
            each in sy&N {
                ns&W && !ns&z &&
                    ah(Thing,'Wind',n.t,ns&ha)
            }
            $dige = Qs&dige;
            !dige and throw "nodige"
            # W:spot/* %ha are 9 (see AWriter), %dige are 12
            if (Q.t.indexOf('spot/') == 0 &&
                dige.length == 12) {
                dige = dige.substr(0,9)
            }
            Things&dige = dige;
        }
        else {
        }
        return Thing
    }








    #c SC/KnowThat-doc
    =pod supr: sub-processes set up diversions
    hoisting updates
    
       probably something like that
     going back to %MindInto
      has heaps to do.
      once this is stored again we want to link it into a /js/ name
     < knowing which can sleep,
       wai transmits all motivation
     < slep the X.*.* - paths and their first hash
       and aplup
       so
        eg all this %tracting gives over to Compiling
         except to game more info and check again just before writing
        unless its Live really changes
        < notify dome from Search
      thats what they need everywhere...
      
            # < each step vaguely leading to the next,
            #   so empty etc can etc
            #   now reliant on pushing ready (or Ready Comste->Comal)
            # illustrates something:
            # C.y side,size,why,whyre
            # C.c 'cuh'
            # C.sc 'see'
      
      %MindInto may also %KnowThat (etc) with %SupplyChai:
      
    =head1 SC:KnowThat

    usually wanting to wake the next phase
    they wai to themselves or others etc
      cross-heavings:
    
    =head1 G:Know
    
    a Know..G knows about an item
      eg whether to include it
        < other tricks
    %tracting leaves a Thing + fs&changey dige
      the others:
        reset if much change (esp Things&dige)
        sleep until we are ready/get to them
      must be awake sometimes later
       they zap it via wai $om
    
    =head2 Compiling
    
    %Compala leaves which thing to do next + how
      starts using leaf nodes from the Know..W,
       then the That..W it compiles
    
    =head2 Seq
    
    %Comste does it, steppily:
    
    =head4 %ting fully
    
    zap the {Know,That}..W to %species=1
    oughtnt change Things&dige
     would mean a 4 is not pointing to the 1 proper
    to change without losing its own mind,
    watch Things&dige stay the same
    
    =head1 G:This
    
    G:This/$t/$step may become any mid-change state,
      so we can bisect the changes of each hack we apply
       < and get perl to jsBabz
       we already have before/after babz in .1
        < acknowledge diff (minus source diff)
     and %MindInto can save and resume,
      supposing the ephemeral all/seq
        will converge on the same thing,
      loading G:This...W rather than generating it
    
    =head1 G:That
    
    writes it into /W/Forthe/That/$t.{1,5}
    
     the .5 would only include the That..W (non-leaf nodes)
     < but could include the foreign Know..W,
       if there was a way to C&W further away things
        would impose complicatable indexes on gatherthink
         which wai looks like it might handle fine
       else it symlinks them across the boundary,
        ForThe NAT putting them in ./exotic/$t,
         they mentioning W:exotic/$t
    
    commits the Know..$t %changey into ForThe
     < in the same commit as the Thats
    
    =head1 anyway
    
    =head2 G:*
    
    are %tracting items,
      having the ..G side in W:ForThe,
      the ..W could be anywhere (..G knows %directory)
    the G:Know should receive changes
    the G:This may hold %Comste states of interest
    the G:That are finished items
    
    (W:ForThe)/$G/**$t - aka $G..G
      is a treeish map of the pile, inside W:ForThe
      knowing their W out there, and more:
       eg. Know..G informs our processing of the Know..W
        by s&el=9 leaving entire W-things out for now
       eg. This..G helps %Comste resync for same %changey
        < and the same set of hacks,
          supposing they will be W to n, like W:of
        < This..G/$aspect (!%tracting) talks more
          would that be intended typing, eg. Swim cW together
       
    (W:ForThe/$G/$t) - aka $W
      are the items themselves...
    
    =head2 inhabit the line
    
    that springs up around them,
     wai and s.y.* carrying superimpositions
     
     s.y.*
      may inherit along the line,
       may provide ref continuity,
      sy&f, sy&Thing may change to new editions
      sy&Compiling = s)%ball%Compiling etc,
       so steps know about each other,
      sy&supr=Compiling to know what type it is
       %Omplier sets them as such...
      sy&R should be the R%ball
      
     wai
      same but more sensitive/out of timeable,
    
    =head1 KnowThat-story #c
    
    %SC = %SupplyChai
    s/ForThe/MindInto/g
    
    @31
        looks at what it would send %SC-ward about its progress
         and more since its the particular thing doing something  
      usual 2-things to do,
       check for changes in state,
       that one may be waiting for a message from another
      
    < and mini-Display as such
       with an R Ringing on its own, inside a %sleeping
        vaguely looked at this near %Cit,
        it needs to recycle its X (not be a transaction)
         and R:Display only itself?
       would really help performance,
         esp when we know we just need to go Round again,
         to handle something posted to:
    
    @32
        see
        act
        has to go around to hoist things up
         which is probably good to frame
         < %SC-Ringing it again in the same day
    
    # etc:
    
      take messagey wai from **
       expecting them to at least say ok
        or recycle what was if sleeping
       passing that on to its next step,
        which it suggests the creation of:
        cellular relationships, their etc
        and know if this is reset-level change
         on either side, with the same tools and data
         just different perspectives on who we are
          the %SupplyChai being the A, the others being C
    
    
    =cut

    # for Compositing of/other tings
    # Lis R life of %Search%_ting(Q)/G&ting/G&t
    # extra tricks here
    
    # < rename oscty
    # local variables/hierarchy
    # as per some scheme
    $tracin = &Ry{
        $y ||= &{};
        me&ioty,R,'ball' .map(&r{
            $rf = rs&tracting;
            !rf and return
            rs&ignore and return
            y(r,rf);
        })
    };
    
    me.Tongingness = &acgtR{ return [
        #... me&Wrongingness ,
        #c A:f@37 %tracting waits -> %Compiling
        # %tracting_good waits for R/*%tracting_good, etc
        #  when we can rely on our children to complain,
        #  know if they're changey/trouble
        ['ball+tracting_good','52',&acgtRs{
            T.Mw = 'trac';
            $f = Rs&tracting;
            $pf = fy&up;
            
            tracin(R,&r,rf{
                # into this pool of what we're looking for from who
                # < display their stuff up against them
                #   dividing the ball in two
                
                # completed 51
                !rs&tracting_good &&
                    ah(R,'waitz','tw_scgk_r',r.t,'tracting_good',r);
                
                # completed 52
                #  which they haven't this future
                #  it should know changzo/simply/awake+ready,
                #   which would unset in 61 if net change
                !me&ollbs,r,'tracting_goodin' &&
                    ah(R,'waitz','tw_scgk_r',r.t,'tracting_goodin',r);
                
            });
            
            # autothink
            $wa = {solvent: [{
                dscif: {scgk:'tracting_good'},
                arkfor: {r: {cb:&dr{
                    ac(r,'trouble',R.t+" wants %tracting_good")
                }}}
            }], beready:1};
            
            # weakly supposing no signal means ok
            !me&waitzo,R,wa and return
            
            # children at least here
            #  Ring usu. children almost here
            Rs&tracting_goodin = 1;
            
            # modulat from the grype of late only
            if (fs&changey) {
                $out = [];
                each in fs&changey {
                    !ny&R || Rc&N.indexOf(ny&R) >= 0 and continue
                    ny&timingout ||= 0;
                    ny&timingout++ > 2 and out.push(n)
                }
                fs&changey = fs&changey
                    .filter(n => out.indexOf(n) < 0);
                !fs&changey.length and delete fs&changey
            }
            
            # which means all we need to compile is connected!
            if (pf == fy&top) {
                $g = pfy&G;
                aha(g,'wou')({ready:1,tw:R.t,r:R});
            }
        },'ift,D'],
        
        #c A:f@3 being fy&G
        # gleans %ting's usual sc
        #  C visua
        #  if different, wills its children to do the same
        # over a few Domings, since Ring A-time is not precise
        # < set it to wind back this branch
        #   as ss&wantdige, may not be doable
        #     for _ting to ask /W/ or /js/
        # < copy from last good, or %fix/gamesc gizmo
        # < this Know gets slowly tractorbeamed to stable/Know,
        #   the load.auto waiting for test runs
        ['ball+tracting','51',&acgtRs{
            $D = Rs&C;
            # send r%trouble as late as you want to open it
            me&ollbs,R,'trouble' and Rs&openey = 1
            $c = {};
            $f = me&tracmode,R,'ting',c;
            
            if (f) {
                # the Know.G itself etc don't mind not being
                f == fy&top and return
                $W = fy&W;
                $Q = Ws&Q;
                # ttl occasionally
                $notready = !Q || !Qs&ready;
                notready and me&waits,"!ready"
                $w = Ws&Live;
                !w and me&waits,"!live"
                !w && !notready && Qc&el == '9' and Rs&creatine = 1
            }
            # < should have some waits
            !f and return
            
            # f goes to next steps, beyond %tracting-specifica
            sy&f = f;
            # roll/sleepatch inner processes
            me&rolls,'grype',{s:f.t+"@"+Qs&dige,alsolineate:f};
            me&rollbs,'amCompiling';
            
            # lowlevel pre-f matters
            $game = me&gamesc,R,f,'game',['look','get'];
            
            !me&beready,R,'trac' and return
            
            Rc&dupl = 3;
            
            # looking at the answer
            # < sleep by Q&dige
            $Thing = Rs&Glean = me&lookating,W;
            # sync ss&dige and Thing's dige (however it appears)
            #  and whatever other Things project knowledge around
            
            # key behaviours, to stare at problems for longer:
            # hold changes to s that it has already
            # < we don't need to compile simple connections?
            #   trusted sources etc
            # ! if grype causes f%changey but applies the change
            #   (liesnotok=1 not to)
            #   grype rolled forgets it made the change
            #   f%changey can be forgot if R%tracting is interrupted
            # don't apply change from the Thing until Compiling wants to
            Rs&liesnotok = 1;
            fs&commiting and Rs&liesnotok = 0; fs&commiting++
            # hold waking Thing changes are projected into:
            # < without hiding the change
            #Rs&noprojcha = 1;
            
            # %ting attr were auto upload/download by A:f
            # < configure it here sometimes
            me&grype,R,'ting';
            
            # %dige-ish group - change makes fs&changey
            me&grype,R,'W',{w:Thing};
            
            # < particularly if it changes when we game look->get,
            #    would mean a 4 is not pointing to the 1 proper
            
            # %el etc
            $inc = me&grype,R,'inc';
            if (inc) {
                if (ss&el == 9) {
                    Ds&bri = 0.6;
                    me&mtsc,inc,'ig',0,'B'
                    # < also ignored by the compiler
                    Rs&ignore = 1;
                    return
                }
                ss&el == 7 and me&mtsc,inc,'hmm',0,'B'
            }
            # we must now become changey if:
            #   any of our W-type data changes
            #   child dige projection wrong
            Things&Wind and me&gromps,R,'Wind','t,dige',Things&Wind
            # tally  grypes and gromps (from above)
            me&grimp,R;
            
            if (Rs&traccon) {
                me&zu,'Thingstract',Thing
                fs&changey and me&zu,'changey',fs&changey;
                Rs&trouble and me&zu,"Rtrub",Rs&trouble;
                #me&zu,'Loadism',load
                Ds&fs = 15;
            }
            
            #c various leads to %changey, %openey, %trouble
            if (fs&changey) {
                # dige here or inside solving
                me&tsc,"f%changey","cha",'G';
                s&bgh = 111;
                # 2 them
                me&ioty,R,'ball'
                    .map(n => ns&openey ||= 1)
            }
            Rs&trouble and me&tsc,'trouble','trou','G'
            
            Rs&tracting_good = f;
            
            if (game == 'look') {
                # get dige-level diff figured
            }
            elsif (game == 'get') {
                # should match the dige-level figured
            }
            return;
            # < applying the sort-out-code scheme
            # wanting a decision on each one
            # (1 keep, 7 transfiguration, 9 death)
            $z = tc&s;
            if (!zs&el) {
                me&tsc,'('
                me&rolltog,R,'9',0 and zs&el = 9
                me&rolltog,R,'7',0 and zs&el = 7
                me&tsc,')'
            }
        },'ift,D'],
        
        #c %ting%More -> /%ting vision in
        ['ting','48',&acgtRs{
            $M = Rs&Te && Rs&Te.sc.M || [];
            !Rc&b and M.splice(0,M.length)
            Rs&Modin ||= [];
            each if M {
                ac(R,'Modin',f) and continue
                $c = G&Cye,[f.t,1,{R:1}];
                # gathers sc for type from Ghost,
                #  also inheriting from this W
                # and esp what fs&game might want
                $load = {type:'ting',f:f};
                me&Cloadsc,load,fy&G,R;
                ex(c.sc,load.c)
                ac(R,'More',c);
            }
            Rs&Modout ||= [];
            # entered too late last time
            (me&ollbs,R,'MoreLate' || [])
                .map(n => ac(R,'More',n));
            each in Rs&More {
                ac(R,'Modout',n.t) and continue
                n $n
            }
            # Rings children, then this step again
            T.ziter = 0.4;
            Rs&More = [];
        },'ift,D'],
        
        # ^^%tracting/...%ting finds itself
        ['ting','5',&acgtRs{
            me&tracarri,R,'ting';
            # see 'tracarri ahead'
            # < Ring all == cv to get v before ^ for inners
            #R.t == 'Stylehut' and ~>5 HutCell:
            !Rs&tracting and return
            $f = me&tracmode,R,'ting';
            !f and return
            
            # child find 
            Rs&flook = &f,r,ok{
                # via ForThe or so? collector of masses of %tings
                #~>7 Flook ting: f.t
            };
            # child input
            Rs&finput = &f,r,ok{
                ok != 'W' and throw "ting finput !W"
                $vel = {};
                # M[f] -> More[R]
                #  uses f.t and f Cloadsc
                # from fy&G to fy&W
                me&Ravelvis,fy&G,R,'M',f,vel;
                if (velc&el == 8) {
                    # means we should have seen it
                    # < Ring it
                    # < pass back the Runtime,
                    #   M[f].y.Real? it's not M[f] then
                    #   invent another object, the G pushing
                    #   is almost the %tracupload,
                    #    if it linked back to f
                    !r and me&tsc,'vel=8!r',0,6
                    !f.y [ok] and me&tsc,'vel=8!y'+ok,0,6
                }
                else {
                    # let elvising establish, then r
                    r = null
                }
                return r
            };
        },'ift,D'],
        
        #c ting fance, %tightly
        
        ['tightly','3',&acgtRs{
            ac(R,'inheritsc','tightly')
        },'ift,D'],
        
        ['ball+tightly','3',&acgtRs{
            $p = Ry&up;
            ps&ting && ps&species and Rs&tightly = ps&species
            
            # if they s&W (%sc may be talking about sc)
            $onW = Rs&tightly == 4 && ss&sc.includes('W')
                || Rs&tightly == 5 && ss&W;
            # ting it!
            onW && me&rolltog,R,'W?',0 &&
                n $s.t  R %ting,toW
        },'ift,D'],
        
        # look through 4/5 for links
        ['inspecto','3',&acgtRs{
            me&walla;
            $p = me.cbu(R,'ting');
            each in sy&N {
                (ps&species == 5 && ny&up && ny&up.t == 'W' ||
                ps&species == 4 && ns&sc && ns&sc.includes('W')) &&
                    n $n.t  $s:n,R %itemo:W
                ps&species == 4 && ns&c && ns&c.includes('W') &&
                    n $n.t  $s:n,R %itemo:cW
            }
        },'ift,D'],
        
        ['itemo','3',&acgtRs{
            me&walla,0.4;
            $p = me.cbu(R,'ting');
            me&tsc,'itemo',Rs&itemo,'6' .y.cv = 0.08
            $t = me&domesticate,R;
            ts&hs = 296; # tsc'y'
            ss&zs and me&tsc,'zsize','x'+ss&zs,'b'
            
            (Rs&boost||0) < 1 and return
            
            # open it in the .1
            $wasp = p
            ps&species and p = me.cbu(py&up,'ting')
            !p and throw "!pp !species"
            p == wasp and was = null;
            $M = ps&More ||= [];
            
            if (Rs&itemo == 'W') {
                $n =
                m $s.t  R:1 %ting,toW
                wasp and ns&autospecies = wasps&species;
            }
            else {
                $es = ps&Live;
                $z = es && ess&z;
                $ok = 0;
                each in z {
                    n.t != s.t and continue
                    $ok = 1;
                    m $n.t  $s:n,R:1 %ball,tightly
                }
                !ok and return me&tcs,'!Live/t'
            }
        },'ift,D'],
        #c %ting push/pull of C living across the boundary
        #  the question should roll+clone
        #    to transact by the dependent process?!
        ['ting','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dubquiet = 1;
            # make little label as from this I
            $p = me.cbu(Ry&up,'ting');
            $lab = &ltc{
                $n = me&tsc,'%ting-'+l,t,c;
                ns&fs = 11;
                return n
            };
            T.Mw = 'ting';
            
            # more %ting:1 in the same of/directory
            # < seeing where edges of C are,
            #   pressurise to voyage
            $t = null;
            if (Rs&ting == '1') {
                !p and throw "ting:1 !p"
                # same ting, may be adding %species
                Rs&ting = ps&ting;
                ps&directory and Rs&directory ||= ps&directory
                # may to another W/$t
                t = Rs&toW ? R.t : p.t;
            }
            # the Q&of = W
            !Rs&ting and throw "!%ting";
            $n = lab('ting',Rs&ting,'G');
            ns&fs = 15;
            
            # the Q.t = directory/t/species
            t ||= R.t;
            $fullname = t;
            #   only say change in directory
            (p ? ps&directory != Rs&directory : Rs&directory) &&
                lab('directory',(Rs&directory||'/'),'B')
            p && R.t == p.t ?
                lab('t-same','^','G')
              : lab('t',t,'G')
            Rs&species and lab('species','.'+Rs&species)
            Rs&species and fullname += '/'+Rs&species
            Rs&directory and fullname = Rs&directory+fullname
            
            me&the_ting,R;
            
            $Q = me&rollbs,R,'Q';
            Q && Q.t != fullname and Q = null
            !Q and Q = Rs&Q = G&Cye,[fullname,'',{of:Rs&ting}];
            Rs&Quploadsc and Ry&up.sc[Rs&Quploadsc] = Q
            Qc&async = &{};
            # c&canwait = 1;
            Qc&ready = &CP{};
            Rs&havediges and Qs&havediges = Rs&havediges
            Rs&section and Qs&section = Rs&section
            # < Live should never disappear?
            $s = Rs&Live = Rs&_ting(Q);
            
            T.Mw = 'ting-into';
            # you may roll into 
            me&rolltog,R,{may:'Q'},0 &&
                n Q  $self:Q,R %Cit,ot
            
            !Qs&ready and me&waits,'!ready','...'
            
            Qc&el and $el = me&tsc,'elvis',""+Qc&el,'b'
            el && elc&s == 9 and els&fs = 16;
            
            !s and return
            # look in
            me&rolltog,R,{may:'L'},0 &&
                n Live  $self:s,R %Cit,ot
            
            me&rolltog,R,'toball',0 &&
                n Live  $s:s,R %ball,tightly,refpool
            
            if (Rs&species) {
                if (!Rs&toball) {
                    sy&N ||= me&sunN,s;
                    me&tsc,'Csize','x'+sy&N.length,'b';
                    # < make part of genesising a %ting from a %tracting?
                    $tracting = Rs&tracting || Rc&b && Rc&b.sc.tracting;
                    $ope = !tracting;
                    ope ||= me&rolltog,R,{may:'inspecto',s:'O',fs:12};
                    ope &&
                        n inspecto $s:s,R %inspecto
                }
            }
            else {
                # %ting/%ting subspecies of same
                #  4 is low resolutions of the data
                #  5 is an of/t %Giveness
                Rs&autospecies and R.sc['/'+Rs&autospecies] = 1
                me&rolltog,R,'/4',0 &&
                    n Hive  R %ting,species:4
                me&rolltog,R,'/5',0 &&
                    n Give  R %ting,species:5
            }
        },'ift,D'],
    ] };
    #c Search Tingingness gets domethings
    # stately getting of things
    # < with/via e,
    #   generating more different e,
    #   returning you clues or it
    # < knows structuR, me.cby-like stuff
    #   the old G&t worked off A.1-5 being
    #    the spheres locality around A
    #   
    
    # G&c but harvested by Tool
    #  as coming from this R, in/out of time,
    #   talking about other R, to make acts shimmer
    #  available as verbosity, debug points
    #  muted when recognised
    # < io-param-like + styles of message with object in
    me.chatter = &acgttl{
        l.constructor != Array and throw "send array"
        each in l {
            l[i] = '>'+(3+(i*2))+':l'+i+' '+(n||'')
        }
        return G&c:'>1 '+t,l
    };
    
    # %ting is a layer upon ...
    me.the_ting = &acgtR{
        # have %Search%_ting
        $r = me.cbu(R,'Inn');
        $r = r && rs&Inn;
        !r and throw "no way Inn"
        !rs&_ting and throw "no Inn _ting";
        Rs&_ting = rs&_ting;
    };
    
    # Guxily for thing, got via stately e
    #  W it pulls in may clue changes to other W
    #  per remote place, which may already have its catalogue here
    me.Tingingness = &acgtR{ return [
        # the centralising of stuff going in!
        # for using thing = $of/$t on an ongoing basis
        #  gets I.$of.$t
        #  some $of (W/w/js) may network, contain more I
        # usually 
        #   is $t still $dige?
        #   its $dige, here: $s
        # we may get an el/lv/anything-known about things that change
        # the set of Questions you have:
        #   looks like Writer's .5 deps: $type/$name%details
        ['sleeping+Search','4',&acgtRs{
            $b = Rc&b;
            Rs&_ting = bs&_ting;
        },'ift,D'],
        ['Search','4',&acgtRs{
            # an h call muddies T
            $Gtime = &d{ return G&time,d };
            # similar!
            $ch = &tl{ return me&chatter,t,l||[] };
            
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            me&introqua,[R,'Ghost'],{boost:-1},'@1';
            n Ghost  $s:Ghost,R %ball,childy
            
            # of/t=$P
            i $Ghost/In
            # of/t=$P in motion
            i $Ghost/Pulling
            
            
            $Pio = Rs&Pio = {};
            Pio.what = &tP{
                o $Ghost/#$t/#Pc&of/#$P:s
                return ya
            };
            Pio.not = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
            };
            Pio.is = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
                i $Ghost/#$t/#Pc&of/$P:s
            };
            
            #c _ting - a many arg'd entrypoint
            #  ting becomes the reduce for io's map
            # 
            Rs&_ting = &stz{
                # Question - may come with ...
                $C = isC(s) ? s : G&Cye,[t,1,{of:s}];
                
                # the G.t variety?
                # if !found of a Talky of:
                
                # C in the field, P in the store
                $P = Pio.what('In',C);
                if (!P) {
                    P = G&Cye,[C.t,1,{of:c&of},{}];
                    Pio.is('In',P);
                    Ps&Want_Check = 1;
                }
                # validate cache
                Ps&now && Gtime(Ps&now) > 25 and Ps&Want_Check = 1
                s&P && s&P != P and s&oP = delete s&P
                
                # in/out of time bit, lost in the store
                $ok = Rs&Pull_a(C,P);
                
                # don't wait for the async check
                # Pc&s only null if never found,
                #  or new string is got but not decoded
                !ok && Pc&s && !c&canwait and ok = 1
                
                if (!ok) {
                    # go async
                    s&ready = 0;
                    # after, c&ready() climbs back to C time
                    c&ready and ac(P,'readyingC',C)
                    c&async and c&async()
                    else {
                        G&TuneTimeMachine,c&of+':'+C.t
                    }
                }
                else {
                    # C is, Pc&s == null must be intentional
                    s&ready = 1;
                    
                    # C <dige> P, may surprise
                    # el=1/8 basically
                    c&el = Pc&el;
                    if (!c&el || c&el == 1) {
                        c&el = s&dige != Ps&dige ? (s&dige ? 2 : 1)
                            : 8
                    }
                    c&el && Py&decidedel && Py&decidedel(c&el);
                    
                    s&dige = Ps&dige;
                    s&section = Ps&section;
                    !s&section and delete s&section
                    c&s = Pc&s;
                    # C never gets s&string unless it makes it

                    # keeps Pc&s while update is looked for
                    Pc&s && Ps&Pulling_since && c&canwait and ~waitscan
                    else
                    Pc&s and return Pc&s
                }
            };
            #c Pull_a
            
            Rs&Pulling_already = &P{
                $ya = Pio.what('Pulling',P);
                # don't trust stagnant Pulling
                if (ya && Gtime(yas&Pulling_since) > 5) {
                    ya = Pio.not('Pulling',P);
                }
                # don't shunt Pull_a from outside its own callbacks
                #  which will have ensured they don't reoccur
                ya and ch('dupreq',[Cc&of,P.t]); return
                return ya
            };
            
            # shunt P - can progress out of time
            # then returns 1 and/or calls c&ready
            Rs&Pull_a = &CP{
                # < make s&string mean write string, our thing in c&s
                if (Ps&Want_Check || s&string) {
                    if (Ps&Want_Check == 2) {
                        s&string and ch("Redo+string")
                        delete s&string;
                    }
                    else {
                        # waiting on P
                        Rs&Pulling_already(P) and return
                        # become Pulling
                        Ps&Pulling_since ||= Gtime();
                        Pio.is('Pulling',P);
                        Pc&T = {};
                    }
                    $T = Pc&T;
                    # shunts Pull_a when ready
                    T.cb_gen = &CP{
                        if (T.redo) {
                            ch('Redoing',[P.t]);
                            Ps&Want_Check == 2 and throw "redo x2"
                            Ps&Want_Check = 2;
                            delete T.redo;
                        }
                        else {
                            delete Ps&Want_Check;
                        }
                        Rs&Pull_a(C,P);
                    };
                    # sends
                    Rs&Pull_Check(T,C,P);
                }
                $T = Pc&T;
                !T and throw "unstarted P"
                !T.ok and return
                
                # < C gets its own decode? or Copy Pc&s on el<3
                #s&wantdecode and Ps&Want_Decode = 1
                # < modes of decode: dl/Xpath, allowing yaml code
                Ps&noDecode and delete Ps&Want_Decode
                Ps&Want_Decode and Rs&Pull_Decode(T,C,P)
                
                !T.ok and return
                delete Ps&Want_Decode;
                
                # < way getting args/wrapping/eval as Pull_Transcode?
                #   it's ting's business if things want to share
                
                Pio.not('Pulling',P);
                delete Ps&Pulling_since;
                # pulling done re. $Ghost, but not $C
                #!Pc&s and throw "no ting Pcs: "+Pc&of+'/'+P.t
                
                s&P = P;
                Py&decidedel = &n{ T.tcp && T.tcp.set('l3',n) };
                
                each iC Ps&readyingC {
                    # P completed async, get back to C time
                    #   no longer awaiting yon return 1
                    c&ready and c&ready(C,P)
                }
                delete Ps&readyingC;
                
                return 1
            };
            #c PullCheck
            Rs&Pull_Check = &TCP{
                T.waits and throw "PullCheck while waits"
                T.ok = 0;
                # they may have their own ways to use dige/v, p/P/s&P
                # Pc&get how to ask,
                # Pc&got loads response into P
                $Do = Rs&Talks[c&of];
                !Do and throw "!Talk "+c&of
                T.get = {};
                T.get.data = {};
                Do(T,C,P);
                if (T.done) {
                    # sync Talk.mem.Do
                    Ps&now = Gtime();
                    T.ok = 1;
                    delete T.done;
                    # for Decode timer:
                    #T.tcp = ch(c&of,[C.t,'.','.','.','']);
                    T.aft_waits = Gtime();
                    # no cb_gen, returns to Pull_a
                    return
                }
                !T.get.url || !T.got and throw "!Talk handlers "+c&of
                
                T.cb = &sc{
                    T.aft_waits = Gtime();
                    # every pulling happened now
                    Ps&now = Gtime();
                    # specific stuff moves from the response to P and Pc&s
                    #  can !T.ok...
                    T.got(P,s,c);
                    # out of time plumb
                    # may be stolen by got if more requests (/js)
                    T.ok = 1;
                    T.cb_gen and T.cb_gen(C,P)
                };
                Rs&TCP(T,C,P);
            };
            # rebuild tcp
            # < https://javascript.info/xmlhttprequest
            # < have A, so async in handler gets retried
            #    (or G&way noop deps just before handling)
            # < get or ws
            # retry, expire
            # uses T.get -> T.cb()
            Rs&TCP = &TCP{
                $tcp = T.tcp = ch("tcp",[T.get.url,'.','.','.','']);
                
                $done = &s,how,c{
                    !T.waits and return
                    T.waited = Gtime(T.waits);
                    delete T.waits;
                    tcp.set('l1',G&thime,T.waited );
                    r.status != '200' and return T.status = r.status
                    T.cb(s,c);
                };
                
                $r = T.r = $.ajax(T.get).done(done);
                T.waits = Gtime();
                
            };
            Rs&Pull_Decode = &TCP{
                T.ok = 0;
                $type = Ps&Want_Decode;
                $de = ch('decode',[P.t,type,'','']);
                # Pc&el becomes interesting to the Client,
                #   2-3 were our will carried out
                #   6-7 to merge
                # < C may want a new set for itself, to make a mess
                #   while we are in the clone factory
                #   faster to separate with io than many readLines?
                #   but how much safer?
                
                $s = null;
                try {
                    if (type == 'Lines') {
                        !Ps&string and throw "P!%string"
                        $N = G&readLines,Ps&string;
                        N.length != 1 and throw "Weird tW lines", s
                        s = N[0];
                    }
                    elsif (type == 'way') {
                        $w = G&Cye,[C.t,1];
                        wc&s = Ps&string;
                        ws&of = 'w';
                        # dige is for s before compiled
                        ws&dige = Ps&dige;
                        s = w;
                    }
                    elsif (type == 'js') {
                        s = Pc&s;
                        Rs&Decode.js(s);
                    }
                    else {
                        throw "Decode type "+type
                    }
                    s.y.P = P;
                    Pc&s = s;
                }
                catch (er) {
                    T.er = er;
                    de.set('l2','Error!');
                    de.set('l3',er);
                }
                Pc&s = s;
                s && !T.er and T.ok = 1
                
                if (T.ok && T.aft_waits) {
                    T.aft_waited = Gtime(T.aft_waits);
                    delete T.aft_waits;
                    T.tcp && T.tcp.set('l2',G&thime,T.aft_waited );
                }
            };
            
        
            #c Talks.w
            Rs&Talks = {};
            Rs&Decode = {};
            Rs&Mix = {};
            # < w are from:
            #  the digway+/way/ (trad)
            #  the /w/ (unBabz'd way) (new)
            #    this dige might match the one from digway?
            #  the /wayz/ (Babz usual blockquotes)
            #    for use in We
            Rs&Talks.w = &TCP{
                # < Babz mode: none, normal, BQ-inclusive
                T.get.url = '/way/'+C.t;
                Ps&dige and T.get.data.have = Ps&dige
                T.got = &Psc{
                    $dige = c.getResponseHeader('Dige');
                    !s && Ps&dige == dige and s = Ps&string
                    if (s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = dige;
                        Ps&string = s;
                        Ps&Want_Decode = 'way';
                    }
                };
            };
            #c Talks.js
            Rs&Talks.js = &TCP{
                # I in a .js script (+ a little about the 9)
                # first request: only to find the dige,
                # then we can write a unique <script src=toit>
                # < if we know what version don't do this first request
                # T would put this c&dige to wind back from bugs
                # hazardily shared P having the branch reset,
                #   put the -$dige in C.t already to have a specific P be there
                T.get.url = '/js/'+C.t+'-'+(c&dige||'head');
                # < if c&v forced/trusted (via Wover),
                #   use the exact url to add_script
                # < does the rewritten Location mean the second XHR caches?
                $cb_gen = delete T.cb_gen;
                T.got = &Psc{
                    $src = c.getResponseHeader('Location');
                    $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                    $W = Pc&s = G&Cye,[m[1],1];
                    Ws&I = {};
                    Ws&dige = Ps&dige = m[2];
                    # /js/ 
                    # nest callback
                    T.ok = 0;
                    T.waits = Gtime();
                    $callback = &s,e{
                        T.waited_script = Gtime(T.waits);
                        T.ok = 1;
                        Ps&script = s;
                        Ps&Want_Decode = 'js';
                        cb_gen(C,P);
                    };
                    Rs&add_script(src,callback);
                };
            };
            # implant code as .js
            #  should be able to receive any ting,
            #  esp way, is more stack/debugger findable loaded like so:
            Rs&add_script = &src,cb{
                $have = $('body script[src="'+src+'"]');
                have.length and return cb(have[0])
                $s = document.createElement('script');
                s.setAttribute('src', src);
                s.setAttribute('type', 'text/javascript');
                cb and s.onload = &e{ cb(s,e) };
                document.body.appendChild(s);
                return s
            };
            Rs&Decode.js = &W{
                $tocfunc = W.t+'_'+Ws&dige;
                !window[tocfunc] and throw "Notocfunc: "+tocfunc;
                $toc = window[tocfunc]();
                $D;
                each iv toc {
                    $ind = v[0];
                    $C = G&Cye,[v[1],v[2],v[3],v[4]];
                    if (ind == '') {
                        D = Ws&I[C.t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        # grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t, v
                    }
                }
            }
            #c Talks.W
            Rs&Talks.W = &TCP{
                T.get.url = '/W/'+C.t;
                $d = T.get.data = {};
                # clue them to Hobs for it we have around
                # the current HEAD:
                $haves = s&havediges || {};
                Ps&dige and haves[Ps&dige] = Ps&string
                hak(haves) and d.have = haks(haves).join("\t")
                s&section and d.se = s&section
                # the first "can you hold on to..."
                if (s&string != null) {
                    # wants to write, '' to delete
                    T.get.type = 'post';
                    # the .1
                    d.s = delete s&string;
                    # ignore write 
                    if (d.s.length && d.s == Ps&string) {
                        # just keep expecting it
                        !d.have and throw "sleeping write !Psdige"
                        delete d.s;
                    }
                    else {
                        # < get the average size of codes down,
                        #   mix them locally (A:u)
                        c&patch and throw "< patches"
                        # continuity check, also for deletes
                        # < d.parent=null means it should be new
                        s&P and d.parent = s&P.sc.dige
                        s&parent and d.parent = delete s&parent
                        # the .5 comes along
                        $five = delete s&fivestring;
                        five and d.fivestring = five
                    }
                }
                T.got = &Psc{
                    $r = dej(s);
                    # dige find things we d.have
                    if (r.dige && r.s == null) {
                        if (haves[r.dige]) {
                            r.s = haves[r.dige];
                            dig(r.s) != r.dige and throw "!security of anyone's Cs&havediges providing Ps&string"
                        }
                        else
                        d.s && r.dige == dig(d.s) and r.s = d.s
                        r.s == null and $nors = 1;
                    }
                    if (r.s && r.dige && dig(r.s) != r.dige) {
                        !C.t.match(/^spot\//) and ~>6 Nodig: C.t, dig(r.s), r.dige
                    }
                    $el;
                    $erok = 0;
                    r.ok == 'found' and el = 1
                    r.ok == 'created' and el = 2
                    r.ok == 'updated' and el = 3
                    # 6 is 3 from beyond 5! matters
                    r.ok == 'forward' and el = 6
                    r.er == 'not ffwd' and el = 7; erok++
                    r.ok == 'deleted' and el = 9; Ps&departs = Ps&dige
                    r.er == 'not found' and el = 9; erok++
                    Pc&el = el;
                    r.er && !erok and throw r.er
                    if (el == 9) {
                        # watch for undelete?
                        r.s and throw "what"
                        delete Pc&s;
                        delete Ps&dige;
                        delete Ps&string;
                        delete Ps&section;
                        # plumb? like an elvisory
                        return
                    }
                    if (nors) {
                        # < different perl/javascript dig
                        el == 3 and return T.redo = 1
                        else {
                            T.redo = 1;
                            ~>3 digeuno: C.t, r.dige
                        }
                    }
                    if (el == 7) {
                        # notify push failed?
                        c&rebase and c&rebase(P,r)
                        else {
                            throw "not ffwd: "+C.t, r
                        }
                    }
                    !el and throw "tW er", r.er, P, r
                    if (r.s && r.s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = r.dige;
                        Ps&string = r.s;
                        Ps&Want_Decode = 'Lines';
                    }
                    if (el <= 3) {
                        $se = d.se || r.se;
                        se and Ps&section = se
                    }
                };
            };
         
            #c Talks.ghost,tmp,mem
            # W that is string
            Rs&Talks.ghost = &TCP{
                s&string != null && !s&section and throw "/ghost/+ !section"
                Rs&Talks.W(T,C,P);
                T.get.url = '/ghost/'+C.t;
                Ps&noDecode = 1;
            };
            # tmp that is string
            Rs&Talks.tmp = &TCP{
                Rs&Talks.mem(T,C,P);
                Ps&noDecode = 1;
            };
            # mem that is Lines
            Rs&Talks.mem = &TCP{
                T.done = 1;
                $s = localStorage[C.t];
                $el = 1;
                s == null and el = 9;
                if (s&string != null) {
                    # wants to write
                    $parent;
                    s&P and parent = s&P.sc.dige
                    s&parent and parent = delete s&parent
                    parent && dig(s) != parent and el = 7
                    else {
                        s = localStorage[C.t] = delete s&string
                    }
                }
                Pc&el = el;
                if (el == 9) {
                    # watch for undelete?
                    delete Pc&s;
                    delete Ps&dige;
                    delete Ps&string;
                    # plumb? like an elvisory
                    return
                }
                if (el == 7) {
                    # notify push failed?
                    c&rebase and c&rebase(P,C)
                    else {
                        throw "not ffwd: "+C.t, r
                    }
                }
                if (s && s != Ps&string) {
                    Pc&s = null;
                    Ps&dige = dig(s);
                    Ps&string = s;
                    Ps&Want_Decode = 'Lines';
                }
            };
            #c way/js questions as C
            # public interfaces
            # shows how to plug their async gear into ting's
            # the wandering part of G&way
            Rs&quest_w = &acgttry{
                $ar = r;
                $cb = y;
                $Q = G&Cye,[t,'',{of:'w'}];
                Qc&ready = &{
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                    # so wait for it...
                    !cb and return
                    if (G&arfgunc,cb == "s") {
                        # way randomly happens, give return value to cb
                        # without A lining up around it (it may do so itself)
                        # see G&waylay for use case as delayed call
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the context revisted?
                        cb(t,ar,w);
                    }
                };
                Qc&async = &{
                    cb == 'noop' and cb = &{}
                    else
                    typeof cb == 'string' and throw "Cant go async: "+cb

                    # Jin should avoid this A for a while
                    a&ready = 0;
                    # and throw/abort if no callback
                    !cb and G&TuneTimeMachine,'w:'+t
                };
                $w = Rs&_ting,Q;
                return w
            };

            Rs&quest_js = &acgtt{
                $Q = G&Cye,[t,'',{of:'js'}];
                Qc&ready = &{
                    A.cv = 0.4;
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                };
                Qc&async = &{
                    a&ready = 0;
                    4s&N.push(A);
                    T.not = 1;
                };
                $W = Rs&_ting,Q;
                #a&I = Ws&I;
                #a&v = Ws&v;
                return W
            };

         
        },'ift,D'],
        
    ] };
    #c %mundws holds an A:ws
    me.Socketingness = &acgtR{ return [
        # < push/pull of C living across the boundary
        ['mundws','3',&acgtRs{
            Rs&rowish = 1;
            # < these ways to assume arguments want fibre
            $ws = me&rollbs,R,'Sock',1;
        },'ift,D'],
        
        # at LVing avail
        ['mundws','4',&acgtRs{
            Rs&rowish = 1;
            
            # current state
            $ws = Rs&Sock;
            
            # /path
            me&tsc,'mundws','ws:','b';
            me&tsc,'path',R.t
            me&tsc,'state',ws.state,'6';
            ws.state == 'closed' and Rs&Sock = 1
            
            # %Again
            $z = Rs&Opinion && Rs&Opinion.sc.z;
            $len = z && z.length;
            z and me&tsc,'Opinion.length','('+len+')';
            
            Rs&Lving &&
            n Lving  $self:Rs&Lving,R %Cit
        },'ift,D'],
        #c GhodigWap news from the 5 year old editor
        # one aspect of news about $ways, from g/\w+/\d+
        ['GhodigWap','3',&acgtRs{
            # replaces J:digwaypoll
            me&rolltog,R,'nodigway',1,&s{4c&nodigway=s};
            
            
            # $w as heard about, seekended and living (Iw)
            me&introqua,[R,'ifd','Ghost','apparently'],{boost:-1},'@1';
            me&introqua,[R,'ifd','Ghost','est'],{boost:-1},'@1';
            me&introqua,[R,'wats'],{boost:-1},'@1';
            
            # w can be trusted if listened for in digwaypoll
            # digwaypoll in/out only t + dige
            #  dige may vary in length > 6
            #  dige in merely allows Opinion to sleep
            #   when it comes out, which we could imply:
            #   < Lc&* for server's agreement with said diges
            #     they say what send() they agree up to,
            #      and we synthesize eouts to mean it
            n digwaypoll  R %mundws,Ghocoline,tinyscLines:dige,mightsctrunc:dige
            
            n ifd  R %Ghostway
            # < ^ having its own compile,
            #   your ting w/* perspective may incorporate it
            #   then another ing happens?
            
            # G&way compiled:
            n wats  $s:A.5.I.w,R %Idoubleyou,ball,childy:tw
            
        },'ift,D'],
        #c Ghostway - asks for way notifies, gets them
        # provides ein/out/ope
        #   by way of %Again/%tinyscLines
        #   for C sloshing in or out
        # knows how to talk ws:s/digwaypoll
        ['Ghostway','33',&acgtRs{
            $p = Ry&up;
            # place to talk
            $S = Rs&Upstream = ps&z[ps&z.indexOf(R)-1];
            $ch = Rs&chatter = Ss&chatter;
            # insured memories via %Again
            $g = Ss&Again = ps&z[ps&z.indexOf(R)+1];
            $Way = gc&s;
            
            # the 'here', a join
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            n Ghost  $s:Ghost,R %ball,childy
            
            # pile from both ends over time
            i s:{ Ss&Opinion=C } $Ghost/apparently:s
            # and changes go further
            i s:{ Ss&Further=C } $Ghost/seek:s
            
            # on change, queue:
            Ss&do_Further = &{
                # /apparently/* changing creates /seek/*
                # to look it up since that dige changed
                o $Ghost/seek/*
                $seeking = ays&s;
                !seeking and return
                Rs&seeking = seeking.slice();
                each is seeking {
                    o $Way/#$s
                    !ya and ch("didnt know",[s.t])
                    Rs&seeketh(s,ya)
                }
                return
            };
            
            # < ting many asks per question
            #   so many seekeths make one seekend
            #   is a keepalive for the first question
            Rs&seeketh = &s,was{
                ch("seeking...",[s.t]);
                #$w = G&ting,'w',s.t;
                #   currently takes old-G&t shortcut,
                #    returns way without checking ttl
                $cb = &t,ar,w{
                    Rs&seekend(w,s,was);
                };
                # noop='nottl' so it renews#
                G&way,s.t,{},cb,'nottl';
            };
            
            # thing is got!
            Rs&seekend = &w,s,was{
                Ss&sleep_Further &&
                    Ss&sleep_Further(w,s);
                
                $com = [w.t];
                !was and com.push("@1")
                else
                if (wass&dige == ws&dige) {
                    return ch("Seeksame",[w.t])
                }
                ch("Seekback",com);
                # hold latest one here
                # < of those changing rapidly
                #   rolling commits together
                #   ong branch slower, then ung
                i $Ghost/ing/$w
                # once after the batch (ish)!
                $si = Rs&seeking.indexOf(s);
                si >= 0 and Rs&seeking.slice(si,1);
                # wait up to 30ms if more might seekend
                $delay = Rs&seeking.length ? 30 : 0;
                # joining seekends near in time!!!!!!
                $cb = me&sccb,R,'seekingdone',Rs&do_ing;
                delay ? G&yl,delay,cb
                    : cb();
            };
            
            #c 7 thing-got
            Ss&sleep_Further = &ws{
                if (!w) {
                    # from eout that sleeps
                    o $Way/#$s
                    w = ya;
                    !w and return ch("didn't know sleeping",[s.t])
                }
                # Iw has $w, make permanent!
                ws&now = G&time + 3600;

                i $Ghost/seek/-#$s
                # < should know time is up for this ground,
                #   get it attached via Tsome
                #n seen  $self:w %Cit
                # permanent
                i $Ghost/est/$w
            };
            
            Rs&do_ing = &{
                # things changing, code to redo!
                o $Ghost/ing/*
                $inging = ays&s;
                # < otherwise G&ting evals?
                $doers = 'Soogle Packle Coffle Foogla Fividy NutGravy Fourism'.split(' ');
                $mewrap = 'iooia'.split(' ');
                $doerd = [];
                each iw inging {
                    if (mewrap.indexOf(w.t) >= 0) {
                        # me.code inits something
                        ch("Ghostwaywr",[w.t]);
                        me[w.t](w);
                    }
                    elsif (doers.indexOf(w.t) >= 0) {
                        # way contains me.codes
                        ch("Ghostwayer",[w.t]);
                        G&way,w.t;
                        doerd.push(w);
                    }
                    else {
                        ch("Ghostway",['',w.t]);
                    }
                    i $Ghost/ing/-$w
                    # then anything dependent on the way
                    #  eg I, J...
                    #  diff way to wake a .Ja. is not impossible
                }
                # for $w that generate $me which generate I,
                #   drop Ring's cache of me I
                $dropcache = doerd.length && 1;
                
                Rs&do_permanence(dropcache);
            };
            
            Rs&do_permanence = &dropcache,{
                # keep permanent
                # the only in-time operation
                # < scan for not in Iw
                # < dige sleep on init may not get things here:
                o $Ghost/est/*
                each iw ays&s {
                    ws&now = G&time + 3600;
                    if (dropcache) {
                        delete ws&makesI;
                        delete ws&makesIw;
                    }
                }
            }
            
            # keepalive
            Rs&do_permanence();
            # casual shunt, in case e loses its will to carry it out
            Ss&do_Further() || Rs&do_ing();
        },'ift,D'],
        
        #c %Again (C/%ball source) -> %ein()
        # e inits some state (usually)!
        ['Again','35',&acgtRs{
            !Rs&Again.sc.ball and throw "Again!ball"
            Rs&Lvact = &{
                $N = me&ioty,Rs&Again,'%ball';
                each in N {
                    N.indexOf(n) < i and ~DupeyzLvact: n.t
                    Rs&ein(n)
                }
            };
            # el=2 everything
            Rs&eope = &{ Rs&Lvact() };
            # el=2 changing
            Rs&Lving and Rs&Lvact()
            
        },'ift,D'],
        # %ein() C only t and certain sc
        # %eout() C into %Opinion
        #   and into %Further if certain sc change
        ['tinyscLines','32',&acgtRs{
            # Lving: may not make it through send() if same
            Rs&uniqsend = 1;
            # a t/dige only variety of tinyLines encoding:
            Rs&tinyLines = 1;
            
            # only certain sc taken
            $only = Rs&tinyscLines;
            only = only && only != '1' && only.split(',')
            Rs&takeonlysc = &s{
                !only and return ex({},s.sc)
                $sc = {};
                each ik only {
                    s.sc[k] == null and continue
                    sc[k] = s.sc[k]
                }
                return sc
            };
            
            # their Opinion arriving
            Rs&hasonlysc = &sl{
                $ks = only || haks(s.sc);
                $ok = 1;
                # checks how different it is
                each ik ks {
                    $was = s.sc[k];
                    $is = l.sc[k];
                    $com = [l.t, k, was, '->', is];
                    !is and ch('nullsc',com); return -1
                    
                    was != is and ok = 0
                    
                    if (!ok && Rs&mightsctrunc == k && was
                        && was.length > 6 && is.length > 6) {
                        ok = was.includes(is) || is.includes(was)
                    }
                    !ok && was and ch('scut',com)
                }
                # applies!
                each kv l.sc {
                    s.sc[k] = v
                }
                return ok
            };
            
            $ch = Rs&chatter;
            Rs&ein = &n{
                !ns&ball and throw "!ball: "+ki(n)
                $c = {}; # L%send[D.sc
                $s = nc&s;
                $C = G&Cye,[s.t,1,{},Rs&takeonlysc(s)];
                # Opinion is one piled from both ends
                #   so it can come back same the first time
                i Rs&Opinion/-#$C
                i Rs&Opinion/$C
                c.toLines = C.t;
                if (haks(C.sc).length) {
                    c.toLines += '%'+G&depeel,C.sc
                }
                Rs&send(n,c);
            };
            Rs&eout = &l{
                !Rs&Opinion and throw "give Opinion"
                !Rs&Further and throw "give Further"
                
                # their opinion is arriving
                i Rs&Opinion/#$l:s
                $ok = Rs&hasonlysc(ya,l);
                ok < 0 and 'said error'
                elsif (ok) {
                    ch('sleep',['way',l.t]);
                    Rs&sleep_Further &&
                        Rs&sleep_Further(null,l)
                }
                else {
                    # changes go %Further once per receive
                    ch((!ya?'new':'wake'),['way',l.t])
                    i Rs&Further/$ya
                    Rs&do_Further &&
                        ac(R,'Finally',Rs&do_Further)
                }
            };
        },'ift,D'],
        #c Ghocoline - C<->string envelope
        # provides %receive(), wraps %send()
        #   en/decoding some string format
        # Lving @31 logs a %send/receive[D+]
        # see 'Lving' around here, it may also:
        # < Ls&z clone C we sent them?
        #     would allow better %resumable
        #     %uniqsend dedupes for now
        # the @34 do push/pull C across a boundary stuff
        # the @32 is C<->string:
        # all Lines =~ /^[ \w"]/
        #  so there's room for some protocol in there:
        # < Lc&resumable - do you remember? rolls state:
        #   - roll Ls&send if %uniqsend, dedupes
        #   - know Ls&z and lv-sense to your app
        #   app must sleep while we try to:
        #   negotiate what they know with el=7
        #     might know our/previous Ls&sent_dige
        #       retransmit Ls&send
        #     or stuff on the ground
        #       exploratory W nature,
        #       eg check state of everything in Toys:
        #         Toys el:7%dige:358i0f
        #       may not include %dige on request,
        #         but then the server could pre-empt our:
        #           what has what become,
        #            and what can be patched
        # Lc&responsey - expect one receive per send
        #   link them, ordering if many backends
        #   responses not in requested order
        #   < slowing/Aing out time to understand message
        ['Ghocoline','32',&acgtRs{
            Rs&receive = &sD{
                typeof s != 'string' and throw "receive !string"
                $ch = Rs&chatter;
                ch and ch('receive',[ki(s,3)])
                
                Rs&tinyLines and Rs&someLines ||= 1
                Rs&someLines and Rs&contLines ||= 1
                
                if (Rs&contLines) {
                    # can know how to nest another protocol
                    if (!s.match(/[ \w"]/)) {
                        # tricks with Lving"
                        throw "strange"
                    }
                    elsif (s.match(/^ /)) {
                        # Lving -> last message's cursor
                        throw "floating start"
                    }
                }
                
                # string tricks
                # decoded N everything becomes M ways in
                $l = [s];
                if (Rs&someLines) {
                    # splits lines, batch of something
                    # < by next Line d=0?
                    l = s.split("\n");
                    l.slice(-1)[0] == '' and l.pop()
                }
                
                # parsed
                $z = l.slice();
                if (Rs&tinyLines) {
                    # parse Ghost%dige:4827848
                    each is l {
                        $s = s.split('%');
                        s [0].split("\t").length > 1 and throw "comp"
                        z[i] = G&Cye,[s[0],'',{},s[1]]
                    }
                }
                elsif (Rs&contLines) {
                    throw "readLines wanted"
                    # make R to deLines then ein?
                    #$N = me&readLines,s;
                }
                
                # iterated
                Rs&esout and Rs&esout(z)
                else
                Rs&eout and z.map(s => Rs&eout(s,z))
                
                $Fin = delete Rs&Finally;
                Fin && Fin.map(cb=>cb());
            };
            #c send!!
            $send = Rs&send;
            !send and throw "no Ghocoline proxy send()"
            Rs&send = &sc{
                $string = s;
                # the Lving%send/$D .sc
                c ||= {};
                typeof s == 'string' and 'ok'
                else
                !isC(s) and throw "obj->string"
                else
                s.y.R != s and throw "send C !R"
                else
                if (ss&ball && ss&toLines || c.toLines) {
                    string = c.toLines || ss&toLines;
                    c.origin = s;
                    $L = Rs&Lving;
                    # < Lving: repeat string/diff/compression
                    #   smelting toLines' intel,
                    #   what to do with lots of el:8 etc.
                    if (Rs&uniqsend && Ls&send) {
                        $i = Ls&send.length-1;
                        while (Ls&send[i]) {
                            $D = Ls&send[i--];
                            !Ds&origin and continue
                            if (Ds&origin != s) {
                                # by .t?
                                Ds&origin.t != s.t and continue
                            }
                            Dc&s == string and return
                        }
                    }
                }
                else
                ss&ball and throw "send R%ball!%toLines"
                else {
                    throw "send R!%ball"
                }
                
                $ch = Rs&chatter;
                ch and ch('send',[ki(string,3)])
                send(string,c);
            };
            Rs&open = &{
                $L = Rs&Lving;
                L && Lc&b && Lc&resumable and 'Lvism el=7 for %sent_dige'
                Rs&eope and Rs&eope()
            };
        },'ift,D'],
        #c A%Sock <-> A:ws!
        # at both ends of the deal
        # provides Rs&Lving and Rs&send()
        # uses Rs&open() and Rs&receive()
        ['Sock','31',&acgtRs{
            $ws = Rs&Sock;
            if (ws == 1) {
                $url = 'ws://'+location.host+'/'+R.t;
                ws = Rs&Sock = new WebSocket(url);
                ws.url = url;
            }
            
            # when R el=9
            me.cbuac(R,'unDoming',&{
                ws.close(1000,'lum')
            });
            $X = window.websocks ||= {};
            X[ws.url] = ws;
            $sockdup = &{
                X[ws.url] == ws and return
                ws.close(1000,'dup');
                return 1
            };
            
            # our A:ws.c hooks
            # this should A:session
            #   reflecting a scene across it
            #   they might hold objects for us,
            #     as we talk to them
            #   or show objects we talk about
            $L = me&rollbs,R,'Lving';
            
            # try leak chatter!!!!!!
            $ch = Rs&chatter = &t,ev{
                # < io-param-like + styles of message with object in
                $l = ev.constructor == Array ?
                    [R.t, ... ev] :
                    [R.t,
                    ws.deter('code',ev.code),
                    ev.reason,
                ];
                each in l {
                    l[i] = '>'+(3+(i*2))+' '+(n||'')
                }
                G&c:'>1 '+t,l
            };
            
            # L logs a %send/receive[D+]
            $roll = &tsoc{
                $L = Rs&Lving;
                !L and throw "ws:L:send!open"
                
                # accumulating dige
                $digek = t+'_dige';
                L.sc[digek] = dig((L.sc[digek]||'')+s);
                
                # point in time log
                c ||= {};
                c.now = G&time;
                # opposite direction's count
                # last in when this went out, etc.
                1 && o and c[o] = L.sc[o+"_i"]
                # tsc causes n ... deep within out of time
                $D = me&tsc,t,s,c;
                ac(L,t, D );
                
                # count
                $ik = t+'_i';
                L.sc[ik] ||= 0;
                L.sc[ik]++;
                
                return D
            };
            
            # open/close/explode
            ws.onopen = &ev,{
                ch('open', ev);
                L = me&rollbsc,R,'Lving','b,increment';
                Rs&open();
            };
            ws.onclose = &ev,{
              ch(ev.wasClean ? 'closing' : 'close', ev);
              ws.deter('code',ev.code) != 'bad' and return
              # will re-new when R wakes
              delete Rs&Sock
            };
            ws.onerror = &ev,{
              ch(ev.wasClean ? 'err' : 'errs', ev)
            };
            
            # send/receive
            Rs&send = &sc{
                $D = roll('send',s,'receive',c);
                # never fails?
                ws.send(s);
                return D
            };
            ws.onmessage = &ev,{
                sockdup() and return
                $s = ev.data;
                $D = roll('receive',s,'send');
                Rs&receive(s,D);
            };
            
            # interpret the machine
            ws.proto = {
              state: {
                0:'connecting',
                1:'open',
                2:'closing',
                3:'closed',
              },
              code: {
                1000:'closing',
                1006:'bad',
                1001:'leaving',
                1009:'toobig',
                1011:'500',
              },
            };
            ws.deter = &tk{
                k == null and return ''
                return ws.proto[t][k] || t+'?'+k
            };
            ws.state = ws.deter('state',ws.readyState);
        },'ift,D'],
    ] };
    

