Foogla: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    =head1 #prepare to A=A
    
    some goals:
    - efficiently educating on A passage of time
    - J to take < 200ms
    - not noticing anyway
    - Elvising running the shower
    - unpatch, failing, patch, passing in a few seconds
    
    =head3 future of sleep: Doming
    A starts works, D are their completion
    
       C   E
     A   D 
       C   C
    
    A C9[C...] completes D and elvises a clone
    
    D - the Aing grouping items sprout inside
      z C & A to include C/group A workload
      provide osc-like cha/continuity without osc,
        yet be the atomicness osc uses to commit,
        and load with decor/nativities to make for mediation
          R:I is now being the osc workload gatherer + commit
            which should work on >=1 'pages' of osc at a time
              eg elvising from ...
              or the whole/9er
            rolling the others,
            being able to async progress,
              do work in parallel or not...
    make unities early to sleep/calculate desires better
      eg. when A is @28, the state can be considered D:early
      eg. when Jpin, S makes domes, which can then be known about
    internal buzz. pages of its ground.
      get composited into D:top, C9[C...] post-osc
      which gets hoisted/elvised into J/W timespace elsewhere,
        the macro-J Doming-looking action: hosting stuff.
    so to:
      make arbitrary groups
        for groups sake:
          naming stuff
          handling streams
        to stabilise/refine our sense of activity
      transport C out of time,
        so J>7 can help J<7 (sleep)
        osc-think may play with things outside of osc,
         < holds that state in a dome it hopes to pull in?
      locate them as possible actions,
        as bumping into a S-ection kinda defines it
          < more at compile time
        and elvis handlers... 1s&ein.sayeth = &acgts{
      know inputs in a tracable way
        Elvising pointing in here,
          as Teing is
        giving Desire pathways to trace processes
    
    Domes may iterate X/V or some structure from another Dome,
      it may be important to iterate locally and do remotely,
        they become transactions
    Desire might want to do something,
    as a new elvis pointing into here would
     Teing is a kind of elvising
       and is the float:right upside down triangle of stuff
         the small network-edge pile coming down into
         the big contenty pile of isness
     Schemas too, float their potential/unfoldment
       down holes they start matching
    
    #c sleep/done =head2 sleep
    
    %slep, a Tool probe
      a way to map their changes fast and sleep
        change of container vs. the values within etc
        can give/take sy&slandige/Ry&Te_slandige
     < could be faster/lessR: callback a huge ==-ish plucker,
        50ms 3%slep could get down to 4ms?
     < unicode everywhere. plants: 💮 🌸 🌷 🌹  🌺 🌻 🌼 🥀  🎕 ⚘ 🏵 🏶  🌱 🌽 🌾  ⸙ 🌰 🌿 🍀 🍁 🍂 🍃  🌵 🌴  🎋 🎄 🌲 🌳
     < Cye takes y=o89 -> ycv=0.089
     < put sdiff and dup etc in 11-ish (dup 1189)
     < C/sc/css compressions, in Line or not
     
    Tool openness
      configures injectoids and transfiguration
      < more timely %differ growing out of it
      real interesting later
    
    < Elvisory re-slaning on %push to it?
       is the elvis delivery mechanism:
        give edifice of deliverableness
         resolve to best case or so:
       if it were a different J:
        enter it, changes input to thisJ
        decide to redome thisJ to involve that,
          or seeing our change come back to us
       Matu-ish out-of-time with %push gravitate reruns
      redo R building on changed elvisory?
      see 'rebuild %push to use e'
       %push currently injects the remote %ball%movingin
         which will not work if its asleep
         but it could be brought around about as fast if:
    < Te the %moves to Elvisory/anywhere
       with a watch for completion and callback/expiry
    < universal vision of rc&ha.dup,
    < replace ravel with Doming and Display2
    < TEST io.i z much
    
    # another
    o rebuild I via Babd ways
     o link G/ to W/G so we can update it ourselves
     o get a Lis rolling nicely
      o tests sign the version as it percolates
    o rebuild jsBab in js
     o fast way changes, lots of test results if you want
     o check against jsBabz for j/2/*
    
    o 'rebuild %push to use e'
      %checkout the tangley varieties of %push
    
    o unify name extrusion (see names extruding)
      like X but with where/when to D,
        alt names and fuzzentations (figure name changes)
          inc. crunchable path descriptions in various datalang
        universal gone/unnoticed system
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
    
    good study.
    perldoc -f study
    # < in general, knowing if the A is for a queue or for right now

    
    #c=head2 Maturation
    
    Gombulus hives elvising going in or coming out
    TX
    
    o a&z toplevel thinker
      and its localised sidecares
      a bunch of A not expecting J overhead
      rebuilding on the Co Joinup
        having it bring G (map of its dependencies) (see Give)
          as an %H of a different name
            once osc piles of whatever hoisting is?
              not much doc about osc hoisting:
               the W/of/t may W/what/ever/it/takes/t
               for stats/accounting
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    
    o and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and W-contiguous
            the simple funtimes embedded in the page,
            if browser compatible, Wake up and do anything
        I-ing up Sevo, then placing more A-ily,
    
    o names extruding, like X but with:
      connection to a dome:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
            done-ish by %slep
              could describe path or so
        decide once D:in !%more
          D:new == D:old to sleep, or:
          clone D:new to D:out and ...
            becomes someones D:in
              border control
        
    o Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    o elvising coming out or going in on the X
      and transacting the change of it
       as Domes, which have versions of Domes going into them
       an osc that keeps everything it sees would be first
        and be the wandering frontiers of change
     
    o making the R an A.
      compiling ravel into throat?
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further) (%slep)
     ongoing bisection of A
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    # anyway
    
    back to Pass...
    
    # thursday:
      new A4,
        < starts from a single /js/ with
          one screenful of prior knowledge
        A calmly pulls in its deps, sets foot...
    # saturday:
    # friday:
      new I compiled fore-way,
        composited and storaged in Pass
        is a layer of tools on a type of wormhole,
         which we also need to grasp moving around
        the bunch of names, Lis
    #c monday:!
    W&Ha:
      bugs:
        seeI 1.2: is one of the Is Mlimits diags wrong?
        a slep inside a slep has some history issue, keeps spawning?
      W&ledges:
       tests slepology:
         specifically elvis change
       since W&edges is too large
     
     unseparated W&Ha starts taking Rc&N>1000 to check out
      its the elvising:
       < to be lv change only
       < not deLinesing to Wing, wait til Ting
      such shapes par importo A=A
      
    W&large_edges:
      W&edges:
       tests slepology:
         wakes on elvis/data change
         %countlife%aTool shows if its awake
         %differ goes round in circles as data loops
       only just able to complete with the current memory leak
       step 9 shows a bunch of yReal vanishing...
       
      toomuch:
       leading to '< %run/%differ' is desire to ease
         accepting changes, to exp or Te
       are both a little far away? would be nice
         but nearly done with tests until A=R round,
         which is likely to see them built more elegant
        - exp: later %doing to bring earlier accepted change
         see %differ. little far away.
        - Te: %doing brings T/$W back if modified
         also a little far away.
         get both diffing,
         the innermost T...%ball that was ==
          cloning that over itself, 
           pointed enough to apply to later %doing
            that wants to resume that state with more
          with a diff/accept stage
           temporarily projected into the %run by %Tool
         Lines|diff must find R per diffchunk
           Bunchology with the diffchunks != new
       will be:
       < linking T/$W -> W:PuTe or W:City:
          T/$W:edges.y.owner = $W:PuTe
           and $W:edges ~ $W:PuTe/$W:edges
          T/$W:City.y.owner = $W:City,
           and $W:edges is further inside, etc
             find refs for $W:City/*
          possibly need more %Lines gathering points
           or a function to gather them on demand
       < diffing T/$W:edges <-> W:PuTe/$W:edges,
         producing R in T/$W that have the change,
          and those that are merely transporting it
            common Lis sense
         so we know the minimum clone-over move to make,
           and what it should be cloning over
             < lv changes later
       < being a pathy clone-in %Tool to apply to later %doings
      
      random niceups
       %testrun=2 'get ahead of %run'
        until %step with boost
       %run: inventstep clones last step
       
       < %City is noisy, we want:
         %slan to turn miniature diff on the noise
          path to the Rthing, lines changed before next Rthing
      
       < %Cit shrinkgrouping known R props
        < group them by the I producing them
         < coder than dictionaries every property you use
       < %Cit visual cues for:
         R:Dough that %Someflav=C:Dough,
           for eg Rs&C = picture of self
          or C.y.Process = R
           things R has may link back to R with typing
       
       and A=R
       
       #   the curves of this paragraph looks great up close:
       #  this is what A:s-ions will look like
       # state changes
       # with casual causla {}
       # along space wiggle
       < %run:
         < using %differ to:
          < cursor various things to keep branchy,
            and hooks to make the test reset/pause properlike
              %differ becoming the time controller,
              %push%act merely a workflow in it
          < %doing brings T/$W back if modified
            probably into $doing/$W (nab%aTool loses %H)
            causing:
          < later %doing to bring earlier accepted change
            eg. PuTe arrangement before every step,
            has the story of elvis along it
            < must be applied as an lv change,
              sensitive to overwriting anything etc.
          < storing lv changes for consecutive %doings
       
    #c tuesdA:
    new/old ground:
    come back to A, they are like R:
      a&z (A.sc.z) are innards, like Rs&z
       only used in A:u
      a&N are innards anywhere wanting attention
       w:TuneTimeMachine gives A to 1s&N
       w:AndContinue: resumes all 3s&N
    so 1 can know what A it has in progress...
     AndContinue shall come again
      building W&Lis
      ...
    have R that can simply keep Ringing?
     < osc must get us back into whatever Ring:
       init: Ring@1 everything (Graze)
       then: resumes all Is&z
      the cores may fall asleep at random
       and may still percolate a Display anyway
       or lock the dome it was finishing from starting again
    see I and repackage:
       A:u makes .I
         mixed from many .I,
         got from /js/
         with async for update/check
       A.4:
        has loop bits, local culture
        .I:
         is everything, mixed up with StyleHut
         .i is all StyleHut,
          figure out what we need to keep
         never goes async, is trusted to be maintained,
         .w:
          has only this %namedcode thing
       A.5:
         looks neglected
         .w:
          is the spot, y&tw for $way
           they s&dige and s&now, G&way asyncs
           want to digwaypoll them, make sync
          all scooped up by Shovel, per test run
           which can make sync prior
    I.w is totally incidental,
    1s&minds[uname] = A c&N[4s&mind[t]]
     u deals with W via /js/, mixes onto Normal
    G&question (and other asyncers) should provide:
      ttl, ready=1 on callback
     to be useful for testing this stuff efficiently
    
     how it starts:
       html <script> get & eval from /thestart?step=n
        sends it A&loadI and Stylehut
         which includes HutNuts (begoin/jsung)
       G&begoin -> G&jsung,'NutMachine' cb -> G&Jinthe
         jsung looks like A:u but overwrites any A.I[t] = W:of it loads
         Jinthe sets up listeners,
          waylays NutGravy, defines function,
           waylays NutReady, more waylays.
     
     will start:
     < A&loadI a simple A:u@6 etc for basic mind mixing
       gather more mind, global functions, start loop
      should less async, and:
       be totally new ev/e hookup:
        Display:
         lose on.A
          use attr t/cv, attr sip if sJ
          and lookup to the sips of 4s somewhere global
          A.4 must always know about elvising
         lose jQuery,
          moving elements only as needed,
          text inputs not rebuilding every time
       
       ways to keep track of updates...
        make an islanding that can digwaypoll for:
          w change
          W change is regular /W/ with dige...
        know W that contain other W we are watching,
          digwaypoll for notify of W changing?
          could be wired into /W/
           not for the same socket?
         future /W/ storer is an elvising with a route,
          only then demands stringify to get across the net
    
    #c Wednesday
    water cactus
    very thinning impossibleness:
    < s&lv should come from the $main/A.4
       output modes are a T
    < frames
     < ifr:blank.html, inject with <script> etc, save
     < the html we build able serialise most C
       such that search engines will see it
         $Cs&W.html becomes the href=""
         going to build a lot of piles of <stylehouse>
    
    W:Pass %ball web surfing
     < keep openness from last time - part of:
       provide autosaved W/T from last time
        these could be tracked separately, likely to be mostly garbage
     < testbedding
       < deps: %Gounce - ghost versioning
         knowing exactly each I it ran with
         making cert to help that Gounce get places in W:Lis
     < %play$%W more properly,
         see Be, can elegantly play out over time...
           minor %torun-ish manage what seems to be a situation
         Rsync %gee%ball late,
          checkout fully, same Ring (T.Rq?)
           see about when %gee hits 92 before children done..?
     
     lvhashave%torun:
       test Element replacement with minimal add/remove
       currently will $(Rs&on).empty(); on any change
       'moving elements only as needed'
     
     mund%torun: de-lies fact piles
       various eg %Ghostways produce stuff
       they each become a Ghost unto further ...
       
       %JRom:
         encapsulates activity, Doming in and outs
         parts have error and (1|4)s&N plumbing
         < %balls in have slep/io-sense
         < T plumbing
         < pausing if time/sheer Ring intensive
           could control infinite loops in the same Ring
             the first Ring inside 4 should ttl when starting Ring
           for progress, may Ring more, when theres time
             sleeping for Display meanwhile?
               Rc&X will wander, merge the eventual completion
             or osc-ing each section as it completes
               like Doming, wants recode with T sense,
                recording the set of args used, etc
       
       %GhodigWap/%Ghostways:
         insures /way/$t against %mundws:digwaypoll
         < tractorbeam $Way into Ghost/Way,
           leaving the hoisting to $Way/5Iw up to mund
           this Ghosts best guess for those ways
           and providing data on dupover, etc.
           and helping lay out ref phylogen
         < G&ting/%ting forcing question/remote check
       
       sidenode:
         everything we n ... in R is really an m Rs&M ...
           unless it Cc&R: spawns R, c.* copied to sc.*
         such is a tubeending
      
       # do last
       < one big %ball,
        < some of it grounded
          there are C from/for Activity (osc-levitated)
          and C for being the sticks in the mineshaft
          < have a CdaR (fast) way to diff %balls to themselves
          whatever it takes
         < R:Thing%M should be channelled for %ball, etc
           eg the attr on a %Rom want arranged by the %Doming
            and gave/give each other life
         < R:Mapper may also have a little e/M on each of many,
           hanging up its thinking amongst others language
         < folding, taking %noDisplay off chidlren with activity
        < slep/io <-> what Reaction, batched
          eg /seek/ -> %do_Further()
         < via Sectiona, for an atime iterator of /seek/
        < getting that change to Rsync %balls,
       < even out of sync, to a degree
        < these ch() comments shall Tool down to
          fleeting speechbubbles, beneath the line
        < tree -> table mode as we cross the line,
          smoky action -> seeing office mode
       
     #c t!
     t:
      is thing finding
      t looks up A slope of places with things
      t looks in the dome building now...
       and for A-things around the place
        as A needs to find As to A
         t learning how to traverse every index
      # now:
      G.h(acgtt) does $t subroutine (I.i.h does I.i.$t)
       therein looking for $t becomes:
        G.t(acgt'i't) to avoid infinite h<->t loop
      # future
      B/T stack sensitive
        any call may be paused by a variety of reasoning
      G&lathe,3 Babz:
          G(A,C,T,'lathe',3)
      # or perhaps inlined non-inlined sub calls (no B-stack)
          G.i.lathe(A,C,G,T,3)
      # or totally inlined: ({}-scoped lexicals?)
          s&surface-- for 1..$s;
        this will be handy for generating G&throat
         from the dimensional joint protocols the I use
         these will need variants, as me&Ring is
      
      # lots of lang shall compile to lots of G(...)
      #   anywhere we thing stuff
      G = &ACTs{
          # like G.h
          $G = this;
          $args = arguments.slice(4);
          # simply looking for a function, closest A with it
          $i = is_string s ? G.t(acgt'i',s)
              # looking for something crazy,
              #   may even take args about this call
              #    and beyond, to find the right thing
              : G.t(acgts,[M]);
          B/T stacking {
          T.return = i(A,C,G,T, ... args)
          }
          return T.return
      }
      G.t = &acgtM{
          # like G.ting
          # matches whatever W/C/c in M
          #  sequences of them usu mean by z,
          #  array of arrays for resetting cursor
          # can also mean start doing a thing,
          #  nearby doming invites it to keep state
      }
      # further future:
      Babz realising parameters on things:
      G&$Self$Ne:za,$R$s$c:limin,%vang
      packs in the:
        G.t s={Self,Ne} c={R,s,c} 
         looking for (s) $Self and $Ne
          knowing the act (c) if that helps?
           or would it get confused with more itemology
            spose G could decide on the first being WHERE,
             the others being some extra into
             seems like something for doing subroutine calls remotely
        running it %vang mode with named arguments
         %vang could specify output form,
          a style to apply on something inside (G&tsc)
          some T-condition, error/async continance
          or name the object created
           t looks in the dome building now...
      T-condition,
       check it every B-stack (soon to be a lot of them
       error/async continance
    =cut
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #    C.y.R = R:C
    #   sprouts some sc to R:$gk or so
    # < determine, certify version of etc involved
    # we have a village's machinery for progress
    # < teleporting in: knowing you want such sleep pattern
    #    for vibrating values (oscillation)
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c Besk in options
    # < I, a W of qualities and how to use them
    $Be = me.Be = {};
    Be.scan = &acgtRs{
        $M = []; # q+
        each kt Be.sc {
            !hak(s.sc,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        each kt Be.y {
            !hak(s.y,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        return M
    };
    # makes D for q, thing attachment mode specifics
    #  D also gets how to act
    Be.cutch = &acgtRqc{
        $D = G&Cye,[q.tatch,5,c||{}];
        !D.t and throw "!t"
        # sc from matching
        q and ex(D.sc,q)
        # c from matched, the how
        Be[D.t] and ex(D.c,Be[D.t])
        # known properties on %ball%Be
        if (Ds&nk && Ds&gk) {
            # < Rc&X.Be.nk_gk for:   and Dc&b...
            $be = Rs&Be ||= {};
            be = be[Ds&nk] ||= {};
            be[Ds&gk] = D;
        }
        return D
    };
    
    # entrances:
    
    # 27%play + ^^%playsheet -> 
    Be.plays = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q )
            .map(D => Be&playit,R,s,D );
    };
    Be.playit = &acgtRsD{
        !Rs&ball and throw "What"
        Dc&play and Dc&play(A,C,G,T,R,s)
        else {
            # vaguely know it, not a c&play-er
            # < later check some Be used the %play
            # < thing's sc wants upgrading mode
            me&tsc,"!play:"
        }
    };
    
    # 3%ball sprawls to thing:
    Be.lums = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q,{ohm:1} )
            .map(D => Be&lumit,R,s,D )
    };
    Be.lumit = &acgtRsD{
        # symbol blocks the way
        $n =
        n $D.t  $s:Ds&gk %fs:14,hs:966
        Dc&symbol and nc&s = Dc&symbol
        nc&s.length > 5 and Dc&symbolsize ||= -5
        Dc&symbolsize and ns&fs += Dc&symbolsize
        
        # c&nofurther - stop adding R under this one
        #  recursion control
        Dc&exRc and ex(R.c,Dc&exRc);
        
        Dc&BeX and Be&BeX,R,s,D
        
        # %play things tend to hide/represent in-%balls
        Dc&play and Dc&hbb ||= 1
        # otherwise it costs 1 boost
        # < consumable if Tie remembers
        !Dc&ohm || Rs&boost > 0 and 'open'
        else {
            # tend to hide every R inside...
            !Dc&hbb and Rs&nofurtherDisplay = 1
            # very high level view of what else scans interesting
            ss&z &&
            n withz  s:z %fs:14,hs:966
        }
        Dc&hbb and Rs&hideballsballs = 1
        # do more display?
        # look up for a qua ac?
    };
    
    #c Bersons
    # known properties may ... (%ball%play)
    Be.sc = {};
    Be.y = {};
    
    # s&H
    # stored object
    # < boostrap from H:1
    # < know exactly where it is (/G/*)
    # < know history of it across history of s
    # < history of s vs. history of R, getbetween.
    #   values exist somewhere fractionable in Domes,
    #   pinned down every so often from various angles
    #    and resolutions yada
    #   simply have to play lv in reverse, watching path
    #    lv must play from an el<3
    #    to know it has everything in the situ,
    #     which could be localised to part of the path
    #     < lv requests should serve grep into paths
    #       thence almost-Lines wants to end up in a database
    Be.sc.H = 'sH';
    
    # s&quiet
    # eg a Js&Te doing usual work
    Be.sc.quiet = 'squiet';
    Be.squiet = {symbol:'q'};
    
    # y&lv
    #  boundary to a done thing that will join to us
    #  eg. your %Lines hoists the s.y.lv as itself
    Be.y.lv = 'ylv';
    Be.ylv = {symbolsize:-2,exRc:{nofurther:1}};
    
    # s&testrun
    # does a test via W:Co
    # < elvise it
    Be.sc.testrun = 'stestrun';
    Be.stestrun = {play:&acgtRs{
        $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
        Rs&Te && Rs&Te.sc.almost and ls&almost = 1
        me&introqua,l,'boost:2','@1'
    }};
    
    # s&torun
    # does an Rz kinda thing
    # saving input/output like %push,
    #  similar to s&testrun but less remote!!
    Be.sc.torun = 'storun';
    Be.storun = {play:&acgtRs{
        $k = ss&torun;
        k == '1' and k = s.t
        # as a %Reis, instant to the enclosing Ring
        $c = {};
        c.task = 'rovo';
        c.t = s.t;
        c[k] = 1;
        $r = me&Reis,R,0,0,c;
        ac(R,'unplaycb', &{
            each in rs&unDoming {
                n()
            }
        });
    }};
    
    # s&W
    # < opens that Wormhole in the nearest %gee
    # < located around here:
    #    i ^^%gee/$W y o ^^/G/$W
    #     then %gee late Rsync,
    #      so openness can occur in this ev'd Ring
    #   this would be the stately G&ting
    #    5 could know all the W we use
    #   iter `dig`
    #   < hostinfo
    # < as another J,
    #   managing pause/sleep modes of them
    Be.sc.W = 'sW';
    Be.sW = {play:&acgtRs{
        # becomes signpost leading in
        $l = me.cbu(R,'gee');
        ls&openness.push(R);
    }};
    
    # s&J
    # probably a J:1,
    # make W from the elvisory
    Be.sc.J = 'sJ';
    Be.sJ = {play:&acgtRs{
        ss&J != '1' and throw "nonJ=1"
        # feeds with e
        me&Ravelvis,R,s.t;
        # < unDoming
        ac(R,'unplaycb', &{ me&Ravelvis,R,s.t,9 })
    }};
    
    #c BeGhost
    # R%ball r%fix
    Be.fixit = &acgtrsD{
        $R = ry&up;
        !rs&fix and throw "What"
        !Rs&ball and throw "What"
        # apply styles to r%fix
        $st = 'inputmode viewvia'.split(' ');
        each in st {
            !D.c[n] and continue
            r.sc[n] = D.c[n];
        }
        # < symbol's styles fitting into %fix n t
        #     might be too complex to read
        #       sprout as necessary
        if (Dc&play) {
            # can %play sometimes (via the %ball)
            # likely to show %fix t/s?
            s == '1' and me&tsc,'onething','=1'
        }
    };
    
    # s&of
    # code, generally compiles
    Be.sc.of = 'sof';
    # sets up openable codon on s%fix
    Be.sof = {BeX:{
        's%fix':{inputmode:2,viewvia:'size'}
    }};
    Be.sc.string = 'sstring';
    # sets up openable codon on s%fix
    Be.sstring = {ohm:0,BeX:{
        'string%fix':{inputmode:2,viewvia:'size'}
    }};
    # set properties of children that don't exist yet
    Be.BeX = &acgtRsD{
        each kc Dc&BeX {
            $name = D.t+' '+k;
            k = k.split('%');
            $t = k[0];
            k = k[1];
            # cousin of R.c.X/V
            $X = Rs&BeX ||= {};
            $tk = X.xtk ||= {};
            tk[t] ||= {};
            $oX = tk[t][k] ||= {};
            # where .x=[more R.t],.xtk=[more nk/gk]
            # and non-path things apply to the arriving R
            $sc = oX.exRsc ||= {};
            # rogue generation of D
            # < use cutch, make complicated Be[t]s
            sc.BeD = G&Cye,[name,5,c];
        }
    };
    # X.xtk = R.t, R.sc gk
    Be.BeXarrive = &acgtRsl{
        $p = Ry&up;
        $X = ps&BeX;
        !X and return
        # walk a path of x to X
        $x = X.xtk;
        each in l {
            x = x[n];
            !x and return
        }
        Rs&BeX and throw "Already at RsBeX"
        Rs&BeX = x;
        # check in
        x.z ||= [];
        x.z.indexOf(R) < 0 and x.z.push(R)
        # apply
        x.exRsc and ex(R.sc,x.exRsc);
    }
    
    
    
    
    
    
    
    
    #
    
    #c Beepingness/gc
    # %play engaged tasks
    me.Beepingness = &acgtR{ return [
        ... me&Tingingness ,
        ... me&Socketingness ,
    =pod
    garbec%torun: garbage collect localStorage
     , regex for %W and %H
      < know %parent, ship everything off to a git
       as a %torun
         with an %H/differer for the current state of it
         but just be an R, opening bits of net puzzle
         posit deletables, do one last grep for their %H
       good for up to 5MB?
       %H:
         any non-W chunk, storage t=dige -> string from Lines
         must %Lines encode H:... for regex
         < Lines could have many sc, keep first clean looking
       < %H may all hoist to the top, as in w:Writer/Gversioning
         would look like %Has:0294u390;34ui902d;345u209u3;3u8490j
    =cut
        # boost <0 to rescan. >0 to delete
        # < bright future of the backroom
        # < for the enclosing %gee
        ['garbec','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            
            #Rs&somehash = window.fogive ||= ex({},localStorage);
            Rs&somehash ||= localStorage;
            
            (Rs&boost||0) < 0 and 'rescan'
            else
            me&rollbs,R,'figure' and return
            
            n Pass  R %garbect,viaW
        },'ift,D'],
        ['garbect','3',&acgtRs{
            Rs&noDisplay = 1;
            me&tsc,'nothing';
            $k = R.t;
            $g = me.cbu(R,'garbec');
            # < use $k=Rc&s and Rc&refs to dedup
            $te = gs&garbect_t ||= {};
            te[k] and return
            te[k] = R;
            # order importo par stat hoist
            ac(g,'garbectN',R);
            # read
            $v = gs&somehash[k];
            !v and return Rs&err = "No "+k
            
            $l = v.split("\n");
            each in l {
                # < using Wm[3]: where the match started
                #   and showing the path through this place
                #   %garbect are places/storage points/gravity wells
                $Wm = n.match(/(H):(\w+)\b/);
                if (Wm) {
                    $H = Wm[2];
                    n $H  R %garbect
                    continue
                }
                # the s&W usually 1, encodes to just 'W'
                #  otherwise it's a different W this one must accompany
                #  eg %of is required (eventually) to wake up code
                $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
                if (Wm) {
                    $t = Wm[1];
                    Wm[2] and continue
                    # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                    n $t  R %garbect,viaW
                }
            }
        },'ift,D'],
        ['garbectN','6',&acgtRs{
            $te = Rs&garbect_t;
            Rs&figure and throw "garbectN + figure"
            $d = Rs&figure = {};
            d.to = 0;
            d.total = 0;
            d.disco = [];
            d.discotal = 0;
            each kv localStorage {
                d.to++;
                d.total += v.length;
                te[k] and continue
                d.disco.push(k);
                d.discotal += v.length;
            }
            $N = Rs&garbectN.slice().reverse();
            # < size of Ws sans in-Ws?
            each ir N {
                rs&err and me&tsc,"err",r.t+"_err:"+rs&err
            }
        },'ift,D'],
        ['garbec','7',&acgtRs{
            $d = Rs&figure;
            !d and throw "!figure"
            
            each kv d {
                typeof v == 'object' and v = v.length
                n t  $s:k %hs:999
                typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
                n s  $s:v
                n sp  s:\n
            }
            
            # delete the disconnected
            # < check it's a %H-type key,
            #    deleting W should be harder,
            #    but we can't really tell...
            # < know what hist
            if ((Rs&boost||0) > 0) {
                delete Rs&figure
                each ik d.disco {
                    # check they exist
                    !Rs&somehash[k] and throw "to delete, no: "+k
                }
                each ik d.disco {
                    delete Rs&somehash[k]
                }
            }
            delete Rs&Te.sc.boost;
        },'ift,D'],
    #c mund ravelabhion straight curvy cellvey
    # have wanting uphill showing where come
    # manage more %torun/things they do
    # set off an experiential perspective:
    # A locality of thing availability!
        ['mund','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '7px dotted green';
            s&hue = -70;
            s&br = 1;
            Rs&unDoming = [];
            # inner domes
            Rs&timetopause = 18;
            
            me&tsc,"munde";
            
            # catch errors per dome of resilience
            # provide headings with pausibles,
            #  errors and s&N coming out
            #  T.* changes and chatter
            # < %Reis with error handlers,
            #   pausible
            # < er + Ring cursor
            Rc&Rom = &ptc{
                !c and c = t
                typeof c == 'string' and c = {t:c}; c[c.t] = 1
                !hak(c,'t') and c.t = t
                t = c.t;
                
                # insist on %JRom enclosure
                !ps&JRom and c = {t:t,JRom:c}
                
                c.task ||= 'rovo';
                
                # < explore I by fraction
                c.wantsleep and c.ov = 0.279
                
                try {
                    $r = me&Re,p,c;
                    me&Ring,r;
                    if (c.wantsleep) {
                        if (!rc&b) {
                            #  || !rc&b.y.Display
                            ~nohisttosleep
                        }
                        else {
                            rs&sleeping = 'wanted';
                            if (1) {
                                # put through the rest of itself,
                                # it may have %sleeping things to do
                                delete rs&ov;
                                me&Ring,r
                            }
                            else {
                                me&Display,r;
                            }
                            #~slept: r.t, r.sc.ci, '>2 '+haks(r.sc).join(",")
                        }
                    }
                }
                catch (er) {
                    # can it sleep?
                    $b = rc&b;
                    if (b && by&Display) {
                        # keep last display
                        # < warn shadow?
                        rs&sleeping = 'errors';
                        me&Display,r;
                    }
                    $msg = er.message || er+'';
                    $async = msg.match(/^async/);
                    # doming marked through as async?
                    #me&tsc,'explosion',null,'G';
                    #~Explo: r.t, er.message
                    $n = G&Cye,[Ac&sip,'',{s:msg,er:er}];
                    ns&now = G&time;
                    ns&A = A;
                    ns&B = Gc&B;
                    ns&p = p;
                    ns&R = r;
                    # to nearest dome with room to think about it
                    $JR = me.cbu(p,'erN');
                    $erN = JRs&erN;
                    erN.push(n);
                }
                return rs&returns || r
            };
            
            Rc&Rom(R,'munding');
            
        },'ift,D'],
        
        #c safe/pausible R,
        #  handled errors and s&N
        # a Dome, holding things to resume
        ['JRom','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '2px dotted green';
            s&br = 0.6;
            me&domesticate,R;
            
            # 1 wave matter
            $c = Rs&JRom;
            
            # 2 self, from 
            $D = G&Cye,[R.t,1,{},{}];
            $j = me.cbu(R,'JRomD');
            $b;
            if (!j) {
                $b = me&rollbs,R,'JRomD';
            }
            else {
                j = js&JRomD;
                jy&tw ||= {};
                $b = jy&tw[R.t];
                jy&tw[R.t] = D;
            }
            Rs&JRomD = D;
            
            b and Dc&b = b
            b && by&tw and Dy&tw = by&tw
            Ds&amongst = b && bs&amongst || [];
            Ds&amongst.unshift(D);
            Ds&count = (b && bs&count || 0) + 1;
            D.t = ''+Ds&count;
            
            # 3 what doing
            if ((Rs&boost||0) < 0) {
                me&tsc,'JRom-paused','paused','6';
                s&boc = '888';
                c.wantsleep = 1;
            }
            
            # 4 map matters for before/after
            # < down to the gate, know enough to know
            #   everything else (eg e does any further)
            $emto = {sN1:1s&N,sn4:4s&N};
            each kv emto {
                $har = Ds&watchar ||= {};
                har[k] = v.slice();
            }
            
            # 5 partition explosion collection
            $erN = Rs&erN = [];
            
            # 6 do innard
            $began = G&time;
            
            $r = Rc&Rom(R,'Rom',c);
            # return inner Rom from the Rc&Rom() that becomes JRom
            Rs&returns = r;
            
            # pause if slow
            $max = rs&timetopause || 0.5;
            $delta = G&time,began;
            each tn Dy&tw {
                ns&delta and delta -= ns&delta
            }
            delta > max and me&introqua,R,{boost:-1}
            Ds&delta = delta
            Ds&R = r;
            
            # 7
            # s&N
            each kv emto {
                $har = Ds&watchar ||= {};
                $was = har[k];
                $outi = [];
                $N = [];
                each in v {
                    was.includes(n) and continue
                    outi.push(i);
                    N.push(n);
                }
                !N.length and delete har[k]; continue
                # take, for nearest JRom only
                outi.reverse().map(i => v.splice(i,1));
                har[k] = N;
            }
            !hak(Ds&watchar) and delete Ds&watchar
            erN.length and Ds&erN = erN;
            
            # all but topmost should tend to sleep...
            Rc&Rom(R,'Domeds',{s:Ds&amongst,NzR:'Domed',glamp:9});
            #n $D.t  $s:D,R %Domed
            
            # < A-ing slowly: order then consciousness
            #   for summary up the top
            Rs&down.reverse();
        },'ift,D'],
        #c Domed visually Jing R
        ['Domed','3',&acgtRs{
            $p = Ry&up;
            # p%NzR cs=[D%Domed+]
            $D = s;
            s&bo = '3px solid blue';
            s&br = 1;
            $t = me&domesticate,R;
            ts&hs = '635';
            Rs&sym = "";
            
            # 3 gauge of gauge
            # only latest or Te'd open
            if (Rs&glampi != null &&
                Rs&glampi > 0 && !Rs&Te.c) {
                $b = Rc&b;
                $sym = !b ? "-" : bs&sym || "?";
                tc&s = Rs&sym = sym;
                return
            }
            # boost<0 and delete (if Te.d)
            if ((Rs&boost||0) < 0) {
                $Di = pc&s.indexOf(D);
                Di < 0 and throw "Di"
                pc&s.splice(Di,1);
                n deleted  s:deleted %fs:6,hs:594
                return
            }
            # Te'd stops delete
            Rs&Te.c and Rs&keeper = 1; me&tsc,'keeper','k','6';
            
            # 4 items of interest
            if (Ds&watchar) {
                # As&N we noticed grow
                Rs&sym += '^'
                each kv Ds&watchar {
                    n $k  $s:v,R %NzR:Attend
                }
            }
            
            if (Ds&delta && Ds&delta > 0.04) {
                $say = G&thime,Ds&delta ;
                me&tsc,'delta',say,6
            }
            
            # errors we caught!!!
            if (Ds&erN) {
                Rs&sym += '!';
                n Errors  $s:Ds&erN,R %NzR:Error
            }
            
            $r = Ds&R;
            rs&sleeping && rs&sleeping != 'errors' and Rs&sym += 'ᛍ'
            
            Rs&sym ||= '.'
        },'ift,D'],
        
        ['Attend','4',&acgtRs{
            $Y = s;
            
            $nth = Y.t == 'n' && Y.y.cv == 0.13;
            nth && Yc&s.t == 'Pass' and Rs&nthirteen = 1
            !Rs&nthirteen and Rs&keeper = 1
            
            n Y  $self:Y %R:Cit
        },'ift,D'],

        ['Error','4',&acgtRs{
            #Rs&rowish = 1;
            $skull = '☠';
            me&tsc,'error',skull,'D';
            me&tsc,'message',sc&s,'d';
            n er  $self:s %R:Cit
            
        },'ift,D'],
        

        
        #c NzR, expirez
        # spread Rc&s=N[n+] to many rc&s=n
        #  they have a type that helps NzR or the thing above it
        #  do expirez
        ['NzR','4',&acgtRs{
            Rs&dubquiet = 1;
            # trims to 30s timeframe, not %keepers
            Rs&glamp and Rs&expirez = 30
            $t = me&domesticate,R;
            Rs&NzR+'s' == R.t and Rs&qt = 1
            Rs&qt and t.c.not = 1
            
            $p = Ry&up;
            $outi = [];
            each iY s {
                $t = Y.y == Y ? Yc&sip : Y.t;
                $z =
                n $t  $s:Y,R
                z.sc[Rs&NzR] = 1;
                # inners like a log tail
                Rs&glamp and zs&glampi = i;
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
            
            !z and ts&fs = 7
            0 < i && !Rs&qt and Rs&rowish =  1
        },'ift,D'],
        
        # expiry of care about old A
        # < kind of time we can pause
        # R(cs=[n+]) with r(cs=n)+ self-cleaning
        ['expirez','7',&acgtRs{
            $outi = [];
            each in s {
                $r = Rs&z && Rs&z.filter(r=>rc&s==n)[0];
                !r and continue
                # are %keepers
                rs&keeper and continue
                
                # give %began
                rs&began = me&rollbs,r,'began' || G&time;
                $much = G&time,rs&began;
                
                # things time out or overpopulate
                $out = much - Rs&expirez;
                $over = Rs&glamp && i >= Rs&glamp;
                over && out < 0 and out = Rs&expirez
                out < 0 and continue
                
                # < relative scales into styles
                $C = rs&C;
                out < Rs&expirez/4 and s&fs = 8; s&sat = 0.4
                out < Rs&expirez/3 and s&fs = 6; s&sat = 0.2
                out < Rs&expirez/2 and continue
                
                $Yi = s.indexOf(n);
                Yi < 0 and me&tsc,'nofindY'
                else { outi.push(Yi) }
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
        },'ift,D'],
        
       ##c wedness do next!
    =head1
    flav
       %ting:
         a search or put, any type
         explains G&ting
         < ting both sides of it:
           (/G/Wway=/W/way)/$wcs would G&way
           (/spot/ja=/W/js)/$W would /js/
           then poll Wormhole for everything
         < get/put .4/5, highly surfable
          < unify for an area
       
       < %ball format more
         all %string hidden
         < inheritable & auto Tie/roll
         < c&s protruded
         < c % sc division
       
       the %mund is posting things around,
         including its own insides,
         see 'one big %ball, some of it grounded' ^
       
       tracks stored compilings, eg:
        /W/way/$w -> /W/Comp/$w
         or -> some collection of ways
           a g/(\w+)/(\d+) is such, looks like kv yaml
           is really lots of n $t  $s:... %of:way,%comment:...
       < bringing it back via G&ting /js/ or /way/
        < read our /W/Comp/$w_$dige.js
       
       primarily for:
        using %oph to build I
         < having Babz already done to blockquoted things
           by /wayz/, otherwise like /way/
         < including %Give deps, versions of way/W going into it
         < storage-specific metadata, see w:Writer
           could simply be in the local W:Office
           things to see changing out there to awake
       
       but also:
        translating old -> new ghosts:
          io.*, me.* into W with of:W but not W:of
           such are the new ghost objects
            as g/\w+/\d+ but with a 9,
            thence all of io is in one tidy packet,
            its source compiles out closer to you,
            its tests compile into Tests
          NutMachine probably wants conversion
            perl builds it atm,
             /js/j for acgts, etc
             using 1C&of=js instead of the n \'of:js'
       
       'specifically' for leaving 'GhoNut'
        !
        others involved:
     %Give - ghost versioning
       knowing exactly each I it ran with
       see W&Lis
     W&Lis
      magical W access syntax, via t
    =cut
    #c wensdine, be its own 4 plot
    # < provide this layout from W,
    #   any W:Mount (current Sevo-derived environ)
    #    loads up some W:Pass-like
    # these'll have any z?
    # J8 must check its Jtv for their 1s&N
        ['munding','3',&acgtRs{
            # news from the 5 year old editor
            Rc&Rom(R,'GhodigWap');
            Rc&Rom(R,'GhoNut');
            #Rc&Rom(R,'JRomnotes');
            
            
            # < /W/ReI/* as a $w space
            #   have to keep what's there indexed
            #   Ring similarly as updater or editor
            
            # making a complete A.4.I shouldn't be too far away
            
            
            # end up with typed storage, Lis action
        },'ift,D'],
        
        # 4 handlers/types are in place
        # w are from:
        #  the digway+/way/ (trad)
        #  the /w/ (unBabz'd way) (new)
        #    this dige might match the one from digway?
        #  the /wayz/ (Babz usual blockquotes)
        #    for use in We
        # use diges that don't match to roll attention at w
        # can then download the w and see its true s&dige
        
        # manage and hold for remixing the old NutMachine
        =pod
           specifically:
            generating new I:
             to get an A clearly built from scratch
              into an initial A (or is it G?)
             and know exactly how to play %Give
             is:
             < bits of StyleHut,
             < most of NutMachine,
             < NutIns - G&ting becomes:
               auto hoist R:Search@4  into /js/$Search:
                G&tingup to make Rs&_ting etc at #runtime
                without io
                needs jquery, isC and G.t for G&time/Cye/thime/c/intag
                G&ting proxies Rs&_ting
                Rs&_ting proxies G&t
             
             + io and me at #runtime
             + A:n J as me.J is
             + t that looks at me.$i, me.Ja.$w
        =cut
        ['GhoNut','3',&acgtRs{
            s&hue = 170;
            s&wi = '220%';
            s&ml = '-80%';
            s&bgh = '111';
            Rs&rowish = 1;
            # checker
            Rs&Inn = Rc&Rom(R,'Search');
            # user
            # < sums diges
            Rs&forth = Rc&Rom(R,'ForThe');
            
            # remix 
            Rc&Rom(R,'ChangeInto');
            
            # sidechaining also ju compiles,
            #   A:u testing how we J-J mix I
            n A4smind  $self:A.4.sc.mind %R:Cit
            $f = A.5[4];
            n A54er  $self:f %R:Cit
            n A545er  $self:f.5 %R:Cit
            
        },'ift,D'],
        ['ChangeInto','3',&acgtRs{
            #  knowing the ForThe
            # < slep into:
            # open to check workings
        },'ift,D'],
        # make a bunch of %tings!
        ['ForThe','3',&acgtRs{
            # source
            n Stylehut  R %ting:W,directory:spot/je/
            n NutMachine  R %ting:W,directory:spot/ju/
            n Foogla  R %ting:w
            # random
            n Pass  R %ting:W
            
            # destination
            #  for /way/
            #   to start Rs&_ting from an eval
            n Rew/ChangeInto  R %ting:W,directory:Rejs/
            #  for /js/ that must hack up a bit
            #   sweep eye into i
            n Rejs/ChangeInto  R %ting:W,directory:Rew/
            # < get that done now, to 6
            #S /@6
        },'ift,D'],
        # for a bunch of %tings
        ['ForThe','4',&acgtRs{
            $N = me&ioty,R,'%ting' .map(n => ns&Q);
            # like G&ting,of,t
            # < usable from, is a known interface
            Rs&tin = &st{
                each in N {
                    nc&of == s && n.t == t and return nc&s
                }
            };
            # like A 8, returning a .5 (things depended)
            Rs&eight = &{
                $C = G&Cye,[R.t,''];
                each in N {
                    i $C/#nc&of/#$n:s
                    yas&dige = ns&dige
                }
            };
        },'ift,D'],
        
        #c ting for Composite of other tings
        # Merge.js etc
        
        # push/pull of C living across the boundary
        #  the question should roll+clone
        #    to transact by the dependent process?!
        ['ball+tightly','3',&acgtRs{
            #Rc&dl = Rc&d+1;
            ac(R,'inheritsc','tightly');
            
            $p = Ry&up;
            ps&ting && ps&species and Rs&tightly = ps&species
            
            # if they s&W (%sc may be talking about sc)
            $onW = Rs&tightly == 4 && ss&sc.includes('W')
                || Rs&tightly == 5 && ss&W;
            # ting it!
            onW && me&rolltog,R,'W?',0 &&
                n $s.t  R %ting:2
        },'ift,D'],
        ['ting','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dubquiet = 1;
            $p = Ry&up;
            $t = null;
            $inheritp = &p{
                Rs&ting = ps&ting;
                t = p.t;
                ps&directory and Rs&directory = ps&directory
            };
            Rs&ting == '1' and inheritp(p)
            elsif (Rs&ting == '2') {
                # after a cloud of balls pointing to
                # another $W in the same place
                $ti = me.cbu(p,'ting');
                !ti and throw "noting2"
                inheritp(ti);
                t = R.t;
            }
            !Rs&ting and throw "!%ting";
            t ||= R.t;
            Rs&directory and t = Rs&directory+t;
            
            $what = Rs&ting;
            if (Rs&species) {
                # the .5 instead of .1
                what += '.'+Rs&species;
                t += '/'+Rs&species;
            }
            me&tsc,'%ting-of',what .sc.fs = 11
            
            $r = me.cbu(R,'Inn');
            $r = r && rs&Inn;
            !r and throw "no way Inn"
            
            me&rollbs,R,'Q';
            $C = Rs&Q ||= G&Cye,[t,'',{of:Rs&ting}];
            c&async = &{};
            # c&canwait = 1;
            c&ready = &CP{};
            $s = Rs&Live = rs&_ting(C);
            
            n Q  $self:C,R %Cit,ot
            if (s) {
                n Live  $self:s,R %Cit,ot
                $ti = t.indexOf(s.t);
                Rs&directory = t.slice(0,ti);
            }
            
            c&el and me&tsc,'elvis',c&el .y.cv = 0.8
            !s&ready and me&tsc,'!ready','...' .y.cv = 0.8
            
            # more tinging as a subspecies for the same thing
            
            me&rolltog,R,'toball',0 &&
                n Live  $s:s,R %ball,tightly,refpool
            if (!Rs&species) {
                me&rolltog,R,'/4',0 &&
                    n Hive  R %ting,species:4
                me&rolltog,R,'/5',0 &&
                    n Give  R %ting,species:5
            }
        },'ift,D'],
        
        # see up
        ['JRomnotes','4',&acgtRs{
            $N = me.cby(R).filter(n => ns&JRomD);
            n Woth  $self:N,R %Reis:Cit%
        },'ift,D'],
        
        
    ] };
    #c ting gets domethings
    
    # G&c but harvested by Tool
    #  as coming from this R, in/out of time,
    #   talking about other R, to make acts shimmer
    #  available as verbosity, debug points
    #  muted when recognised
    # < io-param-like + styles of message with object in
    me.chatter = &acgttl{
        l.constructor != Array and throw "send array"
        each in l {
            l[i] = '>'+(3+(i*2))+':l'+i+' '+(n||'')
        }
        return G&c:'>1 '+t,l
    };
    
    # Guxily for thing, got via stately e
    #  W it pulls in may clue changes to other W
    #  per remote place, which may already have its catalogue here
    me.Tingingness = &acgtR{ return [
        # the centralising of stuff going in!
        # for using thing = $of/$t on an ongoing basis
        #  gets I.$of.$t
        #  some $of (W/w/js) may network, contain more I
        # usually 
        #   is $t still $dige?
        #   its $dige, here: $s
        # we may get an el/lv/anything-known about things that change
        # the set of Questions you have:
        #   looks like Writer's .5 deps: $type/$name%details
        ['sleeping+Search','4',&acgtRs{
            $b = Rc&b;
            Rs&_ting = bs&_ting;
        },'ift,D'],
        ['Search','4',&acgtRs{
            # an h call muddies T
            $Gtime = &d{ return G&time,d };
            # similar!
            $ch = &tl{ return me&chatter,t,l||[] };
            
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            me&introqua,[R,'Ghost'],{boost:-1},'@1';
            n Ghost  $s:Ghost,R %ball,childy
            
            # of/t=$P
            i $Ghost/In
            # of/t=$P in motion
            i $Ghost/Pulling
            
            
            $Pio = Rs&Pio = {};
            Pio.what = &tP{
                o $Ghost/#$t/#Pc&of/#$P:s
                return ya
            };
            Pio.not = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
            };
            Pio.is = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
                i $Ghost/#$t/#Pc&of/$P:s
            };
            
            #c _ting - a many arg'd entrypoint
            #  ting becomes the reduce for io's map
            # 
            Rs&_ting = &stz{
                # Question - may come with ...
                $C = isC(s) ? s : G&Cye,[t,1,{of:s}];
                
                # the G.t variety?
                # if !found of a Talky of:
                
                # C in the field, P in the store
                $P = Pio.what('In',C);
                if (!P) {
                    P = G&Cye,[C.t,1,{of:c&of},{}];
                    Pio.is('In',P);
                    Ps&Want_Check = 1;
                }
                # validate cache
                Ps&now && Gtime(Ps&now) > 5 and Ps&Want_Check = 1
                s&P && s&P != P and s&oP = delete s&P
                
                # in/out of time bit, lost in the store
                $ok = Rs&Pull_a(C,P);
                
                # don't wait for the async check
                # Pc&s only null if never found,
                #  or new string is got but not decoded
                !ok && Pc&s && !c&canwait and ok = 1
                
                if (!ok) {
                    # go async
                    s&ready = 0;
                    # after, c&ready() climbs back to C time
                    c&ready and ac(P,'readyingC',C)
                    c&async and c&async()
                    else {
                        G&TuneTimeMachine,c&of+':'+C.t
                    }
                }
                else {
                    # C is, Pc&s == null must be intentional
                    s&ready = 1;
                    
                    # C <dige> P, may surprise
                    # el=1/8 basically
                    c&el = Pc&el;
                    if (!c&el || c&el == 1) {
                        c&el = s&dige != Ps&dige ? (s&dige ? 2 : 1)
                            : 8
                    }
                    c&el && Py&decidedel && Py&decidedel(c&el);
                    
                    s&dige = Ps&dige;
                    c&s = Pc&s;
                    # C never gets s&string unless it makes it

                    # keeps Pc&s while update is looked for
                    Pc&s && Ps&Pulling_since && c&canwait and ~waitscan
                    else
                    Pc&s and return Pc&s
                }
            };
            #c Pull_a
            
            Rs&Pulling_already = &P{
                $ya = Pio.what('Pulling',P);
                # don't trust stagnant Pulling
                if (ya && Gtime(yas&Pulling_since) > 5) {
                    ya = Pio.not('Pulling',P);
                }
                # don't shunt Pull_a from outside its own callbacks
                #  which will have ensured they don't reoccur
                ya and ch('dupreq',[Cc&of,C.t]); return
                return ya
            };
            
            # shunt P - can progress out of time
            # then returns 1 and/or calls c&ready
            Rs&Pull_a = &CP{
                # < make s&string mean write string, our thing in c&s
                if (Ps&Want_Check || s&string) {
                    # waiting on P
                    Rs&Pulling_already(P) and return
                    
                    # become Pulling
                    Ps&Pulling_since ||= Gtime();
                    Pio.is('Pulling',P);
                    $T = Pc&T = {};
                    
                    # shunts Pull_a when ready
                    T.cb_gen = &CP{
                        delete Ps&Want_Check;
                        Rs&Pull_a(C,P);
                    };
                    # sends
                    Rs&Pull_Check(T,C,P);
                }
                $T = Pc&T;
                !T and throw "unstarted P"
                !T.ok and return
                
                #s&wantdecode and Ps&Want_Decode = 1
                # < modes of decode: dl/Xpath, allowing yaml code
                Ps&Want_Decode and Rs&Pull_Decode(T,C,P)
                
                !T.ok and return
                delete Ps&Want_Decode;
                
                # < way getting args/wrapping/eval as Pull_Transcode?
                #   it's ting's business if things want to share
                
                Pio.not('Pulling',P);
                delete Ps&Pulling_since;
                # pulling done re. $Ghost, but not $C
                #!Pc&s and throw "no ting Pcs: "+Pc&of+'/'+P.t
                
                s&P = P;
                Py&decidedel = &n{ T.tcp.set('l3',n) };
                
                each iC Ps&readyingC {
                    # P completed async, get back to C time
                    #   no longer awaiting yon return 1
                    c&ready and c&ready(C,P)
                }
                delete Ps&readyingC;
                
                return 1
            };
            #c PullCheck
            Rs&Pull_Check = &TCP{
                T.waits and throw "PullCheck while waits"
                T.ok = 0;
                # they may have their own ways to use dige/v, p/P/s&P
                # Pc&get how to ask,
                # Pc&got loads response into P
                $Do = Rs&Talks[c&of];
                !Do and throw "!Talk "+c&of
                T.get = {};
                T.get.data = {};
                Do(T,C,P);
                !T.get.url || !T.got and throw "!Talk handlers "+c&of
                
                T.cb = &sc{
                    T.aft_waits = Gtime();
                    # every pulling happened now
                    Ps&now = Gtime();
                    # specific stuff moves from the response to P and Pc&s
                    #  can !T.ok...
                    T.got(P,s,c);
                    # out of time plumb
                    # may be stolen by got if more requests (/js)
                    T.ok = 1;
                    T.cb_gen and T.cb_gen(C,P)
                };
                Rs&TCP(T,C,P);
            };
            # rebuild tcp
            # < https://javascript.info/xmlhttprequest
            # < have A, so async in handler gets retried
            #    (or G&way noop deps just before handling)
            # < get or ws
            # retry, expire
            # uses T.get -> T.cb()
            Rs&TCP = &TCP{
                $tcp = T.tcp = ch("tcp",[T.get.url,'.','.','.','']);
                
                $done = &s,how,c{
                    !T.waits and return
                    T.waited = Gtime(T.waits);
                    delete T.waits;
                    tcp.set('l1',G&thime,T.waited );
                    r.status != '200' and return T.status = r.status
                    T.cb(s,c);
                };
                
                $r = T.r = $.ajax(T.get).done(done);
                T.waits = Gtime();
                
            };
            Rs&Pull_Decode = &TCP{
                T.ok = 0;
                $type = Ps&Want_Decode;
                $de = ch('decode',[P.t,type,'','']);
                # Pc&el becomes interesting to the Client,
                #   2-3 were our will carried out
                #   6-7 to merge
                # < C may want a new set for itself, to make a mess
                #   while we are in the clone factory
                #   faster to separate with io than many readLines?
                #   but how much safer?
                
                $s = null;
                try {
                    if (type == 'Lines') {
                        !Ps&string and throw "P!%string"
                        $N = G&readLines,Ps&string;
                        N.length != 1 and throw "Weird tW lines", s
                        s = N[0];
                    }
                    elsif (type == 'way') {
                        $w = G&Cye,[C.t,1];
                        wc&s = Ps&string;
                        ws&of = 'w';
                        # dige is for s before compiled
                        ws&dige = Ps&dige;
                        s = w;
                    }
                    elsif (type == 'js') {
                        s = Pc&s;
                        Rs&Decode.js(s);
                    }
                    else {
                        throw "Decode type "+type
                    }
                    s.y.P = P;
                    Pc&s = s;
                }
                catch (er) {
                    T.er = er;
                    de.set('l2','Error!');
                    de.set('l3',er);
                }
                Pc&s = s;
                s && !T.er and T.ok = 1
                
                if (T.ok && T.aft_waits) {
                    T.aft_waited = Gtime(T.aft_waits);
                    delete T.aft_waits;
                    $tcp = T.tcp;
                    tcp.set('l2',G&thime,T.aft_waited );
                }
            };
            
        
            #c Talks w/js/W to server
            Rs&Talks = {};
            Rs&Decode = {};
            Rs&Talks.w = &TCP{
                # < Babz mode: none, normal, BQ-inclusive
                T.get.url = '/way/'+C.t;
                Ps&dige and T.get.data.have = Ps&dige
                T.got = &Psc{
                    $dige = c.getResponseHeader('Dige');
                    !s && Ps&dige == dige and s = Ps&string
                    if (s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = dige;
                        Ps&string = s;
                        Ps&Want_Decode = 'way';
                    }
                };
            };
            #c Talks.js
            Rs&Talks.js = &TCP{
                # I in a .js script (+ a little about the 9)
                # first request: only to find the dige,
                # then we can write a unique <script src=toit>
                # < if we know what version don't do this first request
                # T would put this c&dige to wind back from bugs
                # hazardily shared P having the branch reset,
                #   put the -$dige in C.t already to have a specific P be there
                T.get.url = '/js/'+C.t+'-'+(c&dige||'head');
                # < if c&v forced/trusted (via Wover),
                #   use the exact url to add_script
                # < does the rewritten Location mean the second XHR caches?
                $cb_gen = delete T.cb_gen;
                T.got = &Psc{
                    $src = c.getResponseHeader('Location');
                    $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                    $W = Pc&s = G&Cye,[m[1],1];
                    Ws&I = {};
                    Ws&dige = Ps&dige = m[2];
                    # /js/ 
                    # nest callback
                    T.ok = 0;
                    T.waits = Gtime();
                    $callback = &s,e{
                        T.waited_script = Gtime(T.waits);
                        T.ok = 1;
                        Ps&script = s;
                        Ps&Want_Decode = 'js';
                        cb_gen(C,P);
                    };
                    Rs&add_script(src,callback);
                };
            };
            # implant code as .js
            #  should be able to receive any ting,
            #  esp way, is more stack/debugger findable loaded like so:
            Rs&add_script = &src,cb{
                $have = $('body script[src="'+src+'"]');
                have.length and return cb(have[0])
                $s = document.createElement('script');
                s.setAttribute('src', src);
                s.setAttribute('type', 'text/javascript');
                cb and s.onload = &e{ cb(s,e) };
                document.body.appendChild(s);
                return s
            };
            Rs&Decode.js = &W{
                $tocfunc = W.t+'_'+Ws&dige;
                !window[tocfunc] and throw "Notocfunc: "+tocfunc;
                $toc = window[tocfunc]();
                $D;
                each iv toc {
                    $ind = v[0];
                    $C = G&Cye,[v[1],v[2],v[3],v[4]];
                    if (ind == '') {
                        D = Ws&I[C.t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        # grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t, v
                    }
                }
            }
            #c Talks.W
            Rs&Talks.W = &TCP{
                T.get.url = '/W/'+C.t;
                $d = T.get.data = {};
                # clue them to Hobs for it we have around
                # the current HEAD:
                Ps&dige and d.have = Ps&dige
                # the first "can you hold on to..."
                if (s&string != null) {
                    # wants to write, '' to delete
                    T.get.type = 'post';
                    d.s = s&string;
                    if (d.s.length && d.s == Ps&string) {
                        # keep expecting it
                        !d.have and throw "sleeping write !Psdige"
                        delete d.s;
                    }
                    # < get the average size of codes down,
                    #   mix them locally (A:u)
                    c&patch and throw "< patches"
                    # continuity check, also for deletes
                    # < d.parent=null means it should be new
                    s&P and d.parent = s&P.sc.dige;
                }
                T.got = &Psc{
                    $r = dej(s);
                    # dige find things we d.have
                    if (r.dige && r.s == null) {
                        r.dige == Ps&dige and r.s = Ps&string
                        else
                        s&string && r.dige == dig(s&string) and r.s = s&string
                        r.s == null and throw "get/W implied we know", r, P
                    }
                    $el;
                    r.ok == 'found' and el = 1
                    r.ok == 'created' and el = 2
                    r.ok == 'updated' and el = 3
                    # 6 is 3 from beyond 5! matters
                    r.ok == 'forward' and el = 6
                    r.er == 'not ffwd' and el = 7
                    r.ok == 'deleted' and el = 9; Ps&departs = Ps&dige
                    r.er == 'not found' and el = 9
                    Pc&el = el;
                    if (el == 9) {
                        # watch for undelete?
                        r.s and throw "what"
                        delete Pc&s;
                        delete Ps&dige;
                        delete Ps&string;
                        # plumb? like an elvisory
                        return
                    }
                    if (el == 7) {
                        # notify push failed?
                        c&rebase and c&rebase(P,r)
                        else {
                            throw "not ffwd: "+C.t, r
                        }
                    }
                    !el and throw "tW er", r.er, P, r
                    if (r.s && r.s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = r.dige;
                        Ps&string = r.s;
                        Ps&Want_Decode = 'Lines';
                    }
                };
            };
         
            
            #c way/js questions as C
            # public interfaces
            # shows how to plug their async gear into ting's
            # the wandering part of G&way
            Rs&quest_w = &acgttry{
                $ar = r;
                $cb = y;
                $Q = G&Cye,[t,'',{of:'w'}];
                Qc&ready = &{
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                    # so wait for it...
                    !cb and return
                    if (G&arfgunc,cb == "s") {
                        # way randomly happens, give return value to cb
                        # without A lining up around it (it may do so itself)
                        # see G&waylay for use case as delayed call
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the context revisted?
                        cb(t,ar,w);
                    }
                };
                Qc&async = &{
                    cb == 'noop' and cb = &{}
                    else
                    typeof cb == 'string' and throw "Cant go async: "+cb

                    # Jin should avoid this A for a while
                    a&ready = 0;
                    # and throw/abort if no callback
                    !cb and G&TuneTimeMachine,'w:'+t
                };
                $w = Rs&_ting,Q;
                return w
            };

            Rs&quest_js = &acgtt{
                $Q = G&Cye,[t,'',{of:'js'}];
                Qc&ready = &{
                    A.cv = 0.4;
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                };
                Qc&async = &{
                    a&ready = 0;
                    4s&N.push(A);
                    T.not = 1;
                };
                $W = Rs&_ting,Q;
                #a&I = Ws&I;
                #a&v = Ws&v;
                return W
            };

         
        },'ift,D'],
        
    ] };

    #c %mundws holds an A:ws
    me.rolltog = &acgtRkdy{
        # y(s) assigns
        y ||= &{};
        $n =
        n $k  s:● %fs:22,medo:modeen,togla

        me&rollbs,R,k,d;
        !R.sc[k] and ns&fs = 11
        # < merge to Tool's
        Rs&modeen = &acgtr{
            T.wake = 1;
            if (rs&togla) {
                $v = R.sc[r.t] = R.sc[r.t] ? 0 : 1;
                y (v)
            }
            else {
                throw "What? "+r.t
            }
        };
        y (R.sc[k]);
        me.cbuac(R,'unDoming',&{ y (0); });
        return R.sc[k]
    }
    me.Socketingness = &acgtR{ return [
        # < push/pull of C living across the boundary
        ['mundws','3',&acgtRs{
            Rs&rowish = 1;
            # < these ways to assume arguments want fibre
            $ws = me&rollbs,R,'Sock',1;
        },'ift,D'],
        
        # at LVing avail
        ['mundws','4',&acgtRs{
            Rs&rowish = 1;
            
            # current state
            $ws = Rs&Sock;
            
            # /path
            me&tsc,'mundws','ws:','b';
            me&tsc,'path',R.t
            me&tsc,'state',ws.state,'6';
            
            # %Again
            $z = Rs&Opinion && Rs&Opinion.sc.z;
            $len = z && z.length;
            z and me&tsc,'Opinion.length','('+len+')';
            
            Rs&Lving &&
            n Lving  $self:Rs&Lving,R %Cit
        },'ift,D'],
        #c GhodigWap news from the 5 year old editor
        # one aspect of news about $ways, from g/\w+/\d+
        ['GhodigWap','3',&acgtRs{
            # replaces J:digwaypoll
            me&rolltog,R,'nodigway',1,&s{4c&nodigway=s};
            
            
            # $w as heard about, seekended and living (Iw)
            me&introqua,[R,'ifd','Ghost','apparently'],{boost:-1},'@1';
            me&introqua,[R,'ifd','Ghost','est'],{boost:-1},'@1';
            me&introqua,[R,'wats'],{boost:-1},'@1';
            
            # w can be trusted if listened for in digwaypoll
            # digwaypoll in/out only t + dige
            #  dige may vary in length > 6
            #  dige in merely allows Opinion to sleep
            #   when it comes out, which we could imply:
            #   < Lc&* for server's agreement with said diges
            #     they say what send() they agree up to,
            #      and we synthesize eouts to mean it
            n digwaypoll  R %mundws,Ghocoline,tinyscLines:dige,mightsctrunc:dige
            
            n ifd  R %Ghostway
            # < ^ having its own compile,
            #   your ting w/* perspective may incorporate it
            #   then another ing happens?
            
            # G&way compiled:
            n wats  $s:A.5.I.w,R %Idoubleyou,ball,childy:tw
            
        },'ift,D'],
        #c Ghostway - asks for way notifies, gets them
        # provides ein/out/ope
        #   by way of %Again/%tinyscLines
        #   for C sloshing in or out
        # knows how to talk ws:s/digwaypoll
        ['Ghostway','33',&acgtRs{
            $p = Ry&up;
            # place to talk
            $S = Rs&Upstream = ps&z[ps&z.indexOf(R)-1];
            $ch = Rs&chatter = Ss&chatter;
            # insured memories via %Again
            $g = Ss&Again = ps&z[ps&z.indexOf(R)+1];
            $Way = gc&s;
            
            # the 'here', a join
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            n Ghost  $s:Ghost,R %ball,childy
            
            # pile from both ends over time
            i s:{ Ss&Opinion=C } $Ghost/apparently:s
            # and changes go further
            i s:{ Ss&Further=C } $Ghost/seek:s
            
            # on change, queue:
            Ss&do_Further = &{
                # /apparently/* changing creates /seek/*
                # to look it up since that dige changed
                o $Ghost/seek/*
                $seeking = ays&s;
                !seeking and return
                Rs&seeking = seeking.slice();
                each is seeking {
                    o $Way/#$s
                    !ya and ch("didnt know",[s.t])
                    Rs&seeketh(s,ya)
                }
                return
            };
            
            # < ting many asks per question
            #   so many seekeths make one seekend
            #   is a keepalive for the first question
            Rs&seeketh = &s,was{
                ch("seeking...",[s.t]);
                #$w = G&ting,'w',s.t;
                #   currently takes old-G&t shortcut,
                #    returns way without checking ttl
                $cb = &t,ar,w{
                    Rs&seekend(w,s,was);
                };
                # noop='nottl' so it renews
                G&way,s.t,{},cb,'nottl';
            };
            
            # thing is got
            Rs&seekend = &w,s,was{
                Ss&sleep_Further &&
                    Ss&sleep_Further(w,s);
                
                $com = [w.t];
                !was and com.push("@1")
                else
                if (wass&dige == ws&dige) {
                    return ch("Seeksame",[w.t])
                }
                ch("Seekback",com);
                # while changing!!
                i $Ghost/ing/$w
                # once after the batch (ish)
                $si = Rs&seeking.indexOf(s);
                si >= 0 and Rs&seeking.slice(si,1);
                # wait up to 30ms if more might seekend
                $delay = Rs&seeking.length ? 30 : 0;
                # joining seekends near in time
                $cb = me&sccb,R,'seekingdone',Rs&do_ing;
                delay ? G&yl,delay,cb
                    : cb();
            };
            
            #c 7 thing is fine, either way
            Ss&sleep_Further = &ws{
                if (!w) {
                    # from eout that sleeps
                    o $Way/#$s
                    w = ya;
                    !w and return ch("didn't know sleeping",[s.t])
                }
                # Iw has $w, make permanent!
                ws&now = G&time + 3600;

                i $Ghost/seek/-#$s
                # < should know time is up for this ground,
                #   get it attached via Tsome
                #n seen  $self:w %Cit
                # permanent
                i $Ghost/est/$w
            };
            
            Rs&do_ing = &{
                # things changing, code to redo!
                o $Ghost/ing/*
                $inging = ays&s;
                # < otherwise G&ting evals?
                $doers = 'Soogle Packle Coffle Foogla'.split(' ');
                $doerd = [];
                each iw inging {
                    if (doers.indexOf(w.t) >= 0) {
                        # me.codes containers should run
                        ch("Ghostwayer",[w.t]);
                        G&way,w.t;
                        doerd.push(w);
                    }
                    else {
                        ch("Ghostway",['',w.t]);
                    }
                    i $Ghost/ing/-$w
                    # then anything dependent on the way
                    #  eg I, J...
                    #  diff way to wake a .Ja. is not impossible
                }
                # for $w that generate $me which generate I,
                #   drop Ring's cache of me I
                $dropcache = doerd.length && 1;
                
                Rs&do_permanence(dropcache);
            };
            
            Rs&do_permanence = &dropcache,{
                # keep permanent
                # the only in-time operation
                # < scan for not in Iw
                # < dige sleep on init may not get things here:
                o $Ghost/est/*
                each iw ays&s {
                    ws&now = G&time + 3600;
                    if (dropcache) {
                        delete ws&makesI;
                        delete ws&makesIw;
                    }
                }
            }
            
            # keepalive
            Rs&do_permanence();
            # casual shunt, in case e loses its will to carry it out
            Ss&do_Further() || Rs&do_ing();
        },'ift,D'],
        
        #c %Again (C/%ball source) -> %ein()
        # e inits some state (usually)!
        ['Again','35',&acgtRs{
            !Rs&Again.sc.ball and throw "Again!ball"
            Rs&Lvact = &{
                $N = me&ioty,Rs&Again,'%ball';
                each in N {
                    N.indexOf(n) < i and ~DupeyzLvact: n.t
                    Rs&ein(n)
                }
            };
            # el=2 everything
            Rs&eope = &{ Rs&Lvact() };
            # el=2 changing
            Rs&Lving and Rs&Lvact()
            
        },'ift,D'],
        # %ein() C only t and certain sc
        # %eout() C into %Opinion
        #   and into %Further if certain sc change
        ['tinyscLines','32',&acgtRs{
            # Lving: may not make it through send() if same
            Rs&uniqsend = 1;
            # a t/dige only variety of tinyLines encoding:
            Rs&tinyLines = 1;
            
            # only certain sc taken
            $only = Rs&tinyscLines;
            only = only && only != '1' && only.split(',')
            Rs&takeonlysc = &s{
                !only and return ex({},s.sc)
                $sc = {};
                each ik only {
                    s.sc[k] == null and continue
                    sc[k] = s.sc[k]
                }
                return sc
            };
            
            # their Opinion arriving
            Rs&hasonlysc = &sl{
                $ks = only || haks(s.sc);
                $ok = 1;
                # checks how different it is
                each ik ks {
                    $was = s.sc[k];
                    $is = l.sc[k];
                    $com = [l.t, k, was, '->', is];
                    !is and ch('nullsc',com); return -1
                    
                    was != is and ok = 0
                    
                    if (!ok && Rs&mightsctrunc == k && was
                        && was.length > 6 && is.length > 6) {
                        ok = was.includes(is) || is.includes(was)
                    }
                    !ok && was and ch('scut',com)
                }
                # applies!
                each kv l.sc {
                    s.sc[k] = v
                }
                return ok
            };
            
            $ch = Rs&chatter;
            Rs&ein = &n{
                !ns&ball and throw "!ball: "+ki(n)
                $c = {}; # L%send[D.sc
                $s = nc&s;
                $C = G&Cye,[s.t,1,{},Rs&takeonlysc(s)];
                # Opinion is one piled from both ends
                #   so it can come back same the first time
                i Rs&Opinion/-#$C
                i Rs&Opinion/$C
                c.toLines = C.t;
                if (haks(C.sc).length) {
                    c.toLines += '%'+G&depeel,C.sc
                }
                Rs&send(n,c);
            };
            Rs&eout = &l{
                !Rs&Opinion and throw "give Opinion"
                !Rs&Further and throw "give Further"
                
                # their opinion is arriving
                i Rs&Opinion/#$l:s
                $ok = Rs&hasonlysc(ya,l);
                ok < 0 and 'said error'
                elsif (ok) {
                    ch('sleep',['way',l.t]);
                    Rs&sleep_Further &&
                        Rs&sleep_Further(null,l)
                }
                else {
                    # changes go %Further once per receive
                    ch((!ya?'new':'wake'),['way',l.t])
                    i Rs&Further/$ya
                    Rs&do_Further &&
                        ac(R,'Finally',Rs&do_Further)
                }
            };
        },'ift,D'],
        #c Ghocoline - C<->string envelope
        # provides %receive(), wraps %send()
        #   en/decoding some string format
        # Lving @31 logs a %send/receive[D+]
        # see 'Lving' around here, it may also:
        # < Ls&z clone C we sent them?
        #     would allow better %resumable
        #     %uniqsend dedupes for now
        # the @34 do push/pull C across a boundary stuff
        # the @32 is C<->string:
        # all Lines =~ /^[ \w"]/
        #  so there's room for some protocol in there:
        # < Lc&resumable - do you remember? rolls state:
        #   - roll Ls&send if %uniqsend, dedupes
        #   - know Ls&z and lv-sense to your app
        #   app must sleep while we try to:
        #   negotiate what they know with el=7
        #     might know our/previous Ls&sent_dige
        #       retransmit Ls&send
        #     or stuff on the ground
        #       exploratory W nature,
        #       eg check state of everything in Toys:
        #         Toys el:7%dige:358i0f
        #       may not include %dige on request,
        #         but then the server could pre-empt our:
        #           what has what become,
        #            and what can be patched
        # Lc&responsey - expect one receive per send
        #   link them, ordering if many backends
        #   responses not in requested order
        #   < slowing/Aing out time to understand message
        ['Ghocoline','32',&acgtRs{
            Rs&receive = &sD{
                typeof s != 'string' and throw "receive !string"
                $ch = Rs&chatter;
                ch and ch('receive',[ki(s,3)])
                
                Rs&tinyLines and Rs&someLines ||= 1
                Rs&someLines and Rs&contLines ||= 1
                
                if (Rs&contLines) {
                    # can know how to nest another protocol
                    if (!s.match(/[ \w"]/)) {
                        # tricks with Lving"
                        throw "strange"
                    }
                    elsif (s.match(/^ /)) {
                        # Lving -> last message's cursor
                        throw "floating start"
                    }
                }
                
                # string tricks
                # decoded N everything becomes M ways in
                $l = [s];
                if (Rs&someLines) {
                    # splits lines, batch of something
                    # < by next Line d=0?
                    l = s.split("\n");
                    l.slice(-1)[0] == '' and l.pop()
                }
                
                # parsed
                $z = l.slice();
                if (Rs&tinyLines) {
                    # parse Ghost%dige:4827848
                    each is l {
                        $s = s.split('%');
                        s [0].split("\t").length > 1 and throw "comp"
                        z[i] = G&Cye,[s[0],'',{},s[1]]
                    }
                }
                elsif (Rs&contLines) {
                    throw "readLines wanted"
                    # make R to deLines then ein?
                    #$N = me&readLines,s;
                }
                
                # iterated
                Rs&esout and Rs&esout(z)
                else
                Rs&eout and z.map(s => Rs&eout(s,z))
                
                $Fin = delete Rs&Finally;
                Fin && Fin.map(cb=>cb());
            };
            #c send!!
            $send = Rs&send;
            !send and throw "no Ghocoline proxy send()"
            Rs&send = &sc{
                $string = s;
                # the Lving%send/$D .sc
                c ||= {};
                typeof s == 'string' and 'ok'
                else
                !isC(s) and throw "obj->string"
                else
                s.y.R != s and throw "send C !R"
                else
                if (ss&ball && ss&toLines || c.toLines) {
                    string = c.toLines || ss&toLines;
                    c.origin = s;
                    $L = Rs&Lving;
                    # < Lving: repeat string/diff/compression
                    #   smelting toLines' intel,
                    #   what to do with lots of el:8 etc.
                    if (Rs&uniqsend && Ls&send) {
                        $i = Ls&send.length-1;
                        while (Ls&send[i]) {
                            $D = Ls&send[i--];
                            !Ds&origin and continue
                            if (Ds&origin != s) {
                                # by .t?
                                Ds&origin.t != s.t and continue
                            }
                            Dc&s == string and return
                        }
                    }
                }
                else
                ss&ball and throw "send R%ball!%toLines"
                else {
                    throw "send R!%ball"
                }
                
                $ch = Rs&chatter;
                ch and ch('send',[ki(string,3)])
                send(string,c);
            };
            Rs&open = &{
                $L = Rs&Lving;
                L && Lc&b && Lc&resumable and 'Lvism el=7 for %sent_dige'
                Rs&eope and Rs&eope()
            };
        },'ift,D'],
        #c A%Sock <-> A:ws!
        # at both ends of the deal
        # provides Rs&Lving and Rs&send()
        # uses Rs&open() and Rs&receive()
        ['Sock','31',&acgtRs{
            $ws = Rs&Sock;
            if (ws == 1) {
                $url = 'ws://'+location.host+'/'+R.t;
                ws = Rs&Sock = new WebSocket(url);
                ws.url = url;
            }
            
            # when R el=9
            me.cbuac(R,'unDoming',&{
                ws.close(1000,'lum')
            });
            $X = window.websocks ||= {};
            X[ws.url] = ws;
            $sockdup = &{
                X[ws.url] == ws and return
                ws.close(1000,'dup');
                return 1
            };
            
            # our A:ws.c hooks
            # this should A:session
            #   reflecting a scene across it
            #   they might hold objects for us,
            #     as we talk to them
            #   or show objects we talk about
            $L = me&rollbs,R,'Lving';
            
            # try leak chatter!!!!!!
            $ch = Rs&chatter = &t,ev{
                # < io-param-like + styles of message with object in
                $l = ev.constructor == Array ?
                    [R.t, ... ev] :
                    [R.t,
                    ws.deter('code',ev.code),
                    ev.reason,
                ];
                each in l {
                    l[i] = '>'+(3+(i*2))+' '+(n||'')
                }
                G&c:'>1 '+t,l
            };
            
            # L logs a %send/receive[D+]
            $roll = &tsoc{
                $L = Rs&Lving;
                !L and throw "ws:L:send!open"
                
                # accumulating dige
                $digek = t+'_dige';
                L.sc[digek] = dig((L.sc[digek]||'')+s);
                
                # point in time log
                c ||= {};
                c.now = G&time;
                # opposite direction's count
                # last in when this went out, etc.
                1 && o and c[o] = L.sc[o+"_i"]
                # tsc causes n ... deep within out of time
                $D = me&tsc,t,s,c;
                ac(L,t, D );
                
                # count
                $ik = t+'_i';
                L.sc[ik] ||= 0;
                L.sc[ik]++;
                
                return D
            };
            
            # open/close/explode
            ws.onopen = &ev,{
                ch('open', ev);
                L = me&rollbsc,R,'Lving','b,increment';
                Rs&open();
            };
            ws.onclose = &ev,{
              ch(ev.wasClean ? 'closing' : 'close', ev);
              ws.deter('code',ev.code) != 'bad' and return
              # will re-new when R wakes
              delete Rs&Sock
            };
            ws.onerror = &ev,{
              ch(ev.wasClean ? 'err' : 'errs', ev)
            };
            
            # send/receive
            Rs&send = &sc{
                $D = roll('send',s,'receive',c);
                # never fails?
                ws.send(s);
                return D
            };
            ws.onmessage = &ev,{
                sockdup() and return
                $s = ev.data;
                $D = roll('receive',s,'send');
                Rs&receive(s,D);
            };
            
            # interpret the machine
            ws.proto = {
              state: {
                0:'connecting',
                1:'open',
                2:'closing',
                3:'closed',
              },
              code: {
                1000:'closing',
                1006:'bad',
                1001:'leaving',
                1009:'toobig',
                1011:'500',
              },
            };
            ws.deter = &tk{
                k == null and return ''
                return ws.proto[t][k] || t+'?'+k
            };
            ws.state = ws.deter('state',ws.readyState);
        },'ift,D'],
    ] };
    

