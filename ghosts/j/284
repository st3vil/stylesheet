Foogla: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    =head1 #prepare to A=A
    
    some goals:
    - efficiently educating on A passage of time
    - J to take < 200ms
    - not noticing anyway
    - Elvising running the shower
    - unpatch, failing, patch, passing in a few seconds
    
    =head3 future of sleep: Doming
    A starts works, D are their completion
    
       C   E
     A   D 
       C   C
    
    A C9[C...] completes D and elvises a clone
    
    D - the Aing grouping items sprout inside
      z C & A to include C/group A workload
      provide osc-like cha/continuity without osc,
        yet be the atomicness osc uses to commit,
        and load with decor/nativities to make for mediation
          R:I is now being the osc workload gatherer + commit
            which should work on >=1 'pages' of osc at a time
              eg elvising from ...
              or the whole/9er
            rolling the others,
            being able to async progress,
              do work in parallel or not...
    make unities early to sleep/calculate desires better
      eg. when A is @28, the state can be considered D:early
      eg. when Jpin, S makes domes, which can then be known about
    internal buzz. pages of its ground.
      get composited into D:top, C9[C...] post-osc
      which gets hoisted/elvised into J/W timespace elsewhere,
        the macro-J Doming-looking action: hosting stuff.
    so to:
      make arbitrary groups
        for groups sake:
          naming stuff
          handling streams
        to stabilise/refine our sense of activity
      transport C out of time,
        so J>7 can help J<7 (sleep)
        osc-think may play with things outside of osc,
         < holds that state in a dome it hopes to pull in?
      locate them as possible actions,
        as bumping into a S-ection kinda defines it
          < more at compile time
        and elvis handlers... 1s&ein.sayeth = &acgts{
      know inputs in a tracable way
        Elvising pointing in here,
          as Teing is
        giving Desire pathways to trace processes
    
    Domes may iterate X/V or some structure from another Dome,
      it may be important to iterate locally and do remotely,
        they become transactions
    Desire might want to do something,
    as a new elvis pointing into here would
     Teing is a kind of elvising
       and is the float:right upside down triangle of stuff
         the small network-edge pile coming down into
         the big contenty pile of isness
     Schemas too, float their potential/unfoldment
       down holes they start matching
    
    #c sleep/done =head2 sleep
    
    %slep, a Tool probe
      a way to map their changes fast and sleep
        change of container vs. the values within etc
        can give/take sy&slandige/Ry&Te_slandige
     < could be faster/lessR: callback a huge ==-ish plucker,
        50ms 3%slep could get down to 4ms?
     < unicode everywhere. plants: ðŸ’® ðŸŒ¸ ðŸŒ· ðŸŒ¹  ðŸŒº ðŸŒ» ðŸŒ¼ ðŸ¥€  ðŸŽ• âš˜ ðŸµ ðŸ¶  ðŸŒ± ðŸŒ½ ðŸŒ¾  â¸™ ðŸŒ° ðŸŒ¿ ðŸ€ ðŸ ðŸ‚ ðŸƒ  ðŸŒµ ðŸŒ´  ðŸŽ‹ ðŸŽ„ ðŸŒ² ðŸŒ³
     < Cye takes y=o89 -> ycv=0.089
     < put sdiff and dup etc in 11-ish (dup 1189)
     < C/sc/css compressions, in Line or not
     
    Tool openness
      configures injectoids and transfiguration
      < more timely %differ growing out of it
      real interesting later
    
    < Elvisory re-slaning on %push to it?
       is the elvis delivery mechanism:
        give edifice of deliverableness
         resolve to best case or so:
       if it were a different J:
        enter it, changes input to thisJ
        decide to redome thisJ to involve that,
          or seeing our change come back to us
       Matu-ish out-of-time with %push gravitate reruns
      redo R building on changed elvisory?
      see 'rebuild %push to use e'
       %push currently injects the remote %ball%movingin
         which will not work if its asleep
         but it could be brought around about as fast if:
    < Te the %moves to Elvisory/anywhere
       with a watch for completion and callback/expiry
    < universal vision of rc&ha.dup,
    < replace ravel with Doming and Display2
    < TEST io.i z much
    
    # another
    o rebuild I via Babd ways
     o link G/ to W/G so we can update it ourselves
     o get a Lis rolling nicely
      o tests sign the version as it percolates
    o rebuild jsBab in js
     o fast way changes, lots of test results if you want
     o check against jsBabz for j/2/*
    
    o 'rebuild %push to use e'
      %checkout the tangley varieties of %push
    
    o unify name extrusion (see names extruding)
      like X but with where/when to D,
        alt names and fuzzentations (figure name changes)
          inc. crunchable path descriptions in various datalang
        universal gone/unnoticed system
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
    
    good study.
    perldoc -f study
    # < in general, knowing if the A is for a queue or for right now

    
    #c=head2 Maturation
    
    Gombulus hives elvising going in or coming out
    TX
    
    o a&z toplevel thinker
      and its localised sidecares
      a bunch of A not expecting J overhead
      rebuilding on the Co Joinup
        having it bring G (map of its dependencies) (see Give)
          as an %H of a different name
            once osc piles of whatever hoisting is?
              not much doc about osc hoisting:
               the W/of/t may W/what/ever/it/takes/t
               for stats/accounting
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    
    o and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and W-contiguous
            the simple funtimes embedded in the page,
            if browser compatible, Wake up and do anything
        I-ing up Sevo, then placing more A-ily,
    
    o names extruding, like X but with:
      connection to a dome:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
            done-ish by %slep
              could describe path or so
        decide once D:in !%more
          D:new == D:old to sleep, or:
          clone D:new to D:out and ...
            becomes someones D:in
              border control
        
    o Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    o elvising coming out or going in on the X
      and transacting the change of it
       as Domes, which have versions of Domes going into them
       an osc that keeps everything it sees would be first
        and be the wandering frontiers of change
     
    o making the R an A.
      compiling ravel into throat?
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further) (%slep)
     ongoing bisection of A
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    # anyway
    
    back to Pass...
    
    # thursday:
      new A4,
        < starts from a single /js/ with
          one screenful of prior knowledge
        A calmly pulls in its deps, sets foot...
    # saturday:
    # friday:
      new I compiled fore-way,
        composited and storaged in Pass
        is a layer of tools on a type of wormhole,
         which we also need to grasp moving around
        the bunch of names, Lis
    #c monday:!
    W&Ha:
      bugs:
        seeI 1.2: is one of the Is Mlimits diags wrong?
        a slep inside a slep has some history issue, keeps spawning?
      W&ledges:
       tests slepology:
         specifically elvis change
       since W&edges is too large
     
     unseparated W&Ha starts taking Rc&N>1000 to check out
      its the elvising:
       < to be lv change only
       < not deLinesing to Wing, wait til Ting
      such shapes par importo A=A
      
    W&large_edges:
      W&edges:
       tests slepology:
         wakes on elvis/data change
         %countlife%aTool shows if its awake
         %differ goes round in circles as data loops
       only just able to complete with the current memory leak
       step 9 shows a bunch of yReal vanishing...
       
      toomuch:
       leading to '< %run/%differ' is desire to ease
         accepting changes, to exp or Te
       are both a little far away? would be nice
         but nearly done with tests until A=R round,
         which is likely to see them built more elegant
        - exp: later %doing to bring earlier accepted change
         see %differ. little far away.
        - Te: %doing brings T/$W back if modified
         also a little far away.
         get both diffing,
         the innermost T...%ball that was ==
          cloning that over itself, 
           pointed enough to apply to later %doing
            that wants to resume that state with more
          with a diff/accept stage
           temporarily projected into the %run by %Tool
         Lines|diff must find R per diffchunk
           Bunchology with the diffchunks != new
       will be:
       < linking T/$W -> W:PuTe or W:City:
          T/$W:edges.y.owner = $W:PuTe
           and $W:edges ~ $W:PuTe/$W:edges
          T/$W:City.y.owner = $W:City,
           and $W:edges is further inside, etc
             find refs for $W:City/*
          possibly need more %Lines gathering points
           or a function to gather them on demand
       < diffing T/$W:edges <-> W:PuTe/$W:edges,
         producing R in T/$W that have the change,
          and those that are merely transporting it
            common Lis sense:
              T is species of edges, as is W:PuTe
         so we know the minimum clone-over move to make,
           and what it should be cloning over
             < lv changes later
       < being a pathy clone-in %Tool to apply to later %doings
      
      random niceups
       %testrun=2 'get ahead of %run'
        until %step with boost
       %run: inventstep clones last step
       
       < %City is noisy, we want:
         %slan to turn miniature diff on the noise
          path to the Rthing, lines changed before next Rthing
      
       < %Cit shrinkgrouping known R props
        < group them by the I producing them
         < coder than dictionaries every property you use
       < %Cit visual cues for:
         R:Dough that %Someflav=C:Dough,
           for eg Rs&C = picture of self
          or C.y.Process = R
           things R has may link back to R with typing
       
       and A=R
       
       #   the curves of this paragraph looks great up close:
       #  this is what A:s-ions will look like
       # state changes
       # with casual causla {}
       # along space wiggle
       < %run:
         < using %differ to:
          < cursor various things to keep branchy,
            and hooks to make the test reset/pause properlike
              %differ becoming the time controller,
              %push%act merely a workflow in it
          < %doing brings T/$W back if modified
            probably into $doing/$W (nab%aTool loses %H)
            causing:
          < later %doing to bring earlier accepted change
            eg. PuTe arrangement before every step,
            has the story of elvis along it
            < must be applied as an lv change,
              sensitive to overwriting anything etc.
          < storing lv changes for consecutive %doings
       
    #c tuesdA:
    new/old ground:
    come back to A, they are like R:
      a&z (A.sc.z) are innards, like Rs&z
       only used in A:u
      a&N are innards anywhere wanting attention
       w:TuneTimeMachine gives A to 1s&N
       w:AndContinue: resumes all 3s&N
    so 1 can know what A it has in progress...
     AndContinue shall come again
      building W&Lis
      ...
    have R that can simply keep Ringing?
     < osc must get us back into whatever Ring:
       init: Ring@1 everything (Graze)
       then: resumes all Is&z
      the cores may fall asleep at random
       and may still percolate a Display anyway
       or lock the dome it was finishing from starting again
    see I and repackage:
       A:u makes .I
         mixed from many .I,
         got from /js/
         with async for update/check
       A.4:
        has loop bits, local culture
        .I:
         is everything, mixed up with StyleHut
         .i is all StyleHut,
          figure out what we need to keep
         never goes async, is trusted to be maintained,
         .w:
          has only this %namedcode thing
       A.5:
         looks neglected
         .w:
          is the spot, y&tw for $way
           they s&dige and s&now, G&way asyncs
           want to digwaypoll them, make sync
          all scooped up by Shovel, per test run
           which can make sync prior
    I.w is totally incidental,
    1s&minds[uname] = A c&N[4s&mind[t]]
     u deals with W via /js/, mixes onto Normal
    G&question (and other asyncers) should provide:
      ttl, ready=1 on callback
     to be useful for testing this stuff efficiently
    
     how it starts:
       html <script> get & eval from /thestart?step=n
        sends it A&loadI and Stylehut
         which includes HutNuts (begoin/jsung)
       G&begoin -> G&jsung,'NutMachine' cb -> G&Jinthe
         jsung looks like A:u but overwrites any A.I[t] = W:of it loads
         Jinthe sets up listeners,
          waylays NutGravy, defines function,
           waylays NutReady, more waylays.
     
     will start:
     < A&loadI a simple A:u@6 etc for basic mind mixing
       gather more mind, global functions, start loop
      should less async, and:
       be totally new ev/e hookup:
        Display:
         lose on.A
          use attr t/cv, attr sip if sJ
          and lookup to the sips of 4s somewhere global
          A.4 must always know about elvising
         lose jQuery,
          moving elements only as needed,
          text inputs not rebuilding every time
       
       ways to keep track of updates...
        make an islanding that can digwaypoll for:
          w change
          W change is regular /W/ with dige...
        know W that contain other W we are watching,
          digwaypoll for notify of W changing?
          could be wired into /W/
           not for the same socket?
         future /W/ storer is an elvising with a route,
          only then demands stringify to get across the net
    
    #c Wednesday
    water cactus
    very thinning impossibleness:
    < s&lv should come from the $main/A.4
       output modes are a T
    < frames
     < ifr:blank.html, inject with <script> etc, save
     < the html we build able to serialise most C
       such that search engines will see it
         $Cs&W.html becomes the href=""
         going to build a lot of piles of <stylehouse>
    < jsBabz should S to an indent, work in R
    
    W:Pass %ball web surfing
     < keep openness from last time - part of:
       provide autosaved W/T from last time
        these could be tracked separately, likely to be mostly garbage
     < testbedding
       < deps: %Gounce - ghost versioning
         knowing exactly each I it ran with
         making cert to help that Gounce get places in W:Lis
     < %play%W more properly,
         see Be, can play out over time...
           minor %R-ish manage what seems to be a situation
         Rsync %gee%ball late,
          checkout fully, same Ring (T.Rq?)
           see about when %gee hits 92 before children done..?
     
        # between
        #   fio(F...) # f tv
        #   fabioty(p..., # R f is for tv
        #   Rc&X, Rs&Te
        #  we have a few ways to gravitate the elvising made
        # < ad hoc continuity:
        #  < mez&rename (now ballrename) takes Rs&Te
        #  < mez&move should takes Rc&X, in some cases?
        #    if the A of it can be trusted to resync
        # something somewhere in the equation of Waltz
        #  knows exactly why things changed,
        #  holds and spreads knowledge of the move
        #  which may be done out there as:
        #    lv with an el:9, el:6 ?
        #     6 implying recycle the last 9,
        #       or some specific one,
        #       or resurrect recently deleted...
        #      similar logic to:
        #      Lc&responsey - expect one receive per send
        #  requiring all these interations to be suspended
        #  over the judders
        
     %play%R starts:
     %Doming:
       building up how to J(.3)
        < have Swim-ish any index hoisting
           mixing/reducing
            ting Merge.js for J, with W:of
        < ting search in %Doming
          building indexes of I when they are required,
          elvising changes:
        
     ballio, Ravelvis are
     %ios:
      < %balls have io/slep sense
        for intended+not changes
       i wanting to happen
       o happened before
        desire/surprise carrier
        < slep/io <-> what Reaction, batched
          eg /seek/ -> %do_Further()
         < via Sectiona, for an atime iterator of /seek/
       quite to do with:
     < one big %ball,
        < some of it grounded
          there are C from/for Activity (osc-levitated)
          and C for being the sticks in the mineshaft
          < have a CdaR (fast) way to diff %balls to themselves
          whatever it takes
        < getting that change to Rsync %balls,
       < even out of sync, to a degree
        < these ch() comments shall Tool down to
          fleeting speechbubbles, beneath the line
        < tree -> table mode as we cross the line,
          smoky action -> seeing office mode
       
     Mwty
       rearranges modulats
       dressing %ball%fixes for being about ...
       eg the attr on a %Rom messes with the %Doming
        and gave/give each other life
     
     %JRom:
       is separating into %Doming
       
         encapsulates activity, Doming in and outs
         parts have error and (1|4)s&N plumbing
         < T plumbing (see control)
         < pausing if time/sheer Ring intensive
           could control infinite loops in the same Ring
             the first Ring inside 4 should ttl when starting Ring
           for progress, may Ring more, when theres time
             sleeping for Display meanwhile?
               Rc&X will wander, merge the eventual completion
             or osc-ing each section as it completes
               like Doming, wants recode with T sense,
                recording the set of args used, etc
         
         < R:Mapper may also have a little e/Mw on each of many,
           hanging up its thinking amongst others language
           
         < folding, taking %noDisplay off chidlren with activity
       
     %mund: de-lies fact piles
       various eg %Ghostways produce stuff
       they each become a Ghost unto further ...
       
       %Ghostways:
         your version checker
          travel agent
         historically:
       %GhodigWap:
         insures /way/$t against %mundws:digwaypoll
         < tractorbeam $Way into Ghost/Way,
           leaving the hoisting to $Way/5Iw up to mund
           this Ghosts best guess for those ways
           and providing data on dupover, etc.
           and helping lay out ref phylogen
         < G&ting/%ting forcing question/remote check
       
       sidenode:
         everything we n ... in R is really an m Rs&M ...
           unless it Cc&R: spawns R, c.* copied to sc.*
         such is a tubeending
      
       
     #c t!!
     t:
      is thing finding
      t looks up A slope of places with things
      t looks in the dome building now...
       and for A-things around the place
        as A needs to find As to A
         t learning how to traverse every index
      # now:
      G.h(acgtt) does $t subroutine (I.i.h does I.i.$t)
       therein looking for $t becomes:
        G.t(acgt'i't) to avoid infinite h<->t loop
      # future
      B/T stack sensitive
        any call may be paused by a variety of reasoning
      G&lathe,3 Babz:
          G(A,C,T,'lathe',3)
      # or perhaps inlined non-inlined sub calls (no B-stack)
          G.i.lathe(A,C,G,T,3)
      # or totally inlined: ({}-scoped lexicals?)
          s&surface-- for 1..$s;
        this will be handy for generating G&throat
         from the dimensional joint protocols the I use
         these will need variants, as me&Ring is
      
      # lots of lang shall compile to lots of G(...)
      #   anywhere we thing stuff
      G = &ACTs{
          # like G.h
          $G = this;
          $args = arguments.slice(4);
          # simply looking for a function, closest A with it
          $i = is_string s ? G.t(acgt'i',s)
              # looking for something crazy,
              #   may even take args about this call
              #    and beyond, to find the right thing
              : G.t(acgts,[M]);
          B/T stacking {
          T.return = i(A,C,G,T, ... args)
          }
          return T.return
      }
      G.t = &acgtM{
          # like G.ting
          # matches whatever W/C/c in M
          #  sequences of them usu mean by z,
          #  array of arrays for resetting cursor
          # can also mean start doing a thing,
          #  nearby doming invites it to keep state
      }
      # further future:
      Babz realising parameters on things:
      G&$Self$Ne:za,$R$s$c:limin,%vang
      packs in the:
        G.t s={Self,Ne} c={R,s,c} 
         looking for (s) $Self and $Ne
          knowing the act (c) if that helps?
           or would it get confused with more itemology
            spose G could decide on the first being WHERE,
             the others being some extra into
             seems like something for doing subroutine calls remotely
        running it %vang mode with named arguments
         %vang could specify output form,
          a style to apply on something inside (G&tsc)
          some T-condition, error/async continance
          or name the object created
           t looks in the dome building now...
      T-condition,
       check it every B-stack (soon to be a lot of them
       error/async continance
    =cut
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #    C.y.R = R:C
    #   sprouts some sc to R:$gk or so
    # < determine, certify version of etc involved
    # we have a village's machinery for progress
    # < teleporting in: knowing you want such sleep pattern
    #    for vibrating values (oscillation)
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c Be.C - group C.*.*
    # see %Cit/KnowC
    # < I, a W of qualities and how to use them
    $Be = me.Be ||= {};
    # < more C
    Be.C = {};
    Be.C.Cit = {
        scgk:'Cit,fromsitop,scan',
    };
    Be.C.R = {
        ygk:'R',
        cgk:'d,N,X,V,refs,refR,inC',
        scgk:'X,ci',
    };
    Be.C.Rlimits = {
        cgk:'dupl,nl,dl,dubquiet',
        scgk:'boost',
    };
    Be.C.Rplay = {
        scgk:'boost,Te,playsheet,elvis',
    };
    Be.C.History = {
        cgk:'b,V',
    };
    Be.C.Display = {
        scgk:'C,Mw',
    };
    Be.C.fun = {
        scgk:'tightly,inheritsc',
    };
    Be.C.in = {
        ygk:'in,tw,tv',
        scgk:'z,Wind',
        sc: {
            Wind: {path:'t,dige'}
        },
        wanderin:'together',
    };
    Be.C.space = {
        ygk:'cv,ov',
        cgk:'cv,ov',
    };
    
    Be.nks = 'y,c,sc'.split(',');
    me.BeCload = &{
        each K,Kc Be.C {
            Kc.K = K;
            each ik Be.nks {
                k += 'gk';
                !Kc[k] || typeof Kc[k] != 'string' and continue
                Kc[k] = Kc[k].split(',');
            }
        }
    };
    #c Beings arrive, find C.*.*
    me.Bear = &acgtRsk{
        k == 'play' and Be&plays,R,s
        else
        Rs&ball and Be&lums,R,s
        else
        Rs&fix and Be&fix,R,s
        else {
            throw "No Bearing"
        }
    };
    
    # 27%play via %playsheet
    Be.plays = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q )
            .map(D => Be&playit,R,s,D );
    };
    # 3%ball sprawls out
    Be.lums = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q,{ohm:1} )
            .map(D => Be&lumit,R,s,D )
    };
    # 3%fix is a thing
    Be.fix = &acgtRs{
        $p = Ry&up;
        # Be: inherits from %ball's lumit
        #  via %BeX.xtk[$sc][$gk].exRsc.BeD = fixit's D
        #    < should also know lumit's D
        ps&BeX and Be&BeXarrive,R,s,[R.t,'fix']
        $D = Rs&BeD;
        #  or %Be[$sc][$gk] = lumit's D (GOING)
        $be = !D && Be && ps&Be;
        be and D = be[Rs&fix] && be[Rs&fix][R.t];
        # may %viewvia=ki|size to gkness
        # and %inputmode
        # < %fix%play should grow the meaning etc
        D and Be&fixit,R,s,D
    };
    
    # Be about here.*.*
    Be.scan = &acgtRs{
        $M = []; # q+
        each kt Be.sc {
            !hak(s.sc,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        each kt Be.y {
            !hak(s.y,k) and continue
            M.push({tatch:t,nk:'y',gk:k})
        }
        return M
    };
    
    # makes D for q, thing attachment mode specifics
    #  D also gets how to act
    Be.cutch = &acgtRqc{
        $D = G&Cye,[q.tatch,5,c||{}];
        !D.t and throw "!t"
        # sc from matching
        q and ex(D.sc,q)
        # c from matched, the how
        Be[D.t] and ex(D.c,Be[D.t])
        # known properties on %ball%Be
        if (Ds&nk && Ds&gk) {
            # < Rc&X.Be.nk_gk for:   and Dc&b...
            $be = Rs&Be ||= {};
            be = be[Ds&nk] ||= {};
            be[Ds&gk] = D;
        }
        return D
    };
    
        #c BeX getting a %ball/me&lumit's Be-ing to a %fix/me&fixit:
    
    # set properties of children that don't exist yet
    # see RbitX
    Be.BeX = &acgtRsD{
        each kc Dc&BeX {
            $name = D.t+' '+k;
            k = k.split('%');
            $t = k[0];
            k = k[1];
            # cousin of R.c.X/V
            $X = Rs&BeX ||= {};
            $tk = X.xtk ||= {};
            tk[t] ||= {};
            $oX = tk[t][k] ||= {};
            # where .x=[more R.t],.xtk=[more nk/gk]
            # and non-path things apply to the arriving R
            $sc = oX.exRsc ||= {};
            # rogue generation of D
            # < use cutch, make complicated Be[t]s
            sc.BeD = G&Cye,[name,5,c];
        }
    };
    # X.xtk = R.t, R.sc gk
    Be.BeXarrive = &acgtRsl{
        $p = Ry&up;
        $X = ps&BeX;
        !X and return
        # walk a path of x to X
        $x = X.xtk;
        each in l {
            x = x[n];
            !x and return
        }
        Rs&BeX and throw "Already at RsBeX"
        Rs&BeX = x;
        # check in
        x.z ||= [];
        x.z.indexOf(R) < 0 and x.z.push(R)
        # apply
        x.exRsc and ex(R.sc,x.exRsc);
    }
    
    
    
    #c Behave from C.*.*
    # localises & applies Dinstructions
    
    Be.playit = &acgtRsD{
        !Rs&ball and throw "What"
        Dc&play and Dc&play(A,C,G,T,R,s)
        else {
            # vaguely know it, not a c&play-er
            # < later check some Be used the %play
            # < thing's sc wants upgrading mode
            me&tsc,"!play:"
        }
    };
    
    # R%ball
    Be.lumit = &acgtRsD{
        # symbol blocks the way, and leads on
        $c = {k:'clicktoplay',y:&v{
            me&introqua,R,{play:v}
        },Mw:'Be',tsc:'T',relax:1};
        me&rolltog,R,c;
        $n = c.n;
        
        nc&s = Ds&gk;
        Dc&symbol and nc&s = Dc&symbol
        nc&s.length > 5 and Dc&symbolsize ||= -5
        Dc&symbolsize and ns&fs += Dc&symbolsize
        
        # c&nofurther - stop adding R under this one
        #  recursion control
        Dc&exRc and ex(R.c,Dc&exRc);
        $p = Ry&up;
        each kc Dc&ps_Dc {
            p.sc[k] and ex(D.c,c)
        }
        Dc&BeX and Be&BeX,R,s,D
        
        # %play things tend to hide/represent in-%balls
        Dc&ohm && Dc&play and Dc&hbb ||= 1
        # otherwise it costs 1 boost
        # < consumable if Tie remembers
        !Dc&ohm || Rs&boost > 0 and 'open'
        else {
            # tend to hide every R inside...
            !Dc&hbb and Rs&nofurtherDisplay = 1
            # very high level view of what else scans interesting
            ss&z &&
            n withz  s:z %fs:14,hs:966
        }
        Dc&hbb and Rs&hideballsballs = 1
        # do more display?
        # look up for a qua ac?
    };
    
    # R%ball r%fix
    Be.fixit = &acgtrsD{
        $R = ry&up;
        !rs&fix and throw "What"
        !Rs&ball and throw "What"
        # apply styles to r%fix
        $st = 'inputmode viewvia'.split(' ');
        each in st {
            !D.c[n] and continue
            r.sc[n] = D.c[n];
        }
        # < symbol's styles fitting into %fix n t
        #     might be too complex to read
        #       sprout as necessary
        if (Dc&play) {
            # can %play sometimes (via the %ball)
            # likely to show %fix t/s?
            s == '1' and me&tsc,'onething','=1'
        }
    };
    
    #c Bersonality of C.*.*
    # effect C representation
    # known properties may ... (%ball%play)
    Be.sc = {};
    Be.y = {};
    
    # s&H
    # stored object
    # < boostrap from H:1
    # < know exactly where it is (/G/*)
    # < know history of it across history of s
    # < history of s vs. history of R, getbetween.
    #   values exist somewhere fractionable in Domes,
    #   pinned down every so often from various angles
    #    levels and resolutions, compromises
    #   simply have to play lv in reverse, watching path
    #    lv must play from an el<3
    #    to know it has everything in the situ,
    #     which could be localised to part of the path
    #     < lv requests should serve grep into paths
    #       thence almost-Lines wants to end up in a database
    Be.sc.H = 'sH';
    
    # s&quiet
    # eg a Js&Te doing usual work
    Be.sc.quiet = 'squiet';
    Be.squiet = {symbol:'q'};
    
    # y&lv
    #  boundary to a done thing that will join to us
    #  eg. your %Lines hoists the s.y.lv as itself
    Be.y.lv = 'ylv';
    Be.ylv = {symbolsize:-2,exRc:{nofurther:1}};
    
    # s&of
    # code, generally compiles, /\n$/
    Be.sc.of = 'sof';
    Be.sc.js = 'sof';
    # sets up openable codon on s%fix
    Be.sof = {BeX:{
        's%fix':{inputmode:2,viewvia:'size'}
    }};
    Be.sc.string = 'sstring';
    # sets up openable codon on s%fix
    Be.sstring = {ohm:0,BeX:{
        'string%fix':{inputmode:2,viewvia:'size'}
    }};
    
    #c Beeple of C.*.*, proto s&R
    # s&W
    # < opens that Wormhole in the nearest %gee
    # < located around here:
    #    i ^^%gee/$W y o ^^/G/$W
    #     then %gee late Rsync,
    #      so openness can occur in this ev'd Ring
    #   this would be the stately G&ting
    #    5 could know all the W we use
    #   iter `dig`
    #   < hostinfo
    # < as another J,
    #   managing pause/sleep modes of them
    Be.sc.W = 'sW';
    Be.sW = {play:&acgtRs{
        # becomes signpost leading in
        $l = me.cbu(R,'gee');
        ls&openness.push(R);
    }};
    
    # s&J
    # probably a J:1,
    # make W from the elvisory
    Be.sc.J = 'sJ';
    Be.sJ = {play:&acgtRs{
        ss&J != '1' and throw "nonJ=1"
        # feeds with e
        me&Ravelvis,R,s.t;
        # < unDoming
        ac(R,'unplaycb', &{ me&Ravelvis,R,s.t,9 })
    }};
    
    # s&testrun
    # does a test via W:Co
    # < elvise it
    Be.sc.testrun = 'stestrun';
    Be.stestrun = {play:&acgtRs{
        $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
        Rs&Te && Rs&Te.sc.almost and ls&almost = 1
        me&introqua,l,'boost:2','@1'
    }};
    
    #c Beepingness
    # %play engaged tasks
    # Doming & Beeping will separate
    #   Beeping has empirical noise,
    #   particulars have idealism or more noise
    #   toward being a network stack
    me.Beepingness = &acgtR{ return [
        ... me&KnowCitingness ,
        ... me&Tingingness ,
        ... me&Tongingness ,
        ... me&Socketingness ,
        ... me&Domingness ,
    #c %garbec
    =pod
    garbec%R: garbage collect localStorage
     , regex for %W and %H
      < know %parent, ship everything off to a git
       < as a %Gensing?
         with an %H/differer for the current state of it
         but just be an R, opening bits of net puzzle
         posit deletables, do one last grep for their %H
       good for up to 5MB?
       %H:
         any non-W chunk, storage t=dige -> string from Lines
         must %Lines encode H:... for regex
         < Lines could have many sc, keep first clean looking
       < %H may all hoist to the top, as in w:Writer/Gversioning
         would look like %Has:0294u390;34ui902d;345u209u3;3u8490j
    =cut
        # boost <0 to rescan. >0 to delete
        # < bright future of the backroom
        # < for the enclosing %gee
        ['garbec','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            
            #Rs&somehash = window.fogive ||= ex({},localStorage);
            Rs&somehash ||= localStorage;
            
            (Rs&boost||0) < 0 and 'rescan'
            else
            me&rollbs,R,'figure' and return
            n Pass  R %garbect,viaW
        },'ift,D'],
        ['garbect','3',&acgtRs{
            Rs&noDisplay = 1;
            me&tsc,'nothing';
            $k = R.t;
            $g = me.cbu(R,'garbec');
            # < use $k=Rc&s and Rc&refs to dedup
            $te = gs&garbect_t ||= {};
            te[k] and return
            te[k] = R;
            # order importo par stat hoist
            ac(g,'garbectN',R);
            # read
            $v = gs&somehash[k];
            !v and return Rs&err = "No "+k
            
            $l = v.split("\n");
            each in l {
                # < using Wm[3]: where the match started
                #   and showing the path through this place
                #   %garbect are places/storage points/gravity wells
                $Wm = n.match(/(H):(\w+)\b/);
                if (Wm) {
                    $H = Wm[2];
                    n $H  R %garbect
                    continue
                }
                # the s&W usually 1, encodes to just 'W'
                #  otherwise it's a different W this one must accompany
                #  eg %of is required (eventually) to wake up code
                $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
                if (Wm) {
                    $t = Wm[1];
                    Wm[2] and continue
                    # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                    n $t  R %garbect,viaW
                }
            }
        },'ift,D'],
        ['garbectN','6',&acgtRs{
            $te = Rs&garbect_t;
            Rs&figure and throw "garbectN + figure"
            $d = Rs&figure = {};
            d.to = 0;
            d.total = 0;
            d.disco = [];
            d.discotal = 0;
            each kv localStorage {
                d.to++;
                d.total += v.length;
                te[k] and continue
                d.disco.push(k);
                d.discotal += v.length;
            }
            $N = Rs&garbectN.slice().reverse();
            # < size of Ws sans in-Ws?
            each ir N {
                rs&err and me&tsc,"err",r.t+"_err:"+rs&err
            }
        },'ift,D'],
        ['garbec','7',&acgtRs{
            $d = Rs&figure;
            !d and throw "!figure"
            
            each kv d {
                typeof v == 'object' and v = v.length
                n t  $s:k %hs:999
                typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
                n s  $s:v
                n sp  s:\n
            }
            
            # delete the disconnected
            # < check it's a %H-type key,
            #    deleting W should be harder,
            #    but we can't really tell...
            # < know what hist
            if ((Rs&boost||0) > 0) {
                delete Rs&figure
                each ik d.disco {
                    # check they exist
                    !Rs&somehash[k] and throw "to delete, no: "+k
                }
                each ik d.disco {
                    delete Rs&somehash[k]
                }
            }
            delete Rs&Te.sc.boost;
        },'ift,D'],
    #c t/%lvhashave
    # test Element replacement with minimal add/remove
        ['lvhashave','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '7px dotted green';
            s&hue = -70;
            
            $td = [
                'jus fibre g/twas jus fibre g',
                'jus g/twan jus',
                's van to dich/ze van dich toat to',
                'toad transfer lich/fur lich trom toad',
                'sle sla van to dich/sla van sla dich sla toat to',
                'further towards ye goal goal/no further goal shall goal ye',
                'test data shall/test shall gall data',
                'test to nuf fla flong/fla test flo flong to nuf',
            ].map(&s{ return s.split('/').map(&s{
                    return s.split(' ')
                }) });
            
            
            each in td {
                $got = n[0];
                $exp = n[1];
                
                $D = G&Cye,["case_"+i,''];
                Ds&got = got;
                Ds&exp = exp;
                Ds&V = 1;
                #exp[0] == 'fur' and V = 2;
                
                # 6
                me&lvhashave,D;
                
                # 7
                $space = ' ';
                each in Ds&cha {
                    $tn = Ds&actN[i];
                    tn = tn ? tn.join(' ') : "?";
                    me&tsc,'elementing',n,'1b'
                    me&tsc,'elementfunc','@'+space+tn,'1q'
                }
                
                
                if (!Ds&actN || Ds&fail_elementing) {
                    me&tsc,'started',got.join('-'),'1d';
                    me&tsc,'exp',exp.join('-'),'1p';
                    me&tsc,'element',Ds&lvd.join('-'),'1b';
                }
                else {
                    me&tsc,'elementingok','OK.elementing',1
                }
                
                if (!Ds&have || Ds&fail_brute) {
                    me&tsc,'output',Ds&have.join('-'),'1p'
                }
                else {
                    me&tsc,'outputok','OK.brute',1
                }
                
                Ds&fail and me&tsc,'%fail'
                Ds&total_change and me&tsc,'%total_change'
                
                me&tsc,'---',null,'1'
            }
            
            Rs&Sampley and me&Sampley,R
        },'ift,D'],
    ] };
    #c func-Dome
    
    # saves your n ... as joined c&s text
    # some care to \n regularly
    # < unicode embedded colours, see G&intag
    me.Sampley = &acgtR{
        $s = '';
        each in T.nN {
            ns&R || nc&R and continue
            $headed = 0;
            if (n.t.includes('lv') == 0 ||
                n.t.includes('change') == 0) {
                'swathe'
            }
            else {
                s += "\n"+n.t+": ";
                headed = 1;
            }
            s.substr(-1) == "\n" and headed = 1
            ns&dis && !headed and s += "\n";
            nc&s and s += nc&s
            ns&dis and s += "\n";
        }
        s.substr(-1) != "\n" and s += "\n"
        $c = G&Cye,[R.t,'',{sample:s}];
        $l = me&Copy,R,c,{t:'Sampley_lv',ball:0,Lines:3};
        Rs&Sampley and Rs&Sampled = l
        return l
    }
    
    # like G&ind, or Rc&s=C climbing
    #   returning Rc&N.map(Rc&s)
    # and setting yup
    me.sunN = &acgtsdl{
        d ||= 1;
        l ||= 5;
        d > l and return []
        $N = [s];
        each in ss&z {
            ny&up = s;
            N.push( ... me&sunN,n,d+1,l )
        }
        return N
    };
    
    # func Dome t
    # phil somewhere rising
    
    # G&t for this thing
    me.herer = &acgtD{
        $very = arguments.slice(5);
        $s = D;
        each in very {
            typeof n != 'string' and throw "!s"
            # should know where D%in.$tv=C
            #  or D%in=in/C or D/in/C or Dc&X...
            # by the D it's in
            $v = sy&tv $n
            v ||= s.sc[n];
            s = v;
            !v and break
        }
        return s
    };
    
    #c e thingers
    # e as far as ravel goes
    # W: $t/R/[path] of Remote
    # k: mode/act/hook of delivery
    # D: the item to deliver
    # we used to: e $W $D
    #  and got a C that .t=$W, c&e=$D
    # the k not being part of D means D can be more like ec&s:
    #  the item being delivered
    #   which might still be requesty, depending on k
    # k:
    #   M: i 1s&Tes&M/$D
    #     < io param each A.1, 1s&Te & 1s&Tes&M
    #       and mean something
    #   < something like me.RMount
    #     similar/future bunch of things then replace
    #   9: deletes Te
    # < native undo:
    # < when it's
    #    el=1 (creation),
    #    el=2 (more forceful/recreation,
    #      and implies it's the only thing with that t
    #    el<3 implies it's a full copy (to the next %W/H)
    #    el=3 is an update
    #    ...
    #    el=8 keepalive or reference for ordering
    #    el=9 deletes
    # < how it's
    #    coming from a process writing down its deps
    #    something output from osc,
    #     maybe wanting to include those deps ^
    #      as it fits into the store's system
    # < doing all of its procedural thinking via elvis,
    #     and cX state as transactions
    # < everything believed goes through elvis,
    #     then it can be natively from somewhere
    # < el.y.A having 4's being-there consciousness,
    #     partly workable out of frames
    # 
    # e async is ok, n async only if truthgap or sleep/later scheme
    #   your meanings may vary that
    #   eg elvising from G&ting to look up a /js/ would throw async
    #    placing some W:js question,
    #     which could trust cache
    #     look it up in a variety of places:
    #      /W/Somewhere/ju/$t.js for <script>
    #      /W/Compiles/$t is W:$t inc I
    #     or even build it:
    #      make W/Compiles/$t from ghost,
    #      elvising codes to W:js, compiles I
    #        of wants to keep
    me.Ravelvis = &acgtRWkDc{
        # there
        $el = typeof W == 'object' ? me&introqua,W
            : me&stackTe,[W];
        # lives (async awake) (if $Elvisory/$el)
        els&J = 1;
        
        # may be sc
        c and ex(el.sc,c)
        # then cc&el
        c ||= {};
        c.c ||= {};
        # hook
        k == null and 'nothing doing, just async awake'
        elsif (k == '9') {
            i 4s&elvisory/-#$W
        }
        elsif (k == 'M') {
            if (els&M) {
                me&yfuture,els&M;
                els&M.indexOf(D) >= 0 and cc&el = 8
            }
            ac(el,'M',D)
        }
        else {
            throw "elvis?"
        }
    };
    #c Domingness mund ravelabhion straight curvy cellvey
    # < goneRbitX as savepoints
    # < regroup... me&Rom, etc, ways to do things
    #  elvising, everything sleeping until laters wake em,
    #  doming as the flow of signal/control
    #  and physical space, esp code
    #  general linkage to phil somewhere


    # finds r = t/** at depth p
    #  adds to their rs&Mw.rolltog about may:k
    #  returns list of r that are on
    me.iostyle = &acgttpk{
        # < p for path, [y,M] for ioty
        typeof p != 'number' and throw "Set depth p"
        $N = me&ioty,t,p;
        $M = [];
        each ir N {
            if (k == 'Look') {
                # resists mess
                $show = me&rolltog,r,{may:'Look'},0;
                !show and rs&nofurtherDisplay = 1
            }
            else {
                # Rs&$k takes the ball, once?
                $c = {may:k,once:1};
                #k == 'Upload' and delete c.once;
                $doing = me&rolltog,r,c,0;
                doing and M.push(r);
            }
        }
        return M
    };
    
    # i $v/@s o $r/*
    #  complicatedly, using polify/ate
    # can clone-over but keep certain children etc
    #  eg. %Elvisave iostyle's for things to move,
    #   combines them with where they're going,
    #   and uses this to avoid storing/restoring unwanted stuff
    #    eg its own Elvising
    # Elvisoir > mez&clone < e ...
    # the clone-over (or not) usuality,
    #  no taking the top level
    # < pass D to R:Copy to save it needless work
    me.polout = &acgtvr{
        $R = Cy&R;
        $D = G&Cye,['apolout',{R:R}];
        ac(R,'polout_z',D);
        
        $mez = me&ballio,R;

        # r/* is a land cloning into v/*
        me&polify,D,v,r;
        me&ioty,r,'%ball' .map(&s{
            ac(D,'cloned_z',s);
            # < check in to D, do el4/9 better
            $S = mez&clone,v,s;
            ac(D,'clone_z',S);
            me&Rsync,v
        });
        me&polifate,D;
    };
    
    # r/**%balls N=['path','somewhere']
    me.fabioty = &acgtrN{
        return me&ioty,r,N.length,{st:N,zvia:'s'};
    };
    me.ishad = &acgttN{
        # < partial matches
        N = me&fabioty,t,N;
        N.length < 1 and return
        N.length > 1 and throw "many"
        $f = {r:t,N:N};
        # they to where they had it
        f.row = me.cby(N[0],&r{ return r == t });
        return f
    };
    #c polify
    # i $h/* y o $t/*
    # where anyone can have policies for ...
    # eg keeping $t/Elvisforthis only in $t
    # < discover any overlap, hardwire decisions
    me.polify = &acgtDvr{
        Dy&R != Cy&R and throw "D!R";
        !vs&ball and throw "delt!ball"
        !rs&ball and throw "dealing!ball"
        $vr = [v,r];


        each ih vr {
            $t = h == r ? v : r;
            $po = h;
            each kc pos&pol {
                # po always h(ere), where polcify applies
                # h is v going in, r going out
                #   me&clone,v,r flows <--
                # t(heir) is the other
                # has is for h, have for t

                # check for path
                #  hooks may depend on finding stuff here or there
                $fort = c.forTepath.slice();
                $inwhat = '('+fort.join('/');

                # later referred to as f
                $has = me&ishad,h,fort;
                $have = (c.either || c.their) && me&ishad,t,fort;

                !(has || have) and continue

                # adds a polification
                $lo = G&Cye,[k,1,c];
                c&pi = 'polify';
                ac(D,'z',lo);
                # builds an act, for in/around cloning
                # f (has|have), el=s, r? (if!=f.r), callback?
                $sync = me&polsync,lo;

                los&here = h;
                los&has = has;

                los&their = t;
                los&have = have;

                h == r and los&leaving = 1

                if (los&leaving) {
                    # have something, protect them from it?
                if (loc&nonleaving) {
                    # < avoid cloning out things that don't move
                    #   Copy untils, to catch the same tving sesh
                    # they might have something to preserve
                    have && sync(have,4)
                    ||
                    # climb has there and delete
                    has && sync(has,9,t);
                }
                }
                else {
                    # given something, protect us from it?
                if (loc&nonoverwrite) {
                    has && sync(has,4)
                    ||
                    have && sync(have,2,h);
                }
                }
            }
        }
    };
    #c polifate
    me.polsync = &acgt,lo{
        return &fsry{
            loc&sync || loc&el and throw "doublesync"
            !s and throw "no el"
            loc&el = s;
            $sy = loc&sync = {f:f};
            typeof r == 'function' and y = r; r = null
            # this f/row can be tried somewhere it wasn't:
            r and sy.r = r
            y and sy.cb = y
            return 1
        }
    };
    # post-clonial
    me.polifate = &acgtD{
        each i,lo Ds&z {
            $sy = loc&sync;
            if (sy) {
                $f = sy.f;
                $bet = f.row.slice();
                # the thing before
                $v = bet.pop();

                # < code these more positively: $t is= bet.shift()
                f.r != bet.shift() and throw "here not t", "bet.shift()"

                # the thing we change
                $r = sy.r || f.r;
                # walk almost there
                # < many f.rows
                $n = me&fabioty,r,bet.map(t=>tc&s.t) [0];
                if (!n && loc&el == 4) {
                    # rebuild between r and v
                    $rr = r;
                    each it bet {
                        n = me&fabioty,rr,tc&s.t [0];
                        1 && n and rr = n; continue
                        # < input,rr,t recycle/refology/fork
                        n = me&input,rr,tc&s;
                        rr = n;
                    }
                }
                if (n) {
                    # grab what is there now
                    $cs = nc&s;
                    $ks = vc&s;
                    # < should know it's a Copy
                    $si = me&fabioty,n,[ks.t] [0];
                    $is = si && sic&s;
                }

                # do something
                if (loc&el == 2) {
                    ac(lo,'todo',"Accepted over nothing: "+kss&play);
                }
                elsif (loc&el == 4) {
                    !n and throw "Deep 4"
                    # el:4 leaves things,
                    # < may move subjectiver experience
                    # unoverwrite what was there
                    if (is) {
                        los&removed = is;
                        i $cs/-$is
                    }
                    $en = me&input,n,ks;
                    me&Rsync,en;
                    ac(lo,'todo',"Unoverwrite: "+(is&& iss&play)+'->'+kss&play);
                }
                elsif (loc&el == 9) {
                    !n and throw "Deep 9 ok?"
                    # ensure v is deleted once there
                    los&removed = is;
                    i $cs/-$is
                    me&Rsync,n;
                    ac(lo,'todo',["Drops:",r,n,v]);
                }
                else {
                    throw "sync el "+loc&el
                }
            }
        }
    };
    #c Be.sR theory - adjust raised sticks
    # at %ball%play
    =pod
    s&R:
      how to conjoin an other:
    the ground wakes up, doing a J (R for now)
    from a C%ball describing the J
    
     %R=+Save gives %ball%Save
       < separate that kind of thing to %A
      
    if no ^^4%Gens:
     R=Tool makes %ball/r%Tool
       s.sc -> r.sc
       s%z -> r%nz
         is the out %ball cluster continuing inside
           waking up into this layeR
    else:
     R=Tool makes %ball/s.t%Gens%ting/r%Tool
      %Gens creates the thing with memory
       if sc&el=1
         !%ting
       else
         initialises Livec&Tool=1,
           out-s* able to form high level pictures
         Live.c also -> r.sc
    
    %R=1-9 turns into %Doming (the slope)
    
    < %MindInto projects R=... to make thinks into Know/**%ball
      leaving the insphere intermediacies savable
    
    < above may have %methods to continue through our being
      %methods over slopes
    
    %Gens:
      for/in R%ball (usually)
      wakes up R/%Gens/r with its memory
        got via %Gens%ting unless in outs-only mode (sc&el=1)
       < cautiously if no memory:
      < care to authenticate code running by it
    
    %JRom:
      domes it if s&R>=3:
    < elvising (networking)
       %ting consumes stuff from the network
        so people opening the same thing get connected
        and theres a spout for updates/locks
       for acts of change
        to have a formal place
        and they may be 
       see Ravelvis etc
    
    %Gensing:
    < from %Gens, mediates %other <-> %self
      commits a tree in either direction
        syncing pieces required for a coherent there/%other
        as eg the /W/ server would do until all %H are
      
      doing ballio
      
      setting policy
      
      learning qualities
      
      control:
        is an expression separate from data
        
        r%Doming=2, an A.2 slope, unless no ^^4
          levels have many definitions, create slopes
            are points of interest/tingingdoms
        < %whaT to overlay/inject/control
          mucking with I/anything going into it
      
      compression/difference:
        how out%ball -> in%ball
          loading our changes on top of it
          %MindInto out%ball/* are W mixing into it
            in W surfing mode, when you employ %MindInto
        how out%ball <- in%ball
          keeping a vague picture, like %species=4
          %MindInto keeps the 1C only, with $W%H,dig,v,etc
            merging with the Live, which is for notes etc
             mix-figurations
    
    s&W/s&J eventually do this, growing from A.4/A.1
      pinning /way/s.t to define it
    
    'doing from and growing from' will + joints
    
    R=\d+ could mean slopality, instantiatia:
     2: should be remembered
     3: must be Domed
     4: follow children first?
       %MindInto would set this up as its iterating
     5/6: thinkingabout/supposing theyre all processes
    
    < auto %play any %Doming=3/*%R
      supposing theyre all processes,
      not bits of a process
        the for later/someoneelse phenomenon
        the lum, line, probably to do out/in%ball
     < know boundaries, where awareness should end
       usu where %otherstuff begins, or time
       play with making it wake up too hard
    
    < %push/%differ ~s&testrun, less remote
    =cut
    #c Be.sR - adjust raised sticks
    Be.sc.R = 'sR';
    Be.sR = {
    ps_Dc:{Gens:{ohm:0}},
    play:&acgtRs{
        $c = {};
        $sc = ex({},s.sc);
        $k = delete sc.R;
        $z = delete sc.z;
        # R=\d+ could mean slopality
        k > 1 and c.Doming = k
        else {
            k == 1 and k = '1'
            typeof k != 'string' and throw "refR"
            k = k == '1' ? s.t : k;
            k = k.split('+');
            # R=+Save gives R%Save
            # R=Tool+etc makes r%Tool%etc
            k[0] == '' and k.shift(); c = R.sc
            each i,gk k {
                c[gk] = sc[gk] != null ? sc[gk] : 1
            }
            c == R.sc and return
        }
        # new being
        # < namestretch over out/9er/in,
        #   making the formers harder to elvis,
        #    is checked in
        c.t = s.t;
        # who knows names
        $Gens = me.cbu(R,'Gens');
        # and history
        $Doming = me.cbu(R,'Doming');
        # s.sc -> r.sc
        ex(c,sc);
        # the outs
        c.other = s;
        # s%z -> r%nz
        ss&z and c.nz = ss&z
        # c carries through Jrom or %Gens
        !Gens and c.Doming ||= 3
        # or via %Gens waiting room
        else {
            c = {t:c.t,Gens:c};
            # < %JRom/%Gens/... 
            c.Doming ||= 1;
            
            # < join some thinking about Doming it 
            # our %Gens%ting will find its %ting
            #  for pathinto (or not if W:thing)
            #  J would wander in and W along
            
            # < something not quite %JRom, concurrent
            # < group time Ringing inside it
            # < lots of weird ways to make callbacks whenever
        }
        
        !Doming and c.Doming = 4
        c.Doming >= 4 and c.task ||= 'rovo'
        
        # packdown from %play
        ac(R,'unplaycb', &{
            each in rs&unDoming {
                n()
            }
        });
        $r;
        # level of Doming...
        # blend ind
        c.Doming <3 and r = me&Ret,R,c
        # another Ringing (Rc&N)
        # instant to the enclosing Ring
        # < unless it makes Arrangements
        # catches throws
        else {
            r = me&Rom,R,c
        }
        return rs&returns || r
    }};
    # GOING -> s&R
    # %Gens)%ball open %SomeProcess
    Be.sc.Gens = 'sGens';
    Be.sGens = {ohm:0,play:&acgtRs{
        R.sc[ss&Gens] = 1;
        s&boc = 858;
    }};
    # GONER, will be aTool before need again?
    Be.sc.trac = 'strac';
    Be.strac = {ohm:0,play:&acgtRs{
        $sp = me.cbu(R,'tingspot');
        !sp and return me&tsc,'notingspot','!t','B'
        sps&tracball = R;
        s&pa = 0.3;
        s&boc = 588;
    }};
    #c Rom tries R, catches errors
    # provide headings with pausibles,
    #  errors and s&N coming out
    #  T.* changes and chatter
    # < %Reis with error handlers,
    #   pausible
    # < er + Ring cursor
    me.Rom = &acgtptc{
        typeof t == 'object' and c = t
        !c and c = t
        typeof c == 'string' and c = {t:c}; c[c.t] = 1
        !hak(c,'t') and c.t = t
        if (c.t.substr(0,1) == '%') {
            c.t = c.t.substr(1);
            c[c.t] = 1;
        }
        t = c.t;

        # insist on %JRom enclosure
        !ps&JRom and c = {t:t,JRom:c}

        c.task ||= 'rovo';

        # < explore I by fraction
        c.wantsleep and c.ov = 0.279

        try {
            $r = me&Re,p,c;
            me&Ring,r;
            if (c.wantsleep) {
                if (!rc&b) {
                    #  || !rc&b.y.Display
                    ~nohisttosleep
                }
                else {
                    rs&sleeping = 'wanted';
                    if (1) {
                        # put through the rest of itself,
                        # it may have %sleeping things to do
                        delete rs&ov;
                        me&Ring,r
                    }
                    else {
                        me&Display,r;
                    }
                    #~slept: r.t, r.sc.ci, '>2 '+haks(r.sc).join(",")
                }
            }
        }
        catch (er) {
            $msg = er.message || er+'';
            $async = msg.match(/^async/);
            # can it sleep?
            $b = rc&b;
            if (b && by&Display) {
                # keep last display
                # < warn shadow?
                try {
                    rs&sleeping = 'errors';
                    me&Display,r;
                }
                catch (err) {
                    msg = '!sle! '+msg
                }
            }
            # < packdowns for whatever can't continue,
            #   doming marked through as async?
            #    keep some, G&T/thro may resync from B stack
            
            $n = G&Cye,[Ac&sip,'',{}];
            nc&s = msg;
            nc&er = er;
            # bunch of artifaces, < (t,$s)+
            er.tc and nc&M = er.tc
            
            ns&now = G&time;
            ns&A = A;
            ns&B = Gc&B;
            ns&p = p;
            ns&R = r;
            # to nearest dome with room to think about it
            $JR = me.cbu(p,'erN');
            $erN = JRs&erN;
            erN.push(n);
        }
        return rs&returns || r
    };
    #c Domingness
    me.Domingness = &acgtR{ return [
    # < is really %torun, which is really W:Pass
    # have wanting uphill showing where come
    # set off an experiential perspective:
    # A locality of thing availability!
        ['Doming','3',&acgtRs{
            me&walla,'bd:7.1h5,hu-7';
            if (Rs&Doming >= 3) {
                # W have packdowns
                Rs&unDoming ||= [];
            }
            
            me&tsc,"A."+Rs&Doming;
        },'ift,D'],
        
        #c %Gens save/make automata
        # see Be.sR
        # the part of Jing that is someone elses
        # A tracking its new self down
        ['Gens','25',&acgtRs{
            isC(s) and Rs&other ||= s
            # usu the s)%ball above that %plays
            $s = Rs&other;
            if (s && sc&el == 1) {
                # !%ting
                # ins pulls outs
                s = me&rollbs,R,'self';
                if (!s) {
                    s = Rs&self = G&Cye,Rs&other;
                    # new index at s/*
                    #   modifying original others instantly
                    s.y = {cv:sy&cv};
                    ss&z and ss&z = ss&z.slice();
                }
            }
            else {
                me&rollbs,R,'self';
                # comes from:
                Rs&ting ||= 1;
                # < make toW default behaviour
                #   sproutes have their reason
                Rs&toW = 1;
            }
        },'ift,D'],
        
        ['Gens+ting','31',&acgtRs{
            $Q = Rs&Q;
            $P = Qs&P;
            # download
            if (Qc&el < 3) {
                !P and return me&tsc,'wait%Q%P-only'
                Rs&self = me&Copy,R,Pc&s .c.s;
            }
            if (!Rs&self) {
                if (Qc&el == 9) {
                    # creation
                    Rs&self = G&Cye,[R.t,'',{},{}];
                }
                else {
                    me&tsc,'wait%ting','...'
                }
            }
            Rs&self and Rs&Save = 1
        },'ift,D'],
        
        # %Gens%Here R above ours load/saves its Elvisory
        ['Gens+self','31',&acgtRs{
            $s = Rs&self;
            !s and return
            $c = Rs&Gens;
            c == 1 and c = {ball:1,tightly:1}
            typeof c != 'object' and throw "Gens?"
            c.t = s.t;
            $t = delete c.t;
            c.s and throw "Gens.s!"
            
            $h = Rs&Here =
            n $t  $s:s,R
            # configure inside from out%ball,
            #   which %played s&R, creating us
            #    perhaps with big Doming beforehand
            ex(h.sc,c);
            # set freer
            delete Rc&dubquiet;
            Rc&dupl = 3;
        },'ift,D'],
        
        # general out/in%ball negiator
        ['Gens+Here','4',&acgtRs{
            me&rolltog,R,'%Gensing?',0 &&
                n Gensing  R %Gensing
        },'ift,D'],
        
        ['Gensing','7',&acgtRs{
            $p = Ry&up;
            $N = me&ioty,p
            me&tsc,"Yep"
            me&zu,"GeNN",N
        },'ift,D'],
        
        #c %Save
        # Rs&Q is for saving Rs&Here, which Liness
        ['Save','5',&acgtRs{
            !Rs&Here and return me&tsc,'noHere','!h','B'
            $h = Rs&Here = me&yfuture,Rs&Here;
            
            # want to have a %ting
            Rs&Saveting =
                # %ting%Save itself
                Rs&ting ? R :
                # %Save/%ting
                n $R.t  R %ting:W
            
            (Rs&boost||0) <= 0 and return
            
            # check in
            if (!hs&ball) {
                # the non-%ball process defines another
                # storable in-sphere
                hs&Here and h = Rs&Here = hs&Here
                else {
                    # < errors
                    return me&tsc,"looking-for-in%ball","Here!ball"
                }
            }
            hs&Lines = 3
        },'ift,D'],
        ['Save','71',&acgtRs{
            (Rs&boost||0) <= 0 and return
            
            $h = Rs&Here;
            if (!isC(Rs&Saveting)) {
                me&tsc,'!Sting',null,'G';
                return me&zu,"Savoir",Rs&Saveting;
            }
            $ting = Rs&Saveting = me&yfuture,Rs&Saveting;
            !ting || !tings&ting and return me&tsc,'Save!ting';
            
            $Q = tings&Q;
            $P = Qs&P;
            !P and return me&tsc,'!P'
            !Qs&ready and return me&tsc,'!ready'
            !h and return me&tsc,'!here'
            
            me&zu,'here',h;
            me&zu,'their',P;
            
            !hs&string and return me&tsc,'hs!string'
            
            me&introqua,[R,'diff'],'boost','@1';
            me&diffya,R,'diff',h,P;
            
            (Rs&boost||0) <= 1 and return
            
            if (!me&rollbs,R,'sent_string' ) {
                Rs&sent_string = Qs&string = hs&string;
                tings&_ting(Q)
            }
            Ps&string != hs&string and return me&tsc,'pushing'
            me&tsc,'pushed';
            delete Rs&Te.sc.boost
        },'ift,D'],
        
        #c %Elvisave sense grabber
        ['Elvisave','3',&acgtRs{
            Rs&rowish = 1;
            delete Rc&dubquiet;
            Rc&dupl = 3;
            
            # < o ^^%Gens^^%Gens(%Te)
            #   knowing %Te can be made
            $p = Rs&upward = me.cbu(Ry&up.y.up,'Gens');
            $el = me&introqua,p;
            pp = py&up;
            !pp and throw '!pp'
            $L = me&introqua,pp;
            
            me&bal,'Their',L;
            
            me&bal,'Here',s;
        },'ift,D'],
        
        
        ['Elvisave','4',&acgtRs{
            $t = Rs&Their;
            $h = Rs&Here;
            
            # make auto keep this thing's elvising
            # Their/.../Rs&Te is coming in here,
            # make it not part of *load

            # climb atop %ball/%Gens/R, of the same t
            $r = R;
            $N = me.cby(R,&r{ return ry&up && ry&up.t != r.t });
            # then up to the R%upward(%Te -> Their) we capture
            N = me.cby(N[0],&r{ return r == Rs&upward });
            # and make it a non-overwritable,non-leaver
            ts&pol = {
                carefullyTe: {
                    # this path in either t/h
                    forTepath: N.map(r => r.t),
                    either: 1,
                    # will cause t to have
                    nonleaving: 1,
                    nonoverwrite: 1,
                    # which could go as far as nonewt
                    #  to force talking about existing things
                    #  or onlynewt to make first-in locks
                }
            };
            
            # Their
            me&iostyle,t,0,'Look';
            me&iostyle,t,0,'Download' .map(&r{
                $v = me&input,h,'Thus';
                me&polout,v,r;
            });
            # Here
            me&iostyle,h,1,'Look';
            me&iostyle,h,1,'Upload' .map(&r{
                me&polout,t,r;
            });
            
            # keeps knowing last move,
            # < more via NzR
            $lo = Rs&loaded = Rs&polout_z || me&rollbs,R,'loaded',[];
            each iD lo {
                each i,lo Ds&z {
                    me&zu,'lo',lo,'';
                }
            }
        },'ift,D'],
        


        
        #c %iotest sense grabber
        # < wants to store an Elvising for itself,
        #   to be revamped by %Gens
        ['iotest','3',&acgtRs{
            Rs&rowish = 1;
            
            window.iodebug = 1;
            
            $c = me&tsc,"Double"
            i $c/van
            i $c/two
            i $c/two
            $t = me&tsc,"Three"
            i $c/$t
            i $c/$t
            $t = me&tsc,"Three"
            i $c/$t
            
            window.iodebug = 0;
            
            me&zu,c;
        },'ift,D'],
        
        
        #c JRom - safe/pausible R,
        #  handled errors and s&N
        ['JRom','3',&acgtRs{
            me&walla,'bd:2.1h5';
            me&domesticate,R;
            
            # 1 wave matter
            $c = Rs&JRom;
            
            # 2 self, from 
            $D = G&Cye,[R.t,1,{},{}];
            $j = me.cbu(R,'JRomD');
            $b;
            if (!j) {
                $b = me&rollbs,R,'JRomD';
            }
            else {
                j = js&JRomD;
                jy&tw ||= {};
                $b = jy&tw[R.t];
                jy&tw[R.t] = D;
            }
            Rs&JRomD = D;
            
            b and Dc&b = b
            b && by&tw and Dy&tw = by&tw
            Ds&amongst = b && bs&amongst || [];
            Ds&amongst.unshift(D);
            Ds&count = (b && bs&count || 0) + 1;
            D.t = ''+Ds&count;
            
            # 3 what doing
            if ((Rs&boost||0) < -1) {
                delete Rs&Te.sc.boost;
                me&tsc,'JRom-reset','reset','6';
                s&boc = '858';
                c.igV = 1;
            }
            elsif ((Rs&boost||0) < 0 || c.pause) {
                me&tsc,'JRom-paused','paused','6';
                s&boc = '888';
                s&bg = '#002';
                Rs&play and c.hidey = 1;
                Dc&b and c.wantsleep = 1
            }
            c.hidey and s&mah = 30; s&over = 2
            
            # 4 map matters for before/after
            # < down to the gate, know enough to know
            #   everything else (eg e does any further)
            $emto = {sN1:1s&N,sn4:4s&N};
            each kv emto {
                $har = Ds&watchar ||= {};
                har[k] = v.slice();
            }
            
            # 5 partition explosion collection
            $erN = Rs&erN = [];
            
            # 6 do innard
            $began = G&time;
            
            $r = me&Rom,R,'Rom',c;
            # out me&Rom returns in me&Rom
            Rs&returns = r;
            
            # pause if slow
            $max = rs&timetopause || 2.5;
            $delta = G&time,began;
            each tn Dy&tw {
                ns&delta and delta -= ns&delta
            }
            if (delta > max) {
                me&tsc,"("+delta+">"+max+")";
                me&introqua,R,{boost:-1}
            }
            Ds&delta = delta
            Ds&R = r;
            
            # 7
            # s&N
            each kv emto {
                $har = Ds&watchar ||= {};
                $was = har[k];
                $outi = [];
                $N = [];
                each in v {
                    was.includes(n) and continue
                    outi.push(i);
                    N.push(n);
                }
                !N.length and delete har[k]; continue
                # take, for nearest JRom only
                outi.reverse().map(i => v.splice(i,1));
                har[k] = N;
            }
            !hak(Ds&watchar) and delete Ds&watchar
            erN.length and Ds&erN = erN;
            
            # all but topmost should tend to sleep...
            me&Rom,R,'Domeds',{s:Ds&amongst,NzR:'Domed',glamp:9};
            
            # < A-ing slowly: order then consciousness
            #   for summary up the top
            Rs&down && Rs&down.reverse();
        },'ift,D'],
        #c Domed visually Jing R
        # < froth away lots of %balls
        ['Domed','3',&acgtRs{
            me&walla,0,'b:3.1';
            $t = me&domesticate,R;
            ts&hs = '635';
            Rs&sym = "";
            $p = Ry&up;
            # p%NzR cs=[D%Domed+]
            $D = s;
            $r = Ds&R;
            
            # 3 gauge of gauge
            # only latest or Te'd open
            if (Rs&glampi != null &&
                Rs&glampi > 0 && !Rs&Te.c) {
                $b = Rc&b;
                $sym = !b ? "-" : bs&sym || "?";
                tc&s = Rs&sym = sym;
                 return
            }
            # boost<0 and delete (if Te.d)
            if ((Rs&boost||0) < 0) {
                $Di = pc&s.indexOf(D);
                Di < 0 and throw "Di"
                pc&s.splice(Di,1);
                n deleted  s:deleted %fs:6,hs:594
                return
            }
            # Te'd stops delete
            Rs&Te.c and Rs&keeper = 1; me&tsc,'keeper','k','6';
            
            # 4 items of interest
            if (Ds&watchar) {
                # As&N we noticed grow
                Rs&sym += '^'
                each kv Ds&watchar {
                    n $k  $s:v,R %NzR:Attend
                }
            }
            
            if (Ds&delta && Ds&delta > 0.04) {
                $say = G&thime,Ds&delta ;
                me&tsc,'delta',say,6
            }
            
            # errors we caught!!!
            if (Ds&erN) {
                Rs&sym += '!';
                n Errors  $s:Ds&erN,R %NzR:Error
            }
            # oberve limits
            rc&N[0] != r and throw "not h"
            rc&ha and me&zu,'rc\&ha',rc&ha
            
            rs&sleeping && rs&sleeping != 'errors' and Rs&sym += 'á›'
            
            Rs&sym ||= '.'
        },'ift,D'],
        
        ['Attend','4',&acgtRs{
            $Y = s;
            
            $nth = Y.t == 'n' && Y.y.cv == 0.13;
            nth && Yc&s.t == 'Pass' and Rs&nthirteen = 1
            !Rs&nthirteen and Rs&keeper = 1
            
            n Y  $self:Y %R:Cit
        },'ift,D'],

        ['Error','4',&acgtRs{
            #Rs&rowish = 1;#
            $skull = 'â˜ ';
            $bigger = me&rolltog,R,{may:skull,tsc:'D',once:1},0;
            
            me&tsc,'message',sc&s,'d';
            
            each in sc&M {
                $n = me&zu,i+1,n;
            }
            
            (Rs&boost||0) > 0 || !bigger and return
            me&introqua,R,{boost:1}
            
            s&fs = 13
            
            n er  $self:s %R:Cit
            
        },'ift,D'],
        

        
        #c NzR, expirez
        # spread Rc&s=N[n+] to many rc&s=n
        #  they have a type that helps NzR or the thing above it
        #  do expirez
        ['NzR','4',&acgtRs{
            Rs&dubquiet = 1;
            # trims to 30s timeframe, not %keepers
            Rs&glamp and Rs&expirez = 30
            $t = me&domesticate,R;
            Rs&NzR+'s' == R.t and Rs&qt = 1
            Rs&qt and t.c.not = 1
            
            $p = Ry&up;
            $outi = [];
            each iY s {
                $t = Y.y == Y ? Yc&sip : Y.t;
                $z =
                n $t  $s:Y,R
                z.sc[Rs&NzR] = 1;
                # inners like a log tail
                Rs&glamp and zs&glampi = i;
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
            
            !z and ts&fs = 7
            0 < i && !Rs&qt and Rs&rowish =  1
        },'ift,D'],
        
        # expiry of care about old A
        # < kind of time we can pause
        # R(cs=[n+]) with r(cs=n)+ self-cleaning
        ['expirez','7',&acgtRs{
            $outi = [];
            each in s {
                $r = Rs&z && Rs&z.filter(r=>rc&s==n)[0];
                !r and continue
                # are %keepers
                rs&keeper and continue
                
                # give %began
                rs&began = me&rollbs,r,'began' || G&time;
                $much = G&time,rs&began;
                
                # things time out or overpopulate
                $out = much - Rs&expirez;
                $over = Rs&glamp && i >= Rs&glamp;
                over && out < 0 and out = Rs&expirez
                out < 0 and continue
                
                # < relative scales into styles
                $C = rs&C;
                out < Rs&expirez/4 and s&fs = 8; s&sat = 0.4
                out < Rs&expirez/3 and s&fs = 6; s&sat = 0.2
                out < Rs&expirez/2 and continue
                
                $Yi = s.indexOf(n);
                Yi < 0 and me&tsc,'nofindY'
                else { outi.push(Yi) }
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
        },'ift,D'],
        
        #c %WestCases
        ['WestCases','3',&acgtRs{
            me&walla,'bd:3.1h5';
            
            $n = Rs&Inn = me&Rom,R,'Search';
            Rs&_ting = ns&_ting;
            
            
            $Q = me&rollbs,R,'Quest';
            n t/lvhashave  R %ting:W,Quploadsc:Quest
            
            $c = {};
            me&rollbs,R,'Sampled';
            # while checking in, 
            me&rolltog,R,'Checkin',0 and c.Sampley = 2
            else { delete Rs&Sampled }
            Rs&Sampled and c.pause = 1; c.hidey = 1;
            
            $r = !c.pause && me&Rom,R,'%lvhashave',c;
            
            
            # r.sc will not roll when pause/sleep
            r && rs&Sampled and Rs&Sampled = rs&Sampled
            
            if (Rs&Sampled && Q) {
                $P = Qs&P;
                $h = Rs&Sampled;
                
                n here  $self:h,R %Cit
                n Pull  $self:P,R %Cit
                !P and return me&tsc,'P...'
                !h and return me&tsc,'h...'
                #me&introqua,[R,'diff'],'boost','@1';
                me&diffya,R,'diff',h,P;

                !me&rolltog,R,'Push?',0 and return

                if (!me&rollbs,R,'sent_string' ) {
                    Rs&sent_string = Qs&string = hs&string;
                    Rs&_ting(Q)
                }
                Ps&string != hs&string and return me&tsc,'pushing'
                me&tsc,'pushed';
                delete Rs&Te.sc.boost;
            }
        },'ift,D'],
        
       ##c wedness do next!
    =head1
    flav
       %ting:
         a search or put, any type
         explains G&ting
         < ting both sides of it:
           (/G/Wway=/W/way)/$wcs would G&way
           (/spot/ja=/W/js)/$W would /js/
           then poll Wormhole for everything
         get (< put) .4/5, highly surfable
          < unify for an area
           < become the living someone via /W/
         < are name claims, applying or retrieving
           what of/directory selfs, .t others
       everything is, look at it in stylehouse to edit
       
       < %ball format more
         all %string hidden
         < inheritable & auto Tie/roll
         < c&s protruded
         < c % sc division
       
       < merge %torun/%mund, convert %garbec
       the %mund is posting things around,
         including its own insides,
         see 'one big %ball, some of it grounded' ^
       
       tracks stored compilings, eg:
        /W/way/$w -> /W/Comp/$w
         or -> some collection of ways
           a g/(\w+)/(\d+) is such, looks like kv yaml
           is really lots of n $t  $s:... %of:way,%comment:...
       < bringing it back via G&ting /js/ or /way/
        < read our /W/Comp/$w_$dige.js
       
       primarily for:
        using %oph to build I
         < having Babz already done to blockquoted things
           by /wayz/, otherwise like /way/
         < including %Give deps, versions of way/W going into it
         < storage-specific metadata, see w:Writer
           could simply be in the local W:Office
           things to see changing out there to awake
       
       but also:
        translating old -> new ghosts:
          io.*, me.* into W with of:W but not W:of
           such are the new ghost objects
            as g/\w+/\d+ but with a 9,
            thence all of io is in one tidy packet,
            its source compiles out closer to you,
            its tests compile into Tests
          NutMachine probably wants conversion
            perl builds it atm,
             /js/j for acgts, etc
             using 1C&of=js instead of the n \'of:js'
       
       'specifically' for leaving 'GhoNut'
        !
        others involved:
     %Give - ghost versioning
       knowing exactly each I it ran with
       see W&Lis
     W&Lis
      magical W access syntax, via t
    =cut
    #c %mund = GhoNut / ForThe(MindInto) + ChangeInto
    # wensdine, generalise to 4
    # just ForThe new infrastructure,
    # then ForThe becomes Composited from what desires:
    # < provide specifics (ForThe) layout from W,
    # < Pass and Domingness
        # the 5
        ['mund','29',&acgtRs{
            me&walla,'hu:7';
            Rs&timetopause = 3418;
            # remotes
            # news from the old editor
            me&Rom,R,'GhodigWap';
            # newsroom behind the %ting
            Rs&Inn = me&Rom,R,'Search';
            # for that constant EleMento async
            Gc&ttl = 3600;
            
            # runtime
            me&Rom,R,'GhoNut';
            
            # etc
            #me&Rom,R,'WestCases';
            #me&Rom,R,'JRomnotes';
            # here-genera looking
            me&Rom,R,'Loscba';
        },'ift,D'],
        
        ['Loscba','3',&acgtRs{
            # watch for errors from that lv thing
            4s&hashavefail &&
                n hashavefail  $self:4s&hashavefail %R:Cit
            
            # sidechaining also ju compiles,
            #   A:u testing how we J-J mix I
            n A4smind  $self:A.4.sc.mind %R:Cit
            $f = A.5[4];
            n A54er  $self:f %R:Cit
            n A545er  $self:f.5 %R:Cit
        },'ift,D'],
        
        # the 4
        ['GhoNut','3',&acgtRs{
            me&walla,'hu:17,wi:1.7';
            s&bgh = '111';
            
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });
            n Elvito  R %Tool
            
            # user
            # < sums diges
            Rs&forth = me&Rom,R,'ForThe';
            
            # remix
            me&Rom,R,'ChangeInto';
        },'ift,D'],
        
        # make a bunch of %tings!
        # < all hoisting into ForThe, transport workbench
        ['ForThe','3',&acgtRs{
            #Rs&tingspot = 1;
            
            n ForThe  R %ting:W,Gens,tingspot
            #,MoreForThe
        },'ift,D'],
        ['MoreForThe','3',&acgtRs{
            n Stylehut  R %ting:W,directory:spot/je/
            n NutMachine  R %ting:W,directory:spot/ju/
            n Foogla  R %ting:w
            # random
            n Pass  R %ting:W
            
            # destinations are 5
            #  for /way/
            #   to start Rs&_ting from an eval
            n WayInto  R %ting:W,directory:Rew/
            #  for /js/ that must hack up a bit
            #   sweep eye into i
            n MindInto  R %ting:W,directory:Rejs/
            # < get that done now, to 6
            #S /@6
        },'ift,D'],
        
        
        
        # for a bunch of %tings
        # < and their %More ... %tings
        ['ForThe','4',&acgtRs{
            $N = me&ioty,R,'%ting' .map(n => ns&Q);
            # like G&ting,of,t
            # < usable from, is a known interface
            Rs&tin = &st{
                each in N {
                    nc&of == s && n.t == t and return nc&s
                }
            };
            # like A 8, returning a .5 (things depended)
            Rs&eight = &{
                $C = G&Cye,[R.t,''];
                each in N {
                    i $C/#nc&of/#$n:s
                    yas&dige = ns&dige
                }
            };
        },'ift,D'],
        ['Elvising','4',&acgtRs{
            me&tsc,"4Elvising",0,'B'
            me&zu,4s&elvising;
        },'ift,D'],
        
    #c 4 MindInto will/what to mix+how
    =pod
    %Gens forms a %MindInto
     tools to Mix Stylehut + NutMachine + more
      with sessions of map building on top
      selects what to include
      or edit, or delete
      knowing how it mixes already,
       if this of/t dige is included after:
    %ChangeInto mixes many to many:
     minimising regeneration tasks leaning on it
     writing W:MindInto or etc
    
    specifies generating new I
     pure javascript they need to start everything
     to get an A clearly built from scratch
     
    %ChangeInto is:
     gathering of ingredients forwarding
      I-mixing without encoder (W:js)
        ting.Merge.js
      playing %Give (deps) on the %Gens/anywhere line is drawn
        alt see 'using %oph to build I'
      answering the %Gens, which stores our result
    mixing any index, inc from & to
    =cut
        ['ChangeInto','33',&acgtRs{
            #  knowing the ForThe
            # < slep into:
            # open to check workings
        },'ift,D'],
        
    =pod
    I:
     < bits of StyleHut,
     < most of NutMachine,
     < any new I
    #   s/eye/i/
    I.w:
     < I:NutIns/G&ting becoming:
       auto hoist R:Search@4  into /js/$Search:
        G&tingup to make Rs&_ting etc at #runtime
        without io
        needs jquery, isC and G.t for G&time/Cye/thime/c/intag
        G&ting proxies Rs&_ting
        Rs&_ting proxies G&t
     + io and me at #runtime
     + A:n J as me.J is
     + t that looks at me.$i, me.Ja.$w
    =cut
        ['MindInto','304',&acgtRs{
            # wait for R/*%ball to kinda happen
            me&bewind,R and return
            
            # where to
            #me&bal,'That';
            
            # half-moved
            me&bal,'This','dropempty';
            # and its ...
            me&bal,'Compiling','eph';
            
            # where from
            me&bal,'Know';
            
            Rs&SupplyChain = 1;
        },'ift,D'],
        
        # < say how many whats are in there
        ['folder','29',&acgtRs{
            T.Mw = 'folder';
            $c = {may:'unfold',s:'+',tsc:'L'};
            $v = me&rolltog,R,c;
            $n = c.n;
            ny&cv = 0.01;
            ns&fs = 23;
            $wa = C;
            !v and s&fs = 8; Rs&nofurtherDisplay = 1;
            me&walla,'b:2.2';
        },'ift,D'],
        
        #c SC ~ as osc would have it
        ['SupplyChain','305',&acgtRs{
            T.Mw = 'SC';
            # wait for R/*%ball to kinda happen
            me&bewind,R and return
            
            # steps with a tingspot
            $Gs = Rs&balz.filter(r => !rs&eph);
            each ir Gs {
                # eg ForThe/Know/tings%ting, usu 404, mainly to:
                #  %folder the rest of the %tings inside
                $S = me&bal,'tings',{R:r,eph:1,folder:1};
                Ss&ting = 'W';
                # < imply %dir=F/K/ inwards but be F/K ourselves
                #   the kind of %ting that draws pointing inside
                #   its dir/t becoming the implied dir yonder
                #   a gravity of the wormhole
                # puts **%tings in ForThe/Know/*
                Ss&directory = R.t+'/'+r.t+'/';
                delete Ss&ball;
                me&tracto,r,'ball','ting',S;
                
                me&Ring,R,{und:r,ov:0.7};
                me&zu,'ahawou',rs&wou;
            }
            
            # steps flow upwards
            $As = Rs&balz.slice().reverse();
            $woudef = &c{
                return me&waidef,c,'',{k:'wou'};
            };
            $waia = &rc{
                c = woudef(c);
                !r and return
                # G already @7, use the one of it
                !rs&eph and delete c.b; c.gh = 'gh'
                return me&waier,r,c
            };
            $tip = &rc{
                c = woudef(c);
                return me&brackdown,r,c
            };
            each ir As {
                $l = As[i-1];
                $n = As[i+1];
                
                $la = waia(l,{b:1});
                $ra = waia(r,{b:1});
                $na = waia(n,{b:1});
                
                # G already @7, conclude
                if (!rs&eph) {
                    # it may be ready to feed to n
                    tip(r);
                    $N = ra && ra('co:ready','r') || [];
                    N && N.length and me&tsc,"Have"
                    # build ** into n
                    #   apply Cuploadism as they finish
                    # if That generates change... its product is saved
                    continue
                }
                
                # eg here's some %Comal electing the next %Comste
                #  with cha in itself but not its children
                # if fs&changey:
                #   ha('mot:cha');
                #   me.cbu(coy&up,&s{ 
                #       aha(sy&T,'wou')({mot:'cha',fro:'inside',co:co});
                #   });
                # if la:
                #   $ready = la('mot:cha') && !la('fro:inside')
                
                # @31 domecheck, from
                me&Ring,r,{inside:r,ov:0.31};
                
                # @32 doing, from
                me&Ring,r,{inside:r,ov:0.32};
            }
            
            s&boc = 588;
        },'ift,D'],
    ] };
    #c f-%ball/modulat
    # %ball suggested into/assumed from s)R%ball
    #  how processes create/sync their limbs
    #  the s storable, the R waking
    me.bal = &acgttsc{
        $R ||= Cy&R;
        $gaveC = isC(s);
        !gaveC and c = s; s = null
        c ||= {};
        typeof c == 'string' and c = G&peel,c
        c.R and R = c.R
        
        # r may exist
        $r = me&ioty,R,'ball',t [0];
        
        if (c.dropempty && r && !me&ioty,r,'ball' .length) {
            i Rc&s/-rc&s
            return
        }
        
        # create s
        if (!r && !c.dropempty &&
            (!c.maydo || me&rolltog,R,{maydo:t},0 )) {
            # rolling s if !r the next time, eg c.eph unattached
            s ||= me&rollbsc,R,'bal_tw_s/'+t;
        }
        
        if (s && !r) {
            delete c.dropempty;
            ex(c,{t:t,s:s,ball:1,tightly:1});
            r = me&Ret,R,c;
            if (Rs&ball && !c.eph) {
                me&input,R,rc&s;
                # < i $R/$r
                # < with ballio
            }
            rc&dupl = 5;
            me&zN,r;
        }
        if (r && gaveC) {
            R.sc[t] = r;
        }
        
        if (r) {
            ac(R,'balz',r);
            # sort ss&z to order of me&likez
            $li = Rs&balz.indexOf(r);
            $ro = Rs&balz[li-1];
            ro and me&zaft,R,ro,r
        }
        return r
    };
    
    # Rs&z moves t after r
    #  if not already somewhere after it
    me.zaft = &acgtRor{
        $roi = Rs&z.indexOf(o);
        $ri = Rs&z.indexOf(r);
        if (roi > ri) {
            Rs&z.splice(ri,1);
            Rs&z.splice(roi,0,r);
            Rs&z[roi] != r and throw "yos"
        }
    }
    
    # r moves into modulat n
    me.zuct = &acgtnr{
        rs&zuctedto = n;
        # represents s
        delete nc&s;
        fio(n,r);
    };
    # n (modulat) lifted from some ground into C:t
    # < combine with zuck/mez/polify for all-regrouping?
    me.modopt = &acgtRmn{
        !n and throw "modopt!n"
        $could = [T.Mw,null,Rs&M];
        each it could {
            $M = isar(t) ? t : me&Mw,R,t;
            $ni = M.indexOf(n);
            ni >= 0 and break
        }
        ni < 0 and throw "n not fground", could
        M.splice(ni,1);
        return fio(m,n.t,n);
    };
    # me&tsc into another modulat
    me.mtsc = &acgtmtsc{
        $R = Cy&R;
        $n = me&tsc,t,s,c;
        me&modopt,R,m,n;
        return n
    };
    # i $g/#$k/$d
    me.givi = &acgtgktd{
        isC(t) and d = t; t = d.t
        $hi = fio(g,k);
        $b = fio(hi,t,0);
        if (k == 'history') {
            # puts new top on history
            b and ac(d,'z',b);
        }
        return fio(hi,t,d);
    }
    #c modulata groupology/Km/Kn/label, sizo
    # the usual hierarchy:
    # top/groupr(r(gk))/groupology()/grouping(Km)/groupthing(Kn)acgttc
    # all openable
    # < each a -pi some other time
    
    # vertical label in g
    me.vlabinto = &acgtgc{
        $R = Cy&R;
        c ||= {};
        # qualify up g
        $name = me.cby(g) .map(n => n.t) .join("_");
        $q = {may:'label_'+name,s:c.s||g.t};
        c.tsc and q.tsc = delete c.tsc
        $ope = me&rolltog,R,q;
        q = me&modopt,R,g,q.n;
        qy&cv = 0.12;
        qs&ope = ope;
        if (c.opeg) {
            gs&ope = ope;
            if (ope) {
                $Km = me.cbub(g,'grouping');
                Km and delete Kms&fs
            }
        }
        # styles the vertical text, not the spacer it's in
        me&applystylec,qy&label||q,c;
        return q
    };
    # applies tsc/walls as per c or d(efault)
    # < use for rolltog taking .tsc, 
    me.applystylec = &acgtqcd{
        d ||= {};
        c ||= {};
        ex(d,c);
        d.tsc and me&tsc,q,0,d.tsc
        d.walls and me&walls,q,d.walls
    };
    me.opelabel = &acgtgc{
        c ||= {};
        c.tsc ||= 'y'
        c.opeg ||= 1;
        return gy&label = me&vlabinto,g,c
    };

    # groupology, openable
    me.opeology = &acgttc{
        $R = Cy&R;
        c ||= {};
        
        $g = G&Cye,[t,2,{},'hue:30'];
        c.walls == 1 and c.walls = 'bd:2.2h5'
        me&applystylec,g,c,{};
        me&opelabel,g,c.label;
        return g;
    };
    # grouping (Km), openable
    me.opeKm = &acgtgtc{
        $R = Cy&R;
        c ||= {};

        $Km = fio(g,t,[t,1,{},'grouping,ma:0.3,fs:8']);
        Kmy&up = g;
        me&applystylec,Km,c,{walls:'bd:1.4,hu:3'};
        me&opelabel,Km,c.label;
        Kmy&up = g;
        return Km
    };
    # groupthing (Kn)
    me.opeKn = &acgtgtc{
        $R = Cy&R;
        c ||= {};
        $Kn = fio(g,t,[t,1,{},'groupthing,ma:0.3,hue:-50']);
        Kny&up = g;
        me&applystylec,Kn,c;
        c.label and me&opelabel,Kn,c.label;
        Kny&up = g;
        return Kn
    };
    # size of anything control
    # < link to iteration of V(iew)
    me.opesizup = &acgtgc{
        c ||= {};
        c.opeif1 = 1;
        me&sizo,g,c;
    };
    me.sizo = &acgtgc{
        $R = Cy&R;
        c ||= {};
        c.opeif1 && c.len == 1 and gs&ope = 'is1'; return
        $s = fio(g,'size');
        ss&label = 1;
        c.len != null && c.len != 1 and sc&s = 'x'+c.len;
        return s
    };
    #c f-waiting for...
    # puts modulat talking of %waits
    me.waits = &acgttsc{
        !s and s = t; t = 'waits'
        # < this style could be all we need
        c ||= {};
        typeof c == 'number' and c = ""+c
        if (typeof c != 'object') {
            c.length == 1 and $tsc = c; c = {}
            else
            typeof c == 'string' and c = G&peel,c
        }
        c.tsc and $tsc = delete c.tsc;
        # c can be specifically about the wait
        # 1 key means $scgk:$waittype
        #  eg s&tracupload having .differ, needing .accept
        if (haks(c).length == 1) {
            $k = c.waits_sgk = haks(c)[0];
            c.waits_type = delete c[k];
        }
        $n = me&tsc,t,s,tsc;
        c.waits ||= 1;
        ex(n.sc,c);
        return n
    };
    
    # checks R's modulat talk for %waits
    # < named waves of
    me.beready = &acgtRk{
        $Mw = k || '';
        $N = me&Mwty,R,Mw;
        $Nx = {};

        # %acty:1 starts things, %acty:8 opens dialectic
        N = arou(N,'acty',Nx);

        # everything %waits is important
        # everything else is an error
        Nx.err = arou(N,'waits',Nx);
        delete Nx.err;

        each kv Nx {
            !v.length and delete Nx[k]
        }

        # is ready
        !(Nx.waits || Nx.err) and return 1
        # or not

        if (Nx.waits) {
            $situ = "waits("+Nx.waits.length+")";
            $ope = me&rolltog,R,{may:situ,acty:8,tsc:'y'};
        }

        if (ope || Nx.err) {
            me&zu,'Nx',Nx
            each in Nx.waits {
                me&zu,n
            }
        }
    }
    
    #c f-waitzo/solvent
    # of wait data, 
    #  similar to beready pooling modulat %wait
    
    # gh describes things we're waiting for
    # returns 1 if not waiting (no/empty gh)
    # < reverse that so: waitzo and return
    # < projecting the waits over there like grimp
    me.waitzo = &acgtRc{
        c ||= {beready:1};
        c = me&waidef,c,'k',{k:'waitz'};
        
        $gh = me&waicu,R,c;
        !gh and return 9
        
        # rendered modulata
        $g = me&brackdown,R,c,gh;
        me&walls,g,'b:2.2h3';
        
        gs&ope and me&nu,"Xwai",R.sc[c.k]
        
        c.solvent and me&waisolvent,R,c,gh;
        
        if (c.beready) {
            # any gh causes %waits, returns false
            gs&waits = 1;
            return me&beready,R,T.Mw
        }
        return 1;
    };
    
    # react to the state
    # dscif: {scgk:'tracting_good'},
    # arkfor: {r: {cb:&dr{
    me.waisolvent = &acgtRc,gh{
        gh ||= c.gh || me&waicu,R,c;
        !c.solvent and throw "!c.solvent"
        each i,sol c.solvent {
            $M = [];
            each tk sol.dscif {
                $N = gh.sc[t] && gh.sc[t][k]
                N and M.push(...N)
            }
            each ka sol.arkfor {
                each in M {
                    $v = n.c[k];
                    # eg a tracting_good sharing a row with an r
                    !v and continue
                    # < note in dy&brackdown
                    if (a.cb) {
                        a.cb(gh,v);
                    }
                    else {
                        throw "handle arkfor"
                    }
                }
            }
        }
    };
    
    #c brackdown - summarises a pool of data
    # brackdown - explore the dimensions
    # io joins from a display perspective
    # visual interactive group by
    #  is probably an io-sized layer on io,
    #   all about wandering through !C,
    #    many ways in/out of everywhere,
    #    hierarchies that may be
    # < plug in some graph database's visuals
    
    # < standardise Km/Kn modulata,
    #   drawing adjustable versions of them here,
    #   that can be used to generate/explain logic/collection
    
    # < more autothink, process knows the types
    #    without clicking into ope/opel
    #     which should divide tangles
    #   use this pile of types to course action
    #   clues for eg. how to get an r to have an scgk,
    #    or what variants of that scgk mean
    #    and whatever other types of things are involved
    #     esp hold/$r defeating changey/$r
    # < include d.c, which are all refs
    #   inform other k that they ultimately find an r,
    #    and use maths symbols for "complete subset of" etc,
    #     turn into r=twx4=%tracting_good
    #     tw being the way to separate the r
    # < X.ref(R) for mapping values to keyable uniqueness,
    #    refR being for yfuture updating the value persisted
    #    eg Ravelvis M + yfuture, non-string-name persistence
    #    (because RbitX already persisted it)
    # < venn diagrams of how many of this have that
    #   is an io.nz() modulata, making Km/Kn
    # < apart/together levelism of the types,
    #    wandering indexes, conflicts
    
    #c brackdown takes a look
    # < rename scgk %
    # < rename this which?
    # will be very useful for situating crammed meanings
    #  at the very wildest edge of things, where wheres where
    # < opesizup->sizo: func the Km/Kn Kn/w edges
    #   so they may show up to a few C.t,
    #    then expand
    # < fill with hooks, combine with KnowC?
    me.brackdown = &acgtRc,gh{
        $C = Rs&C;
        c = me&waidef,c,'k';
        if (gh && c.gh && gh != c.gh) {
            # < means subset of,
            #   is highlit or layout stuff adding
        }
        gh ||= me&waicu,R,c;
        
        $g = me&opeology,c.t,{label:{walls:'bg',tsc:'l'}};
        me&Mw,R,T.Mw .push(g);
        me&walls,g,'b:2.2h6';
        
        if (!gh) {
            me&mtsc,g,'empty',0,'6';
            return g
        }
        
        gy&waigh = gh;
        ghy&brackdown = g;
        
        if (gs&ope) {
            me&nu,'waiN',ghy&N;
            me&nu,"waigh",gh;
        }
        # < not C rebellion
        $nks = ['c','sc'];
        each i,nk nks {
            each kV gh[nk] {
                # hide fact of paths
                k == 'path' and continue
                # and the 1 in $k:1
                k == 'isness' and continue
                # size, may lead on
                $Km = me&opeKm,g,k;
                me&opesizup,Km,{len:hak(V)};
                
                if (Kms&ope) {
                    fio(Km,['ope',1,{s:":"},'hs:888']);
                    each tn V {
                        $rv = null;
                        if (nk == 'c') {
                            # avoiding ref as key
                            $rv = ghy&refs[t];
                            !rv and throw "invalid Kn refs: "+t
                        }
                        $tee = isC(rv) ? rv.t : t;
                        $Kn = me&opeKn,Km,tee,{label:{tsc:'y'}};
                        
                        $someC = 0;
                        each iw n {
                            # a wai row, eg mot:cha,
                            #  each may have other k
                            # where w.c is like a row:
                            $v = w.c[k];
                            isC(v) and someC++;
                            if (nk == 'c') {
                                rv != v and throw "Kn t(refs) not as wai.c."+k
                            }
                            else {
                                v != t and throw "Kn t not as wai.c."+k, v, t
                            }
                            i > 5 and break
                        }
                        $lab = Kny&label;
                        Knc&sortcv = 1;
                        someC &&
                            fio(Kn,['sym',112,{s:'C'},
                            'label,fs:13,lh:0.8,hs:757']);
                        
                        me&sizo,Kn,{len:hak(n)};
                        
                        
                        Kns&ma = 0.2;
                        if (Kns&ope) {
                            # < light up other k this has
                            each iw n {
                                $na = [g.t,k,t,i].join("'");
                                $wa = me&opeKn,Kn,na;
                                way&cv = 0.2;
                                # concentrate on each wai.c (one row)
                                $s = was&ope ? w : w.c;
                                !was&ope and na += '.c'
                                # has a sprawl limit
                                $nu = me&nu,na,s;
                                # usu. by R Ringing
                                me&zN,nu;
                                me&zuct,wa,nu;
                                was&dis = 1;
                                # see me.endome: if n ...R... that is:
                                #nuc&Rzucto = wa;
                            }
                        }
                    }
                }
            }
        }
        
        return g
    };
    
    #c waigh query
    
    # waier - around waighre, can hist
    #  vary gh:gh to rewaigh
    me.waier = &acgtRc{
        c = me&waidef,c,'';
        
        # from last time
        c.b and $l = me&ollbs,R,c.k+c.gh
        else {
            # or this time
            $l = me&waicu,R,c;
        }
        
        $la = l && me&waighre,l;
        return la
    };
    
    #   $la = waighre(gh)
    #   M[wai+] = la('t:k')
    #      ^ from gh.sc.$t.$k.*:i.*:wai
    #    ie the index t was bitted k by all these wai
    # may return:
    #   M[wai.c.$o] = la('t:k','co')
    #    returns that one column
    #      couldn't include rows without that column
    #   null if !M.length
    
    # < merge gh.c/sc, know here to ..., take ref as input
    # < producing another waigh, of matched
    #  < other sql happenings
    me.waighre = &acgt,gh{
        ghy&waigh != gh and throw "gh !y&waigh"
        $la = &ho{
            $whe = G&peel,h;
            $ok = 1;
            $M = [];
            each tv whe {
                # < nonfirst t must join the Ms
                #   or search within them,
                #    if where's wai/gh indifferent
                $S = gh.sc[t] || gh.c[t] || {};
                each kN S {
                    v != 1 && k != v and continue
                    M.push(...N);
                }
            }
            if (o) {
                $N = M;
                M = [];
                each i,w N {
                    $v = w.c[o];
                    v == null and continue
                    M.push(v);
                }
            }
            M.length and return M
        };
        return la
    };

    
    #c waigh access, grouping
    
    # interpretation of the c
    # usual names of the X and the gh
    me.waidef = &acgtcko{
        c ||= {};
        if (isst(c)) {
            c == '' and c = G&peel,c
            else {
                $v = c;
                c = {};
                c[k] = v
            }
        }
        (o) and ex(c,ex(o,c))
        c.k ||= 'wai';
        c.gh ||= 'gh';
        # for display
        c.t ||= c.k;
        return c
    };
    
    # %wou -> %wough, reusing %wough
    me.waicu = &acgtRc{
        c = me&waidef,c,'k',{k:'wou'};
        
        $gh = R.sc[c.k+c.gh];
        gh and return gh
        $X = R.sc[c.k];
        !X and return
        
        $N = me&Xwai,X;
        # group by any
        $gh = me&waigh,N,c;
        # which makes it more readable
        R.sc[c.k+c.gh] = gh;
        
        return gh
    }
    
    # wai N[d] -> gh
    #  ds&$ark.$key = N[d] with such
    # how io wants to compress tons of rows
    # but for wai, building k/v=[d+]
    # c usu waicu's, accessor for gh
    me.waigh = &acgtNc{
        c = me&waidef,c,'k';
        
        $gh = G&Cye,[c.t,1];
        ghy&waigh = gh;
        ghy&N = N;
        ghy&refs = [];
        each in N {
            each kv n.c {
                $S = gh.sc ||= {};
                # v sometimes object, d.c groups refs
                if (isob(v)) {
                    $vi = ghy&refs.indexOf(v);
                    vi < 0 and vi = ghy&refs.push(v)-1
                    v = vi;
                    S = gh.c ||= {};
                }
                S[k] ||= {};
                $l = S[k][v] ||= [];
                l.push(n);
            }
        }
        return gh
    };
    
    #c N = Xwai(X = aha(...))
    
    # wai each type of path at X.*
    # eg.
    #   ah(R,'waitz','tw_scgk_r',r.t,'tracting_good',r);
    me.Xwai = &acgtXc{
        $N = [];
        each path,v X {
            N.push(... me&wai,{v:v,k:path,name:'path',path:path} );
        }
        return N
    }
    
    # setter of {names:keys} into X.names = k{e{y=s
    # eg.
    #   aha(R,'waitz')({tw:r.t,scgk:'tracting_good',r:r})
    #
    # < get between R better?
    #   maybe do one big pile at the top,
    #    each r able to enter as such,
    #     perhaps using a template for "cares of r"
    #     debugality (of elvising would do) wants to know
    #     where the data came from
    #      while there is expense to spare
    #      brackdown sends hooks onto X.
    #   then waigh for/into each r
    #     triangling the hopes and dreams of the community
    window.aha = &Rt{
        return &s{
            $args = [... arguments].slice(1);
            isst(s) and s = G&peel,s
            $path = [];
            $bits = [];
            each kv s {
                # (tw:C.t)
                path.push(k);
                # (co:1, $co)
                v == '1' && args.length and v = args.shift();
                bits.push(v);
            }
            bits = [ ... bits, ... args ];
            # refs mean the end
            # < doubling path so X.z = nodes here, X.$path = onward 
            # strings at the end must turn into keys
            # < counters
            isst(bits.slice(-1)[0]) and bits.push(1); path.push('isness');
            
            ah(R,t,path.join("_"), ... bits, ...args)
        };
    };
    

    
    #c wai **{ -> N[d+]
    # deep hash with known paths/rows
    # < just wander in until C
    me.wai = &acgtd{
        $N = [];
        $wai;
        wai = &d,c{
            if (d.d == null) {
                d.d = 0;
                d.z = [];
                d.wholepath = d.path;
                d.path = d.path.split('_');
            }
            else {
                $up = d;
                d = ex({},d);
                c and ex(d,c);
                d.up = up;
                d.z = [];
                up.z.push(d);
                d.d++;
            }
            d > 10 and throw "manywai"
            
            $nextname = d.path[d.d];
            $islast = !d.path[d.d+1];
            if (!islast) {
                $eachable = isha(d.v) || isar(d.v);
                !eachable and throw "index!hash"
                each kv d.v {
                    $c = {k:k,v:v,name:nextname};
                    wai(d,c);
                }
                return
            }
            
            # d.v is beyond the path, as s
            # stack =~ io's row but for d not d.v
            #  since the meaning of here is usually:
            #   the key/params used to get through (d.k)
            #   then the final d.v,
            #     without being another stackbit
            #   < anything could be a value on the way down the path
            #     and be related to the parameters used to get the value
            d.stack = me.cby(d,null,&n{ return n.up });
            # the path as names (arks in io) with values
            d.c = {};
            each in d.stack {
                # the key used at this stackbit
                d.c[n.name] = n.k;
            }
            # last one aka s (ya out of io)
            #  from the same stackbit that found it via d.k
            d.c[nextname] = d.v;
            N.push(d)
        };
        wai(d);
        return N
    };
    
    #c trac Know/...%ball <-> Wild...%ting
    
    # %tracting MindInto/Know/**%ball waking up
    # endless loop of trac & ok <-> dependencies
    #  pulling into a mixage
    #  ghosts knowing wormholes
    # < include the flook/finput methods?
    
    # up/downable essential identity
    # W version
    Be.C.W = {
        scgk: 'dige',
    };
    # how to include it
    Be.C.inc = {
        scgk: 'el',
    };
    # %ting config
    Be.C.ting = {
        scgk: 'ting,directory,species',
        # dont need to %ting=W at the top?
        scdefault: {ting:'W'},
        # %tings nest to imply structure,
        #  these sc inherit from above
        # < cause Ravelvis to recreate if changed
        #   eg %ting must start fresh to add %directory
        scinherit: 1,
        scfor: {ting:{W:{
            # < plug this in to Cloadsc,
            #   < %ting using Cloadsc on its own:
            #      g=R,wp=Ry&up,w=R
            #    < deriving the display
            scdefault: {species:1},
            # look mode (ov<=4) implies:
            sclook: {species:5},
            # then the main %species we need to fully awake:
            scget: {species:1},
        }}},
        # wants 1 over the 4
        #  for the details under the main thing
        #  or does ForThe's %ting index/tooling abstract that?
        #   supposing you ask for Thing.1
        #   or you ask for Thing's %H (%ha/%dige),
        #     Thing.4 could have the answer,
        #      and have a %Ghostway to keep it up to date
        #     ThingsInHere.4 also, a big map
        #      which Lis must update, put forks in? or:
        #     Dev.4 + Dev/$Thing, a searchpath
        #      for who rides the chaos as thing grows
        #       a language weld happening
        #       shows where traits arose
    };
    me&BeCload;
    

    # trac happens via
    # < look more like RbitXing
    #    which wants to have posts of different height...
    # < or connect each %ting on the path
    #   up to a certain distance...
    #    should T.allow about going further than ...
    #   the things up the embryo...
    #   branches of %tings could be skipped?
    #    as far as the insides gravity is independent
    #      may stick around because you saw it once,
    #       culture style,
    #      or be mechanical exactitude eg I,
    #       things vanishing noted but immediately effective
    #     memory compresses, making usual shapes
    
    #c trac a Know/...%ball for MindInto
    
    # < editing the %ball's s.t breaks/vanishes
    #   click %ball reveals (lvhashave?)
    #    same t different %tag?
    #    this'd be a good place to start whaT'ing code:
    #     Xpath the modulat, look for its R:Display,
    #     playing back the scenario of the bug
    #     figure where they think to, turn on lvhashave fullness
    #   while:
    
    # Troom to be the top %tracting
    # local %tings hangout
    me.thespot = &acgtRt{
        $l = [t,'the'];
        $s
        each it l {
            $spot = t+'spot';
            s = me.cbu(R,spot);
            s and return s
        }
        me&waits,'no'+spot,'!t','B'
    };
    
    me.tracto = &acgtRktS{
        # through the spot
        $tracting = 'trac'+t;
        S and S.sc[t+'spot'] = 1
        S ||= me&thespot,R,t;
        !S and throw "nospot"
        $f = S.sc[tracting];
        f and return me&waits,"alreadytrac"+t,"oc:"+f.t+'.G='+f.y.G.t
        
        # we are outside the R:Know but can sc it
        $C = Rs&C;
        me&walla,'ba:2h3';
        # s%trac=ting)%tracting=1
        $s = Rc&s;
        ss&trac = t;
        
        
        # the organiser persists
        $abstracting = 'abs'+tracting;
        $F = me&rollbsc,R,abstracting;
        Fc&tracting = tracting;
        # who art coordinating
        Fy&G = R;
        Fy&W = S;
        # in the S=ForThe%ting is G=ForThe%MindInto
        #  ignore any %ting in there (%Gens)
        $insideW = me.cby(R,S)[1];
        insideW and Fc&traciggy = [insideW]
        Fy&top = F;
        Fc&Gtype = k;
        Fc&Wtype = t;
        R.sc[abstracting] = F;
        
        # so %tings notice upward %tracting
        S.sc[tracting] = F;
        # and so this %ball realises its flook etc.
        R.sc[tracting] = F;
        
        # waking up W or G about %tracting
        Fc&indive = &Rk{
            $f = R.sc[tracting];
            !f and throw "indive!tracting"
            me&ioty,R,'%'+k .map(&n{
                ns&rowish = 2;
                n.sc[tracting] = f;
            });
        };
    };
    
    #c tracarri for the %ting
    
    # W %ting@6 finds ^^%tracting
    #  copies it to its own %tracting
    # long distance inheritsc
    me.tracarri = &acgtRt{
        $S = me&thespot,R,t;
        !S and return
        # climb up to the spot until %tracting
        $tracting = 'trac'+t;
        $S = me.cbub(Ry&up,tracting,Sy&up);
        !S and return
        T.Mw = 'trac';
        $t = S.sc[tracting];
        $F = ty&top;
        each in Fc&traciggy {
            me.cbub(R,n) and return
        }
        
        if (ty&W != S) {
            if (t == Sy&up.sc[tracting]) {
                ~tracarri ahead: S.t
                T.wide = 'tracarri ahead of ^^tracmode';
                return;
            }
            throw "cbub^^%tracting!=fyW", S, t
        }
        
        # t = F at the top, then the previous f
        R.sc[tracting] = t;
    };
    
    
    #c tracintro - A:f for either
    # %trac* - W|G grow f and connect themselves
    
    # %tracting@6 either become, F -> f
    
    #  f starts for the parent or the entire trac-ing
    # and either can introduce the other,
    #  eg W reduces to G, G opens a W
    # we end up with a fy&ov for booting that connection
    #   which is in the domain of the particular G or W system,
    #   eg %ting:W,species:4 while checking out %MindInto/Know
    
    me.tracmode = &acgtRtc{
        $f = me&tracintro,R,t,c;
        
        # not chattery
        !me&beready,R,'trac' and return
        # having f, returned, means ready
        !f and return
        # waits for us to 2->3 it
        if (fc&ov == 0.2) {
            # both here + not chattery
            $readygk = 'trac'+t+'_ready';
            R.sc[readygk] = 1;
            $r = fy&G == R ? fy&W : fy&G;
            !r.sc[readygk] and return
            fc&ov = 0.3;
            # must come back so other lives ov=3 first
            return
        }
        # tracupload constantly, not immediately: waits
        
        return f
    };
    # ^ is a layer on v so we can return whenever
    me.tracintro = &acgtRtc{
        $tracting = 'trac'+t;
        $isting = R.sc[t];
        $k = isting ? 'W' : 'G';
        # t = previous f
        $t = R.sc[tracting];
        !t and return
        T.Mw = 'trac';
        # %tings gathering around somewhere
        # while persisting %tracting=f over (under) t
        $F = me&rollbsy,R,tracting;
        $unity = ty&W == R || ty&G == R;
        if (unity) {
            # tops stay f, creation on such type
            #  eg ForThe%ting or Know%ball
            # unity means "the top" for now
            $f = t;
            fc&ov = 0.3;
            F && t != F and throw "top changed f"
            t != ty&top and throw "unity !top"
        }
        else {
        if (t != F) {
            #~>3 rolling: k, R.t
            # double check via f tv
            $f = fio(t,R.t);
            # since 
            f != F && fy&up == F and me&tsc,'Fwasup:'+F.t;
            if (f != F) {
                Fy&up != t and me&tsc,"fupcha";
                # f may recreate to reset state
                if (F.t == f.t) {
                    me&tsc,'f-changed','*f'
                }
                else {
                    # < F = new fy&up
                    #   f moves in at low ov, aka:
                    #   sync elvising to new context
                    #   see mez&rename
                    me&tsc,'Freplace:'+F.t+'->'+f.t
                }
                F = t
            }
        }
        if (t == F) {
            #~>3 growing: k, R.t
            # grows f from spread F
            $f = fio(t,R.t);
            fy&up = F;
            fy&top = Fy&top;
        }
        }
        # the shared object, about each climbing
        R.sc[tracting] = f;
        
        #c A:f@0 connect either
        
        # keep Rs on f
        ['W','W_exp','G','G_exp'].map(&k{
            $r = f.y [k];
            !r and return
            try {
                r = f.y [k] = me&yfuture,r,R;
            }
            catch (er) {
                er.message.match(/^yfutured .+ not in RcN$/) and return
                throw er
            }
        });
        f.y [k] && f.y [k] != R and me&waits,"already-fy"+k; return
        f.y [k] = R;
        
        $ok = !isting ? 'W' : 'G';
        $F = fy&top;
        $type = F.c[k+'type'];
        $otype = F.c[ok+'type'];
        if (!unity) {
            t != fy&up and throw "t !fyup"
            tc&ov < 0.3 and me&waits,"fyupcov"; return
            # the previous thing on either side
            $op = fy&up.y [ok];
            !op and me&waits,"fyup!"+ok; return
            $p = fy&up.y [k];
            !p and me&waits,"fyup!"+k; return
            # op must be the type we expect,
            #  to look/input more of itselves
            
            #  the tops are sometimes op but never have op
            #$istop = F.y [ok] == op;
            !op.sc[otype] and throw "need "+otype
        }
        
        # f state
        #  usually a step can be made by either W/G
        fc&ov ||= 0;
        
        $yo = f.y [ok];
        # reset state per fy&$ok disappearance
        # < not inside %sleeping
        if (yo && Rc&N.indexOf(yo) < 0) {
            ~>9 disco: k,'->',ok, f.t
            me&waits,'disco:'+ok,0,6;
            # < mez&delete should do the delete-all
            #    el=2 input implies delete-all,
            #    which Ghostway/ing needs
            #   it would Rsync if R or s (finding refR) %ball
            i fy&up/-$f
            return
        }
        # or as usual,
        # W tends to wake first, !fy&G means initialise
        !f.y [ok] and fc&ov = was = 0
        
        # rync when Look/Create finds an r
        $lr;
        $rync = &r,how{
            !r and return
            r == lr and return
            lr = r;
            # eg W can find/create the fyG from fyupyG/f.t
            # which should become fy&[ok]
            $exp = f.y [ok+"_exp"];
            $got = f.y [ok];
            if (got) {
                #~>4 otherready: how, k, '->', ok, f.t
                if (exp) {
                    exp == got and delete f.y [ok+"_exp"]
                    else {
                        throw "not predicted "+ok
                    }
                }
            }
            
            # probably already r%tracting=f spread from upyG
            r.sc[tracting] ||= f
            [f,fy&up].indexOf(r.sc[tracting]) < 0 and throw "difftracting"
            
            # and is soon to be fy&[ok], where it should stay:
            exp && exp != r and throw "change exp "+ok
            got and got != r and me&waits,"r~got"; return
            #throw "change got "+ok
            !got and f.y [ok+"_exp"] = r
            
            # may be already
            # go to being entered/having been entered
            fc&ov < 0.1 and fc&ov = 0.1
        }
        $tych = &{
            if (ok == 'G') {
                otype != 'ball' and throw "enterG !ball"
            }
            else {
                otype != 'ting' and throw "enterW !ting"
            }
        };
        
        #c A:f@1 look/input for the other
        # < ongoingly also
        if (fc&ov <= 0.2 && !unity) {
            tych();
            # child find
            $flook = ops&flook;
            flook ||= ops&ball && &f,r,ok{
                $N = me&fabioty,op,[f.t];
                N[0] and return N[0]
            };
            !flook and return me&waits,"!flook" && me&zu,f
            $r = flook(f,r,ok);
        }
        rync(r,'Look');
        
        # Click (or so) to other
        if (fc&ov == 0) {
            $ope = fy&up == fy&top
                # from ball+tracting
                || Rs&openey
                || me&rolltog,R,{may:'^trac',acty:1};
            ope and fc&ov = 0.1
        }
        # Creates the other (either)
        #  even if we already see it
        #    must be repeatable (inputs != creates)
        #   to make sure everything happens that can...
        #   so we know all the outbound connections
        # < only want genesised if we really had to create them
        if (fc&ov == 0.1) {
            $direction = (ok == 'G' ? '<-' : '->');
            #~>6 Enter: ok, op.t, direction, k, f.t
            tych();
            fs&game = 'look';
            # child input
            $finput = ops&finput;
            finput ||= ops&ball && &f,r,ok{
                # returns the %ball without any Ringing
                #  which might be lies if ...
                return me&input,op,f.t;
            };
            !finput and throw "no finput"
            
            $r = finput(f,r,ok);
            
            # having from Looking or the input method,
            !r and me&waits,'connecting:'+ok+'%'+otype,'...'
            else {
                fc&ov = 0.2;
            }
            # if we didn't already see it
            !lr and fy&genesised = k;
        }
        rync(r,'Create');
        #c A:f@2 the idealised lifecycled potentials
        
        # check either y$ok and its type
        if (fc&ov >= 0.2) {
            # should be ready
            if (!f.y [ok]) {
                # wait for the other side to have a mind,
                # then put heads together
                fc&ov = 0.2;
                return
            }
            !f.y [k] .sc[type] and throw "f@2 !y"+k+"%"+type
            !f.y [ok] .sc[otype] and throw "f@2 !y"+ok+"%"+otype
        }
        
        # unity will not have p/op around here (skips to 3)
        
        # generalised notions of trac
        if (fc&ov > 0) {
            $con = me&rolltog,R,{may:'trac',tsc:'l',acty:8};
            if (con) {
                Rs&traccon = 1;
                $ab = T.Mw;
                T.Mw = 'trac-control';
                # clicks open to reveal controls
                me&zu,"control-f",f;
                me&rolltog,R,{may:'re2',tsc:'y',once:1} and fc&ov = 0.1
                
                T.Mw = ab;
            }
        }
        
        # each thing not chattery to 0.3
        if (fc&ov == 0.2) {
            # on startup
            #~>2 En2: k, '->', ok, f.t
            # check config
            #   was sent from here with their finput()
            me&tracupload,R,f,k,ok,type,otype;
            # < ongoingly also
            return f
        }
        
        # is off
        fc&ov < 0.3 and return
        
        # ongoing spread to either/* now
        k == 'G' and Fc&indive(R,type)
        
        # is on
        return f
    };
    #c tracupload info about W to G
    # expression inherits from the last W
    #  eg has only to say the difference
    #   from the last %ting configuration
    # tends to learn what's out there
    # < complain via low-level changzo
    me.tracupload = &acgtRf,k,ok,type,otype{
        # can do it from either end
        #  as if one is prosthetically Awake
        k == 'W' and return
        # at first:
        #  0 = W should give bits to G
        #  1 = W should same bits as G
        #   fatal: out-bitten by another
        #   probably inheriting from ry&up
        # then
        #  asks to give bits
        $load = {f:f};
        # the bits + remarks that matter
        $lasc = fs&tracupload;
        # initial guzzle
        !lasc and load.forming = 1
        # 
        load.forming && fy&genesised == 'G' and load.conform = 1
        # make the change
        # < elvis hoppering acceptance
        load.auto = load.forming || lasc.accepted;
        
        $F = fy&top;
        $ting = Fc&Wtype;
        $tracting = 'trac'+ting;
        load.type = ting;
        
        $g = fy&G;
        $w = fy&W;
        g != R and throw "cup !G"
        !g.sc[type] || !w.sc[otype] and throw "G/W type"
        
        # Thing = whole needs make Thing amongst Stuff about it
        #   Stuff our G/W system (typed %ball/%trac) isn't after
        #  ie ghost is Thinging to really know
        #    embedded in Stuff to know
        #   the Cing of it may not be all Thinging
        #    digitised known bits in a sea of analogue
        #     is how it sees itself and its other
        if (f != fy&top) {
            $p = fy&up;
            !p and throw "no up"
            $gp = gy&up;
            $wp = wy&up;
            # < see variation ^ v # many ghostbits per Thing
            $gp = fy&up.y.G;
            $wp = fy&up.y.W;
            # < see variation ^ v # many tings per Thing etc
            # < g not bound by F/**?
            $gp = me.cbub(gy&up,tracting,F);
            $wp = me.cbub(wy&up,tracting,F);
            !gp.sc[type] || !wp.sc[otype] and throw "cup G/W type"
            
            gp == wp and ~>8 converge: k, '->', ok, p.t+'/'+f.t
            gp == wp and return
        }
        
        # checks it has the non-.t details right
        #   for writing on the ghost
        # %ting inherits them, has explicit ws&$k
        # %ball implies them being inherited
        me&Cloadsc,load,g,wp,w;
        fs&tracupload = load;
    };
    #c Cloadsc for explicit/implicit expression realising
    #  as per wp upward, the last spready instructo
    #  of C.sc.* in a Be.C.$group
    # generating Alets to find completion
    #  g - description/upstream, must have a:
    #   gc&s - whose .sc differs:
    #  w.sc - reality .sc, possibly lies or news
    #  gw - .sc inherits to w.sc
    # scfor plays games after a given k:v
    # < tighten %ting args, entirely by Cloadsc
    # < generalise from sc
    # < show yup%ting <-> %ting difference usually
    #   apart from the .t, isn't in the subtle
    # < worth redoing somewhere... KnowC one-many
    
    me.Cloadsc = &acgtcg,wp,w{
        !c and throw "give c"
        $load = c;
        $f = load.f; # optional
        $s = g && gc&s;
        # bits to give G: nulls for things it needn't
        load.sc ||= {};
        # bits to give W: everything
        load.c ||= {};
        # of this type's group
        # < Wtype:* brings everything,
        #   to where osc watches osc
        $Kc = Be.C[load.type];
        $games = [];
        
        each i,k Kc.scgk {
            # on %ting%$k
            $got = w && w.sc[k];
            # which is inheriting ^^%tracting
            # or not, if many tings per Thing,
            #  needing more explicit bits in recipe
            #  but something weirder might be afoot
            $exp = wp && wp.sc[k];
            # or not if it doesn't do that
            !Kc.scinherit and exp = null
            # weaker exp than inherit
            if (exp == null) {
                $def = Kc.scdefault && Kc.scdefault[k];
                def != null and exp = def
            }
            # f can decide attr, or have them suited to:
            # ephemeral modes of a point in a game
            #  eg look intensely, look casually
            each i,kc games {
                !f and break
                $game = kc['sc'+fs&game];
                if (game && game[k]) {
                    $imp = game[k]
                }
            }
            
            $was = s && s.sc[k];
            # W says everything
            $v = load.c[k] = imp || got || was || exp;
            
            # %ting=W leads to more knowing
            $kc = Kc.scfor && Kc.scfor[k] && Kc.scfor[k][v];
            kc and games.push(kc);
            
            $value = got;
            # G implies what is implied
            if (exp != null && got == exp) {
                # not noted
                !was and value = null
                # or was explicitly something else
                elsif (was != got) {
                    debugger
                    throw k+' implied was !got'
                }
                else {
                    ~>7 redundant: g.t, '%'+load.type
                    value = null;
                }
            }
            # imp acts like exp
            imp && imp == value && imp == got && !was and value = null
            load.sc[k] = value
        }
        
        !s || load.noknow and return load
        
        me&Cloadloadsc,load,g,w;
        
        return load
    };
    #c Cloadloadsc - loads the load
    # {part of,with c=returned from} Cloadsc
    me.Cloadloadsc = &acgtcgw{
        $load = c;
        $s = g && gc&s;
        
        $differs = [];
            each kv load.sc {
            v == null and s.sc[k] != null and differs.push(k)
            else
            v != s.sc[k] and differs.push(k)
        }
        $lies = [];
        each ik differs {
            load.liesok and continue
            load.sc[k] == null and continue
            # we said something, it was something else
            s.sc[k] != null and lies.push(k);
        }
        
        # want extra carevision
        lies.length and load.auto = 0; load.lies = lies
        each ik differs {
            load.was ||= {};
            load.was[k] = s.sc[k];
        }
        
        if (differs.length) {
            load.differs = differs;
            # 
            # < Tool for pulling as branch
            #   something differ can understand
            #   all terrain replication vehicle
            if (load.conform) {
                # should not be changing
                load.auto = 0;
                me&waits,"recipe-doesnt-conform",'exp!',6
            }
            if (load.auto) {
                # enacts change
                each ik differs {
                    me&tsc,'~'+k,0,6;
                    $v = c.sc[k];
                    $was = s.sc[k];
                    if (was != null && v == null) {
                        ~>7 redundant: g.t, '%'+load.type
                    }
                    v == null and delete s.sc[k]
                    else {
                        s.sc[k] = v
                    }
                }
            }
        }
        each ik differs {
            load.is ||= {};
            load.is[k] = s.sc[k];
        }
        return load
    };
    
            

    #c Chavesc helps to groupfixtype
    # like KnowC for %balls
    # sets up Km/Kn modulata
    me.Chavesc = &acgtcw{
        !c and throw "give c"
        $load = c;
        # everything it has:
        load.c ||= {};
        $Kc = Be.C[load.type];
        $Km = load.Km = G&Cye,[load.type,1,{Kc:Kc},'grouping'];
        each i,k Kc.scgk {
            $got = w && w.sc[k];
            got == null and continue
            load.c[k] = got;
            $Kn = fio(Km,k,[k,1,{s:k},'groupthing,fs:9,mar:0.3']);
        }
        !hak(load.c) and delete load.Km
        else {
            $M = Kms&z ||= [];
            $n =
            m KnowC_K 1 $s:Km.t,K:1 %hs:684,fs:7,mt:-1,label
            ny&cv = 0.001;
            M.unshift(M.pop());
            me&walls,Km,'bd:1.4,hu:3'
        }
        
        return load;
    };
    me.groupfixtype = &acgtRk{
        !Rs&ball and throw "!ball"
        $s = Rc&s;
        # type group s.sc.*
        $load = {type:k};
        me&Chavesc,load,s;
        $Km = load.Km;
        !Km and return
        $M = me&Mw,R,'trac-attr';
        Kmy&cv = 0.4;
        M.push(Km);
        # adopt their %fix
        $N = me&ioty,R,['fix'];
        each in N {
            ns&fix != 'sc' and continue
            $Kn = fio(Km,n.t,0);
            !Kn and continue
            ns&zuctedto = Kn;
            delete Knc&s;
            $M = Kns&z ||= [];
            M.push(n);
        }
        Kmc&load = load;
        return Km
    };
    #c grype watches %ball/%fix
    me.grype = &acgtRkc{
        c ||= {};
        # %grypes can outlive a %tracting (untested)
        # < lineated to the %balls in-sphere (checked out)
        # < %balls having gear to express this with us
        $g = me&rollbsc,R,'grype/'+k;
        # roll Km per Rfuture
        gy&R != R and delete gc&Km; gy&R = R;
        $Km = gc&Km ||= me&groupfixtype,R,k;
        
        # history/$gk builds up, can be %changey
        if (c.w) {
            # R is auto-changey ghost
            #  eg %ball%tracting reflecting dige
            $load = {type:k,auto:1,liesok:!Rs&liesnotok};
            me&Cloadsc,load,R,null,c.w;
            each ik load.differs {
                $was = load.was[k];
                $is = load.is[k];
                $d = G&Cye,['Thing-has:'+k,1,{s:">"+was},'changey,histgk,fs:8,hue:2,bri:0.7'];
                me&walls,d,'b:2.2h666';
                ds&gk = k;
                if (was == is) {
                    # if waiting to apply the change
                    dc&s = "<"+load.c[k];
                    ds&bri = 1.3;
                }
                # puts new top on history
                me&givi,g,'history',d;
            }
        }
        
        !Km and return
        Kmc&g = g;
        
        # take interesting g/*/*:gk to their Kn(%fix
        # change history
        $N = me&ioty,g,['',''],['history',''];
        each id N {
            $Kn = fio(Km,ds&gk||d.t);
            !Kn and continue
            fio(Kn,d)
            dy&cv = 0.789;
        }
        
        return Km
    };
    #c gromps - projects into yonder grypes
    # without relying on them %tracting yet
    #  eg check child dige, sends trouble
    #  or !exists, input
    me.gromps = &acgtRtks{
        !Rs&ball and throw "!ball"
        # this R project*
        $g = me&rollbsc,R,'grype/proj';
        $reset = !fio(g,'o',0);
        R.t.includes('ick') && reset and ~>4 reset: R.t
        $go = fio(g,'o');
        # this projection
        $gt = fio(go,t);
        
        $ks = k.split(',');
        ks.length != 2 and throw "only 2-spheres"
        ks[0] != 't' and throw "for t,$scgk"
        # one $scgk, many R/$t
        $k = ks[1];

        # match against what we have
        # < should only be (%ting, but is implied
        #   we have no other stuff in the Know yet, but could
        #   supposedly the implications would change,
        #   as u climb
        $have = {};
        me&ioty,R,'ball' .map(&n{
            hak(s,n.t) and have[n.t] = n
        });
        
        $news = [];
        each tv s {
            $r = have[t];
            # < these should be elvised in there
            #   to sleep the pile. write these:
            #   e $r -proj-cha $lc
            $d = G&Cye,[t+"%"+k,1,{s:v},{proj:gt,nk:'sc',gk:k}];
            fio(gt,d);
            dc&R = R;
            if (r) {
                dc&r = r;
                $rs = rc&s;
                !hak(rs.sc,k) and ds&cha = 'new'
                else
                rs.sc[k] != v and ds&cha = 'diff'
                # < gone is dcR != yfuture at the receiving end
                #   with non-fatal not in Rc&N
                $og = me&rollbsc,r,'grype/proj';
                $ogi = fio(og,'i');
                # < Rname:
                me&givi,ogi,R.t,d;
                # >1 them, springs into lies fixing
                ds&cha && !Rs&noprojcha and ac(r,'trouble',d)
            }
            else {
                ds&cha = 'not';
                # create there
                $d = {may:'input_'+t,s:t,tsc:'y'};
                me&rolltog,R,d and me&input,R,t
                me&walls,d.n,'b:2.2h5';
                news.push(d.n);
            }
        }
        if (news.length) {
            # one thing here about the many not there
            $d = {may:'input_*',s:'Unhad:',tsc:'y'};
            if (me&rolltog,R,d ) {
                news.map(d => me&input,R,dc&s );
            }
            $n = d.n;
            ns&fs = 8;
            ny&cv = 0.4;
            news.map(d => me&modopt,R,n,d );
            me&walls,n,'b:2.2h5';
            me&mtsc,n,"\n";
        }
    };
    
    #c grimp - cross-pollinates grypes
    # dialects of R%grype/* conclude into fs&changey
    me.grimp = &acgtR{
        $g = me&rollbsc,R,'grype/proj';
        # i/R.t/$d%proj
        $N = me&ioty,g,['','','proj'],['i','',''];
        each id N {
            $Kn = null;
            # the groupthing.t we're going for
            $t = ds&gk || '?';
            each in Rs&grype {
                n == g and continue
                $Km = nc&Km;
                !Km and continue
                if (ds&nk && ds&gk) {
                    # < generalise from sc
                    ns&nk && ns&nk != ds&nk and continue
                    Kn = fio(Km,ds&gk);
                }
                else {
                    throw "grimp match "+d.t
                }
            }
            if (!Kn) {
                # may not have gk yet:
                #   make extra grype (usually for type groups)
                #   listens to all grypes for %groupthing/%changey
                $ge = me&rollbsc,R,'grype/sc';
                $Km = gec&Km ||= G&Cye,['may',1,{},'almost,grouping'];
                Kn = fio(Km,[d.t,1,{s:t+'!'},'almost,groupthing,fs:7,mar:0.3']);
            }
            Kns&almost and Kns&opa = 0.5
            # noted, might match history of this gk
            $r = dc&R;
            # < want things for fs&changey to be persistent
            $n = G&Cye,["Projected-from-"+r.t,7894,{projin:d},'dis:2'];
            n.t += " to s&"+t;
            me&walls,n,'b:2.2h666';
            fio(Kn,n);
            # < make namepath looking
            #   also if Mlimits dub all ^^^^ means parent loop
            #     make larger recycle symbol
            $up = fio(n,['fromabove',1,{s:'^'},'hs:999']);
            if (ds&cha) {
                # projected difference
                # noticing out of date from our memory
                ns&changey = 1;
                ups&fs = 13;
                fio(n,['projected-from',2,{s:r.t},'fs:6,hue:166,mat:-1']);
                fio(n,['projected-'+t,3,{s:">"+dc&s},'fs:8,dis']);
            }
        };
        Rs&traccon and me&nu,"grype/*",Rs&grype;
        each kn Rs&grype {
            # c&Km are display parts, non-persistent
            $Km = nc&Km;
            !Km and continue
            #Rs&traccon and me&nu,n
            $f = Rs&tracting;
            if (f) {
                # take any Kn/%changey as fs&changey
                $N = me&ioty,Km,['groupthing','changey'];
                each id N {
                    # < want things for fs&changey to be persistent
                    #   see 'these should be elvised in there'
                    if (fs&changey && dy&cv > 0.7) {
                        fs&changey = fs&changey
                            .filter(c => c.t != d.t)
                    }
                    ac(f,'changey',d)
                }
            }
        }
    };
    
    #c know about the Thing independent of the species
    me.lookating = &acgtW{
        $Q = Ws&Q;
        $s = Ws&Live;
        $Thing = G&Cye,[s.t,1,{},{}];
        if (Ws&species == 5) {
            Things&dige = ss&ha;
            o $s/W/*:s
            each in ays&s {
                ah(Thing,'Wind',n.t,ns&ha)
            }
            # < some piles reway, others remix
            #   some are way leading to many
            o $s/w/*:s
            each in ays&s {
                ah(Thing,'wind',n.t,ns&dige)
            }
        }
        elsif (Ws&species == 1 || !Ws&species) {
            # < can do similar for .4
            # < pointings that adjust for its compression
            each in sy&N {
                ns&W && !ns&z &&
                    ah(Thing,'Wind',n.t,ns&ha)
            }
            $dige = Qs&dige;
            !dige and throw "nodige"
            # %ha are 9, %dige are 12
            dige.length == 12 and dige = dige.substr(0,9)
            Things&dige = dige;
        }
        else {
        }
        return Thing
    }
    #c unifydin Swims Things
    $Cye = &s{
        s = G&Cye,s;
        s.y = {cv:s.y.cv};
        delete ss&z;
        return s
    };
    # Swim N into fresh D
    #  D is not a dome but the old C
    me.unifydin = &acgtDN{
        # the W:HutKitchen
        $ID = Cye(D);
        IDy&tw = {};


        # unifiers may have ground
        $Dnz = me&ioty,D,['']
            .filter(dW => !dWc&W && !dWs&W);
        if (Dnz.length) {
            # would be updated if we way the W,
            #  rather than plumb it indifferently
            # < find mirrors in We, keep over dup
            #   related to updating only Stylating,
            #     without loading siblings HutKichten/*
            me&zu,"extra_ground",Dnz;
        }
        #me&zu,"theee",ID;

        each id N {
            # the W:Stylating

            # have We things
            #  cW says Include with this W
            #  not src code sitting here,
            #  or sW saying included here
            $dWz = me&ioty,d,[''] .filter(dW => dWc&W);
            each i,dW dWz {
                $IW = IDy&tw[dW.t] ||= Cye(dW);
                IWy&tv ||= {};
                IWy&cv != dWy&cv and throw "cvs"
                ac(ID,'z',IW);

                each i,dt dWs&z {
                    $ty = IWy&tv[dt.t] ||= {};
                    $b = ty[dty&cv];
                    b and ac(IW,'overs',b)
                    b and IWs&z.splice(IWs&z.indexOf(b),1)

                    $It = ty[dty&cv] = Cye(dt);
                    dts&z and me&nu,"of/t/*",dt; return
                    ac(IW,'z',It);

                    # the origin of everything is very important
                    $Wa = dts&Wavel;
                    $l = [d.t];
                    Wa and l.push(Wa.split('/'))
                    Its&Wavel = l.join('/');
                }
            }
        }
        each i,IW IDs&z {
            IWs&overs and IWy&overs = delete IWs&overs
            tvsortz(IWs&z);
        }
        return ID
    };
    #c opeuni
    # looks at a compiled W
    me.opeuni = &acgtDN{
        $R = Cy&R;
        $Dg = me&opeology,D.t,{walls:1};
        Dgs&dis = 1;
        ac(R,'M',Dg);

        if (N) {
            # say sources
            # < make %Wind (for .5)
            $Km = me&opeKm,Dg,'src',{};
            each iW N {
                $P = Wy&P;
                if (P) {
                    # is a %ting %Live
                    $Wi = Dy&Wind ||= {};
                    Wi[W.t] = Ps&dige;
                }
                else {
                    me&waits,"!P:"+W.t;
                    me&mtsc,Km,'hasnoP','!P','G'
                }

                $Kn = me&opeKn,Km,W.t,{label:{}};
                Kns&fs = 7;
            }
        }

        each i,IW Ds&z {
            $Km = me&opeKm,Dg,IW.t,{};
            Kms&fs = 12;
            Kms&hue = 160;
            Kms&bri = 1.4;
            Kms&dis = 1;
            #n $IW.t  $s:IW,R %ball,tightly,reneg,refpool

            tvsortz(IWs&z);

            each i,It IWs&z {
                $Kn = me&opeKn,Km,It.t,{label:{}};
                Kns&fs = 7;
                if (Kns&ope) {
                    Kns&fs = 11;
                    Kns&dis = 1;
                    $dis = me&zu,"It",It;
                    me&zuct,Kn,dis
                }
            }
            each in IWy&overs {
                # < tested
                $Kd = Kmy&overs ||= me&opeKm,Dg,'dup';
                $Kn = me&opeKn,Kd,n.t,{label:{}};
                fio(Kn,['from',2,{s:(ns&Wavel||"?")},{fs:7,deco:1}]);
                if (Kns&ope) {
                    Kns&fs = 11;
                    Kns&dis = 1;
                    $dis = me&zu,"It",It;
                    me&zuct,Kn,dis
                }
            }
        }
        return Dg
    };
    #c %ball%tracting%Compiling plots updates
    # for Compositing of/other tings
    # Lis R life of %Search%_ting(Q)/G&ting/G&t
    # extra tricks here
    
    # < rename oscty
    # local variables/hierarchy
    # as per some scheme
    $tracin = &Ry{
        $y ||= &{};
        me&ioty,R,'ball' .map(&r{
            $rf = rs&tracting;
            !rf and return
            rs&ignore and return
            y(r,rf);
        })
    };
    me.Wrongingness = &acgtR{ return [
        # %trac*
        
        # in closing
        ['ball+tracting+Compiling','67',&acgtRs{
            T.Mw = 'trac';
            $f = Rs&tracting;
            $om = Rs&Compiling;
            omy&top != R and return
            #~>7 gets ov: R.t
            
            if (omc&ov == 0.7) {
                # %dige-ish group again
                #   possibly after %ting discovers our change
                # < into the changelog
                # ! may break motivation to percolate changes
                Rs&liesnotok = 0;
                #$g = me&grype,R,'W',{w:Thing};
            }
            
            # < this kind of thing probed in
            #   whatever happened to %Tool?
            #   has %Doming to play on
            if (0 && sy&top == s) {
                ~>2 Plabic: R.t
                $h = Rc&N[0];
                $N = hs&clu;
                $ma = arou(N,&s{ return s.t.includes('Compala') });
                me&nu,"clu",ma;
            }
            
        },'ift,D'],
        
        # any co
        ['ball+Compala','37',&acgtRs{
            me&bewind,R and return
            T.Mw = 'Comp';
            
            me&waitzo,R,'wou';
            #R.t == 'Stylehut' and me&zu;
            # < until wou%digish == uou,
            #    unlocks more entropy
            #     winds up %Compala %Compiling c&ov
            
        },'ift,D'],
        ['ball+Compala+Comread','293',&acgtRs{
            T.Mw = 'Comp';
            ac(R,'inheritsc','Comread');
            $p = Ry&up;
            if (ps&Comread) {
                me&introqua,R,{boost:-1},'@1'
                me&Tie,R,'boost';
                (Rs&boost||0)< 0 and Rc&nofurther = 1; return Rs&Comread = 0
            }
        },'ift,D'],
        
        #c Comread
        ['ball+Compala+Comread','324',&acgtRs{
            T.Mw = 'Comp';
            $p = Ry&up;
            ps&Comread and return
            $g = me&opeology,'%Comread',{walls:1};
            ac(R,'M',g);
        
            $Ready = pc&s;
            $ste = sy&ste;
            !ste and return me&zu,"!ste",s
            $r = stey&V;

            $F = sy&f;
            $co = stey&co;
            $f = coy&f;
            if (f != F) {
                # < tested
                me&mtsc,g,'abandon',0,'G'
                o $Ready/-$s
                me&Rsync,p;
                return
            }
            rs&twoready = 1;
            
            if (gs&ope) {
                # Lines the %ball we're on, mostly hidden
                if (!me&rollbs,R,'string' ) {
                    $st = me&Copy,R,s,{ball:9,Lines:3,ov:8};
                    !sts&string and throw "!string"
                    Rs&string = sts&string
                }
                
                # < W might Ws&P the last Ws&Qs&P it saw...
                $W = fy&W;
                $Q = Ws&Q;
                $P = Qs&P;
                me&diffya,R,'Wover',R,P;
                
                # put it on disk
                me&nu,"Wing",W;
                $M = Ws&MoreLate ||= [];
                $te = s.t+"_new";
                m $te  R:1 %ting,toW
                
                me&nu,"Gensup",me.cbub(R,'MindInto')
                
                $Ws = me&ioty,W,['ting'],[te] [0];
                
                $i = ss&z[0];
                me&nu,"Sandsz",ss&z[0];
                # < has its own islands, also %tracting
                #   from the That, not Know
                #   two sets of Gs to conjoin with %traccout?
                =pod hmm yes.
                   probably something like that
                 going back to %MindInto
                  has heaps to do.
                  once this is stored again we want to link it into a /js/ name
                  the %tracting-cha/%Compilings game
                   is one of many tasks flying around
                  
                   stop/sleeping the %tracting when -> %Compiling
                    except to game more info and check again just before writing
                    
                 Know -> That,
                   except leaf nodes (which compile into others)
                 being G before/after our compilation
                 ~Know are sources changing
                 ~That is us introducing changes we can preempt
                 
                  that how to express difference in a storable way,
                    so we can wake/sleep areas of our process
                    while they are supposedly rolling over
                   is still floating
                  freezing the waitzo modulat would almost do...
                   diff it if waking up again.
                  thats what they need everywhere...
                
                =cut
                if (Ws) {
                    $Qs = Wss&Q;
                    $Ps = Qss&P;
                    Qsc&el != 9 and me&diffya,R,'Wownder',R,Ps;
                    else {
                        me&nu,"Other",Ws;

                        if (!me&rollbs,R,'sent_string' ) {
                            Rs&sent_string =
                            Qss&string = Rs&string;
                            Qss&parent = Pss&dige;
                            Wss&_ting(Qs)
                        }
                        Pss&string != Rs&string and return me&tsc,'pushing'
                        me&tsc,'pushed';
                    }
                }
                
                #ac(W,'More',s.t+"_new");
                me&zu,"streng",['<<<<',Rs&string]
            }
            
            #R.t == 'Stylehut' and me&zu;
            # < until wou%digish == uou,
            #    unlocks more entropy
            #     winds up %Compala %Compiling c&ov
            
        },'ift,D'],
        
        #c ste yco yW we shall Mix
        ['ball+Compala+Comste','34',&acgtRs{
            me&bewind,R and return
            
        },'ift,D'],
        ['ball+Compala+Comste','326',&acgtRs{
            T.Mw = 'Comp';
            
            #c 
            Rs&twoready and 'result held by Comread'
            else
            if (Rs&readytwo) {
                me&tsc,'Heur',0,'G';
                
                $Co = sy&co;
                $F = Coy&f;
                $W = Fy&W;
                $ge = Fy&G;
                
                # %readied (D/*) compile %Ready (D)
                $D = Rs&readied;
                Ws&Live != D and me&tsc,'split',0,'G';
                
                $N = me&ioty,R,'Comste'
                # have hacks while they are %Comste
                # < copy into This/$t/{origin,comp} meanwhile
                #   you would figure out what Know/* they are from
                #   to resume/complete its process
                each ir N {
                    $d = rs&readied;
                    $S = rc&s;
                    $co = Sy&co;
                    $f = coy&f;
                    $w = fy&W;
                    $g = fy&G;
                    $hs = me&ioty,g,['hack'];
                    hs.length and me&nu,'hacks',hs; me&waits,'hacks';
                }
                N = N.map(r => rs&readied);
                
                $ID = Rs&Ready = me&unifydin,D,N;
                me&opeuni,ID,N;
                
                !me&beready,R,'trac' and return
                
                # done, appear in a Ready/$ID)%Comread
                $om = me.cbub(R,'Omplier');
                aha(om,'wou')({elvism:'Ready',ID});
                #me&nu,"Allready",N[0];
                #me&nu,"ID",ID;
                
                # which sets our s%twoready
                IDy&ste = s;
                # get someone to apply it while f same
                # < recompile on source change
                IDy&f = F;
                
                return
                $Km = me&opeKm,IDg,'todo',{};
                $Re = me&opeKn,Km,'%Ready',{label:{}};
                me&zu,"Vism",Re;
                if (Res&ope) {
                }
                
                
                # look up each thing in:
                # see how the things should mix
                #   to reduce the load to:
                # hacking each W as per ...
                # draw attention to hacks on the inside
        
                    # any fy&Gc&s.sc.* unknown may be instructions
                    # fy&W may have access to:
                    # < Search%Mix.W low level tv mixage
                    #   should mix %ting=js|W
                    #     Ws&I/$of/$C as $W/$of/$C
                    #     and maybe way can get en-I-ed as well?
                    #   would be where I needs bootstrapping
                    #    from a dozen few-thousand line /js/
                    #     to a few dozen thousand line /W/
                    #      with some Babzing before it I's too
                    #      so we have a bunch of ghost to show for it
                    # they want those instructions applied tho
                    #   backup system if not simple el=1
                    # < bring on holding A.I = W:Isomewhere,
                    #   should have all onward
                    
                    # so we put it somewhere besides Live,
                    # while mixing + hacking things
                    # Know has Treat?
            }
        },'ift,D'],
        
        #c Compala+Comste
        # ste yV = R%Comste
        # readies sequences of ...
        ['ball+Compala+Comste','32',&acgtRs{
            me&bewind,R and return;
            if (sy&top == s) {
                if (Rs&readied) {
                    $ha = aha(R,'wou');
                    $N = me&ioty,R,'Comste';
                    $z = [];
                    N = arou(N,&r{ return rs&readied },z);
                    N.length and ha('scgk:readied,fro:inside');
                    else {
                        Rs&readytwo = 1;
                    }
                    N.length and me&nu,'still',N
                }
            }
        },'ift,D'],
        ['ball+Compala+Comste','31',&acgtRs{
            me&bewind,R and return;
            T.Mw = 'Comp';
            ss&count ||= 0;
            $le = ss&count++;
            # part of pile $co**
            $co = sy&co;
            # stey&coy&W we shall Mix
            $f = coy&f;
            $p = Ry&up;
            p = ps&Comste && p;
            
            # this wou-gh, ha in, la out
            $ha = aha(R,'wou');
            $l = me&ollbs,R,'wough';
            $la = l && me&waighre,l || &{};
            
            if (sy&top == s) {
                # so we can start with empty la:
                ha('isness:mo');
                # do insiders first signal,
                # only if many things in one %Compiling
                #  not already solved by %Comal
                #   starting to Mix from cha tips
                !la('mot:later') and ha('mot:ready')
            }
            
            # spready readyingness
            la('mot:ready') and Rs&readying = 1
            p && ps&readying and Rs&readying = 1
            if (Rs&readying) {
                if (la('redialy')) {
                    ha('redialy');
                    $W = fy&W;
                    $t = Ws&Live;
                    Rs&readied = t;
                }
                else {
                    # < give fy&G/W some time to have game=...
                    #   ensuring it on the way back (Thing?)
                    # alters the %ting but supposedly it's ours,
                    #  and we will sleep til its ready
                    fs&game = 'get';
                    ha('redialy')
                }
                # < watch going non-ready, if it ever would
                #     drops away 1 depth per life?
            }
        },'ift,D'],
        
        # $om/seq/$ste%Comste** mirrors ready %Comal**
        # they inherit %Compala
        # then @3 it %Comste
        ['ball+Compala+Comste','307',&acgtRs{
            ac(R,'inheritsc','Comste');
            $co = sy&co;
            $N = me&ioty,co,'';
            each in N {
                # see Compala@3 re Sy&co -> %Comste
                $r = me&input,R,n.t;
                $S = rc&s;
                Sy&co && Sy&co != n and throw "rehandle co"
                Sy&co = n;
                Sy&up = s;
            }
        },'ift,D'],
        
        #c from om
        # $om/seq/* does Some:n/First:m before Later:n/Some:m
        # now that these things have emerged as changing all at once
        # probably in order already
        # may result in endless wait, then might choose to start:
        # < smallest changes and/or deepest/widest inclusion first
        # < include back and forth until settled?
        #   if inclusion changes behaviour of W its in,
        #   once we start compiling u for processes out there
        #   esp. n a using u a to define itself
        ['ball+Compala+Omplateau','34',&acgtRs{
            s&hue = -30;
            me&bewind,R;
            $N = me&ioty,s,[''] .filter(n => ny&co);
            $h = {};
            each in N {
                $M = me&ioty,n,[''] .filter(n => ny&co);
                $b = h[n.t];
                h[n.t] = n;
                # n.t > m.t
                b and aha(by&V,'wou') ({mot:'later',fro:'inside',ste:n});
                each im M {
                    $b = h[m.t];
                    # let this n know if its m becomes n later
                    h[m.t] ||= n;
                    # n later if m also n
                    b and aha(ny&V,'wou') ({mot:'later',fro:'inside',ste:b})
                }
            }
        },'ift,D'],
        
        # ready %Comal -> $om%Omplier %wou -> $om/seq/%Comste
        ['ball+Compala+Omplier','33',&acgtRs{
            $l = me&ollbs,R,'wough';
            $la = l && me&waighre,l;
            if (la) {
                $MixN = la('elvism:seq','Mix');
                each i,co MixN {
                    # < should input seq, be able to return r
                    #   if not r%Comste@31 or something
                    $seq = me&input,R,'seq';
                    seqs&Omplateau = 1;
                    $r = me&input,seq,co.t;
                    S = rc&s;
                    Sy&top && Sy&top != S and throw "rehandle seq top"
                    Sy&top = S;
                    # %Compala@3 this into %Comste
                    Sy&co && Sy&co != co and throw "rehandle seq co"
                    Sy&co ||= co;
                }
                $IDN = la('elvism:Ready','ID');
                each i,ID IDN {
                    $Ready = me&input,R,'Ready';
                    $r = me&input,Ready,ID;
                    rs&Comread = 1;
                }
            }
        },'ift,D'],
        
        #c Compala+Comal, hoisting updates
        # < each update leading to the next
        # C.y side,size,why,whyre
        # C.c 'cuh'
        # C.sc 'see'
        
        # enter thinking into wai:%wou
        ['ball+Compala+Comal','31',&acgtRs{
            T.Mw = 'Comp';
            # %Comal=co cell
            $r = sy&G;
            $f = sy&f;
            $co = s;
            # waigh:wou from last time, feedback loop
            #    experience -> notion, notion -> etc,
            #    many nodes out of time etc
            $l = me&ollbs,R,'wough';
            $la = l && me&waighre,l;
            
            $ha = aha(R,'wou');
            
            if (fs&changey) {
                ha('mot:cha');
                # mot:cha affects all parents (dependers)
                # < wants to spready very slowly so we can grok
                #   whether real change or not by then...
                me.cbu(coy&up,&s{
                    # sanity
                    me&yfuture,sy&T,R;
                    aha(sy&T,'wou')({mot:'cha',fro:'inside',co:co});
                })
            }
            
            if (la) {
                $ready = la('mot:cha') && !la('fro:inside')
                if (ready) {
                    ha('mot:ready');
                    $K = Rs&Compala;
                    !K and throw "!Know"
                    # place at top of this om**
                    $om = me.cbub(R,'Omplier');
                    #me&nu,"om",om
                    # as opposed to $om/all/$co == sy&top
                    #me&nu,"top",sy&top
                    # and not as far as $Know%ball%Compiling
                    #me&nu,"Compala",Rs&Compala
                    aha(om,'wou')({elvism:'seq',t:co.t,Mix:co});
                }
            }
            cos&count ||= 0;
            $le = cos&count++;
            
        },'ift,D'],
        
        #c R%ball%Compala** are %Comal|%Comste|%Coat
        ['ball+Compala','291',&acgtRs{
            ac(R,'inheritsc','Compala');
            Rs&fixatfour = 1;
            T.Mw = 'Comp';
            
            if (sy&G) {
                # about a fy&G that is %Compiling
                $r = sy&G;
                rs&Compala and throw "G also %Compala"
                !rs&Comal and throw "G no %Comal"
                rs&Comal != s and throw "%Compala(s not its %Comal"
                # Thinging in a pile of W/G sense
                sy&T = R;
                Rs&Comal = s;
            }
            elsif (sy&co) {
                # about a %Comal that is that is %Compiling
                $co = sy&co;
                $r = coy&T;
                !r and throw "yco!yT"
                !rs&Compala and throw "T not %Compala"
                # View of instruction, yco to yT/G/W, 
                sy&V = R;
                Rs&Comste = s;
            }
            elsif (sy&ste && sy&f) {
                # Views depending on a form
                $ste = sy&ste;
                # sty&V is as above, but can't be checked
                #  via yfuture because this R%ball
                #  happens before others may be started
                Rs&Comread = 1;
            }
            else {
                # something else hanging around
                Rs&Coat = 1;
                me&tsc,'notacomp','-','d'
            }
        },'ift,D'],
        
        #c A:f@47 %Compiling waits -> co)%ball%Compala
        
        # omy&top%Compiling sleepology, on top of ...
        ['ball+tracting+Compiling','64',&acgtRs{
            T.Mw = 'trac';
            $f = Rs&tracting;
            $om = Rs&Compiling;
            omy&top != R and return
            
            # Plabic graph
            $n = me&tsc,'Glabab';
            ns&hue = 80;
            ns&fs = 12;
            ns&dis = 1;
            ny&cv = 0.2;
            
            # A %ball%Compala
            $m = me&bal,'Om',om;
            me&zuct,n,m;
            # inheritsc:
            ms&Compala = R;
            # at the top:
            ms&Omplier = R;
            
            # checking its ingredient pile is ready every time
            # if remembering but not actually doing the Compile:
            Rs&Compiling_waits &&
                ah(R,'waitz','susp','Compiling')
            
            each ir oms&N {
                rs&coready and continue
                ah(R,'waitz','tw_scgk_r',r.t,'coready',r);
            }
            
            if (!me&waitzo,R ) {
                ms&sleeping = 1;
                ns&bgh = '000';
                return
            }
            
        },'ift,D'],
        #c A:f@4 %Compiling** -> %Comal**
        # Know/**%Compiling=$om spreads, %Comal=co mirrors f**
        # everywhere:
        #  would have fs&changey
        #  gets %Compiling=om
        #    batch input from R:Know%Compiling[f+]
        #  gets %Comal=co for itself
        #    coy&top = the f given to Know to compile
        # $om is then another Know-looking pile,
        #  hovering off of the enclosing %ball-sphere
        #   
        # things keep %Compiling even if !%tracting_good
        #   may cause compiling a state that was never there
        # else slep changzo, or reset %Compiling if any waits?
        
        # the Gs leave 
        ['ball+tracting+Compiling','63',&acgtRs{
            T.Mw = 'trac';
            $f = Rs&tracting;
            # starts from the fy&top (Know(%trac)
            $is_top = isar(Rs&Compiling);
            if (is_top) {
                # has Know/* %f
                Rs&amCompiling = delete Rs&Compiling;
            }
            # all fy&G%Compiling =
            $om = me&rollbsc,R,'Compiling',{lineate:fy&top};
            # C:co buildup, live as %ball%Compala
            $inp = &R{
                $co = Rs&Comal ||= me&givi,om,'all',[R.t,1];
                coy&top ||= co;
                # fs&top yN R, coy&top yR co (Know/**%Comal)
                ac(coy&top,'yN',co);
                # the Ghost%ball
                coy&G = R;
                # edge of %tracting, knowing the W
                #  as the large object beyond the
                #   ghostwork giving you stuff
                coy&W = fy&W;
                # f becomes formlandia
                coy&f = f;
                tracin(R,&r,rf{
                    # all the Gs %Compiling%Comal
                    rs&Compiling = om;
                    $b = fio(co,r.t,0);
                    $o = fio(co,r.t);
                    oy&up = co;
                    oy&top = coy&top;
                    rs&Comal = o;
                });
            };
            if (is_top) {
                omc&ov ||= 0.1;
                omy&top && omy&top != Rc&b &&
                    me&tsc,'f-om-sync',0,'G';
                # f/coy&top point to f/co, omy&top = R
                # < use these points of difference to phylo Cit
                omy&top = R;
                # start Know/*
                # creating @63, all there @64 to %ball
                each if Rs&amCompiling {
                    inp(fy&G);
                }
                # keeps %Compiling/**r, any goners fatal
                omy&N ||= [];
                me&yfuture,omy&N,R
                me&tsc,"Compiling...",0,'G';
            }
            
            ac(om,'yN',R);
            Rs&tracting_goodin and Rs&coready = 1
            
            is_top and return
            # each awakes children
            inp(R);
            
        },'ift,D'],

        # %Compiling persists while chaos stops it engaging
        #  eg %ting changes %species
        #   may noLive%waits but f remains
        #    Things&dige should be the same (5%ha|1%dige lies)
        ['ball+tracting+amCompiling','627',&acgtRs{
            Rs&Compiling and return
            Rs&Compiling_waits = 1;
            Rs&Compiling = 1;
            $b = Rc&b;
            !b and throw "no hist amCompiling"
            bs&Compiling = Rs&amCompiling;
            s&bgh = 111;
            me&tsc,"amCompiling",0,'G';
        },'ift,D'], 
    ]};
    #c supr
    =pod supr: sub-processes set up diversions
    
    usually wanting to wake the next phase
    they wai to themselves or $om
      cross-heavings:
    
    =head1 G:Know
    
    a Know..G knows about an item
      eg whether to include it
        < other tricks
    %tracting leaves a Thing + fs&changey dige
      the others:
        reset if much change (esp Things&dige)
        sleep until we are ready/get to them
      must be awake sometimes later
       they zap it via wai $om
    
    =head2 all
    
    %Compala leaves which thing to do next + how
      starts using leaf nodes from the Know..W,
       then the That..W it compiles
    
    =head2 seq
    
    %Comste does it, steppily:
    
    =head4 %ting fully
    
    zap the {Know,That}..W to %species=1
    oughtnt change Things&dige
     would mean a 4 is not pointing to the 1 proper
    to change without losing its own mind,
    watch Things&dige stay the same
    
    =head1 G:This
    
    G:This/$t/$step may become any mid-change state,
      so we can bisect the changes of each hack we apply
       < and get perl to jsBabz
       we already have before/after babz in .1
        < acknowledge diff (minus source diff)
     and %MindInto can save and resume,
      supposing the ephemeral all/seq
        will converge on the same thing,
      loading G:This...W rather than generating it
    
    =head1 G:That
    
    writes it into /W/Forthe/That/$t.{1,5}
    
     the .5 would only include the That..W (non-leaf nodes)
     < but could include the foreign Know..W,
       if there was a way to C&W further away things
        would impose complicatable indexes on gatherthink
         which wai looks like it might handle fine
       else it symlinks them across the boundary,
        ForThe NAT putting them in ./exotic/$t,
         they mentioning W:exotic/$t
    
    commits the Know..$t %changey into ForThe
     < in the same commit as the Thats
    
    =head1 anyway
    
    =head2 G:*
    
    are %tracting items,
      having the ..G side in W:ForThe,
      the ..W could be anywhere (..G knows %directory)
    the G:Know should receive changes
    the G:This may hold %Comste states of interest
    the G:That are finished items
    
    (W:ForThe)/$G/**$t - aka $G..G
      is a treeish map of the pile, inside W:ForThe
      knowing their W out there, and more:
       eg. Know..G informs our processing of the Know..W
        by s&el=9 leaving entire W-things out for now
       eg. This..G helps %Comste resync for same %changey
        < and the same set of hacks,
          supposing they will be W to n, like W:of
        < This..G/$aspect (!%tracting) talks more
          would that be intended typing, eg. Swim cW together
       
    (W:ForThe/$G/$t) - aka $W
      are the items themselves...
    
    =head2 inhabit the line
    
    that springs up around them,
     wai and s.y.* carrying superimpositions
     
     s.y.*
      may inherit along the line,
       may provide ref continuity,
      sy&f, sy&Thing may change to new editions
      sy&Compiling = s)%ball%Compiling etc,
       so steps know about each other,
      sy&supr=Compiling to know what type it is
       %Omplier sets them as such...
      sy&R should be the R%ball
      
     wai
      same but more sensitive/out of timeable,
    
    =head1 story #c
    
    s/ForThe/MindInto/g
    
    for-$om
      for-$om-Know
    
    ForThe@31 takes on %Omplier function:
      makes all%Omplateau/%t%Comste etc,
        not-in-ForThe projections, amongst it
      Rings G:*%tracting to 7
    
    skip to ForThe@34 if nothing but %tracting
     or,
     we do that thinking already, coupled with
      going on to Ring {all,seq,...}@{31,32,33}
     would be better to be effective at a few steps per life,
       Awinding will be nicer than nervously sprawling Icv
       centralised waicycling too,
        the Know@33 %woughs -> all@32
        what all@33 concluded -> seq@32
     looping only when @33 has to create/hoist etc
       which is probably good to frame
    
    **@32 becomes the sy&supr all over,
      sync its dependencies, see if it feels like running
       which it would do with a mixture of
        its own/deps waigh now(aft 2?) feedback
        looks at what it would send ForThe@34 about its progress
         and more since its the particular thing doing something
      usual 2-things to do,
       check for changes in state,
       that one may be waiting for a message from another
      
      and mini-Display as such
       with an R Ringing on its own, inside a %sleeping
        vaguely looked at this near %Cit,
        it needs to recycle its X (not be a transaction)
         and R:Display only itself?
       would really help performance,
         esp when we know we just need to go Round again,
         to handle something posted to:
    
    **@33 takes its step (if awake)
      into the time of the line reacting
    
    sending messages to:
    
    ForThe@34:
      take messagey wai from **
       expecting them to at least say ok
        or recycle what was if sleeping
       passing that on to its next step,
        which it suggests the creation of:
      eg. %tracting %changey generates %Compala
       which maybe should already be there,
        and know if this is reset-level change
         on either side, with the same tools and data
         just different perspectives on who we are
          the ForThe being the A, the others being C
    
    =head1 so
    
    < ForThe@34 groups many waigh, which may sleep
      - seems simple
    < each supr builds into the next
     
    
    =cut

    me.Tongingness = &acgtR{ return [
        #... me&Wrongingness ,
        
        # every Know/** becomes %coready,
        #  meaning the next Threativity may take it
        ['ball+tracting+Compiling','63',&acgtRs{
            # pointing s.y.f = %tracting
            me&tsc,"Readyie"
        },'ift,D'],
        
        #c A:f@37 %tracting waits -> %Compiling
        # %tracting_good waits for R/*%tracting_good, etc
        #  when we can rely on our children to complain,
        #  know if they're changey/trouble
        ['ball+tracting_good','62',&acgtRs{
            T.Mw = 'trac';
            $f = Rs&tracting;
            $pf = fy&up;
            
            tracin(R,&r,rf{
                # into this pool of what we're looking for from who
                # < display their stuff up against them
                #   dividing the ball in two
                
                # completed 61
                !rs&tracting_good &&
                    ah(R,'waitz','tw_scgk_r',r.t,'tracting_good',r);
                
                # completed 62
                #  which they haven't this future
                #  it should know changzo/simply/awake+ready,
                #   which would unset in 61 if net change
                !me&ollbs,r,'tracting_goodin' &&
                    ah(R,'waitz','tw_scgk_r',r.t,'tracting_goodin',r);
                
            });
            
            # autothink
            $wa = {solvent: [{
                dscif: {scgk:'tracting_good'},
                arkfor: {r: {cb:&dr{
                    ac(r,'trouble',R.t+" wants %tracting_good")
                }}}
            }], beready:1};
            
            # weakly supposing no signal means ok
            !me&waitzo,R,wa and return
            
            # children at least here
            #  Ring usu. children almost here
            Rs&tracting_goodin = 1;
            
            # which means all we need to compile is connected!
            if (pf == fy&top) {
                $g = pfy&G;
                aha(g,'wou')({co:'ready',tw:R.t,r:R});
            }
        },'ift,D'],
        
        #c A:f@3 being fy&G
        # gleans %ting's usual sc
        #  C visua
        #  if different, wills its children to do the same
        # over a few Domings, since Ring A-time is not precise
        # < set it to wind back this branch
        #   as ss&wantdige, may not be doable
        #     for _ting to ask /W/ or /js/
        # < copy from last good, or %fix/gamesc gizmo
        # < this Know gets slowly tractorbeamed to stable/Know,
        #   the load.auto waiting for test runs
        ['ball+tracting','61',&acgtRs{
            $D = Rs&C;
            # send r%trouble as late as you want to open it
            me&ollbs,R,'trouble' and Rs&openey = 1
            $c = {};
            $f = me&tracmode,R,'ting',c;
            
            if (f) {
                # the Know.G itself etc don't mind not being
                f == fy&top and return
                $W = fy&W;
                $Q = Ws&Q;
                !Q || !Qs&ready and me&waits,"!ready"
                $w = Ws&Live;
                !w and me&waits,"!live"
            }
            # < should have some waits
            !f and return
            
            # roll/sleepatch inner processes
            me&rolls,'grype',{s:f.t+"@"+Qs&dige,alsolineate:f};
            me&rollbs,'amCompiling';
            
            # lowlevel pre-f matters
            $game = me&gamesc,R,f,'game',['look','get'];
            
            !me&beready,R,'trac' and return
            
            Rc&dupl = 3;
            
            # looking at the answer
            # < sleep by Q&dige
            $Thing = Rs&Glean = me&lookating,W;
            # sync ss&dige and Thing's dige (however it appears)
            #  and whatever other Things project knowledge around
            
            # key behaviours, to stare at problems for longer:
            # hold changes to s that it has already
            # < we don't need to compile simple connections?
            #   trusted sources etc
            # ! if grype causes f%changey but applies the change
            #   (liesnotok=1 not to)
            #   grype rolled forgets it made the change
            #   f%changey can be forgot if R%tracting is interrupted
            # don't apply change from the Thing until Compiling wants to
            Rs&liesnotok = 1;
            # hold waking Thing changes are projected into:
            # < without hiding the change
            #Rs&noprojcha = 1;
            
            # %ting attr were auto upload/download by A:f
            # < configure it here sometimes
            me&grype,R,'ting';
            
            # %dige-ish group - change makes fs&changey
            me&grype,R,'W',{w:Thing};
            
            # < particularly if it changes when we game look->get,
            #    would mean a 4 is not pointing to the 1 proper
            
            # %el etc
            $inc = me&grype,R,'inc';
            if (inc) {
                if (ss&el == 9) {
                    Ds&bri = 0.6;
                    me&mtsc,inc,'ig',0,'B'
                    # < also ignored by the compiler
                    Rs&ignore = 1;
                    return
                }
                ss&el == 7 and me&mtsc,inc,'hmm',0,'B'
            }
            # we must now become changey if:
            #   any of our W-type data changes
            #   child dige projection wrong
            Things&Wind and me&gromps,R,'Wind','t,dige',Things&Wind
            # tally  grypes and gromps (from above)
            me&grimp,R;
            
            if (Rs&traccon) {
                me&zu,'Thingstract',Thing
                #me&zu,'Loadism',load
                Ds&fs = 15;
            }
            
            # various leads to %changey, %openey, %trouble
            if (fs&changey) {
                # dige here or inside solving
                me&tsc,"f%changey","cha",'G';
                me&zu,'changey',fs&changey;
                # 2 them
                me&ioty,R,'ball'
                    .map(n => ns&openey ||= 1)
            }
            Rs&trouble and me&zu,"Rtrub",Rs&trouble;
            
            Rs&tracting_good = f;
            
            if (game == 'look') {
                # get dige-level diff figured
            }
            elsif (game == 'get') {
                # should match the dige-level figured
                
                
            }
            return;
            # < applying the sort-out-code scheme
            # wanting a decision on each one
            # (1 keep, 7 transfiguration, 9 death)
            $z = tc&s;
            if (!zs&el) {
                me&tsc,'('
                me&rolltog,R,'9',0 and zs&el = 9
                me&rolltog,R,'7',0 and zs&el = 7
                me&tsc,')'
            }
        },'ift,D'],
        
        #c %ting%More -> /%ting vision in
        ['ting','5',&acgtRs{
            $M = Rs&Te && Rs&Te.sc.M || [];
            !Rc&b and M.splice(0,M.length)
            Rs&Modin ||= [];
            each if M {
                ac(R,'Modin',f) and continue
                $c = G&Cye,[f.t,1,{R:1}];
                # gathers sc for type from Ghost,
                #  also inheriting from this W
                # and esp what fs&game might want
                $load = {type:'ting',f:f};
                me&Cloadsc,load,fy&G,R;
                ex(c.sc,load.c)
                ac(R,'More',c);
            }
            Rs&Modout ||= [];
            # entered too late last time
            (me&ollbs,R,'MoreLate' || [])
                .map(n => ac(R,'More',n));
            each in Rs&More {
                ac(R,'Modout',n.t) and continue
                n $n
            }
            # Rings children, then this step again
            T.ziter = 0.4;
            Rs&More = [];
        },'ift,D'],
        
        # ^^%tracting/...%ting finds itself
        ['ting','6',&acgtRs{
            me&tracarri,R,'ting';
            # see 'tracarri ahead'
            # < Ring all == cv to get v before ^ for inners
            #R.t == 'Stylehut' and ~>5 HutCell:
            !Rs&tracting and return
            $f = me&tracmode,R,'ting';
            !f and return
            
            # child find 
            Rs&flook = &f,r,ok{
                # via ForThe or so? collector of masses of %tings
                #~>7 Flook ting: f.t
            };
            # child input
            Rs&finput = &f,r,ok{
                ok != 'W' and throw "ting finput !W"
                $vel = {};
                # M[f] -> More[R]
                #  uses f.t and f Cloadsc
                # from fy&G to fy&W
                me&Ravelvis,fy&G,R,'M',f,vel;
                if (velc&el == 8) {
                    # means we should have seen it
                    # < Ring it
                    # < pass back the Runtime,
                    #   M[f].y.Real? it's not M[f] then
                    #   invent another object, the G pushing
                    #   is almost the %tracupload,
                    #    if it linked back to f
                    !r and me&tsc,'vel=8!r',0,6
                    !f.y [ok] and me&tsc,'vel=8!y'+ok,0,6
                }
                else {
                    # let elvising establish, then r
                    r = null
                }
                return r
            };
        },'ift,D'],
        
        #c ting fance, %tightly
        
        ['tightly','3',&acgtRs{
            ac(R,'inheritsc','tightly')
        },'ift,D'],
        
        ['ball+tightly','3',&acgtRs{
            $p = Ry&up;
            ps&ting && ps&species and Rs&tightly = ps&species
            
            # if they s&W (%sc may be talking about sc)
            $onW = Rs&tightly == 4 && ss&sc.includes('W')
                || Rs&tightly == 5 && ss&W;
            # ting it!
            onW && me&rolltog,R,'W?',0 &&
                n $s.t  R %ting,toW
        },'ift,D'],
        
        # look through 4/5 for links
        ['inspecto','3',&acgtRs{
            me&walla;
            $p = me.cbu(R,'ting');
            each in sy&N {
                (ps&species == 5 && ny&up && ny&up.t == 'W' ||
                ps&species == 4 && ns&sc && ns&sc.includes('W')) &&
                    n $n.t  $s:n,R %itemo:W
                ps&species == 4 && ns&c && ns&c.includes('W') &&
                    n $n.t  $s:n,R %itemo:cW
            }
        },'ift,D'],
        
        ['itemo','3',&acgtRs{
            me&walla,0.4;
            $p = me.cbu(R,'ting');
            me&tsc,'itemo',Rs&itemo,'6' .y.cv = 0.08
            $t = me&domesticate,R;
            ts&hs = 296; # tsc'y'
            ss&zs and me&tsc,'zsize','x'+ss&zs,'b'
            
            (Rs&boost||0) < 1 and return
            
            # open it in the .1
            $wasp = p
            ps&species and p = me.cbu(py&up,'ting')
            !p and throw "!pp !species"
            p == wasp and was = null;
            $M = ps&More ||= [];
            
            if (Rs&itemo == 'W') {
                $n =
                m $s.t  R:1 %ting,toW
                wasp and ns&autospecies = wasps&species;
            }
            else {
                $es = ps&Live;
                $z = es && ess&z;
                $ok = 0;
                each in z {
                    n.t != s.t and continue
                    $ok = 1;
                    m $n.t  $s:n,R:1 %ball,tightly
                }
                !ok and return me&tcs,'!Live/t'
            }
        },'ift,D'],
        #c %ting push/pull of C living across the boundary
        #  the question should roll+clone
        #    to transact by the dependent process?!
        ['ting','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dubquiet = 1;
            # make little label as from this I
            $p = me.cbu(Ry&up,'ting');
            $lab = &ltc{
                $n = me&tsc,'%ting-'+l,t,c;
                ns&fs = 11;
                return n
            };
            T.Mw = 'ting';
            
            # more %ting:1 in the same of/directory
            # < seeing where edges of C are,
            #   pressurise to voyage
            $t = null;
            if (Rs&ting == '1') {
                !p and throw "ting:1 !p"
                # same ting, may be adding %species
                Rs&ting = ps&ting;
                ps&directory and Rs&directory ||= ps&directory
                # may to another W/$t
                t = Rs&toW ? R.t : p.t;
            }
            # the Q&of = W
            !Rs&ting and throw "!%ting";
            $n = lab('ting',Rs&ting,'G');
            ns&fs = 15;
            
            # the Q.t = directory/t/species
            t ||= R.t;
            $fullname = t;
            #   only say change in directory
            (p ? ps&directory != Rs&directory : Rs&directory) &&
                lab('directory',(Rs&directory||'/'),'B')
            p && R.t == p.t ?
                lab('t-same','^','G')
              : lab('t',t,'G')
            Rs&species and lab('species','.'+Rs&species)
            Rs&species and fullname += '/'+Rs&species
            Rs&directory and fullname = Rs&directory+fullname
            
            me&the_ting,R;
            
            $Q = me&rollbs,R,'Q';
            Q && Q.t != fullname and Q = null
            !Q and Q = Rs&Q = G&Cye,[fullname,'',{of:Rs&ting}];
            Rs&Quploadsc and Ry&up.sc[Rs&Quploadsc] = Q
            Qc&async = &{};
            # c&canwait = 1;
            Qc&ready = &CP{};
            $s = Rs&Live = Rs&_ting(Q);
            
            T.Mw = 'ting-into';
            # you may roll into 
            me&rolltog,R,{may:'Q'},0 &&
                n Q  $self:Q,R %Cit,ot
            
            !Qs&ready and me&waits,'!ready','...'
            
            Qc&el and $el = me&tsc,'elvis',""+Qc&el,'b'
            el && elc&s == 9 and els&fs = 16;
            
            !s and return
            # look in
            me&rolltog,R,{may:'L'},0 &&
                n Live  $self:s,R %Cit,ot
            
            me&rolltog,R,'toball',0 &&
                n Live  $s:s,R %ball,tightly,refpool
            
            if (Rs&species) {
                if (!Rs&toball) {
                    sy&N ||= me&sunN,s;
                    me&tsc,'Csize','x'+sy&N.length,'b';
                    # < make part of genesising a %ting from a %tracting?
                    $tracting = Rs&tracting || Rc&b && Rc&b.sc.tracting;
                    $ope = !tracting;
                    ope ||= me&rolltog,R,{may:'inspecto',s:'O',fs:12};
                    ope &&
                        n inspecto $s:s,R %inspecto
                }
            }
            else {
                # %ting/%ting subspecies of same
                #  4 is low resolutions of the data
                #  5 is an of/t %Giveness
                Rs&autospecies and R.sc['/'+Rs&autospecies] = 1
                me&rolltog,R,'/4',0 &&
                    n Hive  R %ting,species:4
                me&rolltog,R,'/5',0 &&
                    n Give  R %ting,species:5
            }
        },'ift,D'],
    ] };
    #c Search Tingingness gets domethings
    # stately getting of things
    # < with/via e,
    #   generating more different e,
    #   returning you clues or it
    # < knows structuR, me.cby-like stuff
    #   the old G&t worked off A.1-5 being
    #    the spheres locality around A
    #   
    
    # G&c but harvested by Tool
    #  as coming from this R, in/out of time,
    #   talking about other R, to make acts shimmer
    #  available as verbosity, debug points
    #  muted when recognised
    # < io-param-like + styles of message with object in
    me.chatter = &acgttl{
        l.constructor != Array and throw "send array"
        each in l {
            l[i] = '>'+(3+(i*2))+':l'+i+' '+(n||'')
        }
        return G&c:'>1 '+t,l
    };
    
    # %ting is a layer upon ...
    me.the_ting = &acgtR{
        # have %Search%_ting
        $r = me.cbu(R,'Inn');
        $r = r && rs&Inn;
        !r and throw "no way Inn"
        !rs&_ting and throw "no Inn _ting";
        Rs&_ting = rs&_ting;
    };
    
    # Guxily for thing, got via stately e
    #  W it pulls in may clue changes to other W
    #  per remote place, which may already have its catalogue here
    me.Tingingness = &acgtR{ return [
        # the centralising of stuff going in!
        # for using thing = $of/$t on an ongoing basis
        #  gets I.$of.$t
        #  some $of (W/w/js) may network, contain more I
        # usually 
        #   is $t still $dige?
        #   its $dige, here: $s
        # we may get an el/lv/anything-known about things that change
        # the set of Questions you have:
        #   looks like Writer's .5 deps: $type/$name%details
        ['sleeping+Search','4',&acgtRs{
            $b = Rc&b;
            Rs&_ting = bs&_ting;
        },'ift,D'],
        ['Search','4',&acgtRs{
            # an h call muddies T
            $Gtime = &d{ return G&time,d };
            # similar!
            $ch = &tl{ return me&chatter,t,l||[] };
            
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            me&introqua,[R,'Ghost'],{boost:-1},'@1';
            n Ghost  $s:Ghost,R %ball,childy
            
            # of/t=$P
            i $Ghost/In
            # of/t=$P in motion
            i $Ghost/Pulling
            
            
            $Pio = Rs&Pio = {};
            Pio.what = &tP{
                o $Ghost/#$t/#Pc&of/#$P:s
                return ya
            };
            Pio.not = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
            };
            Pio.is = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
                i $Ghost/#$t/#Pc&of/$P:s
            };
            
            #c _ting - a many arg'd entrypoint
            #  ting becomes the reduce for io's map
            # 
            Rs&_ting = &stz{
                # Question - may come with ...
                $C = isC(s) ? s : G&Cye,[t,1,{of:s}];
                
                # the G.t variety?
                # if !found of a Talky of:
                
                # C in the field, P in the store
                $P = Pio.what('In',C);
                if (!P) {
                    P = G&Cye,[C.t,1,{of:c&of},{}];
                    Pio.is('In',P);
                    Ps&Want_Check = 1;
                }
                # validate cache
                Ps&now && Gtime(Ps&now) > 25 and Ps&Want_Check = 1
                s&P && s&P != P and s&oP = delete s&P
                
                # in/out of time bit, lost in the store
                $ok = Rs&Pull_a(C,P);
                
                # don't wait for the async check
                # Pc&s only null if never found,
                #  or new string is got but not decoded
                !ok && Pc&s && !c&canwait and ok = 1
                
                if (!ok) {
                    # go async
                    s&ready = 0;
                    # after, c&ready() climbs back to C time
                    c&ready and ac(P,'readyingC',C)
                    c&async and c&async()
                    else {
                        G&TuneTimeMachine,c&of+':'+C.t
                    }
                }
                else {
                    # C is, Pc&s == null must be intentional
                    s&ready = 1;
                    
                    # C <dige> P, may surprise
                    # el=1/8 basically
                    c&el = Pc&el;
                    if (!c&el || c&el == 1) {
                        c&el = s&dige != Ps&dige ? (s&dige ? 2 : 1)
                            : 8
                    }
                    c&el && Py&decidedel && Py&decidedel(c&el);
                    
                    s&dige = Ps&dige;
                    c&s = Pc&s;
                    # C never gets s&string unless it makes it

                    # keeps Pc&s while update is looked for
                    Pc&s && Ps&Pulling_since && c&canwait and ~waitscan
                    else
                    Pc&s and return Pc&s
                }
            };
            #c Pull_a
            
            Rs&Pulling_already = &P{
                $ya = Pio.what('Pulling',P);
                # don't trust stagnant Pulling
                if (ya && Gtime(yas&Pulling_since) > 5) {
                    ya = Pio.not('Pulling',P);
                }
                # don't shunt Pull_a from outside its own callbacks
                #  which will have ensured they don't reoccur
                ya and ch('dupreq',[Cc&of,C.t]); return
                return ya
            };
            
            # shunt P - can progress out of time
            # then returns 1 and/or calls c&ready
            Rs&Pull_a = &CP{
                # < make s&string mean write string, our thing in c&s
                if (Ps&Want_Check || s&string) {
                    if (Ps&Want_Check == 2) {
                        s&string and ch("Redo+string")
                        delete s&string;
                    }
                    else {
                        # waiting on P
                        Rs&Pulling_already(P) and return
                        # become Pulling
                        Ps&Pulling_since ||= Gtime();
                        Pio.is('Pulling',P);
                        Pc&T = {};
                    }
                    $T = Pc&T;
                    # shunts Pull_a when ready
                    T.cb_gen = &CP{
                        if (T.redo) {
                            ch('Redoing',[P.t]);
                            Ps&Want_Check == 2 and throw "redo x2"
                            Ps&Want_Check = 2;
                            delete T.redo;
                        }
                        else {
                            delete Ps&Want_Check;
                        }
                        Rs&Pull_a(C,P);
                    };
                    # sends
                    Rs&Pull_Check(T,C,P);
                }
                $T = Pc&T;
                !T and throw "unstarted P"
                !T.ok and return
                
                # < C gets its own decode? or Copy Pc&s on el<3
                #s&wantdecode and Ps&Want_Decode = 1
                # < modes of decode: dl/Xpath, allowing yaml code
                Ps&Want_Decode and Rs&Pull_Decode(T,C,P)
                
                !T.ok and return
                delete Ps&Want_Decode;
                
                # < way getting args/wrapping/eval as Pull_Transcode?
                #   it's ting's business if things want to share
                
                Pio.not('Pulling',P);
                delete Ps&Pulling_since;
                # pulling done re. $Ghost, but not $C
                #!Pc&s and throw "no ting Pcs: "+Pc&of+'/'+P.t
                
                s&P = P;
                Py&decidedel = &n{ T.tcp.set('l3',n) };
                
                each iC Ps&readyingC {
                    # P completed async, get back to C time
                    #   no longer awaiting yon return 1
                    c&ready and c&ready(C,P)
                }
                delete Ps&readyingC;
                
                return 1
            };
            #c PullCheck
            Rs&Pull_Check = &TCP{
                T.waits and throw "PullCheck while waits"
                T.ok = 0;
                # they may have their own ways to use dige/v, p/P/s&P
                # Pc&get how to ask,
                # Pc&got loads response into P
                $Do = Rs&Talks[c&of];
                !Do and throw "!Talk "+c&of
                T.get = {};
                T.get.data = {};
                Do(T,C,P);
                !T.get.url || !T.got and throw "!Talk handlers "+c&of
                
                T.cb = &sc{
                    T.aft_waits = Gtime();
                    # every pulling happened now
                    Ps&now = Gtime();
                    # specific stuff moves from the response to P and Pc&s
                    #  can !T.ok...
                    T.got(P,s,c);
                    # out of time plumb
                    # may be stolen by got if more requests (/js)
                    T.ok = 1;
                    T.cb_gen and T.cb_gen(C,P)
                };
                Rs&TCP(T,C,P);
            };
            # rebuild tcp
            # < https://javascript.info/xmlhttprequest
            # < have A, so async in handler gets retried
            #    (or G&way noop deps just before handling)
            # < get or ws
            # retry, expire
            # uses T.get -> T.cb()
            Rs&TCP = &TCP{
                $tcp = T.tcp = ch("tcp",[T.get.url,'.','.','.','']);
                
                $done = &s,how,c{
                    !T.waits and return
                    T.waited = Gtime(T.waits);
                    delete T.waits;
                    tcp.set('l1',G&thime,T.waited );
                    r.status != '200' and return T.status = r.status
                    T.cb(s,c);
                };
                
                $r = T.r = $.ajax(T.get).done(done);
                T.waits = Gtime();
                
            };
            Rs&Pull_Decode = &TCP{
                T.ok = 0;
                $type = Ps&Want_Decode;
                $de = ch('decode',[P.t,type,'','']);
                # Pc&el becomes interesting to the Client,
                #   2-3 were our will carried out
                #   6-7 to merge
                # < C may want a new set for itself, to make a mess
                #   while we are in the clone factory
                #   faster to separate with io than many readLines?
                #   but how much safer?
                
                $s = null;
                try {
                    if (type == 'Lines') {
                        !Ps&string and throw "P!%string"
                        $N = G&readLines,Ps&string;
                        N.length != 1 and throw "Weird tW lines", s
                        s = N[0];
                    }
                    elsif (type == 'way') {
                        $w = G&Cye,[C.t,1];
                        wc&s = Ps&string;
                        ws&of = 'w';
                        # dige is for s before compiled
                        ws&dige = Ps&dige;
                        s = w;
                    }
                    elsif (type == 'js') {
                        s = Pc&s;
                        Rs&Decode.js(s);
                    }
                    else {
                        throw "Decode type "+type
                    }
                    s.y.P = P;
                    Pc&s = s;
                }
                catch (er) {
                    T.er = er;
                    de.set('l2','Error!');
                    de.set('l3',er);
                }
                Pc&s = s;
                s && !T.er and T.ok = 1
                
                if (T.ok && T.aft_waits) {
                    T.aft_waited = Gtime(T.aft_waits);
                    delete T.aft_waits;
                    $tcp = T.tcp;
                    tcp.set('l2',G&thime,T.aft_waited );
                }
            };
            
        
            #c Talks.w
            Rs&Talks = {};
            Rs&Decode = {};
            Rs&Mix = {};
            # < w are from:
            #  the digway+/way/ (trad)
            #  the /w/ (unBabz'd way) (new)
            #    this dige might match the one from digway?
            #  the /wayz/ (Babz usual blockquotes)
            #    for use in We
            Rs&Talks.w = &TCP{
                # < Babz mode: none, normal, BQ-inclusive
                T.get.url = '/way/'+C.t;
                Ps&dige and T.get.data.have = Ps&dige
                T.got = &Psc{
                    $dige = c.getResponseHeader('Dige');
                    !s && Ps&dige == dige and s = Ps&string
                    if (s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = dige;
                        Ps&string = s;
                        Ps&Want_Decode = 'way';
                    }
                };
            };
            #c Talks.js
            Rs&Talks.js = &TCP{
                # I in a .js script (+ a little about the 9)
                # first request: only to find the dige,
                # then we can write a unique <script src=toit>
                # < if we know what version don't do this first request
                # T would put this c&dige to wind back from bugs
                # hazardily shared P having the branch reset,
                #   put the -$dige in C.t already to have a specific P be there
                T.get.url = '/js/'+C.t+'-'+(c&dige||'head');
                # < if c&v forced/trusted (via Wover),
                #   use the exact url to add_script
                # < does the rewritten Location mean the second XHR caches?
                $cb_gen = delete T.cb_gen;
                T.got = &Psc{
                    $src = c.getResponseHeader('Location');
                    $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                    $W = Pc&s = G&Cye,[m[1],1];
                    Ws&I = {};
                    Ws&dige = Ps&dige = m[2];
                    # /js/ 
                    # nest callback
                    T.ok = 0;
                    T.waits = Gtime();
                    $callback = &s,e{
                        T.waited_script = Gtime(T.waits);
                        T.ok = 1;
                        Ps&script = s;
                        Ps&Want_Decode = 'js';
                        cb_gen(C,P);
                    };
                    Rs&add_script(src,callback);
                };
            };
            # implant code as .js
            #  should be able to receive any ting,
            #  esp way, is more stack/debugger findable loaded like so:
            Rs&add_script = &src,cb{
                $have = $('body script[src="'+src+'"]');
                have.length and return cb(have[0])
                $s = document.createElement('script');
                s.setAttribute('src', src);
                s.setAttribute('type', 'text/javascript');
                cb and s.onload = &e{ cb(s,e) };
                document.body.appendChild(s);
                return s
            };
            Rs&Decode.js = &W{
                $tocfunc = W.t+'_'+Ws&dige;
                !window[tocfunc] and throw "Notocfunc: "+tocfunc;
                $toc = window[tocfunc]();
                $D;
                each iv toc {
                    $ind = v[0];
                    $C = G&Cye,[v[1],v[2],v[3],v[4]];
                    if (ind == '') {
                        D = Ws&I[C.t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        # grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t, v
                    }
                }
            }
            #c Talks.W
            Rs&Talks.W = &TCP{
                T.get.url = '/W/'+C.t;
                $d = T.get.data = {};
                # clue them to Hobs for it we have around
                # the current HEAD:
                Ps&dige and d.have = Ps&dige
                # the first "can you hold on to..."
                if (s&string != null) {
                    # wants to write, '' to delete
                    T.get.type = 'post';
                    d.s = delete s&string;
                    if (d.s.length && d.s == Ps&string) {
                        # keep expecting it
                        !d.have and throw "sleeping write !Psdige"
                        delete d.s;
                    }
                    # < get the average size of codes down,
                    #   mix them locally (A:u)
                    c&patch and throw "< patches"
                    # continuity check, also for deletes
                    # < d.parent=null means it should be new
                    s&P and d.parent = s&P.sc.dige
                    s&parent and d.parent = delete s&parent
                }
                T.got = &Psc{
                    $r = dej(s);
                    # dige find things we d.have
                    if (r.dige && r.s == null) {
                        r.dige == Ps&dige and r.s = Ps&string
                        else
                        d.s && r.dige == dig(d.s) and r.s = d.s
                        r.s == null and $nors = 1;
                    }
                    $el;
                    r.ok == 'found' and el = 1
                    r.ok == 'created' and el = 2
                    r.ok == 'updated' and el = 3
                    # 6 is 3 from beyond 5! matters
                    r.ok == 'forward' and el = 6
                    r.er == 'not ffwd' and el = 7
                    r.ok == 'deleted' and el = 9; Ps&departs = Ps&dige
                    r.er == 'not found' and el = 9
                    Pc&el = el;
                    if (el == 9) {
                        # watch for undelete?
                        r.s and throw "what"
                        delete Pc&s;
                        delete Ps&dige;
                        delete Ps&string;
                        # plumb? like an elvisory
                        return
                    }
                    if (nors) {
                        # < different perl/javascript dig
                        el == 3 and return T.redo = 1
                        else {
                            throw "get/W implied we know", r, P
                        }
                    }
                    if (el == 7) {
                        # notify push failed?
                        c&rebase and c&rebase(P,r)
                        else {
                            throw "not ffwd: "+C.t, r
                        }
                    }
                    !el and throw "tW er", r.er, P, r
                    if (r.s && r.s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = r.dige;
                        Ps&string = r.s;
                        Ps&Want_Decode = 'Lines';
                    }
                };
            };
         
            
            #c way/js questions as C
            # public interfaces
            # shows how to plug their async gear into ting's
            # the wandering part of G&way
            Rs&quest_w = &acgttry{
                $ar = r;
                $cb = y;
                $Q = G&Cye,[t,'',{of:'w'}];
                Qc&ready = &{
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                    # so wait for it...
                    !cb and return
                    if (G&arfgunc,cb == "s") {
                        # way randomly happens, give return value to cb
                        # without A lining up around it (it may do so itself)
                        # see G&waylay for use case as delayed call
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the context revisted?
                        cb(t,ar,w);
                    }
                };
                Qc&async = &{
                    cb == 'noop' and cb = &{}
                    else
                    typeof cb == 'string' and throw "Cant go async: "+cb

                    # Jin should avoid this A for a while
                    a&ready = 0;
                    # and throw/abort if no callback
                    !cb and G&TuneTimeMachine,'w:'+t
                };
                $w = Rs&_ting,Q;
                return w
            };

            Rs&quest_js = &acgtt{
                $Q = G&Cye,[t,'',{of:'js'}];
                Qc&ready = &{
                    A.cv = 0.4;
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                };
                Qc&async = &{
                    a&ready = 0;
                    4s&N.push(A);
                    T.not = 1;
                };
                $W = Rs&_ting,Q;
                #a&I = Ws&I;
                #a&v = Ws&v;
                return W
            };

         
        },'ift,D'],
        
    ] };
    #c %mundws holds an A:ws
    me.Socketingness = &acgtR{ return [
        # < push/pull of C living across the boundary
        ['mundws','3',&acgtRs{
            Rs&rowish = 1;
            # < these ways to assume arguments want fibre
            $ws = me&rollbs,R,'Sock',1;
        },'ift,D'],
        
        # at LVing avail
        ['mundws','4',&acgtRs{
            Rs&rowish = 1;
            
            # current state
            $ws = Rs&Sock;
            
            # /path
            me&tsc,'mundws','ws:','b';
            me&tsc,'path',R.t
            me&tsc,'state',ws.state,'6';
            ws.state == 'closed' and Rs&Sock = 1
            
            # %Again
            $z = Rs&Opinion && Rs&Opinion.sc.z;
            $len = z && z.length;
            z and me&tsc,'Opinion.length','('+len+')';
            
            Rs&Lving &&
            n Lving  $self:Rs&Lving,R %Cit
        },'ift,D'],
        #c GhodigWap news from the 5 year old editor
        # one aspect of news about $ways, from g/\w+/\d+
        ['GhodigWap','3',&acgtRs{
            # replaces J:digwaypoll
            me&rolltog,R,'nodigway',1,&s{4c&nodigway=s};
            
            
            # $w as heard about, seekended and living (Iw)
            me&introqua,[R,'ifd','Ghost','apparently'],{boost:-1},'@1';
            me&introqua,[R,'ifd','Ghost','est'],{boost:-1},'@1';
            me&introqua,[R,'wats'],{boost:-1},'@1';
            
            # w can be trusted if listened for in digwaypoll
            # digwaypoll in/out only t + dige
            #  dige may vary in length > 6
            #  dige in merely allows Opinion to sleep
            #   when it comes out, which we could imply:
            #   < Lc&* for server's agreement with said diges
            #     they say what send() they agree up to,
            #      and we synthesize eouts to mean it
            n digwaypoll  R %mundws,Ghocoline,tinyscLines:dige,mightsctrunc:dige
            
            n ifd  R %Ghostway
            # < ^ having its own compile,
            #   your ting w/* perspective may incorporate it
            #   then another ing happens?
            
            # G&way compiled:
            n wats  $s:A.5.I.w,R %Idoubleyou,ball,childy:tw
            
        },'ift,D'],
        #c Ghostway - asks for way notifies, gets them
        # provides ein/out/ope
        #   by way of %Again/%tinyscLines
        #   for C sloshing in or out
        # knows how to talk ws:s/digwaypoll
        ['Ghostway','33',&acgtRs{
            $p = Ry&up;
            # place to talk
            $S = Rs&Upstream = ps&z[ps&z.indexOf(R)-1];
            $ch = Rs&chatter = Ss&chatter;
            # insured memories via %Again
            $g = Ss&Again = ps&z[ps&z.indexOf(R)+1];
            $Way = gc&s;
            
            # the 'here', a join
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            n Ghost  $s:Ghost,R %ball,childy
            
            # pile from both ends over time
            i s:{ Ss&Opinion=C } $Ghost/apparently:s
            # and changes go further
            i s:{ Ss&Further=C } $Ghost/seek:s
            
            # on change, queue:
            Ss&do_Further = &{
                # /apparently/* changing creates /seek/*
                # to look it up since that dige changed
                o $Ghost/seek/*
                $seeking = ays&s;
                !seeking and return
                Rs&seeking = seeking.slice();
                each is seeking {
                    o $Way/#$s
                    !ya and ch("didnt know",[s.t])
                    Rs&seeketh(s,ya)
                }
                return
            };
            
            # < ting many asks per question
            #   so many seekeths make one seekend
            #   is a keepalive for the first question
            Rs&seeketh = &s,was{
                ch("seeking...",[s.t]);
                #$w = G&ting,'w',s.t;
                #   currently takes old-G&t shortcut,
                #    returns way without checking ttl
                $cb = &t,ar,w{
                    Rs&seekend(w,s,was);
                };
                # noop='nottl' so it renews#
                G&way,s.t,{},cb,'nottl';
            };
            
            # thing is got!
            Rs&seekend = &w,s,was{
                Ss&sleep_Further &&
                    Ss&sleep_Further(w,s);
                
                $com = [w.t];
                !was and com.push("@1")
                else
                if (wass&dige == ws&dige) {
                    return ch("Seeksame",[w.t])
                }
                ch("Seekback",com);
                # hold latest one here
                # < of those changing rapidly
                #   rolling commits together
                #   ong branch slower, then ung
                i $Ghost/ing/$w
                # once after the batch (ish)!
                $si = Rs&seeking.indexOf(s);
                si >= 0 and Rs&seeking.slice(si,1);
                # wait up to 30ms if more might seekend
                $delay = Rs&seeking.length ? 30 : 0;
                # joining seekends near in time!!!!!!
                $cb = me&sccb,R,'seekingdone',Rs&do_ing;
                delay ? G&yl,delay,cb
                    : cb();
            };
            
            #c 7 thing-got
            Ss&sleep_Further = &ws{
                if (!w) {
                    # from eout that sleeps
                    o $Way/#$s
                    w = ya;
                    !w and return ch("didn't know sleeping",[s.t])
                }
                # Iw has $w, make permanent!
                ws&now = G&time + 3600;

                i $Ghost/seek/-#$s
                # < should know time is up for this ground,
                #   get it attached via Tsome
                #n seen  $self:w %Cit
                # permanent
                i $Ghost/est/$w
            };
            
            Rs&do_ing = &{
                # things changing, code to redo!
                o $Ghost/ing/*
                $inging = ays&s;
                # < otherwise G&ting evals?
                $doers = 'Soogle Packle Coffle Foogla Fividy NutGravy'.split(' ');
                $mewrap = 'iooia'.split(' ');
                $doerd = [];
                each iw inging {
                    if (mewrap.indexOf(w.t) >= 0) {
                        # me.codes containers should run
                        ch("Ghostwaywr",[w.t]);
                        me[w.t](w);
                    }
                    elsif (doers.indexOf(w.t) >= 0) {
                        # me.codes containers should run
                        ch("Ghostwayer",[w.t]);
                        G&way,w.t;
                        doerd.push(w);
                    }
                    else {
                        ch("Ghostway",['',w.t]);
                    }
                    i $Ghost/ing/-$w
                    # then anything dependent on the way
                    #  eg I, J...
                    #  diff way to wake a .Ja. is not impossible
                }
                # for $w that generate $me which generate I,
                #   drop Ring's cache of me I
                $dropcache = doerd.length && 1;
                
                Rs&do_permanence(dropcache);
            };
            
            Rs&do_permanence = &dropcache,{
                # keep permanent
                # the only in-time operation
                # < scan for not in Iw
                # < dige sleep on init may not get things here:
                o $Ghost/est/*
                each iw ays&s {
                    ws&now = G&time + 3600;
                    if (dropcache) {
                        delete ws&makesI;
                        delete ws&makesIw;
                    }
                }
            }
            
            # keepalive
            Rs&do_permanence();
            # casual shunt, in case e loses its will to carry it out
            Ss&do_Further() || Rs&do_ing();
        },'ift,D'],
        
        #c %Again (C/%ball source) -> %ein()
        # e inits some state (usually)!
        ['Again','35',&acgtRs{
            !Rs&Again.sc.ball and throw "Again!ball"
            Rs&Lvact = &{
                $N = me&ioty,Rs&Again,'%ball';
                each in N {
                    N.indexOf(n) < i and ~DupeyzLvact: n.t
                    Rs&ein(n)
                }
            };
            # el=2 everything
            Rs&eope = &{ Rs&Lvact() };
            # el=2 changing
            Rs&Lving and Rs&Lvact()
            
        },'ift,D'],
        # %ein() C only t and certain sc
        # %eout() C into %Opinion
        #   and into %Further if certain sc change
        ['tinyscLines','32',&acgtRs{
            # Lving: may not make it through send() if same
            Rs&uniqsend = 1;
            # a t/dige only variety of tinyLines encoding:
            Rs&tinyLines = 1;
            
            # only certain sc taken
            $only = Rs&tinyscLines;
            only = only && only != '1' && only.split(',')
            Rs&takeonlysc = &s{
                !only and return ex({},s.sc)
                $sc = {};
                each ik only {
                    s.sc[k] == null and continue
                    sc[k] = s.sc[k]
                }
                return sc
            };
            
            # their Opinion arriving
            Rs&hasonlysc = &sl{
                $ks = only || haks(s.sc);
                $ok = 1;
                # checks how different it is
                each ik ks {
                    $was = s.sc[k];
                    $is = l.sc[k];
                    $com = [l.t, k, was, '->', is];
                    !is and ch('nullsc',com); return -1
                    
                    was != is and ok = 0
                    
                    if (!ok && Rs&mightsctrunc == k && was
                        && was.length > 6 && is.length > 6) {
                        ok = was.includes(is) || is.includes(was)
                    }
                    !ok && was and ch('scut',com)
                }
                # applies!
                each kv l.sc {
                    s.sc[k] = v
                }
                return ok
            };
            
            $ch = Rs&chatter;
            Rs&ein = &n{
                !ns&ball and throw "!ball: "+ki(n)
                $c = {}; # L%send[D.sc
                $s = nc&s;
                $C = G&Cye,[s.t,1,{},Rs&takeonlysc(s)];
                # Opinion is one piled from both ends
                #   so it can come back same the first time
                i Rs&Opinion/-#$C
                i Rs&Opinion/$C
                c.toLines = C.t;
                if (haks(C.sc).length) {
                    c.toLines += '%'+G&depeel,C.sc
                }
                Rs&send(n,c);
            };
            Rs&eout = &l{
                !Rs&Opinion and throw "give Opinion"
                !Rs&Further and throw "give Further"
                
                # their opinion is arriving
                i Rs&Opinion/#$l:s
                $ok = Rs&hasonlysc(ya,l);
                ok < 0 and 'said error'
                elsif (ok) {
                    ch('sleep',['way',l.t]);
                    Rs&sleep_Further &&
                        Rs&sleep_Further(null,l)
                }
                else {
                    # changes go %Further once per receive
                    ch((!ya?'new':'wake'),['way',l.t])
                    i Rs&Further/$ya
                    Rs&do_Further &&
                        ac(R,'Finally',Rs&do_Further)
                }
            };
        },'ift,D'],
        #c Ghocoline - C<->string envelope
        # provides %receive(), wraps %send()
        #   en/decoding some string format
        # Lving @31 logs a %send/receive[D+]
        # see 'Lving' around here, it may also:
        # < Ls&z clone C we sent them?
        #     would allow better %resumable
        #     %uniqsend dedupes for now
        # the @34 do push/pull C across a boundary stuff
        # the @32 is C<->string:
        # all Lines =~ /^[ \w"]/
        #  so there's room for some protocol in there:
        # < Lc&resumable - do you remember? rolls state:
        #   - roll Ls&send if %uniqsend, dedupes
        #   - know Ls&z and lv-sense to your app
        #   app must sleep while we try to:
        #   negotiate what they know with el=7
        #     might know our/previous Ls&sent_dige
        #       retransmit Ls&send
        #     or stuff on the ground
        #       exploratory W nature,
        #       eg check state of everything in Toys:
        #         Toys el:7%dige:358i0f
        #       may not include %dige on request,
        #         but then the server could pre-empt our:
        #           what has what become,
        #            and what can be patched
        # Lc&responsey - expect one receive per send
        #   link them, ordering if many backends
        #   responses not in requested order
        #   < slowing/Aing out time to understand message
        ['Ghocoline','32',&acgtRs{
            Rs&receive = &sD{
                typeof s != 'string' and throw "receive !string"
                $ch = Rs&chatter;
                ch and ch('receive',[ki(s,3)])
                
                Rs&tinyLines and Rs&someLines ||= 1
                Rs&someLines and Rs&contLines ||= 1
                
                if (Rs&contLines) {
                    # can know how to nest another protocol
                    if (!s.match(/[ \w"]/)) {
                        # tricks with Lving"
                        throw "strange"
                    }
                    elsif (s.match(/^ /)) {
                        # Lving -> last message's cursor
                        throw "floating start"
                    }
                }
                
                # string tricks
                # decoded N everything becomes M ways in
                $l = [s];
                if (Rs&someLines) {
                    # splits lines, batch of something
                    # < by next Line d=0?
                    l = s.split("\n");
                    l.slice(-1)[0] == '' and l.pop()
                }
                
                # parsed
                $z = l.slice();
                if (Rs&tinyLines) {
                    # parse Ghost%dige:4827848
                    each is l {
                        $s = s.split('%');
                        s [0].split("\t").length > 1 and throw "comp"
                        z[i] = G&Cye,[s[0],'',{},s[1]]
                    }
                }
                elsif (Rs&contLines) {
                    throw "readLines wanted"
                    # make R to deLines then ein?
                    #$N = me&readLines,s;
                }
                
                # iterated
                Rs&esout and Rs&esout(z)
                else
                Rs&eout and z.map(s => Rs&eout(s,z))
                
                $Fin = delete Rs&Finally;
                Fin && Fin.map(cb=>cb());
            };
            #c send!!
            $send = Rs&send;
            !send and throw "no Ghocoline proxy send()"
            Rs&send = &sc{
                $string = s;
                # the Lving%send/$D .sc
                c ||= {};
                typeof s == 'string' and 'ok'
                else
                !isC(s) and throw "obj->string"
                else
                s.y.R != s and throw "send C !R"
                else
                if (ss&ball && ss&toLines || c.toLines) {
                    string = c.toLines || ss&toLines;
                    c.origin = s;
                    $L = Rs&Lving;
                    # < Lving: repeat string/diff/compression
                    #   smelting toLines' intel,
                    #   what to do with lots of el:8 etc.
                    if (Rs&uniqsend && Ls&send) {
                        $i = Ls&send.length-1;
                        while (Ls&send[i]) {
                            $D = Ls&send[i--];
                            !Ds&origin and continue
                            if (Ds&origin != s) {
                                # by .t?
                                Ds&origin.t != s.t and continue
                            }
                            Dc&s == string and return
                        }
                    }
                }
                else
                ss&ball and throw "send R%ball!%toLines"
                else {
                    throw "send R!%ball"
                }
                
                $ch = Rs&chatter;
                ch and ch('send',[ki(string,3)])
                send(string,c);
            };
            Rs&open = &{
                $L = Rs&Lving;
                L && Lc&b && Lc&resumable and 'Lvism el=7 for %sent_dige'
                Rs&eope and Rs&eope()
            };
        },'ift,D'],
        #c A%Sock <-> A:ws!
        # at both ends of the deal
        # provides Rs&Lving and Rs&send()
        # uses Rs&open() and Rs&receive()
        ['Sock','31',&acgtRs{
            $ws = Rs&Sock;
            if (ws == 1) {
                $url = 'ws://'+location.host+'/'+R.t;
                ws = Rs&Sock = new WebSocket(url);
                ws.url = url;
            }
            
            # when R el=9
            me.cbuac(R,'unDoming',&{
                ws.close(1000,'lum')
            });
            $X = window.websocks ||= {};
            X[ws.url] = ws;
            $sockdup = &{
                X[ws.url] == ws and return
                ws.close(1000,'dup');
                return 1
            };
            
            # our A:ws.c hooks
            # this should A:session
            #   reflecting a scene across it
            #   they might hold objects for us,
            #     as we talk to them
            #   or show objects we talk about
            $L = me&rollbs,R,'Lving';
            
            # try leak chatter!!!!!!
            $ch = Rs&chatter = &t,ev{
                # < io-param-like + styles of message with object in
                $l = ev.constructor == Array ?
                    [R.t, ... ev] :
                    [R.t,
                    ws.deter('code',ev.code),
                    ev.reason,
                ];
                each in l {
                    l[i] = '>'+(3+(i*2))+' '+(n||'')
                }
                G&c:'>1 '+t,l
            };
            
            # L logs a %send/receive[D+]
            $roll = &tsoc{
                $L = Rs&Lving;
                !L and throw "ws:L:send!open"
                
                # accumulating dige
                $digek = t+'_dige';
                L.sc[digek] = dig((L.sc[digek]||'')+s);
                
                # point in time log
                c ||= {};
                c.now = G&time;
                # opposite direction's count
                # last in when this went out, etc.
                1 && o and c[o] = L.sc[o+"_i"]
                # tsc causes n ... deep within out of time
                $D = me&tsc,t,s,c;
                ac(L,t, D );
                
                # count
                $ik = t+'_i';
                L.sc[ik] ||= 0;
                L.sc[ik]++;
                
                return D
            };
            
            # open/close/explode
            ws.onopen = &ev,{
                ch('open', ev);
                L = me&rollbsc,R,'Lving','b,increment';
                Rs&open();
            };
            ws.onclose = &ev,{
              ch(ev.wasClean ? 'closing' : 'close', ev);
              ws.deter('code',ev.code) != 'bad' and return
              # will re-new when R wakes
              delete Rs&Sock
            };
            ws.onerror = &ev,{
              ch(ev.wasClean ? 'err' : 'errs', ev)
            };
            
            # send/receive
            Rs&send = &sc{
                $D = roll('send',s,'receive',c);
                # never fails?
                ws.send(s);
                return D
            };
            ws.onmessage = &ev,{
                sockdup() and return
                $s = ev.data;
                $D = roll('receive',s,'send');
                Rs&receive(s,D);
            };
            
            # interpret the machine
            ws.proto = {
              state: {
                0:'connecting',
                1:'open',
                2:'closing',
                3:'closed',
              },
              code: {
                1000:'closing',
                1006:'bad',
                1001:'leaving',
                1009:'toobig',
                1011:'500',
              },
            };
            ws.deter = &tk{
                k == null and return ''
                return ws.proto[t][k] || t+'?'+k
            };
            ws.state = ws.deter('state',ws.readyState);
        },'ift,D'],
    ] };
    

