Foogla: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    =head1 #prepare to A=A
    
    some goals:
    - efficiently educating on A passage of time
    - J to take < 200ms
    - not noticing anyway
    - Elvising running the shower
    - unpatch, failing, patch, passing in a few seconds
    
    =head3 future of sleep: Doming
    A starts works, D are their completion
    
       C   E
     A   D 
       C   C
    
    A C9[C...] completes D and elvises a clone
    
    D - the Aing grouping items sprout inside
      z C & A to include C/group A workload
      provide osc-like cha/continuity without osc,
        yet be the atomicness osc uses to commit,
        and load with decor/nativities to make for mediation
          R:I is now being the osc workload gatherer + commit
            which should work on >=1 'pages' of osc at a time
              eg elvising from ...
              or the whole/9er
            rolling the others,
            being able to async progress,
              do work in parallel or not...
    make unities early to sleep/calculate desires better
      eg. when A is @28, the state can be considered D:early
      eg. when Jpin, S makes domes, which can then be known about
    internal buzz. pages of its ground.
      get composited into D:top, C9[C...] post-osc
      which gets hoisted/elvised into J/W timespace elsewhere,
        the macro-J Doming-looking action: hosting stuff.
    so to:
      make arbitrary groups
        for groups sake:
          naming stuff
          handling streams
        to stabilise/refine our sense of activity
      transport C out of time,
        so J>7 can help J<7 (sleep)
        osc-think may play with things outside of osc,
         < holds that state in a dome it hopes to pull in?
      locate them as possible actions,
        as bumping into a S-ection kinda defines it
          < more at compile time
        and elvis handlers... 1s&ein.sayeth = &acgts{
      know inputs in a tracable way
        Elvising pointing in here,
          as Teing is
        giving Desire pathways to trace processes
    
    Domes may iterate X/V or some structure from another Dome,
      it may be important to iterate locally and do remotely,
        they become transactions
    Desire might want to do something,
    as a new elvis pointing into here would
     Teing is a kind of elvising
       and is the float:right upside down triangle of stuff
         the small network-edge pile coming down into
         the big contenty pile of isness
     Schemas too, float their potential/unfoldment
       down holes they start matching
    
    #c sleep/done =head2 sleep
    
    %slep, a Tool probe
      a way to map their changes fast and sleep
        change of container vs. the values within etc
        can give/take sy&slandige/Ry&Te_slandige
     < could be faster/lessR: callback a huge ==-ish plucker,
        50ms 3%slep could get down to 4ms?
     < unicode everywhere. plants: 💮 🌸 🌷 🌹  🌺 🌻 🌼 🥀  🎕 ⚘ 🏵 🏶  🌱 🌽 🌾  ⸙ 🌰 🌿 🍀 🍁 🍂 🍃  🌵 🌴  🎋 🎄 🌲 🌳
     < Cye takes y=o89 -> ycv=0.089
     < put sdiff and dup etc in 11-ish (dup 1189)
     < C/sc/css compressions, in Line or not
     
    Tool openness
      configures injectoids and transfiguration
      < more timely %differ growing out of it
      real interesting later
    
    < Elvisory re-slaning on %push to it?
       is the elvis delivery mechanism:
        give edifice of deliverableness
         resolve to best case or so:
       if it were a different J:
        enter it, changes input to thisJ
        decide to redome thisJ to involve that,
          or seeing our change come back to us
       Matu-ish out-of-time with %push gravitate reruns
      redo R building on changed elvisory?
      see 'rebuild %push to use e'
       %push currently injects the remote %ball%movingin
         which will not work if its asleep
         but it could be brought around about as fast if:
    < Te the %moves to Elvisory/anywhere
       with a watch for completion and callback/expiry
    < universal vision of rc&ha.dup,
    < replace ravel with Doming and Display2
    < TEST io.i z much
    
    # another
    o rebuild I via Babd ways
     o link G/ to W/G so we can update it ourselves
     o get a Lis rolling nicely
      o tests sign the version as it percolates
    o rebuild jsBab in js
     o fast way changes, lots of test results if you want
     o check against jsBabz for j/2/*
    
    o 'rebuild %push to use e'
      %checkout the tangley varieties of %push
    
    o unify name extrusion (see names extruding)
      like X but with where/when to D,
        alt names and fuzzentations (figure name changes)
          inc. crunchable path descriptions in various datalang
        universal gone/unnoticed system
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
    
    good study.
    perldoc -f study
    # < in general, knowing if the A is for a queue or for right now

    
    #c=head2 Maturation
    
    Gombulus hives elvising going in or coming out
    TX
    
    o a&z toplevel thinker
      and its localised sidecares
      a bunch of A not expecting J overhead
      rebuilding on the Co Joinup
        having it bring G (map of its dependencies) (see Give)
          as an %H of a different name
            once osc piles of whatever hoisting is?
              not much doc about osc hoisting:
               the W/of/t may W/what/ever/it/takes/t
               for stats/accounting
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    
    o and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and W-contiguous
            the simple funtimes embedded in the page,
            if browser compatible, Wake up and do anything
        I-ing up Sevo, then placing more A-ily,
    
    o names extruding, like X but with:
      connection to a dome:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
            done-ish by %slep
              could describe path or so
        decide once D:in !%more
          D:new == D:old to sleep, or:
          clone D:new to D:out and ...
            becomes someones D:in
              border control
        
    o Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    o elvising coming out or going in on the X
      and transacting the change of it
       as Domes, which have versions of Domes going into them
       an osc that keeps everything it sees would be first
        and be the wandering frontiers of change
     
    o making the R an A.
      compiling ravel into throat?
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further) (%slep)
     ongoing bisection of A
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    # anyway
    
    back to Pass...
    
    # thursday:
      new A4,
        < starts from a single /js/ with
          one screenful of prior knowledge
        A calmly pulls in its deps, sets foot...
    # saturday:
    # friday:
      new I compiled fore-way,
        composited and storaged in Pass
        is a layer of tools on a type of wormhole,
         which we also need to grasp moving around
        the bunch of names, Lis
    #c monday:!
    W&Ha:
      bugs:
        seeI 1.2: is one of the Is Mlimits diags wrong?
        a slep inside a slep has some history issue, keeps spawning?
      W&ledges:
       tests slepology:
         specifically elvis change
       since W&edges is too large
     
     unseparated W&Ha starts taking Rc&N>1000 to check out
      its the elvising:
       < to be lv change only
       < not deLinesing to Wing, wait til Ting
      such shapes par importo A=A
      
    W&large_edges:
      W&edges:
       tests slepology:
         wakes on elvis/data change
         %countlife%aTool shows if its awake
         %differ goes round in circles as data loops
       only just able to complete with the current memory leak
       step 9 shows a bunch of yReal vanishing...
       
      toomuch:
       leading to '< %run/%differ' is desire to ease
         accepting changes, to exp or Te
       are both a little far away? would be nice
         but nearly done with tests until A=R round,
         which is likely to see them built more elegant
        - exp: later %doing to bring earlier accepted change
         see %differ. little far away.
        - Te: %doing brings T/$W back if modified
         also a little far away.
         get both diffing,
         the innermost T...%ball that was ==
          cloning that over itself, 
           pointed enough to apply to later %doing
            that wants to resume that state with more
          with a diff/accept stage
           temporarily projected into the %run by %Tool
         Lines|diff must find R per diffchunk
           Bunchology with the diffchunks != new
       will be:
       < linking T/$W -> W:PuTe or W:City:
          T/$W:edges.y.owner = $W:PuTe
           and $W:edges ~ $W:PuTe/$W:edges
          T/$W:City.y.owner = $W:City,
           and $W:edges is further inside, etc
             find refs for $W:City/*
          possibly need more %Lines gathering points
           or a function to gather them on demand
       < diffing T/$W:edges <-> W:PuTe/$W:edges,
         producing R in T/$W that have the change,
          and those that are merely transporting it
            common Lis sense:
              T is species of edges, as is W:PuTe
         so we know the minimum clone-over move to make,
           and what it should be cloning over
             < lv changes later
       < being a pathy clone-in %Tool to apply to later %doings
      
      random niceups
       %testrun=2 'get ahead of %run'
        until %step with boost
       %run: inventstep clones last step
       
       < %City is noisy, we want:
         %slan to turn miniature diff on the noise
          path to the Rthing, lines changed before next Rthing
      
       < %Cit shrinkgrouping known R props
        < group them by the I producing them
         < coder than dictionaries every property you use
       < %Cit visual cues for:
         R:Dough that %Someflav=C:Dough,
           for eg Rs&C = picture of self
          or C.y.Process = R
           things R has may link back to R with typing
       
       and A=R
       
       #   the curves of this paragraph looks great up close:
       #  this is what A:s-ions will look like
       # state changes
       # with casual causla {}
       # along space wiggle
       < %run:
         < using %differ to:
          < cursor various things to keep branchy,
            and hooks to make the test reset/pause properlike
              %differ becoming the time controller,
              %push%act merely a workflow in it
          < %doing brings T/$W back if modified
            probably into $doing/$W (nab%aTool loses %H)
            causing:
          < later %doing to bring earlier accepted change
            eg. PuTe arrangement before every step,
            has the story of elvis along it
            < must be applied as an lv change,
              sensitive to overwriting anything etc.
          < storing lv changes for consecutive %doings
       
    #c tuesdA:
    new/old ground:
    come back to A, they are like R:
      a&z (A.sc.z) are innards, like Rs&z
       only used in A:u
      a&N are innards anywhere wanting attention
       w:TuneTimeMachine gives A to 1s&N
       w:AndContinue: resumes all 3s&N
    so 1 can know what A it has in progress...
     AndContinue shall come again
      building W&Lis
      ...
    have R that can simply keep Ringing?
     < osc must get us back into whatever Ring:
       init: Ring@1 everything (Graze)
       then: resumes all Is&z
      the cores may fall asleep at random
       and may still percolate a Display anyway
       or lock the dome it was finishing from starting again
    see I and repackage:
       A:u makes .I
         mixed from many .I,
         got from /js/
         with async for update/check
       A.4:
        has loop bits, local culture
        .I:
         is everything, mixed up with StyleHut
         .i is all StyleHut,
          figure out what we need to keep
         never goes async, is trusted to be maintained,
         .w:
          has only this %namedcode thing
       A.5:
         looks neglected
         .w:
          is the spot, y&tw for $way
           they s&dige and s&now, G&way asyncs
           want to digwaypoll them, make sync
          all scooped up by Shovel, per test run
           which can make sync prior
    I.w is totally incidental,
    1s&minds[uname] = A c&N[4s&mind[t]]
     u deals with W via /js/, mixes onto Normal
    G&question (and other asyncers) should provide:
      ttl, ready=1 on callback
     to be useful for testing this stuff efficiently
    
     how it starts:
       html <script> get & eval from /thestart?step=n
        sends it A&loadI and Stylehut
         which includes HutNuts (begoin/jsung)
       G&begoin -> G&jsung,'NutMachine' cb -> G&Jinthe
         jsung looks like A:u but overwrites any A.I[t] = W:of it loads
         Jinthe sets up listeners,
          waylays NutGravy, defines function,
           waylays NutReady, more waylays.
     
     will start:
     < A&loadI a simple A:u@6 etc for basic mind mixing
       gather more mind, global functions, start loop
      should less async, and:
       be totally new ev/e hookup:
        Display:
         lose on.A
          use attr t/cv, attr sip if sJ
          and lookup to the sips of 4s somewhere global
          A.4 must always know about elvising
         lose jQuery,
          moving elements only as needed,
          text inputs not rebuilding every time
       
       ways to keep track of updates...
        make an islanding that can digwaypoll for:
          w change
          W change is regular /W/ with dige...
        know W that contain other W we are watching,
          digwaypoll for notify of W changing?
          could be wired into /W/
           not for the same socket?
         future /W/ storer is an elvising with a route,
          only then demands stringify to get across the net
    
    #c Wednesday
    water cactus
    very thinning impossibleness:
    < s&lv should come from the $main/A.4
       output modes are a T
    < frames
     < ifr:blank.html, inject with <script> etc, save
     < the html we build able serialise most C
       such that search engines will see it
         $Cs&W.html becomes the href=""
         going to build a lot of piles of <stylehouse>
    < jsBabz should S to an indent, work in R
    
    W:Pass %ball web surfing
     < keep openness from last time - part of:
       provide autosaved W/T from last time
        these could be tracked separately, likely to be mostly garbage
     < testbedding
       < deps: %Gounce - ghost versioning
         knowing exactly each I it ran with
         making cert to help that Gounce get places in W:Lis
     < %play%W more properly,
         see Be, can play out over time...
           minor %R-ish manage what seems to be a situation
         Rsync %gee%ball late,
          checkout fully, same Ring (T.Rq?)
           see about when %gee hits 92 before children done..?
     
        # between
        #   fio(F...) # f tv
        #   fabioty(p..., # R f is for tv
        #   Rc&X, Rs&Te
        #  we have a few ways to gravitate the elvising made
        # < ad hoc continuity:
        #  < mez&rename (now ballrename) takes Rs&Te
        #  < mez&move should takes Rc&X, in some cases?
        #    if the A of it can be trusted to resync
        # something somewhere in the equation of Waltz
        #  knows exactly why things changed,
        #  holds and spreads knowledge of the move
        #  which may be done out there as:
        #    lv with an el:9, el:6 ?
        #     6 implying recycle the last 9,
        #       or some specific one,
        #       or resurrect recently deleted...
        #      similar logic to:
        #      Lc&responsey - expect one receive per send
        #  requiring all these interations to be suspended
        #  over the judders
        
     %play%R starts:
     %Doming:
       building up how to J(.3)
        < have Swim-ish any index hoisting
           mixing/reducing
            ting Merge.js for J, with W:of
        < ting search in %Doming
          building indexes of I when they are required,
          elvising changes:
        
     ballio, Ravelvis are
     %ios:
      < %balls have io/slep sense
        for intended+not changes
       i wanting to happen
       o happened before
        desire/surprise carrier
        < slep/io <-> what Reaction, batched
          eg /seek/ -> %do_Further()
         < via Sectiona, for an atime iterator of /seek/
       quite to do with:
     < one big %ball,
        < some of it grounded
          there are C from/for Activity (osc-levitated)
          and C for being the sticks in the mineshaft
          < have a CdaR (fast) way to diff %balls to themselves
          whatever it takes
        < getting that change to Rsync %balls,
       < even out of sync, to a degree
        < these ch() comments shall Tool down to
          fleeting speechbubbles, beneath the line
        < tree -> table mode as we cross the line,
          smoky action -> seeing office mode
       
     Mwty
       rearranges modulats
       dressing %ball%fixes for being about ...
       eg the attr on a %Rom messes with the %Doming
        and gave/give each other life
     
     %JRom:
       is separating into %Doming
       
         encapsulates activity, Doming in and outs
         parts have error and (1|4)s&N plumbing
         < T plumbing (see control)
         < pausing if time/sheer Ring intensive
           could control infinite loops in the same Ring
             the first Ring inside 4 should ttl when starting Ring
           for progress, may Ring more, when theres time
             sleeping for Display meanwhile?
               Rc&X will wander, merge the eventual completion
             or osc-ing each section as it completes
               like Doming, wants recode with T sense,
                recording the set of args used, etc
         
         < R:Mapper may also have a little e/Mw on each of many,
           hanging up its thinking amongst others language
           
         < folding, taking %noDisplay off chidlren with activity
       
     %mund: de-lies fact piles
       various eg %Ghostways produce stuff
       they each become a Ghost unto further ...
       
       %Ghostways:
         your version checker
          travel agent
         historically:
       %GhodigWap:
         insures /way/$t against %mundws:digwaypoll
         < tractorbeam $Way into Ghost/Way,
           leaving the hoisting to $Way/5Iw up to mund
           this Ghosts best guess for those ways
           and providing data on dupover, etc.
           and helping lay out ref phylogen
         < G&ting/%ting forcing question/remote check
       
       sidenode:
         everything we n ... in R is really an m Rs&M ...
           unless it Cc&R: spawns R, c.* copied to sc.*
         such is a tubeending
      
       
     #c t!
     t:
      is thing finding
      t looks up A slope of places with things
      t looks in the dome building now...
       and for A-things around the place
        as A needs to find As to A
         t learning how to traverse every index
      # now:
      G.h(acgtt) does $t subroutine (I.i.h does I.i.$t)
       therein looking for $t becomes:
        G.t(acgt'i't) to avoid infinite h<->t loop
      # future
      B/T stack sensitive
        any call may be paused by a variety of reasoning
      G&lathe,3 Babz:
          G(A,C,T,'lathe',3)
      # or perhaps inlined non-inlined sub calls (no B-stack)
          G.i.lathe(A,C,G,T,3)
      # or totally inlined: ({}-scoped lexicals?)
          s&surface-- for 1..$s;
        this will be handy for generating G&throat
         from the dimensional joint protocols the I use
         these will need variants, as me&Ring is
      
      # lots of lang shall compile to lots of G(...)
      #   anywhere we thing stuff
      G = &ACTs{
          # like G.h
          $G = this;
          $args = arguments.slice(4);
          # simply looking for a function, closest A with it
          $i = is_string s ? G.t(acgt'i',s)
              # looking for something crazy,
              #   may even take args about this call
              #    and beyond, to find the right thing
              : G.t(acgts,[M]);
          B/T stacking {
          T.return = i(A,C,G,T, ... args)
          }
          return T.return
      }
      G.t = &acgtM{
          # like G.ting
          # matches whatever W/C/c in M
          #  sequences of them usu mean by z,
          #  array of arrays for resetting cursor
          # can also mean start doing a thing,
          #  nearby doming invites it to keep state
      }
      # further future:
      Babz realising parameters on things:
      G&$Self$Ne:za,$R$s$c:limin,%vang
      packs in the:
        G.t s={Self,Ne} c={R,s,c} 
         looking for (s) $Self and $Ne
          knowing the act (c) if that helps?
           or would it get confused with more itemology
            spose G could decide on the first being WHERE,
             the others being some extra into
             seems like something for doing subroutine calls remotely
        running it %vang mode with named arguments
         %vang could specify output form,
          a style to apply on something inside (G&tsc)
          some T-condition, error/async continance
          or name the object created
           t looks in the dome building now...
      T-condition,
       check it every B-stack (soon to be a lot of them
       error/async continance
    =cut
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #    C.y.R = R:C
    #   sprouts some sc to R:$gk or so
    # < determine, certify version of etc involved
    # we have a village's machinery for progress
    # < teleporting in: knowing you want such sleep pattern
    #    for vibrating values (oscillation)
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c Be.C - group C.*.*
    # see %Cit/KnowC
    # < I, a W of qualities and how to use them
    $Be = me.Be ||= {};
    # < more C
    Be.C = {};
    Be.C.Cit = {
        scgk:'Cit,fromsitop,scan',
    };
    Be.C.R = {
        ygk:'R',
        cgk:'d,N,X,V,refs,refR,inC',
        scgk:'X,ci',
    };
    Be.C.Rlimits = {
        cgk:'dupl,nl,dl,dubquiet',
        scgk:'boost',
    };
    Be.C.Rplay = {
        scgk:'boost,Te,playsheet,elvis',
    };
    Be.C.History = {
        cgk:'b,V',
    };
    Be.C.Display = {
        scgk:'C,Mw',
    };
    Be.C.fun = {
        scgk:'tightly,inheritsc',
    };
    Be.C.in = {
        ygk:'in,tw,tv',
        scgk:'z,Wind',
        sc: {
            Wind: {path:'t,dige'}
        },
        wanderin:'together',
    };
    Be.C.space = {
        ygk:'cv,ov',
        cgk:'cv,ov',
    };
    
    Be.nks = 'y,c,sc'.split(',');
    me.BeCload = &{
        each K,Kc Be.C {
            Kc.K = K;
            each ik Be.nks {
                k += 'gk';
                !Kc[k] || typeof Kc[k] != 'string' and continue
                Kc[k] = Kc[k].split(',');
            }
        }
    };
    #c Beings arrive, find C.*.*
    me.Bear = &acgtRsk{
        k == 'play' and Be&plays,R,s
        else
        Rs&ball and Be&lums,R,s
        else
        Rs&fix and Be&fix,R,s
        else {
            throw "No Bearing"
        }
    };
    
    # 27%play via %playsheet
    Be.plays = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q )
            .map(D => Be&playit,R,s,D );
    };
    # 3%ball sprawls out
    Be.lums = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q,{ohm:1} )
            .map(D => Be&lumit,R,s,D )
    };
    # 3%fix is a thing
    Be.fix = &acgtRs{
        $p = Ry&up;
        # Be: inherits from %ball's lumit
        #  via %BeX.xtk[$sc][$gk].exRsc.BeD = fixit's D
        #    < should also know lumit's D
        ps&BeX and Be&BeXarrive,R,s,[R.t,'fix']
        $D = Rs&BeD;
        #  or %Be[$sc][$gk] = lumit's D (GOING)
        $be = !D && Be && ps&Be;
        be and D = be[Rs&fix] && be[Rs&fix][R.t];
        # may %viewvia=ki|size to gkness
        # and %inputmode
        # < %fix%play should grow the meaning etc
        D and Be&fixit,R,s,D
    };
    
    # Be about here.*.*
    Be.scan = &acgtRs{
        $M = []; # q+
        each kt Be.sc {
            !hak(s.sc,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        each kt Be.y {
            !hak(s.y,k) and continue
            M.push({tatch:t,nk:'y',gk:k})
        }
        return M
    };
    
    # makes D for q, thing attachment mode specifics
    #  D also gets how to act
    Be.cutch = &acgtRqc{
        $D = G&Cye,[q.tatch,5,c||{}];
        !D.t and throw "!t"
        # sc from matching
        q and ex(D.sc,q)
        # c from matched, the how
        Be[D.t] and ex(D.c,Be[D.t])
        # known properties on %ball%Be
        if (Ds&nk && Ds&gk) {
            # < Rc&X.Be.nk_gk for:   and Dc&b...
            $be = Rs&Be ||= {};
            be = be[Ds&nk] ||= {};
            be[Ds&gk] = D;
        }
        return D
    };
    
        #c BeX getting a %ball/me&lumit's Be-ing to a %fix/me&fixit:
    
    # set properties of children that don't exist yet
    # see RbitX
    Be.BeX = &acgtRsD{
        each kc Dc&BeX {
            $name = D.t+' '+k;
            k = k.split('%');
            $t = k[0];
            k = k[1];
            # cousin of R.c.X/V
            $X = Rs&BeX ||= {};
            $tk = X.xtk ||= {};
            tk[t] ||= {};
            $oX = tk[t][k] ||= {};
            # where .x=[more R.t],.xtk=[more nk/gk]
            # and non-path things apply to the arriving R
            $sc = oX.exRsc ||= {};
            # rogue generation of D
            # < use cutch, make complicated Be[t]s
            sc.BeD = G&Cye,[name,5,c];
        }
    };
    # X.xtk = R.t, R.sc gk
    Be.BeXarrive = &acgtRsl{
        $p = Ry&up;
        $X = ps&BeX;
        !X and return
        # walk a path of x to X
        $x = X.xtk;
        each in l {
            x = x[n];
            !x and return
        }
        Rs&BeX and throw "Already at RsBeX"
        Rs&BeX = x;
        # check in
        x.z ||= [];
        x.z.indexOf(R) < 0 and x.z.push(R)
        # apply
        x.exRsc and ex(R.sc,x.exRsc);
    }
    
    
    
    #c Behave from C.*.*
    # localises & applies Dinstructions
    
    Be.playit = &acgtRsD{
        !Rs&ball and throw "What"
        Dc&play and Dc&play(A,C,G,T,R,s)
        else {
            # vaguely know it, not a c&play-er
            # < later check some Be used the %play
            # < thing's sc wants upgrading mode
            me&tsc,"!play:"
        }
    };
    
    # R%ball
    Be.lumit = &acgtRsD{
        # symbol blocks the way, and leads on
        $c = {k:'clicktoplay',y:&v{
            me&introqua,R,{play:v}
        },Mw:'Be',tsc:'T',relax:1};
        me&rolltog,R,c;
        $n = c.n;
        
        nc&s = Ds&gk;
        Dc&symbol and nc&s = Dc&symbol
        nc&s.length > 5 and Dc&symbolsize ||= -5
        Dc&symbolsize and ns&fs += Dc&symbolsize
        
        # c&nofurther - stop adding R under this one
        #  recursion control
        Dc&exRc and ex(R.c,Dc&exRc);
        $p = Ry&up;
        each kc Dc&ps_Dc {
            p.sc[k] and ex(D.c,c)
        }
        Dc&BeX and Be&BeX,R,s,D
        
        # %play things tend to hide/represent in-%balls
        Dc&ohm && Dc&play and Dc&hbb ||= 1
        # otherwise it costs 1 boost
        # < consumable if Tie remembers
        !Dc&ohm || Rs&boost > 0 and 'open'
        else {
            # tend to hide every R inside...
            !Dc&hbb and Rs&nofurtherDisplay = 1
            # very high level view of what else scans interesting
            ss&z &&
            n withz  s:z %fs:14,hs:966
        }
        Dc&hbb and Rs&hideballsballs = 1
        # do more display?
        # look up for a qua ac?
    };
    
    # R%ball r%fix
    Be.fixit = &acgtrsD{
        $R = ry&up;
        !rs&fix and throw "What"
        !Rs&ball and throw "What"
        # apply styles to r%fix
        $st = 'inputmode viewvia'.split(' ');
        each in st {
            !D.c[n] and continue
            r.sc[n] = D.c[n];
        }
        # < symbol's styles fitting into %fix n t
        #     might be too complex to read
        #       sprout as necessary
        if (Dc&play) {
            # can %play sometimes (via the %ball)
            # likely to show %fix t/s?
            s == '1' and me&tsc,'onething','=1'
        }
    };
    
    #c Bersonality of C.*.*
    # effect C representation
    # known properties may ... (%ball%play)
    Be.sc = {};
    Be.y = {};
    
    # s&H
    # stored object
    # < boostrap from H:1
    # < know exactly where it is (/G/*)
    # < know history of it across history of s
    # < history of s vs. history of R, getbetween.
    #   values exist somewhere fractionable in Domes,
    #   pinned down every so often from various angles
    #    levels and resolutions, compromises
    #   simply have to play lv in reverse, watching path
    #    lv must play from an el<3
    #    to know it has everything in the situ,
    #     which could be localised to part of the path
    #     < lv requests should serve grep into paths
    #       thence almost-Lines wants to end up in a database
    Be.sc.H = 'sH';
    
    # s&quiet
    # eg a Js&Te doing usual work
    Be.sc.quiet = 'squiet';
    Be.squiet = {symbol:'q'};
    
    # y&lv
    #  boundary to a done thing that will join to us
    #  eg. your %Lines hoists the s.y.lv as itself
    Be.y.lv = 'ylv';
    Be.ylv = {symbolsize:-2,exRc:{nofurther:1}};
    
    # s&of
    # code, generally compiles, /\n$/
    Be.sc.of = 'sof';
    Be.sc.js = 'sof';
    # sets up openable codon on s%fix
    Be.sof = {BeX:{
        's%fix':{inputmode:2,viewvia:'size'}
    }};
    Be.sc.string = 'sstring';
    # sets up openable codon on s%fix
    Be.sstring = {ohm:0,BeX:{
        'string%fix':{inputmode:2,viewvia:'size'}
    }};
    
    #c Beeple of C.*.*, proto s&R
    # s&W
    # < opens that Wormhole in the nearest %gee
    # < located around here:
    #    i ^^%gee/$W y o ^^/G/$W
    #     then %gee late Rsync,
    #      so openness can occur in this ev'd Ring
    #   this would be the stately G&ting
    #    5 could know all the W we use
    #   iter `dig`
    #   < hostinfo
    # < as another J,
    #   managing pause/sleep modes of them
    Be.sc.W = 'sW';
    Be.sW = {play:&acgtRs{
        # becomes signpost leading in
        $l = me.cbu(R,'gee');
        ls&openness.push(R);
    }};
    
    # s&J
    # probably a J:1,
    # make W from the elvisory
    Be.sc.J = 'sJ';
    Be.sJ = {play:&acgtRs{
        ss&J != '1' and throw "nonJ=1"
        # feeds with e
        me&Ravelvis,R,s.t;
        # < unDoming
        ac(R,'unplaycb', &{ me&Ravelvis,R,s.t,9 })
    }};
    
    # s&testrun
    # does a test via W:Co
    # < elvise it
    Be.sc.testrun = 'stestrun';
    Be.stestrun = {play:&acgtRs{
        $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
        Rs&Te && Rs&Te.sc.almost and ls&almost = 1
        me&introqua,l,'boost:2','@1'
    }};
    
    #c Beepingness
    # %play engaged tasks
    # Doming & Beeping will separate
    #   Beeping has empirical noise,
    #   particulars have idealism or more noise
    #   toward being a network stack
    me.Beepingness = &acgtR{ return [
        ... me&KnowCitingness ,
        ... me&Tingingness ,
        ... me&Tongingness ,
        ... me&Socketingness ,
        ... me&Domingness ,
    #c %garbec
    =pod
    garbec%R: garbage collect localStorage
     , regex for %W and %H
      < know %parent, ship everything off to a git
       < as a %Gensing?
         with an %H/differer for the current state of it
         but just be an R, opening bits of net puzzle
         posit deletables, do one last grep for their %H
       good for up to 5MB?
       %H:
         any non-W chunk, storage t=dige -> string from Lines
         must %Lines encode H:... for regex
         < Lines could have many sc, keep first clean looking
       < %H may all hoist to the top, as in w:Writer/Gversioning
         would look like %Has:0294u390;34ui902d;345u209u3;3u8490j
    =cut
        # boost <0 to rescan. >0 to delete
        # < bright future of the backroom
        # < for the enclosing %gee
        ['garbec','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            
            #Rs&somehash = window.fogive ||= ex({},localStorage);
            Rs&somehash ||= localStorage;
            
            (Rs&boost||0) < 0 and 'rescan'
            else
            me&rollbs,R,'figure' and return
            n Pass  R %garbect,viaW
        },'ift,D'],
        ['garbect','3',&acgtRs{
            Rs&noDisplay = 1;
            me&tsc,'nothing';
            $k = R.t;
            $g = me.cbu(R,'garbec');
            # < use $k=Rc&s and Rc&refs to dedup
            $te = gs&garbect_t ||= {};
            te[k] and return
            te[k] = R;
            # order importo par stat hoist
            ac(g,'garbectN',R);
            # read
            $v = gs&somehash[k];
            !v and return Rs&err = "No "+k
            
            $l = v.split("\n");
            each in l {
                # < using Wm[3]: where the match started
                #   and showing the path through this place
                #   %garbect are places/storage points/gravity wells
                $Wm = n.match(/(H):(\w+)\b/);
                if (Wm) {
                    $H = Wm[2];
                    n $H  R %garbect
                    continue
                }
                # the s&W usually 1, encodes to just 'W'
                #  otherwise it's a different W this one must accompany
                #  eg %of is required (eventually) to wake up code
                $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
                if (Wm) {
                    $t = Wm[1];
                    Wm[2] and continue
                    # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                    n $t  R %garbect,viaW
                }
            }
        },'ift,D'],
        ['garbectN','6',&acgtRs{
            $te = Rs&garbect_t;
            Rs&figure and throw "garbectN + figure"
            $d = Rs&figure = {};
            d.to = 0;
            d.total = 0;
            d.disco = [];
            d.discotal = 0;
            each kv localStorage {
                d.to++;
                d.total += v.length;
                te[k] and continue
                d.disco.push(k);
                d.discotal += v.length;
            }
            $N = Rs&garbectN.slice().reverse();
            # < size of Ws sans in-Ws?
            each ir N {
                rs&err and me&tsc,"err",r.t+"_err:"+rs&err
            }
        },'ift,D'],
        ['garbec','7',&acgtRs{
            $d = Rs&figure;
            !d and throw "!figure"
            
            each kv d {
                typeof v == 'object' and v = v.length
                n t  $s:k %hs:999
                typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
                n s  $s:v
                n sp  s:\n
            }
            
            # delete the disconnected
            # < check it's a %H-type key,
            #    deleting W should be harder,
            #    but we can't really tell...
            # < know what hist
            if ((Rs&boost||0) > 0) {
                delete Rs&figure
                each ik d.disco {
                    # check they exist
                    !Rs&somehash[k] and throw "to delete, no: "+k
                }
                each ik d.disco {
                    delete Rs&somehash[k]
                }
            }
            delete Rs&Te.sc.boost;
        },'ift,D'],
    #c t/%lvhashave
    # test Element replacement with minimal add/remove
        ['lvhashave','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '7px dotted green';
            s&hue = -70;
            
            $td = [
                'jus fibre g/twas jus fibre g',
                'jus g/twan jus',
                's van to dich/ze van dich toat to',
                'toad transfer lich/fur lich trom toad',
                'sle sla van to dich/sla van sla dich sla toat to',
                'further towards ye goal goal/no further goal shall goal ye',
                'test data shall/test shall gall data',
                'test to nuf fla flong/fla test flo flong to nuf',
            ].map(&s{ return s.split('/').map(&s{
                    return s.split(' ')
                }) });
            
            
            each in td {
                $got = n[0];
                $exp = n[1];
                
                $D = G&Cye,["case_"+i,''];
                Ds&got = got;
                Ds&exp = exp;
                Ds&V = 1;
                #exp[0] == 'fur' and V = 2;
                
                # 6
                me&lvhashave,D;
                
                # 7
                $space = ' ';
                each in Ds&cha {
                    $tn = Ds&actN[i];
                    tn = tn ? tn.join(' ') : "?";
                    me&tsc,'elementing',n,'1b'
                    me&tsc,'elementfunc','@'+space+tn,'1q'
                }
                
                
                if (!Ds&actN || Ds&fail_elementing) {
                    me&tsc,'started',got.join('-'),'1d';
                    me&tsc,'exp',exp.join('-'),'1p';
                    me&tsc,'element',Ds&lvd.join('-'),'1b';
                }
                else {
                    me&tsc,'elementingok','OK.elementing',1
                }
                
                if (!Ds&have || Ds&fail_brute) {
                    me&tsc,'output',Ds&have.join('-'),'1p'
                }
                else {
                    me&tsc,'outputok','OK.brute',1
                }
                
                Ds&fail and me&tsc,'%fail'
                Ds&total_change and me&tsc,'%total_change'
                
                me&tsc,'---',null,'1'
            }
            
            Rs&Sampley and me&Sampley,R
        },'ift,D'],
    ] };
    #c func Dome
    
    # saves your n ... as joined c&s text
    # some care to \n regularly
    # < unicode embedded colours, see G&intag
    me.Sampley = &acgtR{
        $s = '';
        each in T.nN {
            ns&R || nc&R and continue
            $headed = 0;
            if (n.t.includes('lv') == 0 ||
                n.t.includes('change') == 0) {
                'swathe'
            }
            else {
                s += "\n"+n.t+": ";
                headed = 1;
            }
            s.substr(-1) == "\n" and headed = 1
            ns&dis && !headed and s += "\n";
            nc&s and s += nc&s
            ns&dis and s += "\n";
        }
        s.substr(-1) != "\n" and s += "\n"
        $c = G&Cye,[R.t,'',{sample:s}];
        $l = me&Copy,R,c,{t:'Sampley_lv',ball:0,Lines:3};
        Rs&Sampley and Rs&Sampled = l
        return l
    }
    
    # like G&ind, or Rc&s=C climbing
    #   returning Rc&N.map(Rc&s)
    # and setting yup
    me.sunN = &acgtsdl{
        d ||= 1;
        l ||= 5;
        d > l and return []
        $N = [s];
        each in ss&z {
            ny&up = s;
            N.push( ... me&sunN,n,d+1,l )
        }
        return N
    };
    
    # cell wall style
    # < dome for geometry adjustement on its own
    me.walla = &acgthc{
        R = Cy&R;
        me&walls,R,h,c;
    }
    me.walls = &acgtthc{
        !isC(t) and throw "walls C"
        !ty&R || ty&R != t and $C = t
        else {
            $R = t;
            $C = Rs&C;
            !C and throw "walls R!C"
        }
        $x;
        typeof h == 'number' and x = {m:h}; h = null
        c ||= h || {};
        typeof c == 'string' and c = G&peel,c
        x and ex(c,x)
        
        # can be used to style any C
        if (R) {
            Rs&C != C and throw "Cy&R not Rs&C"
            c.m == null || c.r and Rs&rowish = 1
        }
        
        # mass/space from others
        c.m and s&ma = c.m
        
        c.hu and s&hue = c.hu * 10
        if (c.wi) {
            # wider than parent
            $f = (100*c.wi);
            s&wi = f+'%';
            f > 120 and s&ml = (-(f-120))+'%'
        }
        c.bd and c.b ||= c.bd
        c.ba and c.b ||= c.ba
        if (c.b) {
            # (border px).(rounded em)
            $s = (''+c.b).split('h');
            $geo = s [0].split('.');
            
            $px = geo[0] || 0;
            $round = geo[1];
            
            $colour = 'blue';
            if (s [1]) {
                # < unify as hue
                colour = s [1] == '5' ? 'green'
                    : 'white'
            }
            $style = c.bd && "dotted"
                || c.ba && "dashed"
                || "solid";
                
            s&bo = px+'px '+style+' '+colour;
            round and s&br = round
        }
    };
    
    #c func Dome t
    # phil somewhere rising
    
    # G&t for this thing
    me.herer = &acgtD{
        $very = arguments.slice(5);
        $s = D;
        each in very {
            typeof n != 'string' and throw "!s"
            # should know where D%in.$tv=C
            #  or D%in=in/C or D/in/C or Dc&X...
            # by the D it's in
            $v = sy&tv $n
            v ||= s.sc[n];
            s = v;
            !v and break
        }
        return s
    };
    
    #c e thingers
    # e as far as ravel goes
    # W: $t/R/[path] of Remote
    # k: mode/act/hook of delivery
    # D: the item to deliver
    # we used to: e $W $D
    #  and got a C that .t=$W, c&e=$D
    # the k not being part of D means D can be more like ec&s:
    #  the item being delivered
    #   which might still be requesty, depending on k
    # k:
    #   M: i 1s&Tes&M/$D
    #     < io param each A.1, 1s&Te & 1s&Tes&M
    #       and mean something
    #   < something like me.RMount
    #     similar/future bunch of things then replace
    #   9: deletes Te
    # < native undo:
    # < when it's
    #    el=1 (creation),
    #    el=2 (more forceful/recreation,
    #      and implies it's the only thing with that t
    #    el<3 implies it's a full copy (to the next %W/H)
    #    el=3 is an update
    #    ...
    #    el=8 keepalive or reference for ordering
    #    el=9 deletes
    # < how it's
    #    coming from a process writing down its deps
    #    something output from osc,
    #     maybe wanting to include those deps ^
    #      as it fits into the store's system
    # < doing all of its procedural thinking via elvis,
    #     and cX state as transactions
    # < everything believed goes through elvis,
    #     then it can be natively from somewhere
    # < el.y.A having 4's being-there consciousness,
    #     partly workable out of frames
    # 
    # e async is ok, n async only if truthgap or sleep/later scheme
    #   your meanings may vary that
    #   eg elvising from G&ting to look up a /js/ would throw async
    #    placing some W:js question,
    #     which could trust cache
    #     look it up in a variety of places:
    #      /W/Somewhere/ju/$t.js for <script>
    #      /W/Compiles/$t is W:$t inc I
    #     or even build it:
    #      make W/Compiles/$t from ghost,
    #      elvising codes to W:js, compiles I
    #        of wants to keep
    me.Ravelvis = &acgtRWkDc{
        # there
        $el = typeof W == 'object' ? me&introqua,W
            : me&stackTe,[W];
        # lives (async awake) (if $Elvisory/$el)
        els&J = 1;
        
        # may be sc
        c and ex(el.sc,c)
        # then cc&el
        c ||= {};
        c.c ||= {};
        # hook
        k == null and 'nothing doing, just async awake'
        elsif (k == '9') {
            i 4s&elvisory/-#$W
        }
        elsif (k == 'M') {
            if (els&M) {
                me&yfuture,els&M;
                els&M.indexOf(D) >= 0 and cc&el = 8
            }
            ac(el,'M',D)
        }
        else {
            throw "elvis?"
        }
    };
    #c Domingness mund ravelabhion straight curvy cellvey
    # < goneRbitX as savepoints
    # < regroup... me&Rom, etc, ways to do things
    #  elvising, everything sleeping until laters wake em,
    #  doming as the flow of signal/control
    #  and physical space, esp code
    #  general linkage to phil somewhere


    # finds r = t/** at depth p
    #  adds to their rs&Mw.rolltog about may:k
    #  returns list of r with k=on
    me.iostyle = &acgttpk{
        # < p for path, [y,M] for ioty
        typeof p != 'number' and throw "Set depth p"
        $N = me&ioty,t,p;
        $M = [];
        each ir N {
            if (k == 'Look') {
                # resists mess
                $show = me&rolltog,r,{may:'Look'},0;
                !show and rs&nofurtherDisplay = 1
            }
            else {
                # Rs&$k takes the ball, once?
                $c = {may:k,once:1};
                #k == 'Upload' and delete c.once;
                $doing = me&rolltog,r,c,0;
                doing and M.push(r);
            }
        }
        return M
    };
    # Elvisoir > mez&clone < e ...
    # the clone-over (or not) usuality,
    #  no taking the top level
    # < pass D to clone's Copy to save it needless work
    me.polout = &acgtvr{
        $R = Cy&R;
        $D = G&Cye,['apolout',{R:R}];
        ac(R,'polout_z',D);
        
        $mez = me&ballio,R;

        # r/* is a land cloning into v/*
        me&polify,D,v,r;
        me&ioty,r,'%ball' .map(&s{
            ac(D,'cloned_z',s);
            # < check in to D, do el4/9 better
            $S = mez&clone,v,s;
            ac(D,'clone_z',S);
            me&Rsync,v
        });
        me&polifate,D;
    };
    
    # r/**%balls N=['path','somewhere']
    me.fabioty = &acgtrN{
        return me&ioty,r,N.length,{st:N,zvia:'s'};
    };
    me.ishad = &acgttN{
        # < partial matches
        N = me&fabioty,t,N;
        N.length < 1 and return
        N.length > 1 and throw "many"
        $f = {r:t,N:N};
        # they to where they had it
        f.row = me.cby(N[0],&r{ return r == t });
        return f
    };
    #c polify
    # i $h/* y o $t/*
    # where anyone can have policies for ...
    # eg keeping $t/Elvisforthis only in $t
    # < discover any overlap, hardwire decisions
    me.polify = &acgtDvr{
        Dy&R != Cy&R and throw "D!R";
        !vs&ball and throw "delt!ball"
        !rs&ball and throw "dealing!ball"
        $vr = [v,r];


        each ih vr {
            $t = h == r ? v : r;
            $po = h;
            each kc pos&pol {
                # po always h(ere), where polcify applies
                # h is v going in, r going out
                #   me&clone,v,r flows <--
                # t(heir) is the other
                # has is for h, have for t

                # check for path
                #  hooks may depend on finding stuff here or there
                $fort = c.forTepath.slice();
                $inwhat = '('+fort.join('/');

                # later referred to as f
                $has = me&ishad,h,fort;
                $have = (c.either || c.their) && me&ishad,t,fort;

                !(has || have) and continue

                # adds a polification
                $lo = G&Cye,[k,1,c];
                c&pi = 'polify';
                ac(D,'z',lo);
                # builds an act, for in/around cloning
                # f (has|have), el=s, r? (if!=f.r), callback?
                $sync = me&polsync,lo;

                los&here = h;
                los&has = has;

                los&their = t;
                los&have = have;

                h == r and los&leaving = 1

                if (los&leaving) {
                    # have something, protect them from it?
                if (loc&nonleaving) {
                    # < avoid cloning out things that don't move
                    #   Copy untils, to catch the same tving sesh
                    # they might have something to preserve
                    have && sync(have,4)
                    ||
                    # climb has there and delete
                    has && sync(has,9,t);
                }
                }
                else {
                    # given something, protect us from it?
                if (loc&nonoverwrite) {
                    has && sync(has,4)
                    ||
                    have && sync(have,2,h);
                }
                }
            }
        }
    };
    #c polifate
    me.polsync = &acgt,lo{
        return &fsry{
            loc&sync || loc&el and throw "doublesync"
            !s and throw "no el"
            loc&el = s;
            $sy = loc&sync = {f:f};
            typeof r == 'function' and y = r; r = null
            # this f/row can be tried somewhere it wasn't:
            r and sy.r = r
            y and sy.cb = y
            return 1
        }
    };
    # post-clonial
    me.polifate = &acgtD{
        each i,lo Ds&z {
            $sy = loc&sync;
            if (sy) {
                $f = sy.f;
                $bet = f.row.slice();
                # the thing before
                $v = bet.pop();

                # < code these more positively: $t is= bet.shift()
                f.r != bet.shift() and throw "here not t", "bet.shift()"

                # the thing we change
                $r = sy.r || f.r;
                # walk almost there
                # < many f.rows
                $n = me&fabioty,r,bet.map(t=>tc&s.t) [0];
                if (!n && loc&el == 4) {
                    # rebuild between r and v
                    $rr = r;
                    each it bet {
                        n = me&fabioty,rr,tc&s.t [0];
                        1 && n and rr = n; continue
                        # < input,rr,t recycle/refology/fork
                        n = me&input,rr,tc&s;
                        rr = n;
                    }
                }
                if (n) {
                    # grab what is there now
                    $cs = nc&s;
                    $ks = vc&s;
                    # < should know it's a Copy
                    $si = me&fabioty,n,[ks.t] [0];
                    $is = si && sic&s;
                }

                # do something
                if (loc&el == 2) {
                    ac(lo,'todo',"Accepted over nothing: "+kss&play);
                }
                elsif (loc&el == 4) {
                    !n and throw "Deep 4"
                    # el:4 leaves things,
                    # < may move subjectiver experience
                    # unoverwrite what was there
                    if (is) {
                        los&removed = is;
                        i $cs/-$is
                    }
                    $en = me&input,n,ks;
                    me&Rsync,en;
                    ac(lo,'todo',"Unoverwrite: "+(is&& iss&play)+'->'+kss&play);
                }
                elsif (loc&el == 9) {
                    !n and throw "Deep 9 ok?"
                    # ensure v is deleted once there
                    los&removed = is;
                    i $cs/-$is
                    me&Rsync,n;
                    ac(lo,'todo',["Drops:",r,n,v]);
                }
                else {
                    throw "sync el "+loc&el
                }
            }
        }
    };
    #c Be.sR theory - adjust raised sticks
    # at %ball%play
    =pod
    s&R:
      how to conjoin an other:
    the ground wakes up, doing a J (R for now)
    from a C%ball describing the J
    
     %R=+Save gives %ball%Save
       < separate that kind of thing to %A
      
    if no ^^4%Gens:
     R=Tool makes %ball/r%Tool
       s.sc -> r.sc
       s%z -> r%nz
         is the out %ball cluster continuing inside
           waking up into this layeR
    else:
     R=Tool makes %ball/s.t%Gens%ting/r%Tool
      %Gens creates the thing with memory
       if sc&el=1
         !%ting
       else
         initialises Livec&Tool=1,
           out-s* able to form high level pictures
         Live.c also -> r.sc
    
    %R=1-9 turns into %Doming (the slope)
    
    < %MindInto projects R=... to make thinks into Know/**%ball
      leaving the insphere intermediacies savable
    
    < above may have %methods to continue through our being
      %methods over slopes
    
    %Gens:
      for/in R%ball (usually)
      wakes up R/%Gens/r with its memory
        got via %Gens%ting unless in outs-only mode (sc&el=1)
       < cautiously if no memory:
      < care to authenticate code running by it
    
    %JRom:
      domes it if s&R>=3:
    < elvising (networking)
       %ting consumes stuff from the network
        so people opening the same thing get connected
        and theres a spout for updates/locks
       for acts of change
        to have a formal place
        and they may be 
       see Ravelvis etc
    
    %Gensing:
    < from %Gens, mediates %other <-> %self
      commits a tree in either direction
        syncing pieces required for a coherent there/%other
        as eg the /W/ server would do until all %H are
      
      doing ballio
      
      setting policy
      
      learning qualities
      
      control:
        is an expression separate from data
        
        r%Doming=2, an A.2 slope, unless no ^^4
          levels have many definitions, create slopes
            are points of interest/tingingdoms
        < %whaT to overlay/inject/control
          mucking with I/anything going into it
      
      compression/difference:
        how out%ball -> in%ball
          loading our changes on top of it
          %MindInto out%ball/* are W mixing into it
            in W surfing mode, when you employ %MindInto
        how out%ball <- in%ball
          keeping a vague picture, like %species=4
          %MindInto keeps the 1C only, with $W%H,dig,v,etc
            merging with the Live, which is for notes etc
             mix-figurations
    
    s&W/s&J eventually do this, growing from A.4/A.1
      pinning /way/s.t to define it
    
    'doing from and growing from' will + joints
    
    R=\d+ could mean slopality, instantiatia:
     2: should be remembered
     3: must be Domed
     4: follow children first?
       %MindInto would set this up as its iterating
     5/6: thinkingabout/supposing theyre all processes
    
    < auto %play any %Doming=3/*%R
      supposing theyre all processes,
      not bits of a process
        the for later/someoneelse phenomenon
        the lum, line, probably to do out/in%ball
     < know boundaries, where awareness should end
       usu where %otherstuff begins, or time
       play with making it wake up too hard
    
    < %push/%differ ~s&testrun, less remote
    =cut
    #c Be.sR - adjust raised sticks
    Be.sc.R = 'sR';
    Be.sR = {
    ps_Dc:{Gens:{ohm:0}},
    play:&acgtRs{
        $c = {};
        $sc = ex({},s.sc);
        $k = delete sc.R;
        $z = delete sc.z;
        # R=\d+ could mean slopality
        k > 1 and c.Doming = k
        else {
            k == 1 and k = '1'
            typeof k != 'string' and throw "refR"
            k = k == '1' ? s.t : k;
            k = k.split('+');
            # R=+Save gives R%Save
            # R=Tool+etc makes r%Tool%etc
            k[0] == '' and k.shift(); c = R.sc
            each i,gk k {
                c[gk] = sc[gk] != null ? sc[gk] : 1
            }
            c == R.sc and return
        }
        # new being
        # < namestretch over out/9er/in,
        #   making the formers harder to elvis,
        #    is checked in
        c.t = s.t;
        # who knows names
        $Gens = me.cbu(R,'Gens');
        # and history
        $Doming = me.cbu(R,'Doming');
        # s.sc -> r.sc
        ex(c,sc);
        # the outs
        c.other = s;
        # s%z -> r%nz
        ss&z and c.nz = ss&z
        # c carries through Jrom or %Gens
        !Gens and c.Doming ||= 3
        # or via %Gens waiting room
        else {
            c = {t:c.t,Gens:c};
            # < %JRom/%Gens/... 
            c.Doming ||= 1;
            
            # < join some thinking about Doming it 
            # our %Gens%ting will find its %ting
            #  for pathinto (or not if W:thing)
            #  J would wander in and W along
            
            # < something not quite %JRom, concurrent
            # < group time Ringing inside it
            # < lots of weird ways to make callbacks whenever
        }
        
        !Doming and c.Doming = 4
        c.Doming >= 4 and c.task ||= 'rovo'
        
        # packdown from %play
        ac(R,'unplaycb', &{
            each in rs&unDoming {
                n()
            }
        });
        $r;
        # level of Doming...
        # blend ind
        c.Doming <3 and r = me&Ret,R,c
        # another Ringing (Rc&N)
        # instant to the enclosing Ring
        # < unless it makes Arrangements
        # catches throws
        else {
            r = me&Rom,R,c
        }
        return rs&returns || r
    }};
    # GOING -> s&R
    # %Gens)%ball open %SomeProcess
    Be.sc.Gens = 'sGens';
    Be.sGens = {ohm:0,play:&acgtRs{
        R.sc[ss&Gens] = 1;
        s&boc = 858;
    }};
    # GONER, will be aTool before need again?
    Be.sc.trac = 'strac';
    Be.strac = {ohm:0,play:&acgtRs{
        $sp = me.cbu(R,'tingspot');
        !sp and return me&tsc,'notingspot','!t','B'
        sps&tracball = R;
        s&pa = 0.3;
        s&boc = 588;
    }};
    #c Rom tries R, catches errors
    # provide headings with pausibles,
    #  errors and s&N coming out
    #  T.* changes and chatter
    # < %Reis with error handlers,
    #   pausible
    # < er + Ring cursor
    me.Rom = &acgtptc{
        typeof t == 'object' and c = t
        !c and c = t
        typeof c == 'string' and c = {t:c}; c[c.t] = 1
        !hak(c,'t') and c.t = t
        if (c.t.substr(0,1) == '%') {
            c.t = c.t.substr(1);
            c[c.t] = 1;
        }
        t = c.t;

        # insist on %JRom enclosure
        !ps&JRom and c = {t:t,JRom:c}

        c.task ||= 'rovo';

        # < explore I by fraction
        c.wantsleep and c.ov = 0.279

        try {
            $r = me&Re,p,c;
            me&Ring,r;
            if (c.wantsleep) {
                if (!rc&b) {
                    #  || !rc&b.y.Display
                    ~nohisttosleep
                }
                else {
                    rs&sleeping = 'wanted';
                    if (1) {
                        # put through the rest of itself,
                        # it may have %sleeping things to do
                        delete rs&ov;
                        me&Ring,r
                    }
                    else {
                        me&Display,r;
                    }
                    #~slept: r.t, r.sc.ci, '>2 '+haks(r.sc).join(",")
                }
            }
        }
        catch (er) {
            $msg = er.message || er+'';
            $async = msg.match(/^async/);
            # can it sleep?
            $b = rc&b;
            if (b && by&Display) {
                # keep last display
                # < warn shadow?
                try {
                    rs&sleeping = 'errors';
                    me&Display,r;
                }
                catch (err) {
                    msg = '!sle! '+msg
                }
            }
            # < packdowns for whatever can't continue,
            #   doming marked through as async?
            #    keep some, G&T/thro may resync from B stack
            
            $n = G&Cye,[Ac&sip,'',{}];
            nc&s = msg;
            nc&er = er;
            # bunch of artifaces, < (t,$s)+
            er.tc and nc&M = er.tc
            
            ns&now = G&time;
            ns&A = A;
            ns&B = Gc&B;
            ns&p = p;
            ns&R = r;
            # to nearest dome with room to think about it
            $JR = me.cbu(p,'erN');
            $erN = JRs&erN;
            erN.push(n);
        }
        return rs&returns || r
    };
    #c Domingness
    me.Domingness = &acgtR{ return [
    # < is really %torun, which is really W:Pass
    # have wanting uphill showing where come
    # set off an experiential perspective:
    # A locality of thing availability!
        ['Doming','3',&acgtRs{
            me&walla,'bd:7.1h5,hu-7';
            if (Rs&Doming >= 3) {
                # W have packdowns
                Rs&unDoming ||= [];
            }
            
            me&tsc,"A."+Rs&Doming;
        },'ift,D'],
        
        #c %Gens save/make automata
        # see Be.sR
        # the part of Jing that is someone elses
        # A tracking its new self down
        ['Gens','25',&acgtRs{
            isC(s) and Rs&other ||= s
            # usu the s)%ball above that %plays
            $s = Rs&other;
            if (s && sc&el == 1) {
                # !%ting
                # ins pulls outs
                s = me&rollbs,R,'self';
                if (!s) {
                    s = Rs&self = G&Cye,Rs&other;
                    # new index at s/*
                    #   modifying original others instantly
                    s.y = {cv:sy&cv};
                    ss&z and ss&z = ss&z.slice();
                }
            }
            else {
                me&rollbs,R,'self';
                # comes from:
                Rs&ting ||= 1;
                # < make toW default behaviour
                #   sproutes have their reason
                Rs&toW = 1;
            }
        },'ift,D'],
        
        ['Gens+ting','31',&acgtRs{
            $Q = Rs&Q;
            $P = Qs&P;
            # download
            if (Qc&el < 3) {
                !P and return me&tsc,'wait%Q%P-only'
                Rs&self = me&Copy,R,Pc&s .c.s;
            }
            if (!Rs&self) {
                if (Qc&el == 9) {
                    # creation
                    Rs&self = G&Cye,[R.t,'',{},{}];
                }
                else {
                    me&tsc,'wait%ting','...'
                }
            }
            Rs&self and Rs&Save = 1
        },'ift,D'],
        
        # %Gens%Here R above ours load/saves its Elvisory
        ['Gens+self','31',&acgtRs{
            $s = Rs&self;
            !s and return
            $c = Rs&Gens;
            c == 1 and c = {ball:1,tightly:1}
            typeof c != 'object' and throw "Gens?"
            c.t = s.t;
            $t = delete c.t;
            c.s and throw "Gens.s!"
            
            $h = Rs&Here =
            n $t  $s:s,R
            # configure inside from out%ball,
            #   which %played s&R, creating us
            #    perhaps with big Doming beforehand
            ex(h.sc,c);
            # set freer
            delete Rc&dubquiet;
            Rc&dupl = 3;
        },'ift,D'],
        
        # general out/in%ball negiator
        ['Gens+Here','4',&acgtRs{
            me&rolltog,R,'%Gensing?',0 &&
                n Gensing  R %Gensing
        },'ift,D'],
        
        ['Gensing','7',&acgtRs{
            $p = Ry&up;
            $N = me&ioty,p
            me&tsc,"Yep"
            me&zu,"GeNN",N
        },'ift,D'],
        
        #c %Save
        # Rs&Q is for saving Rs&Here, which Liness
        ['Save','5',&acgtRs{
            !Rs&Here and return me&tsc,'noHere','!h','B'
            $h = Rs&Here = me&yfuture,Rs&Here;
            
            # want to have a %ting
            Rs&Saveting =
                # %ting%Save itself
                Rs&ting ? R :
                # %Save/%ting
                n $R.t  R %ting:W
            
            (Rs&boost||0) <= 0 and return
            
            # check in
            if (!hs&ball) {
                # the non-%ball process defines another
                # storable in-sphere
                hs&Here and h = Rs&Here = hs&Here
                else {
                    # < errors
                    return me&tsc,"looking-for-in%ball","Here!ball"
                }
            }
            hs&Lines = 3
        },'ift,D'],
        ['Save','71',&acgtRs{
            (Rs&boost||0) <= 0 and return
            
            $h = Rs&Here;
            if (!isC(Rs&Saveting)) {
                me&tsc,'!Sting',null,'G';
                return me&zu,"Savoir",Rs&Saveting;
            }
            $ting = Rs&Saveting = me&yfuture,Rs&Saveting;
            !ting || !tings&ting and return me&tsc,'Save!ting';
            
            $Q = tings&Q;
            $P = Qs&P;
            !P and return me&tsc,'!P'
            !Qs&ready and return me&tsc,'!ready'
            !h and return me&tsc,'!here'
            
            me&zu,'here',h;
            me&zu,'their',P;
            
            !hs&string and return me&tsc,'hs!string'
            
            me&introqua,[R,'diff'],'boost','@1';
            me&diffya,R,'diff',h,P;
            
            (Rs&boost||0) <= 1 and return
            
            if (!me&rollbs,R,'sent_string' ) {
                Rs&sent_string = Qs&string = hs&string;
                tings&_ting(Q)
            }
            Ps&string != hs&string and return me&tsc,'pushing'
            me&tsc,'pushed';
            delete Rs&Te.sc.boost
        },'ift,D'],
        

        #c %Elvisave sense grabber
        ['Elvisave','3',&acgtRs{
            Rs&rowish = 1;
            delete Rc&dubquiet;
            Rc&dupl = 3;
            
            # < o ^^%Gens^^%Gens(%Te)
            #   knowing %Te can be made
            $p = Rs&upward = me.cbu(Ry&up.y.up,'Gens');
            $el = me&introqua,p;
            pp = py&up;
            !pp and throw '!pp'
            $L = me&introqua,pp;
            
            me&bal,'Their',L;
            
            me&bal,'Here',s;
        },'ift,D'],
        
        
        ['Elvisave','4',&acgtRs{
            $t = Rs&Their;
            $h = Rs&Here;
            
            # make auto keep this thing's elvising
            # Their/.../Rs&Te is coming in here,
            # make it not part of *load

            # climb atop %ball/%Gens/R, of the same t
            $r = R;
            $N = me.cby(R,&r{ return ry&up && ry&up.t != r.t });
            # then up to the R%upward(%Te -> Their) we capture
            N = me.cby(N[0],&r{ return r == Rs&upward });
            # and make it a non-overwritable,non-leaver
            ts&pol = {
                carefullyTe: {
                    # this path in either t/h
                    forTepath: N.map(r => r.t),
                    either: 1,
                    # will cause t to have
                    nonleaving: 1,
                    nonoverwrite: 1,
                    # which could go as far as nonewt
                    #  to force talking about existing things
                    #  or onlynewt to make first-in locks
                }
            };
            
            # Their
            me&iostyle,t,0,'Look';
            me&iostyle,t,0,'Download' .map(&r{
                $v = me&input,h,'Thus';
                me&polout,v,r;
            });
            # Here
            me&iostyle,h,1,'Look';
            me&iostyle,h,1,'Upload' .map(&r{
                me&polout,t,r;
            });
            
            # keeps knowing last move,
            # < more via NzR
            $lo = Rs&loaded = Rs&polout_z || me&rollbs,R,'loaded',[];
            each iD lo {
                each i,lo Ds&z {
                    me&zu,'lo',lo,'';
                }
            }
        },'ift,D'],
        


        
        #c %iotest sense grabber
        # < wants to store an Elvising for itself,
        #   to be revamped by %Gens
        ['iotest','3',&acgtRs{
            Rs&rowish = 1;
            
            window.iodebug = 1;
            
            $c = me&tsc,"Double"
            i $c/van
            i $c/two
            i $c/two
            $t = me&tsc,"Three"
            i $c/$t
            i $c/$t
            $t = me&tsc,"Three"
            i $c/$t
            
            window.iodebug = 0;
            
            me&zu,c;
        },'ift,D'],
        
        
        #c JRom - safe/pausible R,
        #  handled errors and s&N
        ['JRom','3',&acgtRs{
            me&walla,'bd:2.1h5';
            me&domesticate,R;
            
            # 1 wave matter
            $c = Rs&JRom;
            
            # 2 self, from 
            $D = G&Cye,[R.t,1,{},{}];
            $j = me.cbu(R,'JRomD');
            $b;
            if (!j) {
                $b = me&rollbs,R,'JRomD';
            }
            else {
                j = js&JRomD;
                jy&tw ||= {};
                $b = jy&tw[R.t];
                jy&tw[R.t] = D;
            }
            Rs&JRomD = D;
            
            b and Dc&b = b
            b && by&tw and Dy&tw = by&tw
            Ds&amongst = b && bs&amongst || [];
            Ds&amongst.unshift(D);
            Ds&count = (b && bs&count || 0) + 1;
            D.t = ''+Ds&count;
            
            # 3 what doing
            if ((Rs&boost||0) < -1) {
                delete Rs&Te.sc.boost;
                me&tsc,'JRom-reset','reset','6';
                s&boc = '858';
                c.igV = 1;
            }
            elsif ((Rs&boost||0) < 0 || c.pause) {
                me&tsc,'JRom-paused','paused','6';
                s&boc = '888';
                s&bg = '#002';
                Rs&play and c.hidey = 1;
                Dc&b and c.wantsleep = 1
            }
            c.hidey and s&mah = 30; s&over = 2
            
            # 4 map matters for before/after
            # < down to the gate, know enough to know
            #   everything else (eg e does any further)
            $emto = {sN1:1s&N,sn4:4s&N};
            each kv emto {
                $har = Ds&watchar ||= {};
                har[k] = v.slice();
            }
            
            # 5 partition explosion collection
            $erN = Rs&erN = [];
            
            # 6 do innard
            $began = G&time;
            
            $r = me&Rom,R,'Rom',c;
            # out me&Rom returns in me&Rom
            Rs&returns = r;
            
            # pause if slow
            $max = rs&timetopause || 2.5;
            $delta = G&time,began;
            each tn Dy&tw {
                ns&delta and delta -= ns&delta
            }
            if (delta > max) {
                me&tsc,"("+delta+">"+max+")";
                me&introqua,R,{boost:-1}
            }
            Ds&delta = delta
            Ds&R = r;
            
            # 7
            # s&N
            each kv emto {
                $har = Ds&watchar ||= {};
                $was = har[k];
                $outi = [];
                $N = [];
                each in v {
                    was.includes(n) and continue
                    outi.push(i);
                    N.push(n);
                }
                !N.length and delete har[k]; continue
                # take, for nearest JRom only
                outi.reverse().map(i => v.splice(i,1));
                har[k] = N;
            }
            !hak(Ds&watchar) and delete Ds&watchar
            erN.length and Ds&erN = erN;
            
            # all but topmost should tend to sleep...
            me&Rom,R,'Domeds',{s:Ds&amongst,NzR:'Domed',glamp:9};
            
            # < A-ing slowly: order then consciousness
            #   for summary up the top
            Rs&down && Rs&down.reverse();
        },'ift,D'],
        #c Domed visually Jing R
        # < froth away lots of %balls
        ['Domed','3',&acgtRs{
            me&walla,0,'b:3.1';
            $t = me&domesticate,R;
            ts&hs = '635';
            Rs&sym = "";
            $p = Ry&up;
            # p%NzR cs=[D%Domed+]
            $D = s;
            $r = Ds&R;
            
            # 3 gauge of gauge
            # only latest or Te'd open
            if (Rs&glampi != null &&
                Rs&glampi > 0 && !Rs&Te.c) {
                $b = Rc&b;
                $sym = !b ? "-" : bs&sym || "?";
                tc&s = Rs&sym = sym;
                 return
            }
            # boost<0 and delete (if Te.d)
            if ((Rs&boost||0) < 0) {
                $Di = pc&s.indexOf(D);
                Di < 0 and throw "Di"
                pc&s.splice(Di,1);
                n deleted  s:deleted %fs:6,hs:594
                return
            }
            # Te'd stops delete
            Rs&Te.c and Rs&keeper = 1; me&tsc,'keeper','k','6';
            
            # 4 items of interest
            if (Ds&watchar) {
                # As&N we noticed grow
                Rs&sym += '^'
                each kv Ds&watchar {
                    n $k  $s:v,R %NzR:Attend
                }
            }
            
            if (Ds&delta && Ds&delta > 0.04) {
                $say = G&thime,Ds&delta ;
                me&tsc,'delta',say,6
            }
            
            # errors we caught!!!
            if (Ds&erN) {
                Rs&sym += '!';
                n Errors  $s:Ds&erN,R %NzR:Error
            }
            # oberve limits
            rc&N[0] != r and throw "not h"
            rc&ha and me&zu,'rc\&ha',rc&ha
            
            rs&sleeping && rs&sleeping != 'errors' and Rs&sym += 'ᛍ'
            
            Rs&sym ||= '.'
        },'ift,D'],
        
        ['Attend','4',&acgtRs{
            $Y = s;
            
            $nth = Y.t == 'n' && Y.y.cv == 0.13;
            nth && Yc&s.t == 'Pass' and Rs&nthirteen = 1
            !Rs&nthirteen and Rs&keeper = 1
            
            n Y  $self:Y %R:Cit
        },'ift,D'],

        ['Error','4',&acgtRs{
            #Rs&rowish = 1;#
            $skull = '☠';
            $bigger = me&rolltog,R,{may:skull,tsc:'D',once:1},0;
            
            me&tsc,'message',sc&s,'d';
            
            each in sc&M {
                $n = me&zu,i+1,n;
            }
            
            (Rs&boost||0) > 0 || !bigger and return
            me&introqua,R,{boost:1}
            
            s&fs = 13
            
            n er  $self:s %R:Cit
            
        },'ift,D'],
        

        
        #c NzR, expirez
        # spread Rc&s=N[n+] to many rc&s=n
        #  they have a type that helps NzR or the thing above it
        #  do expirez
        ['NzR','4',&acgtRs{
            Rs&dubquiet = 1;
            # trims to 30s timeframe, not %keepers
            Rs&glamp and Rs&expirez = 30
            $t = me&domesticate,R;
            Rs&NzR+'s' == R.t and Rs&qt = 1
            Rs&qt and t.c.not = 1
            
            $p = Ry&up;
            $outi = [];
            each iY s {
                $t = Y.y == Y ? Yc&sip : Y.t;
                $z =
                n $t  $s:Y,R
                z.sc[Rs&NzR] = 1;
                # inners like a log tail
                Rs&glamp and zs&glampi = i;
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
            
            !z and ts&fs = 7
            0 < i && !Rs&qt and Rs&rowish =  1
        },'ift,D'],
        
        # expiry of care about old A
        # < kind of time we can pause
        # R(cs=[n+]) with r(cs=n)+ self-cleaning
        ['expirez','7',&acgtRs{
            $outi = [];
            each in s {
                $r = Rs&z && Rs&z.filter(r=>rc&s==n)[0];
                !r and continue
                # are %keepers
                rs&keeper and continue
                
                # give %began
                rs&began = me&rollbs,r,'began' || G&time;
                $much = G&time,rs&began;
                
                # things time out or overpopulate
                $out = much - Rs&expirez;
                $over = Rs&glamp && i >= Rs&glamp;
                over && out < 0 and out = Rs&expirez
                out < 0 and continue
                
                # < relative scales into styles
                $C = rs&C;
                out < Rs&expirez/4 and s&fs = 8; s&sat = 0.4
                out < Rs&expirez/3 and s&fs = 6; s&sat = 0.2
                out < Rs&expirez/2 and continue
                
                $Yi = s.indexOf(n);
                Yi < 0 and me&tsc,'nofindY'
                else { outi.push(Yi) }
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
        },'ift,D'],
        
        #c %WestCases
        ['WestCases','3',&acgtRs{
            me&walla,'bd:3.1h5';
            
            $n = Rs&Inn = me&Rom,R,'Search';
            Rs&_ting = ns&_ting;
            
            
            $Q = me&rollbs,R,'Quest';
            n t/lvhashave  R %ting:W,Quploadsc:Quest
            
            $c = {};
            me&rollbs,R,'Sampled';
            # while checking in, 
            me&rolltog,R,'Checkin',0 and c.Sampley = 2
            else { delete Rs&Sampled }
            Rs&Sampled and c.pause = 1; c.hidey = 1;
            
            $r = !c.pause && me&Rom,R,'%lvhashave',c;
            
            
            # r.sc will not roll when pause/sleep
            r && rs&Sampled and Rs&Sampled = rs&Sampled
            
            if (Rs&Sampled && Q) {
                $P = Qs&P;
                $h = Rs&Sampled;
                
                n here  $self:h,R %Cit
                n Pull  $self:P,R %Cit
                !P and return me&tsc,'P...'
                !h and return me&tsc,'h...'
                #me&introqua,[R,'diff'],'boost','@1';
                me&diffya,R,'diff',h,P;

                !me&rolltog,R,'Push?',0 and return

                if (!me&rollbs,R,'sent_string' ) {
                    Rs&sent_string = Qs&string = hs&string;
                    Rs&_ting(Q)
                }
                Ps&string != hs&string and return me&tsc,'pushing'
                me&tsc,'pushed';
                delete Rs&Te.sc.boost;
            }
        },'ift,D'],
        
       ##c wedness do next!
    =head1
    flav
       %ting:
         a search or put, any type
         explains G&ting
         < ting both sides of it:
           (/G/Wway=/W/way)/$wcs would G&way
           (/spot/ja=/W/js)/$W would /js/
           then poll Wormhole for everything
         get (< put) .4/5, highly surfable
          < unify for an area
           < become the living someone via /W/
         < are name claims, applying or retrieving
           what of/directory selfs, .t others
       everything is, look at it in stylehouse to edit
       
       < %ball format more
         all %string hidden
         < inheritable & auto Tie/roll
         < c&s protruded
         < c % sc division
       
       < merge %torun/%mund, convert %garbec
       the %mund is posting things around,
         including its own insides,
         see 'one big %ball, some of it grounded' ^
       
       tracks stored compilings, eg:
        /W/way/$w -> /W/Comp/$w
         or -> some collection of ways
           a g/(\w+)/(\d+) is such, looks like kv yaml
           is really lots of n $t  $s:... %of:way,%comment:...
       < bringing it back via G&ting /js/ or /way/
        < read our /W/Comp/$w_$dige.js
       
       primarily for:
        using %oph to build I
         < having Babz already done to blockquoted things
           by /wayz/, otherwise like /way/
         < including %Give deps, versions of way/W going into it
         < storage-specific metadata, see w:Writer
           could simply be in the local W:Office
           things to see changing out there to awake
       
       but also:
        translating old -> new ghosts:
          io.*, me.* into W with of:W but not W:of
           such are the new ghost objects
            as g/\w+/\d+ but with a 9,
            thence all of io is in one tidy packet,
            its source compiles out closer to you,
            its tests compile into Tests
          NutMachine probably wants conversion
            perl builds it atm,
             /js/j for acgts, etc
             using 1C&of=js instead of the n \'of:js'
       
       'specifically' for leaving 'GhoNut'
        !
        others involved:
     %Give - ghost versioning
       knowing exactly each I it ran with
       see W&Lis
     W&Lis
      magical W access syntax, via t
    =cut
    #c %mund = GhoNut / ForThe(MindInto) + ChangeInto
    # wensdine, generalise to 4
    # just ForThe new infrastructure,
    # then ForThe becomes Composited from what desires:
    # < provide specifics (ForThe) layout from W,
    # < Pass and Domingness
        # the 5
        ['mund','29',&acgtRs{
            me&walla,'hu:7';
            Rs&timetopause = 3418;
            # remotes
            # news from the old editor
            me&Rom,R,'GhodigWap';
            # newsroom behind the %ting
            Rs&Inn = me&Rom,R,'Search';
            G&waylay,'Fividy';
            
            # runtime
            me&Rom,R,'GhoNut';
            
            # etc
            #me&Rom,R,'WestCases';
            #me&Rom,R,'JRomnotes';
            # here-genera looking
            me&Rom,R,'Loscba';
        },'ift,D'],
        
        ['Loscba','3',&acgtRs{
            # watch for errors from that lv thing
            4s&hashavefail &&
                n hashavefail  $self:4s&hashavefail %R:Cit
            
            # sidechaining also ju compiles,
            #   A:u testing how we J-J mix I
            n A4smind  $self:A.4.sc.mind %R:Cit
            $f = A.5[4];
            n A54er  $self:f %R:Cit
            n A545er  $self:f.5 %R:Cit
        },'ift,D'],
        
        # the 4
        ['GhoNut','3',&acgtRs{
            me&walla,'hu:17,wi:1.7';
            s&bgh = '111';
            
            $(window).off('blur').off('focus')
            .on('blur',&{
                ~blur
                4s&paused = 1;
            }).on('focus',&{
                ~focus
                4s&paused = 0;
            });
            n Elvito  R %Tool
            
            # user
            # < sums diges
            Rs&forth = me&Rom,R,'ForThe';
            
            # remix
            me&Rom,R,'ChangeInto';
        },'ift,D'],
        
        # make a bunch of %tings!
        # < all hoisting into ForThe, transport workbench
        ['ForThe','3',&acgtRs{
            #Rs&tingspot = 1;
            
            n ForThe  R %ting:W,Gens,tingspot
            #,MoreForThe
        },'ift,D'],
        ['MoreForThe','3',&acgtRs{
            n Stylehut  R %ting:W,directory:spot/je/
            n NutMachine  R %ting:W,directory:spot/ju/
            n Foogla  R %ting:w
            # random
            n Pass  R %ting:W
            
            # destinations are 5
            #  for /way/
            #   to start Rs&_ting from an eval
            n WayInto  R %ting:W,directory:Rew/
            #  for /js/ that must hack up a bit
            #   sweep eye into i
            n MindInto  R %ting:W,directory:Rejs/
            # < get that done now, to 6
            #S /@6
        },'ift,D'],
        
        
        
        # for a bunch of %tings
        # < and their %More ... %tings
        ['ForThe','4',&acgtRs{
            $N = me&ioty,R,'%ting' .map(n => ns&Q);
            # like G&ting,of,t
            # < usable from, is a known interface
            Rs&tin = &st{
                each in N {
                    nc&of == s && n.t == t and return nc&s
                }
            };
            # like A 8, returning a .5 (things depended)
            Rs&eight = &{
                $C = G&Cye,[R.t,''];
                each in N {
                    i $C/#nc&of/#$n:s
                    yas&dige = ns&dige
                }
            };
        },'ift,D'],
        ['Elvising','4',&acgtRs{
            me&tsc,"4Elvising",0,'B'
            me&zu,4s&elvising;
        },'ift,D'],
        
    #c 4 MindInto will/what to mix+how
    =pod
    %Gens forms a %MindInto
     tools to Mix Stylehut + NutMachine + more
      with sessions of map building on top
      selects what to include
      or edit, or delete
      knowing how it mixes already,
       if this of/t dige is included after:
    %ChangeInto mixes many to many:
     minimising regeneration tasks leaning on it
     writing W:MindInto or etc
    
    specifies generating new I
       /way/ they need to start
     to get an A clearly built from scratch
     
    %ChangeInto is:
     gathering of ingredients forwarding
      I-mixing without encoder (W:js)
        ting.Merge.js
      playing %Give (deps) on the %Gens/anywhere line is drawn
        alt see 'using %oph to build I'
      answering the %Gens, which stores our result
    mixing any index, inc from & to
    =cut
        ['ChangeInto','33',&acgtRs{
            #  knowing the ForThe
            # < slep into:
            # open to check workings
        },'ift,D'],
        
    =pod
    %MindInto is:
      populating %ForThe with what it needs to:
      Know/** become %ting, as needed
      Tree/* sense, arrange acts
    W&MindInto:
     < bits of StyleHut,
     < most of NutMachine,
     < any new I
    W&WayInto is:
     < I:NutIns/G&ting becoming:
       auto hoist R:Search@4  into /js/$Search:
        G&tingup to make Rs&_ting etc at #runtime
        without io
        needs jquery, isC and G.t for G&time/Cye/thime/c/intag
        G&ting proxies Rs&_ting
        Rs&_ting proxies G&t
     + io and me at #runtime
     + A:n J as me.J is
     + t that looks at me.$i, me.Ja.$w
    =cut
        ['MindInto','33',&acgtRs{
            # W&ForThe/Know populates %ForThe withs %tings
            #   which starts as an other-%ting attractor:
            # < suggestive n
            $K = me&likez,R,'Know',{ususc:{trac:'ting'}};
            K and me&tracto,K,'ball','ting'
            s&boc = 588;
            
            
            #  populate what is now %ForThe besides W&ForThe
            # knowing the W&ForThe should populate what is now %ForThe
            # < slep into:
            # open to check workings
            
            # the $Mixage/Kn%trac/$Thing syncs to Thing%ting
            #  version check and  maybe:
            #    %el=9 - not included
            #    %el=7 - dubiously included (check later)
            #  then if Thing%ting change, open up everything,
            #   s/eye/i/
            #   A:u' mind-mix so
            # so:
            #  you start the %Czech process, or:
            #  you %play the %trac ball,
            #  becomes %trackball, children pathfind their %tracball
            #   surge open if different - need all %tracballs
            #   and check for unknown children here not in %tracballs
        },'ift,D'],
    ] };
    #c func %ball zu
    # %ball made for s
    me.bal = &acgttsc{
        $R = Cy&R;
        c ||= {};
        typeof c == 'string' and c = G&peel,c
        ex(c,{t:t,s:s,ball:1,tightly:1});
        $r = me&Ret,R,c;
        if (Rs&ball) {
            # < i $R/$r
            # < with ballio
        }
        rc&dupl = 5;
        R.sc[t] = r;
    };
    # %ball suggested into/assumed from s)R%ball
    #  how processes create/sync their limbs
    #   without %R, which they oughtta...
    me.likez = &acgtRtc{
        $got = Rs&ball ? me&ioty,R,'%ball',t [0] : R.sc[t];
        got != null and return got
        if (me&rolltog,R,{maydo:t},0 ) {
            if (Rs&ball) {
                $r = me&input,R,t;
                c.ususc and ex(rc&s.sc,c.ususc)
            }
            else {
                R.sc[t] = 1
            }
        }
    };
    #c trac top func Know/%ball<->ForThe/%ting
    
    # endless loop of trac & ok <-> dependencies
    #  pulling into a mixage
    
    # < look more like RbitXing
    #    which wants to have posts of different height...
    # < or connect each %ting on the path
    #   up to a certain distance...
    #    should T.allow about going further than ...
    #   the things up the embryo...
    #   branches of %tings could be skipped?
    #    as far as the insides gravity is independent
    #      may stick around because you saw it once,
    #       culture style,
    #      or be mechanical exactitude eg I,
    #       things vanishing noted but immediately effective
    #     memory compresses, making usual shapes
    
    # Troom to be the top %tracting
    # local %tings hangout
    me.thespot = &acgtRt{
        $l = [t,'the'];
        $s
        each it l {
            $spot = t+'spot';
            s = me.cbu(R,spot);
            s and return s
        }
        me&waits,'no'+spot,'!t','B'
    };
    
    # checks R's modulat talk for %waits
    # < named waves of
    me.beready = &acgtRk{
        $Mw = k || '';
        $N = me&Mwty,R,Mw;
        $Nx = {};

        # %acty:1 starts things, %acty:8 opens dialectic
        N = arou(N,'acty',Nx);

        # everything %waits is important
        # everything else is an error
        Nx.err = arou(N,'waits',Nx);
        delete Nx.err;

        each kv Nx {
            !v.length and delete Nx[k]
        }

        # is ready
        !(Nx.waits || Nx.err) and return 1
        # or not

        if (Nx.waits) {
            $situ = "waits("+Nx.waits.length+")";
            $ope = me&rolltog,R,{may:situ,acty:8,tsc:'y'};
        }

        if (ope || Nx.err) {
            me&zu,'Nx',Nx
            each in Nx.waits {
                me&zu,n
            }
        }
    }
    
    # me.cbu having a boundary
    #  eg find %ting between %ting and %tingspot
    me.cbub = &Rkbc{
        c ||= {};
        typeof b == 'string' and c.neggk = b; b = null
        b && !isC(b) and c = b; b = null
        isfu(b) and c.boundy = b
        else
        b and c.bound = b
        $alongthe = &s{
            return c.boundy && c.boundy(s)
            || c.bound && s == c.bound
            || c.neggk && s.sc[c.neggk]
        };
        $N = me.cby(R,&s{ return alongthe(s)
            # k may be an inclusive boundary, returns path
            || typeof k == 'object' ? s == k : s.sc[k]
        });
        # hit boundary, no path
        alongthe(N[0]) and return
        return N[0]
    }
    
    #c MindInto/Know/*%ball going to gather %tings
    #  ghosts knowing wormholes
    
    # < editing the %ball's s.t breaks,
    #   click %ball reveals (lvhashave?)
    #    same t different %tag?
    #    this'd be a good place to start whaT'ing code:
    #     Xpath the modulat, look for its R:Display,
    #     playing back the scenario of the bug
    #     figure where they think to, turn on lvhashave fullness
    #   while:
    
    # as the MindInto, coordinating its Know
    me.tracto = &acgtRkt{
        # we are outside the R:Know but can sc it
        $C = Rs&C;
        me&walla,'ba:2h3'
        # the individuals sc
        $tracting = 'trac'+t;
        # through the spot
        $S = me&thespot,R,t;
        !S and throw "nospot"
        
        $f = S.sc[tracting];
        f and return me&waits,"alreadytrac"+t,"oc:"+r.t
        
        # the organiser persists
        $abstracting = 'abs'+tracting;
        $F = me&rollbsc,R,abstracting;
        Fc&tracting = tracting;
        # who art coordinating
        Fy&G = R;
        Fy&W = S;
        # in the S=ForThe%ting is G=ForThe%MindInto
        #  ignore any %ting in there (%Gens)
        $insideW = me.cby(R,S)[1];
        insideW and Fc&traciggy = [insideW]
        Fy&top = F;
        Fc&Gtype = k;
        Fc&Wtype = t;
        R.sc[abstracting] = F;
        
        # so %tings notice upward %tracting
        S.sc[tracting] = F;
        # and so this %ball realises its flook etc.
        R.sc[tracting] = F;
        
        # waking up W or G about %tracting
        Fc&indive = &Rk{
            $f = R.sc[tracting];
            !f and throw "indive!tracting"
            me&ioty,R,'%'+k .map(&n{
                ns&rowish = 2;
                n.sc[tracting] = f;
            });
        };
    };
    
    # %tracting@6 either become, F -> f
    
    # W %ting@6 finds ^^%tracting
    #  copies it to its own %tracting
    # long distance inheritsc
    me.tracarri = &acgtRt{
        $S = me&thespot,R,t;
        !S and return
        # climb up to the spot until %tracting
        $tracting = 'trac'+t;
        $S = me.cbub(Ry&up,tracting,Sy&up);
        !S and return
        T.Mw = 'trac';
        $t = S.sc[tracting];
        $F = ty&top;
        each in Fc&traciggy {
            me.cbub(R,n) and return
        }
        
        if (ty&W != S) {
            if (t == Sy&up.sc[tracting]) {
                ~tracarri ahead: S.t
                T.wide = 'tracarri ahead of ^^tracmode';
                return;
            }
            throw "cbub^^%tracting!=fyW", S, t
        }
        
        # t = F at the top, then the previous f
        R.sc[tracting] = t;
    };
    
    #c W|G grow f and put themselves as fy&W|G
    #  f starts for the parent or the entire trac-ing
    # and either can introduce the other,
    #  eg W reduces to G, G opens a W
    # we end up with a fy&ov for booting that connection
    #   which is in the domain of the particular G or W system,
    #   eg %ting:W,species:4 while checking out %MindInto/Know
    me.tracmode = &acgtRtc{
        $f = me&tracintro,R,t,c;
        
        # not chattery
        !me&beready,R,'trac' and return
        # having f, returned, means ready
        !f and return
        # waits for us to 2->3 it
        if (fc&ov == 0.2) {
            # both here + not chattery
            $readygk = 'trac'+t+'_ready';
            R.sc[readygk] = 1;
            $r = fy&G == R ? fy&W : fy&G;
            !r.sc[readygk] and return
            fc&ov = 0.3;
            # must come back so other lives ov=3 first
            return
        }
        # tracupload constantly, not immediately: waits
        
        return f
    };
    me.tracintro = &acgtRtc{
        $tracting = 'trac'+t;
        $isting = R.sc[t];
        $k = isting ? 'W' : 'G';
        # t = previous f
        $t = R.sc[tracting];
        !t and return
        T.Mw = 'trac';
        # %tings gathering around somewhere
        # while persisting %tracting=f over (under) t
        $F = me&rollbsy,R,tracting;
        $unity = ty&W == R || ty&G == R;
        if (unity) {
            # tops stay f, creation on such type
            #  eg ForThe%ting or Know%ball
            # unity means "the top" for now
            $f = t;
            fc&ov = 0.3;
            F && t != F and throw "top changed f"
            t != ty&top and throw "unity !top"
        }
        else {
        if (t != F) {
            #~>3 rolling: k, R.t
            # double check via f tv
            $f = fio(t,R.t);
            # since 
            f != F && fy&up == F and me&tsc,'Fwasup:'+F.t;
            if (f != F) {
                Fy&up != t and me&tsc,"fupcha";
                # f may recreate to reset state
                if (F.t == f.t) {
                    me&tsc,'f-changed','*f'
                }
                else {
                    # < F = new fy&up
                    #   f moves in at low ov, aka:
                    #   sync elvising to new context
                    #   see mez&rename
                    me&tsc,'Freplace:'+F.t+'->'+f.t
                }
                F = t
            }
        }
        if (t == F) {
            #~>3 growing: k, R.t
            # grows f from spread F
            $f = fio(t,R.t);
            fy&up = F;
            fy&top = Fy&top;
        }
        }
        # the shared object, about each climbing
        R.sc[tracting] = f;
        # keep Rs on f
        ['W','W_exp','G','G_exp'].map(&k{
            $r = f.y [k];
            !r and return
            r = f.y [k] = me&yfuture,r;
        });
        f.y [k] && f.y [k] != R and me&waits,"already-fy"+k; return
        f.y [k] = R;
        
        $ok = !isting ? 'W' : 'G';
        $F = fy&top;
        $type = F.c[k+'type'];
        $otype = F.c[ok+'type'];
        if (!unity) {
            t != fy&up and throw "t !fyup"
            tc&ov < 0.3 and me&waits,"fyupcov"; return
            # the previous thing on either side
            $op = fy&up.y [ok];
            !op and me&waits,"fyup!"+ok; return
            $p = fy&up.y [k];
            !p and me&waits,"fyup!"+k; return
            # op must be the type we expect,
            #  to look/input more of itselves
            
            #  the tops are sometimes op but never have op
            #$istop = F.y [ok] == op;
            !op.sc[otype] and throw "need "+otype
        }
        
        
        #c A:f-ness, connect either
        # using this elvisory
        # f state
        #  usually a step can be made by either W/G
        fc&ov ||= 0;
        
        $yo = f.y [ok];
        # reset state per fy&$ok disappearance
        # < not inside %sleeping
        if (yo && Rc&N.indexOf(yo) < 0) {
            ~>9 disco: k,'->',ok, f.t
            me&waits,'disco:'+ok,0,6;
            # < mez&delete should do the delete-all
            #    el=2 input implies delete-all,
            #    which Ghostway/ing needs
            #   it would Rsync if R or s (finding refR) %ball
            i fy&up/-$f
            return
        }
        # or as usual,
        # W tends to wake first, !fy&G means initialise
        !f.y [ok] and fc&ov = was = 0
        
        # rync when Look/Create finds an r
        $lr;
        $rync = &r,how{
            !r and return
            r == lr and return
            lr = r;
            # eg W can find/create the fyG from fyupyG/f.t
            # which should become fy&[ok]
            $exp = f.y [ok+"_exp"];
            $got = f.y [ok];
            if (got) {
                #~>4 otherready: how, k, '->', ok, f.t
                if (exp) {
                    exp == got and delete f.y [ok+"_exp"]
                    else {
                        throw "not predicted "+ok
                    }
                }
            }
            
            # probably already r%tracting=f spread from upyG
            r.sc[tracting] ||= f
            [f,fy&up].indexOf(r.sc[tracting]) < 0 and throw "difftracting"
            
            # and is soon to be fy&[ok], where it should stay:
            exp && exp != r and throw "change exp "+ok
            got and got != r and me&waits,"r~got"; return
            #throw "change got "+ok
            !got and f.y [ok+"_exp"] = r
            
            # may be already
            # go to being entered/having been entered
            fc&ov < 0.1 and fc&ov = 0.1
        }
        $tych = &{
            if (ok == 'G') {
                otype != 'ball' and throw "enterG !ball"
            }
            else {
                otype != 'ting' and throw "enterW !ting"
            }
        };
        
        #c Look for the other
        # < ongoingly also
        if (fc&ov <= 0.2 && !unity) {
            tych();
            # child find
            $flook = ops&flook;
            flook ||= ops&ball && &f,r,ok{
                $N = me&fabioty,op,[f.t];
                N[0] and return N[0]
            };
            !flook and return me&waits,"!flook" && me&zu,f
            $r = flook(f,r,ok);
        }
        rync(r,'Look');
        
        # Click (or so) to other
        if (fc&ov == 0) {
            $ope = fy&up == fy&top
                # from ball+tracting
                || Rs&openey
                || me&rolltog,R,{may:'^trac',acty:1};
            ope and fc&ov = 0.1
        }
        # Creates the other (either)
        #  even if we already see it
        #    must be repeatable (inputs != creates)
        #   to make sure everything happens that can...
        #   so we know all the outbound connections
        # < only want genesised if we really had to create them
        if (fc&ov == 0.1) {
            $direction = (ok == 'G' ? '<-' : '->');
            #~>6 Enter: ok, op.t, direction, k, f.t
            tych();
            fs&game = 'look';
            # child input
            $finput = ops&finput;
            finput ||= ops&ball && &f,r,ok{
                # returns the %ball without any Ringing
                #  which might be lies if ...
                return me&input,op,f.t;
            };
            !finput and throw "no finput"
            
            $r = finput(f,r,ok);
            
            # having from Looking or the input method,
            !r and me&waits,'connecting:'+ok+'%'+otype,'...'
            else {
                fc&ov = 0.2;
            }
            # if we didn't already see it
            !lr and fy&genesised = k;
        }
        rync(r,'Create');
        #c C:f-ness the idealised lifecycled potentials
        
        # check either y$ok and its type
        if (fc&ov >= 0.2) {
            # should be ready
            if (!f.y [ok]) {
                # wait for the other side to have a mind,
                # then put heads together
                fc&ov = 0.2;
                return
            }
            !f.y [k] .sc[type] and throw "f@2 !y"+k+"%"+type
            !f.y [ok] .sc[otype] and throw "f@2 !y"+ok+"%"+otype
        }
        
        # unity will not have p/op around here (skips to 3)
        
        # generalised notions of trac
        if (fc&ov > 0) {
            $con = me&rolltog,R,{may:'trac',tsc:'l',acty:8};
            if (con) {
                Rs&traccon = 1;
                $ab = T.Mw;
                T.Mw = 'trac-control';
                # clicks open to reveal controls
                me&zu,"control-f",f;
                me&rolltog,R,{may:'re2',tsc:'y',once:1} and fc&ov = 0.1
                
                T.Mw = ab;
            }
        }
        
        # each thing not chattery to 0.3
        if (fc&ov == 0.2) {
            # on startup
            ~>2 En2: k, '->', ok, f.t
            # check config
            #   was sent from here with their finput()
            me&tracupload,R,f,k,ok,type,otype;
            # < ongoingly also
            return f
        }
        
        # is off
        fc&ov < 0.3 and return
        
        # ongoing spread to either/* now
        k == 'G' and Fc&indive(R,type)
        
        # is on
        return f
    };
    #c expression inherits from the last:
    #   %ball%tracting - when establishing %ting
    #   %ting%tracting - when learning %ball
    me.tracupload = &acgtRf,k,ok,type,otype{
        # can do it from either end
        #  as if one is prosthetically Awake
        k == 'W' and return
        # at first:
        #  0 = W should give bits to G
        #  1 = W should same bits as G
        #   fatal: out-bitten by another
        #   probably inheriting from ry&up
        # then
        #  asks to give bits
        $load = {f:f};
        # the bits + remarks that matter
        $lasc = fs&tracupload;
        # initial guzzle
        !lasc and load.forming = 1
        # 
        load.forming && fy&genesised == 'G' and load.conform = 1
        # make the change
        # < elvis hoppering acceptance
        load.auto = load.forming || lasc.accepted;
        
        $F = fy&top;
        $ting = Fc&Wtype;
        $tracting = 'trac'+ting;
        load.type = ting;
        
        $g = fy&G;
        $w = fy&W;
        g != R and throw "cup !G"
        !g.sc[type] || !w.sc[otype] and throw "G/W type"
        
        # Thing = whole needs make Thing amongst Stuff about it
        #   Stuff our G/W system (typed %ball/%trac) isn't after
        #  ie ghost is Thinging to really know
        #    embedded in Stuff to know
        #   the Cing of it may not be all Thinging
        #    digitised known bits in a sea of analogue
        #     is how it sees itself and its other
        if (f != fy&top) {
            $p = fy&up;
            !p and throw "no up"
            $gp = gy&up;
            $wp = wy&up;
            # < see variation ^ v # many ghostbits per Thing
            $gp = fy&up.y.G;
            $wp = fy&up.y.W;
            # < see variation ^ v # many tings per Thing etc
            # < g not bound by F/**?
            $gp = me.cbub(gy&up,tracting,F);
            $wp = me.cbub(wy&up,tracting,F);
            !gp.sc[type] || !wp.sc[otype] and throw "cup G/W type"
            
            gp == wp and ~>8 converge: k, '->', ok, p.t+'/'+f.t
            gp == wp and return
        }
        
        # checks it has the non-.t details right
        #   for writing on the ghost
        # %ting inherits them, has explicit ws&$k
        # %ball implies them being inherited
        me&Cloadsc,load,g,wp,w;
        fs&tracupload = load;
    };
    #c Cloadsc for explicit/implicit expression
    #  as per wp upward, the last spready instructo
    #  of C.sc.* in a Be.C.$group
    # generating Alets to find completion
    #  g - description/upstream, must have a:
    #   gc&s - whose .sc differs:
    #  w.sc - reality .sc, possibly lies or news
    #  gw - .sc inherits to w.sc
    # scfor plays games after a given k:v
    # < tighten %ting args, entirely by Cloadsc
    # < generalise from sc
    # < show yup%ting <-> %ting difference usually
    #   apart from the .t, isn't in the subtle
    # < worth redoing somewhere... KnowC one-many
    me.Cloadsc = &acgtcg,wp,w{
        !c and throw "give c"
        $load = c;
        $f = load.f;
        $s = g && gc&s;
        # bits to give G: nulls for things it needn't
        load.sc ||= {};
        # bits to give W: everything
        load.c ||= {};
        # of this type's group
        # < Wtype:* brings everything,
        #   to where osc watches osc
        $Kc = Be.C[load.type];
        $games = [];
        
        each i,k Kc.scgk {
            # on %ting%$k
            $got = w && w.sc[k];
            # which is inheriting ^^%tracting
            # or not, if many tings per Thing,
            #  needing more explicit bits in recipe
            #  but something weirder might be afoot
            $exp = wp && wp.sc[k];
            # or not if it doesn't do that
            !Kc.scinherit and exp = null
            # weaker exp than inherit
            if (exp == null) {
                $def = Kc.scdefault && Kc.scdefault[k];
                def != null and exp = def
            }
            # f can decide attr, or have them suited to:
            # ephemeral modes of a point in a game
            #  eg look intensely, look casually
            each i,kc games {
                $game = kc['sc'+fs&game];
                if (game && game[k]) {
                    $imp = game[k]
                }
            }
            
            
            $was = s && s.sc[k];
            # W says everything
            $v = load.c[k] = imp || got || was || exp;
            
            # %ting=W leads to more knowing
            $kc = Kc.scfor && Kc.scfor[k] && Kc.scfor[k][v];
            kc and games.push(kc);
            
            $value = got;
            # G implies what is implied
            if (exp != null && got == exp) {
                # not noted
                !was and value = null
                # or was explicitly something else
                elsif (was != got) {
                    debugger
                    throw k+' implied was !got'
                }
                else {
                    ~>7 redundant: g.t, '%'+load.type
                    value = null;
                }
            }
            # imp acts like exp
            imp && imp == value && imp == got && !was and value = null
            load.sc[k] = value
        }
        
        !s || load.noknow and return load
        me&Cnotesc,load,g,w;
        return load
    };
    #c Cnotesc
    # finds difference to s (g)
    me.Cnotesc = &acgtcgw{
        $load = c;
        $f = load.f;
        $s = g && gc&s;
        
        $differs = [];
        each kv load.sc {
            v == null and s.sc[k] != null and differs.push(k)
            else
            v != s.sc[k] and differs.push(k)
        }
        $lies = [];
        each ik differs {
            load.liesok and continue
            load.sc[k] == null and continue
            # we said something, it was something else
            s.sc[k] != null and lies.push(k);
        }
        
        # want extra carevision
        lies.length and load.auto = 0; load.lies = lies
        
        if (differs.length) {
            load.differs = differs;
            # 
            # < Tool for pulling as branch
            #   something differ can understand
            #   all terrain replication vehicle
            if (load.conform) {
                # should not be changing
                load.auto = 0;
                me&waits,"recipe-doesnt-conform",'exp!',6
            }
            if (load.auto) {
                # enacts change
                each ik differs {
                    me&tsc,'~'+k,0,6;
                    $v = c.sc[k];
                    $was = s.sc[k];
                    if (was != null && v == null) {
                        ~>7 redundant: g.t, '%'+load.type
                    }
                    v == null and delete s.sc[k]
                    else {
                        s.sc[k] = v
                    }
                }
            }
        }
        return load
    };
    
            
    #c Tongingness %ting %trac* %Gens
    # %ting* for Compositing of/other tings
    # the R life of %Search%_ting(Q)/G&ting/G&t
    # extra tricks here
    
    # < include the flook/finput methods?
    
    # up/downable essential identity
    Be.C.W = {
        scgk: 'dige',
    };
    Be.C.ting = {
        scgk: 'ting,directory,species',
        # dont need to %ting=W at the top?
        scdefault: {ting:'W'},
        # %tings nest to imply structure,
        #  these sc inherit from above
        # < cause Ravelvis to recreate if changed
        #   eg %ting must start fresh to add %directory
        scinherit: 1,
        scfor: {ting:{W:{
            # < plug this in to Cloadsc,
            #   < %ting using Cloadsc on its own:
            #      g=R,wp=Ry&up,w=R
            #    < deriving the display
            scdefault: {species:1},
            # look mode (ov<=4) implies:
            sclook: {species:5},
            # then the main %species we need to fully awake:
            scget: {species:1},
        }}},
        # wants 1 over the 4
        #  for the details under the main thing
        #  or does ForThe's %ting index/tooling abstract that?
        #   supposing you ask for Thing.1
        #   or you ask for Thing's %H (%ha/%dige),
        #     Thing.4 could have the answer,
        #      and have a %Ghostway to keep it up to date
        #     ThingsInHere.4 also, a big map
        #      which Lis must update, put forks in? or:
        #     Dev.4 + Dev/$Thing, a searchpath
        #      for who rides the chaos as thing grows
        #       a language weld happening
        #       shows where traits arose
    };
    me&BeCload;
    
    # toggle fs&$k = m[0,1]
    # < dropdown/typein
    me.gamesc = &acgtRfkm{
        $c = {may:'change_'+k,tsc:'d',once:1};
        c.s = f.sc[k] || '+';
        $get = me&rolltog,R,c;
        
        $n = c.n;
        me&walls,n,'b:2.2'
        ns&bri = 1.3;
        $bet = "toggles %"+k+" between "+m.join(',');
        ns&z = [G&Cye,[bet,1,{s:'?'},'fs:8'] ];
        
        # leaves unset (will init to m[1])
        # returns it if not changed
        !get and return f.sc[k]
        $ki = m.indexOf(f.sc[k]) + 1;
        !m[ki] and ki = 0
        nc&s = f.sc[k] = m[ki];
    };
    # hash stash
    window.ah = &th{
        !isC(t) and throw "!C"
        $M = [... arguments].slice(2);
        $h = t.sc[h] ||= {};
        while (M.length) {
            $k = M.shift();
            M.length > 1 and h = h[k] ||= {}
            else {
                h[k] = M.shift()
            }
        }
    };
    #c know about the Thing independent of the species
    me.lookating = &acgtW{
        $Q = Ws&Q;
        $s = Ws&Live;
        $Thing = G&Cye,[s.t,1,{},{}];
        if (Ws&species == 5) {
            Things&dige = ss&ha;
            o $s/W/*:s
            each in ays&s {
                ah(Thing,'Wind',n.t,ns&ha)
            }
            o $s/w/*:s
            each in ays&s {
                ah(Thing,'wind',n.t,ns&dige)
            }
        }
        elsif (Ws&species == 1 || !Ws&species) {
            # < can do similar for .4
            # < pointings that adjust for its compression
            each in sy&N {
                ns&W && !ns&z &&
                    ah(Thing,'Wind',n.t,ns&ha)
            }
            Things&dige = Qs&dige;
        }
        else {
        }
        return Thing
    }
    
    # n (modulat) liften from R ground into t
    # < combine with zuck/mez/polify for all-regrouping?
    me.modopt = &acgtRtn{
        $M = me&Mw,R,T.Mw;
        $ni = M.indexOf(n);
        ni < 0 and throw "n not in "+T.Mw
        M.splice(ni,1);
        fio(t,n.t,n);
    };
    me.mtsc = &acgtmtsc{
        $R = Cy&R;
        $n = me&tsc,t,s,c;
        me&modopt,R,m,n;
        return n
    };
    me.check_projected = &acgtRnk{
        ['trouble','okay'].map(&diff,{
            $z = R.sc[diff];
            each it z {
                !tc&proj and continue
                # < do with Cshowsc (displays Cloadsc)
                each kv t.sc {
                    n.sc[k] == s and continue
                    # < climb to the f/Winding
                    me&tsc,"proj!%"+k
                }
            }
        });
    };
    me.Tongingness = &acgtR{ return [
        # %trac*
        
        # %ball end
        # with some C visua
        # being fy&G, gleans %ting's usual sc
        ['ball+tracting','61',&acgtRs{
            $D = Rs&C;
            $c = {};
            Rc&b && Rc&b.sc.trouble and Rs&openey = 1
            $f = me&tracmode,R,'ting',c;
            !f and return
            $W = fy&W;
            $Q = Ws&Q;
            !Q || !Qs&ready and me&waits,"!ready"
            $w = Ws&Live;
            !w and me&waits,"!live"
            
            f == fy&top and return
            
            $game = me&gamesc,R,f,'game',['look','get'];
            
            # < roll/sleepatch inner processes
            !me&beready,R,'trac' and return
            
            Rc&dupl = 3;
            
            #c looking at the answer
            # < sleep by Q&dige
            $Thing = me&lookating,W;
            
            # accumulate into ss&dige
            # < set it to wind back this branch
            #   as ss&wantdige, may not be doable
            #     for _ting to ask /W/ or /js/
            # < copy from last good, or %fix/gamesc gizmo
            # < this Know gets slowly tractorbeamed to stable/Know,
            #   the load.auto waiting for test runs
            $load = {type:'W',auto:1,liesok:1};
            me&Cloadsc,load,R,null,Thing;
            if (load.differs) {
                # make this thing curious until solvey
                fs&changey ||= 1;
                me&tsc,'~';
                Ds&bri = 1.3
            }
            
            if (Things&Wind) {
                # check dige/exist
                $ha = ex({},Things&Wind);
                
                # < should only be (%ting, but is implied
                #   we have no other stuff in the Know yet, but could
                #   supposedly the implications would change,
                #   as u climb
                # match against what we have
                $N = me&ioty,R,'ball';
                $have = {};
                each in N {
                    !ha[n.t] and continue
                    have[n.t] = n;
                }
                $news = [];
                each t,dige ha {
                    $r = have[t];
                    if (r) {
                        # see their diff from here
                        $rs = rc&s;
                        $diff = rss&dige != dige;
                        # expect it will find the same diff
                        # give it cause to wake/sleep
                        # < these should be elvised in there
                        #   to sleep the pile. write these:
                        #   e $r -proj-cha $lc
                        $d = G&Cye,["projected:",1,{proj:1,f:f},{dige:dige}];
                        d.t += (diff ? 'cha' : 'still');
                        ac(r, (diff ? 'trouble' : 'okay'), d);
                    }
                    else {
                        $d = {may:'lookup_'+t,s:t,tsc:'y'};
                        me&rolltog,R,d and me&input,R,t
                        me&walls,d.n,'b:2.2';
                        news.push(d.n);
                    }
                }
                if (news.length) {
                    $d = {may:'readnews',s:'Unhad:',tsc:'y'};
                    if (me&rolltog,R,d ) {
                        news.map(d => me&input,R,dc&s );
                    }
                    $n = d.n;
                    ns&fs = 8;
                    ny&cv = 0.4;
                    news.map(d => me&modopt,R,n,d );
                    me&walls,n,'b:2.2';
                    me&mtsc,n,"\n";
                }
                # < put news etc after %fixen as %dis:1
                #me&zu,'Win',N
                #me&zu,'Wind',Things&Wind
            }
            me&check_projected,R,Thing,'dige';
            
            if (Rs&traccon) {
                me&zu,'Thingstract',Thing
                me&zu,'Loadism',load
            }
            
            $N = me&ioty,R,'ball';
            each in N {
                # engages their rolltog ^trac
                fs&changey and ns&openey ||= 1
            }
            if (fs&changey) {
                # dige here or inside solving
                me&tsc,"f%changey","~!",'G';
                # 2 them
                me&ioty,R,'ball'
                    .map(n => ns&openey ||= 1)
            }
                
            if (game == 'look') {
                # get dige-level diff figured
            }
            elsif (game == 'get') {
                # should match the dige-level figured
                
                
            }
            
            return;
            $z = tc&s;
            if (!zs&el) {
                me&tsc,'('
                me&rolltog,R,'9',0 and zs&el = 9
                me&rolltog,R,'7',0 and zs&el = 7
                me&tsc,')'
            }
            #n trac  $s:tc&s,R %ball,tightly
            
            #R.t == 'Stylehut' and me&zu,Rs&tracting
            
            #$s = me&thespot,R,'ting';
            #Rs&KnowingC = me&zu,'Firstly',s;
            

            # similar. headful.
            # loads up our %tings
            # if different, wills its children to do the same
            # over a few Domings, since Ring A-time is not precise
        },'ift,D'],
        #c trac-swarm comes together over the top
        ['tracting','81',&acgtRs{
            $f = Rs&tracting;
            
            # < fbitX + fc&N, the whole trac-swarm
            #f == fy&top and ...
            #me&beready,R,'trac';
        },'ift,D'],
        
        ['ball+KnowingC','87',&acgtRs{
            Rc&noKnowC = 1;
            $s = Rs&KnowingC;
            #$s = me&thespot,R,'ting';
            me&zu,'FCit',s,''
        },'ift,D'],
        
        #c %ting%More -> /%ting vision in
        ['ting','5',&acgtRs{
            $M = Rs&Te && Rs&Te.sc.M || [];
            !Rc&b and M.splice(0,M.length)
            Rs&Modin ||= [];
            each if M {
                ac(R,'Modin',f) and continue
                $c = G&Cye,[f.t,1,{R:1}];
                # gathers sc for type from Ghost,
                #  also inheriting from this W
                # and esp what fs&game might want
                $load = {type:'ting',f:f};
                me&Cloadsc,load,fy&G,R;
                ex(c.sc,load.c)
                ac(R,'More',c);
            }
            Rs&Modout ||= [];
            each in Rs&More {
                ac(R,'Modout',n.t) and continue
                n $n
            }
            # Rings children, then this step again
            T.ziter = 0.4;
            Rs&More = [];
        },'ift,D'],
        
        # ^^%tracting/...%ting finds itself
        ['ting','6',&acgtRs{
            me&tracarri,R,'ting';
            # see 'tracarri ahead'
            # < Ring all == cv to get v before ^ for inners
            !Rs&tracting and return
            $f = me&tracmode,R,'ting';
            !f and return
            
            # child find 
            Rs&flook = &f,r,ok{
                # via ForThe or so? collector of masses of %tings
                #~>7 Flook ting: f.t
            };
            # child input
            Rs&finput = &f,r,ok{
                ok != 'W' and throw "ting finput !W"
                $vel = {};
                # M[f] -> More[R]
                #  uses f.t and f Cloadsc
                # from fy&G to fy&W
                me&Ravelvis,fy&G,R,'M',f,vel;
                if (velc&el == 8) {
                    # means we should have seen it
                    # < Ring it
                    # < pass back the Runtime,
                    #   M[f].y.Real? it's not M[f] then
                    #   invent another object, the G pushing
                    #   is almost the %tracupload,
                    #    if it linked back to f
                    !r and me&tsc,'vel=8!r',0,6
                    !f.y [ok] and me&tsc,'vel=8!y'+ok,0,6
                }
                else {
                    # let elvising establish, then r
                    r = null
                }
                return r
            };
        },'ift,D'],
        
        #c ting fance, %tightly
        
        ['tightly','3',&acgtRs{
            ac(R,'inheritsc','tightly')
        },'ift,D'],
        
        ['ball+tightly','3',&acgtRs{
            $p = Ry&up;
            ps&ting && ps&species and Rs&tightly = ps&species
            
            # if they s&W (%sc may be talking about sc)
            $onW = Rs&tightly == 4 && ss&sc.includes('W')
                || Rs&tightly == 5 && ss&W;
            # ting it!
            onW && me&rolltog,R,'W?',0 &&
                n $s.t  R %ting,toW
        },'ift,D'],
        
        # look through 4/5 for links
        ['inspecto','3',&acgtRs{
            me&walla;
            $p = me.cbu(R,'ting');
            each in sy&N {
                (ps&species == 5 && ny&up && ny&up.t == 'W' ||
                ps&species == 4 && ns&sc && ns&sc.includes('W')) &&
                    n $n.t  $s:n,R %itemo:W
                ps&species == 4 && ns&c && ns&c.includes('W') &&
                    n $n.t  $s:n,R %itemo:cW
            }
        },'ift,D'],
        
        ['itemo','3',&acgtRs{
            me&walla,0.4;
            $p = me.cbu(R,'ting');
            me&tsc,'itemo',Rs&itemo,'6' .y.cv = 0.08
            $t = me&domesticate,R;
            ts&hs = 296; # tsc'y'
            ss&zs and me&tsc,'zsize','x'+ss&zs,'b'
            
            (Rs&boost||0) < 1 and return
            
            # open it in the .1
            $wasp = p
            ps&species and p = me.cbu(py&up,'ting')
            !p and throw "!pp !species"
            p == wasp and was = null;
            $M = ps&More ||= [];
            
            if (Rs&itemo == 'W') {
                $n =
                m $s.t  R:1 %ting,toW
                wasp and ns&autospecies = wasps&species;
            }
            else {
                $es = ps&Live;
                $z = es && ess&z;
                $ok = 0;
                each in z {
                    n.t != s.t and continue
                    $ok = 1;
                    m $n.t  $s:n,R:1 %ball,tightly
                }
                !ok and return me&tcs,'!Live/t'
            }
        },'ift,D'],
        #c %ting push/pull of C living across the boundary
        #  the question should roll+clone
        #    to transact by the dependent process?!
        ['ting','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dubquiet = 1;
            # make little label as from this I
            $p = me.cbu(Ry&up,'ting');
            $lab = &ltc{
                $n = me&tsc,'%ting-'+l,t,c;
                ns&fs = 11;
                return n
            };
            T.Mw = 'ting';
            
            # more %ting:1 in the same of/directory
            # < seeing where edges of C are,
            #   pressurise to voyage
            $t = null;
            if (Rs&ting == '1') {
                !p and throw "ting:1 !p"
                # same ting, may be adding %species
                Rs&ting = ps&ting;
                ps&directory and Rs&directory ||= ps&directory
                # may to another W/$t
                t = Rs&toW ? R.t : p.t;
            }
            # the Q&of = W
            !Rs&ting and throw "!%ting";
            $n = lab('ting',Rs&ting,'G');
            ns&fs = 15;
            
            # the Q.t = directory/t/species
            t ||= R.t;
            $fullname = t;
            #   only say change in directory
            (p ? ps&directory != Rs&directory : Rs&directory) &&
                lab('directory',(Rs&directory||'/'),'B')
            p && R.t == p.t ?
                lab('t-same','^','G')
              : lab('t',t,'G')
            Rs&species and lab('species','.'+Rs&species)
            Rs&species and fullname += '/'+Rs&species
            Rs&directory and fullname = Rs&directory+fullname
            
            me&the_ting,R;
            
            $Q = me&rollbs,R,'Q';
            Q && Q.t != fullname and Q = null
            !Q and Q = Rs&Q = G&Cye,[fullname,'',{of:Rs&ting}];
            Rs&Quploadsc and Ry&up.sc[Rs&Quploadsc] = Q
            Qc&async = &{};
            # c&canwait = 1;
            Qc&ready = &CP{};
            $s = Rs&Live = Rs&_ting(Q);
            
            T.Mw = 'ting-into';
            # you may roll into 
            me&rolltog,R,{may:'Q'},0 &&
                n Q  $self:Q,R %Cit,ot
            
            !Qs&ready and me&waits,'!ready','...'
            
            Qc&el and $el = me&tsc,'elvis',""+Qc&el,'b'
            el && elc&s == 9 and els&fs = 16;
            
            !s and return
            # look in
            me&rolltog,R,{may:'L'},0 &&
                n Live  $self:s,R %Cit,ot
            
            me&rolltog,R,'toball',0 &&
                n Live  $s:s,R %ball,tightly,refpool
            
            if (Rs&species) {
                if (!Rs&toball) {
                    sy&N ||= me&sunN,s;
                    me&tsc,'Csize','x'+sy&N.length,'b';
                    # < make part of genesising a %ting from a %tracting?
                    $tracting = Rs&tracting || Rc&b && Rc&b.sc.tracting;
                    $ope = !tracting;
                    ope ||= me&rolltog,R,{may:'inspecto',s:'O',fs:12};
                    ope &&
                        n inspecto $s:s,R %inspecto
                }
            }
            else {
                # %ting/%ting subspecies of same
                #  4 is low resolutions of the data
                #  5 is an of/t %Giveness
                Rs&autospecies and R.sc['/'+Rs&autospecies] = 1
                me&rolltog,R,'/4',0 &&
                    n Hive  R %ting,species:4
                me&rolltog,R,'/5',0 &&
                    n Give  R %ting,species:5
            }
        },'ift,D'],
    ] };
    #c Search Tingingness gets domethings
    # stately getting of things
    # < with/via e,
    #   generating more different e,
    #   returning you clues or it
    # < knows structuR, me.cby-like stuff
    #   the old G&t worked off A.1-5 being
    #    the spheres locality around A
    #   
    
    # G&c but harvested by Tool
    #  as coming from this R, in/out of time,
    #   talking about other R, to make acts shimmer
    #  available as verbosity, debug points
    #  muted when recognised
    # < io-param-like + styles of message with object in
    me.chatter = &acgttl{
        l.constructor != Array and throw "send array"
        each in l {
            l[i] = '>'+(3+(i*2))+':l'+i+' '+(n||'')
        }
        return G&c:'>1 '+t,l
    };
    
    # %ting is a layer upon ...
    me.the_ting = &acgtR{
        # have %Search%_ting
        $r = me.cbu(R,'Inn');
        $r = r && rs&Inn;
        !r and throw "no way Inn"
        !rs&_ting and throw "no Inn _ting";
        Rs&_ting = rs&_ting;
    };
    
    # Guxily for thing, got via stately e
    #  W it pulls in may clue changes to other W
    #  per remote place, which may already have its catalogue here
    me.Tingingness = &acgtR{ return [
        # the centralising of stuff going in!
        # for using thing = $of/$t on an ongoing basis
        #  gets I.$of.$t
        #  some $of (W/w/js) may network, contain more I
        # usually 
        #   is $t still $dige?
        #   its $dige, here: $s
        # we may get an el/lv/anything-known about things that change
        # the set of Questions you have:
        #   looks like Writer's .5 deps: $type/$name%details
        ['sleeping+Search','4',&acgtRs{
            $b = Rc&b;
            Rs&_ting = bs&_ting;
        },'ift,D'],
        ['Search','4',&acgtRs{
            # an h call muddies T
            $Gtime = &d{ return G&time,d };
            # similar!
            $ch = &tl{ return me&chatter,t,l||[] };
            
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            me&introqua,[R,'Ghost'],{boost:-1},'@1';
            n Ghost  $s:Ghost,R %ball,childy
            
            # of/t=$P
            i $Ghost/In
            # of/t=$P in motion
            i $Ghost/Pulling
            
            
            $Pio = Rs&Pio = {};
            Pio.what = &tP{
                o $Ghost/#$t/#Pc&of/#$P:s
                return ya
            };
            Pio.not = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
            };
            Pio.is = &tP{
                i $Ghost/#$t/#Pc&of/-#$P:s
                i $Ghost/#$t/#Pc&of/$P:s
            };
            
            #c _ting - a many arg'd entrypoint
            #  ting becomes the reduce for io's map
            # 
            Rs&_ting = &stz{
                # Question - may come with ...
                $C = isC(s) ? s : G&Cye,[t,1,{of:s}];
                
                # the G.t variety?
                # if !found of a Talky of:
                
                # C in the field, P in the store
                $P = Pio.what('In',C);
                if (!P) {
                    P = G&Cye,[C.t,1,{of:c&of},{}];
                    Pio.is('In',P);
                    Ps&Want_Check = 1;
                }
                # validate cache
                Ps&now && Gtime(Ps&now) > 25 and Ps&Want_Check = 1
                s&P && s&P != P and s&oP = delete s&P
                
                # in/out of time bit, lost in the store
                $ok = Rs&Pull_a(C,P);
                
                # don't wait for the async check
                # Pc&s only null if never found,
                #  or new string is got but not decoded
                !ok && Pc&s && !c&canwait and ok = 1
                
                if (!ok) {
                    # go async
                    s&ready = 0;
                    # after, c&ready() climbs back to C time
                    c&ready and ac(P,'readyingC',C)
                    c&async and c&async()
                    else {
                        G&TuneTimeMachine,c&of+':'+C.t
                    }
                }
                else {
                    # C is, Pc&s == null must be intentional
                    s&ready = 1;
                    
                    # C <dige> P, may surprise
                    # el=1/8 basically
                    c&el = Pc&el;
                    if (!c&el || c&el == 1) {
                        c&el = s&dige != Ps&dige ? (s&dige ? 2 : 1)
                            : 8
                    }
                    c&el && Py&decidedel && Py&decidedel(c&el);
                    
                    s&dige = Ps&dige;
                    c&s = Pc&s;
                    # C never gets s&string unless it makes it

                    # keeps Pc&s while update is looked for
                    Pc&s && Ps&Pulling_since && c&canwait and ~waitscan
                    else
                    Pc&s and return Pc&s
                }
            };
            #c Pull_a
            
            Rs&Pulling_already = &P{
                $ya = Pio.what('Pulling',P);
                # don't trust stagnant Pulling
                if (ya && Gtime(yas&Pulling_since) > 5) {
                    ya = Pio.not('Pulling',P);
                }
                # don't shunt Pull_a from outside its own callbacks
                #  which will have ensured they don't reoccur
                ya and ch('dupreq',[Cc&of,C.t]); return
                return ya
            };
            
            # shunt P - can progress out of time
            # then returns 1 and/or calls c&ready
            Rs&Pull_a = &CP{
                # < make s&string mean write string, our thing in c&s
                if (Ps&Want_Check || s&string) {
                    if (Ps&Want_Check == 2) {
                        s&string and ch("Redo+string")
                        delete s&string;
                    }
                    else {
                        # waiting on P
                        Rs&Pulling_already(P) and return
                        # become Pulling
                        Ps&Pulling_since ||= Gtime();
                        Pio.is('Pulling',P);
                        Pc&T = {};
                    }
                    $T = Pc&T;
                    # shunts Pull_a when ready
                    T.cb_gen = &CP{
                        if (T.redo) {
                            ch('Redoing',[P.t]);
                            Ps&Want_Check == 2 and throw "redo x2"
                            Ps&Want_Check = 2;
                            delete T.redo;
                        }
                        else {
                            delete Ps&Want_Check;
                        }
                        Rs&Pull_a(C,P);
                    };
                    # sends
                    Rs&Pull_Check(T,C,P);
                }
                $T = Pc&T;
                !T and throw "unstarted P"
                !T.ok and return
                
                # < C gets its own decode? or Copy Pc&s on el<3
                #s&wantdecode and Ps&Want_Decode = 1
                # < modes of decode: dl/Xpath, allowing yaml code
                Ps&Want_Decode and Rs&Pull_Decode(T,C,P)
                
                !T.ok and return
                delete Ps&Want_Decode;
                
                # < way getting args/wrapping/eval as Pull_Transcode?
                #   it's ting's business if things want to share
                
                Pio.not('Pulling',P);
                delete Ps&Pulling_since;
                # pulling done re. $Ghost, but not $C
                #!Pc&s and throw "no ting Pcs: "+Pc&of+'/'+P.t
                
                s&P = P;
                Py&decidedel = &n{ T.tcp.set('l3',n) };
                
                each iC Ps&readyingC {
                    # P completed async, get back to C time
                    #   no longer awaiting yon return 1
                    c&ready and c&ready(C,P)
                }
                delete Ps&readyingC;
                
                return 1
            };
            #c PullCheck
            Rs&Pull_Check = &TCP{
                T.waits and throw "PullCheck while waits"
                T.ok = 0;
                # they may have their own ways to use dige/v, p/P/s&P
                # Pc&get how to ask,
                # Pc&got loads response into P
                $Do = Rs&Talks[c&of];
                !Do and throw "!Talk "+c&of
                T.get = {};
                T.get.data = {};
                Do(T,C,P);
                !T.get.url || !T.got and throw "!Talk handlers "+c&of
                
                T.cb = &sc{
                    T.aft_waits = Gtime();
                    # every pulling happened now
                    Ps&now = Gtime();
                    # specific stuff moves from the response to P and Pc&s
                    #  can !T.ok...
                    T.got(P,s,c);
                    # out of time plumb
                    # may be stolen by got if more requests (/js)
                    T.ok = 1;
                    T.cb_gen and T.cb_gen(C,P)
                };
                Rs&TCP(T,C,P);
            };
            # rebuild tcp
            # < https://javascript.info/xmlhttprequest
            # < have A, so async in handler gets retried
            #    (or G&way noop deps just before handling)
            # < get or ws
            # retry, expire
            # uses T.get -> T.cb()
            Rs&TCP = &TCP{
                $tcp = T.tcp = ch("tcp",[T.get.url,'.','.','.','']);
                
                $done = &s,how,c{
                    !T.waits and return
                    T.waited = Gtime(T.waits);
                    delete T.waits;
                    tcp.set('l1',G&thime,T.waited );
                    r.status != '200' and return T.status = r.status
                    T.cb(s,c);
                };
                
                $r = T.r = $.ajax(T.get).done(done);
                T.waits = Gtime();
                
            };
            Rs&Pull_Decode = &TCP{
                T.ok = 0;
                $type = Ps&Want_Decode;
                $de = ch('decode',[P.t,type,'','']);
                # Pc&el becomes interesting to the Client,
                #   2-3 were our will carried out
                #   6-7 to merge
                # < C may want a new set for itself, to make a mess
                #   while we are in the clone factory
                #   faster to separate with io than many readLines?
                #   but how much safer?
                
                $s = null;
                try {
                    if (type == 'Lines') {
                        !Ps&string and throw "P!%string"
                        $N = G&readLines,Ps&string;
                        N.length != 1 and throw "Weird tW lines", s
                        s = N[0];
                    }
                    elsif (type == 'way') {
                        $w = G&Cye,[C.t,1];
                        wc&s = Ps&string;
                        ws&of = 'w';
                        # dige is for s before compiled
                        ws&dige = Ps&dige;
                        s = w;
                    }
                    elsif (type == 'js') {
                        s = Pc&s;
                        Rs&Decode.js(s);
                    }
                    else {
                        throw "Decode type "+type
                    }
                    s.y.P = P;
                    Pc&s = s;
                }
                catch (er) {
                    T.er = er;
                    de.set('l2','Error!');
                    de.set('l3',er);
                }
                Pc&s = s;
                s && !T.er and T.ok = 1
                
                if (T.ok && T.aft_waits) {
                    T.aft_waited = Gtime(T.aft_waits);
                    delete T.aft_waits;
                    $tcp = T.tcp;
                    tcp.set('l2',G&thime,T.aft_waited );
                }
            };
            
        
            #c Talks.w
            Rs&Talks = {};
            Rs&Decode = {};
            Rs&Mix = {};
            # < w are from:
            #  the digway+/way/ (trad)
            #  the /w/ (unBabz'd way) (new)
            #    this dige might match the one from digway?
            #  the /wayz/ (Babz usual blockquotes)
            #    for use in We
            Rs&Talks.w = &TCP{
                # < Babz mode: none, normal, BQ-inclusive
                T.get.url = '/way/'+C.t;
                Ps&dige and T.get.data.have = Ps&dige
                T.got = &Psc{
                    $dige = c.getResponseHeader('Dige');
                    !s && Ps&dige == dige and s = Ps&string
                    if (s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = dige;
                        Ps&string = s;
                        Ps&Want_Decode = 'way';
                    }
                };
            };
            #c Talks.js
            Rs&Talks.js = &TCP{
                # I in a .js script (+ a little about the 9)
                # first request: only to find the dige,
                # then we can write a unique <script src=toit>
                # < if we know what version don't do this first request
                # T would put this c&dige to wind back from bugs
                # hazardily shared P having the branch reset,
                #   put the -$dige in C.t already to have a specific P be there
                T.get.url = '/js/'+C.t+'-'+(c&dige||'head');
                # < if c&v forced/trusted (via Wover),
                #   use the exact url to add_script
                # < does the rewritten Location mean the second XHR caches?
                $cb_gen = delete T.cb_gen;
                T.got = &Psc{
                    $src = c.getResponseHeader('Location');
                    $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                    $W = Pc&s = G&Cye,[m[1],1];
                    Ws&I = {};
                    Ws&dige = Ps&dige = m[2];
                    # /js/ 
                    # nest callback
                    T.ok = 0;
                    T.waits = Gtime();
                    $callback = &s,e{
                        T.waited_script = Gtime(T.waits);
                        T.ok = 1;
                        Ps&script = s;
                        Ps&Want_Decode = 'js';
                        cb_gen(C,P);
                    };
                    Rs&add_script(src,callback);
                };
            };
            # implant code as .js
            #  should be able to receive any ting,
            #  esp way, is more stack/debugger findable loaded like so:
            Rs&add_script = &src,cb{
                $have = $('body script[src="'+src+'"]');
                have.length and return cb(have[0])
                $s = document.createElement('script');
                s.setAttribute('src', src);
                s.setAttribute('type', 'text/javascript');
                cb and s.onload = &e{ cb(s,e) };
                document.body.appendChild(s);
                return s
            };
            Rs&Decode.js = &W{
                $tocfunc = W.t+'_'+Ws&dige;
                !window[tocfunc] and throw "Notocfunc: "+tocfunc;
                $toc = window[tocfunc]();
                $D;
                each iv toc {
                    $ind = v[0];
                    $C = G&Cye,[v[1],v[2],v[3],v[4]];
                    if (ind == '') {
                        D = Ws&I[C.t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        # grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t, v
                    }
                }
            }
            #c Talks.W
            Rs&Talks.W = &TCP{
                T.get.url = '/W/'+C.t;
                $d = T.get.data = {};
                # clue them to Hobs for it we have around
                # the current HEAD:
                Ps&dige and d.have = Ps&dige
                # the first "can you hold on to..."
                if (s&string != null) {
                    # wants to write, '' to delete
                    T.get.type = 'post';
                    d.s = delete s&string;
                    if (d.s.length && d.s == Ps&string) {
                        # keep expecting it
                        !d.have and throw "sleeping write !Psdige"
                        delete d.s;
                    }
                    # < get the average size of codes down,
                    #   mix them locally (A:u)
                    c&patch and throw "< patches"
                    # continuity check, also for deletes
                    # < d.parent=null means it should be new
                    s&P and d.parent = s&P.sc.dige;
                }
                T.got = &Psc{
                    $r = dej(s);
                    # dige find things we d.have
                    if (r.dige && r.s == null) {
                        r.dige == Ps&dige and r.s = Ps&string
                        else
                        d.s && r.dige == dig(d.s) and r.s = d.s
                        r.s == null and $nors = 1;
                    }
                    $el;
                    r.ok == 'found' and el = 1
                    r.ok == 'created' and el = 2
                    r.ok == 'updated' and el = 3
                    # 6 is 3 from beyond 5! matters
                    r.ok == 'forward' and el = 6
                    r.er == 'not ffwd' and el = 7
                    r.ok == 'deleted' and el = 9; Ps&departs = Ps&dige
                    r.er == 'not found' and el = 9
                    Pc&el = el;
                    if (el == 9) {
                        # watch for undelete?
                        r.s and throw "what"
                        delete Pc&s;
                        delete Ps&dige;
                        delete Ps&string;
                        # plumb? like an elvisory
                        return
                    }
                    if (nors) {
                        # < different perl/javascript dig
                        el == 3 and return T.redo = 1
                        else {
                            throw "get/W implied we know", r, P
                        }
                    }
                    if (el == 7) {
                        # notify push failed?
                        c&rebase and c&rebase(P,r)
                        else {
                            throw "not ffwd: "+C.t, r
                        }
                    }
                    !el and throw "tW er", r.er, P, r
                    if (r.s && r.s != Ps&string) {
                        Pc&s = null;
                        Ps&dige = r.dige;
                        Ps&string = r.s;
                        Ps&Want_Decode = 'Lines';
                    }
                };
            };
         
            
            #c way/js questions as C
            # public interfaces
            # shows how to plug their async gear into ting's
            # the wandering part of G&way
            Rs&quest_w = &acgttry{
                $ar = r;
                $cb = y;
                $Q = G&Cye,[t,'',{of:'w'}];
                Qc&ready = &{
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                    # so wait for it...
                    !cb and return
                    if (G&arfgunc,cb == "s") {
                        # way randomly happens, give return value to cb
                        # without A lining up around it (it may do so itself)
                        # see G&waylay for use case as delayed call
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the context revisted?
                        cb(t,ar,w);
                    }
                };
                Qc&async = &{
                    cb == 'noop' and cb = &{}
                    else
                    typeof cb == 'string' and throw "Cant go async: "+cb

                    # Jin should avoid this A for a while
                    a&ready = 0;
                    # and throw/abort if no callback
                    !cb and G&TuneTimeMachine,'w:'+t
                };
                $w = Rs&_ting,Q;
                return w
            };

            Rs&quest_js = &acgtt{
                $Q = G&Cye,[t,'',{of:'js'}];
                Qc&ready = &{
                    A.cv = 0.4;
                    # Jin should accept this A again
                    # < never set to 0, might speed it up if...
                    a&ready = 1;
                };
                Qc&async = &{
                    a&ready = 0;
                    4s&N.push(A);
                    T.not = 1;
                };
                $W = Rs&_ting,Q;
                #a&I = Ws&I;
                #a&v = Ws&v;
                return W
            };

         
        },'ift,D'],
        
    ] };
    #c %mundws holds an A:ws
    me.Socketingness = &acgtR{ return [
        # < push/pull of C living across the boundary
        ['mundws','3',&acgtRs{
            Rs&rowish = 1;
            # < these ways to assume arguments want fibre
            $ws = me&rollbs,R,'Sock',1;
        },'ift,D'],
        
        # at LVing avail
        ['mundws','4',&acgtRs{
            Rs&rowish = 1;
            
            # current state
            $ws = Rs&Sock;
            
            # /path
            me&tsc,'mundws','ws:','b';
            me&tsc,'path',R.t
            me&tsc,'state',ws.state,'6';
            ws.state == 'closed' and Rs&Sock = 1
            
            # %Again
            $z = Rs&Opinion && Rs&Opinion.sc.z;
            $len = z && z.length;
            z and me&tsc,'Opinion.length','('+len+')';
            
            Rs&Lving &&
            n Lving  $self:Rs&Lving,R %Cit
        },'ift,D'],
        #c GhodigWap news from the 5 year old editor
        # one aspect of news about $ways, from g/\w+/\d+
        ['GhodigWap','3',&acgtRs{
            # replaces J:digwaypoll
            me&rolltog,R,'nodigway',1,&s{4c&nodigway=s};
            
            
            # $w as heard about, seekended and living (Iw)
            me&introqua,[R,'ifd','Ghost','apparently'],{boost:-1},'@1';
            me&introqua,[R,'ifd','Ghost','est'],{boost:-1},'@1';
            me&introqua,[R,'wats'],{boost:-1},'@1';
            
            # w can be trusted if listened for in digwaypoll
            # digwaypoll in/out only t + dige
            #  dige may vary in length > 6
            #  dige in merely allows Opinion to sleep
            #   when it comes out, which we could imply:
            #   < Lc&* for server's agreement with said diges
            #     they say what send() they agree up to,
            #      and we synthesize eouts to mean it
            n digwaypoll  R %mundws,Ghocoline,tinyscLines:dige,mightsctrunc:dige
            
            n ifd  R %Ghostway
            # < ^ having its own compile,
            #   your ting w/* perspective may incorporate it
            #   then another ing happens?
            
            # G&way compiled:
            n wats  $s:A.5.I.w,R %Idoubleyou,ball,childy:tw
            
        },'ift,D'],
        #c Ghostway - asks for way notifies, gets them
        # provides ein/out/ope
        #   by way of %Again/%tinyscLines
        #   for C sloshing in or out
        # knows how to talk ws:s/digwaypoll
        ['Ghostway','33',&acgtRs{
            $p = Ry&up;
            # place to talk
            $S = Rs&Upstream = ps&z[ps&z.indexOf(R)-1];
            $ch = Rs&chatter = Ss&chatter;
            # insured memories via %Again
            $g = Ss&Again = ps&z[ps&z.indexOf(R)+1];
            $Way = gc&s;
            
            # the 'here', a join
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            n Ghost  $s:Ghost,R %ball,childy
            
            # pile from both ends over time
            i s:{ Ss&Opinion=C } $Ghost/apparently:s
            # and changes go further
            i s:{ Ss&Further=C } $Ghost/seek:s
            
            # on change, queue:
            Ss&do_Further = &{
                # /apparently/* changing creates /seek/*
                # to look it up since that dige changed
                o $Ghost/seek/*
                $seeking = ays&s;
                !seeking and return
                Rs&seeking = seeking.slice();
                each is seeking {
                    o $Way/#$s
                    !ya and ch("didnt know",[s.t])
                    Rs&seeketh(s,ya)
                }
                return
            };
            
            # < ting many asks per question
            #   so many seekeths make one seekend
            #   is a keepalive for the first question
            Rs&seeketh = &s,was{
                ch("seeking...",[s.t]);
                #$w = G&ting,'w',s.t;
                #   currently takes old-G&t shortcut,
                #    returns way without checking ttl
                $cb = &t,ar,w{
                    Rs&seekend(w,s,was);
                };
                # noop='nottl' so it renews#
                G&way,s.t,{},cb,'nottl';
            };
            
            # thing is got!
            Rs&seekend = &w,s,was{
                Ss&sleep_Further &&
                    Ss&sleep_Further(w,s);
                
                $com = [w.t];
                !was and com.push("@1")
                else
                if (wass&dige == ws&dige) {
                    return ch("Seeksame",[w.t])
                }
                ch("Seekback",com);
                # hold latest one here
                # < of those changing rapidly
                #   rolling commits together
                #   ong branch slower, then ung
                i $Ghost/ing/$w
                # once after the batch (ish)!
                $si = Rs&seeking.indexOf(s);
                si >= 0 and Rs&seeking.slice(si,1);
                # wait up to 30ms if more might seekend
                $delay = Rs&seeking.length ? 30 : 0;
                # joining seekends near in time!!!!!!
                $cb = me&sccb,R,'seekingdone',Rs&do_ing;
                delay ? G&yl,delay,cb
                    : cb();
            };
            
            #c 7 thing-got
            Ss&sleep_Further = &ws{
                if (!w) {
                    # from eout that sleeps
                    o $Way/#$s
                    w = ya;
                    !w and return ch("didn't know sleeping",[s.t])
                }
                # Iw has $w, make permanent!
                ws&now = G&time + 3600;

                i $Ghost/seek/-#$s
                # < should know time is up for this ground,
                #   get it attached via Tsome
                #n seen  $self:w %Cit
                # permanent
                i $Ghost/est/$w
            };
            
            Rs&do_ing = &{
                # things changing, code to redo!
                o $Ghost/ing/*
                $inging = ays&s;
                # < otherwise G&ting evals?
                $doers = 'Soogle Packle Coffle Foogla Fividy'.split(' ');
                $mewrap = 'iooia'.split(' ');
                $doerd = [];
                each iw inging {
                    if (mewrap.indexOf(w.t) >= 0) {
                        # me.codes containers should run
                        ch("Ghostwaywr",[w.t]);
                        me[w.t](w);
                    }
                    elsif (doers.indexOf(w.t) >= 0) {
                        # me.codes containers should run
                        ch("Ghostwayer",[w.t]);
                        G&way,w.t;
                        doerd.push(w);
                    }
                    else {
                        ch("Ghostway",['',w.t]);
                    }
                    i $Ghost/ing/-$w
                    # then anything dependent on the way
                    #  eg I, J...
                    #  diff way to wake a .Ja. is not impossible
                }
                # for $w that generate $me which generate I,
                #   drop Ring's cache of me I
                $dropcache = doerd.length && 1;
                
                Rs&do_permanence(dropcache);
            };
            
            Rs&do_permanence = &dropcache,{
                # keep permanent
                # the only in-time operation
                # < scan for not in Iw
                # < dige sleep on init may not get things here:
                o $Ghost/est/*
                each iw ays&s {
                    ws&now = G&time + 3600;
                    if (dropcache) {
                        delete ws&makesI;
                        delete ws&makesIw;
                    }
                }
            }
            
            # keepalive
            Rs&do_permanence();
            # casual shunt, in case e loses its will to carry it out
            Ss&do_Further() || Rs&do_ing();
        },'ift,D'],
        
        #c %Again (C/%ball source) -> %ein()
        # e inits some state (usually)!
        ['Again','35',&acgtRs{
            !Rs&Again.sc.ball and throw "Again!ball"
            Rs&Lvact = &{
                $N = me&ioty,Rs&Again,'%ball';
                each in N {
                    N.indexOf(n) < i and ~DupeyzLvact: n.t
                    Rs&ein(n)
                }
            };
            # el=2 everything
            Rs&eope = &{ Rs&Lvact() };
            # el=2 changing
            Rs&Lving and Rs&Lvact()
            
        },'ift,D'],
        # %ein() C only t and certain sc
        # %eout() C into %Opinion
        #   and into %Further if certain sc change
        ['tinyscLines','32',&acgtRs{
            # Lving: may not make it through send() if same
            Rs&uniqsend = 1;
            # a t/dige only variety of tinyLines encoding:
            Rs&tinyLines = 1;
            
            # only certain sc taken
            $only = Rs&tinyscLines;
            only = only && only != '1' && only.split(',')
            Rs&takeonlysc = &s{
                !only and return ex({},s.sc)
                $sc = {};
                each ik only {
                    s.sc[k] == null and continue
                    sc[k] = s.sc[k]
                }
                return sc
            };
            
            # their Opinion arriving
            Rs&hasonlysc = &sl{
                $ks = only || haks(s.sc);
                $ok = 1;
                # checks how different it is
                each ik ks {
                    $was = s.sc[k];
                    $is = l.sc[k];
                    $com = [l.t, k, was, '->', is];
                    !is and ch('nullsc',com); return -1
                    
                    was != is and ok = 0
                    
                    if (!ok && Rs&mightsctrunc == k && was
                        && was.length > 6 && is.length > 6) {
                        ok = was.includes(is) || is.includes(was)
                    }
                    !ok && was and ch('scut',com)
                }
                # applies!
                each kv l.sc {
                    s.sc[k] = v
                }
                return ok
            };
            
            $ch = Rs&chatter;
            Rs&ein = &n{
                !ns&ball and throw "!ball: "+ki(n)
                $c = {}; # L%send[D.sc
                $s = nc&s;
                $C = G&Cye,[s.t,1,{},Rs&takeonlysc(s)];
                # Opinion is one piled from both ends
                #   so it can come back same the first time
                i Rs&Opinion/-#$C
                i Rs&Opinion/$C
                c.toLines = C.t;
                if (haks(C.sc).length) {
                    c.toLines += '%'+G&depeel,C.sc
                }
                Rs&send(n,c);
            };
            Rs&eout = &l{
                !Rs&Opinion and throw "give Opinion"
                !Rs&Further and throw "give Further"
                
                # their opinion is arriving
                i Rs&Opinion/#$l:s
                $ok = Rs&hasonlysc(ya,l);
                ok < 0 and 'said error'
                elsif (ok) {
                    ch('sleep',['way',l.t]);
                    Rs&sleep_Further &&
                        Rs&sleep_Further(null,l)
                }
                else {
                    # changes go %Further once per receive
                    ch((!ya?'new':'wake'),['way',l.t])
                    i Rs&Further/$ya
                    Rs&do_Further &&
                        ac(R,'Finally',Rs&do_Further)
                }
            };
        },'ift,D'],
        #c Ghocoline - C<->string envelope
        # provides %receive(), wraps %send()
        #   en/decoding some string format
        # Lving @31 logs a %send/receive[D+]
        # see 'Lving' around here, it may also:
        # < Ls&z clone C we sent them?
        #     would allow better %resumable
        #     %uniqsend dedupes for now
        # the @34 do push/pull C across a boundary stuff
        # the @32 is C<->string:
        # all Lines =~ /^[ \w"]/
        #  so there's room for some protocol in there:
        # < Lc&resumable - do you remember? rolls state:
        #   - roll Ls&send if %uniqsend, dedupes
        #   - know Ls&z and lv-sense to your app
        #   app must sleep while we try to:
        #   negotiate what they know with el=7
        #     might know our/previous Ls&sent_dige
        #       retransmit Ls&send
        #     or stuff on the ground
        #       exploratory W nature,
        #       eg check state of everything in Toys:
        #         Toys el:7%dige:358i0f
        #       may not include %dige on request,
        #         but then the server could pre-empt our:
        #           what has what become,
        #            and what can be patched
        # Lc&responsey - expect one receive per send
        #   link them, ordering if many backends
        #   responses not in requested order
        #   < slowing/Aing out time to understand message
        ['Ghocoline','32',&acgtRs{
            Rs&receive = &sD{
                typeof s != 'string' and throw "receive !string"
                $ch = Rs&chatter;
                ch and ch('receive',[ki(s,3)])
                
                Rs&tinyLines and Rs&someLines ||= 1
                Rs&someLines and Rs&contLines ||= 1
                
                if (Rs&contLines) {
                    # can know how to nest another protocol
                    if (!s.match(/[ \w"]/)) {
                        # tricks with Lving"
                        throw "strange"
                    }
                    elsif (s.match(/^ /)) {
                        # Lving -> last message's cursor
                        throw "floating start"
                    }
                }
                
                # string tricks
                # decoded N everything becomes M ways in
                $l = [s];
                if (Rs&someLines) {
                    # splits lines, batch of something
                    # < by next Line d=0?
                    l = s.split("\n");
                    l.slice(-1)[0] == '' and l.pop()
                }
                
                # parsed
                $z = l.slice();
                if (Rs&tinyLines) {
                    # parse Ghost%dige:4827848
                    each is l {
                        $s = s.split('%');
                        s [0].split("\t").length > 1 and throw "comp"
                        z[i] = G&Cye,[s[0],'',{},s[1]]
                    }
                }
                elsif (Rs&contLines) {
                    throw "readLines wanted"
                    # make R to deLines then ein?
                    #$N = me&readLines,s;
                }
                
                # iterated
                Rs&esout and Rs&esout(z)
                else
                Rs&eout and z.map(s => Rs&eout(s,z))
                
                $Fin = delete Rs&Finally;
                Fin && Fin.map(cb=>cb());
            };
            #c send!!
            $send = Rs&send;
            !send and throw "no Ghocoline proxy send()"
            Rs&send = &sc{
                $string = s;
                # the Lving%send/$D .sc
                c ||= {};
                typeof s == 'string' and 'ok'
                else
                !isC(s) and throw "obj->string"
                else
                s.y.R != s and throw "send C !R"
                else
                if (ss&ball && ss&toLines || c.toLines) {
                    string = c.toLines || ss&toLines;
                    c.origin = s;
                    $L = Rs&Lving;
                    # < Lving: repeat string/diff/compression
                    #   smelting toLines' intel,
                    #   what to do with lots of el:8 etc.
                    if (Rs&uniqsend && Ls&send) {
                        $i = Ls&send.length-1;
                        while (Ls&send[i]) {
                            $D = Ls&send[i--];
                            !Ds&origin and continue
                            if (Ds&origin != s) {
                                # by .t?
                                Ds&origin.t != s.t and continue
                            }
                            Dc&s == string and return
                        }
                    }
                }
                else
                ss&ball and throw "send R%ball!%toLines"
                else {
                    throw "send R!%ball"
                }
                
                $ch = Rs&chatter;
                ch and ch('send',[ki(string,3)])
                send(string,c);
            };
            Rs&open = &{
                $L = Rs&Lving;
                L && Lc&b && Lc&resumable and 'Lvism el=7 for %sent_dige'
                Rs&eope and Rs&eope()
            };
        },'ift,D'],
        #c A%Sock <-> A:ws!
        # at both ends of the deal
        # provides Rs&Lving and Rs&send()
        # uses Rs&open() and Rs&receive()
        ['Sock','31',&acgtRs{
            $ws = Rs&Sock;
            if (ws == 1) {
                $url = 'ws://'+location.host+'/'+R.t;
                ws = Rs&Sock = new WebSocket(url);
                ws.url = url;
            }
            
            # when R el=9
            me.cbuac(R,'unDoming',&{
                ws.close(1000,'lum')
            });
            $X = window.websocks ||= {};
            X[ws.url] = ws;
            $sockdup = &{
                X[ws.url] == ws and return
                ws.close(1000,'dup');
                return 1
            };
            
            # our A:ws.c hooks
            # this should A:session
            #   reflecting a scene across it
            #   they might hold objects for us,
            #     as we talk to them
            #   or show objects we talk about
            $L = me&rollbs,R,'Lving';
            
            # try leak chatter!!!!!!
            $ch = Rs&chatter = &t,ev{
                # < io-param-like + styles of message with object in
                $l = ev.constructor == Array ?
                    [R.t, ... ev] :
                    [R.t,
                    ws.deter('code',ev.code),
                    ev.reason,
                ];
                each in l {
                    l[i] = '>'+(3+(i*2))+' '+(n||'')
                }
                G&c:'>1 '+t,l
            };
            
            # L logs a %send/receive[D+]
            $roll = &tsoc{
                $L = Rs&Lving;
                !L and throw "ws:L:send!open"
                
                # accumulating dige
                $digek = t+'_dige';
                L.sc[digek] = dig((L.sc[digek]||'')+s);
                
                # point in time log
                c ||= {};
                c.now = G&time;
                # opposite direction's count
                # last in when this went out, etc.
                1 && o and c[o] = L.sc[o+"_i"]
                # tsc causes n ... deep within out of time
                $D = me&tsc,t,s,c;
                ac(L,t, D );
                
                # count
                $ik = t+'_i';
                L.sc[ik] ||= 0;
                L.sc[ik]++;
                
                return D
            };
            
            # open/close/explode
            ws.onopen = &ev,{
                ch('open', ev);
                L = me&rollbsc,R,'Lving','b,increment';
                Rs&open();
            };
            ws.onclose = &ev,{
              ch(ev.wasClean ? 'closing' : 'close', ev);
              ws.deter('code',ev.code) != 'bad' and return
              # will re-new when R wakes
              delete Rs&Sock
            };
            ws.onerror = &ev,{
              ch(ev.wasClean ? 'err' : 'errs', ev)
            };
            
            # send/receive
            Rs&send = &sc{
                $D = roll('send',s,'receive',c);
                # never fails?
                ws.send(s);
                return D
            };
            ws.onmessage = &ev,{
                sockdup() and return
                $s = ev.data;
                $D = roll('receive',s,'send');
                Rs&receive(s,D);
            };
            
            # interpret the machine
            ws.proto = {
              state: {
                0:'connecting',
                1:'open',
                2:'closing',
                3:'closed',
              },
              code: {
                1000:'closing',
                1006:'bad',
                1001:'leaving',
                1009:'toobig',
                1011:'500',
              },
            };
            ws.deter = &tk{
                k == null and return ''
                return ws.proto[t][k] || t+'?'+k
            };
            ws.state = ws.deter('state',ws.readyState);
        },'ift,D'],
    ] };
    

