Foogla: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    =head1 #prepare to A=A
    
    some goals:
    - efficiently educating on A passage of time
    - J to take < 200ms
    - not noticing anyway
    - Elvising running the shower
    - unpatch, failing, patch, passing in a few seconds
    
    =head3 future of sleep: Doming
    A starts works, D are their completion
    
       C   E
     A   D 
       C   C
    
    A C9[C...] completes D and elvises a clone
    
    D - the Aing grouping items sprout inside
      z C & A to include C/group A workload
      provide osc-like cha/continuity without osc,
        yet be the atomicness osc uses to commit,
        and load with decor/nativities to make for mediation
          R:I is now being the osc workload gatherer + commit
            which should work on >=1 'pages' of osc at a time
              eg elvising from ...
              or the whole/9er
            rolling the others,
            being able to async progress,
              do work in parallel or not...
    make unities early to sleep/calculate desires better
      eg. when A is @28, the state can be considered D:early
      eg. when Jpin, S makes domes, which can then be known about
    internal buzz. pages of its ground.
      get composited into D:top, C9[C...] post-osc
      which gets hoisted/elvised into J/W timespace elsewhere,
        the macro-J Doming-looking action: hosting stuff.
    so to:
      make arbitrary groups
        for groups sake:
          naming stuff
          handling streams
        to stabilise/refine our sense of activity
      transport C out of time,
        so J>7 can help J<7 (sleep)
        osc-think may play with things outside of osc,
         < holds that state in a dome it hopes to pull in?
      locate them as possible actions,
        as bumping into a S-ection kinda defines it
          < more at compile time
        and elvis handlers... 1s&ein.sayeth = &acgts{
      know inputs in a tracable way
        Elvising pointing in here,
          as Teing is
        giving Desire pathways to trace processes
    
    Domes may iterate X/V or some structure from another Dome,
      it may be important to iterate locally and do remotely,
        they become transactions
    Desire might want to do something,
    as a new elvis pointing into here would
     Teing is a kind of elvising
       and is the float:right upside down triangle of stuff
         the small network-edge pile coming down into
         the big contenty pile of isness
     Schemas too, float their potential/unfoldment
       down holes they start matching
    
    #c sleep/done =head2 sleep
    
    %slep, a Tool probe
      a way to map their changes fast and sleep
        change of container vs. the values within etc
        can give/take sy&slandige/Ry&Te_slandige
     < could be faster/lessR: callback a huge ==-ish plucker,
        50ms 3%slep could get down to 4ms?
     < unicode everywhere. plants: üíÆ üå∏ üå∑ üåπ  üå∫ üåª üåº ü•Ä  üéï ‚öò üèµ üè∂  üå± üåΩ üåæ  ‚∏ô üå∞ üåø üçÄ üçÅ üçÇ üçÉ  üåµ üå¥  üéã üéÑ üå≤ üå≥
     < Cye takes y=o89 -> ycv=0.089
     < put sdiff and dup etc in 11-ish (dup 1189)
     < C/sc/css compressions, in Line or not
     
    Tool openness
      configures injectoids and transfiguration
      < more timely %differ growing out of it
      real interesting later
    
    < Elvisory re-slaning on %push to it?
       is the elvis delivery mechanism:
        give edifice of deliverableness
         resolve to best case or so:
       if it were a different J:
        enter it, changes input to thisJ
        decide to redome thisJ to involve that,
          or seeing our change come back to us
       Matu-ish out-of-time with %push gravitate reruns
      redo R building on changed elvisory?
      see 'rebuild %push to use e'
       %push currently injects the remote %ball%movingin
         which will not work if its asleep
         but it could be brought around about as fast if:
    < Te the %moves to Elvisory/anywhere
       with a watch for completion and callback/expiry
    < universal vision of rc&ha.dup,
    < replace ravel with Doming and Display2
    < TEST io.i z much
    
    # another
    o rebuild I via Babd ways
     o link G/ to W/G so we can update it ourselves
     o get a Lis rolling nicely
      o tests sign the version as it percolates
    o rebuild jsBab in js
     o fast way changes, lots of test results if you want
     o check against jsBabz for j/2/*
    
    o 'rebuild %push to use e'
      %checkout the tangley varieties of %push
    
    o unify name extrusion (see names extruding)
      like X but with where/when to D,
        alt names and fuzzentations (figure name changes)
          inc. crunchable path descriptions in various datalang
        universal gone/unnoticed system
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
    
    good study.
    perldoc -f study
    # < in general, knowing if the A is for a queue or for right now

    
    #c=head2 Maturation
    
    Gombulus hives elvising going in or coming out
    TX
    
    o a&z toplevel thinker
      and its localised sidecares
      a bunch of A not expecting J overhead
      rebuilding on the Co Joinup
        having it bring G (map of its dependencies) (see Give)
          as an %H of a different name
            once osc piles of whatever hoisting is?
              not much doc about osc hoisting:
               the W/of/t may W/what/ever/it/takes/t
               for stats/accounting
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    
    o and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and W-contiguous
            the simple funtimes embedded in the page,
            if browser compatible, Wake up and do anything
        I-ing up Sevo, then placing more A-ily,
    
    o names extruding, like X but with:
      connection to a dome:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
            done-ish by %slep
              could describe path or so
        decide once D:in !%more
          D:new == D:old to sleep, or:
          clone D:new to D:out and ...
            becomes someones D:in
              border control
        
    o Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    o elvising coming out or going in on the X
      and transacting the change of it
       as Domes, which have versions of Domes going into them
       an osc that keeps everything it sees would be first
        and be the wandering frontiers of change
     
    o making the R an A.
      compiling ravel into throat?
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further) (%slep)
     ongoing bisection of A
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    # anyway
    
    back to Pass...
    
    # thursday:
      new A4,
        < starts from a single /js/ with
          one screenful of prior knowledge
        A calmly pulls in its deps, sets foot...
    # saturday:
    # friday:
      new I compiled fore-way,
        composited and storaged in Pass
        is a layer of tools on a type of wormhole,
         which we also need to grasp moving around
        the bunch of names, Lis
    #c monday:
    W&Ha:
      bugs:
        seeI 1.2: is one of the Is Mlimits diags wrong?
        a slep inside a slep has some history issue, keeps spawning?
      W&ledges:
       tests slepology:
         specifically elvis change
       since W&edges is too large
     
     unseparated W&Ha starts taking Rc&N>1000 to check out
      its the elvising:
       < to be lv change only
       < not deLinesing to Wing, wait til Ting
      such shapes par importo A=A
      
    W&large_edges:
      W&edges:
       tests slepology:
         wakes on elvis/data change
         %countlife%aTool shows if its awake
         %differ goes round in circles as data loops
       only just able to complete with the current memory leak
       step 9 shows a bunch of yReal vanishing...
       
      toomuch:
       leading to '< %run/%differ' is desire to ease
         accepting changes, to exp or Te
       are both a little far away? would be nice
         but nearly done with tests until A=R round,
         which is likely to see them built more elegant
        - exp: later %doing to bring earlier accepted change
         see %differ. little far away.
        - Te: %doing brings T/$W back if modified
         also a little far away.
         get both diffing,
         the innermost T...%ball that was ==
          cloning that over itself, 
           pointed enough to apply to later %doing
            that wants to resume that state with more
          with a diff/accept stage
           temporarily projected into the %run by %Tool
         Lines|diff must find R per diffchunk
           Bunchology with the diffchunks != new
       will be:
       < linking T/$W -> W:PuTe or W:City:
          T/$W:edges.y.owner = $W:PuTe
           and $W:edges ~ $W:PuTe/$W:edges
          T/$W:City.y.owner = $W:City,
           and $W:edges is further inside, etc
             find refs for $W:City/*
          possibly need more %Lines gathering points
           or a function to gather them on demand
       < diffing T/$W:edges <-> W:PuTe/$W:edges,
         producing R in T/$W that have the change,
          and those that are merely transporting it
            common Lis sense
         so we know the minimum clone-over move to make,
           and what it should be cloning over
             < lv changes later
       < being a pathy clone-in %Tool to apply to later %doings
      
      random niceups
       %testrun=2 'get ahead of %run'
        until %step with boost
       %run: inventstep clones last step
       
       < %City is noisy, we want:
         %slan to turn miniature diff on the noise
          path to the Rthing, lines changed before next Rthing
      
       < %Cit shrinkgrouping known R props
        < group them by the I producing them
         < coder than dictionaries every property you use
       < %Cit visual cues for:
         R:Dough that %Someflav=C:Dough,
           for eg Rs&C = picture of self
          or C.y.Process = R
           things R has may link back to R with typing
       
       and A=R
       
       #   the curves of this paragraph looks great up close:
       #  this is what A:s-ions will look like
       # state changes
       # with casual causla {}
       # along space wiggle
       < %run:
         < using %differ to:
          < cursor various things to keep branchy,
            and hooks to make the test reset/pause properlike
              %differ becoming the time controller,
              %push%act merely a workflow in it
          < %doing brings T/$W back if modified
            probably into $doing/$W (nab%aTool loses %H)
            causing:
          < later %doing to bring earlier accepted change
            eg. PuTe arrangement before every step,
            has the story of elvis along it
            < must be applied as an lv change,
              sensitive to overwriting anything etc.
          < storing lv changes for consecutive %doings
       
    #c tuesdA:
    new/old ground:
    come back to A, they are like R:
      a&z (A.sc.z) are innards, like Rs&z
       only used in A:u
      a&N are innards anywhere wanting attention
       w:TuneTimeMachine gives A to 1s&N
       w:AndContinue: resumes all 3s&N
    so 1 can know what A it has in progress...
     AndContinue shall come again
      building W&Lis
      ...
    have R that can simply keep Ringing?
     < osc must get us back into whatever Ring:
       init: Ring@1 everything (Graze)
       then: resumes all Is&z
      the cores may fall asleep at random
       and may still percolate a Display anyway
       or lock the dome it was finishing from starting again
    see I and repackage:
       A:u makes .I
         mixed from many .I,
         got from /js/
         with async for update/check
       A.4:
        has loop bits, local culture
        .I:
         is everything, mixed up with StyleHut
         .i is all StyleHut,
          figure out what we need to keep
         never goes async, is trusted to be maintained,
         .w:
          has only this %namedcode thing
       A.5:
         looks neglected
         .w:
          is the spot, y&tw for $way
           they s&dige and s&now, G&way asyncs
           want to digwaypoll them, make sync
          all scooped up by Shovel, per test run
           which can make sync prior
    I.w is totally incidental,
    1s&minds[uname] = A c&N[4s&mind[t]]
     u deals with W via /js/, mixes onto Normal
    G&question (and other asyncers) should provide:
      ttl, ready=1 on callback
     to be useful for testing this stuff efficiently
    
     how it starts:
       html <script> get & eval from /thestart?step=n
        sends it A&loadI and Stylehut
         which includes HutNuts (begoin/jsung)
       G&begoin -> G&jsung,'NutMachine' cb -> G&Jinthe
         jsung looks like A:u but overwrites any A.I[t] = W:of it loads
         Jinthe sets up listeners,
          waylays NutGravy, defines function,
           waylays NutReady, more waylays.
     
     will start:
     < A&loadI a simple A:u@6 etc for basic mind mixing
       gather more mind, global functions, start loop
      should less async, and:
       be totally new ev/e hookup:
        Display:
         lose on.A
          use attr t/cv, attr sip if sJ
          and lookup to the sips of 4s somewhere global
          A.4 must always know about elvising
         lose jQuery,
          moving elements only as needed,
          text inputs not rebuilding every time
       
       ways to keep track of updates...
        make an islanding that can digwaypoll for:
          w change
          W change is regular /W/ with dige...
        know W that contain other W we are watching,
          digwaypoll for notify of W changing?
          could be wired into /W/
           not for the same socket?
         future /W/ storer is an elvising with a route,
          only then demands stringify to get across the net
    
    #c Wednesday
    water cactus
    very thinning impossibleness:
    < s&lv should come from the $main/A.4
       output modes are a T
    < frames
    
    W:Pass %ball web surfing
     < keep openness from last time - part of:
       provide autosaved W/T from last time
        these could be tracked separately, likely to be mostly garbage
     < testbedding
       < deps: %Gounce - ghost versioning
         knowing exactly each I it ran with
         making cert to help that Gounce get places in W:Lis
     < %play$%W more properly,
         see Be, can elegantly play out over time...
           minor %torun-ish manage what seems to be a situation
         Rsync %gee%ball late,
          checkout fully, same Ring (T.Rq?)
           see about when %gee hits 92 before children done..?
     
     mund%torun: de-lies fact piles
       various eg %Ghostways produce stuff
       they each become a Ghost unto further ...
       
       %JRom:
         encapsulates activity, Doming
         parts have error and (1|4)s&N plumbing
         < T plumbing
       
       %Ghostways:
         insures /way/$t via %mundws:digwaypoll
         < tractorbeam $Way into Ghost/Way,
           leaving the hoisting to $Way/5Iw up to mund
           this Ghosts best guess for those ways
           and providing data on dupover, etc.
           and helping lay out ref phylogen
         < G&ting/%ting forcing question/remote check
       
       # do last
       < one big %ball 
        < slep/io <-> what Reaction, batched
          eg /seek/ -> %do_Further()
         < via Sectiona, for an atime iterator of /seek/
        < getting that change to Rsync %balls,
       < even out of sync, to a degree
        < these ch() comments shall Tool down to
          fleeting speechbubbles, beneath the line
        < tree -> table mode as we cross the line,
          smoky action -> seeing office mode
       
       # do next!
       %ting:
         a search or put, any type
         < explains G&ting
         < ting (/G/Wway=/W/way)/$w (linked)
           makes them available through G&way
       
       tracks stored compilings, eg:
        /W/way/$w -> /W/Comp/$w
         or -> some collection of ways
           a g/(\w+)/(\d+) is such, looks like kv yaml
           is really lots of n $t  $s:... %of:way,%comment:...
       < bringing it back via G&ting /js/ or /way/
        < read our /W/Comp/$w_$dige.js
       
       primarily for:
        using %oph to build I
         < having Babz already done to blockquoted things
           by /wayz/, otherwise like /way/
         < including %Give deps, versions of way/W going into it
         < storage-specific metadata, see w:Writer
           could simply be in the local W:Office
           things to see changing out there to awake
       
       but also:
        translating old -> new ghosts:
          io.*, me.* into W with of:W but not W:of
           such are the new ghost objects
            as g/\w+/\d+ but with a 9,
            thence all of io is in one tidy packet,
            its source compiles out closer to you,
            its tests compile into Tests
          NutMachine probably wants conversion
            perl builds it atm,
             /js/j for acgts, etc
             using 1C&of=js instead of the n \'of:js'
       
       specifically:
        generating new I:
         to get an A clearly built from scratch
          into an initial A (or is it G?)
         and know exactly how to play %Give
         is:
         < bits of StyleHut,
         < most of NutMachine,
         < NutIns - G&ting
         < NutText - rebuild cm into Display
         + io and me at runtime....
         + J as me.J is
         + t that looks at me.$i, me.Ja.$w
        
        others involved:
     %Give - ghost versioning
       knowing exactly each I it ran with
       see W&Lis
     W&Lis
      magical W access syntax, via t
    
     #c t
     t:
      is thing finding
      t looks up A slope of places with things
      t looks in the dome building now...
       and for A-things around the place
        as A needs to find As to A
         t learning how to traverse every index
      # now:
      G.h(acgtt) does $t subroutine (I.i.h does I.i.$t)
       therein looking for $t becomes:
        G.t(acgt'i't) to avoid infinite h<->t loop
      # future
      B/T stack sensitive
        any call may be paused by a variety of reasoning
      G&lathe,3 Babz:
          G(A,C,T,'lathe',3)
      # or perhaps inlined non-inlined sub calls (no B-stack)
          G.i.lathe(A,C,G,T,3)
      # or totally inlined: ({}-scoped lexicals?)
          s&surface-- for 1..$s;
        this will be handy for generating G&throat
         from the dimensional joint protocols the I use
         these will need variants, as me&Ring is
      
      # lots of lang shall compile to lots of G(...)
      #   anywhere we thing stuff
      G = &ACTs{
          # like G.h
          $G = this;
          $args = arguments.slice(4);
          # simply looking for a function, closest A with it
          $i = is_string s ? G.t(acgt'i',s)
              # looking for something crazy,
              #   may even take args about this call
              #    and beyond, to find the right thing
              : G.t(acgts,[M]);
          B/T stacking {
          T.return = i(A,C,G,T, ... args)
          }
          return T.return
      }
      G.t = &acgtM{
          # like G.ting
          # matches whatever W/C/c in M
          #  sequences of them usu mean by z,
          #  array of arrays for resetting cursor
          # can also mean start doing a thing,
          #  nearby doming invites it to keep state
      }
      # further future:
      Babz realising parameters on things:
      G&$Self$Ne:za,$R$s$c:limin,%vang
      packs in the:
        G.t s={Self,Ne} c={R,s,c} 
         looking for (s) $Self and $Ne
          knowing the act (c) if that helps?
           or would it get confused with more itemology
            spose G could decide on the first being WHERE,
             the others being some extra into
             seems like something for doing subroutine calls remotely
        running it %vang mode with named arguments
         %vang could specify output form,
          a style to apply on something inside (G&tsc)
          some T-condition, error/async continance
          or name the object created
           t looks in the dome building now...
      T-condition,
       check it every B-stack (soon to be a lot of them
       error/async continance
    =cut
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #    C.y.R = R:C
    #   sprouts some sc to R:$gk or so
    # < determine, certify version of etc involved
    # we have a village's machinery for progress
    # < teleporting in: knowing you want such sleep pattern
    #    for vibrating values (oscillation)
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c Besk in options
    # < I, a W of qualities and how to use them
    $Be = me.Be = {};
    Be.scan = &acgtRs{
        $M = []; # q+
        each kt Be.sc {
            !hak(s.sc,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        each kt Be.y {
            !hak(s.y,k) and continue
            M.push({tatch:t,nk:'sc',gk:k})
        }
        return M
    };
    # makes D for q, thing attachment mode specifics
    #  D also gets how to act
    Be.cutch = &acgtRqc{
        $D = G&Cye,[q.tatch,5,c||{}];
        !D.t and throw "!t"
        # sc from matching
        q and ex(D.sc,q)
        # c from matched, the how
        Be[D.t] and ex(D.c,Be[D.t])
        # known properties on %ball%Be
        if (Ds&nk && Ds&gk) {
            # < Rc&X.Be.nk_gk for:   and Dc&b...
            $be = Rs&Be ||= {};
            be = be[Ds&nk] ||= {};
            be[Ds&gk] = D;
        }
        return D
    };
    
    # entrances:
    
    # 27%play + ^^%playsheet -> 
    Be.plays = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q )
            .map(D => Be&playit,R,s,D );
    };
    Be.playit = &acgtRsD{
        !Rs&ball and throw "What"
        Dc&play and Dc&play(A,C,G,T,R,s)
        else {
            # vaguely know it, not a c&play-er
            # < later check some Be used the %play
            # < thing's sc wants upgrading mode
            me&tsc,"!play:"
        }
    };
    
    # 3%ball sprawls to thing:
    Be.lums = &acgtRs{
        Be&scan,R,s
            .map(q => Be&cutch,R,q,{ohm:1} )
            .map(D => Be&lumit,R,s,D )
    };
    Be.lumit = &acgtRsD{
        # symbol blocks the way
        $n =
        n $D.t  $s:Ds&gk %fs:14,hs:966
        Dc&symbol and nc&s = Dc&symbol
        nc&s.length > 5 and Dc&symbolsize ||= -5
        Dc&symbolsize and ns&fs += Dc&symbolsize
        
        # c&nofurther - stop adding R under this one
        #  recursion control
        Dc&exRc and ex(R.c,Dc&exRc);
        
        Dc&BeX and Be&BeX,R,s,D
        
        # %play things tend to hide/represent in-%balls
        Dc&play and Dc&hbb ||= 1
        # otherwise it costs 1 boost
        # < consumable if Tie remembers
        !Dc&ohm || Rs&boost > 0 and 'open'
        else {
            # tend to hide every R inside...
            !Dc&hbb and Rs&nofurtherDisplay = 1
            # very high level view of what else scans interesting
            ss&z &&
            n withz  s:z %fs:14,hs:966
        }
        Dc&hbb and Rs&hideballsballs = 1
        # do more display?
        # look up for a qua ac?
    };
    
    #c Bersons
    # known properties may ... (%ball%play)
    Be.sc = {};
    Be.y = {};
    
    # s&H
    # stored object
    # < boostrap from H:1
    # < know exactly where it is (/G/*)
    # < know history of it across history of s
    # < history of s vs. history of R, getbetween.
    #   values exist somewhere fractionable in Domes,
    #   pinned down every so often from various angles
    #    and resolutions yada
    #   simply have to play lv in reverse, watching path
    #    lv must play from an el<3
    #    to know it has everything in the situ,
    #     which could be localised to part of the path
    #     < lv requests should serve grep into paths
    #       thence almost-Lines wants to end up in a database
    Be.sc.H = 'sH';
    
    # s&quiet
    # eg a Js&Te doing usual work
    Be.sc.quiet = 'squiet';
    Be.squiet = {symbol:'q'};
    
    # y&lv
    #  boundary to a done thing that will join to us
    #  eg. your %Lines hoists the s.y.lv as itself
    Be.y.lv = 'ylv';
    Be.ylv = {symbolsize:-2,exRc:{nofurther:1}};
    
    # s&testrun
    # does a test via W:Co
    # < elvise it
    Be.sc.testrun = 'stestrun';
    Be.stestrun = {play:&acgtRs{
        $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
        Rs&Te && Rs&Te.sc.almost and ls&almost = 1
        me&introqua,l,'boost:2','@1'
    }};
    
    # s&torun
    # does an Rz kinda thing
    # saving input/output like %push,
    #  similar to s&testrun but less remote
    Be.sc.torun = 'storun';
    Be.storun = {play:&acgtRs{
        $k = ss&torun;
        k == '1' and k = s.t
        # as a %Reis, instant to the enclosing Ring
        $c = {};
        c.task = 'rovo';
        c.t = s.t;
        c[k] = 1;
        $r = me&Reis,R,0,0,c;
        ac(R,'unplaycb', &{
            each in rs&unDoming {
                n()
            }
        });
    }};
    
    # s&W
    # < opens that Wormhole in the nearest %gee
    # < located around here:
    #    i ^^%gee/$W y o ^^/G/$W
    #     then %gee late Rsync,
    #      so openness can occur in this ev'd Ring
    #   this would be the stately G&ting
    #    5 could know all the W we use
    #   iter `dig`
    #   < hostinfo
    # < as another J,
    #   managing pause/sleep modes of them
    Be.sc.W = 'sW';
    Be.sW = {play:&acgtRs{
        # becomes signpost leading in
        $l = me.cbu(R,'gee');
        ls&openness.push(R);
    }};
    
    # s&J
    # probably a J:1,
    # make W from the elvisory
    Be.sc.J = 'sJ';
    Be.sJ = {play:&acgtRs{
        ss&J != '1' and throw "nonJ=1"
        # feeds with e
        me&Ravelvis,R,s.t;
        # < unDoming
        ac(R,'unplaycb', &{ me&Ravelvis,R,s.t,9 })
    }};
    
    #c BeGhost
    # R%ball r%fix
    Be.fixit = &acgtrsD{
        $R = ry&up;
        !rs&fix and throw "What"
        !Rs&ball and throw "What"
        # apply styles to r%fix
        $st = 'inputmode viewvia'.split(' ');
        each in st {
            !D.c[n] and continue
            r.sc[n] = D.c[n];
        }
        # < symbol's styles fitting into %fix n t
        #     might be too complex to read
        #       sprout as necessary
        if (Dc&play) {
            # can %play sometimes (via the %ball)
            # likely to show %fix t/s?
            s == '1' and me&tsc,'onething','=1'
        }
    };
    
    # s&of
    # code, generally compiles
    Be.sc.of = 'sof';
    # sets up openable codon on s%fix
    Be.sof = {BeX:{
        's%fix':{inputmode:2,viewvia:'size'}
    }};
    # set properties of children that don't exist yet
    Be.BeX = &acgtRsD{
        each kc Dc&BeX {
            $name = D.t+' '+k;
            k = k.split('%');
            $t = k[0];
            k = k[1];
            # cousin of R.c.X/V
            $X = Rs&BeX ||= {};
            $tk = X.xtk ||= {};
            tk[t] ||= {};
            $oX = tk[t][k] ||= {};
            # where .x=[more R.t],.xtk=[more nk/gk]
            # and non-path things apply to the arriving R
            $sc = oX.exRsc ||= {};
            # rogue generation of D
            # < use cutch, make complicated Be[t]s
            sc.BeD = G&Cye,[name,5,c];
        }
    };
    # X.xtk = R.t, R.sc gk
    Be.BeXarrive = &acgtRsl{
        $p = Ry&up;
        $X = ps&BeX;
        !X and return
        # walk a path of x to X
        $x = X.xtk;
        each in l {
            x = x[n];
            !x and return
        }
        Rs&BeX and throw "Already at RsBeX"
        Rs&BeX = x;
        # check in
        x.z ||= [];
        x.z.indexOf(R) < 0 and x.z.push(R)
        # apply
        x.exRsc and ex(R.sc,x.exRsc);
    }
    
    
    
    
    
    
    
    
    #
    
    #c Beepingness/gc
    # %play engaged tasks
    me.Beepingness = &acgtR{ return [
    =pod
    garbec%torun: garbage collect localStorage
     , regex for %W and %H
      < know %parent, ship everything off to a git
       as a %torun
         with an %H/differer for the current state of it
         but just be an R, opening bits of net puzzle
         posit deletables, do one last grep for their %H
       good for up to 5MB?
       %H:
         any non-W chunk, storage t=dige -> string from Lines
         must %Lines encode H:... for regex
         < Lines could have many sc, keep first clean looking
       < %H may all hoist to the top, as in w:Writer/Gversioning
         would look like %Has:0294u390;34ui902d;345u209u3;3u8490j
    =cut
        # boost <0 to rescan. >0 to delete
        # < bright future of the backroom
        # < for the enclosing %gee
        ['garbec','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            
            #Rs&somehash = window.fogive ||= ex({},localStorage);
            Rs&somehash ||= localStorage;
            
            (Rs&boost||0) < 0 and 'rescan'
            else
            me&rollbs,R,'figure' and return
            
            n Pass  R %garbect,viaW
        },'ift,D'],
        ['garbect','3',&acgtRs{
            Rs&noDisplay = 1;
            me&tsc,'nothing';
            $k = R.t;
            $g = me.cbu(R,'garbec');
            # < use $k=Rc&s and Rc&refs to dedup
            $te = gs&garbect_t ||= {};
            te[k] and return
            te[k] = R;
            # order importo par stat hoist
            ac(g,'garbectN',R);
            # read
            $v = gs&somehash[k];
            !v and return Rs&err = "No "+k
            
            $l = v.split("\n");
            each in l {
                # < using Wm[3]: where the match started
                #   and showing the path through this place
                #   %garbect are places/storage points/gravity wells
                $Wm = n.match(/(H):(\w+)\b/);
                if (Wm) {
                    $H = Wm[2];
                    n $H  R %garbect
                    continue
                }
                # the s&W usually 1, encodes to just 'W'
                #  otherwise it's a different W this one must accompany
                #  eg %of is required (eventually) to wake up code
                $Wm = n.match(/^\s+(\w+)\t.*\t\bW(?::(.+))?\b[^\t]*$/);
                if (Wm) {
                    $t = Wm[1];
                    Wm[2] and continue
                    # ^ of W:lobbek's %oph'ing, We thing s%W:oph/
                    n $t  R %garbect,viaW
                }
            }
        },'ift,D'],
        ['garbectN','6',&acgtRs{
            $te = Rs&garbect_t;
            Rs&figure and throw "garbectN + figure"
            $d = Rs&figure = {};
            d.to = 0;
            d.total = 0;
            d.disco = [];
            d.discotal = 0;
            each kv localStorage {
                d.to++;
                d.total += v.length;
                te[k] and continue
                d.disco.push(k);
                d.discotal += v.length;
            }
            $N = Rs&garbectN.slice().reverse();
            # < size of Ws sans in-Ws?
            each ir N {
                rs&err and me&tsc,"err",r.t+"_err:"+rs&err
            }
        },'ift,D'],
        ['garbec','7',&acgtRs{
            $d = Rs&figure;
            !d and throw "!figure"
            
            each kv d {
                typeof v == 'object' and v = v.length
                n t  $s:k %hs:999
                typeof v == 'number' && v > 1000 and v = G&sca,v*0.000001 +'mb'
                n s  $s:v
                n sp  s:\n
            }
            
            # delete the disconnected
            # < check it's a %H-type key,
            #    deleting W should be harder,
            #    but we can't really tell...
            # < know what hist
            if ((Rs&boost||0) > 0) {
                delete Rs&figure
                each ik d.disco {
                    # check they exist
                    !Rs&somehash[k] and throw "to delete, no: "+k
                }
                each ik d.disco {
                    delete Rs&somehash[k]
                }
            }
            delete Rs&Te.sc.boost;
        },'ift,D'],
    #c mund ravelabhion straight curvy cellvey
    # have wanting uphill showing where come
    # manage more %torun/things they do
    # set off an experiential perspective:
    # A locality of thing availability!
        ['mund','3',&acgtRs{
            Rs&rowish = 1;
            s&bo = '7px dotted green';
            s&hue = -70;
            s&br = 1;
            Rs&unDoming = [];
            
            me&tsc,"mund";
            
            $fore =
            me&Reis,R,{t:'iN',foreigN:1,task:'rovo'};
            
            $erN = me&rollbs,R,'erN',[];
            
            # catch errors per dome of resilience
            # provide headings with pausibles,
            #  errors and s&N coming out
            #  T.* changes and chatter
            # < %Reis with error handlers,
            #   pausible
            # < er + Ring cursor
            Rc&Rom = &ptc{
                !c and c = t
                typeof c == 'string' and c = {t:c}; c[c.t] = 1
                !hak(c,'t') and c.t = t
                t = c.t;
                
                # insist on %JRom enclosure
                !ps&JRom and c = {t:t,JRom:c}
                
                c.task ||= 'rovo';
                
                try {
                    $r = me&Re,p,c;
                    me&Ring,r;
                }
                catch (er) {
                    # can it sleep?
                    $b = rc&b;
                    if (b && by&Display) {
                        # keep last display
                        # < warn shadow?
                        rs&sleeping = 'async';
                        me&Display,r;
                    }
                    $async = (er.message || er).match(/^async/);
                    # doming marked through as async?
                    me&tsc,'explosion',null,'G';
                    ~Explo: r.t, er.message
                    $n = G&Cye,[Ac&sip,'',{s:er.message,er:er}];
                    ns&now = G&time;
                    ns&A = A;
                    ns&B = Gc&B;
                    ns&p = p;
                    ns&R = r;
                    # to nearest dome with room to think about it
                    $JR = me.cbu(p,'erN');
                    $erN = JRs&erN;
                    erN.push(n);
                }
                return r
            };
            
            Rc&Rom(R,'munding');
            
            me&Reis,R,{t:'oN',foreigN:1,task:'rovo'};
            
        },'ift,D'],
        
        #c safe/pausible R,
        #  handled errors and s&N
        # a Dome, holding things to resume
        ['JRom','4',&acgtRs{
            Rs&rowish = 1;
            s&bo = '2px dotted green';
            s&br = 0.4;
            me&domesticate,R;
            
            # 2 self from 
            $j = me.cbu(R,'JRomt') || R;
            $mt = me&rollbs,j,'JRomt',{};
            $b = mt[R.t];
            $D = mt[R.t] = G&Cye,[R.t,1,{},{}];
            b and Dc&b = b
            Ds&amongst = b && bs&amongst || [];
            Ds&amongst.unshift(D);
            Ds&count = (b && bs&count || 0) + 1;
            D.t = "D."+Ds&count;
            
            # 4 pic for before/after
            $emto = {sN1:1s&N,sn4:4s&N};
            each kv emto {
                $har = Ds&watchar ||= {};
                har[k] = v.slice();
            }
            
            # 5 partition explosion collection
            $erN = Rs&erN = [];
            
            # 6 do innard
            $c = Rs&JRom;
            
            
            $r = Rc&Rom(R,'Rom',c);
            
            # 7
            # s&N
            each kv emto {
                $har = Ds&watchar ||= {};
                $was = har[k];
                $outi = [];
                $N = [];
                each in v {
                    was.includes(n) and continue
                    outi.push(i);
                    N.push(n);
                }
                !N.length and delete har[k]; continue
                # take, for nearest JRom only
                outi.reverse().map(i => v.splice(i,1));
                har[k] = N;
            }
            !hak(Ds&watchar) and delete Ds&watchar
            erN.length and Ds&erN = erN;
            
            # all but topmost should tend to sleep...
            Rc&Rom(R,'Domeds',{s:Ds&amongst,NzR:'Domed',glamp:12});
            #n $D.t  $s:D,R %Domed
            
            # < A-ing slowly: order then consciousness
            #   for summary up the top
            Rs&down.reverse();
        },'ift,D'],
        #c visually Jing R
        ['Domed','4',&acgtRs{
            $p = Ry&up;
            # p%NzR cs=[...$D...]
            $D = s;
            s&bo = '3px solid blue';
            s&br = 1;
            $t = me&domesticate,R;
            Rs&sym = "";
            
            # only latest or Te'd open
            if (Rs&glampi != null &&
                Rs&glampi > 0 && !Rs&Te.c) {
                $b = Rc&b;
                $sym = !b ? "-" : bs&sym || "?";
                tc&s = Rs&sym = sym;
                return
            }
            # boost<0 and delete (if Te.d)
            if ((Rs&boost||0) < 0) {
                $Di = pc&s.indexOf(D);
                Di < 0 and throw "Di"
                pc&s.splice(Di,1);
                n deleted  s:deleted %fs:6,hs:594
                return
            }
            # Te'd stops delete
            Rs&Te.c and Rs&keeper = 1; me&tsc,'keeper','k','6';
            
            if (Ds&watchar) {
                # As&N we noticed grow
                Rs&sym += '^'
                each kv Ds&watchar {
                    n $k  $s:v,R %NzR:Attend
                }
            }
            
            # errors we caught!!!
            if (Ds&erN) {
                Rs&sym += '!';
                n Errors  $s:Ds&erN,R %NzR:Error
            }
            Rs&sym ||= '.'
        },'ift,D'],
        ['Domed','7',&acgtRs{
            
        },'ift,D'],
        
        ['Attend','4',&acgtRs{
            $Y = s;
            
            $nth = Y.t == 'n' && Y.y.cv == 0.13;
            nth && Yc&s.t == 'Pass' and Rs&nthirteen = 1
            !Rs&nthirteen and Rs&keeper = 1
            
            n Y  $self:Y %R:Cit
        },'ift,D'],

        ['Error','4',&acgtRs{
            Rs&rowish = 1;
            $skull = '‚ò†';
            me&tsc,'error',skull,'D';
            me&tsc,'message',sc&s,'d';
            n er  $self:s %R:Cit
            
        },'ift,D'],
        

        
        #c NzR, expirez
        # spread Rc&s=N[n+] to many rc&s=n
        #  they have a type that helps NzR or the thing above it
        #  do expirez
        ['NzR','4',&acgtRs{
            Rs&dubquiet = 1;
            # trims to 30s timeframe, not %keepers
            Rs&glamp and Rs&expirez = 30
            $t = me&domesticate,R;
            
            $p = Ry&up;
            $outi = [];
            each iY s {
                $t = Y.y == Y ? Yc&sip : Y.t;
                $z =
                n $t  $s:Y,R
                z.sc[Rs&NzR] = 1;
                # inners like a log tail
                Rs&glamp and zs&glampi = i;
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
            
            !z and ts&fs = 7
            0 < i and Rs&rowish =  1
        },'ift,D'],
        
        # expiry of care about old A
        # < kind of time we can pause
        # R(cs=[n+]) with r(cs=n)+ self-cleaning
        ['expirez','7',&acgtRs{
            $outi = [];
            each in s {
                $r = Rs&z && Rs&z.filter(r=>rc&s==n)[0];
                !r and continue
                # are %keepers
                rs&keeper and continue
                
                # give %began
                rs&began = me&rollbs,r,'began' || G&time;
                $much = G&time,rs&began;
                
                $out = much - Rs&expirez;
                if (out < 0) {
                    if (Rs&glamp && i >= Rs&glamp) {
                        out = Rs&expirez;
                    }
                    else {
                        continue
                    }
                }
                # < relative scales into styles
                $C = rs&C;
                out < Rs&expirez/4 and s&fs = 8; s&sat = 0.4
                out < Rs&expirez/3 and s&fs = 6; s&sat = 0.2
                out < Rs&expirez/2 and continue
                
                $Yi = s.indexOf(n);
                Yi < 0 and me&tsc,'nofindY'
                else { outi.push(Yi) }
            }
            outi.reverse().map(Yi => s.splice(Yi,1));
        },'ift,D'],
        
    #c mundine, be its own 4 plot
        ['munding','3',&acgtRs{
            # these'll have any z?
            # J8 must check its Jtv for their 1s&N
             
            # w state can be trusted if listened for:
            #   
            
            # lay out the things that matter:
            #  A.4.sc.mind     /js/ ?
            # roll realities as change needed
            #  e believers
            # be %gee-like, belief relay
            $n =
            n nodigway  s:‚óè %fs:22,medo:modeen,togla
            # turn off the J:digwaypoll
            me&rollbs,R,'nodigway',1;
            !Rs&nodigway and ns&fs = 11
            # < merge to Tool
            Rs&modeen = &acgtr{
                T.wake = 1;
                if (rs&togla) {
                    R.sc[r.t] = 4c&nodigway = R.sc[r.t] ? 0 : 1
                }
                else {
                    throw "What? "+r.t
                }
            };
            4c&nodigway = Rs&nodigway;
            ac(R,'unDoming',&{ 4c&nodigway =  0 });
            
            # w can be trusted if digwaypoll
            n digwaypoll  R %mundws,Ghocoline,tinyLines
            
            n ifd  R %Ghostway
            # < ^ having its own compile,
            #   your ting w/* perspective may incorporate it
            #   then another ing happens?
            
            # G&way compiled:
            n wats  $s:A.5.I.w,R %Idoubleyou,ball,childy:tw
            
            me&introqua,[R,'ifd','Ghost','apparently'],{boost:-1},'@1';
            me&introqua,[R,'ifd','Ghost','est'],{boost:-1},'@1';
            me&introqua,[R,'wats'],{boost:-1},'@1';
            
            Rc&Rom(R,{t:'NutMachine',ting:'w'});
            
            n A4smind  $self:A.4.sc.mind %R:Cit
            # < /W/ReI/* as a $w space
            #   have to keep what's there indexed
            #   Ring similarly as updater or editor
            
            # making a complete A.4.I shouldn't be too far away
            
            
            # end up with typed storage, Lis action
        },'ift,D'],
        
        # 4 handlers/types are in place
        # w are from:
        #  the digway+/way/ (trad)
        #  the /w/ (unBabz'd way) (new)
        #    this dige might match the one from digway?
        #  the /wayz/ (Babz usual blockquotes)
        #    for use in We
        # use diges that don't match to roll attention at w
        # can then download the w and see its true s&dige
        
        #c ting gets domethings
        # push/pull of C living across the boundary
        ['ting','3',&acgtRs{
            Rs&rowish = 1;
            $t = Rs&Live = G&ting,Rs&ting,R.t;
        },'ift,D'],
        
        # at LVing avail
        ['ting','4',&acgtRs{
            Rs&rowish = 1;
            
            
            Rs&Live &&
            n Live  $self:Rs&Live,R %Cit
        },'ift,D'],
        #c mundws holds an A:ws
        # < push/pull of C living across the boundary
        ['mundws','3',&acgtRs{
            Rs&rowish = 1;
            # < these ways to assume arguments want fibre
            $ws = me&rollbs,R,'Sock';
            ws = Rs&Sock = me&ws,R.t,ws;
            $WS = wsc&ws;
        },'ift,D'],
        
        # at LVing avail
        ['mundws','4',&acgtRs{
            Rs&rowish = 1;
            
            # current state
            $ws = Rs&Sock;
            
            # /path
            me&tsc,'mundws','ws:','b';
            me&tsc,'path',wsc&s
            me&tsc,'state',wss&state,'6';
            
            Rs&Lving &&
            n Lving  $self:Rs&Lving,R %Cit
        },'ift,D'],
        #c Ghostway - asks for way notifies, gets them
        # provides ein/out/ope
        #   by way of %Again/%tinyscLines
        #   for C sloshing in or out
        # knows how to talk ws:s/digwaypoll
        ['Ghostway','33',&acgtRs{
            $p = Ry&up;
            # place to talk
            $S = Rs&Upstream = ps&z[ps&z.indexOf(R)-1];
            $ch = Rs&chatter = Ss&chatter;
            # insured memories via %Again
            $g = Ss&Again = ps&z[ps&z.indexOf(R)+1];
            $Way = gc&s;
            
            # the 'here', a join
            $Ghost = Rs&perc = me&rollbsc,R,'Ghost';
            n Ghost  $s:Ghost,R %ball,childy
            
            # reads t + dige
            Ss&tinyscLines = 'dige';
            # allow dige at different lengths >= 8
            Ss&mightsctrunc = 'dige';
            # pile from both ends over time
            i s:{ Ss&Opinion=C } $Ghost/apparently:s
            # and changes go further
            i s:{ Ss&Further=C } $Ghost/seek:s
            
            # on change, queue:
            Ss&do_Further = &{
                # /apparently/* changing creates /seek/*
                # to look it up since that dige changed
                o $Ghost/seek/*
                $seeking = ays&s;
                !seeking and return
                Rs&seeking = seeking.slice();
                each is seeking {
                    o $Way/#$s
                    !ya and ch("didnt know",[s.t])
                    Rs&seeketh(s,ya)
                }
                return
            };
            
            # < ting many asks per question
            #   so many seekeths make one seekend
            #   is a keepalive for the first question
            Rs&seeketh = &s,was{
                ch("seeking...",[s.t]);
                #$w = G&ting,'w',s.t;
                #   currently takes old-G&t shortcut,
                #    returns way without checking ttl
                $cb = &t,ar,w{
                    Rs&seekend(w,s,was);
                };
                # noop='nottl' so it renews
                G&way,s.t,{},cb,'nottl';
            };
            
            # thing is got
            Rs&seekend = &w,s,was{
                Ss&sleep_Further &&
                    Ss&sleep_Further(w,s);
                
                $com = [w.t];
                !was and com.push("@1")
                else
                if (wass&dige == ws&dige) {
                    return ch("Seeksame",[w.t])
                }
                ch("Seekback",com);
                # while changing!!
                i $Ghost/ing/$w
                # once after the batch (ish)
                $si = Rs&seeking.indexOf(s);
                si >= 0 and Rs&seeking.slice(si,1);
                # wait up to 30ms if more might seekend
                $delay = Rs&seeking.length ? 30 : 0;
                # joining seekends near in time
                $cb = me&sccb,R,'seekingdone',Rs&do_ing;
                delay ? G&yl,delay,cb
                    : cb();
            };
            
            #c 7 thing is fine, either way
            Ss&sleep_Further = &ws{
                if (!w) {
                    # from eout that sleeps
                    o $Way/#$s
                    w = ya;
                    !w and return ch("didn't know sleeping",[s.t])
                }
                # Iw has $w, make permanent!
                ws&now = G&time + 3600;

                i $Ghost/seek/-#$s
                # < should know time is up for this ground,
                #   get it attached via Tsome
                #n seen  $self:w %Cit
                # permanent
                i $Ghost/est/$w
            };
            
            Rs&do_ing = &{
                # things changing, code to redo!
                o $Ghost/ing/*
                $inging = ays&s;
                # < otherwise G&ting evals?
                $doers = 'Soogle Packle Coffle Foogla'.split(' ');
                $doerd = [];
                each iw inging {
                    if (doers.indexOf(w.t) >= 0) {
                        # me.codes containers should run
                        ch("Ghostwayer",[w.t]);
                        G&way,w.t;
                        doerd.push(w);
                    }
                    else {
                        ch("Ghostway",['',w.t]);
                    }
                    i $Ghost/ing/-$w
                    # then anything dependent on the way
                    #  eg I, J...
                    #  diff way to wake a .Ja. is not impossible
                }
                # and drop Ring's cache of me I, which
                # may have re generated for a new $w
                #   but the old $me (just sprang from $w ^)
                each iw doerd {
                    delete ws&makesI;
                    delete ws&makesIw;
                }
            };
            
            # keep permanent
            # the only in-time operation
            # < scan for not in Iw
            # < dige sleep on init may not get things here:
            o $Ghost/est/*
            each iw ays&s {
                ws&now = G&time + 3600;
            }
            
            # casual
            Ss&do_Further() || Rs&do_ing();
        },'ift,D'],
        
        #c %Again (C/%ball source) -> %ein()
        # e inits some state (usually)
        ['Again','35',&acgtRs{
            !Rs&Again.sc.ball and throw "Again!ball"
            Rs&Lvact = &{
                $N = me&ioty,Rs&Again,'%ball';
                each in N {
                    N.indexOf(n) < i and ~DupeyzLvact: n.t
                    Rs&ein(n)
                }
            };
            # el=2 everything
            Rs&eope = &{ Rs&Lvact() };
            # el=2 changing
            Rs&Lving and Rs&Lvact()
        },'ift,D'],
        # %ein() C only t and certain sc
        # %eout() C into %Opinion
        #   and into %Further if certain sc change
        ['tinyscLines','34',&acgtRs{
            # Lving: may not make it through send() if same
            Rs&uniqsend = 1;
            # a t/dige only variety of tinyLines encoding:
            Rs&tinyLines = 1;
            
            # only certain sc taken
            $only = Rs&tinyscLines;
            only = only && only != '1' && only.split(',')
            Rs&takeonlysc = &s{
                !only and return ex({},s.sc)
                $sc = {};
                each ik only {
                    s.sc[k] == null and continue
                    sc[k] = s.sc[k]
                }
                return sc
            };
            
            # their Opinion arriving
            Rs&hasonlysc = &sl{
                $ks = only || haks(s.sc);
                $ok = 1;
                # checks how different it is
                each ik ks {
                    $was = s.sc[k];
                    $is = l.sc[k];
                    $com = [l.t, k, was, '->', is];
                    !is and ch('nullsc',com); return -1
                    
                    was != is and ok = 0
                    
                    #!ok and debugger;
                    ok ||= Rs&mightsctrunc == k &&
                        was && was.includes(is);
                    !ok && was and ch('scut',com)
                }
                # applies!
                each kv l.sc {
                    s.sc[k] = v
                }
                return ok
            };
            
            $ch = Rs&chatter;
            Rs&ein = &n{
                !ns&ball and throw "!ball: "+ki(n)
                $c = {}; # L%send[D.sc
                $s = nc&s;
                $C = G&Cye,[s.t,1,{},Rs&takeonlysc(s)];
                # Opinion is one piled from both ends
                #   so it can come back same the first time
                i Rs&Opinion/$C
                c.toLines = C.t;
                if (haks(C.sc).length) {
                    c.toLines += '%'+G&depeel,C.sc
                }
                Rs&send(n,c);
            };
            Rs&eout = &l{
                !Rs&Opinion and throw "give Opinion"
                !Rs&Further and throw "give Further"
                
                # their opinion is arriving
                i Rs&Opinion/#$l:s
                $ok = Rs&hasonlysc(ya,l);
                ok < 0 and 'said error'
                elsif (ok) {
                    ch('sleep',['way',l.t]);
                    Rs&sleep_Further &&
                        Rs&sleep_Further(null,l)
                }
                else {
                    # changes go %Further once per receive
                    ch((!ya?'new':'wake'),['way',l.t])
                    i Rs&Further/$ya
                    Rs&do_Further &&
                        ac(R,'Finally',Rs&do_Further)
                }
            };
        },'ift,D'],
        #c Ghocoline - C<->string envelope
        # provides %receive(), wraps %send()
        #   en/decoding some string format
        # Lving @31 logs a %send/receive[D+]
        # see 'Lving' around here, it may also:
        # < Ls&z clone C we sent them?
        #     would allow better %resumable
        #     %uniqsend dedupes for now
        # the @34 do push/pull C across a boundary stuff
        # the @32 is C<->string:
        # all Lines =~ /^[ \w"]/
        #  so there's room for some protocol in there:
        # < Rs&resumable - do you remember? rolls state:
        #   - roll Ls&send if %uniqsend, dedupes
        #   - know Ls&z and lv-sense to your app
        #   app must sleep while we try to:
        #   negotiate what they know with el=7
        #     might know our/previous Ls&sent_dige
        #       retransmit Ls&send
        #     or stuff on the ground
        #       exploratory W nature,
        #       eg check state of everything in Toys:
        #         Toys el:7%dige:358i0f
        #       may not include %dige on request,
        #         but then the server could pre-empt our:
        #           what has what become,
        #            and what can be patched
        # Rs&responsey - expect one receive per send
        #   link them, ordering if many backends
        #   responses not in requested order
        #   < slowing/Aing out time to understand message
        ['Ghocoline','32',&acgtRs{
            Rs&receive = &sD{
                typeof s != 'string' and throw "receive !string"
                $ch = Rs&chatter;
                ch and ch('receive',[ki(s,3)])
                
                Rs&tinyLines and Rs&someLines ||= 1
                Rs&someLines and Rs&contLines ||= 1
                
                if (Rs&contLines) {
                    # can know how to nest another protocol
                    if (!s.match(/[ \w"]/)) {
                        # tricks with Lving"
                        throw "strange"
                    }
                    elsif (s.match(/^ /)) {
                        # Lving -> last message's cursor
                        throw "floating start"
                    }
                }
                
                # string tricks
                $l = [s];
                if (Rs&someLines) {
                    # splits lines, batch of something
                    # < by next Line d=0?
                    l = s.split("\n");
                    l.slice(-1)[0] == '' and l.pop()
                }
                
                # parsed
                $z = l.slice();
                if (Rs&tinyLines) {
                    # parse Ghost%dige:4827848
                    each is l {
                        $s = s.split('%');
                        s [0].split("\t").length > 1 and throw "comp"
                        z[i] = G&Cye,[s[0],'',{},s[1]]
                    }
                }
                elsif (Rs&contLines) {
                    throw "readLines wanted"
                    # make R to deLines then ein?
                    #$N = me&readLines,s;
                }
                
                # iterated
                Rs&esout and Rs&esout(z)
                else
                Rs&eout and z.map(s => Rs&eout(s,z))
                
                $Fin = delete Rs&Finally;
                Fin && Fin.map(cb=>cb());
            };
            
            $send = Rs&send;
            !send and throw "no Ghocoline proxy send()"
            Rs&send = &sc{
                $string = s;
                # the Lving%send/$D .sc
                c ||= {};
                if (isC(s)) {
                    if (s.y.R == s) {
                        if (ss&ball && ss&toLines || c.toLines) {
                            string = c.toLines || ss&toLines;
                            c.origin = s;
                            $L = Rs&Lving;
                            # < Lving: repeat string/diff/compression
                            #   smelting toLines' intel,
                            #   what to do with lots of el:8 etc.
                            if (Rs&uniqsend && Ls&send) {
                                $i = Ls&send.length-1;
                                while (Ls&send[i]) {
                                    $D = Ls&send[i--];
                                    !Ds&origin and continue
                                    if (Ds&origin != s) {
                                        # by .t?
                                        Ds&origin.t != s.t and continue
                                    }
                                    Dc&s == string and return
                                }
                            }
                        }
                        else {
                            ss&ball and throw "send R%ball!%toLines"
                            throw "send R!%ball"
                        }
                    }
                    else {
                        throw "send C !R"
                    }
                }
                else
                typeof s == 'object' and throw "obj->string"
                
                $ch = Rs&chatter;
                ch and ch('send',[ki(string,3)])
                send(string,c);
            };
            Rs&open = &{
                $L = Rs&Lving;
                L && Lc&b && Rs&resumable and 'Lvism el=7 for %sent_dige'
                Rs&eope and Rs&eope()
            };
        },'ift,D'],
        #c A%Sock <-> A:ws
        # at both ends of the deal
        # provides Rs&Lving and Rs&send()
        # uses Rs&open() and Rs&receive()
        ['Sock','31',&acgtRs{
            $ws = Rs&Sock;
            $WS = wsc&ws;
            !WS and throw "Sock"
            # when R el=9
            me.cbuac(R,'unDoming',&{
                WS.close(1000,'lum')
            });
            $X = window.websocks ||= {};
            X[wsc&s] = ws;
            $sockdup = &{
                X[wsc&s] == ws and return
                WS.close(1000,'lum');
                return 1
            };
            
            # our A:ws.c hooks
            # this should A:session
            #   reflecting a scene across it
            #   they might hold objects for us,
            #     as we talk to them
            #   or show objects we talk about
            $L = me&rollbs,R,'Lving';
            
            # try leak chatter
            $ch = Rs&chatter = &t,ev{
                # < io-param-like + styles of message with object in
                $l = ev.constructor == Array ?
                    [wsc&s, ... ev] :
                    [wsc&s,
                    wsc&deter('code',ev.code),
                    ev.reason,
                ];
                each in l {
                    l[i] = '>'+(3+(i*2))+' '+(n||'')
                }
                G&c:'>1 '+t,l
            };
            
            # L logs a %send/receive[D+]
            $roll = &tsoc{
                $L = Rs&Lving;
                !L and throw "ws:L:send!open"
                
                # accumulating dige
                $digek = t+'_dige';
                L.sc[digek] = dig((L.sc[digek]||'')+s);
                
                # point in time log
                c ||= {};
                c.now = G&time;
                # opposite direction's count
                # last in when this went out, etc.
                1 && o and c[o] = L.sc[o+"_i"]
                # tsc causes n ... deep within out of time
                $D = me&tsc,t,s,c;
                ac(L,t, D );
                
                # count
                $ik = t+'_i';
                L.sc[ik] ||= 0;
                L.sc[ik]++;
                
                return D
            };
            
            wsc&open = &{
                L = me&rollbsc,R,'Lving','b,increment';
                Rs&open();
            };
            Rs&send = wsc&send = &sc{
                $D = roll('send',s,'receive',c);
                # never fails?
                WS.send(s);
            };
            wsc&receive = &sc{
                sockdup() and return
                $D = roll('receive',s,'send',c);
                Rs&receive(s,D);
            };
            
            # put in A:ws, when G&c redone...
            
            wsc&proto = {
              state: {
                0:'connecting',
                1:'open',
                2:'closing',
                3:'closed',
              },
              code: {
                1000:'closing',
                1006:'close',
                1001:'leaving',
                1009:'toobig',
                1011:'500',
              },
            };
            wsc&deter = &tk{
                k == null and return ''
                return wsc&proto[t][k] || t+'?'+k
            };
            
            wss&state = wsc&deter('state',WS.readyState);
            
            # WebSocket hooks
            
            WS.onopen = &ev,{
                WS != wsc&ws and debugger;
                WS != wsc&ws and return ch('sockdupe', ev);
                ch('open', ev);
                wsc&open and wsc&open()
            };
            WS.onclose = &ev,{
              ch(ev.wasClean ? 'closing' : 'close', ev)
            };
            WS.onerror = &ev,{
              ch(ev.wasClean ? 'err' : 'errs', ev)
            };
            
        },'ift,D'],
    ] };
    

