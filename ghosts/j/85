
Tips: | # test your ball of knowing
    my $t = Rw Towering Ang _ Dimmer Zpace
        || return;
    # as an out of bander...
    # makes points to hang around
    Rw Tipz + $t;
Tipz: | # test trip applicator
    if (c&Se == 1) {
        # these two make ghost updating
         5s&desi = "Ghoster";
        n Waytch
        
        G&Ti,Trips=>[Catchelism=>''=>\'W:Friv,At:s,Acv:4'],$_
            for  &acgtlr{
                acu $G, trip=>[$l,"@Me",{A=>$A},$C];
            };
        
        t.e = 
        G&Ti,Trips=>[InjectO=>''=>\'W:Friv,At:O,Acv:5,Ct:e'],$_
            for &acgtlr{
                acu $G, trip=>[$l,"@Me",{A=>$A},$C];
                C.sc.fri = 3 if C.t eq 'e';
            };
        
        t.cs->('sc lv,olv','Trips');
        
        # n Fri
        t.e =
        n Nowish
        t.cs->('sc top','Other reflects shows');
        #t.e =
        #n OscNotter=>V
        n Toter
    }
Nowish: |
    u TripDrop
    Jc&tape = 'Dejo';
    n Friv
    n _.t=>_.y.cv=>_.t=>{fs=>14 * (_s&fri || 1)} for G&op;
Friv: | # dece
    n d=>1
    n e=>2
    n c=>3
    n e=>4
Tripical: | # T roominance
    n Tripin
    n TruPic
    # n Tripserv # TODO
    n TripDrop
    n More
    n Jold
Tripin: | # trip applicator
    u i
    # elvis $s with to-l,r for travel grab/do giving to 4s&trip
    # r may be acgtlr
    Ti: %acgt:s l r
        (my$y,$r) = ($r,undef) if ref $r eq 'CODE';
        $r ||= [acgt=>''];
        my $c = {l=>G&Ct,$l , r=>G&Ct,$r };
        c.r.c.code = $y if $y;
        n $s=>[to=>$c]
    # apply levels of looking-for-ness, run hook if done
    # called by tripping an A.trip.$whereabouts...
    # which gives you A.c to keep trip in and/or set antitrip
    trip: %acgt
        my $t = G&pint,A.trip,@Me;
        my $emp = !$t;
        $t ||= G&pint,A.c.trip,@Me || die "tripnotripped @Me";
        
        G&punt,A.c=>tripped=>@Me,1;
        #saygr "Want to apply @Me to ".G&sn ."\t  ".G&aC,$C;
        
        # from A locate next business
        # could be another falling everywhere A.trip
        # or A.c.trip to further this A
        my $l = ts&l;
        # may like to know progress esp if full nothing
        #lc&sense && acu $G, trip=>[l.t,"@Me"];
        
        for my $k (qw'At Acv Ct') {
            my $v = l.c.>$k || next;
            A&tripped.>$k && next;
            # run on to find
            # assume first is fally, rest are on the A
            # should be able to pass a thread of work down
            if ($k eq 'Ct') {
                # is test for now
                $v eq C.t ? next : return;
            }
            # otherwise install the next trip in
            A&trip.>$k.>$v = $t;
            #saygr "Has to find: $k $v (l.t)";
            return
        }
        
        # do hook
        my $r = ts&r;
        rc&code || die "what r: ".ki$r;
        rc&code ->($A,$C,$G,$T,$l,$r,@Me);
TruPic: | # descript
    u i
    # describe a C's surface
    # < make accentuatable
    aC: %acgt:s dt
        $s ||= $C;
        my $yk = join ' ',sort grep{$_ ne 'cv'} keys %{s.y};
        my $ck = join ' ',sort keys %{s.c};
        my $sk = join ' ',sort keys %{s.sc};
        return [s.t,s.y.cv,$yk,$ck,$sk] if $dt eq 'Ck5';
        "s.t s.y.cv ".($yk ? "($yk)" : " - ")
            ." $ck".($sk && " % $sk");
    
    # stringify M, talking about scs
    sscC: %acgt:M
        join "\n", map {
            my $in = _c&inds;
            my $sc = _.sc;
            my $ha = (keys %$sc && "\n").join "\n", map {
                my $v = $sc.>$_;
                $v = ki $v if ref $v;
                "$in  $_:".($v !~ /\n/ ? " $v"
                    : "\n".join "\n", map { "$in    $_" }
                    split /\n/, $v);
            } grep { $_ ne 'z' && $_ ne 'strung'
                && !(sc.strung && sc.strung.>$_ ) } sort keys %$sc;

            sprintf "%-20s %-30s", $in . _c&s , $ha
        } @$M;
TripDrop: | # bind Trips at moment of W
    u s
    # tripper supplies trips for name
    W 31: %of:mo
        my $t = 4s&tripper || return;
        if (A.trip) {
            saygr "Trips undoing: ".ki A.trip;
            delete A.trip;
        }
        my $al = ts&top.y.tw;
        my $i = $al.>C.t;
        unless ($i) {
            if (my $tripany = ts&tripany) {
                $tripany->($A,$C,$G,$T);
            }
            else {
                return
            }
        }
        #1 && sayyl "Have trips for C.t";
        my $n = is&J.sc.top;
        $n = n.y.tv;
        # from W locate A by t
        for my $p ('At') {
            each cv,d $n.>$p {
                A.trip.>$p.>dc&s = $d;
            }
        }
        trip At/mo
Jold: | # for J universal handling FactorEase
    u i
    dedu:
        my $x = J.sc.>$s ||= {};
        G&pint,$x,@Me && return T.pos = 0;
        G&punt,$x,@Me,1;
        1
    # andor sanity/scheme checks
    musb:
        for (@Me) {
            if ($s eq 'W') {
                _.3 eq $_ || die "Wants W not: ".ki$_
            }
            else {
                die "how else? $s"
            }
        }
Trips: | # to be distributed to W
    # host instructures
    # elvis garden of stuff for others
    # wire into Os to check us for instructions to W
    # which are then pyramid schemes into details
    # the snake catcher
    #Jc&tape = 'Dejo';
    Js&ein.t.to.sMJ = &sMJjeT{
        # e&l keeps returning from the first elvis?
        #my ($l,$r) = (e&l , e&r);
        my ($l,$r) = (ec&l,ec&r);
        $l && $r || return G&vent,"Nottravel(l/r)";
        $s = l.t;
        
        G&dedu,tri=>$s || return;
            
        my $forW = l.c.W || die "l not cW";
        m $forW=>''=>{l=>$l,r=>$r}
    };
    Js&ein.t.not.sMJ = &sMJj{
        $s ||= e&l ->{t};
        @$M = grep { _c&l.t ne $s } @$M;
    };
    # see Jigup
    Js&ein.t.tripany.sMJ = &sMJj{
        Js&tripany = $s;
    };
    S
    # make Troom for the Words
    my $WT = {};
    for (@{Js&M||[]}) {
        push @{$WT.>_c&l.c.W ||= []}, $_;
    }
    each Wz $WT {
        n $W=>-trip=>$z
    }
    4s&tripper = $J;
pi/trip: | # bag of tricks to pass to a W
    n t=>1=>C.t."\n"
    # should be slept via 
    my $m = {}; # Aim: method/unknown = r
    #exit;
    # is A mania ^
    # some r could group clutter
    my $i = 1;
    for my $t (@$s) {
        my ($l,$r) = (tc&l, tc&r);
        
        # braid for action
        r.y.t = $t;
        l.y.t = $t;
        lc&Acv /= 10 while lc&Acv && lc&Acv >= 1;
        # conot for C c&tC, A, etc.
        # 
        # and attaches to the throat
        if (lc&At) {
            m.At.>lc&At = $r;
        }
        else {
            die "Unknown travel linkup: ".ki($l);
        }
        next;
        n t=>$i.'1',"t: l.t\n"
        n l=>$i.'2',{pi=>pud=>s=>$l};
        n r=>$i.'3',{pi=>pud=>s=>$r};
        $i++;
    }
    my $i = 1;
    each tsr $m {
        n $t=>"2$i"=>{s=>$s},{l=>r.y.t.c.l,r=>$r};
        $i++;
    }}

