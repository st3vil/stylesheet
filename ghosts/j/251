

NutC: | # start C-ing
    u j
    n \'of:eye'
    #c G&Four - webbing to J doing anything
    # All require A.I already
    # TES move A.I to A&I?
    
    # A.4 creation/garden
    # already have an A, keep it if it's window.A
    # if you had an A.on, that becomes the new toplevel of things
    
    # s would be the W on the server to try and ws or so
    #   when elvises fail they just return W page
    #   makes a socket hang around, whatever comes across.
    
    # begins
    # 4s&N are A/C wanting attention/typing in
    Four: %acgt:fourt fivet
        fourt ||= 'Four';
        fivet ||= 'Five';
        $el = A.on;
        if (window.A != A) {
            A = A.4.up;
            !A and throw "requires an enclosing event forwarding A4"
            A = G&Aye,'atop';
        }
        A.on = el || A.on;
        A.on.A = A;
        
        A.1 = A; # so A:top == A.4.up
        
        A.I = $.extend({},A.I);
        delete A.I.w; # way cache
        
        $J = A.1 = A.2 = A.3 = A.4 = G&J,fourt;
        J.1 = J.2 = J.3 = J.4 = J;
        $f = G&J,fivet;
        A.5 = J.5 = f.5 = f;
        # BAB: put 1s&Jtv A.4.t 0.01 A.4
        1s&Jtv ||= {};
        1s&Jtv[A.5.t] ||= {};
        1s&Jtv[A.5.t][0.01] = A.5;
        1s&Jtv[A.4.t] ||= {};
        1s&Jtv[A.4.t][0.01] = A.4;
        # 1s&z etc for showing state
        # 1s&N is A-ction, stuff to do,
        # Jambien everything in 1s&Jtv
        4s&NormalI = A.I;
        
        # pretty printer
        4s&ki ||= &s,d{ return "!kiyet:"+typeof s };
        G&waylay,'NutGravy';
        # ^ then G&waylay,'NutReady'
        # should wait for that ^ before init W
        
        # textual umbiloca t
        4s&ws = G&Aye,'ws',9;
        
        # msgs - should be clickable somehow
        $msgs = $(A.on).find('> #msgs')[0];
        msgs ||= $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
        4s&msgs = msgs;
        
        
        
        # DNS - a list of current A.4 by name
        #  this is really 6s&Jtv? or if A.4.2.Jtv[A.4.t]... == A.4?
        #   TES callbacks should use G&back:
        #    - rejoining Gc&B, A,
        #    - possible G.DNS[A.4.t] != A.4 and return;
        $dns = G.DNS = G.DNS || {};
        $old = dns[A.4.t];
        dns[A.4.t] = A.4;
        
        4s&uuid = G&desca,Math.random(),8;
        
        return A.4;
        
    
    #c Jinthe for A:top start, having I - webbing to Four
    Jinthe:
        # comes from event sometimes
        A = window.A;
        
        $reset_event_listeners = &{
            G.clof(); G.keof();
            G.clon(); G.keon();
            delete Gc&B;
        };
        s == 'reset_event_listeners' and return reset_event_listeners();
        
        A&ws ||= 1;
        
        G.c = {};
        G.sc = {};
        G.DNS = {};
        
        $glo = ['h','t'];
        each it glo {
            $z = G.t(A,C,G,T,'i',t);
            $code = z.c.code;
            typeof code != 'function' and throw "Give I.i."+t
            G[t] = code;
        }
        # ^ v ?
        G.h = A.I.eye.y.tw.h.c.code;
        
        # many G means many A.4 for now,
        # find the A:top to sprout the document -> stylehousings
        #   G&Ban for errors
        #   G&gev for events - target will climb up to an A.4 element
        #     and non-target evs (keydown) will go to the last targeted A.4
        #     you could setup more handlers on inners that ev.stopPropagation
        window.BamonG = &{
            $A = Gc&B.sc.A;
            return A.4.up
        };
        window.onerror = &msg,url,lineNo,colNo,error{
            A = BamonG();
            A&bang and return
            A&bang = 1;
            G&Ban,error,msg,url,lineNo,colNo,error;
            delete A&bang;
            return
        };
        
        A.t = 'top';
        A.y = A;
        delete A&T;
        
        A.on = $('body')[0];
        
        G&Four;
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev,{ G&gev,ev }) };
        G.keon = &{ $(window).on("keydown", &ev,{ G&gev,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        G&headi,'A','Jin';
        G&headi,'C','Typ';
        G&headi,'G','begoin';
        G&headi,'T','Tri';
    
        reset_event_listeners();
    

    # G (W) reinits...
    
    # T adjusts net
    
    #c A: run funnel
    # the general J 8, starting from A.4
    Jin:
        A.1 != A.4 and ~wherefour
        # toggle
        s && s.t.match(/^S\+/) and return G&waylay,'Jinloop';
        # thinking
        G&Jinthe,'reset_event_listeners';
        G&waylay,'AndContinue';
    
    # C: collect chatter
    # create error, order its fixing
    Typ:
        A.1.t != 'Typ' and return G&n,['Typ'];
        
        G&way,A.1.t;
    
    # gets its own way, comes back, assum
    Tri:
        # toggle time to live
        s && s.t.match(/^S\+/) and return G&waylay,'VastTimeout';
        
        A.1.t != 'Tri' and return G&n,['Tri'];
        
        G&way,A.1.t;
    
    # make buttons for these ACGT impulsory things...
    headi: %acgt:s t
        t ||= s
        
        $('body h2').filter(&i,v{
            v.innerHTML.match('^'+s) and v.remove()
        });
        
        $func = "G.h(A,C,G,T,'"+t+"')";
        $('<h2 id="'+t+'" onclick="'+func+'">'+s+'</h2>')
            .appendTo('body')
    
    # more inside
    Who:
        A.1.t != 'Who' and return G&n,['Who'];
        
        G&way,A.1.t;
        
NutGravy: | # non-I routines: json, dig, diff
    # disable Hut's particling of c&W
    A.I.om.y.tw.W.c.code = &acgts{};
    
    # data
    window.isC = &s{
        return s && typeof s == 'object'
            && s.t != null && s.y && s.c && s.sc
    };

    # < use for subnet extraction & auto-+-<1ism
    # < passthrough non-number, return number as number if number
    # js caveat: numbers messily turn string, which breaks sort, +, etc
    #   esp the each i may be a string, i-+-1 is safer than i+1
    window.regexforanumber = new RegExp(/^\-?\d+(?:\.\d+)?$/);
    window.isnum = &s{
        return typeof s == 'number' ||
        (typeof s == 'string' && window.regexforanumber.test(s))
    };
    # [[...]...] to [......], with callback per/after flattening
    window.lineate = &L,d,cb{
        typeof d == 'function' and cb = d; d = {}
        typeof d == 'number' and d = {dl:d}
        d and d = ex({},d); d.di = (d.di||1)-1;
        d ||= {};
        (d.di ||= 0) < -15 and debugger; throw "Too many lineate";
        $s = [];
        each il L {
            if (l.constructor == Array && (!d.dl || d.dl > d.di)) {
                $r = l = lineate(l,d,cb);
                cb and r = cb(r,d,l);
                r and l = r
            }
            if (l && l.constructor == Array) {
                each i,ll l {
                    s.push(ll);
                }
            }
            else {
                s.push(l)
            }
        }
        return s
    };
    # s=Object has keys, or has a d=key
    window.haks = &s,d{
        $N = [];
        !s and return N
        each k,v s {
            d == 'kv' and N.push(k,v)
            else
            d == 's' and N.push(v)
            else {
                N.push(k);
            }
        }
        return N
    };
    # s=Object has keys, or has a d=key
    window.hak = &s,d{
        return d == null ? Object.keys(s).length : s.hasOwnProperty(d)
    };
    window.ex = &s,d{
        return $.extend(s,d)
    };
    # < for hash too?
    window.uniq = &N{
        $M = [];
        each is N {
            M.indexOf(s) >= 0 and continue
            M.push(s);
        }
        return M;
    };
    
    #c encodings
    # < no knowing where they are fully, used for small things by G&toLines
    Function.prototype.toJSON = &lastkey,{
        $ca = window.enj_catch;
        if (ca) {
            ca.push("Has a function at .../"+lastkey);
            return "CODE"
        }
    };
    window.enj = &sT{
        if (T && T.enj_catch) {
            window.enj_catch and throw "Nested (global) enj catch"
            window.enj_catch = T.enj_catch;
        }
        $encoded = JSON.stringify(s)
        delete window.enj_catch;
        return encoded;
    };
    window.dej = &s{
        return $.parseJSON(s)
    };
    
    window.eny = &sTn{
        $opt = {};
        typeof n == 'object' and ex(opt,n); n = 0
        !T and 1
        else
        typeof T == 'object' and opt.Tcatch = T.eny_catch; T = n;
        
        T > 0 and opt.nl = T; # node limit
        else
        T < 0 and opt.dl = T * -1; # depth limit
        
        opt.Tcatch and opt.catch = opt.Tcatch
        opt.catch ||= [];
        opt.catch.length and throw "T.eny_catch not empty array"
        $encoded;
        $err;
        try { encoded = jsyaml.safeDump(s,opt) }
        catch(er) { err = er }
        if (err || opt.catch.length) {
            if (opt.Tcatch) {
                # is minded by something up there,
                # allows munted encodes
                # < not mixing types, may [err,pathwarning+]
                err and opt.catch.unshift(err);
            }
            elsif (err) {
                throw err, opt.catch
            }
            else {
                throw "Unyamlables", opt.catch
            }
        }
        return encoded
    };
    window.dey = &s{
        return jsyaml.safeLoad(s)
    };
    
    # the other hash
    window.dig = &s{
        return sha256(s).slice(0,12)
    };
    
    #c diffing text
    window.dmp = new diff_match_patch();
    window.diff = &s,S,c{
        c ||= {};
        typeof c != 'object' and c = {chunk:'line'};
        $dmp = window.dmp;
        dmp.Diff_Timeout = 1; # second
        dmp.Diff_EditCost = c.edar || 4;

        $ms_start = (new Date()).getTime();
        $d = dmp.diff_main(s, S);
        $ms_end = (new Date()).getTime();
        
        # idealise the size of the groups coming/going
        c.chunk ||= 'word';
        c.chunk == 'line' and dmp.diff_cleanupSemantic(d)
        c.chunk == 'word' and dmp.diff_cleanupEfficiency(d)
        # or letters at a time, nice and noisy
        
        $ds = window.diff_prettyC(d);
        
        return ds;
    };
    # window.C = &t,y,c,sc{
    window.diff_prettyC = &diffs,{
        $N = [];
        each il diffs {
            $op = l[0];
            $s = l[1];
            
            $n = {y:{},c:{s:s},sc:{}};
            n.t = op == DIFF_INSERT ? "new" :
                op == DIFF_DELETE ? "gone" :
                op == DIFF_EQUAL ? "same" :
                'huh: '+op;
            N.push(n)
        }
        return N
    };
    # the example
    # < make it use G&intag?
    window.diff_prettyHtml = &diffs,{
        $html = [];
        $pattern_amp = /&/g;
        $pattern_lt = /</g;
        $pattern_gt = />/g;
        $pattern_para = /\n/g;
        for (var x = 0; x < diffs.length; x++) {
          var op = diffs[x][0];    // Operation (insert, delete, equal)
          var data = diffs[x][1];  // Text of change.
          var text = data.replace(pattern_amp, '&').replace(pattern_lt, '<')
              .replace(pattern_gt, '>');
              #.replace(pattern_para, '¶<br>');
          switch (op) {
            case DIFF_INSERT:
              html[x] = '<ins style="background:#151;">' + text + '</ins>';
              break;
            case DIFF_DELETE:
              html[x] = '<del style="background:#622;">' + text + '</del>';
              break;
            case DIFF_EQUAL:
              html[x] = '<span>' + text + '</span>';
              break;
          }
        }
        return html.join('');
    };
    
    
    #c ki leaves through here for singular squish factory,
        # optional c.keys
        $cvf = window.cvf = &cv,{
            m = (cv+'').match(/^0\.(\d+)$/);
            return m && m.length ? m[1] : cv
        };
        $li = &s,c,k{
            $ks = c.ks;
            $was = c;
            $c = $.extend({},c);
            k != null and c.k = k; s = s[k]; c.up = was;
            delete c.ks;
            $M = [];
            $joiner = ',';
            if (s && typeof s == 'object') {
                if (!ks) {
                    ks = [];
                    each kv s {
                        ks.push(k);
                    }
                }
                $elem = 1;
                each ik ks {
                    # could look at c.drawn but we're before/in the mouth of es()
                    (c.type == 'A' || c.type == 'J') && c.k == 'y' && (k == 't' || k == 'y' || k == 'c' || k == 'sc') and continue
                    
                    v = s[k]; # ]
                    $d = $.extend({},c);
                    d.d += 1;
                    d.up = c;
                    d.k = k;
                    $ke = '';
                    c.saykey and ke = k+':';
                    
                    c.k == 'y' and d.d += 2;
                    $sa = ki(v,d);
                    
                    # a number on its own is the cv
                    c.k == 'y' && d.k == 'cv' && sa.drawn == 'string' and sa.s = cvf(v); ke = '';
                    
                    elem && sa.drawn != 'html' and elem = 0;
                    if (elem && sa.drawn == 'html') {
                        # shorten paths in (or out)
                        if (elem != 1) {
                            if (!(v.parentNode == elem
                                || elem.parentNode == v)) {
                                elem = 0
                            }
                        }
                        elem and elem = v;
                    }
                    if (sa.drawn == 'type:t') {
                        # its own type part of the key
                        k.match(sa.type+'$') and ke = k+';'; sa = v.t
                        c.type == 'a' and sa.s = sa.s.replace(/^{|}$/g,'');
                    }
                    if (sa.drawn == 'tycsc') {
                        # enclosed t y c sc
                        # smaller insides?
                        sa.s = '('+sa.s+')';
                    }
                    M.push([ke,sa]);
                }
                # #c whatjust 
                if (elem) {
                    joiner = '^'; # conjoiner of inside elements
                    each im M {
                        sa = m[1];
                        sa.s = sa.s.replace(/^\^|\^$/g,'');
                        
                    }
                }
                if (c.up && c.up.type == 'C' && c.k == 'y') {
                    each im M {
                        m[0] == 'cv:' and m[1] = cvf(m[1])
                    }
                }
                if (c.type == 'A' || c.type == 'J') {
                    # bits in each ks ^
                    if (c.k == 'y') {
                        # split out A.\d, points on wormhole slope
                        $Jnet = {};
                        $N = [];
                        $cvm;
                        each im M {
                            $sa = m[1];
                            # not es() intel object
                            typeof sa == 'string' and N.push(m); continue
                            # take out cv, prefix to Jnet
                            sa.k == 'cv' and cvm = m; continue
                            # take out Jnet numbers
                            sa.k.match(/^\d+$/) and Jnet[sa.k] = sa; continue
                            # we can see properties of string and undefined:
                            # J.2 usually == J.up
                            sa.k == 'up' && sa.v == c.v.2 and continue;
                            sa.k == 'I' and continue;
                            N.push(m);
                        }
                        # crunch them together implicitively
                        $Jnek = Object.keys(Jnet);
                        if (Jnek.length) {
                            Jnek.sort();
                            $E = [];
                            $la;
                            each in Jnek {
                                $d = Jnet[n];
                                d.type != 'J' and throw "JnetnotJ: ", d
                                $l = la && Jnet[la.k];
                                if (l) {
                                    # same J takes highest number
                                    l.v == d.v and E.pop()
                                }
                                if (n > 3) {
                                    n == 4 && !E.length and E.push('1-4')
                                    # leave off fqdn 4/5, if same as here
                                    # here from last B
                                    $Y = Gc&B && Gc&B.sc.A || A;
                                    d.v == Y[n] and continue
                                }
                                # dont say 2 if its 4 
                                n == 2 && d.v == c.v.4 and continue
                                # and if 1,3 etc is it
                                d.v == c.v && d.v != c.v.4 and E.push(n); continue
                                E.push(d);
                                la = d;
                            }
                            $netname = [];
                            each id E {
                                typeof d != 'string' and d = d.v.t
                                netname.push(d);
                            }
                            netname = netname.join('.');
                            # cv can prefix a net name
                            if (cvm) {
                                netname = cvm[1] +'@'+ netname;
                                cvm = null;
                            }
                            N.unshift(['',netname]);
                        }
                        cvm and N.unshift(cvm);
                        M = N;
                    }
                    else
                    if (c.k == 'c' || c.k == 'sc') {
                        $E = [];
                        $N = [];
                        each im M {
                            c.k == 'c' && (m[0] == 'sip' || m[0] == 's' || m[0] == 'N') and E.push(m); continue
                            c.k == 'sc' && (m[0] == 'N' || m[0] == 's') and E.push(m); continue
                            N.push(m);
                        }
                        # will see later-defined things first, except for ^
                        N = N.reverse();
                        while (E.length)
                            N.unshift(E.pop())
                        M = N;
                    }
                }
                $N = [];
                each im M {
                    # 'key:' label and its drawing, an overloaded object
                    $str = m[0]+m[1];
                    N.push(str);
                }
                M = N;
            }
            else {
                $d = $.extend({},c);
                d.d += 1;
                d.up = c;
                M.push(''+ki(s,d));
            }
            $m = M.join(joiner);
            $strlim = c.lum * 20 + 5;
            m.length > strlim + 10 and m = m.substr(0,strlim)+'..*'+M.length
            
            # TODO lightningbolt? coloured metacharacters title=unicode info?
            # Cify the es() object, next/in all this stuff 
            m = m.replace(/\r|\n/g, "↯");
            
            return m
        };
        # #c more ki
        $arfgunc = &s{
            typeof s != 'function' and return
            $m = s.toString().match(/^function \((.+?)\)/);
            return m && m[1] || ''
        };
        $ki = &s,c{
            c && typeof c != 'object' and c = {dl:c};
            c ||= {dl:4};
            if (!c.d) {
                c.d ||= 1;
                # if 4.32, shrink de-dl by 2 at d=3
                # to get a big top full of small items
                # should balance itself
                $detail = c.dl - c.dl.toFixed();
                if (detail) {
                    detail = (detail+'').split('').slice(2);
                    detail[1] ||= 2;
                    c.ritard ||= {};
                    c.ritard[detail[0]] = detail[1];
                }
            }
            c.ritard && c.ritard[c.d] and c.dl -= c.ritard[c.d]
            c.d > 15 and throw "large ki";
            c.lum = c.dl - c.d;
            delete c.saykey;
            c.v = s;
            # turn c into string object, add knowing how it is drawn
            $es = &s,drawn{
                c.s = s;
                drawn and c.drawn = drawn;
                c.toString = &{ return ''+this.s };
                c.d == 1 and return ''+c;
                return c
            };
            
            
            if (s == null) {
                return "n*ll"
            }
            else
            if (typeof s == 'number' || typeof s == 'string') {
                !(s+'').match(/^[\+\w]+$/) and s = "'"+s+"'";
                return es(s,'string');
            }
            else
            if (s.constructor == Array) {
                c.type = 'a';
                !s.length and return '[]'
                c.lum < 1 and return '[*'+s.length+']'
                return '['+li(s,c)+']'
            }
            else
            if (s.constructor == Object) {
                c.saykey = 1;
                $ks = Object.keys(s);
                !ks.length and return '{}'
                $type = s.y ? s.y == s ? 'A' : 'C' : 'd';
                !(s.c && s.sc && s.t != null) and type = 'd';
                type == 'C' && ks.length > 4 and type = 'd';
                type == 'A' && s.1 == s and type = 'J'
                c.type = type;
                if (type != 'd') {
                    type == 'A' and c.lum -= 1
                    type == 'J' and c.lum -= 1
                    if (c.lum < 2 && type == 'A') {
                        $cv = cvf(s.cv);
                        return es('{'+type+':'+s.t+'@'+cv+'}','type:t')
                    }
                    c.lum < 1 and return es('{'+type+':'+s.t+'}','type:t')
                    c.lum < 2 and return es(li(s,c,'t')+' '+li(s,c,'y'),'ty');
                    # t y c sc mode, for a clean screen
                    # A.on will be seen through A.y.on
                    return es(
                        li(s,c,'t')+' '+li(s,c,'y')
                        +' '+li(s,c,'c')+' % '
                        +li(s,c,'sc'),
                        'tycsc')
                }
                else {
                    c.lum < 3 and return es('{*'+ks.length+'}')
                    return es('{'+li(s,c)+'}')
                }
                return ''+s
            }
            else
            if ((s.constructor+'').match(/^function HTML/)) {
                $t = s.getAttribute && s.getAttribute('t');
                t ||= s.tagName && s.tagName.toLowerCase();
                t ||= s;
                return es('^'+t+"^",'html')
                
            }
            else
            if (s.constructor == Function) {
                return '&'+ arfgunc(s) +'{*}';
            }
            else {
                return "?"+s+"?"
            }
        };
        window.ki = 4s&ki = ki;
        4s&ready = 1;
        G&waylay,'NutReady';
NutReady: | # on startup, after NutGravy (after G&Four)
    # start the thing, we will leave/async via e
    e Tri
    # whenever that finishes, click it
    $done = &{
        $e = G&Cye,['click','',{p:'rm'}];
        G&e,['Tri'],e;
    };
    G&yl,390,done;
    
    $done = &{
        $e = G&Cye,['click','',{p:'first'}];
        G&e,['Tri'],e;
    };
    G&yl,390,done;
    # turn on the all-retry
    !4c&Jinlooping and G&waylay,'con/Jinloop';
    ~Lovely:
Launch: | # TODO never gets an A
    $h = G&heading,'55';
    ys&class = 'ww'; # takes space but not direct clicks
    G&u,['NutIns'];
    G&clusp;
    
    ys&height = '96%'
    1s&counter ||= 1;
    
    # push for attention
    n Dosin 23 $s:1s&counter++ %dos:do/Lunch
    
    # put the inside
    $n =
    n Inner 24  %hue:30deg
    
    # name innerer and innerer
    $dolls = 'Four Inside Around Near Close'.split(" ");
    $i = dolls.indexOf(A.4.t);
    i < 0 and throw "Where? "+A.4.t
    $t = dolls[i+1];
    
    # place its element.A=4up
    # el<3 blows away any innerer (and create zombies?)
    G&n,[t,3,{Four:6},{height:'80%'}];
    
    # resolve the name
    # should really AndContinue once at the top level,
    #   and travel in through the above n s&J = this 1s&child
    if (1s&child && 1s&child != G.DNS[t]) {
        # if they G themselves
        G&n,['restart',28,{s:'restart'},'fs:70%'];
        1s&child = G.DNS[t];
    }
    # and display it since resolve
    nc&s = ki(1s&child,2);
    
    
Lunch: | # toplevel control/summary of a foodport (tests)
    G&heading;
    
    # aspects, some of these can be switched on
    # < hardwire a bunch of this, no time to be Aing
    [ 
    G&n,['A',2,{s:'A'}] ,
    G&n,['C',21,{s:'C'}] ,
    G&n,['G',22,{s:'G'}] ,
    G&n,['T',23,{s:'T'}]
    ].map(&c{
        cs&dos = 'do/Lunchust';
        cs&doswaylay = 1;
        c.t == "A" && 4c&Jinlooping and cc&s += '°';
        c.t == "T" && 4c&ttl and cc&s += '°';
    });
    
    G&n:['Dosin',3,{s:'Lunch '+4s&uuid},{hue:'60deg'}];
    
do/Lunchust: | # adjust/fire parameters ACGT
    $adj = 1 && e.t.match(/^S\+/);
    if (c.t == 'A') {
        adj and G&waylay,'con/Jinloop';
        else { G&waylay,'AndContinue' }
    }
    else if (c.t == 'C') {
        G&n,['Typ'];
    }
    else if (c.t == 'G') {
        throw "How to restart 4?"
    }
    else if (c.t == 'T') {
        adj and G&waylay,'con/VastTimeout';
        else { G&n,['Tri'] }
    }
    else {
        throw "Nut a button", c
    }
    ~>87 adj: c.t, ki(adj)
    !adj and T.ok = 1;
    
con/VastTimeout: | # less asyncing by making G&t sure of cached things
    if (4c&ttl) {
        delete 4c&ttl;
        delete Gc&ttl;
    }
    else {
        4c&ttl = 3600;
        Gc&ttl = 3600;
    }
con/Jinloop: | # A continuously
    # would rather change OC s&on and tell s to pull
    if (4c&Jinlooping) {
        delete 4c&Jinlooping;
        ~>5 Jinloop off:
    }
    else {
        $lo = 4c&Jinlooping = Math.random();
        $op = &{
            lo != 4c&Jinlooping and return
            G.DNS[A.4.t] != A.4 and G&c,"Loopoff:"+A.4.t+"-VS-"+ki(G.DNS[A.4.t],2); return;
            G&delay,0.3,op;
            G&waylay,'AndContinue';
        };
        op();
        ~>5 Jinloop on:
    }
    
VastTimeout: | # one of many parameters to a 4/G
    $el = $('h2#Tri');
    if (1s&VastTimeout) {
        delete 1s&VastTimeout;
        delete Gc&ttl;
        el.text("T");
    }
    else {
        el.text("T°");
        1s&VastTimeout = 1;
        Gc&ttl = 3600;
    }
Jinloop: | # A continuously
    $el = $('h2#Jin');
    if (1s&looping) {
        delete 1s&looping;
        el.text("A");
    }
    else {
        el.text("A°");
        $lo = 1s&looping = Math.random();
        $op = &{
            lo != 1s&looping and return
            window.A.4 != A.4 and return
            G&delay,0.5,op;
            G&waylay,'AndContinue';
        };
        op();
    }
    

