Typ: | # exact lounge
    # TO give at a glance a pretty good idea of where you are
    # in the colour code of
    #
    G&jam and return T.not = 1;
    G&n,['t',0.01,{s:A.1.t},{ab:1,fs:'200%',blr:'2px'}];
    ys&dis = 'block';
    
    #G&way,"BLath";
    
        
        
        G&u,['MelTest'];
        G&u,['NutText'];
        G&u,['NutLands'];
        G&clusp;
        1s&i ||= 0;
        1s&i++;
        G&n,['C',4,{s:'Hererereere'+1s&i},{e:1}];
    ~>3 Ze colour: 1s&i, '>1 one', '>2 two', '>3 three', '>4 four',  '>5 five',  '>6 six', '>7 seven', '>8 eight', '>9 nine'
        
        $te = "steve\t4\t\"Val\"\tEin:4,daw:go,sf:004";
        $N = G&readLines,te;
        each in N {
            $cv = 0.6+i*0.002;
            G&n:['readLines+ki',cv,{s:"Item: "+4s&ki(n)},{dis:'block'}];
            $s = G&toLines,n;
            G&n:['toLines',cv+0.001,{s:"Writ: "+s},{dis:'block'}];
        }
        
    $m = G&n:['M','-jod_7',{s:A,dl:4}];
    #$m = G&n:['overflow:scroll','-jod_7',{s:A,dl:4}];
        
    1c&save = "lo";
    
Tri: | # travel
    G&jam and return T.not = 1;
    G&n,['t',0.01,{s:A.1.t},{ab:1,fs:'200%',blr:'2px',zi:-20}];
    1s&root.sc.dis = 'block';
    
    1s&ein ||= {};
    1s&ein.click = {w:'einclick'};
    
    # waddley
    G&u,['MelTest'];
    G&u,['NutText'];
    G&clusp;
    
    1s&M ||= [];
    
    
    # navigation/breadcrumb
    # < click to reposition/wake
    # < leave what you didn't interact with
    G&n,['other',1,{s:"Ge"},{jela:15,dos:"SwitchupEl:#msgs:css:overflow:hidden/scroll"}];
    G&n,['something',15,{s:"La"},{fs:'170%',hs:'345'}];
    
    # the name, renamable
    G&n,['Name',3,{s:"Steve"},{e:2}];
    
    # where latest ^ gets down
    G&n,['Content',4,{s:'Intwrrori'},{e:1}];
    
    #G&n,['Who'];
    G&n,['Wheer','-jod_6',{s:["Vla",'Ua']}];
    
    
    if (1s&M.length) {
        each in 1s&M {
            i == 6 and G&n,['many',5,{s:'...'}]; break
            i = i * 0.001;
            G&n,['ane',4+i,{s:n},{dis:'block'}];
        }
    }
    
SwitchupEl: | # tweak Elemental bitology
    # make overflowable
    # 
Who: | # lis
    G&jam and return T.not = 1;
    G&n,['t',0.01,{s:A.1.t},{ab:1,fs:'200%',blr:'2px'}];
    1s&root.sc.dis = 'block';
    
    G&n,['Name',3,{s:"Fand"},{e:2}];
    
    
einclick: | # what any webby W can experience
    #G&E,'hC s&dos';
    # 
    # path (elements with .A) to hC (their .A.c.s's found in 1s&ss&top)
    $E = &d{
        $d = d.split(' ');
        $s = d.shift();
        if (s == 'hC') {
            ec&hC || get_hC(e);
            s = ec&hC;
        }
        else { throw "What data? "+s }
        
        !d.length and return s
        d = d.join(' ');
        return FE(s,d);
    };
    # grep/map, know structure
    $FE = &s,d,l{ 
        $m;
        $p = &r{
            if (d.match(r)) {
                m = d.match(r);
                m.shift();
                d = d.replace(r,'');
                return 1
            }
        };
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ return s && s[nk] && s[nk][gk] });
        }
        
        # calling it s means grep for and move to
        # items replace with something that must be true
        if (p(/^(s\.A\.c\.s) ?/)) {
            s = s.map(&s{ return s.A && s.A.c.s }).filter(&s{ return s });
        }
        
        # remove items until...
        if (p(/^(since) (yA1) (==) (A1) ?/)) {
            while (s.length) {
                $z = s[0]; # ]
                z.y.A && z.y.A && z.y.A.1 == A.1 and break;
                s.shift();
            }
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s;
    };
    $get_hC = &e{
        $path = FE(ec&path,'s.A.c.s since yA1 == A1');
        
        $r = 1s&s.sc.top;
        $tv = r.y.tv;
        ec&hC = [];
        each iD path {
            if (tv && tv[D.t] && tv[D.t][D.y.cv]) {
                $o = tv[D.t][D.y.cv];
                ec&hC.push(o);
                tv = o.y.tv;
            }
            else {
                $res = tv ? "404" : "notv";
                ~>96 point: res, i+' in:', 4s&ki(path,3)
                throw "Broken pointer";
                break;
            }
        }
    };
    
    #debugger;
    $D = E('hC s&dos').slice(-1)[0];
    $dodos = &D{
        !D || !Ds&dos and throw "no dos";
        $w = Ds&dos;
        w = w.split(':');
        way = w.shift();
        ar.m = w;
        ~>3 dos: way
        G&way,way,ar;
    };
    
    dodos(D);
    #debugger;
    1s&M.push("Anteract: "+4s&ki(C,3));
    
SwitchupEl: | # adjust css of elements
    $find = m.shift();
    $adjust = m.shift();
    $property = m.shift();
    $between = m.shift().split('/');
    $el = $(find);
    !el and throw "Nofind "+find;
    $now = el[adjust](property);
    $i = 0;
    while (between[0] != now) {
        between.push(between.shift());
        i++ > between.length and throw "Didnt start with any of "+ki(between);
    }
    between.shift();
    $next = between.shift();
    el[adjust](property, next);
t/JSTesti: | # test the JS bits
    # how does it work?
    # a bunch of timers?
    # C-ing
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Thumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
MelTest: |
    u js
    n \'of:n'
    
    jela 53:
        s&fs = (15 * s)+'%';
    
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    G&n,['Thing',3,{s:4s&ki(c&s,c&dl||3)},{e:1}];

