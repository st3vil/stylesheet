
Topo: | # and - the activity
    # Topo - single read/writer
    #   to know more W about Four/Five/etc than you need to
    #   for async G&t lookup and allocation
    #   writable stuff given to it, knows the 1-5 non-git form
    #   W pushed outside of the G must be commit
    
    # Tri - pushing G frontiers of language
    # Typ - molten C edits of stuff in G
Cluts: | # ore - the matrial
    # land upon body,
    # balance neuron attention
    # into time, around tasks
Typ: | # exact lounge
    # TO give at a glance a pretty good idea of where you are
    # in the colour code of
    G&heading;
    
        G&u,['MelTest'];
        G&u,['NutText'];
        G&u,['NutLands'];
        
        G&clusp;
        1s&i ||= 0;
        1s&i++;
        G&n,['C',4,{s:'Hererereere'+1s&i},{e:1}];
    ~>3 Ze colour: 1s&i, '>1 one', '>2 two', '>3 three', '>4 four',  '>5 five',  '>6 six', '>7 seven', '>8 eight', '>9 nine'
        
        $te = "steve\t4\t\"Val\"\tEin:4,daw:go,sf:004";
        $N = G&readLines,te;
        each in N {
            $cv = 0.6+i*0.002;
            G&n:['readLines+ki',cv,{s:"Item: "+4s&ki(n)},{dis:'block'}];
            $s = G&toLines,n;
            G&n:['toLines',cv+0.001,{s:"Writ: "+s},{dis:'block'}];
        }
        
    $m = G&n:['M','-jod_7',{s:A,dl:4}];
    #$m = G&n:['overflow:scroll','-jod_7',{s:A,dl:4}];
        
    1c&save = "lo";
    
Tri: | # travel
    G&heading;
    # sends G by setting T they sprout from
    # u t - declare find-and-change thing, usually into being
    #  making an I that matches (finds) and applies change,
    
    
    # waddley
    G&u,['NutText'];
    G&clusp;
    
    # navigation/breadcrumb
    # < click to reposition/wake
    # < leave what you didn't interact with
    G&n,['other',1,{s:"Ge"},{jela:15,dos:"SwitchupEl:4msgs:css:overflow:hidden/scroll"}];
    G&n,['something',15,{s:"La"},{fs:'170%',hs:'345',dos:"do/Launch"}];
    G&n,['something',17,{s:"Yu"},{fs:'150%',hs:'345',dos:"do/Launch"}];
    
    # the name, renamable
    G&n,['Name',3,{s:"Steve"},{e:2}];
    
    1s&ein['C+says'] = 'says:intent:overwrite';
    1s&ein['A+says'] = 'says:intent:expand';
    1s&ein['says'] = {w:'says/Tri'};
    
    
    # where latest ^ gets down
    $src = "$('body > nlaunchn')[0].A";
    G&n,['Content',4,{s:src},{e:1}];
    
    1s&runput and G&n:['Wheer','-jod_6',{v:1s&runtime,s:1s&runput,dl:4}];
    
    
    if (1s&M.length) {
        each in 1s&M {
            i == 6 and G&n,['many',5,{s:'...'}]; break
            i = i * 0.001;
            G&n,['ane',4+i,{s:n},{dis:'block'}];
        }
    }
    
Expect: | # pull results along
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    
    G&m,M,['FUN','',{s:'FUN'},{hue:'150deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'120deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'100deg'}];
    
    # subgroups for the ground
    $doming = &t{
        if (!t) { # resets
            $h = A.ground;
            hc&dome and A.ground = h.y.up;
            return
        }
        1s&domes ||= {};
        $h = 1s&domes[t];
        if (h) { # redoing
            A.ground = h;
            hs&z = [];
        }
        else {
            $h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            $g = A.ground;
            gc&dome and g = g.y.up;
            gc&dome and throw "many domes deep", A.ground
            h.y.up = g;
            A.ground = h;
        }
    };
    # when doming right, bails: return T.il = waiting condition
    #   and the T rests on the crest of a wave
    $til = &s{
        $n = 
        G&n:['waits','',{s:"Waiting: "+s},{hue:'150deg'}];
        G&m,M,['waits','',{s:s},{hue:'150deg'}];
        1s&step_tries++ > 3 and nc&s = "Gave up: "+s; delete 1s&loop;
    };
    
    # pin sections/doming idea
    1s&step ||= 1;
    1s&step_tries ||= 1;
    $osc_each_step = 1;
    $S = &s,d{
        typeof s != 'number' and throw "NaN",s;
        s < 1s&step and return 0; # dont redo
        s > 1s&step and return 0; # dont get ahead
        if (A&didstep == s) {
            # second loop of while, allow next step
            1s&step++;
            return 0
        }
        # draw each step for stuff flying by on the screen
        # or to commit changes to test data (...)
        A&bailstep == s and return 0;
        osc_each_step and A&bailstep = s+1;
        1s&step_tries = 1;
        A&didstep = s;
        $t = "Step "+s;
        d and t += ": "+d;
        #doming(t);
        return 1;
    };
    
    $tr =
    G&n:['testrun',1,{s:"J, with lv ("+1s&step+"/?)"},{dis:'block'}];
    $loop = 1s&loop = Math.random();
    G&yl:630,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[J.t] };
    
    while (S(1)) {
        $j = G&n,['Launch','V'];
        $L = j && js&J;
        !L and return til('Jup');
        Jc&L = L;

        $F = Ls&child;
        !F and return til('4s\&child: '+ki(L));
        Jc&F = F;
    }
    $L = Jc&L;
    $F = Jc&F;
    $don = &n{
        $s = Fs&subphone;
        !s and throw "Nosubphone", F
        return s(&acgt{ return G&n,n }); #)
    };
    while (S(2)) {
        $n = don(['t/LetsOsc']);
        
        G&n:['made W','-jod_3',{s:n}];
        $Y = ny&A;
        $ok = Y.cv >= 0.8;
        G&n:['A complete','-jod_3',{is:ok?"OK":"Not OK: "+Y.cv}];
        !ok and return til('n completes');
    }
    
    while (S(3)) {
        G&n:['3 (parent) complete','-jod_632',{s:L,dl:4}];
    }
    
    doming();
    
    trc&s = "J, with lv ("+1s&step+"/?)";
    1s&step > 1 and delete 1s&loop;
says/Tri: | # code is said
    $c = G&E:'hC -1';
    if (c.t == 'Name') {
        # change the name/write in a new place
        # < reset pre-name-change changes to Content, dividing history as:
        #   (thing became as it is), GAP, (changes to thing, renamed to thing2)
        #   with link between...
        
    }
    else
    if (c.t == 'Content') {
        if (cc&s != ec&s) {
            # diff and save
        }
        #debugger;
        $B = Gc&B;
        $was = Bs&way;
        Bs&way = e;
        
        $cod = "window.funcifunc = function() {\n"+ec&s+"\n}";
        try { 
        #eval(cod);
        var lu;
        #var lu = $('<script/>')[0]; $(lu).html(cod).appendTo($('head'))[0];
        var ul = Function(ec&s);
        #window.funcifunc;
        
        }
        catch(e) { var za = e }
        $(lu).remove();
        debugger;
        $ln = za && za.lineNumber;
        $or = za;
        za and za = za.stack;
        console.log("EVA:",ln, ul, za, or);
        $evaler = &s{
            # more of it
            return eval(s);
        };
        
        #$r = evaler(ec&s);
        Bs&way = was;
        1s&runput = r;
        1s&runtime ||= 0;
        1s&runtime++;
    }
    ~>3 says/Tri:
    
do/Launch: |
    e.t.indexOf('S') >= 0 and delete 4s&Jtv.Launch; delete 4s&Jtv.Expect;
    G&e,['Launch'];
    # shouldn't need the yl, e should catch (and G&Ban) errors (async)
    # then Expect would complain when the thing doesn't show up,
    #   it already points to where the thing should emerge from...
    G&yl:30,&{ G&e,['Expect'] };
    T.ok = 1;
do/Launcheen: | # toilet?
    # 
Launch: | # TODO never gets an A
    $h = G&heading,'55';
    hs&dos = 'do/Launch';
    ys&class = 'ww'; # takes space but not direct clicks
    G&u,['NutIns'];
    G&clusp;
    
    ys&height = '80%'
    1s&counter ||= 1;
    
    G&n:['Dosin',23,{s:'Dose '+1s&counter++},{dos:'do/Lunch'}];
    $n =
    G&n:['Inner',24,{},{hue:'30deg'}];
    
    # calls your code in an A off the top of the inside
    1s&subphone = &s{
        $F = Js&child;
        !F and throw "innard missing", J
        A = F.up;
        A.t != 'atop' and throw "innard up not atop", A, F
        A = G&Aye,'phone';
        return s(A,C,G,T);
    }; # )
    
    #debugger;
    
    # name innerer and innerer
    $dolls = 'Four Inside Around Near Close'.split(" ");
    $i = dolls.indexOf(A.4.t);
    i < 0 and throw "Where? "+A.4.t
    $t = dolls[i+1];
    
    # place its element.A=4up
    # el<3 blow away any innerer (and create zombies?)
    G&n,[t,3,{Four:6},{height:'80%'}];
    
    # resolve the name
    # should really AndContinue once at the top level,
    #   and travel in through the above n s&J = this 1s&child
    if (1s&child && 1s&child != G.DNS[t]) {
        # if they G themselves
        G&n,['restart',28,{s:'restart'},'fs:70%'];
        1s&child = G.DNS[t];
    }
    # and display it since resolve
    nc&s = ki(1s&child,2);
    
    
do/Lunch: |
    # pump ?
    ~>59 SubPhonica:
    1s&subphone(&acgt{ G&n,['Lunch'] });
Lunch: | # toplevel control/summary of a foodport (tests)
    G&heading;
    
    # aspects, some of these can be switched on
    [ 
    G&n,['A',2,{s:'A'}] ,
    G&n,['C',21,{s:'C'}] ,
    G&n,['G',22,{s:'G'}] ,
    G&n,['T',23,{s:'T'}]
    ].map(&c{
        cs&dos = 'do/Lunchust';
        cs&doswaylay = 1;
        c.t == "A" && 4s&looping and cc&s += '°';
        c.t == "T" && 4s&ttl and cc&s += '°';
    });
    
    G&n:['Dosin',3,{s:'Lunch '+4s&uuid},{hue:'60deg'}];
    
do/Lunchust: | # adjust/fire parameters ACGT
    $adj = 1 && e.t.match(/^S\+/);
    if (c.t == 'A') {
        adj and G&waylay,'con/Jinloop';
        else { G&waylay,'AndContinue' }
    }
    else if (c.t == 'C') {
        G&n,['Typ'];
    }
    else if (c.t == 'G') {
        throw "How to restart 4?"
    }
    else if (c.t == 'T') {
        adj and G&waylay,'con/VastTimeout';
        else { G&n,['Tri'] }
    }
    else {
        throw "Nut a button", c
    }
    ~>87 adj: c.t, ki(adj)
    !adj and T.ok = 1;
    
con/VastTimeout: | # less asyncing by making G&t sure of cached things
    if (4s&ttl) {
        delete 4s&ttl;
        delete Gc&ttl;
    }
    else {
        4s&ttl = 3600;
        Gc&ttl = 3600;
    }
con/Jinloop: | # A continuously
    # would rather change OC s&on and tell s to pull
    if (4s&looping) {
        delete 4s&looping;
        ~>5 Jinloop off:
    }
    else {
        $lo = 4s&looping = Math.random();
        $op = &{
            lo != 4s&looping and return
            G.DNS[A.4.t] != A.4 and G&c,"Loopoff:"+A.4.t+"-VS-"+ki(G.DNS[A.4.t],2); return;
            G&delay,0.5,op;
            G&waylay,'AndContinue';
        };
        op();
        ~>5 Jinloop on:
    }
    
NutIns: | # subverse valuar, for editables s&e
    u jc
    # of html?
    n \'of:om'
    # starts a child process - rename to G at some point
    #   see G&Four
    # s is a runlevel
    Four 6:
        $Y = 1s&child = G&Four,C.t;
        $p = Ys&parent = A.1;
        # doesn't have a clock running yet...
        # should n {C},{c:resyncin:20ms} and push the Jinloop button via e?
        $startup = &acgt{
            G&waylay,'con/Jinloop',{},0.001;
            G&n,['Lunch'];
        };
        s >= 6 && ps&subphone and ps&subphone(startup);
        # 
        
Who: | # lis
    G&heading;
    
    G&n,['Name',3,{s:"Fand"},{e:2}];
    
    
einclick: | # what any webby W can experience s&dos
    #G&E,'hC s&dos';
    # 
    #debugger;
    $D = G&E:'hC s&dos -1';
    if (D) {
        $ar = G&F:D,'s&dos peel:way:@m';
        ~>3 dos: ar.way
        ar.e = e;
        ar.c = D;
        G&way,ar.way,ar;
        return T.el = 1;
    }
    else {
        
    }
    #debugger;
    #1s&M.push("Anteract: "+4s&ki(C,3));
    
SwitchupEl: | # tweak Elemental bitology
    $find = m.shift();
    find.slice(0,1) == '4' and find = A.4.sc[find.slice(1)]
    $adjust = m.shift();
    $property = m.shift();
    $between = m.shift().split('/');
    $el = $(find);
    !el and throw "Nofind "+find;
    $now = el[adjust](property);
    $i = 0;
    while (between[0] != now) {
        between.push(between.shift());
        i++ > between.length and throw "Didnt start with any of "+ki(between);
    }
    between.shift();
    $next = between.shift();
    el[adjust](property, next);
t/JSTesti: | # test the JS bits
    # how does it work?
    # a bunch of timers?
    # C-ing
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Thumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
MelTest: |
    u js
    n \'of:n'
    
    jela 53:
        s&fs = (15 * s)+'%';
    
NutTal: | # speak of W
    u j
    n \'of:eye'
    # n usual title in J6
    # should t s be a ki of the J?
    heading:
        $Hz = 5;
        s == 'Hz:50' and Hz = 50; s = '';
        G&jam,Hz and throw "jamming", A.1;
        
        $size = A.1 == A.3 ? "200" : "150";
        $n = G&n,['t',0.01,{s:A.1.t},{ab:1,blr:'2px',zi:-20}];
        ns&fs = size+'%';
        ns&mt = '-0.5em';
        
        $r = 1s&root;
        rs&mt = '1em';
        
        rs&dis = 'block';
        rs&width = '50%';
        
        if (s) {
            if (s == '55') {
                rs&left = '50%';
                rs&width = '100%';
                rs&ab = '1';
            }
            else {
                throw "unknown heading style", s
            }
        }
        
        1s&ein ||= {};
        1s&ein.click = {w:'einclick'};
        
        1s&M ||= [];
        
        return n
    
    
    
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];

