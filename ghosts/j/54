Door: |
    # interrogate process remotely
    
    # want to checklist/stepthrough the commersion
    # expect response in time or error
    # make a central error receiver ay T
    
    Rw Tiot;
    Rw GiveTime;
    my $to = 'Door';
    # returns result
    Js&ein.pi.res.sMJ = &sMJje{
        my $t = e.t || 'res';
        ($t,$s) = ('error',ec&error) if ec&error;
        $s = ec&data if ec&data;
        my $pi = 'od';
        if (my $f = ec&tape) {
            $s = G&Beach,$f;
            $s = $s->[0] if @$s == 1;
            $pi = ec&pie ||
                'adoc';
        }
        m $t=>"-$pi"=>{dl=>5,s=>$s}
    };
    S
    Js&boels++ ||
    `rm -rf blank/sac_sc`;
    
    if (!@{Js&M||[]}) {
        # if no result yet
        if (-d "Gc&bay/p/Text") {
            # ask G:Text for its W
            my $code = q/
                my @Js;
                each t,cv,J 4s&Jtv {
                    my @yp;
                    each m,soJ,oJ Js&typed {
                        push @yp, $m ." by ". G&sn,$oJ;
                    }}
                    push @Js, join "\n", "$t $cv is:",map{" - $_"}@yp;
                }}
                \@Js;
            /;
            my $re = [get_types=>-eval=>{s=>$code,returnto=>'Door'}];
            Rw Wudder $to=Text $s:_ for [Doory=>$re];
        }
        else {
            # use G:Intrup to do something, it returns data...
            Rw Wudder $s=Intrup;
        }
    }
    else {
        n result=>2=>result=>dis
        y.n = 3;
        m $_ for @{Js&M};
    }
    
    
pi/siphier: | # piley log of things going mo 3
    s&fs = 8;
    
    # de-coda into C again
    my $top = Rw decoda $s;
    my $z = top.y.val;
    n odeppl=>-od=>{s=>$z};
    return;
    my @s = @$z;
    
    my $lev = {}; # masklen/[C]
    for (@s) {
        _s&sip || die "Somenotsip: ".ki$_;
        my $len = _c&len = split ' ', _s&sip;
        push @{ $lev.>$len ||= []}, $_;
    }
    
    my $lenind = {};
    for my $len (sort keys %$lev) {
        $lenind.>$len = keys %$lenind;
    }
    
    n t=>o1=>C.t=>dis
    n type=>o2=>'sip sn',dis
    
    #,ml:". $lenind.>_s&len 
    for (@s) {
        my $x = {%{_.sc}};
        my $sc;
        sc.dis = 1;
        if (my $type = delete x.isin) {
            sc.hs = (
                $type eq 's' ? '2' :
                $type eq 'u' ? '6' :
                die "Other isin type: $type"
            ).'86';
        }
        if (x.dec eq '6 from elvis') {
            delete x.dec;
            my $M = sc.z = [];
            m ise=>''=>"e",'ma:0.3,hs:458'
        }
        my $t = _.t;
        $t =~ s/\.Motor\.Howz$//;
        m _.t=>''=>{s=>"_s&sip    $t"},$sc
        delete x.sip;
        if (keys %$x) {
            my $sc = "dis,fs:8,hs:486";#,ml:". $lenind.>_c&len ;
            m _.t=>''=>{s=>ki $x},$sc
        }
    }
    
decoda: | # recode data from -coda C
    # some
    my $top;
    top.y.rw = {}; # refs -> $n/-coda non-9s
    top.y.mw = {}; # paths -> $n where meta 
    top.y.val = ss&sym eq '[' ? [] : {};
    my @s = ([$top,$s]);
    while (@s) {
        my ($u,$C) = map{@$_} shift @s; # C = -coda 9
        my $uv = u.y.val;
        # C implies cv=1 and two hemispheres
        (uv.y.cv, uv.c, uv.sc) = (0.1, {}, {}) if s&sym eq 'C';
        (uv.y, uv.c, uv.sc) = ($uv, {}, {}) if s&sym eq 'A' || s&sym eq 'J';
        for my $n (@{s&z||[]}) {
            my $k = n.t;
            my $v;
            if (ns&pi eq 'coda') {
                my $s = ns&z ->[0];
                $v = s.y.val = ss&sym eq '[' ? [] : {};
                s.y.path = (C.y.path || C.t).' '.n.t;
                push @s, [$C,$s];
            }
            elsif (ns&pi || ns&W) {
                die "Want to decoda C.t's ".ki $n;
            }
            else {
                if (ns&hs) {
                    my $path = C.y.path .':'. n.t;
                    top.y.mw.>$path = $n;
                    ns&gets = n.t;
                    next;
                }
                join('-',sort keys %{n.c}) =~ /^(el-)?s$/
                && join('-',sort keys %{n.sc}) eq ''
                || die "More to C.t's ".ki($n)."\n\n"
                  .join('-',sort keys %{n.c})
                  .' % '. join('-',sort keys %{n.sc});
                if (ns&sym eq 'ki') {
                    my $h = nc&s;
                    my $ha;
                    $ha.>$1 = $2 while $h =~ s/^ ?(\S+)=(.+?)( (\S+)=|$)/$3/;
                    ns&gets = 'vague' unless $ha && ki($ha) eq sc&s;
                    $v = $ha || $h;
                }
                elsif (ns&sym) {
                    die "Newsym: ns&sym  ".ki$n;
                }
                else {
                    $v = nc&s;
                }
            }
            1 && saybl "Putting u.t's(u.sc.sym) C.t's(s&sym) n.t's(ns&sym) ".ki $v;
            if (ref $uv eq 'ARRAY') {
                $uv->[$k] = $v;
            }
            else {
                $uv.>$k = $v;
            }
            top.y.rw.>$v = $n if ref $v;
        }
    }
    $top
    
pi/adoc: | # remote severalism
    Rw HaveDepth;
    y.at.ml = 0.4;
    y.at.dis = 1;
    s&dos = 'reCrank';
    if (ref $s eq 'HASH' && G&isC,$s) {
        my $s = G&hup,$s;
        if (my $z = delete ss&z) {
            # skip into the 9 if simple
            # FactorEase
            my $f = $z->[0] if @$z == 1;
            $f && delete(fc&el) && delete fc&Jo;
            $z = fs&z if $f && f.t eq C.t && f.y.cv == 0.9
                && !%{f.c} && keys %{f.sc} == 1 && fs&z;
            
            m _.t=>-adoc=>{s=>$_} for @$z;
        }
        
        my $t = s.t;
        my $cv = s.y.cv;
        $cv =~ s/^0\.//;
        
        n t=>o1=>{s=>$t}  ,'dos:Crank'
        n cv=>o2=>{s=>$cv}  ,'hs:384,fs:7'
        
        exists sc&s &&
        n s=>o3=>{s=>"sc&s"},'hs:483,fs:11,ma:0.2'
        
        my $sc = {%{s.sc}};
        delete sc.pi if sc.pi eq 'coda';
        keys %$sc &&
        n sc=>o4=>'% '.ki($sc),'hs:685,fs:7'
        
        Js&boost &&
        n t=>-od_6=>{dl=>1,s=>$s}
    }
    else {
        n _.t=>-od=>{s=>$s}
    }
reCrank: | # remote Crank
    $c = c.y.C;
    $s = cc&s;
    1 && saybl wdump 3, $s
Intrup: | # do experiments with sensors 
    Jc&save = Jc&tape = Jc&quiet = '7';
    Jc&imping = 1; # tape always in one wave
    # also take samples once
    unless (Js&bowls) {
        # the T setup
        Rw Intre;
        # used by the J45 sleepwaker
        4c&way_foursleep = 'FourSleep';
        # also captures what happens
        4s&foursleepy = Js&samples ||= [];
        0 &&
        G&elph,Trips=>[tripany=>$_] for &acgt{
            return if Js&bowls;
            my $sn = G&sn,$A;
            my $c = G&Ct,[$sn=>''=>{}=>{}];
            cs&sip = Ac&sip;
            # cs&upsn = G&sn,A.up;
            if (my $i = A.isinu && 0) {
                push @{is&z||=[]}, $c;
            }
            else {
                push @{Js&samples||=[]}, $c;
            }
            if (A.2.t eq 'u' && 2c&is eq 'mind') {
                # collect the J hierarchy as flatlist on this record
                A.isinu = $c;
                cs&is = 'mind';
            }
        };
        n TMinding
    }
    Js&bowls++;
    
    S
    
    my $i =
    n inter=>-coda=>{dl=>4,tape=>1,s=>Js&samples}
    my $j = is&J;
    my $f = js&output_file || die "Nofile: ".G&sn,$j;
    
    my $to = 'Door';
    my $s = [$to=>[Intrup=>-res=>{tape=>$f,pie=>'siphier'}]];
    Rw Wudder $to $s;
    
    saygr "Yeup";
    #exit;
    
    
    
Intre: | # what T sets up for I res
    # the 5 has in and out trays
    5s&z && die "Double z";
    # is now (5 readying) mapped for names to resolve there
    5s&z =  [
        # place to thaw u from
        G&e,sac=>-mine=>{}=>'implies:thaw,if:A-clusping' ,
        
        # posit for sac all other u things?
        G&e,sac_sc=>-mine=>{}=>'otherwise:use,if:A-clusping' ,
        
        # to continue
        G&e,gou=>-mine=>{}=>'implies:resume' ,
        
        # default write location
        G&e,neu=>-mine=>{}=>'implies:write' ,
    ];
    # name in gou/neu causes resuming/writing where it needn't
    # most taped things will flop into neu, being last
    # most gou
    # and should give path up to toplevel? HaMachine
    return;
    my @tvs = [map{
        "_.t = ".ki _s&J.sc.top.sc.z;
    }@{5s&z}];
    n glop=>-od=>{s=>\@tvs}
    
pi/mine: | # worded place
    my $f = "Gc&bay/$s";
    -d $f || return s&empty = 1;
    
    m $_=>''=>{} for split "\n", ''.`ls -1 $f`;
    #Rw pi/listle;
TMinding: |
    Rw Tiot;
    u Minding
    S
    n oy=>2=> G&vangal,'lips' ,dis
    n douk=>-od_3=>{s=>A.I.mo}
    
Minding: |
    u c
    W 2: %of:mo
        # look for W in 5/permitted places...
        1 && sayyl "Leka ".ki $C;
    u i
    vangal:
        "Placed $s"
pi/coda: | # convey data
    # default hash
    y.at.sym = '[' if ref $s eq 'ARRAY';
    Rw HaveDepth;
    Rw MayC;
    c&path = join'/',grep{defined}2Cc&path,C.t;
    3c&refs.>$s = $C if ref $s;
    c&left = c&dl - c&depth;
    
    if (!Js&boost) {
        if (c&isA && c&left < 2) {
            y.at.sym = s.1 eq $s ? 'J' : 'A';
            n sn=>''=>G&sn,$s  
            n sip=>''=>sc&sip
            return
        }
        if (c&isC && c&left < 4) {
            y.at.sym = 'C';
            n t=>''=>{s=>s.t}
            s.y.cv && s.y.cv != 0.1 &&
            n y_cv=>''=>{s=>s.y.cv}
            for my $k ('c','sc') {
                my $v = $s.>$k;
                if (!keys %$v) {
                }
                elsif (grep{ref}values%$v) {
                    m $k=>-coda=>{s=>$v}
                }
                else {
                    n $k=>4=>{s=>ki $v},{sym=>'ki',elabo=>5}
                }
            }
            return
        }
    }
    
    Rw Fromany;
Fromany: |
    return s&toomany = 'overall' if 
        3Cc&intl++ > 3Cc&intlim;
    
    if (ref $s eq 'ARRAY') {
        c&isarray = 1;
        c&vs = [@$s];
        c&ks = [0..(@$s-1)];
    }
    
    my ($hash,@ks) = Rw HashKs;
    my $limit = 60;
    my $lim = @ks > $limit;
    my $was = @ks;
    @ks = @ks[0..($limit-1)] if $lim;
    
    my $pi = c&pi || 'od';
    for (@ks) {
        my $S = $hash.>$_;
        if (!ref $S) {
            m $_=>''=>{s=>$S}
        }
        elsif (my $O = $S eq $s && '.' || 3c&refs.>$S ) {
            m $_=>''=>{}=>{sameas=>ref $O ? Oc&path : $O}
        }
        elsif (my $block = $_ eq 'I' && 'I' || c&depth > c&dl && "deep") {
            m $_=>''=>{}=>{block=>$block}
        }
        else {
            m $_=>''=>{pi=>$pi,s=>$S};
        }
    }
    
    $lim && 
    m limited=>''=>"limit: $limit < $was",'hs:888'
FourSleep: | # J entry/sleep decision
    # all sorts of policy...
    # restart osc once this piece adds to mo J 45
    1s&fourslept++ || 1c&imping++;
    
        # A mo sensors, sticks on the J
        my $sn = G&sn;
        my $c = G&Ct,[$sn=>''];
        cs&sip = Ac&sip;
        1s&mosen = $c;
            

        # < should happen if Js&ein known too
        A&want.elvis ||= 6 if A&E;
    
        my $isu = A.up.t eq 'clusping';
        A.clusping = A.up if $isu;
        $isu = 1 if A.clusping;
        if ($isu) {
            cs&isin = 'u';
            # first W layer below u-ing/clusping
            cs&Clookslike = G&aC,$C if A.up.t eq 'clusping';
        }
        if (A.up.t eq 's') {
            cs&isin = 's';
            # cs&labe = join ' ', sort keys %{A.up};
        }
        push @{4s&foursleepy}, $c;
        
        # not for osc positing content of hyper-W (Swim/We)
        return if cs&isin eq 's';
        
        # the A.3 figures some storage relationship
        A.1 eq A.3 &&
            Rw FourStorage;
        
        #saygr " must_save_in = A&must_save_in" if A&must_save_in;
        saygr " may_save_in = A&may_save_in" if A&may_save_in;
        saygr " thaw = ".G&aC,A&thaw if A&thaw;
        
        # point in mo to skip to
        my $cv;
        
        if (my $r = A&thaw) {
            my $f = r.y.five;
            if (my $R = 1c&thaw) {
                my $F = R.y.five;
                if (fs&ha eq Fs&ha) {
                    A&want.thaw_same = -6;
                }
                else {
                    A&want.thaw_diff = 6;
                }
            }
        }
        
        
        # desire to wake comes from many places
        desire_to_wake: my $de;
        de.mo = A&want if A&want;
        de.C = c&want if c&want;
        de.J = 1c&want if 1c&want;
        
        
        if (!$de) {
            return; # continues without thinking
        }
        my $des = "C.t C.y.cv ".G&sn,3 ." -> ".ki $de;
        
        # want.* is weight if numeric, explanation if ref
        my $eq;
        my @got;
        each ftc $de {
            next if ref $c;
            push @got, $t;
            $eq += $c;
        }}
        my $only = $got[0] if @got == 1;
        
        # want to add counterpoints
        # everything eventually sleeps way/u/W stuff
        cs&dec = "$eq from @got";
        sayyl "HAving decided:  ".G&sn ."    cs&dec";
        @got > 1 && die "Getting complicated: cs&dec";
        
        A&thaw &&
            Rw FourThaw;
        
        if ($eq < 0) {
            $only eq 'once' ||
                saybl "Sleep $eq   $des";
            # we can skip 6, keep ground
            # our mo C should be re-put from before
            
            # do 7/osc/s if thaw-ing new
            sayre "Sleeping thaw" if A&thaw;
            
            my $to = 8; #$eq < -6 ? '8' : '7';
            T.Z.>$to = $A;
        }
        else {
            # FactorEase 
            keys %$de == 1 && de.mo && keys %{de.mo} == 1 && de.mo.elvis eq '6'
            ||
            saygr "Waker $eq   $des";
        }
        
        
FourThaw: |
    my $r = A&thaw;
    sayyl "Want to thaw: ".G&aC,A&thaw;
            # takeover ground/page ?
            my $ch = '';
            1s&grounds.>$ch = A.ground = G&Ct,[$ch=>1=>{},{J=>s&J}];
FourStorage: | # collaborate thing with the Wall
        my $g;
        my $mode;
        my $o;
        my @search = @{5s&z||[]};
        while (@search) {
            my $D = shift @search;
            # FactorEase 
            # also Scuttle modey sc (implies,etc) moC (D) -> 9 (d)
            my $d = Ds&J.sc.top if Ds&J;
            # is the name pool
            if (Ds&if) {
                if (Ds&if =~ /^A-(.+)$/) {
                    $A.>$1 || next;
                }
                else {
                    die "Unko if: ".ki $D;
                }
            }
            # is the name
            $o = d.y.tw.>C.t;
            if ($mode = Ds&otherwise) {
                # combined with if for default in that condition
                # begin planting u in sac_sc
            }
            elsif (!$o && @search) {
                next;
            }
            else {
                $mode = Ds&implies
            }
            $g = D.t;
            last;
        }
        
        # mode:
        # thaw - skip 6 and replant osc
        #   thing's updates are managed by another
        # use - thaw with w/W dependance checking
        #   thing is random cachement not yet managed by other
        #   as in sac_sc's random u things heading to sac's our u things
        # resume - replant osc and do 6, continuing the log
        #   as if in running sequence
        # write - do 6 with a fresh osc, restarting the log
        my $r;
        if ($mode eq 'thaw' || $mode eq 'use' || $mode eq 'resume') {
            $r = Rw LowCat $g $t:C.t;
        }
        my $K = {}; # tw 5 cache
        r.y.five = $K.>C.t ||= Rw LowCat $g $t:C.t 5 if $r;
        
        if ($mode eq 'thaw') {
            # read file, trust its state
            # skip 6, replant osc
            A&want.thaw = -6;
            Ac&thaw = $r;
        }
        elsif ($mode eq 'use') {
            # check its state/5 w/W 
            # < W refs leaving the g or further
            my @check = C.t if $r;
            my $do = {}; # tw need update
            $do.>C.t = 1 if !@check;
            while (@check) {
                my $t = shift @check;
                my $f = $K.>$t ||= Rw LowCat $g $t 5;
                if (!$f) {
                    $do.>$t = 1;
                    next;
                }
                saybl "HAving f: ". G&ind,$f,'aC';
                if (my $w = f.y.tw.w) {
                    for my $w (@{ws&z}) {
                        my $y = G&wops,w.t;
                        if (ws&dige ne ys&dige) {
                            saybl "Way diff $t's w.t";
                            $do.>$t = 1;
                        }
                    }
                }
                if (my $W = f.y.tw.W) {
                    for my $W (@{Ws&z}) {
                        my $y = $K.>$t ||= Rw LowCat $g $t:W.t 5;
                        if (Ws&ha ne ys&ha) {
                            saybl "Wormhole diff $t's W.t";
                            $do.>$t = 1;
                        }
                        push @check, W.t; # Wecursively
                    }
                }
            }
            
            if (!keys %$do) {
                A&want.use = -6;
                A&thaw = $r;
            }
            else {
                my $tr = join', ',sort keys %$do;
                saybl "Continuing C.t because of $tr" if $tr ne C.t;
                A&want.use = 5;
                A&must_save_in = $g;
            }
            # read file, 
            #   plant T to refresh bits if changes
            #   skip 6, replant osc
        }
        elsif ($mode eq 'resume') {
            # replant osc, do 6
            A&want.resume = 5;
            Ac&thaw = $r;
        }
        elsif ($mode eq 'write') {
            if ($o) {
                # save required
                # Scuttle some T from last save 8
                # alternate-history linkage
                A&must_save_in = $g;
            }
            else {
                A&may_save_in = $g;
            }
        }
        

