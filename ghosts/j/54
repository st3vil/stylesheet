Door: |
    # interrogate process remotely
    Rw Tiot;
    Rw GiveTime;
    my $to = 'Door';
    # returns result
    Js&ein.pi.res.sMJ = &sMJje{
        my $t = e.t || 'res';
        ($t,$s) = ('error',ec&error) if ec&error;
        $s = ec&data if ec&data;
        my $pi = 'od';
        if (my $f = ec&tape) {
            $s = G&Beach,$f;
            $s = $s->[0] if @$s == 1;
            $pi = 'adoc'
        }
        m $t=>"-$pi"=>{s=>$s}
    };
    S
    if (!@{Js&M||[]}) {
        if (-d "Gc&bay/p/Text") {
        my $code = q/
            my @Js;
            each t,cv,J 4s&Jtv {
                my @yp;
                each m,soJ,oJ Js&typed {
                    push @yp, $m ." by ". G&sn,$oJ;
                }}
                push @Js, join "\n", "$t $cv is:",map{" - $_"}@yp;
            }}
            \@Js;
        /;
        my $re = [get_types=>-eval=>{s=>$code,returnto=>'Door'}];
        Rw Wudder $to=Text $s:_ for [Doory=>$re];
        }
        else {
            Rw Wudder $s=Intrup;
        }
    }
    else {
        n result=>2=>result=>dis
        y.n = 3;
        m $_ for @{Js&M};
    }
    
    
pi/adoc: | # remote severalism
    Rw HaveDepth;
    y.at.ml = 0.4;
    y.at.dis = 1;
    s&dos = 'reCrank';
    if (ref $s eq 'HASH' && G&isC,$s) {
        my $s = G&hup,$s;
        if (my $z = delete ss&z) {
            m _.t=>-adoc=>{s=>$_} for @$z;
        }
        my $t = s.t;
        my $cv = s.y.cv;
        $cv =~ s/^0\.//;
        
        n t=>o1=>{s=>$t}  ,'dos:Crank'
        n cv=>o2=>{s=>$cv}  ,'hs:384,fs:7'
        
        exists sc&s &&
        n s=>o3=>{s=>"sc&s"},'hs:483,fs:11,ma:0.2'
        
        my $sc = {%{s.sc}};
        delete sc.pi if sc.pi eq 'coda';
        keys %$sc &&
        n sc=>o4=>'% '.ki($sc),'hs:685,fs:7'
        
        Js&boost &&
        n t=>-od_6=>{dl=>1,s=>$s}
    }
    else {
        n _.t=>-od=>{s=>$s}
    }
reCrank: | # remote Crank
    $c = c.y.C;
    $s = cc&s;
    1 && saybl wdump 3, $s
Intrup: |
    Jc&save = Jc&tape = Jc&quiet = '7';
    Jc&imping = 1; # tape always in one wave
    unless (Js&bowls) {
        G&elph,Trips=>[tripany=>$_] for &acgt{
            return if Js&bowls;
            push @{Js&samples}, $A;
        };
        n Stylands
    }
    Js&bowls++;
    
    S
    
    my $i =
    n inter=>-coda=>{tape=>1,s=>Js&samples}
    my $j = is&J;
    my $f = js&output_file || die "Nofile: ".G&sn,$j;
    
    my $to = 'Door';
    my $s = [$to=>[Intrup=>-res=>{tape=>$f}]];
    Rw Wudder $to $s;
    
    saygr "Yeup";
    exit;
    
    
pi/coda: | # convey data
    Rw HaveDepth;
    Rw MayC;
    c&path = join'/',grep{defined}2Cc&path,C.t;
    3c&refs.>$s = $C;
    c&left = c&dl - c&depth;
    
    if (!Js&boost) {
        if (c&isA && c&left < 2) {
            n sn=>''=>G&sn,$s  
            return
        }
    }
    
    Rw Fromany;
Fromany: |
    return s&toomany = 'overall' if 
        3Cc&intl++ > 3Cc&intlim;
    
    if (ref $s eq 'ARRAY') {
        c&isarray = 1;
        c&vs = [@$s];
        c&ks = [0..(@$s-1)];
    }
    
    my ($hash,@ks) = Rw HashKs;
    my $limit = 30;
    my $lim = @ks > $limit;
    my $was = @ks;
    @ks = @ks[0..($limit-1)] if $lim;
    
    my $pi = c&pi || 'od';
    for (@ks) {
        my $S = $hash.>$_;
        if (my $O = $S eq $s && '.' || 3c&refs.>$S ) {
            m $_=>''=>{}=>{sameas=>ref $O ? Oc&path : $O}
        }
        elsif (my $block = $_ eq 'I' && 'I' || c&depth > c&dl && "deep") {
            m $_=>''=>{}=>{block=>$block}
        }
        else {
            m $_=>''=>{pi=>$pi,s=>$S}
        }
    }
    
    $lim && 
    m limited=>''=>"limit: $limit < $was",'hs:888'
Doory: |
    #Rw Tiot;
    Js&ein.pi.eval.sMJ = &sMJje{
        my $s = eval $s;
        my $err = $@ if $@;
        m Jtv=>''=>{s=>$s}
        if (my $to = ec&returnto) {
            my $c = {};
            if ($err) {
                c.error = $err;
            }
            else {
                c.data = $s
            }
            my $s = [$to=>[e.t=>-res=>$c]];
            Rw Wudder $to $s;
            exit; # if we forked for this input
        }
    };
    S
    
    n on=>o1=>G.t,dis
    
    #m $_ for @{Js&M};
    
    

