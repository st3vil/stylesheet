Door: |
    # interrogate process remotely
    
    # want to checklist/stepthrough the commersion
    # expect response in time or error
    # make a central error receiver ay T
    
    Rw Tiot;
    Rw GiveTime;
    my $to = 'Door';
    # returns result
    Js&ein.pi.res.sMJ = &sMJje{
        my $t = e.t || 'res';
        ($t,$s) = ('error',ec&error) if ec&error;
        $s = ec&data if ec&data;
        my $pi = 'od';
        if (my $f = ec&tape) {
            $s = G&Beach,$f;
            $s = $s->[0] if @$s == 1;
            $pi = ec&pie ||
                'adoc';
        }
        m $t=>"-$pi"=>{dl=>5,s=>$s}
    };
    S
    
    # to check that null -> undef
    my $t = 'al4noJ';
    my $s = Rw Beach $f=blank/sac/jc/1 $s=0 $V=0;
    #n $t
    n als=>-od=>{s=>$s->[0]}
    return;
    
    #Rw Doorin;
    #my $s = Rw LowCat $g=sac_sc $t=Minding 5;
    # Minding=>-od=>{s=>[ G&ind,$s,'aC' ] };
    
    #return;
    Js&boels++ || 1 ||
    `rm -rf blank/sac_sc`;
    
    if (!@{Js&M||[]}) {
        # if no result yet
        #delete 1c&tape;
        if (-d "Gc&bay/p/Text") {
            # ask G:Text for its W
            my $code = q/
                my @Js;
                each t,cv,J 4s&Jtv {
                    my @yp;
                    each m,soJ,oJ Js&typed {
                        push @yp, $m ." by ". G&sn,$oJ;
                    }}
                    push @Js, join "\n", "$t $cv is:",map{" - $_"}@yp;
                }}
                \@Js;
            /;
            my $re = [get_types=>-eval=>{s=>$code,returnto=>'Door'}];
            Rw Wudder $to=Text $s:_ for [Doory=>$re];
        }
        else {
            # use G:Intrup to do something, it returns data...
            Rw Wudder $s=Intrup;
        }
    }
    else {
        n result=>2=>result=>dis
        y.n = 3;
        m $_ for @{Js&M};
    }
    
    
pi/adoc: | # remote severalism
    Rw HaveDepth;
    y.at.ml = 0.4;
    y.at.dis = 1;
    s&dos = 'reCrank';
    if (ref $s eq 'HASH' && G&isC,$s) {
        my $s = G&hup,$s;
        if (my $z = delete ss&z) {
            # skip into the 9 if simple
            # FactorEase
            my $f = $z->[0] if @$z == 1;
            $f && delete(fc&el) && delete fc&Jo;
            $z = fs&z if $f && f.t eq C.t && f.y.cv == 0.9
                && !%{f.c} && keys %{f.sc} == 1 && fs&z;
            
            m _.t=>-adoc=>{s=>$_} for @$z;
        }
        
        my $t = s.t;
        my $cv = s.y.cv;
        $cv =~ s/^0\.//;
        
        n t=>o1=>{s=>$t}  ,'dos:Crank'
        n cv=>o2=>{s=>$cv}  ,'hs:384,fs:7'
        
        exists sc&s &&
        n s=>o3=>{s=>"sc&s"},'hs:483,fs:11,ma:0.2'
        
        my $sc = {%{s.sc}};
        delete sc.pi if sc.pi eq 'coda';
        keys %$sc &&
        n sc=>o4=>'% '.ki($sc),'hs:685,fs:7'
        
        Js&boost &&
        n t=>-od_6=>{dl=>1,s=>$s}
    }
    else {
        n _.t=>-od=>{s=>$s}
    }
reCrank: | # remote Crank
    $c = c.y.C;
    $s = cc&s;
    1 && saybl wdump 3, $s
Intrup: | # do experiments with sensors 
    Jc&save = Jc&tape = Jc&quiet = '7';
    Jc&imping = 1; # tape always in one wave
    # also take samples once
    unless (Js&bowls) {
        # the T setup
        #Rw Intre;
        # used by the J45 sleepwaker
        #4c&way_foursleep = 'FourSleep';
        # also captures what happens
        4s&foursleepy = Js&samples ||= [];
        0 &&
        G&elph,Trips=>[tripany=>$_] for &acgt{
            return if Js&bowls;
            my $sn = G&sn,$A;
            my $c = G&Ct,[$sn=>''=>{}=>{}];
            cs&sip = Ac&sip;
            # cs&upsn = G&sn,A.up;
            if (my $i = A.isinu && 0) {
                push @{is&z||=[]}, $c;
            }
            else {
                push @{Js&samples||=[]}, $c;
            }
            if (A.2.t eq 'u' && 2c&is eq 'mind') {
                # collect the J hierarchy as flatlist on this record
                A.isinu = $c;
                cs&is = 'mind';
            }
        };
        n TMinding
    }
    Js&bowls++;
    
    S
    
    
    
    my $i =
    n inter=>-coda=>{dl=>4,tape=>1,s=>Js&samples}
    my $j = is&J;
    my $f = js&output_file || die "Nofile: ".G&sn,$j;
    
    my $to = 'Door';
    my $s = [$to=>[Intrup=>-res=>{tape=>$f,pie=>'foursleepier'}]];
    Rw Wudder $to $s;
    
    saygr "Yeup";
    #exit;
    
    
    
TMinding: | # TTTTTTTTTTTTTTTTTTTTTTTTTTT run
    Rw Tiot;
    u Minding
    S
    n oy=>2=> G&vangal,'lips' ,dis
    n douk=>-od_3=>{s=>A.I.mo}
    
Minding: |
    u c
    W 2: %of:mo
        # look for W in 5/permitted places...
        1 && sayyl "Leka ".ki $C;
    n Winding
Winding: |
    u i
    vangal:
        "Viritibi $s"
    

