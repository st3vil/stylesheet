ET: | # collecT after e how to refresh
    my $et = 3c&ET || die "noET";
    my $wayby = Rw ef/Bs $t=w 1;
    #$wayby = G&es;
    my $t = et.y.next ||= G&Ct:["after ".$wayby =>''];
    tc&s ||= G&es;
    
    # 
    # 1c&ET &&
    # Rw ET + $wake 2;
    my ($n,$huh) = @{ar.m};
    t.y.cv = "0.$n";
    
    my $wake = ar.wake || [];
    $wake = [$wake] if ref $wake ne 'ARRAY';
    
    if ($n eq '2') { # wake to the smallest j we visited
        if ($J ne $j) {
            push @$wake, $j;
        }
    }
    elsif ($n eq '1') { # wake probably (not definitely) nothing
    }
    else {
        die "What doing?".
        G&give:Budge=>[el=>''=>{s=>[$ar]}];
    }
    
    for my $J (@$wake) {
        my $z;
        z.t = Rw fe/upJpath $J;
        # note what way it came from
        zs&wayby = $wayby;
        push @{ts&z||=[]}, $z;
    }
ETsl: | # mo considers waking up about 4/5
    A.1 eq A.3 && return
        Rw FourSleep;
    # if some clues, sleep
    
    my $r = 3c&TE; # the/one's results
    my $M = rs&z ||= [];
    
    my $R = 1c&TE = # our results
    m A.1.t=>''
    my $M = Rs&z ||= []; # random talkylines
    
    my $p = 2c&ET; # parent/many's expectation
    my $t = A.1.t; # us as a name
    my $l; # our expectation, with t:
    
    my @z = grep{$_} map {
        _.t =~ /^\Q$t\E$/ ? do {
            $l = $_;
            0
        } :
        # shortens their t when in here, keeping y/c/sc
        _.t =~ /^\Q$t\E;?(.*)?$/ ? do {
            my $hash = {%$_,t=>$1};
        } : undef; # not here
    } @{ps&z||[]};
    
    ls&unspec = 1 if !$l; # may not know (may still have @z)
    ls&J = A.1; # our expectation knows us
    ps&last = $l; # it can follow itself up as the next sibling
    Rs&l = $l; # 1c&TE (R) knows ~ 1c&ET
    
    # skip if l is specific enough:
    if (@z && !ls&unspec) {
        die "self and other";
    }
    elsif (@z) {
        # for others
        ls&z = \@z;
        lc&want.children = 5; # wake for someone
        lc&theyllknow = 1;
        m inside=>''=>{}=>'count:'.@z
    }
    elsif (!ls&unspec) {
        m awake=>''=>{s=>$l}
    }
    else { # ls&unspec, not if @z (or $l) was found
        # (osc needed any time @zward changes)
        if (pc&theyllknow) { # but we dont
            # a sibling is awake
            lc&want.dunno = -5;
        }
    }
        
    #push @{rs&z}, "1c&sip A.1.t --> ".G&aC,$_ for @z;
    if (lc&want) {
        c&want && die "Merge wants";
        c&want = lc&want;
    }
    
    Rw FourSleep;
    
    Rc&s = a&J_awake ? 'wake' : 'sleep';
    Rs&sip = 1c&sip;
    Rs&pi = s&pi if s&pi ;
    Rs&dec = a&dec;
    
    # hook M with many of this function too
    # if the first group of -pis are still the rest can sleep?
IET: | # singularly you ET
    A.1 eq A.3 || die "Be W";
    my $et = 3c&ET;
    
    # the map to use this time
    my $l = 3c&ET = et.y.next || {};
    
    # to what will be
    my $r = 3c&TE = {};
    
    # should A.3 local...
    4c&way_foursleep = 'ETsl';
    
    # to show what it went in with
    my $M = Gs&follow ||= [];
    my $i = ++Js&IETs;
    m A.1.t=>''=>{}=>{i=>$i,l=>$l,r=>$r,J=>A.1,mo=>$A}
    
    
    G&timer,0.2,$_ for &{
    #G&give:Budge=>[edoddl=>''=>{dl=>4,s=>[$t,$r]}];
    };
TEing: | # prove ET
    Rw Tiot;
    Rw GiveTime;
    my $c =
    n TEer
    
    
SeeTEer: |
    Rw Tiot;
    Jc&es = delete Gs&follow if Gs&follow;
    my $s = Jc&es;
    my $i;
    m $i++=>-od=>{s=>$_} for @$s;
TEer: | # use ET
    Rw Tiot;
    Rw IET;
    Rw GiveTime;
    
    delete Js&M;
    Rw piFeedTape + $default=luf:-ETcet;
    
    
    G&timer,0.1,$_ for &{
        4s&toy->({to=>['SeeTEer']})
    };
pi/ETcet: |
    s&ma = 0.2;
    s&dos = 'ETvis';
    s&fs = s&fis if s&fis;
    delete Js&M;
    Rw piFeedTape;
    n nmow=>o4=>"/",'fs:5'
    n clock=>o5=>Js&bowls++,'fs:7'
    return if @$M;
    if (A.2 eq A.3) {
        n afresh=>9=>'*'=>'fs:33,ab'
        m go=>-ETcet
        m ja=>-ETcet
        m da=>-ETcet
        m fo=>-ETcet
        m la=>-ETcet
    }
    else {
        my $t = slm 6, dig $s;
        n t=>1=>$t=>'dos:ETvis'
        s&remote &&
        n four=>2=>s&remote;
    }
    
    _s&mix = 1 for @$M;
ETvis: |
    # use something... make this usual change to a j's mo C in j.2...
    my $K = Rw fe/J2C $J:j;
    Ks&fis ||= 20;
    Ks&fis++;
    
    G&give:Budge=>[ffffe=>''=>{dl=>1,s=>[[[j.2,$j]],[[$K,$c]]]}];
    
    my $wake = [];
    push @$wake, $j;
    1c&ET &&
    Rw ET + $wake 1;
    
    
    
    
fe/J2C: | # the C (now KC) in 2 that invoked 1
    # $C as in 1's pin, after tv'ing, so KC
    #   (KC is top, in style/compression but before refs like sJ get quieted out)
    # elvis wants to shoot changes at tv,
    #   which piFeedTape feeds back into 2's M
    my $j = J.2;
    my $M = Rw fe/fi $C:j stop sz;
    my @S = grep { _s&J eq $J } @$M;
    @S>1 && die "Extra bits! ".ki\@S;
    saybl "Found J.t in j.2: ".@S;
    wantarray ? @S : shift @S
    
    

