NutCertainty: |
    # and
NutConsciousness: |
    u j
    n \'of:eye'
    # pudding things on could...
    # < clean away use of the drain as the top C
    # < dome system composing them onto the root C directly...
    #   would expose useful tools for playing data...
    s: %acgt:c sc
        $A = G&Aye,'s',0,c,sc;
        
        $g = A.ground;
        
        # ground -> drain, so it can be resupposed
        # < keeping stuff on 9... replace 1s&root with the drained one?
        1s&drains ||= {};
        $d = 1s&drains[g.t] = 1s&drains[g.t] || G&Cye,g;
        $was = ds&z;
        ds&z = [];
        each iC gs&z {
            # C-form complete enough
            null == C.t || !C.y || !C.c || !C.sc and throw "nonC: "+4s&ki(C)
            # not what is not
            $Y = C.y.A;
            Y && (Yc&T.not || C.sc.not) and continue
            # not what is already
            $dup = 0;
            each iD ds&z {
                D == C and dup = 1
            }
            !dup and ds&z.push(C);
        }
        $r = 1s&root;
        !r and throw "how to hold many"
        
        # brain per ground, ongoing
        1s&brains ||= {};
        $C = A&s = 1s&brains[g.t] = 1s&brains[g.t] || G&Cye,[g.t,1,{},{J:A.1}];
        
        $diff = &di,ff,dd{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            each kv di {
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            }
            each kv ff {
                null == di[k] and wh.gone[k] = {};
            }
            each qua,k,ha wh {
                qua == 'same' and continue
                dd && dd.ignore == k and continue
                return 1
            }}
        };
        
        $la = s&top;
        $ltv = la && la.y.tv;
        $tw = r.y.tw = {};
        $tv = r.y.tv = {};
        rs&z = [];
        $lv = [];
        each iD ds&z {
            # put on tv, even 9/r
            tv[D.t] ||= {};
            tv[D.t][D.y.cv] = D;
            D != r and rs&z.push(D);
            
            # diff last C
            $L = ltv && ltv[D.t] && ltv[D.t][D.y.cv];
            L ||= {};
            $cha = diff(D.t,L.t)
                || diff(D.c,L.c||{})
                || diff(D.sc,L.sc||{},{ignore:'z'});
            
            !cha and continue
            
            # make patch/lv
            $s = G&Cye,D;
            s.y.OC = D;
            # limited
            sc&el = 1;
            lv.push(s);
        }
        # notice gone C
        if (la) {
            each iL las&z {
                tv[L.t] && tv[L.t][L.y.cv] and continue
                lv.push(G&Cye,[L.t,L.y.cv,{el:9}]);
            }
        }
        
        s&v ||= 0;
        $chsymb = '-'; # stillness?
        
        #c consequence change
        s&lv ||= [];
        if (lv.length) {
            s&v++;
            chsymb = '~';
            
            # the lv root is C for 1s&root
            $lr;
            each iD lv {
                D.y.OC == r and lr = D
            }
            # which may not be
            lr ||= G&Cye,[r.t,{cv:r.y.cv,OC:r},{el:3}];
            # contains everything else
            lrs&z = [];
            each iD lv {
                D.y.OC != r and lrs&z.push(D)
            }
            s&lv.push(lr);
        }
        
        s&top = r;
        
        # hangs brain up on the J
        1s&s = C;
        
        if (chsymb == '-') {
            ~>7 osc: A.1.t, chsymb, s&v
        }
        else {
            ~>3 osc: A.1.t, chsymb, s&v
        }

        
        if (s&lv.length > (s&readlv || 0)) {
            $lv = s&lv.slice(s&readlv || 0);
            s&readlv = s&lv.length;
            G&Hut,lv;
        }
        return C
    
    #c send lv to Hut, the contractor, have A.on already
    Hut: %acgt:lv
        for (var i = 0; i < lv.length; i++) {
            var v = lv[i];
            # recur W, where A.b starts
            $W = A.on.thing = A.on.thing || {};
            A.W = W;

            # do om, depth of A:n
            T.d = (T.oT && T.oT.d) + 1;
            $A = G&Aye,'om';
            A.om ||= A;
            A.om == A.up and A.mo = A;

            $C = G&Cye,v;
            C.y.A = A;

            A&T = T;
            G&thro,2,C;
            T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
            s&css ||= {};
            s&anc ||= {};
            G&thro,7;
        }

