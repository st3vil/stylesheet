NutCertainty: |
    # and
    u j
    n \'of:eye'
    # a functional guide to o
    #  produces a big Z, or N of all atoms (C), even those inside others
    # traverse! sweep into G&F
    # climb in/next/z of $s with a sub $y
    # returns big flat (Cora) list of the sub's returns
    # $y ||= &Cd{ $C }
    ind: %acgt:s y d
        $D = s;
        # setup
        d ||= {};
        if (!d.refs) {
            d.refs = []; # all things
            d.refid = {}; # those indices to d
        }
        y ||= &s{ return s }
        if (typeof y == 'string') {
            if (y.slice(0,2) == 'ki') {
                $dl = y.slice(2);
                y = &s{ return ki(s,dl) }
            }
            else { 
                throw "ind y named", y
            }
        }
        
        # dedupe (s always an Object)
        $ri = d.refs.indexOf(s);
        if (ri < 0) {
            ri = d.refs.push(s) - 1;
            d.refid ||= {};
            d.refid[ri] = d;
        }
        else {
            $od = d.refid[ri];
            # dupe seeing very interesting for -jod
            return;
        }
        
        if (d.hup) {
            # fills matched C.c with info about where it is
            # < a separate object, a map to the result of the map this is
            #d.infolate == null and d.infolate = 1;
            s = G&Cye,s;
            s.y.D = D;
        }
        
        $dd = &d{
            d = $.extend({},d);
            d.path = (d.path||[]).slice();
            return d
        };
        d = dd(d);
        d.s = s;
        d.path.push(s.t+' '+s.y.cv);
        d.ind == null and d.ind = '  ';
        # ^ accumulates on every depth's return of a string
        d.d ||= 0;
        d.d++;
        # depth limit vs depth
        d.dl && d.dl < d.d and return;
        
        $out = [];
        $one;
        $my = [];
        
        d.cbfirst and one = y(s,d)
        d.not and return
        d.nofurther and return one
        
        # )
        #c the ways to go deep, should be all? will dedup
        # user throws something on any way
        if (ss&z) {
            $z = ss&z.filter(&s{ return 1 && s });
            d.zort and d.zort(z,s,d);
            each iD z {
                out.push( G&ind,D,y,d );
            }
        }
        
        if (s.y.in) {
            out.push( G&ind,s.y.in,y,d );
        }
        
        if (s.y.tw) {
            each tD s.y.tw {
                out.push( G&ind,D,y,d );
            }
        }
        
        if (s.y.tv) {
            each tvD s.y.tv {
                out.push( G&ind,D,y,d );
            }}
        }
        
        out = out.filter(&s{ return 1 && s });
        # flatten a bit, G&ind returns js arrays
        $oute = []; 
        out.map(&s{
            s.constructor == Array ? 
                s.map(&s{ oute.push(s) })
            : oute.push(s)
        });
        out = oute;
        
        out = out.filter(&s{ return 1 && s }).map(&s{
            if (typeof s == 'string')
                return s.split("\n").map(&s{ return d.ind+s }).join("\n")
            
            if (typeof s.constructor == Object) {
                if (d.infolate) {
                    if (!sc&ind) {
                        # (once) write where things are
                        # on the things themselves
                        sc&ind = d.d;
                        sc&inds = '';
                        $i = 0; # to d.d==1 for the first level
                        while (i++ < d.d)
                            sc&inds += '  ';
                        sc&inside = d.path;
                    }
                }
                my.push(s);
            }
            return s
        });
        
        if (s.y.next && !d.nonext) {
            $od = dd(d);
            od.path.pop();
            od.d--;
            out.push( G&ind,s.y.next,y,od );
        }
        
        !d.cbfirst and one = y(s,d)
        d.not and return
        out.unshift(one);
        
        out = out.filter(&s{ return 1 && s });
        !out.length and return
        $retrefs = out.filter(&s{ return typeof s != 'string' }).length > 0;
        
        if (d.d == 1 && !retrefs) {
            d.wantarray and return out
            return out.join("\n");
        }
        else {
            # an N with insidenesses, has been organised, located...
            # put insides (s&z,yin) in a z on the outside
            my.length && typeof one == Object and ones&z = my
            # return every C in N, each G&ind leaves [] to dissolve
            $flat = [];
            each is out {
                s.constructor != Array and flat.push(s); continue
                each IS s {
                    flat.push(S);
                }
            }
            return flat
        }
        
NutConsciousness: |
    u j
    n \'of:eye'
    
    #c send lv to Hut, the contractor, have A.on already
    # ! will this get confused when lv > 1?
    Hut: %acgt:lv
        for (var i = 0; i < lv.length; i++) {
            var v = lv[i];
            # recur W, where A.b starts
            $W = A.on.thing = A.on.thing || {};
            A.W = W;

            # do om, depth of A:n
            T.d = (T.oT && T.oT.d) + 1;
            $A = G&Aye,'om';
            A.om ||= A;
            A.om == A.up and A.mo = A;

            $C = G&Cye,v;
            C.y.A = A;

            A&T = T;
            G&thro,2,C;
            T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
            s&css ||= {};
            s&anc ||= {};
            G&thro,7;
        }
    #c pudding things on could...
    # < clean away use of the drain as the top C
    # < dome system composing them onto the root C directly...
    #   would expose useful tools for playing data...
    s: %acgt:c sc
        $A = G&Aye,'s',0,c,sc;
        
        G&way,'SingConscious';
SingConscious: |
    # ert
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "manydomes"
        
        # ground -> drain, so it can be resupposed
        # < keeping stuff on 9... replace 1s&root with the drained one?
        1s&drains ||= {};
        $d = 1s&drains[g.t] = 1s&drains[g.t] || G&Cye,g;
        $was = ds&z;
        ds&z = [];
        $drain = &C{
            # C-form complete enough
            null == C.t || !C.y || !C.c || !C.sc and throw "nonC", C
            # not what is not
            C.sc.not and return
            $Y = C.y.A;
            Y && Yc&T.not and return
            if (c&dome) {
                $z = s&z;
                ~>28 Fou: C.t, ki(z,3)
                each iC z {
                    drain(C);
                }
                return
            }
            # not what is already
            ds&z.indexOf(C) < 0 and ds&z.push(C);
        };
        each iC gs&z {
            drain(C);
        }
        $r = 1s&root;
        !r and throw "how to hold many"
        
        #c brain per ground, ongoing
        1s&brains ||= {};
        $C = A&s = 1s&brains[g.t] = 1s&brains[g.t] || G&Cye,[g.t,1,{},{J:A.1}];
        C = G&Cye,C;
        
        $diff = &di,ff,dd{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            each kv di {
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            }
            each kv ff {
                null == di[k] and wh.gone[k] = {};
            }
            each qua,k,ha wh {
                qua == 'same' and continue
                dd && dd.ignore == k and continue
                return 1
            }}
        };
        
        $ltv = s&top && s&top.y.tv;
        $tw = r.y.tw = {};
        $tv = r.y.tv = {};
        rs&z = [];
        $lv = [];
        $la;
        each iD ds&z {
            # put on tv, even 9/r
            tv[D.t] ||= {};
            tv[D.t][D.y.cv] = D;
            tw[D.t] ||= D;
            D != r and rs&z.push(D);
            
            # expand/see into J
            if (Ds&J) {
                $J = Ds&J;
                $z = Js&s; # other s
                if (z) {
                    Ds&v = zs&v;
                    !Ds&v and throw "Joinnov", J
                }
            }
            
            # diff last C
            $L = ltv && ltv[D.t] && ltv[D.t][D.y.cv];
            L ||= {};
            $cha = diff(D.t,L.t)
                || diff(D.c,L.c||{})
                || diff(D.sc,L.sc||{},{ignore:'z'});
            
            !cha and la = D; continue
            
            # make patch/lv
            $s = G&Cye,D;
            s.y.OC = D;
            # limited
            sc&el = 1;
            # unlimited
            if (Ds&J && Ds&J.sc.s) {
                $J = Ds&J;
                $z = Js&s;
                !zs&lv and throw "Doesn't lv", z
                if (L.sc && Ls&v) {
                    # read backwards to last one we knew
                    $ov = zs&lv.slice();
                    while (1) {
                        $th = ov.shift();
                        !th and throw "Out of tape, version not found"
                        ths&v == Ls&v and break;
                        # < working back in time, stop at el=1
                    }
                    
                    sc&el = 3;
                    ss&z = ov;
                }
                else {
                    ss&z = zs&lv.slice();
                }
            }
            if (la && la != r && la != lv.slice(-1)[0]) {
                # there is a cursor, this moves it past something already there
                lv.push(G&Cye,[la.t,la.y.cv,{el:8}]);
            }
            lv.push(s);
            la = s;
        }
        # notice gone C
        if (ltv) {
            each tvD ltv {
                tv[t] && tv[t][v] and continue
                t == r.t && v == r.y.cv and ~>want9root: ki(tv,3)
                t == r.t && v == r.y.cv and continue
                lv.push(G&Cye,[t,v,{el:9}]);
            }}
        }
        
        s&v ||= 0;
        $chsymb = '-'; # stillness?
        
        #c consequence change
        s&lv ||= [];
        if (lv.length) {
            s&v++;
            chsymb = '~';
            
            # the lv root is C for 1s&root
            $lr;
            each iD lv {
                D.y.OC == r and lr = D
            }
            # which may not be
            lr ||= G&Cye,[r.t,{cv:r.y.cv,OC:r},{el:3}];
            lrs&v = s&v;
            # contains everything else
            lrs&z = [];
            each iD lv {
                D.y.OC != r and lrs&z.push(D)
            }
            s&lv.push(lr);
        }
        
        s&top = r;
        
        # applies oscillation/hangs brain up on the J
        1s&s = 1s&brains[g.t] = C;
        
        if (chsymb == '-') {
            ~>7 osc: A.1.t, chsymb, s&v
        }
        else {
            s&title = A.1.t+' '+s&v;
            1c&save and G&e,[1c&saver||'Savior'],['save','',{s:C,to:1c&save}]
            ~>2 osc: A.1.t, chsymb, s&v
        }

        # happens on Four s
        # is an escaping gas deal
        if (A.3 == A.1 && s&lv.length > (s&readlv || 0)) {
            $lv = s&lv.slice(s&readlv || 0);
            s&readlv = s&lv.length;
            G&Hut,lv;
        }
        return C
    

