NutCertainty: |
    # and
NutConsciousness: |
    u j
    n \'of:eye'
    
    #c send lv to Hut, the contractor, have A.on already
    # ! will this get confused when lv > 1?
    Hut: %acgt:lv
        for (var i = 0; i < lv.length; i++) {
            var v = lv[i];
            # recur W, where A.b starts
            $W = A.on.thing = A.on.thing || {};
            A.W = W;

            # do om, depth of A:n
            T.d = (T.oT && T.oT.d) + 1;
            $A = G&Aye,'om';
            A.om ||= A;
            A.om == A.up and A.mo = A;

            $C = G&Cye,v;
            C.y.A = A;

            A&T = T;
            G&thro,2,C;
            T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
            s&css ||= {};
            s&anc ||= {};
            G&thro,7;
        }
    #c pudding things on could...
    # < clean away use of the drain as the top C
    # < dome system composing them onto the root C directly...
    #   would expose useful tools for playing data...
    s: %acgt:c sc
        $A = G&Aye,'s',0,c,sc;
        
        G&way,'SingConscious';
SingConscious: |
    # ert
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "manydomes"
        
        # ground -> drain, so it can be resupposed
        # < keeping stuff on 9... replace 1s&root with the drained one?
        1s&drains ||= {};
        $d = 1s&drains[g.t] = 1s&drains[g.t] || G&Cye,g;
        $was = ds&z;
        ds&z = [];
        $drain = &C{
            # C-form complete enough
            null == C.t || !C.y || !C.c || !C.sc and throw "nonC", C
            # not what is not
            C.sc.not and return
            $Y = C.y.A;
            Y && Yc&T.not and return
            if (c&dome) {
                $z = s&z;
                ~>28 Fou: C.t, ki(z,3)
                each iC z {
                    drain(C);
                }
                return
            }
            # not what is already
            ds&z.indexOf(C) < 0 and ds&z.push(C);
        };
        each iC gs&z {
            drain(C);
        }
        $r = 1s&root;
        !r and throw "how to hold many"
        
        #c brain per ground, ongoing
        1s&brains ||= {};
        $C = A&s = 1s&brains[g.t] = 1s&brains[g.t] || G&Cye,[g.t,1,{},{J:A.1}];
        C = G&Cye,C;
        
        $diff = &di,ff,dd{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            each kv di {
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            }
            each kv ff {
                null == di[k] and wh.gone[k] = {};
            }
            each qua,k,ha wh {
                qua == 'same' and continue
                dd && dd.ignore == k and continue
                return 1
            }}
        };
        
        $ltv = s&top && s&top.y.tv;
        $tw = r.y.tw = {};
        $tv = r.y.tv = {};
        rs&z = [];
        $lv = [];
        $la;
        each iD ds&z {
            # put on tv, even 9/r
            tv[D.t] ||= {};
            tv[D.t][D.y.cv] = D;
            tw[D.t] ||= D;
            D != r and rs&z.push(D);
            
            # expand/see into J
            if (Ds&J) {
                $J = Ds&J;
                $z = Js&s;
                Ds&v = zs&v;
                !Ds&v and throw "Joinnov", J
            }
            
            # diff last C
            $L = ltv && ltv[D.t] && ltv[D.t][D.y.cv];
            L ||= {};
            $cha = diff(D.t,L.t)
                || diff(D.c,L.c||{})
                || diff(D.sc,L.sc||{},{ignore:'z'});
            
            !cha and la = D; continue
            
            # make patch/lv
            $s = G&Cye,D;
            s.y.OC = D;
            # limited
            sc&el = 1;
            # unlimited
            if (Ds&J) {
                $J = Ds&J;
                $z = Js&s;
                !zs&lv and throw "Doesn't lv", z
                if (L.sc && Ls&v) {
                    # read backwards to last one we knew
                    $ov = zs&lv.slice();
                    while (1) {
                        $th = ov.shift();
                        !th and throw "Out of tape, version not found"
                        ths&v == Ls&v and break;
                        # < working back in time, stop at el=1
                    }
                    
                    sc&el = 3;
                    ss&z = ov;
                }
                else {
                    ss&z = zs&lv.slice();
                }
            }
            if (la && la != r && la != lv.slice(-1)[0]) {
                # there is a cursor, this moves it past something already there
                lv.push(G&Cye,[la.t,la.y.cv,{el:8}]);
            }
            lv.push(s);
            la = s;
        }
        # notice gone C
        if (ltv) {
            each tvD ltv {
                tv[t] && tv[t][v] and continue
                t == r.t && v == r.y.cv and ~>want9root: ki(tv,3)
                t == r.t && v == r.y.cv and continue
                lv.push(G&Cye,[t,v,{el:9}]);
            }}
        }
        
        s&v ||= 0;
        $chsymb = '-'; # stillness?
        
        #c consequence change
        s&lv ||= [];
        if (lv.length) {
            s&v++;
            chsymb = '~';
            
            # the lv root is C for 1s&root
            $lr;
            each iD lv {
                D.y.OC == r and lr = D
            }
            # which may not be
            lr ||= G&Cye,[r.t,{cv:r.y.cv,OC:r},{el:3}];
            lrs&v = s&v;
            # contains everything else
            lrs&z = [];
            each iD lv {
                D.y.OC != r and lrs&z.push(D)
            }
            s&lv.push(lr);
        }
        
        s&top = r;
        
        # applies oscillation/hangs brain up on the J
        1s&s = 1s&brains[g.t] = C;
        
        if (chsymb == '-') {
            ~>7 osc: A.1.t, chsymb, s&v
        }
        else {
            s&title = A.1.t+' '+s&v;
            1c&save and G&e,[1c&saver||'Savior'],['save','',{s:C,to:1c&save}]
            ~>2 osc: A.1.t, chsymb, s&v
        }

        # happens on Four s
        # is an escaping gas deal
        if (A.3 == A.1 && s&lv.length > (s&readlv || 0)) {
            $lv = s&lv.slice(s&readlv || 0);
            s&readlv = s&lv.length;
            G&Hut,lv;
        }
        return C
    

