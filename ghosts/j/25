
Presentables: | # goals, desires
    # Expect:
    # get deps,
    #   prepare them before testing as sync as possible,
    # and as async,
    #   show how things alter as asyncs infest our attention
    
    # Thing of Expect, writing them
    #  grow a way watching the action
    #  with domes relating to restarting ability
    
    # Thinging in Expect v Tri:
    # edit Cs and Ts
    # push into a C, Ting down test cases
    
    # know what song was playing when things were typed in
    # virtual stylehouse
    
    # many G
    #  means many A.4 for now
    #  let them go at frequencies, for goals (complete J..)
    # J8 s interJ:
    #   part of completing J completes other J
    #   indexen, lv is a type of hoisting pooling something
    # indexen: of things
    # in-J creation should eminate from domes, unto the out-Js&Jtv
    #  and when dome/a J in it is disappearing, remove from this index of Jtv
    #   when not also projected from sisters/brothers
    #   and minor T note about clobbering
    # so the write-up-index, handles:
    # Swim: W Wt Wcv t cv = C
    # Jtv: Ct Ccv == J
    
    # tours through code:
    # - from error, context up to Jin and code back to src
    #  ! G&Ban doesn't know what line compile errors come from
    # - for any name
    # - EXP marked comments, about program experience
    # - TES marked comments, about changes doable once tested
    
    # have the wormhole going,
    #   W:screen1 can crash, refresh
    #   W:screen2 can keep playing the soundtrack
    #   W:screen1 can resume without altering the playback
    
    # for talk about how there's multiple people
    
    # stylehouse on a projector, camera films the whole scene
    # so it locates askew the stylehouse in the picture
    # and gently wraps a W:reality around W:screen1's *
    # which slowly skews W:screen1 out, film drifting into the filmed
    # then adds another W:reality, starts making a tunnel
    # and slows the last W:reality down to 100ms behind the first, etc
    
Domes: | # phil sections of stuff
    u j
    n \'of:eye'
    
    
    # S marks sections of pin/phase of consciousness
    # likely to mark out domes - might use goto
    # placed after handlers are set up and
    #  before handled stuff is rendered as the J
    # w/Doming or w/Duning
    
    # < A.ground is becoming the 9/A.r,
    #   who leaves out most of itself in Osc,
    #   but has all these universals...
    # Do@Doing@s+t and return 0
    # Do@Doing@s+t = what A&doming makes....
    # ra&Doing...
    S: %acgt:s t talk params
        G&clusp;
        A.e && G&thro,A.e,6;
        A&S and return A&S(s,t,talk,params)
        # sync progress to ground...
        $g = A.ground;
        !g and throw "groundless doming";
        $Do =
        gs&Doing ||= {};
        Do[s+t] and return 0
        Do[s+t] = 1;
        return 1



    # domes are the figurines of a Jplay
    # they import info, may have a J themselves
    #   be a model that vanishes as what matters goes into s
    #   be known as a piece of code 
    
    # supposedly these can be named and/or numbered,
    # presenting special cases and linear thought patterns,
    # such as responding to a situation, as s ideally will
    # and doing a sequence of steps for a test or so,
    # where the J is returning to itself
    # trying to progress domes each time,
    # some could be in parallel too...
    # or be gated by subroutines that
    #   (without the J infrastructure)
    # assess whether the situation has changed,
    #   eg has the nyA moved/aged...
    
    # we may want to index/toc the Sections, on the w
    # and assign sequence numbers? leave it to humans
    
    # the G&S should use A&S if present, as set up by:
    
    #   w/Doming - a sequential operati
    
    # wants redesigning to operate shuntable thought processess:
    #   w/Duning - compressed sands of time
    #     specifics on "most of it sleeps" realities,
    #     something to build Matu on
    # and allow J's universals to eminate from the dome it's up to
    # so that phases of the story can be told, shunted back to
    # providing 
    
    # G&S otherwise gives a moment to introspect
    #   after the head of the pin
    #     when elvis would have more info if creating the J
    # 
    
    # and then every a cachable wave of your data is grounded
    #   so each dome can be A:o'd to a point, to figure sleep
    #   then probably presents everything to G&s, as objects
    #   that are almost definitely asleep, or this bit awake, etc
    
    # anyway these are controlling chunks around them with whiles
    # var is function scoped, let is nowhere yet but won't work here
    # also, every n is like a chunk of S,
    # happening through a diferent interface:
    #   ground plop vs. pin progress
    
AndContinue: | # Jin stuff
    A = A.4.up;
    !A and throw "Where?";
    A = G&Aye,'Jin';
    # should go 2-5Hz? slider it
    G&jam and return
    $begins = G&time;
    $ki = 4s&ki;
    
    Gc&Continues ||= 1;
    Gc&Continues++;
    Gc&Continues > 33 and Gc&Continues = 0; G&waylay,'AndTidy';
    
    # Y means other A, from outside itself
    # bring back A that went async (Y)
    # Js&N=[Y+] and then also Ys&N=[Y+]
    #   getting attention to flow to what was using it
    
    # then venn diagram of waiting-n >< busy-u
    
    # a female J 8 introspector that demands J 6 action when ...
    
    #   female: the algebra of updatability
    #     u etc leaves traces of
    #     W versioning
    #   male: just find all the 1s&N
    #     A with desire to thro
    
    # full of variables, schemes, like how much to regroup by J/net
    # who created who, creation required for creation
    # like Matu, unify environmental/causal concerns
    
    # the use case is:
    #   (A:n) <- up A:clusping <- a&N (A:u) <- a&N (A:u')
    # thro'ing bracketed A from right to left, one per Jin
    # getting an A:n to continue
    
    # being the toplevel of everything calling back to an A,
    # which should be everything sooner or later...
    
    # < throw errors that bundles its arguments
    #   like a G&c that blows up, from the perspective of the caller
    
    # < make G&c objecty, truncate, click items
    #   even a J on a stable G...
    
    # < compressed notation for where/what it is from this A
    
    # < general dedupe/group operation:
    #     da (de|gr) (c sip|$func)
    $dedup_by_sip = &N,seen{
        seen ||= {};
        $M = [];
        each is N {
            !sc&sip and throw "Has no sip: "+i, s
            see = seen[sc&sip] = seen[sc&sip] || [];
            see.push(s);
            see.length == 1 and M.push(s);
        }
        return M;
    };
    # < use ki's es object so we can click into things
    $sa = &Y{
        return Y.t
    };
    
    # gather J with J&N
    $Js = [];
    # Five/Four should come (they were entered) first (also since cv=0.01)
    each tvJ 1s&Jtv {
        $N = Js&N;
        N && N.length and Js.push(J);
    }}
    
    !Js.length and return
    
    # persist a needs for each J
    1s&needs ||= {};
    $needs = [];
    # sip = [Y+] to dedup A and relieve from Js&N later
    $seen = {};
    each iJ Js {
        # persist so ready=0 and feedback loops can be ttl'd,
        #delete 1s&needs[J.t]; # TODO
        $n = 1s&needs[J.t];
        n && ns&J !== J and n = null;
        n = 1s&needs[J.t] = n || G&Cye,[J.t,''];
        needs.push(n);
        
        # falling - s&N A list in, s&M understanding for that A, clobber
        delete ns&was_trouble;
        ns&trouble and ns&was_trouble = ns&trouble; delete ns&trouble;
        
        # could care/prioritise dup A?
        ns&J = J;
        ns&N = dedup_by_sip(Js&N,seen);
    }
    
    #c away to order needs by elabourate infinity
    # all items resonate
    # simulate in A:s/osc in another G?
    
    # each need (n) has (sM) a bunch of matters,
    # containing (sY) the A that came out of ns&Js&N
    # it's free to move around and get complicated
    $kiM = {};
    each in needs {
        # add intel per Y
        ns&M and ns&oM = ns&M;
        ns&M = [];
        each iY ns&N {
            $m = G&Cye,[Y.t,'',{},{Y:Y}];
            
            if (!Yc&T) {
                # A never G&thro, climb up to something we can sequence
                $y = Y;
                while (y && !yc&T && y.up) {
                    y = y.up;
                }
                ms&Yfrom = Y;
                m.t = y.t+"<-"+m.t;
                Y = y
            }
            ms&Y = Y;
            ms&J = ns&J;
            ms&n = n;
            
            # compress by the look of C
            if (Y.t == 'n') {
                $s = ki(Yc&s);
                kiM[s] ||= [];
                kiM[s].push(m);
            }
            else {
                ns&M.push(m);
            }
        }
    }
    
    # one C per unique C
    # also puts A:n later
    each sL kiM {
        $m = L[0];
        $n = ms&n;
        ns&M.push(m);
        L.length == 1 and continue
        ms&Cdup = L.length;
        each iy L {
            # y: other m, see if same J
            ys&J == ns&J and continue
            ms&Joth ||= [];
            ms&Joth.push(ys&J);
        }
    }
    
    # one Y per Y
    # have already deduped by sip
    each in needs {
        each im ns&M {
            $Y = ms&Y;
            $L = seen[Yc&sip];
            if (!L) {
                $f = ms&Yfrom;
                !(f && seen[fc&sip]) and throw "Wherefrom?";
                L = seen[fc&sip]
            }
            L.length > 1 and ms&Ydup = L.length;
        }
    }
    
    # say what - how many points may have compressed
    each in needs {
        $J = ns&J;
        ns&say = [">37 "+J.t];
        $msay = [];
        each im ns&M {
            $s = m.t;
            ms&Ydup and s += '*'+ms&Ydup;
            ms&Cdup and s += '*C'+ms&Cdup;
            if (ms&Joth) {
                $Js = ms&Joth.map(&j{ return 4s&ki(j,2) }).join("+");
                s += '+'+Js;
                ~Jothing: m.t, Js
            }
            msay.push(s);
        }
        ns&say.push(">65 "+msay.join(','));
    }
    
    # title(s) of Jin, gets delta later
    $it;
    if (needs.length > 1) {
        it =
        ~>3 Jin: '*'+needs.length, '>:ms'
    }
    
        
    #c talky
    # T a flow pauser/queue in here
    # batch[time] = needs
    # good for testing!
    # catch errors? could be the most normal place to
    # notice success?
    4s&batch ||= [];
    4s&batch.push(needs);
    G&lim,4s&batch,9;
    
    $Ys = [];
    $sipms = {};
    each in needs {
        ns&trouble = [];
        if (needs.length == 1) {
            $say = ns&say.slice();
            say.push('>:ms');
            it =
            G&c:'>4 Jin\'',say
        }
        else {
            G&c:'>4 Jin\'',ns&say
        }
        each im ns&M {
            Y = ms&Y;
            Ys.push(Y);
            sipms[Yc&sip] = m;
        }
    }
    
    #c thro rubble, swept up into another pile
    Ys = Ys.sort(G&sortsip );
    each iY Ys {
        # the one-of-many needs of J
        $m = sipms[Yc&sip];
        
        # the needs of J
        $n = ms&n;
        
        # A microscope
        #~>49 ,: Y.c.sip, ki(Y,3), ki(Yc&s,3)
        
            if (!Yc&T) {
                ~>9 Jin ignores YnoT: ki(Y)
                continue
            }
            if (Y.4 != A.4) {
                ~>9 Jin ignores non4: ki(Y)
            }
            # try wind it up with its own cv/ov
            4s&batching = Y;
            try {
                G&thro,Y;
            }
            
            catch (er) {
                G&Ban,er;
                
                4s&jinbug and debugger
                
                if (ns&was_trouble && ns&was_trouble.indexOf(Y) != -1) {
                    # have failed twice to get here
                    Ys&failing_lots ||= 1;
                    Ys&failing_lots++
                }
                # async are no big deal, errors are, but run it again anyway
                $fail_allowed = er.nobigdeal ? 7 : 2;
                $mul = Y.3.sc.empathy;
                mul and fail_allowed *= mul;
                if (Ys&failing_lots >= fail_allowed) {
                    ~>96 Jinvingup: ki(Y,2), ki(Yc&s,3)
                }
                else { 
                    ns&trouble.push(Y);
                }
            }
            delete 4s&batching;
    }
    each in needs {
        each im ns&M {
            Y = ms&Y;
            # A then A
            Ys&N && Ys&N.length and ms&YIN = [];
        }
    }
    
    # Js&N: relieved of the seen
    #  it may have been added to since it became ns&N
    each in needs {
        $J = ns&J;
        $N = [];
        each iY Js&N {
            seen[Yc&sip] and continue
            N.push(Y);
        }
        each iY ns&trouble {
            N.push(Y);
        }
        Js&N = N;
    }
    
    # Ys&N: gives Js&N things that emerged from doing
    each in needs {
        $J = ns&J;
        each im ns&M {
            !ms&YIN and continue
            $Y = ms&Y;
            $N = [];
            $yiin = {};
            each iy Ys&N {
                # this is a relation to others
                # to whom attention should flow to
                # they link each other repeatedly
                #  they should persist the A, or this will flood
                yiin[yc&sip] and continue
                yiin[yc&sip] = y;
                # Js&N to have
                ms&YIN.push(y); 
                # don't keep A without T (G&thro sets A&T)
                #  we might want to anyway, or not even if so
                # !A&T are probably transient A,
                #  used to frame the action but not sequence it,
                #  giving no direct way to resume it,
                #  unless we A.up to find something we can sequence
                # eg:
                #  A:u' (A&T) wakes W where it's grouped:
                #  A:u (A&T) groups W used by the:
                #  A:clusping (!A&T), whose A:n above is retargeted
                # but the A:clusping may not be there:
                #  the A:u' live in 5s&mind, could indep. wake up:
                #  the A:u on your 1s&minds, to try and reapply itself:
                # if Ys&N, do that (eg A:clusping)
                # or translate that energy to a wake-J deal,
                #  perhaps knowing what dome that A:u serves
                #   domes seem like A but structural of J
                #  by the way G&clusp might work
                !yc&T and continue
                # Ys&N to keep
                N.push(y);
            }
            Ys&N = N;
            $say = ms&YIN.map(&y{ return y.t }).join(',');
            # }
            $src = '<- '+Y.t+(Yc&s ? ' '+ki(Yc&s) : '');
            !say.match(/u(,u)*/) and ~>5 YIN: J.t+"'s", say, src
            
            # if auto-YIN-next-Jin away:
            each iy ms&YIN {
                Js&N.push(y);
            }
        }
    }
    
    #c around that was an animation frame
    # TODO measure time
    # TODO get machine health
    # TODO make/dedup comeback
    
    $delta = G&time,begins;
    $si = delta > 20 ? '8' : delta > 10 ? '7' : '';
    !4c&notime and it.set('ms', '>7'+si+' '+G&thime,delta );
AndTidy: | # every 30-second jobs...
    # for G&c, top-posting <m> under #msgs 
    $('#msgs').each(&i,m{
        m = $(m).children();
        m.length > 330 and m.slice(290).remove();
    });

