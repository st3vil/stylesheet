
Presentables: | # goals
    # have the wormhole going,
    #   W:screen1 can crash, refresh
    #   W:screen2 can keep playing the soundtrack
    #   W:screen1 can resume without altering the playback
    
    # for talk about how there's multiple people
    
    # stylehouse on a projector, camera films the whole scene
    # so it locates askew the stylehouse in the picture
    # and gently wraps a W:reality around W:screen1's *
    # which slowly skews W:screen1 out, film drifting into the filmed
    # then adds another W:reality, starts making a tunnel
    # and slows the last W:reality down to 100ms behind the first, etc
NutC: | # start C-ing
    u j
    n \'of:eye'
    # start, having I
    # s would be the W on the server to try and ws or so
    #   when elvises fail they just return W page
    #   makes a socket hang around, whatever comes across.
    # begins
    # 1s&N are A/C wanting attention/typing in
    Jinthe:
        $reset_event_listeners = &{
            G.clof(); G.keof();
            G.clon(); G.keon();
            delete Gc&B;
        };
        s == 'reset_event_listeners' and return reset_event_listeners();
        
        A&ws ||= 1;
        
        G.c = {};
        G.sc = {};
        
        $glo = ['h','t'];
        each it glo {
            $z = G.t(A,C,G,T,'i',t);
            $code = z.c.code;
            typeof code != 'function' and throw "Give I.i."+t
            G[t] = code;
        }
        # ^ v ?
        G.h = A.I.eye.y.tw.h.c.code;
        
        window.onerror = &msg,url,lineNo,colNo,error{
            A&bang and return
            A&bang = 1;
            G&Ban,msg,url,lineNo,colNo,error;
            delete A&bang;
            return
        };
        
        A.t = 'top';
        A.y = A;
        delete A&T;
        
        A.on = $('body')[0];
        A.on.A = A;
        
        $J = A.1 = A.2 = A.3 = A.4 = G&J,'Four';
        J.1 = J.2 = J.3 = J.4 = J;
        $f = G&J,'Five';
        A.5 = J.5 = f.5 = f;
        # call it put 1s&Jtv A.4.t 0.01 A.4
        1s&Jtv ||= {};
        1s&Jtv[A.5.t] ||= {};
        1s&Jtv[A.5.t][0.01] = A.5;
        1s&Jtv[A.4.t] ||= {};
        1s&Jtv[A.4.t][0.01] = A.4;
        # 1s&z etc for showing state
        # 1s&N is A-ction, stuff to do,
        # Jambien everything in 1s&Jtv
        4s&NormalI = A.I;
        
        4s&ki = &s,d{ return "!kiyet:"+typeof s };
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&gev,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&gev,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        // G&sockneck;
        4s&ws = G&Aye,'ws',9;
        
        G&headi,'A','Jin';
        G&headi,'C','Typ';
        G&headi,'G','begoin';
        G&headi,'T','Tri';
    
        reset_event_listeners();
    

    # G reinits...
    
    # T adjusts net
    
    #c A: run funnel
    # the general J 8, starting from A.4
    Jin:
        A.1.t != 'Four' and ~wherefour
        # toggle
        s && s.t == 'S+A' and return G&waylay,'Jinloop';
        # thinking
        G&Jinthe,'reset_event_listeners';
        G&waylay,'AndContinue';
    
    # C: collect chatter
    # create error, order its fixing
    Typ:
        A.1.t != 'Typ' and return G&n,['Typ'];
        
        G&way,A.1.t;
    
    # gets its own way, comes back, assum
    Tri:
        # toggle time to live
        s && s.t == 'S+T' and return G&waylay,'VastTimeout';
        
        A.1.t != 'Tri' and return G&n,['Tri'];
        
        G&way,A.1.t;
    
VastTimeout: |
    $el = $('h2#Tri');
    if (1s&VastTimeout) {
        delete 1s&VastTimeout;
        delete Gc&ttl;
        el.text("T");
    }
    else {
        el.text("T°");
        1s&VastTimeout = 1;
        Gc&ttl = 3600;
    }
Jinloop: | # A continuously
    $el = $('h2#Jin');
    if (1s&looping) {
        delete 1s&looping;
        el.text("A");
    }
    else {
        el.text("A°");
        $lo = 1s&looping = Math.random();
        $op = &{
            lo != 1s&looping and return
            G&delay,0.5,op;
            G&waylay,'AndContinue';
        };
        op();
    }
    
Typ: | # exact lounge
    # TO give at a glance a pretty good idea of where you are
    # in the colour code of
    #
    G&jam and return T.not = 1;
    
    ~>3 Ze colour: '>1 one', '>2 two', '>3 three', '>4 four',  '>5 five',  '>6 six', '>7 seven', '>8 eight', '>9 nine'
        
        
        G&u,['MelTest'];
        G&clusp;
        G&n,['C','',{cod:1,s:'Hererereere'}];
        
        $.ajax('do/Lis est Ref').done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
        });
Tri: | # travel
    G&jam and return T.not = 1;
    
    1s&ein ||= {};
    1s&ein.click = {w:'einclick'};
    
    # waddley
    G&u,['MelTest'];
    G&u,['NutText'];
    #debugger;
    G&clusp;
    
    1s&M ||= [];
    
    # the name, renamable
    G&n,['rere',3,{s:"Steve"},{e:2}];
    
    # navigation bars, click to reposition/wake
    G&n,['other',1,{s:"steve!"},{jela:15}];
    G&n,['something',15,{s:"!!~!@r!"},{fs:'170%',hs:'345'}];
    
    # where latest ^ gets down
    G&n,['d33ee',4,{s:'Intri'},{e:1}];
    
    if (1s&M.length) {
        each in 1s&M {
            i == 6 and G&n,['many',5,{s:'...'}]; break
            i = i * 0.001;
            G&n,['ane',4+i,{s:n},{dis:'block'}];
        }
    }
    
    ~Trydone
    
einclick: | # what any webby W can experience
    # 
    ~Have the anteracto: A.1.t, 4s&ki(A,3), 4s&ki(A.up,3)
    1s&M.push("Anteract: "+4s&ki(C));
    
t/JSTesti: | # test the JS bits
    # how does it work?
    # a bunch of timers?
    # C-ing
        ~W: ki(G&Cye,['Thumb'] )
        ~W: ki(G&Cye,['Thumb','W',{},'flac:please'] )
        ~pi: ki(G&Cye,['Thumb','-lattice_331'] )
        
        
        $az = G&Cye,['yo',5,{s:'lalala'},{re:'554',en:3}];
        
        $see = G&Cye,['tango',22,{e:C},{la:'hn',na:3,z:[az]}];
        
        see.y.A = A.up;
    
    # data-ing
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        
        
MelTest: |
    u js
    n \'of:n'
    
    jela 53:
        s&fs = (15 * s)+'%';
        
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
AndContinue: | # Jin stuff
    A = G&Aye,'Jin';
    # should go 2-5Hz? slider it
    G&jam and return
    $begins = G&time;
    $ki = 4s&ki;
    
    Gc&Continues ||= 1;
    Gc&Continues++;
    Gc&Continues > 33 and Gc&Continues = 0; G&waylay,'AndTidy';
    
    # Y means other A, from outside itself
    # bring back A that went async (Y)
    # Js&N=[Y+] and then also Ys&N=[Y+]
    #   getting attention to flow to what was using it
    
    # then venn diagram of waiting-n >< busy-u
    
    # a female J 8 introspector that demands J 6 action when ...
    
    #   female: the algebra of updatability
    #     u etc leaves traces of
    #     W versioning
    #   male: just find all the 1s&N
    #     A with desire to thro
    
    # full of variables, schemes, like how much to regroup by J/net
    # who created who, creation required for creation
    # like Matu, unify environmental/causal concerns
    
    # the use case is:
    #   (A:n) <- up A:clusping <- a&N (A:u) <- a&N (A:u')
    # thro'ing bracketed A from right to left, one per Jin
    # getting an A:n to continue
    
    # being the toplevel of everything calling back to an A,
    # which should be everything sooner or later...
    
    # < throw errors that bundles its arguments
    #   like a G&c that blows up, from the perspective of the caller
    
    # < make G&c objecty, truncate, click items
    #   even a J on a stable G...
    
    # < compressed notation for where/what it is from this A
    
    # < general dedupe/group operation:
    #     da (de|gr) (c sip|$func)
    $dedup_by_sip = &N,seen{
        seen ||= {};
        $M = [];
        each is N {
            !sc&sip and throw "Has no sip: "+i, s
            see = seen[sc&sip] = seen[sc&sip] || [];
            see.push(s);
            see.length == 1 and M.push(s);
        }
        return M;
    };
    # < use ki's es object so we can click into things
    $sa = &Y{
        return Y.t
    };
    
    # gather J with J&N
    $Js = [];
    # Five/Four should come (they were entered) first (also since cv=0.01)
    each tvJ 1s&Jtv {
        $N = Js&N;
        N && N.length and Js.push(J);
    }}
    
    !Js.length and return
    
    # persist a needs for each J
    1s&needs ||= {};
    $needs = [];
    # sip = [Y+] to dedup A and relieve from Js&N later
    $seen = {};
    each iJ Js {
        # persist so ready=0 and feedback loops can be ttl'd,
        delete 1s&needs[J.t]; # TODO
        $n = 1s&needs[J.t] = 1s&needs[J.t] || G&Cye,[J.t,''];
        needs.push(n);
        
        # could care/prioritise dup A?
        ns&J = J;
        ns&N = dedup_by_sip(Js&N,seen);
    }
    
    #c away to order needs by elabourate infinity
    # all items resonate
    # simulate in A:s/osc in another G?
    
    # each need (n) has (sM) a bunch of matters,
    # containing (sY) the A that came out of ns&Js&N
    # it's free to move around and get complicated
    $kiM = {};
    each in needs {
        # add intel per Y
        ns&M and ns&oM = ns&M;
        ns&M = [];
        each iY ns&N {
            $m = G&Cye,[Y.t,'',{},{Y:Y}];
            
            if (!Yc&T) {
                # A never G&thro, climb up to something we can sequence
                $y = Y;
                while (y && !yc&T && y.up) {
                    y = y.up;
                }
                ms&Yfrom = Y;
                m.t = y.t+"<-"+m.t;
                Y = y
            }
            ms&Y = Y;
            ms&J = ns&J;
            ms&n = n;
            
            # compress by the look of C
            if (Y.t == 'n') {
                $s = ki(Yc&s);
                kiM[s] ||= [];
                kiM[s].push(m);
            }
            else {
                ns&M.push(m);
            }
        }
    }
    
    # one C per unique C
    # also puts A:n later
    each sL kiM {
        $m = L[0];
        $n = ms&n;
        ns&M.push(m);
        L.length == 1 and continue
        ms&Cdup = L.length;
        each iy L {
            # y: other m, see if same J
            ys&J == ns&J and continue
            ms&Joth ||= [];
            ms&Joth.push(ys&J);
        }
    }
    
    # one Y per Y
    # have already deduped by sip
    each in needs {
        each im ns&M {
            $Y = ms&Y;
            $L = seen[Yc&sip];
            if (!L) {
                $f = ms&Yfrom;
                !(f && seen[fc&sip]) and throw "Wherefrom?";
                L = seen[fc&sip]
            }
            L.length > 1 and ms&Ydup = L.length;
        }
    }
    
    each in needs {
        $J = ns&J;
        ns&say = [">37 "+J.t];
        $msay = [];
        each im ns&M {
            $s = m.t;
            ms&Ydup and s += '*'+ms&Ydup;
            ms&Cdup and s += '*C'+ms&Cdup;
            if (ms&Joth) {
                $Js = ms&Joth.map(&j{ return j }).join("+");
                s += '+'+Js
            }
            msay.push(s);
        }
        ns&say.push(">65 "+msay.join(','));
    }
    
    # title(s) of Jin, gets delta later
    $it =
    ~>3 Jin: '*'+needs.length, '>:ms'
    each in needs {
        G&c:'>4 Jin\'',ns&say
    }
    
        
    #c thro'ing
    # T a flow pauser/queue in here
    # batch[time] = needs
    # good for testing!
    # catch errors? could be the most normal place to
    # notice success?
    
    if (4s&batch) {
        # etc? hash items iterate in order defined
        # call the rest of this w ToThrow?
    }
    
    each in needs {
        each im ns&M {
            Y = ms&Y;
            if (!Yc&T) {
                ~>9 Jin ignores YnoT: ki(Y)
                continue
            }
            # try wind it up with its own cv/ov
            G&thro,Y;
            
            # A then A
            Ys&N && Ys&N.length and ms&YIN = [];
        }
    }
    
    # Js&N: relieved of the seen
    #  it may have been added to since it became ns&N
    each in needs {
        $J = ns&J;
        $N = [];
        each iY Js&N {
            seen[Yc&sip] and continue
            N.push(Y);
        }
        Js&N = N;
    }
    
    # Ys&N: gives Js&N things that emerged from doing
    each in needs {
        $J = ns&J;
        each im ns&M {
            !ms&YIN and continue
            $Y = ms&Y;
            $N = [];
            $yiin = {};
            each iy Ys&N {
                # this is a relation to others
                # to whom attention should flow to
                # they link each other repeatedly
                #  they should persist the A, or this will flood
                yiin[yc&sip] and continue
                yiin[yc&sip] = y;
                # Js&N to have
                ms&YIN.push(y); 
                # don't keep A without T (G&thro sets A&T)
                #  we might want to anyway, or not even if so
                # !A&T are probably transient A,
                #  used to frame the action but not sequence it,
                #  giving no direct way to resume it,
                #  unless we A.up to find something we can sequence
                # eg:
                #  A:u' (A&T) wakes W where it's grouped:
                #  A:u (A&T) groups W used by the:
                #  A:clusping (!A&T), whose A:n above is retargeted
                # but the A:clusping may not be there:
                #  the A:u' live in 5s&mind, could indep. wake up:
                #  the A:u on your 1s&minds, to try and reapply itself:
                # if Ys&N, do that (eg A:clusping)
                # or translate that energy to a wake-J deal,
                #  perhaps knowing what dome that A:u serves
                #   domes seem like A but structural of J
                #  by the way G&clusp might work
                !yc&T and continue
                # Ys&N to keep
                N.push(y);
            }
            Ys&N = N;
            $say = ms&YIN.map(&y{ return y.t }).join(',');
            # }
            $src = '<- '+Y.t+(Yc&s ? ' '+ki(Yc&s) : '');
            !say.match(/u(,u)*/) and ~>5 YIN: J.t+"'s", say, src
            
            # if auto-YIN-next-Jin away:
            each iy ms&YIN {
                Js&N.push(y);
            }
        }
    }
    
    #c around that was an animation frame
    # TODO measure time
    # TODO get machine health
    # TODO make/dedup comeback
    
    $delta = G&time,begins;
    $si = delta > 20 ? '8' : delta > 10 ? '7' : '';
    it.set('ms', '>7'+si+' '+G&thime,delta );
AndTidy: | # every 30-second jobs...
    # for G&c, top-posting <m> under #msgs 
    $m = $('body #msgs').children();
    m.length > 90 and m.slice(90).remove();

