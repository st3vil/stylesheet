NutCertainty: |
    # and
NutConsciousness: |
    # pudding things on could...
    # < clean away use of the drain as the top C
    # < dome system composing them onto the root C directly...
    #   would expose useful tools for playing data...
    s: %acgt:c sc
        $A = G&Aye,'s',0,c,sc;
        
        $g = A.ground;
        
        // ground -> drain, so it can be resupposed
        // < keeping stuff on 9... replace 1s&root with the drained one?
        1s&drains ||= {};
        $d = 1s&drains[g.t] = 1s&drains[g.t] || G&Cye,g;
        $was = ds&z;
        ds&z = $.unique(gs&z).filter(&C,i{
            !C.t || !C.y || !C.c || !C.sc and throw "low on C: ", C
            $Y = C.y.A;
            if (Y && (Yc&T.not || C.sc.not)) {
                return 0
            }
            return 1;
        });
        $r = 1s&root;
        !r and throw "how to hold many"
        
        // brain per ground, ongoing
        1s&brains ||= {};
        $C = A&s = 1s&brains[g.t] = 1s&brains[g.t] || G&Cye,[g.t,1,{},{J:A.1}];
        
        $diff = &di,ff{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            $.each(di, &k,v{
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            });
            $.each(ff, &k,v{
                null == di[k] and wh.gone[k] = {};
            });
            $.each(wh, &k,v{
                v.length and return 1;
            });
        };
        
        $la = s&top;
        $ltv = la && la.y.tv;
        $tw = r.y.tw = {};
        $tv = r.y.tv = {};
        rs&z = [];
        rs&lv = [];
        $.each(ds&z, &i,C{
            // put on tv
            tv[C.t] ||= {};
            tv[C.t][C.y.cv] = C;
            rs&z.push(C);
            
            // diff
            $D = ltv && ltv[C.t] && ltv[C.t][C.y.cv];
            D ||= {};
            $cha = diff(C.t,D.t)
                || diff(C.c,D.c||{})
                || diff(C.sc,D.sc||{});
            
            !cha and return
            
            // make patch
            $s = G&Cye,C;
            s.y.OC = C;
            sc&el = 1;
            rs&lv.push(s);
        });
        la &&
        $.each(la.sc.z, &i,C{
            tv[C.t] && tv[C.t][C.y.cv] and return
            rs&lv.push(G&Cye,[C.t,C.y.cv,{el:9}]);
        });
        
        // consequence change
        s&lv ||= [];
        if (rs&lv.length) {
            $lr;
            $.each(rs&lv, &i,C{
                C.y.OC == r and lr = C
            });
            lr ||= G&Cye,[r.t,{cv:r.y.cv,OC:r},{el:3}];
            lr.sc.z = $(rs&lv).filter(&i,C{
                // and
                return C.y.OC != r
            });
            // delete rs&lv; lets top s&lv its latest change
            delete lr.sc.lv; // is a property out there, lv insides are s&z
            s&lv.push(lr);
        }
        
        s&top = r;
        
        // hangs brain up on the J
        1s&s = C;
        

        
        if (s&lv.length > (s&readlv || 0)) {
            $lv = s&lv.slice(s&readlv || 0);
            s&readlv = s&lv.length;
            G&Hut,lv;
        }
        return C
    
    # send to Hut, the conscruction, give A.on already
    Hut: %acgt:lv
        for (var i = 0; i < lv.length; i++) {
            var v = lv[i];
            // recur W, where A.b starts
            $W = A.on.thing = A.on.thing || {};
            A.W = W;

            // do om, depth of A:n
            T.d = (T.oT && T.oT.d) + 1;
            $A = G&Aye,'om';
            A.om ||= A;
            A.om == A.up and A.mo = A;

            $C = G&Cye,v;
            C.y.A = A;

            A&T = T;
            G&thro,2,C;
            T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
            s&css ||= {};
            s&anc ||= {};
            G&thro,7;
        }
