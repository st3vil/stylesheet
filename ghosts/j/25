
NutC: | # make C
    u j
    n \'of:eye'
    # start, having I
    # s would be the W on the server to try and ws or so
    #   when elvises fail they just return W page
    #   makes a socket hang around, whatever comes across.
    # begins
    # 1s&N are A/C wanting attention/typing in
    Jinthe:
        A&ws ||= 1;
        
        window.onerror = &msg,url,lineNo,colNo,error{
            A&bang and return
            A&bang = 1;
            G&Ban,msg,url,lineNo,colNo,error;
            delete A&bang;
            return
        };
        
        A.t = 'top';
        A.y = A;
        
        A.on = $('body')[0];
        A.on.A = A;
        
        $J = A.1 = A.2 = A.3 = A.4 = G&J,'Four';
        J.1 = J.2 = J.3 = J.4 = J;
        $f = G&J,'Five';
        A.5 = J.5 = f.5 = f;
        # call it put 1s&Jtv A.4.t 0.01 A.4
        1s&Jtv ||= {};
        1s&Jtv[A.5.t] ||= {};
        1s&Jtv[A.5.t][0.01] = A.5;
        1s&Jtv[A.4.t] ||= {};
        1s&Jtv[A.4.t][0.01] = A.4;
        # 1s&z etc for showing state
        # 1s&N is A-ction, stuff to do,
        # Jambien everything in 1s&Jtv
        4s&NormalI = A.I;
        
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&gev,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&gev,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        // G&sockneck;
        4s&ws = G&Aye,'ws',9;
        
        G&headi,'A','Jin';
        G&headi,'C','Typ';
        G&headi,'G','begoin';
        G&headi,'T','Tri';
        
        G.clof(); G.keof();
        G.clon(); G.keon()
    

    # G reinits...
    
    # T adjusts net
    
    #c A: run funnel
    # the general J 8, starting from A.4
    Jin:
        A = G&Aye,'seeing';
        A.1.t != 'Four' and ~wherefour
        # thinking
        G&waylay,'AndContinue';
    
    
    # C: collect chatter
    # create error, order its fixing
    Typ:
        # becomes J, comes back
        A.1.t != 'Typ' and return G&n,['Typ','',{W:1,on:s}];
        c&on and A.on = c&on;
        
        if (0) {
        G&datam,[],"['*']" and throw "Isnt 1"
        !G&datam,['anything'],"['*']" and throw "Isnt 2"
        !G&datam,[['']],"[['']]" and throw "Isnt 3"
        G&datam,[['']],"['']" and throw "Isnt 4"
        ~WayLAy
        G&waylay,'AndType',2;
        }
        
        G&u,['MelTest'];
        G&clusp;
        G&n,['C','',{cod:1,s:'Hererereere'}];
        
        $.ajax('do/Lis est Ref').done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
        });
    
    # gets its own way, comes back, assum
    Tri:
        # becomes J, comes back
        $pin = 'Tri';
        if (A.1.t != pin) {
            $D = G&n,[pin,'',{W:1,on:s}];
            $Y = D.y.A;
            Y.cv < 0.8 and ~waylay: D.t
            return
        }
        # somehow gets empty {} as C? when in A:n...
        #C = A&s;
        c&on and A.on = c&on;
        console.log("Wha");
        # a non buildingness...
        #A.on.A ||= A;
        
        G&way,pin;
    
AndContinue: | # Jin stuff
    $begins = G&time;
    # Js&N=[Y+] and Ys&N=[Y+]
    #   bring back processes (A) that went async (Y)
    #
    # like a female that demands J 6 action when sometime
    # find all 1s&N, A with desire to thro
    
    # full of variables, schemes, like how much to regroup by J/net
    # like Matu, unify environmental/causal concerns
    
    
    # the use case is:
    #   (A:n) <- up A:clusping <- a&N (A:u) <- a&N (A:u')
    # thro'ing bracketed A from right to left, one per Jin
    # getting an A:n to continue
    
    # < throw that bundles its arguments
    #   like a G&c that blows up, from the perspective of the caller
    
    # < make G&c objecty, truncate, click items
    #   even a J on a stable G...
    
    
    
    
    # da (de|gr) (c sip|$func)
    $dedup_by_sip = &N{
        $seen = {};
        $M = [];
        each is N {
            !sc&sip and throw "Has no sip: "+i, s
            seen[sc&sip] and continue
            seen[sc&sip] = s;
            M.push(s);
        }
        return M;
    };
    
    # describe an A
            # < compressed notation for where/what it is from this A
            # and amongst these things
            # and the A:n etc it's for/underneath,
            #   even slowlaned N for the A:n and the A:u, rapido A:u',
            #   made of A:u's having a&N of A:u which a&N the A:n
            #   structure can be seen as directional,
            #   the lower, less pointed to stuff works out first,
            #   then we give attention to what was using it (a&N)
            # then venn diagram of waiting-n >< busy-u
    # return objects that stringify, or regroup
    $sa = &Y{
        
        return Y.t
    };
    # describe an N
    $lim = &{};
    $squa = &{};
    
    
    
    # gather J with J&N
    $Js = [];
    # Five/Four should come (they were entered) first (also since cv=0.01)
    each tvJ 1s&Jtv {
        $N = Js&N;
        !(N && N.length) and continue;
        Js.push(J);
    }}
    
    # identify who and create a needs object
    # Jin to Jin persist by J.t
    1s&needs ||= {};
    $needs = [];
    each iJ Js {
        # could care/prioritise dup A?
        $N = dedup_by_sip(Js&N);
        
        # persist so ready=0 can be ttl'd,
        $n = 1s&needs[J.t];
        n ||= G&Cye,[J.t,''];
        1s&needs[J.t] = n;
        
        # if ns&N, see what's different?
        $what = [];
        each iY N {
            what.push(sa(Y));
        }
        ns&J = J;
        ns&N = N;
        ns&name = what.join(',');
        needs.push(n);
    }
    
    
    #c away order needs by elabourate infinity
    # all items resonate
    # for A:s/osc in another G?
    
    $seen = {}; # sip
    each in needs {
        $J = ns&J;
        $N = ns&N;
        $M = [];
        each iY N {
            # things to relieve from Js&N later
            seen[Yc&sip] = Y;
            
            # retarget
            $y = Y;
            while (y && !yc&T && y.up) {
                # climb up to something we can sequence
                # would cT if it ever thro'd
                y = y.up;
            }
            y != Y and ~Yy: sa(Y), sa(y)
            Y = y;
            
            # diff multiple A:n C
            if (Y.t == 'n') {
                # TODO ki2 the C, equate things together and do once
                #   when many otherwise same, elvising should be able to group
                #   many A:n elvising may be able to do 1 A:n with many A:e
                #     you might get that working later, stream processing items
            }
            
            M.push(Y);
        }
    }
    
    $sum = [];
    each in needs {
        sum.push(ns&name);
    }
    sum = sum.join(',');
    # capture element, put timestamp on
    $it =
    ~>3 Jin: sum, '>:ms'
    
    # T a flow pauser/queue in here
    # batch[time] = needs
    # good for testing!
    
    #c thro'ing
    $seen = {}; # sip
    each in needs {
        $J = ns&J;
        $N = ns&N;
        $soN = ns&sip_oN = {}; # sip: N # Js&N future?
        each iY N {
            seen[Yc&sip] = Y;
            
            # TODO detect Y-y wander earlier, group same A:n
            $y = Y;
            while (y && !yc&T && y.up) {
                # climb up to something we can sequence
                # would cT if it ever thro'd
                # all items resonate
                y = y.up;
            }
            y != Y and ~Yy: sa(Y), sa(y)
            Y = y;
            
            # try wind it up with its own cv/ov
            G&thro,Y;
            # catch errors? could be the most normal place to
            # notice success?
            
            $oN = Ys&N;
            !(oN && oN.length) and continue
            # get A backlinks every time around
            oN = Ys&N = dedup_by_sip(oN);
            # oN deduped but never tidied up?
            #   want centralised A:u' to remember all the scattered A:u,
            #    who can find where they are in Js, which would point
            #      the desire to a s&mind of the Js&u
            #      the A:u A.2 is J, A.1 is Js&u, which could be found...
            #   A:u u to forget the passing clusping,
            #   although maybe the last copy of it would be good dome resync clues
            #   domes seem like A but structural of J
            # keep if they a&retaiN?
            soN[Yc&sip] = oN;
        }
    }
    
    # delete things we did
    # TODO make into a "drain thingses" thing
    each in needs {
        $J = ns&J;
        $N = [];
        each iY Js&N {
            seen[Yc&sip] and continue
            N.push(Y);
        }
        Js&N = N;
    }
    
    # insert things that emerged from doing
    each in needs {
        $J = ns&J;
        $soN = ns&sip_oN;
        !soN and continue
        each sip,N soN {
            $Y = seen[sip];
            $aliens = [];
            each iy N {
                ~Jinmore: J.t, sa(Y), sa(y)
                # Ys&N should drain sometimes...
                # they could be ongoing wake-parent paths
                # classify being, see above
                !yc&T and aliens.push(i)
                
                Js&N.push(y)
            }
            # remove things this A doesn't permanently N to
            each ai aliens {
                Ys&N.splice(i,1)
            }
        }
    }
    
    #c around that was an animation frame
    # TODO measure time
    # TODO get machine health
    # TODO make/dedup comeback
    
    $delta = G&time,begins;
    $si = delta > 20 ? '8' : delta > 10 ? '7' : '';
    it.set('ms', '>7'+si+' '+G&thime,delta );
Presentables: | # goals
    # have the wormhole going,
    #   W:screen1 can crash, refresh
    #   W:screen2 can keep playing the soundtrack
    #   W:screen1 can resume without altering the playback
    
    # for talk about how there's multiple people
    
    # stylehouse on a projector, camera films the whole scene
    # so it locates askew the stylehouse in the picture
    # and gently wraps a W:reality around W:screen1's *
    # which slowly skews W:screen1 out, film drifting into the filmed
    # then adds another W:reality, starts making makes a tunnel
    # and slows the last W:reality down to 100ms behind the first, etc

