
Presentables: | # goals
    # edit Cs and Ts
    # push into a C, Ting down test cases
    
    # many G
    #  means many A.4 for now
    
    # tours through code:
    # - for any name
    # - EXP marked comments, about program experience
    # - TES marked comments, about changes doable once tested
    
    # have the wormhole going,
    #   W:screen1 can crash, refresh
    #   W:screen2 can keep playing the soundtrack
    #   W:screen1 can resume without altering the playback
    
    # for talk about how there's multiple people
    
    # stylehouse on a projector, camera films the whole scene
    # so it locates askew the stylehouse in the picture
    # and gently wraps a W:reality around W:screen1's *
    # which slowly skews W:screen1 out, film drifting into the filmed
    # then adds another W:reality, starts making a tunnel
    # and slows the last W:reality down to 100ms behind the first, etc
NutC: | # start C-ing
    u j
    n \'of:eye'
    # All require A.I already
    # TES move A.I to A&I?
    
    # A.4 creation/garden
    # already have an A, keep it if it's window.A
    # if you had an A.on, that becomes the new toplevel of things
    
    # s would be the W on the server to try and ws or so
    #   when elvises fail they just return W page
    #   makes a socket hang around, whatever comes across.
    
    # begins
    # 4s&N are A/C wanting attention/typing in
    Four:
        $el = A.on;
        if (window.A != A) {
            A = A.4.up;
            !A and throw "requires an enclosing event forwarding A4"
            A = G&Aye,'atop';
        }
        A.on = el || A.on;
        A.on.A = A;
        
        A.1 = A; # so A:top == A.4.up
        $J = A.1 = A.2 = A.3 = A.4 = G&J,'Four';
        J.1 = J.2 = J.3 = J.4 = J;
        $f = G&J,'Five';
        A.5 = J.5 = f.5 = f;
        # BAB: put 1s&Jtv A.4.t 0.01 A.4
        1s&Jtv ||= {};
        1s&Jtv[A.5.t] ||= {};
        1s&Jtv[A.5.t][0.01] = A.5;
        1s&Jtv[A.4.t] ||= {};
        1s&Jtv[A.4.t][0.01] = A.4;
        # 1s&z etc for showing state
        # 1s&N is A-ction, stuff to do,
        # Jambien everything in 1s&Jtv
        4s&NormalI = A.I;
        
        # pretty printer
        4s&ki ||= &s,d{ return "!kiyet:"+typeof s };
        G&waylay,'NutGravy';
        # should wait for that ^ before init W
        
        # textual umbiloca t
        4s&ws = G&Aye,'ws',9;
        
        # msgs - should be clickable somehow
        $msgs = $(A.on).find('#msgs')[0];
        msgs ||= $(A.on).append("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:50%;height:28%; overflow:hidden;padding:0.2em;color:#abc;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'50%','5%');\"> </div>")[0];
        4s&msgs = msgs;
        
        return A.4;
        
    
    #c Jinthe for A:top start, having I
    Jinthe:
        # comes from event sometimes
        A = window.A;
        
        $reset_event_listeners = &{
            G.clof(); G.keof();
            G.clon(); G.keon();
            delete Gc&B;
        };
        s == 'reset_event_listeners' and return reset_event_listeners();
        
        A&ws ||= 1;
        
        G.c = {};
        G.sc = {};
        
        $glo = ['h','t'];
        each it glo {
            $z = G.t(A,C,G,T,'i',t);
            $code = z.c.code;
            typeof code != 'function' and throw "Give I.i."+t
            G[t] = code;
        }
        # ^ v ?
        G.h = A.I.eye.y.tw.h.c.code;
        
        # many G means many A.4 for now,
        # find the A:top to sprout the document -> stylehousings
        #   G&Ban for errors
        #   G&gev for events - target will climb up to an A.4 element
        #     and non-target evs (keydown) will go to the last targeted A.4
        #     you could setup more handlers on inners that ev.stopPropagation
        window.BamonG = &{
            $A = Gc&B.sc.A;
            return A.4.up
        };
        window.onerror = &msg,url,lineNo,colNo,error{
            A = BamonG();
            A&bang and return
            A&bang = 1;
            G&Ban,error,msg,url,lineNo,colNo,error;
            delete A&bang;
            return
        };
        
        A.t = 'top';
        A.y = A;
        delete A&T;
        
        A.on = $('body')[0];
        
        G&Four;
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&gev,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&gev,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        G&headi,'A','Jin';
        G&headi,'C','Typ';
        G&headi,'G','begoin';
        G&headi,'T','Tri';
    
        reset_event_listeners();
    

    # G (W) reinits...
    
    # T adjusts net
    
    #c A: run funnel
    # the general J 8, starting from A.4
    Jin:
        A.1 != A.4 and ~wherefour
        # toggle
        s && s.t == 'S+A' and return G&waylay,'Jinloop';
        # thinking
        G&Jinthe,'reset_event_listeners';
        G&waylay,'AndContinue';
    
    # C: collect chatter
    # create error, order its fixing
    Typ:
        A.1.t != 'Typ' and return G&n,['Typ'];
        
        G&way,A.1.t;
    
    # gets its own way, comes back, assum
    Tri:
        # toggle time to live
        s && s.t == 'S+T' and return G&waylay,'VastTimeout';
        
        A.1.t != 'Tri' and return G&n,['Tri'];
        
        G&way,A.1.t;
    
    # more inside
    Who:
        A.1.t != 'Who' and return G&n,['Who'];
        
        G&way,A.1.t;
        
VastTimeout: |
    $el = $('h2#Tri');
    if (1s&VastTimeout) {
        delete 1s&VastTimeout;
        delete Gc&ttl;
        el.text("T");
    }
    else {
        el.text("T°");
        1s&VastTimeout = 1;
        Gc&ttl = 3600;
    }
Jinloop: | # A continuously
    $el = $('h2#Jin');
    if (1s&looping) {
        delete 1s&looping;
        el.text("A");
    }
    else {
        el.text("A°");
        $lo = 1s&looping = Math.random();
        $op = &{
            lo != 1s&looping and return
            window.A.4 != A.4 and return
            G&delay,0.5,op;
            G&waylay,'AndContinue';
        };
        op();
    }
    
Savior: | # big list of s that 1c&save somewhere
    G&n,['t',0.01,{s:C.t},{ab:1,fs:'200%',blr:'2px'}];
    ys&dis = 'block';
    
    1s&ein ||= {};
    1s&ein.save = {w:'W/save'};
    1s&M ||= [];
    if (c&e) {
        $e = c&e;
        $Y = e.y.A;
        ~>6 Savie: Y.cv
    }
    
    G&S;
    
    
    $m = G&n:['M','-jod_2',{s:[]}];
    
    each in 1s&M {
        mc&s.push(n.t)
        G&n:[n.t,3+i*0.001,{s:n,pi:'jod'},{dis:'block'}];
    }
    G&lim,1s&M,8;
    mc&s = mc&s.join(", ");
W/save: |
    ~>79 saving: A.1.t, A.cv+'@'+A.n.cv, ss&v
    
    ec&hand and return ~againe
    ec&hand = "G";
    # 4s&ki(C,2), 4s&ki(e,2), 4s&ki(s,2)
    # do e in order, incase later e get handled before waylaid e get handled
    
    
    
    each iY 1s&N {
        # sometimes A.n
        Y.e and Y = Y.e
        Y == A || Ac&s == Yc&s and continue
        Y.cv >= 0.5 and continue
        $D = Yc&s;
        $S = Dc&s;
        # sort = 1 if A should come before Y
        #  break, assume later 1s&N are later
        G&sortsip (Y,A) and continue
        ~>28 queN: 4s&ki(Y,2), Ss&v
        # Y wants to happen before A
        #debugger;
        G&TuneTimeMachine,'e-order';
    }
    G&m:M,[ss&title,'',{s:ss&top}];
    
AndContinue: | # Jin stuff
    A = G&Aye,'Jin';
    # should go 2-5Hz? slider it
    G&jam and return
    $begins = G&time;
    $ki = 4s&ki;
    
    Gc&Continues ||= 1;
    Gc&Continues++;
    Gc&Continues > 33 and Gc&Continues = 0; G&waylay,'AndTidy';
    
    # Y means other A, from outside itself
    # bring back A that went async (Y)
    # Js&N=[Y+] and then also Ys&N=[Y+]
    #   getting attention to flow to what was using it
    
    # then venn diagram of waiting-n >< busy-u
    
    # a female J 8 introspector that demands J 6 action when ...
    
    #   female: the algebra of updatability
    #     u etc leaves traces of
    #     W versioning
    #   male: just find all the 1s&N
    #     A with desire to thro
    
    # full of variables, schemes, like how much to regroup by J/net
    # who created who, creation required for creation
    # like Matu, unify environmental/causal concerns
    
    # the use case is:
    #   (A:n) <- up A:clusping <- a&N (A:u) <- a&N (A:u')
    # thro'ing bracketed A from right to left, one per Jin
    # getting an A:n to continue
    
    # being the toplevel of everything calling back to an A,
    # which should be everything sooner or later...
    
    # < throw errors that bundles its arguments
    #   like a G&c that blows up, from the perspective of the caller
    
    # < make G&c objecty, truncate, click items
    #   even a J on a stable G...
    
    # < compressed notation for where/what it is from this A
    
    # < general dedupe/group operation:
    #     da (de|gr) (c sip|$func)
    $dedup_by_sip = &N,seen{
        seen ||= {};
        $M = [];
        each is N {
            !sc&sip and throw "Has no sip: "+i, s
            see = seen[sc&sip] = seen[sc&sip] || [];
            see.push(s);
            see.length == 1 and M.push(s);
        }
        return M;
    };
    # < use ki's es object so we can click into things
    $sa = &Y{
        return Y.t
    };
    
    # gather J with J&N
    $Js = [];
    # Five/Four should come (they were entered) first (also since cv=0.01)
    each tvJ 1s&Jtv {
        $N = Js&N;
        N && N.length and Js.push(J);
    }}
    
    !Js.length and return
    
    # persist a needs for each J
    1s&needs ||= {};
    $needs = [];
    # sip = [Y+] to dedup A and relieve from Js&N later
    $seen = {};
    each iJ Js {
        # persist so ready=0 and feedback loops can be ttl'd,
        #delete 1s&needs[J.t]; # TODO
        $n = 1s&needs[J.t];
        n && ns&J !== J and throw "Jinturning needs of J not current", J, n
        n = 1s&needs[J.t] = n || G&Cye,[J.t,''];
        needs.push(n);
        
        # falling - s&N A list in, s&M understanding for that A, clobber
        delete ns&was_trouble;
        ns&trouble and ns&was_trouble = ns&trouble; delete ns&trouble;
        
        # could care/prioritise dup A?
        ns&J = J;
        ns&N = dedup_by_sip(Js&N,seen);
    }
    
    #c away to order needs by elabourate infinity
    # all items resonate
    # simulate in A:s/osc in another G?
    
    # each need (n) has (sM) a bunch of matters,
    # containing (sY) the A that came out of ns&Js&N
    # it's free to move around and get complicated
    $kiM = {};
    each in needs {
        # add intel per Y
        ns&M and ns&oM = ns&M;
        ns&M = [];
        each iY ns&N {
            $m = G&Cye,[Y.t,'',{},{Y:Y}];
            
            if (!Yc&T) {
                # A never G&thro, climb up to something we can sequence
                $y = Y;
                while (y && !yc&T && y.up) {
                    y = y.up;
                }
                ms&Yfrom = Y;
                m.t = y.t+"<-"+m.t;
                Y = y
            }
            ms&Y = Y;
            ms&J = ns&J;
            ms&n = n;
            
            # compress by the look of C
            if (Y.t == 'n') {
                $s = ki(Yc&s);
                kiM[s] ||= [];
                kiM[s].push(m);
            }
            else {
                ns&M.push(m);
            }
        }
    }
    
    # one C per unique C
    # also puts A:n later
    each sL kiM {
        $m = L[0];
        $n = ms&n;
        ns&M.push(m);
        L.length == 1 and continue
        ms&Cdup = L.length;
        each iy L {
            # y: other m, see if same J
            ys&J == ns&J and continue
            ms&Joth ||= [];
            ms&Joth.push(ys&J);
        }
    }
    
    # one Y per Y
    # have already deduped by sip
    each in needs {
        each im ns&M {
            $Y = ms&Y;
            $L = seen[Yc&sip];
            if (!L) {
                $f = ms&Yfrom;
                !(f && seen[fc&sip]) and throw "Wherefrom?";
                L = seen[fc&sip]
            }
            L.length > 1 and ms&Ydup = L.length;
        }
    }
    
    # say what - how many points may have compressed
    each in needs {
        $J = ns&J;
        ns&say = [">37 "+J.t];
        $msay = [];
        each im ns&M {
            $s = m.t;
            ms&Ydup and s += '*'+ms&Ydup;
            ms&Cdup and s += '*C'+ms&Cdup;
            if (ms&Joth) {
                $Js = ms&Joth.map(&j{ return 4s&ki(j,2) }).join("+");
                s += '+'+Js;
                ~Jothing: m.t, Js
            }
            msay.push(s);
        }
        ns&say.push(">65 "+msay.join(','));
    }
    
    # title(s) of Jin, gets delta later
    $it;
    if (needs.length > 1) {
        it =
        ~>3 Jin: '*'+needs.length, '>:ms'
    }
    
        
    #c thro'ing
    # T a flow pauser/queue in here
    # batch[time] = needs
    # good for testing!
    # catch errors? could be the most normal place to
    # notice success?
    4s&batch ||= [];
    4s&batch.push(needs);
    G&lim,4s&batch,9;
    
    $Ys = [];
    $sipms = {};
    each in needs {
        ns&trouble = [];
        if (needs.length == 1) {
            $say = ns&say.slice();
            say.push('>:ms');
            it =
            G&c:'>4 Jin\'',say
        }
        else {
            G&c:'>4 Jin\'',ns&say
        }
        each im ns&M {
            Y = ms&Y;
            Ys.push(Y);
            sipms[Yc&sip] = m;
        }
    }
    
    Ys = Ys.sort(G&sortsip );
    
    each iY Ys {
        # the one-of-many needs of J
        $m = sipms[Yc&sip];
        # the needs of J
        $n = ms&n;
        
            if (!Yc&T) {
                ~>9 Jin ignores YnoT: ki(Y)
                continue
            }
            if (Y.4 != A.4) {
                ~>9 Jin ignores non4: ki(Y)
            }
            # try wind it up with its own cv/ov
            4s&batching = Y;
            try {
                G&thro,Y;
            }
            #if (0) {
            catch (e) {
                #~>96 Jinbang: e
                G&Ban,e;
                4s&jinbug and debugger
                
                if (ns&was_trouble && ns&was_trouble.indexOf(Y) != -1) {
                    ~>96 Jinvingup:
                }
                else {
                    ns&trouble.push(Y);
                }
            }
            delete 4s&batching;
    }
    each in needs {
        each im ns&M {
            Y = ms&Y;
            # A then A
            Ys&N && Ys&N.length and ms&YIN = [];
        }
    }
    
    # Js&N: relieved of the seen
    #  it may have been added to since it became ns&N
    each in needs {
        $J = ns&J;
        $N = [];
        each iY Js&N {
            seen[Yc&sip] and continue
            N.push(Y);
        }
        each iY ns&trouble {
            N.push(Y);
        }
        Js&N = N;
    }
    
    # Ys&N: gives Js&N things that emerged from doing
    each in needs {
        $J = ns&J;
        each im ns&M {
            !ms&YIN and continue
            $Y = ms&Y;
            $N = [];
            $yiin = {};
            each iy Ys&N {
                # this is a relation to others
                # to whom attention should flow to
                # they link each other repeatedly
                #  they should persist the A, or this will flood
                yiin[yc&sip] and continue
                yiin[yc&sip] = y;
                # Js&N to have
                ms&YIN.push(y); 
                # don't keep A without T (G&thro sets A&T)
                #  we might want to anyway, or not even if so
                # !A&T are probably transient A,
                #  used to frame the action but not sequence it,
                #  giving no direct way to resume it,
                #  unless we A.up to find something we can sequence
                # eg:
                #  A:u' (A&T) wakes W where it's grouped:
                #  A:u (A&T) groups W used by the:
                #  A:clusping (!A&T), whose A:n above is retargeted
                # but the A:clusping may not be there:
                #  the A:u' live in 5s&mind, could indep. wake up:
                #  the A:u on your 1s&minds, to try and reapply itself:
                # if Ys&N, do that (eg A:clusping)
                # or translate that energy to a wake-J deal,
                #  perhaps knowing what dome that A:u serves
                #   domes seem like A but structural of J
                #  by the way G&clusp might work
                !yc&T and continue
                # Ys&N to keep
                N.push(y);
            }
            Ys&N = N;
            $say = ms&YIN.map(&y{ return y.t }).join(',');
            # }
            $src = '<- '+Y.t+(Yc&s ? ' '+ki(Yc&s) : '');
            !say.match(/u(,u)*/) and ~>5 YIN: J.t+"'s", say, src
            
            # if auto-YIN-next-Jin away:
            each iy ms&YIN {
                Js&N.push(y);
            }
        }
    }
    
    #c around that was an animation frame
    # TODO measure time
    # TODO get machine health
    # TODO make/dedup comeback
    
    $delta = G&time,begins;
    $si = delta > 20 ? '8' : delta > 10 ? '7' : '';
    it.set('ms', '>7'+si+' '+G&thime,delta );
AndTidy: | # every 30-second jobs...
    # for G&c, top-posting <m> under #msgs 
    $('#msgs').each(&i,m{
        m = $(m).children();
        m.length > 330 and m.slice(290).remove();
    });

