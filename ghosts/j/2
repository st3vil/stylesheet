Sound: |
    # arecord -f dat -D hw:3,0 eo.wav

    # mix down to mono:
    # mplayer     -ao pcm:fast:waveheader:file=output.wav     -af pan=1:0.5:0.5     -vo null -vc null     onecha.wav
    
    # into flac:
    # arecord -f dat -D hw:3,0 | flac - -o MorganSophie9.flac
    
    # to 19twok ogg:
    # $arecording | oggenc - -q 6 -r -o MorganSophie4.ogg
    
    # for spectrograms:
    # apt-get install spek
    sayyl "Your:\t". sjson([gab=>"zoy\tblab"])
    

Jig: | # initiates W to store somewhere
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # to be, for code stitch/branch
    #   G ionvolk.
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    # awareness of G gou in G gou is feedback
    
    =pod
    
    super
    soft
    ''
    hard
    far
    
    with a why exuder (female) and death circuitty
    terminal input, flying hold (tripany);
    the place says T
    
    TODO
    
    the code has lost its 
    catch it in the throat maker
    
    =cut
    
    Js&ein.pi.Gdo.sMJ = &sMJjeTC{
        #G&give,Budge=>[Jigzen=>''=>{s=>$e}];
        # e.t = 'bay/via'
        # ec&s = 'commit message'
        # es&z = [W items]
        # do them, T.H/impart the non-itemic
        m $e
    };
    S
    # flush the queue of -Gdo
    my @t = @{Js&M||[]};
    @{Js&M} = ();
    @t || return
        n no=>1=>"Nothing doing (send -Gdo from Lize)"
    die "many Gdo" if @t > 1;
    
    my @todo; # W steps
    my $tw; # which W to sleep
    my $aw; # which W to awake everything under
    for my $y (@t) {
        my ($bay,$gd) = y.t =~ /^(G.c.bay)\/(.+)$/;
        $bay || die "bay not our bay? G.c.bay / y.t";
        A.7.t = $gd; # or branch
        A.6.t = $gd;
        for my $t (@{ys&z}) {
            push @todo, $t;
            $tw.>t.t = $t;
        }
        undef $tw if ys&everything;
        $aw.>$_ ++ for grep{$_} split ',', ys&everything_under;
    }
    
    
    
    # - put wrapper on any W
    my $l = [];
    my @wake;
    G&elph,Trips=>[tripany=>$_] for &acgt{
        return unless $l;
        # avoid W for the mind or the oscillator
        # deals with land itself
        return if A.up.up.t =~ /^(u|s)$/;
        # nor the Storage or any other agents
        return if C.t =~ /^(Stro)$/;
        
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        push @$l, G&aC,$C . "\t" . $Ats;
        
        if ($aw.>C.t) {
            # wake everything under here
            push @wake, $A;
            T.H = 0;
        }
        elsif (grep { Ac&sip =~ /^_c&sip/ } @wake) {
            # is subnetically within an all-awaker
            1 && saygr " --- C.t awake within";
            T.H = 0;
        }
        elsif ($tw && !$tw.>C.t) {
            my $f = G&Locate_read,C.t;
            my $d = G&Beach,"$f/1" if $f;
            if ($d) {
                ($d) = @$d;
                c&pretend = $d;
                # get Hosthing's thawJ to do the c&parts, T.Z.7ing
                # doesn't seem to work directly from here (early?)
                T.H = 1;
            }
        }
        
        # before method wrapper, returning $d to c&phind
        c&phin = 'Experience';
    };
    
    # - the Jig invokes Experience/writing into bay
    # supplement that with a linier storage format
    Rw AWriter;
    
    for my $t (@todo) {
        #next unless $t =~ /^P/;
        my $eh = hitime();
        n $t
        my $tr = T.op;

        my $ts = hitime() - $eh;
        my $delta = Rw mass $s:ts;
        my @bunch = G&op;
        @bunch = "massive lot of things" if T.op.sc.massive;
        my @l = ("took: $delta", @bunch );
        n tr.t=>-od=>{dl=>2,s=>\@l}
    }
    # the -od must overwrite the W so we can web ourselves
    #@$M = reverse @$M;
    undef $l; # untrip
    exit; # dont hang around with all this memory
Lize: | # watch ghost/wormhole watcher TODO
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    
    =head DESCRIPTION
    
    see and affect stylehouse openness/movingness
    
    =pod TODO
    
    have AWriter copy some 9 sc (in 4) to 5
        so eg the s&massive LeMachine never gets mixed
        since startups can do it quickly
    
    Scuttle hops attributes across borders
      needs two I, for the gk and the border
    
    have many piles, one unified field of ways to watch
      all change should start in some way
    
    W starting -tin
    
    W ordering
    
    fix button - smooth out the edge
    
    ghost editor sync/tie down the fix button
    n Besider
    see latest them
    =cut
    
    
    n view=>o2=>\'pi:pit,s:sac je via vil'
    my $g = Js&view || die 'No view';
    my $add = ''; # to start tops
    
    my $gd = "G.c.bay/$g";
    
    # our saves land in gou, must be in stay to help sleep
    n $gd=>-lies=>"*/5",'%qz'
    # < if ^ steady, skip -jackpole
    S
    
    
    my $eh = hitime();
    # < get any lies that changed, redome w/W outent
    # lay out web of dependencies
    n waved=>-jackpole=>{s=>T.op},'%qz'
    my $lies = T.op;
    
    # see updatables
    n edge=>-respec=>{s=>T.op},'%qz'
    # < if ^ steady, skip -lenot
    
    # pile with desire
    my $act = [Jig=>[$gd=>-Gdo=>{}]];
    my $c = {};
    # to start tops:
    c.add = $add if $add;
    n pile=>-lenot=>{s=>T.op,%$c},{runs=>$act}
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    n tripes=>4=>"took: $delta"
    
    # look at everything
    #m zome=>-beli=>{s=>$lies}
    
    # next things take some pi sit as input
    # and continue/restart branches of thinking
    # until something comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down 
    
    # < know history to W
    # < sets most-W-owning, ordering
    # < more than one parent, 
    
    
Higg: | # see Lize
    Jc&tape = 'Dejo';
    n Lize=>V
    n Lize=>-beli=>{s=>T.op}
Budge: | # throw data off the edge of the map
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    Rw Elationist;
    S
    
    n tehe=>-od=>{s=>Jc&es,dl=>3}
    
letsclick: | # click pile
    sayyl "Have lets: ".ki e&us;
    # < presenting these potential actions
    #   so gesturing at the frontend is free to evolve
    my @h = e&_hC;
    my @n;
    my ($p) = grep { _s&pi eq 'pile' } reverse @h;
    push @n, shift @h until $h[0] eq $c;
    
    # the dos-ing's casement
    # (J that made C above the 9)
    my $o = $n[-1];
    my $i = $h[-1];
    # click name to go
    # can wire the button down for some G
    # exhausting for the edge of development
    my $com = &s,sc{
                my @y = $o; # deep
                while ($o && os&ml) {
                    $o = o.y.prev || last;
                    my $l = $y[-1];
                    # skip 22 in 1222(3)
                    os&depth < ls&depth || next;
                    push @y, $o;
                }
                # top..deep
                @y = reverse @y;
                ($o) = (@y); # highest caretaker of o
                # < along @y may be tests wanting
                my ($run) = grep{$_} map {_s&runs} reverse @n;
                # fill out the form for action
                my $R = G&Ct,$run;
                my $E= Rc&e || die "run form not elvis";
                
                Ec&s = $s || "An Update";
                
                # runs deepest first for fast compile check
                # then the rest in the same process
                # < J sleeping (wants to check G&t deps)
                Es&z = [map{ G&Ct,[_.t] }reverse @y];
                
                G&hoh,E.sc,$sc if $sc;
                saygr "For ".ki($sc)." Over ".ki E.sc;
                
                my $d = G.c.bay."/p";
                my $in = "$d/Udder/in";
                sayyl "Writing $in For ".ki $R;
                sayre "OrE ".ki $E;
                write_file($in,{append=>1},
                    sjson($R)."\n");
    };
    if (os&pi eq 'lets') {
        # is an edge
        if (i.t eq 't') {
            if ( us&S ) {
                G&give:Budge=>"Add o.t to batch";
            }
            else {
                my $sc = {};
                sc.everything_under = o.t if us&C ->{C};
                $com->('',$sc);
            }
        }
        else {
            if ( us&S ) {
                G&give:Budge=>"Ignore o.t's i.t change?";
            }
            else {
                G&give:Budge=>"Get interested in o.t's i.t change";
            }
        }
    }
    else {
        $o = $i; # the very end of it is t=$W
        # general ghost/Wsitch interest in something
        # or pushing the key that didn't necessarily want to be pushed
        if ( us&S ) {
            my $sc = {};
            # everything under the toplevel
            sc.everything = 1 if us&C ->{C};
            $com->("Entirety",$sc);
            #G&give:Budge=>"Rise out of i.t";
            # or wind backward?
        }
        elsif ( us&C ->{C}) {
            my $sc = {};
            sc.everything_under = o.t if us&C ->{C};
            $com->("Especially",$sc);
        }
        else {
            G&give:Budge=>["Get interested in i.t",1,{s=>[$o,$i]}];
            # or wind forwards?
        }
    }
    
    #
    exit;
    saybl " - ".G&aC,$_ for e&_hC;
    T.pos = 0;
pi/lets: | # bitular suggestion
    y.at.dos = 'letsclick';
    n t=>o1=>C.t,'%fw:4,fs:14'
    s&hs = 798;
    
    my $R = c&R || return;
    
    my $nex;$nex = &C{
        $C, C.y.next ? $nex->(C.y.next) : ();
    };
    
    for my $r ($nex->(R.y.in)) {
        for my $t ($nex->(r.y.in)) {
            my $d = tc&s;
            # the changed object ^
            # we have s&(ha/dige)_was on t
            # depending on thing, chase difference
            m "r.t t.t"=>''=>" r.t t.t "
        }
    }
    
    
lenotclick: | # poking around the pile
    Rw letsclick + $not=1;
pi/lenot: | # make pile of something
    y.at.dos = 'lenotclick';
    s&fs = 8;
    my $z = [
        map{ G&Ct,[_.t=>{R=>$_,cv=>1}] }
        sort {a.t cmp b.t} 
        values %{s.y.tw}
    ];
    my $tw = {map{ _.t=>$_ }@$z};
    my $got;
    for my $C (@$z) {
        my $R = C.y.R;
        my @in = map { $tw.>$_ || die "nosuchW $_" }
            split ',', Rs&inside;
        if (@in > 1) {
            1 && sayre join "\n", "many ".G&aC,$R ." in:",
                map { " - ".G&aC,$_ } @in;
        }
        my $i = 0;
        for my $W (@in) {
            $got.>C.t ++;
            my ($C) = $i++ ? grep{ _s&another = 1 } G&hup,$C : $C;
            push @{Ws&z}, $C;
            $i++;
        }
    }
    my @tops = grep { !$got.>_.t } @$z;
    die "No tops: ".ki$z if !@tops && @$z;
    
    my @l = map { G&ind,$_ } @tops;
    my $have;
    for my $I (@l) {
        $have.>I.t ++;
        my $R = I.y.D.y.R;
        my $K = G&Ct,[I.t=>''=>{s=>I.t}];
        if (Ic&ind) {
            # depth to stay a number for later
            Ks&depth = Ks&ml = Ic&ind;
        }
        Ks&dis = 1; # one line
        if (exists Rs&z) {
            Kc&pi = 'lets';
            Kc&R = $R;
        }
        m $K
    }
    if (my @dont = grep { !$have.>_.t } @$z) {
        my $me = "(circular mounting?) Dont have "
            .ki\@dont;
        warn $me;
        n ohno=>o5=>"!! $me",'dis:1,hs:577'
    }
    
    m $_=>-lets=>$_ for grep{$_} split ',', c&add;
    for my $C (@$M) {
        s&hs = '744' if s&another;
    }
pi/respec: | # compare w/W situations, make pile
    my $rs = {}; # what is
    my $tr = {}; # what is trouble
    # FactorEase w/* etc (G&ind follows thing's next)
    # this is probably where to start growing FactorEase
    my $nex;$nex = &C{
        $C, C.y.next ? $nex->(C.y.next) : ();
    };
    my $atwz = &CD{
        $D = G&Ct,$D if ref $D ne 'HASH';
        C.y.tw.>D.t ||= do {
            push @{s&z||=[]}, $D;
            $D
        };
    };
    for my $k (qw'w W K') {
        my $n = s.y.tw.>$k || next;
        $rs.>$k = [$nex->(n.y.in || next)];
    }
    
    # check way used vs now
    for my $w (@{rs.w||[]}) {
        my $y = G&wops,w.t;
        if (ws&dige ne ys&dige) {
            # w/$w/$W
            my $r = tr.w ||= G&Ct,[w=>1];
            
            my $t = G&Ct,[w.t=>1]; # way difference
            ts&dige = ys&dige;
            ts&z = [$nex->(w.y.in)]; # affected W
            _s&dige_was = ws&dige for @{ts&z};
            push @{rs&z||=[]}, $t;
        }
    }
    
    # check W's W included vs W now (K)
    my $K = { map { _.t => $_ }@{rs.K||[]} };
    for my $W (@{rs.W||[]}) {
        my @l = $nex->(W.y.in || next);
        for my $l (@l) {
            my $k = $K.>l.t;
            if (ls&ha ne ks&ha) {
                # W/$Wunder/$W
                my $r = tr.W ||= G&Ct,[W=>1];
                # each l/W may appear in many W
                my $L = $atwz->($r,[l.t=>1]);
                my $t = G&Ct,[W.t=>1]; # W difference
                Ls&ha = ks&ha;
                ts&ha_was = ls&ha;
                push @{Ls&z||=[]}, $t;
            }
        }
    }
    
    # all W
    my $tw = { map { _.t => G&Ct,[_.t,{K=>$_,cv=>1}] } values %$K };
    
    # distribute trouble to W
    # s&z problems type(w/W) / $w/$W
    each kv $tr {
        for my $p (@{vs&z}) {
            # the thing causing imbalance
            for my $t (@{ps&z}) {
                # ourselves and our end of the situation
                my $W = $tw.>t.t || die "noWtw t.t";
                # our this kind (w/W) of probs
                my $k = $atwz->($W,[$k=>1]);
                # the thing causing is the flame
                $atwz->($k,[p.t=>2=>{s=>$p},t.sc]);
            }
        }
    }
    
    # s&inside = $Wover
    for my $Wo (@{rs.W||[]}) {
        my @l = $nex->(Wo.y.in || next);
        for my $l (@l) {
            my $W = $tw.>l.t || die "noWtw l.t";
            Ws&inside = join',',grep{$_} Wo.t, Ws&inside;
        }
    }
    
    if (0) {
        my $ub = &Cd{ G&aC };
        
        saybl "\t$_" for G&ind,tr.w,$ub,{nohup=>1};
        saygr "\t$_" for G&ind,tr.W,$ub,{nohup=>1};
        my $y = G&Ct,[y=>1];
        ys&z = [sort {a.t cmp b.t} values %$tw];

        sayre "\t$_" for G&ind,$y,$ub,{nohup=>1};
    }
    
    n $_ for values %$tw;
    # all yK = jackpole's K/$W with cs = the 5ile, 5's 9 sc
    
pi/jackpole: | # map bay/$W/5 to $W and collect w/W outputs
    # to 5ile, way, W in, W out
    my $types = {};
    my $in = &KCD{
        my $K = $types.>$K ||= G&Ct,[$K=>2];
        my $B = K.y.tw.>C.t ||= $C; # known/w
        # Bs&* == Cs&*, except z
        # < more than one version of something? FactorEase
        return unless $D;
        my $E = B.y.tw.>D.t ||= $D; # unknown/W
    };
    T.op = $s;
    for my $D ( G&op ) {
        my $N = G&Beas,Dc&s;
        my ($F) = @$N;
        my $t = F.t;
        
        my $K = G&Ct,[$t=>1=>{s=>D.t}=>{%{F.sc}}];
        delete Ks&z;
        $in->(K=>$K);
        
        for my $d (@{Fs&z}) {
            for my $B (@{ds&z}) {
                $B = G&hup,$B;
                my $C = G&Ct,[$t=>1];
                if (d.t eq 'W') {
                    # our version of it under us
                    $in->(W => $C => $B );
                }
                else {
                    # us under it
                    $in->(d.t => $B => $C );
                }
            }
        }
    }
    # tw to zs
    my $twz = &C{
        my @z = sort {a.t cmp b.t} values %{delete(C.y.tw)||{}};
        s&z = \@z if @z;
        @z
    };
    my $ub = &Cd{ ki $C };
    each kC $types {
        $twz->($_) for $twz->($C);
        #saybl "$k\t$_" for G&ind,$C,$ub,{nohup=>1};
        n $C
    }
    
    # so now
    # K is for each W:
    #   cs where it came from, sc (-z) copied from its 9
    
    # W is each W including other W (one piece hierarchy)
    #   the s&ha/version there needs checked against K, what it is now
    
    # w is each way with s&dige being used by other W
    #   usually the pin
pi/lies: | # watch wormhole (mtimes)
    local A.V = 0;
    # page i increases in flood
    # stretches out lim to keep reading until it hits old news
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = "C.t/$s" if $s =~ /^\W/;
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &s{
        my $sc = {};
        (sc.size,sc.mtime) = (stat $s)[7,9];
        sc.link = readlink $s if -l $s;
        $s=>1=>{},$sc
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = G&Experience;
    
    # osc changing atom loads contents
    @$M = Rw Modulate $d $list $forms;
    
    1s&sels.mtime.>$_ = &acgt{
        if (s&size > 2000 && s&large <  2) {
            s&large = 1;
            return;
        }
        c&s = read_file(C.t);
    } for 1,3;
    
    # imparting to self again, next thing will require version bump
    # since there is no hashing the reverse of travel yet
    
 
Modulate: | # loadup M news
    # stop when old news found
    my $done;
    my $list_done;
    my $seen;
    my @l;
    my $page = 1;
    my $M = [];
    my $keen; # whether to read into the rest of the page
              # once something same has been found
    until ($done && (!$keen || !@l)) {
        if (!@l && !$done) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep { !$seen.>$_ } @{s&sz};
            @l || last;
        }
        my $s = shift @l;
        $seen.>$s = 1;
        
        my @C = $forms->($s);
        my $C = G&Ct,\@C;
        my $c = d.y.tw.>C.t;
        
        my $cha;
        
        # could use the thing beneath o
        my $l = G&Ct,[c.t=>''=>{s=>$c}];
        my $o = G&Ct,[C.t=>''=>{s=>$C}];
        G&Chang,$l,$o;
        $cha = oc&cha;
        
        # or just
        $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        else {
            sayyl "Done upon C.t";
            $done = 1;
        }
        push @$M, $C;
    }
    
    each t,C d.y.tw {
        next if $seen.>$t;
        next if !-e $t;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
pi/beli: | # wormhoe
    T.op = $s;
    my $ub = &Cd{ G&aC };
    my @stu = G&ind,$s,$ub,{nohup=>1};
    n beli=>-pud=>{dl=>6,s=>\@stu}
    #[ G&op ]}
    

