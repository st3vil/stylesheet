Sound: |
    # arecord -f dat -D hw:3,0 eo.wav

    # mix down to mono:
    # mplayer     -ao pcm:fast:waveheader:file=output.wav     -af pan=1:0.5:0.5     -vo null -vc null     onecha.wav
    
    # into flac:
    # arecord -f dat -D hw:3,0 | flac - -o MorganSophie9.flac
    
    # to 19twok ogg:
    # $arecording | oggenc - -q 6 -r -o MorganSophie4.ogg
    
    # for spectrograms:
    # apt-get install spek
    
Jig: |
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # awareness of G gou in G gou is feedback
    A.7.t = 'via';
    
    n Jigna
    
    
    n Jigna=>-od=>{dl=>3,s=>[ G&op ]}
    #n Jigna=>-pud=>{dl=>3,s=>[ G&op ]}
    my $d = 1s&Jignad;
    n eco=>-pre=>{s=>"InJig: ".wdump 5, $d};
    
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    # [
Jigna: |
    G.c.leakmax = 40;
    n "G.c.bay/{gou,stay}"=>-lies_02=>"/*{,/j/*,/j/*/j/*}/head"
    my ($l) = G&op;
    n _.t=>-sea_2=>{s=>$_} for $l;
    
    n sev=>7=>3489
    n theA=>3=>{s=>$A}
    # users (A.3) will stratify (into J) stages of their transform
    # unless the input looks the same
    # 
pi/sea: |
    Js&fam = 't hsize hago';
    S
    # if large, prefer xoics
    # be able to ask for lum from 
    s&ago = int hitime() - ss&mtime;
    s&hago = Rw mass $s:s&ago;
    s&hsize = Rw sciun $s:ss&size;
    S
    #y.at.dos = 'Continues';
    #Js&ope > Js&bowls || return;
    #Js&bowls++;
    
    my $v = read_file(C.t);
    my $d = Load($v);

    n t=>o1=>C.t
    n see=>''=>wdump(4,$d);
Lize: | # watch ghost/wormhole watcher
    Jc&tape = 'Dejo';
    # see stylehouse openness 
    #n Besider
    # see latest them
    n "G.c.bay/Z"=>-lies=>"*/xo"
    S
    n zome=>-beli=>{s=>T.op}
    # next things take that ^ as input
    # and continue/restart branches of thinking
    # until something comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down 
    n sq=>1=>"Lies of thee"
    
    d:
        lies good
    
pi/lies: | # watch wormhole (mtimes)
    # page i increases in flood
    # stretches out lim to keep reading until it hits old news
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = "C.t/$s" if $s =~ /^\W/;
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &s{
        my ($si,$mt) = (stat $s)[7,9];
        $s=>1=>{},{mtime=>$mt,size=>$si}
    };
    
    my $d = Rw Experience;
    
    # osc changing atom loads contents
    @$M = Rw Modulate $d $list $forms;
    
    1s&sels.mtime.>$_ = &acgt{
        if (s&size > 2000 && s&large <  2) {
            s&large = 1;
            return;
        }
        c&s = read_file(C.t);
    } for 1,3;
    
    # imparting to self again, next thing will require version bump
    # since there is no hashing the reverse of travel yet
    
 
Modulate: | # loadup M news
    # stop when old news found
    my $done;
    my $list_done;
    my $seen;
    my @l;
    my $page = 1;
    my $M = [];
    my $keen; # whether to read into the rest of the page
              # once something same has been found
    until ($done && (!$keen || !@l)) {
        if (!@l && !$done) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep { !$seen.>$_ } @{s&sz};
            @l || last;
        }
        my $s = shift @l;
        $seen.>$s = 1;
        
        my @C = $forms->($s);
        my $C = G&Ct,\@C;
        my $c = d.y.tw.>C.t;
        
        my $cha;
        
        # could use the thing beneath o
        my $l = G&Ct,[c.t=>''=>{s=>$c}];
        my $o = G&Ct,[C.t=>''=>{s=>$C}];
        G&Chang,$l,$o;
        $cha = oc&cha;
        
        # or just
        $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        else {
            sayyl "Done upon C.t";
            $done = 1;
        }
        push @$M, $C;
    }
    
    each t,C d.y.tw {
        next if $seen.>$t;
        next if !-e $t;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
pi/beli: | # wormhoe
    T.op = $s;
    n beli=>-pud=>[ G&op ]
    

