Sound: |
    # arecord -f dat -D hw:3,0 eo.wav

    # mix down to mono:
    # mplayer     -ao pcm:fast:waveheader:file=output.wav     -af pan=1:0.5:0.5     -vo null -vc null     onecha.wav
    
    # into flac:
    # arecord -f dat -D hw:3,0 | flac - -o MorganSophie9.flac
    
    # to 19twok ogg:
    # $arecording | oggenc - -q 6 -r -o MorganSophie4.ogg
    
    # for spectrograms:
    # apt-get install spek
    sayyl "Your:\t". sjson([gab=>"zoy\tblab"])
    
Atool: | # reliable/old A
    u i
    # snakinf
    Aup:
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        return $Ats;
        
Jig: | # initiates W to store somewhere
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # to be, for code stitch/branch
    #   G ionvolk.
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    # awareness of G gou in G gou is feedback
    
    =pod
    
    super
    soft
    ''
    hard
    far
    
    with a why exuder (female) and death circuitty
    terminal input, flying hold (tripany);
    the place says T
    
    TODO
    
    the code has lost its 
    catch it in the throat maker
    
    n Placement
    n Sequencing
    n Intel
    n ForJ
    n Tangle
    n Stuff
    
    n Art
    
    n Storage
    n Elvising
    n Tripical
    =cut
    
    Js&ein.pi.Gdo.sMJ = &sMJjeTC{
        #G&give,Budge=>[Jigzen=>''=>{s=>$e}];
        # e.t = 'bay/via'
        # ec&s = 'commit message'
        # es&z = [W items]
        # do them, T.H/impart the non-itemic
        m $e
    };
    S
    # flush the queue of -Gdo
    my @t = @{Js&M||[]};
    @{Js&M} = ();
    @t || return
        n no=>1=>"Nothing doing (send -Gdo from Lize)"
    die "many Gdo" if @t > 1;
    
    my @todo; # W steps
    my $tw; # to know which W to sleep
    for my $y (@t) {
        my ($bay,$gd) = y.t =~ /^(G.c.bay)\/(.+)$/;
        $bay || die "bay not our bay? G.c.bay / y.t";
        A.7.t = $gd; # or branch
        A.6.t = $gd;
        for my $t (@{ys&z}) {
            push @todo, $t;
            $tw.>t.t = $t;
        }
        undef $tw if ys&everything;
    }
    
    # - put wrapper on any W
    my $l = [];
    G&elph,Trips=>[tripany=>$_] for &acgt{
        return unless $l;
        # avoid W for the mind or the oscillator
        # deals with land itself
        return if A.up.up.t =~ /^(u|s)$/;
        # nor the Storage or any other agents
        return if C.t =~ /^(Stro)$/;
        
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        push @$l, G&aC,$C . "\t" . $Ats;
        
        if (!$tw.>C.t) {
            sayre "Could sleep C.t?";
            T.H = 4;
        }
        
        # before method wrapper, returning $d to c&phind
        c&phin = 'Experience';
    };
    
    # - the Jig invokes Experience/writing into bay
    # supplement that with a linier storage format
    Rw AWriter;
    
    my @not = qw'Atool Placement Sequencing Intel ForJ';
    for my $t (@todo) {
        #next unless $t =~ /^P/;
        my $eh = hitime();
        n $t
        my $tr = T.op;

        my $ts = hitime() - $eh;
        my $delta = Rw mass $s:ts;

        my @l = ("took: $delta", G&op );
        n tr.t=>-od=>{dl=>2,s=>\@l}
    }
    undef $l; # untrip
Jigdoer: | # bootstrap a G from W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    A.6.t = 'via';
    G.c.bay = 'bay';
    
    my $eh = hitime();
    
    my $set = [];
    my $M = [];
    for my $t (qw'Atool Placement Sequencing Intel ForJ') {
        my $f = G&Locate_read,$t;
        $f .= "/1";
        -f $f || die "NO such $t ($f ?)";
        if ($set) {
            push @$set, $f;
            next;
        }
        my $N = G&Beach,$f;
        push @$M, @$N;
    }
    if ($set) {
        my @suub;
        for ([Beach=>'f'],[Believe=>'N']) {
            my ($t,$args) = @$_;
            my $s = G.way.>$t || die "No $t";
            my $C = G&Ct,[$t=>1=>{s=>$s},{args=>$args,of=>'w'}];
            G&perlcode,$C;
            push @suub, 'my $'.$t.' = '.c&s;
        }
        my $bab = &s{
            my $C = G&Ct,["someba"=>1=>{s=>$s}];
            G&CoBabbler;
            C.c.s
        };
        
        my @inc = 'G';
        my $l = join "\n\n",
            G.way.strictwarn,
            'use FindBin qw($Bin);',
            'use lib "$Bin/othlia";',
            'use lib "$Bin/slib";',
            (map{"use $_;"}@inc),
            'my ($A,$C,$G,$T);',
            @suub,
            'my @f = ('.join(",",map{"'$_'"}@$set).');',
            $bab->(<<'');
                saygr 'Some more';
                my $N = [map{ @{ $Beach->($_) } }@f];
                my $A = $Believe->($N);
                G.c.mas = sub {
                    my ($A,$C,$G,$T,$s) = @_;
                    1 && saygr "Es: $s";
                };
                A.t = 'toplevel';
                G.h = A.i.h || die "No h";
                G.i.t = A.i.t || die "No t";
                G.c.bay = 'bay';
                1 && sayre "Ontop";
                
                G.ydrop = 1;
                my @ha =  G&Aup;
                $A = G&A,'twanga';
                push @ha,  G&Aup;
                1 && sayyl wdump 3, [Thes=>@ha]
        
        my $f = "q\.pl";
        write_file $f, $l;
        `chmod +x $f`;
        sayre "Done";
        exit;
        #
    }
    my $Y = G&Believe,$M;
    my @seen;
    for my $A ($Y) {
        A.t = 'top';
        my $G = {};
        1 && sayre "Doing:". q{
        push @seen, G&Aup;
        };
        G.ydrop = 1;
        push @seen, G&Aup;
        1 && sayre "Toka";
        $A = G&A,'tokative';
        1 && sayre "Two";
        push @seen, G&Aup;
        1 && sayre "Ze";
        
    }
    
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    n tripes=>4=>"took: $delta"
    
    n seen=>2=>{s=>\@seen};
    
    #n file=>''=>"File is $f"
    # < clicking od not reliving Beach
    n re=>-od_3=>{s=>$Y,dl=>3}
    #
    
Jigna: | # see heads
    G.c.leakmax = 40;
    n "G.c.bay/{gou,stay}"=>-lies_02=>"/*{,/j/*,/j/*/j/*}/head"
    my ($l) = G&op;
    n _.t=>-sea_2=>{s=>$_} for $l;
    
    n sev=>7=>3489
    n theA=>3=>{s=>$A}
    # users (A.3) will stratify (into J) stages of their transform
    # unless the input looks the same
    # 
pi/sea: | # more awareness of the differing point
    Js&fam = 't hsize hago';
    S
    # if large, prefer xoics
    # be able to ask for lum from 
    s&ago = int hitime() - ss&mtime;
    s&hago = Rw mass $s:s&ago;
    s&hsize = Rw sciun $s:ss&size;
    S
    #y.at.dos = 'Continues';
    #Js&ope > Js&bowls || return;
    #Js&bowls++;
    return;
    my $v = read_file(C.t);
    my $d = Load($v);

    n t=>o1=>C.t
    n see=>''=>wdump(4,$d);
Lize: | # watch ghost/wormhole watcher
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # see stylehouse openness/movingness
    #n Besider
    # see latest them
    my $gd = "G.c.bay/via";
    n $gd=>-lies=>"*/5",'%qz'
    # < if ^ steady, skip -jackpole
    S
    
    
    my $eh = hitime();
    # < get any lies that changed, redome w/W outent
    # lay out web of dependencies
    n waved=>-jackpole=>{s=>T.op},'%qz'
    my $lies = T.op;
    
    # see updatables
    n edge=>-respec=>{s=>T.op},'%qz'
    # < if ^ steady, skip -lenot
    
    # pile with desire
    my $act = [Jig=>[$gd=>''=>{}=>'pi:Gdo']];
    n pile=>-lenot=>{s=>T.op},{runs=>$act}
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    #n tripes=>4=>"took: $delta"
    
    # look at everything
    #m zome=>-beli=>{s=>$lies}
    
    # next things take some pi sit as input
    # and continue/restart branches of thinking
    # until something comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down 
    
    # < know history to W
    # < sets most-W-owning, ordering
    # < more than one parent, 
    
    
Budge: | # shunt chute
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    Rw Elationist;
    S
    
    n tehe=>-od=>{s=>Jc&es,dl=>3}
    
letsclick: |
    sayyl "Have lets: ".ki e&us;
    my @h = e&_hC;
    my @n;
    my ($p) = grep { _s&pi eq 'pile' } reverse @h;
    push @n, shift @h until $h[0] eq $c;
    
    
    # the dos-ing's casement
    # (J that made C above the 9)
    my $o = $n[-1];
    my $i = $h[-1];
    if (os&pi eq 'lets') {
        # is an edge
        if (i.t eq 't') {
            if ( us&S ) {
                G&give:Budge=>"Add o.t to batch";
            }
            else {
                # click name to go
                # wire the button down for some G
                # exhausting for the edge of development
                my @y = $o;
                while ($o && os&ml) {
                    $o = o.y.prev || last;
                    push @y, $o;
                }
                @y = reverse @y;
                $o = (@y); # highest caretaker of o
                # < along @y may be tests wanting
                my ($run) = grep{$_} map {_s&runs} reverse @n;
                # fill out the form for action
                my $R = G&Ct,$run;
                my $E= Rc&e || die "run form not elvis";
                Ec&s = "An Update";
                # runs -1 first for fast compile check
                # then the rest in the same process
                Es&z = [map{ G&Ct,[_.t] }reverse @y];
                
                my $d = G.c.bay."/p";
                my $in = "$d/Udder/in";
                sayyl "Writing $in For ".ki $R;
                write_file($in,{append=>1},
                    sjson($R)."\n");
                
            }
        }
        else {
            if ( us&S ) {
                G&give:Budge=>"Ignore o.t's i.t change?";
            }
            else {
                G&give:Budge=>"Get interested in o.t's i.t change";
            }
        }
    }
    else {
        # general ghost/Wsitch interest in something
        # or pushing the key that didn't necessarily want to be pushed
        if ( us&S ) {
            G&give:Budge=>"Rise out of i.t";
            # or wind backward?
        }
        else {
            G&give:Budge=>"Get interested in i.t";
            # or wind forwards?
        }
    }
    
    #
    exit;
    saybl " - ".G&aC,$_ for e&_hC;
    T.pos = 0;
pi/lets: | # bitular suggestion
    y.at.dos = 'letsclick';
    n t=>o1=>C.t,'%fw:4,fs:14'
    
    my $R = c&R || die "Give Reason to lets";
    
    my $nex;$nex = &C{
        $C, C.y.next ? $nex->(C.y.next) : ();
    };
    
    for my $r ($nex->(R.y.in)) {
        for my $t ($nex->(r.y.in)) {
            my $d = tc&s;
            # the changed object ^
            # we have s&(ha/dige)_was on t
            # depending on thing, chase difference
            m "r.t t.t"=>''=>" r.t t.t "
        }
    }
    s&hs = 798;
    
    
lenotclick: | # poking around the pile
    Rw letsclick + $not=1;
pi/lenot: | # make pile of something
    y.at.dos = 'lenotclick';
    s&fs = 7;
    my $z = [
        map{ G&Ct,[_.t=>{R=>$_,cv=>1}] }
        sort {a.t cmp b.t} 
        values %{s.y.tw}
    ];
    my $tw = {map{ _.t=>$_ }@$z};
    my $got;
    for my $C (@$z) {
        my $R = C.y.R;
        my @in = map { $tw.>$_ || die "nosuchW $_" }
            split ',', Rs&inside;
        die "many ".ki$R if @in > 1;
        for my $W (@in) {
            $got.>C.t ++;
            push @{Ws&z}, $C;
        }
    }
    my @tops = grep { !$got.>_.t } @$z;
    
    my @l = map { G&ind,$_ } @tops;
    my $have;
    for my $I (@l) {
        $have.>I.t ++;
        my $R = I.y.D.y.R;
        my $K = G&Ct,[I.t=>''=>{s=>I.t}];
        Ks&ml = Ic&ind if Ic&ind;
        Ks&dis = 1; # one line
        if (exists Rs&z) {
            Kc&pi = 'lets';
            Kc&R = $R;
        }
        m $K
    }
    if (my @dont = grep { !$have.>_.t } @$z) {
        my $me = "(circular mounting?) Dont have "
            .ki\@dont;
        warn $me;
        n ohno=>o5=>"!! $me",'dis:1,hs:577'
    }
    
    for my $C (@$M) {
        
    }
pi/respec: | # compare w/W situations, make pile
    my $rs = {}; # what is
    my $tr = {}; # what is trouble
    # FactorEase w/* etc (G&ind follows thing's next)
    # this is probably where to start growing FactorEase
    my $nex;$nex = &C{
        $C, C.y.next ? $nex->(C.y.next) : ();
    };
    my $atwz = &CD{
        $D = G&Ct,$D if ref $D ne 'HASH';
        C.y.tw.>D.t ||= do {
            push @{s&z||=[]}, $D;
            $D
        };
    };
    for my $k (qw'w W K') {
        my $n = s.y.tw.>$k || next;
        $rs.>$k = [$nex->(n.y.in || next)];
    }
    
    # check way used vs now
    for my $w (@{rs.w||[]}) {
        my $y = G&wops,w.t;
        if (ws&dige ne ys&dige) {
            # w/$w/$W
            my $r = tr.w ||= G&Ct,[w=>1];
            
            my $t = G&Ct,[w.t=>1]; # way difference
            ts&dige = ys&dige;
            ts&z = [$nex->(w.y.in)]; # affected W
            _s&dige_was = ws&dige for @{ts&z};
            push @{rs&z||=[]}, $t;
        }
    }
    
    # check W's W included vs W now (K)
    my $K = { map { _.t => $_ }@{rs.K||[]} };
    for my $W (@{rs.W||[]}) {
        my @l = $nex->(W.y.in || next);
        for my $l (@l) {
            my $k = $K.>l.t;
            if (ls&ha ne ks&ha) {
                # W/$Wunder/$W
                my $r = tr.W ||= G&Ct,[W=>1];
                # each l/W may appear in many W
                my $L = $atwz->($r,[l.t=>1]);
                my $t = G&Ct,[W.t=>1]; # W difference
                Ls&ha = ks&ha;
                ts&ha_was = ls&ha;
                push @{Ls&z||=[]}, $t;
            }
        }
    }
    
    # all W
    my $tw = { map { _.t => G&Ct,[_.t,{K=>$_,cv=>1}] } values %$K };
    
    # distribute trouble to W
    # s&z problems type(w/W) / $w/$W
    each kv $tr {
        for my $p (@{vs&z}) {
            # the thing causing imbalance
            for my $t (@{ps&z}) {
                # ourselves and our end of the situation
                my $W = $tw.>t.t || die "noWtw t.t";
                # our this kind (w/W) of probs
                my $k = $atwz->($W,[$k=>1]);
                # the thing causing is the flame
                $atwz->($k,[p.t=>2=>{s=>$p},t.sc]);
            }
        }
    }
    
    # s&inside = $Wover
    for my $Wo (@{rs.W||[]}) {
        my @l = $nex->(Wo.y.in || next);
        for my $l (@l) {
            my $W = $tw.>l.t || die "noWtw l.t";
            Ws&inside = join',',grep{$_} Wo.t, Ws&inside;
        }
    }
    
    if (0) {
        my $ub = &Cd{ G&aC };
        
        saybl "\t$_" for G&ind,tr.w,$ub,{nohup=>1};
        saygr "\t$_" for G&ind,tr.W,$ub,{nohup=>1};
        my $y = G&Ct,[y=>1];
        ys&z = [sort {a.t cmp b.t} values %$tw];

        sayre "\t$_" for G&ind,$y,$ub,{nohup=>1};
    }
    
    n $_ for values %$tw;
    # all yK = jackpole's K/$W with cs = the 5ile, 5's 9 sc
    
pi/jackpole: | # map bay/$W/5 to $W and collect w/W outputs
    # to 5ile, way, W in, W out
    my $types = {};
    my $in = &KCD{
        my $K = $types.>$K ||= G&Ct,[$K=>2];
        my $B = K.y.tw.>C.t ||= $C; # known/w
        # Bs&* == Cs&*, except z
        # < more than one version of something? FactorEase
        return unless $D;
        my $E = B.y.tw.>D.t ||= $D; # unknown/W
    };
    T.op = $s;
    for my $D ( G&op ) {
        my $N = G&Beas,Dc&s;
        my ($F) = @$N;
        my $t = F.t;
        
        my $K = G&Ct,[$t=>1=>{s=>D.t}=>{%{F.sc}}];
        delete Ks&z;
        $in->(K=>$K);
        
        for my $d (@{Fs&z}) {
            for my $B (@{ds&z}) {
                $B = G&hup,$B;
                my $C = G&Ct,[$t=>1];
                if (d.t eq 'W') {
                    # our version of it under us
                    $in->(W => $C => $B );
                }
                else {
                    # us under it
                    $in->(d.t => $B => $C );
                }
            }
        }
    }
    # tw to zs
    my $twz = &C{
        my @z = sort {a.t cmp b.t} values %{delete(C.y.tw)||{}};
        s&z = \@z if @z;
        @z
    };
    my $ub = &Cd{ ki $C };
    each kC $types {
        $twz->($_) for $twz->($C);
        #saybl "$k\t$_" for G&ind,$C,$ub,{nohup=>1};
        n $C
    }
    
    # so now
    # K is for each W:
    #   cs where it came from, sc (-z) copied from its 9
    
    # W is each W including other W (one piece hierarchy)
    #   the s&ha/version there needs checked against K, what it is now
    
    # w is each way with s&dige being used by other W
    #   usually the pin
pi/lies: | # watch wormhole (mtimes)
    local A.V = 0;
    # page i increases in flood
    # stretches out lim to keep reading until it hits old news
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = "C.t/$s" if $s =~ /^\W/;
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &s{
        my $sc = {};
        (sc.size,sc.mtime) = (stat $s)[7,9];
        sc.link = readlink $s if -l $s;
        $s=>1=>{},$sc
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = G&Experience;
    
    # osc changing atom loads contents
    @$M = Rw Modulate $d $list $forms;
    
    1s&sels.mtime.>$_ = &acgt{
        if (s&size > 2000 && s&large <  2) {
            s&large = 1;
            return;
        }
        c&s = read_file(C.t);
    } for 1,3;
    
    # imparting to self again, next thing will require version bump
    # since there is no hashing the reverse of travel yet
    
 
Modulate: | # loadup M news
    # stop when old news found
    my $done;
    my $list_done;
    my $seen;
    my @l;
    my $page = 1;
    my $M = [];
    my $keen; # whether to read into the rest of the page
              # once something same has been found
    until ($done && (!$keen || !@l)) {
        if (!@l && !$done) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep { !$seen.>$_ } @{s&sz};
            @l || last;
        }
        my $s = shift @l;
        $seen.>$s = 1;
        
        my @C = $forms->($s);
        my $C = G&Ct,\@C;
        my $c = d.y.tw.>C.t;
        
        my $cha;
        
        # could use the thing beneath o
        my $l = G&Ct,[c.t=>''=>{s=>$c}];
        my $o = G&Ct,[C.t=>''=>{s=>$C}];
        G&Chang,$l,$o;
        $cha = oc&cha;
        
        # or just
        $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        else {
            sayyl "Done upon C.t";
            $done = 1;
        }
        push @$M, $C;
    }
    
    each t,C d.y.tw {
        next if $seen.>$t;
        next if !-e $t;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
pi/beli: | # wormhoe
    T.op = $s;
    my $ub = &Cd{ G&aC };
    my @stu = G&ind,$s,$ub,{nohup=>1};
    n beli=>-pud=>{dl=>6,s=>\@stu}
    #[ G&op ]}
    

