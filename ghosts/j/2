Sound: |
    # arecord -f dat -D hw:3,0 eo.wav

    # mix down to mono:
    # mplayer     -ao pcm:fast:waveheader:file=output.wav     -af pan=1:0.5:0.5     -vo null -vc null     onecha.wav
    
    # into flac:
    # arecord -f dat -D hw:3,0 | flac - -o MorganSophie9.flac
    
    # to 19twok ogg:
    # $arecording | oggenc - -q 6 -r -o MorganSophie4.ogg
    
    # for spectrograms:
    # apt-get install spek
    sayyl "Your:\t". sjson([gab=>"zoy\tblab"])
    
Atool: | # reliable/old A
    u i
    # snakinf
    Aup:
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        
Jig: | # initiates W to Jigup
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # awareness of G gou in G gou is feedback, in G view is not
    A.7.t = 'via';
    
    # to be toplevel code stitch and branching controller
    #   G ionvolk.
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    =pod
    
    super
    soft
    ''
    hard
    far
    
    with a why exuder (female) and death circuitty
    terminal input, flying hold (tripany);
    the place says T
    
    TODO
    
    the code has lost its 
    catch it in the throat maker
    
    =cut
    
    # - put Jigup wrapper on any W
    my $l = [];
    G&elph,Trips=>[tripany=>$_] for &acgt{
        return unless $l;
        # avoid W for the mind or the oscillator
        # deals with land itself
        return if A.up.up.t =~ /^(u|s)$/;
        # nor the Storage or any other agents
        return if C.t =~ /^(Stro)$/;
        
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        push @$l, G&aC,$C . "\t" . $Ats;
        
        # around method wrapper
        c&pin = 'Jigup';
    };
    
    # - the Jigups invoke Experience/writing into bay
    # supplement that with a linier storage format
    Rw AWriter;
    
    my $eh = hitime();
    my $t = 'Sequencing';
    n $t
    my $tr = T.op;
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    n tripes=>4=>"took: $delta"
    
    my @l = G&op,'cW:';
    #n ese=>o1=>"Seeing $t in beW"
    #n $t=>-od=>{dl=>3,s=>[ "jaya @l" ]}
    
    #n zaph=>-od=>{dl=>3,s=>[ G&wup,'a' ]}
    
    #n a=>V
    my @l = G&op;
    my $oo = "0.1";
    my $j = tr.y.s.1.sc.u.sc.top.y.tv.a.>$oo;
    $j = j.sc.J; 
    $j = tr.y.tv;
    n $t=>-od=>{dl=>2,s=>\@l}
    return;
    
    #n Jigna
    
    #my $ce = la.c.mo.c.s;
    n tripany=>-pud=>{dl=>3,s=>$l}
    my $d = 1s&Jignad;
    #n eco=>-pre=>{s=>"InJig: ".wdump 3, $l};
    
    # [
    #n Ghostig
    undef $l;
Jigup: | # recursively (with Trip) follow & store dependencies
    my $d = Rw Experience;
    #n oput=>8=>"Somewhere?"
    Rw C.t;
Jigdo: | # bootstrap a G from W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    A.6.t = 'via';
    my $M = [];
    for my $t (qw'To Tube') {
        my $f = Rw Locate $read=1 $t=Sequencing;
        $f .= "/1";
        my $N = Rw Beach $f;
        push @$M, @$N;
    }
    my $Y = Rw Believe $N:M;
    
    #n file=>''=>"File is $f"
    # < clicking od not reliving Beach
    n re=>-od=>{s=>$Y,dl=>6}
    #
    
AWriter: | # 7s&writer makes 12345
    7s&writer = &acgt{
        my $f = 1c&write_to;
        my $gd = 1c&write_bay;
        1 && saygr "We are A.1.t ($f)";
        
        # not s but the top/9
        my $s = G&hup,$C;
        s.c.feo.f.f.f.f.e.e.e.e = 1;
        
        # take meta off the 9, put ha on W
        my $meta;
        my $ub = &Cd{
            # the 9 has this old meta bunch
            # helped impart itself to s
            if (my $m = delete s&meta) {
                $meta && die "doublemeta";
                $meta = $m;
            }
            # assume W is in G
            if (my $t = s&W) {
                $t =~ s/\W+/-/gs;
                my $d = "$gd/$t";
                -d $d || die "Nod $d";
                my $ha = readlink "$d/1";
                $ha =~ s/^h\///;
                s&ha = $ha;
            }
        };
        G&ind,$s,$ub,{nohup=>1};
        
        # gist to first t/y sc{shape,stringth,c,sc,etc}
        # < histogram and group like things
        # < and compress styles
        # and collect W joins for 5
        my $W = G&Ct,['W',1];
        $ub = &Cd{
            return undef if d.d > 2;
            if (s&W) {
                my $D = G&Ct,[C.t,C.y.cv];
                Ds&W = s&W;
                Ds&ha = s&ha || die "W without ha";
                push @{Ws&z||=[]}, $D;
            }
            my $D = G&Ct,[C.t,C.y.cv];
            # assuming gk is safe to join with -
            # < imply the style's encoding for FactorEase
            # like we can do for Line's
            for my $k (qw'c sc') {
                my $v = $C.>$k || {};
                keys %$v || next;
                D.sc.>$k = join'-',sort keys %$v;
            }
            # seem to prefer ytv than z connection
            # < both
            Ds&zs = @{s&z||[]} if s&z;
            Ds&zs = map{values %$_} values %{C.y.tv} if C.y.tv;
            # < more shape, classify language
            Ds&slines = split "\n", c&s if c&s;
            
            Ds&W = s&W if s&W && s&W ne C.t;
            Ds&ha = s&ha if s&ha;
            
            if (d.d == 1 && C.y.cv == 0.9) {
                Ds&ha = 'HAHAR';
            }
            Rw Line $C:D;
        };
        my @four = G&ind,$s,$ub;
        
        $ub = &Cd{
            my $p = join "/", @{d.path};
            my $l = eval {
            
            s&z && die "Hadz";
            delete s&z;
            delete C.y.>$_ for qw'next prev in more up tv tw';
            Rw Line $C;
            
            };
            $@ && die "For $p:\n  C: ".ki($C)."\n$@";
            
            $l
        };
        my @all = G&ind,$s,$ub,{nohup=>1};
        
        #c storage the bits: h/$hash = content
        my $st = &st{
            $s = join "\n", @$s,'' if ref $s eq 'ARRAY';
            my $ha = slm 9, dig $s;
            `mkdir -p $f/h` if !-d "$f/h";
            my $hf = "h/$ha";
            write_file("$f/$hf", $s);
            if ($t) {
                `unlink $f/$t` if -e "$f/$t";
                `ln -s h/$ha $f/$t`;
            }
            $ha
        };
        
        # point to object: 1 -> h/$hash
        my $ha = $st->(\@all,'1');
        
        # lum feeling: 4 ~= content, 
        $four[0] =~ s/HAHAR/$ha/;
        my $foha = $st->(\@four,'4');
        
        # meta/5cience behind it: 5
        my $fi = G&Ct,[C.t,C.y.cv];
        fi.sc.ha = $ha;
        my $z = [];
        
        # belief structure dependage
        my $xo = meta.A.xo;
        if (my $way = xo.way) {
            my $w = G&Ct,[w=>1];
            my $wz = ws&z = [];
            for my $pin (sort keys %$way) {
                my $p = G&Ct,[$pin,1];
                push @$wz, $p;
                my $v = $way.>$pin;
                if (keys %$v > 1) {
                    pc&s = $v;
                    ps&way_variants = keys %$v;
                    next;
                }
                (ps&dige,ps&used) = %$v;
                delete ps&used if ps&used eq 1;
            }
            push @$z, $w if @$wz;
        }
        
        # other meta stuff
        delete $xo.>$_ for qw'way o sWo';
        if (keys %$xo) {
            push @$z, G&Ct,[xo=>1=>{s=>$xo}]
        }
        
        # other W and their ha
        push @$z, $W if @{Ws&z||[]};
        
        fi.sc.z = $z if @$z;
        $ub = &Cd{
            delete s&z;
            Rw Line $C;
        };
        my @five = G&ind,$fi,$ub;
        my $fiha = $st->(\@five,'5');
        
        # status check point: 2 versions 1,4,5
        my $t = G&Ct,[C.t,C.y.cv];
        ts&1 = $ha;
        ts&4 = $foha;
        ts&5 = $fiha;
        my @two = G&ind,$t,$ub;
        my $twha = $st->(\@two,'2');
        
        # changelog/tree: 3 -> 2, last 3...
        my $r = G&Ct,[C.t,C.y.cv];
        (my $was = readlink "$f/3") =~ s/^h\///
            if -s "$f/3";
        rs&parent = $was;
        rs&2 = $twha;
        my @three = G&ind,$r,$ub;
        my $rwha = $st->(\@three,'3');
    };
    
Line: | # C as a tabby line
    # make a line to crawl up some beach
    my $t = C.t;
    my $y = C.y.cv;
    $y =~ s/^0\.//;
    
    # aims for simplicity of notation for G&C, G&peel
    # block quotes (BQ) big strings or data after the  line
    # uses json for anything complicated
    # z insides done by the process around this one Line
    #  - they have the same indent as BQs
    #    but their t should json or not look like BQ
    
    my $simp = &s{
        $s =~ /^[\w\.\-]+$/ && length $s < 24
    };
    my $h; # hath
    h.c = C.c || {};
    h.sc = C.sc || {};
    my $n = {}; # needs json
    my $q = {}; # needs blockquote
    each nk,gk,v $h {
        if (!$simp->($gk)) {
            $n.>$nk.>$gk = $v;
            next;
        }
        if (ref $v) {
            if (G&oleak,$v,4 ) {
                G&oleak,$v,24 && die "Leaky $nk $gk: ".ki $v;
                # big enough to quote, simplifies remainder
                $q.>$nk.>$gk = $v;
            }
            else {
                # ref too small to quote, json hemisphere
                $n.>$nk.>$gk = $v;
            }
        }
        else {
            if (length $v > 42 && $v =~ /\n/) {
                # long enough to quote
                $q.>$nk.>$gk = $v;
            }
            elsif ($simp->($v)) {
                # decipherable to G&peel
            }
            else {
                # midway to unwieldy
                $n.>$nk.>$gk = $v;
            }
        }
    }}
    
    each nk,g $n { 
        my $v = $h.>$nk;
        next if !keys%$v;
        if (keys(%$g) / keys(%$v) < 0.3) {
            # quote some freaks
            $q.>$nk.>$_ = $h.>$nk.>$_ for keys %$g;
        }
    }
    
    each nk,gk,v $q {
        delete $h.>$nk.>$gk;
        delete $n.>$nk.>$gk;
    }}
    
    my $enj = &s{
        $s = sjson[$s];
        $s =~ s/^\[|\]$//sg;
        $s
    };
    
    my $l;
    if ($simp->($t)) {
        $l = $t;
    }
    else {
        $l = $enj->($t);
    }
    
    # just indent if 1
    $l .= "\t".($y ne '1' ? $y : '');
    
    for my $nk (qw'c sc') {
        my $v = $h.>$nk;
        if ($nk eq 'c' && 0 == keys %$v) {
            # blank
            $l .= "\t";
        }
        elsif ($nk eq 'c' && 1 == keys%$v && v.s) {
            # t y "the s" sc
            $l .= "\t".$enj->(v.s);
        }
        elsif ($n.>$nk) {
            # t y {c} {sc}
            $l .= "\t".$enj->($v);
        }
        elsif (keys %$v) {
            # t y W:At et:3,se:te
            my @k = sort keys %$v;
            $l .= "\t".join",",map{ "$_:".$v.>$_ } @k;
        }
    }
    
    my @l;
    each nk,gk,v $q {
        my $k = "  $nk $gk:";
        if (ref $v) {
            # BQ yaml data
            $v = Dump $v;
            $v =~ s/^--- \n//s;
            $v = join "\n", map{"    $_"}split"\n",$v;
            $k .= "\n".$v;
        }
        elsif ($v =~ /^\w([\w ,]*\w)?$/) {
            # simple strings
            # not to confuse into 'Thing 2'
            $k .= " $v";
        }
        else {
            # BQ string
            $k .= " |\n".join "\n", map{"    $_"}split"\n",$v;
        }
        push @l, $k
    }}
    
    $l = join "\n", $l, @l;
    
    $l
Beach: | # inhale Lines
    my @l = split "\n", ''.`cat $f`;
    my $tot = @l;
    my $N = [];
    local A.V = 0;
    my @in;
    my $l;
    my $lastC;
    my $peel = &s{
        return {map { split':',$_ } split ',', $s}
    };
    eval{
    while (@l) {
        $l = shift @l;
        my ($in) = $1 if $l =~ s/^(\s+)//;
        my $d = length($in) / 2;
        my ($t,$y,$c,$sc,$s) = split "\t", $l;
        
        sayyl "$in $l";
            
        $t = djson $t if $t =~ /^\W/;
        
        $y = 1 if !length$y;
        $y = 0+('0.'.$y);
        
        if ($s =~ /^\W/) {
            # fifth thing would be c.s
            $s = djson $s;
        }
        if ($c =~ /^"/) {
            $s = djson $c;
            $c = {};
        }
        elsif ($c =~ /^\W/) {
            $c = djson $c
        }
        elsif ($c) {
            $c = $peel->($c);
        }
        else { $c = {} }
        c.s = $s if $s;
        
        if ($sc =~ /^\W/) {
            $sc = djson $sc
        }
        elsif ($sc) {
            $sc = $peel->($sc)
        }
        else { $sc = {} }
        
        my $C = {t=>$t,y=>{cv=>$y},c=>$c,sc=>$sc};
        
        # add blockquoted c/sc
        while ($l[0] =~ /^$in  (\w[\S ]+):( (\||.+))?$/) {
            my ($k,$v) = ($1,$3);
            my $string;
            if ($v eq '|') {
                $string++;
                undef $v;
            }
            shift @l;
            my ($nk,$gk) = split ' ', $k, 2;
            sayyl "$in C.t C.y.cv - $nk $gk ($string) $v";
            unless ($v) {
                saybl $in."Beaming in";
                my @s;
                while ($l[0] =~ /^$in    (.*)$/) {
                    push @s, $1;
                    shift @l;
                }
                $v = join "\n", @s;
                sayyl "Loaded til $l[0]\n with $nk $gk - ".slim(30,$v);
            }
            unless ($string) {
                $v = Load $v
            }
            $C.>$nk.>$gk = $v;
        }
        
        saygr "Popped $in".ki$C;
        $in[$d] = $C;
        if ($d) {
            my $p = $in[$d-1];
            push @{ps&z||=[]}, $C;
        }
        else {
            push @$N, $C;
        }
    }
    };
    $@ && die "On line ".($tot - @l).": $l\n\n$@";
    $N
Believe: | # fold Waters together into i
    # take $N, produces A.i/A.ii
    
    
    my $tv = {}; # t v = C what are
    for my $P (@$N) { # Punter 9
        for my $C (@{Ps&z||[]}) { # Water 0.001
            c&W || next;
            
            $C = G&hup,$C;
            C.y = {cv=>C.y.cv};
            my $z = delete s&z;
            
            if (my $c = $tv.>C.t.>C.y.cv ) {
                # merge sc from the rest?
                cs&contrib .= ",P.t";
                $C = $c;
            }
            else {
                s&contrib = P.t;
                $tv.>C.t.>C.y.cv = $C;
            }
            s&z ||= [];
            for my $D (@$z) { # Doing 1
                if (my $over = C.y.tv.>D.t && C.y.tv.>D.t.>D.y.cv ) {
                    @{s&z} = grep { $_ ne $over } @{s&z};
                    delete C.y.tw.>D.t if C.y.tw.>D.t eq $over;
                }
                C.y.tv.>D.t.>D.y.cv = $D;
                C.y.tw.>D.t ||= $D;
                push s&z, $D;
            }
        }
    }
    
    # tw of 
    my $ii = {};
    for my $t
    
    for my $of (keys %$v) {
        my $o = $ii->{$of} = {t=>$of,y=>{cv=>0.001},c=>{W=>'of'}};
        my $c = $v->{$of};
        my $la = $o;
        for my $cv (sort keys %$c) {
            my $ts = $c->{$cv};
            for my $t (sort keys %$ts) {
                my $z = $ts->{$t};
                
                z.sc.coded ||
                Rw CoBabbler $C:z;
                
                my $y = eval z.c.s;
                
                die "Throcompile $of z.y.cv: z.t:"
                    .ind('  ',$@)."\n\n z.c.s\n" if $@;
                die "Not code: z.t z.y.cv: $@\n".ki $z if ref $y ne 'CODE' && !z.sc.subpeel;
                
                z.c.code = $y;
                
                if ($la eq $o) {
                    la.y.in = $z;
                }
                else {
                    la.y.next = $z;
                    z.y.prev = $la;
                }
                o.y.tw.>$t = $z;
                o.y.tv.>$t.>$cv = $z;
                $la = $z;
            }
        }
    }
    
Jigna: |
    G.c.leakmax = 40;
    n "G.c.bay/{gou,stay}"=>-lies_02=>"/*{,/j/*,/j/*/j/*}/head"
    my ($l) = G&op;
    n _.t=>-sea_2=>{s=>$_} for $l;
    
    n sev=>7=>3489
    n theA=>3=>{s=>$A}
    # users (A.3) will stratify (into J) stages of their transform
    # unless the input looks the same
    # 
pi/sea: |
    Js&fam = 't hsize hago';
    S
    # if large, prefer xoics
    # be able to ask for lum from 
    s&ago = int hitime() - ss&mtime;
    s&hago = Rw mass $s:s&ago;
    s&hsize = Rw sciun $s:ss&size;
    S
    #y.at.dos = 'Continues';
    #Js&ope > Js&bowls || return;
    #Js&bowls++;
    
    my $v = read_file(C.t);
    my $d = Load($v);

    n t=>o1=>C.t
    n see=>''=>wdump(4,$d);
Lize: | # watch ghost/wormhole watcher
    Jc&tape = 'Dejo';
    # see stylehouse openness 
    #n Besider
    # see latest them
    n "G.c.bay/via"=>-lies=>"*/xo"
    S
    n zome=>-beli=>{s=>T.op}
    # next things take that ^ as input
    # and continue/restart branches of thinking
    # until something comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down 
    n sq=>1=>"Lies of thee"
    
    d:
        lies good
    
pi/lies: | # watch wormhole (mtimes)
    # page i increases in flood
    # stretches out lim to keep reading until it hits old news
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = "C.t/$s" if $s =~ /^\W/;
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &s{
        my ($si,$mt) = (stat $s)[7,9];
        $s=>1=>{},{mtime=>$mt,size=>$si}
    };
    
    my $d = Rw Experience;
    
    # osc changing atom loads contents
    @$M = Rw Modulate $d $list $forms;
    
    1s&sels.mtime.>$_ = &acgt{
        if (s&size > 2000 && s&large <  2) {
            s&large = 1;
            return;
        }
        c&s = read_file(C.t);
    } for 1,3;
    
    # imparting to self again, next thing will require version bump
    # since there is no hashing the reverse of travel yet
    
 
Modulate: | # loadup M news
    # stop when old news found
    my $done;
    my $list_done;
    my $seen;
    my @l;
    my $page = 1;
    my $M = [];
    my $keen; # whether to read into the rest of the page
              # once something same has been found
    until ($done && (!$keen || !@l)) {
        if (!@l && !$done) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep { !$seen.>$_ } @{s&sz};
            @l || last;
        }
        my $s = shift @l;
        $seen.>$s = 1;
        
        my @C = $forms->($s);
        my $C = G&Ct,\@C;
        my $c = d.y.tw.>C.t;
        
        my $cha;
        
        # could use the thing beneath o
        my $l = G&Ct,[c.t=>''=>{s=>$c}];
        my $o = G&Ct,[C.t=>''=>{s=>$C}];
        G&Chang,$l,$o;
        $cha = oc&cha;
        
        # or just
        $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        else {
            sayyl "Done upon C.t";
            $done = 1;
        }
        push @$M, $C;
    }
    
    each t,C d.y.tw {
        next if $seen.>$t;
        next if !-e $t;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
pi/beli: | # wormhoe
    T.op = $s;
    n beli=>-pud=>[ G&op ]
    

