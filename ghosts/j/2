
DungBeatles: | # rolling language around
    # getting Wesources
    n SunBeatle
    # growth: ZenBeatle
    
    # using Wesources
    n ThWay
    
    # compiling code
    n Babblar
ZunZanBeatles: | # byt (way solver) looks in ghost/
    u i
    byt: %acgt:s t
        # hereford
        die "You look for $s called $t";
    zaputa:
        die "Hered";
SunBeatle: | # world primitives
    u i
    # sympathetic to design some stuff
    #c ge, for G.way, going
    # abstracts w/way/$pin to G.way.$pin
    # $pin must already be like-this (s/\W/-/g)
    # makes G.way.o.dige.$pin when given overrides etc (House)
    # going once G&t does all readins
    Gee:
        # make G.way.$pin retrieve code
        {
            package Wormhole;
            use G;
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my %o;
                %o = (%o, %{$_}) for @_;
                return bless [{},\%o], $class;
            }
            sub STORE {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                die "Storign o: $v" if $k eq 'o';
                if (o.nonyam) {
                    o.dige->{$k} = slm 12, dig $v unless ref $v;
                }
                $s->{$k} = $v;
            }
            sub FETCH {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                return $o if $k eq 'o';
                $s->{$k} || STORE($e,$k, do {
                    my $il = join('/', grep{defined} o.dir, $k);
                    my $f = o.base.'/'.$il;
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole', $o, {dir=>$il};
                        \%Di;
                    }
                    elsif (-f $f) {
                        o.nonyam ?
                        scalar read_file($f)
                        :
                        LoadFile($f);
                    }
                    else {
                        warn "Wormhole sens nothing: $f";
                        undef
                    }
                });
            }
        }
        my %way;
        tie %way,'Wormhole',{base=>'w/way'},{nonyam=>1};
        G.way = \%way;
        $G
    
    #c te args (i,(ii),W,w) $t $t...
    # find local(ish) things
    # looking up the slope/trail of con centers A.1..5...
    #  ii/We things by default
    #  W and w know how to look in Gspaces for names,
    #  they may also be in ii.w but are too wide to load up
    # i stuff is subs, ii stuff is classes
    # you might also be only after 5uperficia, not the code itself
    # gently pulls in remote resources... if that A takes charge
    
    # only used by throat, possibly osc
    
    # G&t,I=>$of      # for an A.ii.$of/We thing
    #                    bunch of steps for throat
    # G&t,i=>$sub     # for an A.i.$sub/G&$sub
    # ^^ should be compiled nearby
    # G&t,w=>$w     # for a way
    # ^ vaugely nearby
    # G&t,W=>$W        # for a W
    
    # maybe:
    # G&t,'>'=>$W     # for where you can write a W
    # W would want to find themselves then write themselves...
    # < W come up knowing the next gd/staging area
    # < you might want some historic view of it...
    t: %acgt:s t c
        ($s,$t) = ('I',$s) if !$t;
        $t = t.t if ref $t eq 'HASH';
        $C = {t=>$t,y=>{},c=>($c||{})};
        length C.t || die "t empty string";
        # everything looks in A.I
        c&on ||= 'I';
        # s leads us through a We thing to its t
        c&andon ||= $s if $s ne c&on;
        c&max ||= 5;
        c&min ||= 0;
        for my $i (c&min .. c&max) {
            my $Y = ($i == 0 ? $A : $A.>$i) || next;
            my $on = $Y.>c&on || next;
            if (c&andon) {
                # want We thing's things
                # put us on ii.$s.y.tw
                $on = $on.>c&andon;
                $on = on.y.tw;
            }
            
            my $the = $on.>C.t;
            if (my $by = !$the && Ys&tby) {
                my $A = $Y;
                $the = G&$by,$s,$t;
            }
            $the || next;
            c&from = $Y;
            c&inet = $i;
            return $the;
            # t may be just a pointer, to negotiate with c&desire
        }
        return
    
    # an extension to this A's G&t capacity
    # < search path for w/W
    # < G&has linking resource to moment of use (G&w does)
    byt: %acgt:s t
        if ($s eq 'W') {
            my $f = G&Locate_read,$t;
            G&Ct,[$t=>1=>{resume=>$f}];
        }
        elsif ($s eq 'w') {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $t) =~ s/\W/-/g;
            my $f = "wormhole/way/$fi";
            -f $f || sayre("Not byt $s $t: $f") && return;
            my $w = {t=>$t,y=>{}};
            wc&s = read_file($f);
            ws&dige = slm(12, dig wc&s);
            ws&of = 'w';
            $w
        }
        else {
            sayre "Unknown search $s $t ";
            return;
        }
    
    # deprecated
    # look for thing named $s in We thing named $of, on A net
    wup:
        G&t,w=>$s
    wops:
        G&t,w=>$s
    Wup:
        my $l = 
        G&t,W=>$s;
        sayre "Wup not: $s" if !$l;
        $l
    
ThWay: | # meaning of calling a word
    u i
    #c ha make G&$call, in i
    # looks up to 5 many rare/little subs
    # s is code, $D or i t
    # Me precompiled args
    # contexts calls, kinds of frame:
    # B lexical cell joinery
    # D cell itself, T.D is of A throat
    # < T.h is an error handler
    h:
        my $y; # code
        my $D; # C about code
        if (ref $s eq 'CODE') {
            $y = $s;
            if (my $d = T.D) {
                # passed code, happens to be T.D
                $D = $d if dc&code && dc&code eq $y;
            }
        }
        elsif (my $i = !ref $s && A.I && A.I.i && A.I.i.y
            && A.I.i.y.tw && A.I.i.y.tw.>$s ) {
            $y = i.c.code || die "AIi shortcut not code: ".ki$i;
            $D = $i;
        }
        elsif (ref $s eq 'HASH' && ref s.c eq 'HASH'
            && ref sc&code eq 'CODE') {
            $y = sc&code;
            $D = $s;
        }
        else {
            # avoid using G&h inside G&h:
            $D = G.i.t->($A,$C,$G,$T,'i',$s);
            $D || die "t Look fail:  i/$s   from A.t/A.c.sip";
            $y = Dc&code;
        };
        $y || die "no h: $s";
        
        my $uB = Gc&B;# || {t=>'nowhere',sc=>{A=>A.up}};
        my $B = {t=>Ds&of||"?",y=>{cv=>D.y.cv||''}};
        if ($uB) {
            B.y.out = $uB;
            if (my $p = uB.y.in) {
                # uB yin points to first call
                p.y.next = $B;
                B.y.prev = $p;
            }
            else {
                uB.y.in = $B;
            }
        }
        Bs&y = $y;
        Bs&D = $D if $D;
        Bc&s = $s;
        Bc&h = delete T.h if T.h;
        Bs&A = $A;
        Bs&C = $C;
        Bs&Me = \@Me;
        Gc&B = $B;
        Gc&mas && Gc&mas->($A,$C,$G,$T," h B.t D.t");
        ref $y eq 'CODE' || ref \$y eq 'GLOB'
            || die "B.t not code: ($s) ".G&sn ."  $y ref:"
            .ref($y)."\n   refref".ref(\$y)."\n   "
                .ki($y)."\n   ".ki $D;
        
        my @r;
        if (wantarray || !Ds&raysens) {
            @r = eval { $DB::single = G.ydrop;
                $y->($A,$C,$G,$T,@Me) };
        }
        else {
            $r[0] = eval { $DB::single = G.ydrop;
                $y->($A,$C,$G,$T,@Me) };
        }
        Gc&mas && Gc&mas->($A,$C,$G,$T,"<h B.t D.t");
        Gc&B = $uB;
        
        # sum h
        if ($@) {
            (my$ba,$@) = ($@,'');
            my $s; eval {
            $s = Rw Bangilate $ba $B;
            };
            if ($@ || Gc&avoid_Bangilate) {
                sayre "Error doing Bangilate, exiting: $@";
                exit
            }
            die $s if $s;
        }
        elsif (my $ba = Bs&warning) {
            1 && sayre "Warning:",
                Rw Bangilate $ba $B;
        }
        wantarray ? @r : $r[0];
    
    #c way gets source from outside, compiles for given args
    # Rw $pin + $v=some
    # calls $pin, inheriting args from Rw we are in
    #    plus $v = 'some'
    # $v without + implies no $ar inherits
    w:
        my $ar = {};
        # their $ar (+)
        $ar = shift @Me if ref $Me[0];
        # their args
        my @o = @Me;
        while (@Me) {
            my $k = shift @Me;
            @Me || die "w odd hash after $k: ".ki\@o;
            my $v = shift @Me;
            $ar.>$k = $v;
        }
        ar.__D && die "w __D deprecated: ".ki$ar;
        my $nar;
        # use this w call's ACGT
        # replaced once our A finds code, before its h'd
        $nar.>$_ = delete $ar.>$_ for grep {exists $ar.>$_ } qw'A C G T';
        my @args = sort keys %$ar;
        my $args = join',','A,C,G,T,ar',@args;
        
        # look in of=w up the network to 5
        # they are pins near network of knowledge via T
        my $w = G&wup,$s;
        
        # or the old way,
        if (!$w) {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            $w = {t=>$s};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
        }
        $w || die "No way to $s (on A.1.t's A.t)";
        
        ws&dige || die "w no dige: ".ki$w;
        ws&of || die "w not of: ".ki$w;
        
        my $ark = G.sc.pinark ||= {};
        # dige same across all arg variations
        my $v = $ark.>w.t.>ws&dige.>$args ||= do {
            my $v = G&hup,$w;
            v.y.argumented = $w;
            vs&args = $args;
            G&perlcode,$v,"MakingWay";
            v.c.code || die "no ccode back: ".ki$v;
            $v;
        };
        v.sc.called++;
        
        G&has,\'mo'=>way=>w.t=>w.sc.dige=>1 if A.mo;
        
        T.w = $v;
        my $A = exists nar.A ? nar.A : $A;
        my $C = exists nar.C ? nar.C : $C;
        my $G = exists nar.G ? nar.G : $G;
        my $T = exists nar.T ? nar.T : $T;
        my @arg = map{ $ar.>$_ }@args;
        if (ref $A ne 'HASH') {
            die "Not hashA: ".wdump 3, [$nar,$ar];
        }
        G.i.h->($A,$C,$G,$T,$v,$ar,@arg);
        #vc&code ->($A,$C,$G,$T,$ar,@arg);
    
    #c make s.c.code, see of (which sets dige)
    perlcode:
        $C = $s;
        # encapsulate sub with args
        G&CoArgulate;
        # translate into perl
        G&hoh,C.sc,$_ for grep{$_} G&CoBabbler;
        # c&code = eval c&s
        G&Code,$C,@Me;
    
    # c&code = eval c&s
    # l = name of situation
    Code: %acgt:s l
        ($s,$l) = ($C,$s) if !ref $s;
        $l = "$l: " if $l;
        my $Y = $Bun::A;
        delete Ys&stacktime;
        
        T.bangC = $s;
        if (my $B = Gc&B) {
            Bs&bangC = $s;
        }
        my $y = eval sc&s;
        die $l."Nocompile s.t:\n"
            .ind('  ',$@)."\n"
            if $@;
        die $l."Not code s.t: ".ki($s)
            if ref $y ne 'CODE' && !ss&subpeel;
        delete T.bangC;
        sayre join"\n", "Warning from $l s.t s.y.cv"
            if delete Ys&stacktime;
        
        sc&code = $y;
    
Babblar: | # unpack deceptions, perl code the code
    u i
    #c CoArgulate
    my @Ay =
    CoArgulate:
        s&of || die "No of on ".ki$C;

        s&args ||= join',','A,C,G,T',grep{$_ ne '1'}s&acgt if s&acgt;
        s&args =~ s/[\+ ]/,/sgm;

        s&code && sayre "CoArgu C.t C.y.cv has scode: s&code:\n  ".ki$C;

        my $ara = [];

        exists s&t &&
            Rw conot $C;

        # the nk/gk it wants to wake up
        my $pasn = sub {
            my $v = shift;
            my ($nk,$gk,$more) = $v =~ /^([tycs])?(\S*)(?: (.+))?$/;
            $nk = 'sc' if $nk eq 's';
            $nk ||= 'c';
            $nk && $gk || die"strv:$v -> $nk,$gk from ".ki $C;
            ($nk,$gk);
        };
        (s&nk,s&gk) = $pasn->(s&v) if s&v;
        (s&nnk,s&ngk) = $pasn->(s&v) if s&Nv;

        # < not doing this, relying on throat to pass nk gk as $s?
        if (my $nk = s&nk) {
            push @$ara, "my \$".$nk." = C\.".$nk.";";
            if (my $gk = s&gk) {
                # dont remy v=cs in acgts
                my $my = "my " unless s&args =~ /\b$gk\b/;
                warn "Redefined the $gk ($nk\.$gk): ".ki$C if $gk =~ /^[ACGT]$/;
                push @$ara, "$my\$".$gk." = C\.".$nk."\.".$gk.";";
            }
        }

        C.sc.>$_ && die "Given $_: ".ki $C for qw'rg cg';

        s&args ||= 1;
        if (my $args = s&args) {
            #die "wonky C.t   of ".ki $C if C.t =~ /\W/;
            my $gl = "";
            my $und = "_";
            # it becomes something
            my ($sf,$sa) = ('(',')->($A,$C,$G,$T)') if s&subpeel;
            my $sub = "sub {\n";
            if ($args ne '1') {
                my @args;
                my $und = '_';
                if ($args =~ s/^(A,C,G,T,)(?!s$)//) {
                    push @args, 'my ($A,$C,$G,$T,@M)=@_;';
                    $und = 'M';
                }
                push @args, "my (".join(',',map{'$'.$_}
                    split',',$args).',@Me) = @'.$und.";";
                unshift @$ara, @args;
            }
            c&s .= "\n" if c&s !~ /\n$/;
            c&s = $sf
                ."sub {\n"
                .join("",map{"$_\n"} @$ara)
                .c&s
                ."}"
                .$sa
                .";";
        }
    #c CoBabbler
    bitsof_babble:
        my $p;
        p.alive = qr/\$[\w]*[\w\->\{\}]+/;
        p.dotha = qr/[A-Za-z_]\w{0,3}(?:\.[\w-]*\w+)+/;
        p.oing = qr/\w*p.alive|p.dotha|[-\w]{8,}/;
        p.oint = qr/[\w\$\/\->\{\}\*]*[\w\$\/\->\.\}\*]+/;
        p.mwall = qr/(?:= |if |unless |^\s*)/;
        p.sur = qr/ if| unless| for| when|,?\s*$|;\s*/;
        $p
    push @Ay,
    CoBabbler: %right
        my $sc; # C.sc.* to be set from this encoding
        my $p = G.sc.bitsof_babble ||= G&bitsof_babble;
        
        my @s;
        my $indbe;
        my $inend;
        my $indun;
        my $angt = '<'.'<';
        for my $l (split "\n", c&s) {
            my $s = $l;
            # things:
            $s =~ s{^(\w+)(?: (-?\w+))?:(?: (%.+))?$}
                {n $1 =>'$2',$angt'',"$3"}smg;
            if ($indbe) {
                if ($indun eq 'NEXT') {
                    $s =~ /^(\s+)/ || die "Must Indunext:\n$s[-1]\n$s";
                    $indun = $1;
                }
                if ($s =~ $indbe) {
                    $s =~ s/^(\s*)\.(\s*)$/$1$2/;
                    $s =~ s/^$indun//
                        if defined $indun;
                    push @s, $s;
                    next;
                }
                else {
                    undef $indbe;
                    undef $indun;
                    if ($s !~ /^\s*$/) {
                        if ($inend) {
                            pop @s  if $s[-1] eq '';
                            push @s, $inend;
                        }
                    }
                    else {
                        $s = $inend if $inend;
                    }
                    undef $inend;
                }
            }
            my $ze = qr/$angt['"](\w*)['"]/;
            if ($s =~ /^(\s*)(?!#)\S.*$ze/) {
                if ($2) {
                    # for <#<'EOD' til ^EOD, etc
                    $indbe = qr/^(?!\Q$1\E)/;
                }
                else {
                    $indbe = qr/^($1\s+|\s*$)/;
                    $indun = 'NEXT';
                    $s =~ s/$ze/$angt.($1?"'$1'":"'STEVE'")/e;
                    $inend = 'STEVE' if !$1;
                }
            }
            
            #c with the not-in-blockquote intelising:
            # say things depending on A.V (verbosity)
            my $sw = {};
            $sw.>$_ = 'say' for qw'saygr saybl sayyl sayre say';
            %$sw = () if C.sc.nobasay;
            for (keys %$sw) {
                my $if = $_ ne 'sayre' ? "A\.V && " : "";
                $s =~ s/^(\s*)$_ ([^\n]+?)((?: (?:for|if) .+)?;?)$/${1}${if}G\.h->(\$A,\$C,\$G,\$T,'$sw->{$_}','$_',$2)$3/sgm;
            }

            #
            # 22Cs&blue -> A.2.2.c.s.sc.blue
            for my $l (qw'y c s') {
                my $nk = $l eq 's' ? 'sc' : $l;
                $s =~ s/\b(up|\d+|A\w+?)(C)?$l\&(\w+)/
                    my ($net,$see,$gks) = ($1,$2,$3);
                    if ($net eq 'up') {
                        $net = join'.','A',$net;
                    }
                    elsif ($net =~ m{^A.+}) { # A.L...
                        # TODO split lc like words, know cs is c.s, etc
                        $net = join'.',split'',$net;
                    }
                    else { # numbers
                        $net = join'.','A',split'',$net;
                    }
                    $see = ".c\.s" if $see;
                    $gks = "\.$gks" if $gks ne 'C';
                    "$net$see\.$nk$gks"
                /smeg;
            }

            # s&eo -> C.sc.eo etc
            $s =~ s/\bs\&(\w+)/C\&$1/sgm;
            $s =~ s/\bA\&(\w+)/A\.c\.$1/sgm;
            $s =~ s/\ba\&(\w+)/A\.sc\.$1/sgm;
            $s =~ s/\b((?!u)\w)s\&(\w+)/$1\.sc\.$2/sgm;
            $s =~ s/\b(\w)c\&(\w+)/$1\.c\.$2/sgm;
            $s =~ s/\b(\w)y\&(\w+)/$1\.y\.$2/sgm;
            
            # S / T
            # label-making do or return sleepomatics
            my @num;
            for my $sym ('S','T') {
                # become gotoable, for test frames
                $s =~ s{^(\s*)$sym(?: (\S+.*?))?\s*$}{
                    my $l = $2;
                    (my $label = $l) =~ s/\W+/_/sgm;
                    if ($label eq '' && $sym eq 'S') {
                        $label = $l = 1 + @num;
                        push @num, $label;
                    }
                    $label = $sym."_$label: ";
                    qq[$1${label}G\&$sym,"doming","$l" || return;]
                }sgme;
            }
            sc.num = @num if @num;

            # look for th/$ing in A.?.th.ing and A.c.?.th.ing
            # trip if so
            for my $sym ('trip') {
                $s =~ s{^(\s*)$sym (\S+)\s*$}{
                    my $ind = $1;
                    # 
                    my (@n) = split '/', $2;
                    my @opt = map {
                        my $st = $_;
                        my @lot;
                        join " && ", $st, map {
                            push @lot, $_;
                            $st . join('',map{
                                /^\w+/ && !/\./ ? "\.$_" : "\.>$_";
                            } @lot);
                        } @n;
                    } "A\.$sym", "A\.c\.$sym";
                    my $in = "(".join(" || ", @opt).")";
                    my $quot = join',',map { /^\w+/ && !/\./ ? qq{"$_"} : $_ } @n;
                    "$ind$in && G&"."$sym,$quot;"
                }sgme;
            }

            c&s =~ s/^(\w+:)\s+$/$1/smeg 
                && sayre "Blockquoter whitespace trimmed";

            # little sub maker
            # G may like to track lamda meta in a coderef => $D like way
            #    wants to be a function the sub passes through
            # one word args assumed to be many single letter args
            my $codes = sub {
                my @r = split',',shift;
                my $acgt;
                $acgt = shift(@r) if $r[0] eq 'acgt';
                $acgt = 1 if $r[0] =~ s/^acgt//;
                @r = split '', $r[0] if @r == 1;
                unshift @r, qw'A C G T' if $acgt;
                my $arg = " my (".join(',',map{'$'.$_}@r).") = \@_;"
                    if @r;
                "sub {".$arg
            };
            $s =~ s[(\W)\&(\w+(?:,\w+)*)?\{][$1.$codes->($2)]smeg;

            # each etc $data {    into:
            # while (my ($e,$tv) = each %$data) {
            # while (my ($t,$c) = each %$tv) {
            #   so the value tv is for t-ing into
            # DIY closing brackets
            # avoids eaching nonref after first
            # could replace with G&chew-ish call if more spec
            # and know indents to close
            my $doi = sub {
                my ($ind,$in,$from) = @_;
                my @in = split ',', $in;
                @in = split '', $in[0] if @in == 1;
                my @open;
                while (@in) {
                    my $s = 'while (my ($'.shift(@in).',$';
                    my $ismore = @in > 1;
                    my $v = $ismore ? 
                        $in[0].'v' : shift(@in);
                    $s .= $v;
                    $s .= ') = each %{'.$from.' }) {'
                        .($ismore ?
                            " ref \$$v eq 'HASH' || next;" : "");
                    $from = '$'.$v;
                    push @open, $s;
                }
                @open = map { $ind.$_ } @open;
                join "\n", @open;
            };
            $s =~ s/^(\s*)each (\w+(,\w+)*) (\S+) \{(\s*)$/
                $doi->($1,$2,$4);
            /smeg;
            #c expect closing brackets and insert J
            
            # n $C etc
            my $gh = "G\.h".'->($A,$C,$G,$T';
            $s =~ s/(p.mwall)(u|n) (.+?)(;| for(.*?))?$/
                "${1}$gh,\"$2\",$3=>'')".($4||';')/smeg;
            
            # m $C passes $M
            $s =~ s/(p.mwall)(m) (.+?)(;| for.*?)?$/
                "${1}$gh,\"$2\",\$M,$3=>'')".($4||';')/smeg;
            
            # C&hs = 388 # C.sc.>hs
            $s =~ s/\bC&(\w+)\b/C\.sc\.$1/g;
            $s =~ s/\bc&(\w+)\b/C\.c\.$1/g;
            # e&you -> G&e,"you"
            $s =~ s/\b([e])&(\w+)\b/G\&$1,"$2"/g;
            
            # also e&so -> G&e,"so"...  generalised name pickup
            # spiral slumping. us&hJ works sometimes somehow?
            $s =~ s/ ((?!G)\w+)\&(p.oint)/ G\&$1,"$2"/g;
            
            # G&thing:"with space in args";
            $s =~ s/(p.oing|\w+)\&(p.oint)(:\S+[^\n;]+)(;)?/
                my ($on,$p,$e,$t) = ($1,$2,$3,$4);
                $e =~ s{^:}{,};
                ($on,my$in) = ("G\.h",'$A,$C,$G,$T,')
                    if $on eq 'G';
                my $s = $on."->($in\"$p\"$e)$t";
                $s = '$'.$s if $on !~ m{\.};
                $s
            /smge;
            # G&usi,$s -> G.h->(acgts)
            $s =~ s/(p.oing|\w+)\&(p.oint)(,[^\s;]+)?(;)?/
                my ($on,$p,$e,$t) = ($1,$2,$3,$4);
                ($on,my$in) = ("G\.h",'$A,$C,$G,$T,')
                    if $on eq 'G';
                my $s = $on."->($in\"$p\"$e)$t";
                $s = '$'.$s if $on !~ m{\.};
                $s
            /smge;
            # $sc.>$k -> $sc->{$k}
            $s =~ s/(p.oing)((?:\.>p.oing)+)/
                join '->', $1, map {'{"'.$_.'"}'}
                grep {$_} split m{\.>}, $2;
            /smge;
            
            #c Rw
            while ($s =~ /(Rw (p.oint)(?:(?!p.sur) (.+?))?)p.sur/gsm) {
                my ($old, $op, $oa) = ($1, $2, $3);
                my $g;
                $g ||= '$G';
                
                my $ne = ""; # hidden reverse
                $ne = $1 if $oa =~ s/(p.sur)$//;
                
                my @n;
                my @m;
                # want to mix {m m m %$ar m m} whereever + is
                my $wanr = $oa =~ s/^\+ ?//;
                $wanr = 'stick' if $oa =~ s/^- ?//;
                for (split /\,| |\, /, $oa) {
                    # sweet little pool... $J:geo etc
                    if (/^\$((\w+(:|=))?\S+)$/) {
                        my ($na, $fa, $wa) = ($1, $2, $3);
                        if (!$fa) { # fake name, to ar
                            $fa = $na;
                        }
                        else {
                            $na =~ s/^\Q$fa\E//;
                            $fa =~ s/(:|=)$//;
                            if ($wa eq '=') {
                                $na = '"'.$na.'"';
                            }
                        }
                        $na = '$'.$na unless
                            $wa eq '=' || $na =~ /^\S+\.\S/;
                        push @n, "$fa=>$na" ; # also avail a listy position
                    }
                    else {
                        push @m, $_;
                    }
                }
                unshift @n, '$ar' if (!@n || $wanr) && $wanr ne "stick";
                push @n, "m=>[".join(',',map{'"'.$_.'"'}@m).']'
                    if @m;
                
                my @e;
                push @e, '"'.$op.'"';
                push @e, join(",",@n);
                my $en = join ",", @e;
                
                my $wa = $g.'->{w}->($A,$C,$G,$T,'.$en.')'.$ne;
                $s =~ s/\Q$old\E/$wa/          || die "Ca't replace $1\n\n $s";
            }
            
            # sc.k -> $sc->{k};
            $s =~ s/([A-Za-z_]\w*)((?:\.\w+)+)/"\$$1".join"",map {"->{$_}"} grep {length} split '\.', $2;/segm;
            # 
            push @s, $s;
        }
        push @s, $inend if $indbe && $inend;
        c&s = join "\n", @s;
        $sc
    
    #c and re-pretend the going G&won
    if (@Ay == grep {_.ii && _.la} @Ay) {
        my @co = map{ _c&s }map{_.la} @Ay;
        n won=>''=>join("\n\n",map{_c&s}@co)
        1 && saygr "Made won out of ".join", ",map{_.t}@co;
        #saygr "Ay: ".wdump 3, [@co];
    }
    
    
    
of: | # compile/collect
    # container process is traveling bunches of code, see 99 Traweil
    # place toward A.ii.>$s, linked list of embryo
    my $of = C.t;
    my $ark = G.sc.codeark ||= {};

    # rennovating around town
    # a geodesic self-mover
    # keeps rebuilding in different locations
    
    # this way should export osc hooks and another way...
    for my $C ( e&_cz ) {
        c&s || sayre "C.t C.y.cv has no s: ".ki $C;
        if (!c&code && (s&args || s&acgt)) {
            # may already be compiled
            # shades code through the wall
            # the W listened to needs one osc in G, then all can whole it
            # coded while the W goes through the wall
            my $coded = delete(s&coded) || s&args && s&acgt;
            my $digs;
            my $scbab;
            c&s .= "\n" unless c&s =~ /\n$/s;
            unless ($coded) {
                # shade the edges, args, parsables etc.
                G&CoArgulate;
                # CoB/Code must depend on c&s now and make only c&code
                # unless a track is cut for adding universals...
                # like a map of extra lines babbled
                #   (caused by block quotes, argulation...)
                $digs = dig c&s;
                if (my $y = $ark.>$of.>C.t.>$digs) {
                    (c&s, c&code, $scbab) = @$y;
                    undef $digs;
                }
                else {
                    # translate into perl
                    $scbab = G&CoBabbler;
                }
            }
            c&s =~ s/(#[^\n]+};)$/};/s
                && sayre "commented closing bracket in C.t C.y.cv, was: $1";
            G&Code,$C,"Of=$of" if !c&code;
            
            G&hoh,C.sc,$scbab if $scbab;
            $ark.>$of.>C.t.>$digs = [c&s,c&code,$scbab] if $digs;
            
        }
        track: # etc
        s&dige = slm 12, dig c&s if exists c&s && !ref c&s;
    }

    delete s&J; # be of W only (osc should mute if J=t)
    T.nose = 1;
    T.pos = 0;
    
conot: | # expand sc.t->ip, compiled throat clause
    my $ip = C.sc.ip = {};
    my $or;
    my @o;
    my $t = C.sc.t;
    
    # convert 3-4 or 3 to >=0.3 <0.4
    #            or 33 to >=0.33 <0.34
    #            or 3+ to >=0.3   (with 9er)
    if ($t =~ /^((\d+)(?:(\-|\+)(\d+))?)/) {
        my $s = $1;
        my $n = 0+('0.'.$2);
        my $se = "ycv:>=$n";
        if ($3 ne '+') {
            my $u = $4 ? 0+('0.'.$4)
                : $n + 1 / 10 ** length($2);
            $se .= " ycv:<$u";
        }
        $t =~ s/^\Q$s\E/$se/s || die "Not replacable $se in $t";
    }
    
    for my $k (split ' ', $t) {
        $or++, next if $k eq '||';
        my $ok = $k;
        my $is;
        # ^ our C.t
        $k =~ s/^(\w+):\^$/"$1:".C.t/e;
        # complication
        $is = C.sc.>C$k if exists C.sc.>C$k;
        
        my $p;
        # simple key:val ing
        if ($k =~ /^(\w+):([^:]*)$/) {
            $k = $1;
            $is = $2;
            (p.nk,p.gk) = G&pang,$k;
            p.gk || delete p.gk;
        }
        # pint further
        elsif ($k =~ /\w+:\w+/) {
            my @p = split ':', $k;
            $k = $p[0];
            $is = ''; # exists
            $is = $1 if $p[-1] =~ s/([^\w\.-]+.+$)//;
            p.pint = \@p;
        }
        else {
            die "Unknown sc t bit: $k";
        }
        die "merge in? ".ki$is if ref $is;
        (p.or,$or) = (1,0) if $or;
        
        if (defined $is) {
            my $i;
            my $neg = $is =~ s/^\!//;
            $i = 'gt' if $is =~ s/^>//;
            $i = 'lt' if $is =~ s/^<//;
            $i.= 'eq' if $is =~ s/^=//;
            $i = 're' if $is =~ s/^~//;
            $i ||= 'is';
            if ($i eq 'is') {
                if ($is eq "''") {
                    $is = '';
                }
                elsif (!length($is)) {
                    $i = 'true';
                    $is = 1;
                }
            }
            p.neg = 1 if $neg;
            $p.>$i = $is;
        }
        $k =~ s/(\d+)?$/$1+1/e while exists $ip.>$k;
        push @o, $k;
        $ip.>$k = $p;
    }
    ip.order = \@o if @o > 1;
Bangular: |
    my $end;
    $SIG{ALRM} = &{
        die "Was about here!";
    };
    $SIG{__WARN__} = &{
        my ($s) = @_;
        return if $s =~ /Deep recursion on (anonymous )?subroutine/
            || $s =~ /masks earlier declaration in same/;
        $end->($s);
        warn "Warndg: $s";
    };
    my $lastts;
    $SIG{__DIE__} = $end = &s{
        return if $lastts >  hitime() - 1;
        sayre "SIGDIE began: ".slim(200,$s);
        $lastts =  hitime();
        my $notabang = !$@;
        $s && $@ && sayre "stackend with \$@ and arg0";
        $s ||= $@;
        $s ||= do { saygr "\$@ was blank"; $_[0] };
        local $@;
        eval { G::confess( 'yab' ) };
        my @stack = split m/\n/, $@;
        
        shift @stack for 1,2; # this sub and that eval ^
        if (0 || $stack[-1] =~ /^\s+Mojo::IOLoop::start/) {
            pop @stack until $stack[-1] !~ /Mojo|eval/;
        }
        
        my @stock;
        my $stacking;
        # suckup string spilling out of a line
        for my $l (@stack) {
            if ($stacking) {
                if ($l =~ /^\t\S/) {
                    $stacking = 0;
                    push @stock, $l;
                }
                else {
                    push @{$stock[-1]}, $l
                }
            }
            elsif ($l =~ /^\teval '/) {
                $stacking = 1;
                push @stock, [$l];
            }
            else {
                push @stock, $l;
            }
        }
        @stack = map { ref $_ ? join "\n", @$_ : $_ } @stock;
        
        @stack = map{
            my $l = {y=>{}};
            ls&dataline = $1 if s/, <DATA> line (\d+)\.\n?$//s;
            
            if (/^\s*(?:eval \{\.\.\.\} |([^\(\s]+)::([^\s\(]+?)\((.+)\) )called at (\S+|\(eval \S+\)) line (\d+)$/) {
                ls&pack = $1 if $1; # usu main, undef for eval{}
                ls&sub = $2 if $2; # usu __ANON__, "
                ls&Mes = $3 if $3; # stringified @_
                ls&file = $4 if $4; # usu (eval \d+) or stylehouse.pl
                ls&line = $5 if $5; # in the code above this call
            }
            elsif ($_ =~ /^\teval '(.+)' called .+?$/sgm) {
                ls&file = 'eval $s';
                ls&string = $1;
                lc&s = $_
            }
            else {
                lc&s = $_
            }
            $l
        } @stack;
        my $B = Gc&B;
        Bs&stack = \@stack;
        Bs&warning = $s if $notabang;
        
        Bs&callers = [map{ [caller($_)] }0..4];
    };
    sayre "Bangular loaded";
Bangilate: |
    # handler figured it safe from below
    Bs&hand && return;
    
    # Bangilated already, pass out
    # on each enclosing h
    # < look at caller() eval nums for more stack sync
    #   be good to have lines calling from last Jpin, w, and h
    Bs&foot && return $ba;
    
    Bc&h && die "< Have the handler to $ba things.";
    
    Gc&avoid_Bangilate && sayre("Errors Bangilating, will exit: $ba") && exit;
    
    # here
    my $D = Bs&D;
    # bangC is code the problem would have come from
    my $d = Bs&bangC || delete(T.bangC) || $D;
    
    # stack syncy to know G&h's eval number:
    my $hs_file = (caller(0))[1];
    my ($st,$l,$for);
    eval{
    $st = Rw StackSyncy + $D $d $hs_file;
    ($l,$for) = Rw StackShuf + $D $d $st;
    };
    if ($@) {
        sayre "Error doing Bangilate/Stack*: $@";
        $l = ["<<<Error doing Bangilate/Stack*: $@>>>"];
        Gc&avoid_Bangilate = 1;
        $@ = "";
    }
    1 && sayre "Stack,";
    
    
    #c codesplatter
    
    (my $clear = $ba) =~ s/, <\w+> line \d+\.//;
    my ($line) = $clear =~ /.+ line (\d+)/g;
    if (my $v = @$for == 1 && $for->[0]) {
        if (v.t =~ /^\(eval \d+\)$/) {
            1 && saygr "line $line really vs&line? from ".ki v.t;
            #$line = vs&line;
        }
    }
    
    my @obya;
    eval{
    for my $gk (qw'aA aC') {
        my $v = B.sc.>$gk;
        ref $v || next;
        my $label = "  Bs&".$gk.": ";
        if (ref $v eq 'HASH' && v.y eq $v) {
            my @S = $v;
            unshift @S, $v while $v = v.up;
            $v = $S[-1];
            my $max;
            $max = _c&ind > $max ? _c&ind : $max for @S;
            # make a reverse ind tree of nodes coming down to here
            my @L = map {
                my $ind = $max - _c&ind;
                $ind += length $label;
                $ind = join('',(' ') x $ind);
                my $c = {%{_.c}};
                "$ind _.t".(ref c.s ? " C=".ki delete c.s : "")
                ."  ".ki {c=>$c,sc=>_c&sc}
            } @S;
            push @obya, @L;
            
        }
        push @obya, $label .ki $v;
    }
    };
    if ($@) {
        sayre "Error doing Bangilate/obya: $@";
        Gc&avoid_Bangilate = 1;
        $@ = "";
    }
    my $obya = join"\n","obya:",@obya if @obya;
    
                
                my @tri;
                if ($line) {
                    1 && sayyl "Line is $line";
                    my @s = split "\n", dc&s;
                    my ($for,$aft) = (5,3);
                    @tri = ([]); # split into three
                    my $i = 1;
                    for (@s) {
                        $i eq $line && push @tri, [];
                        $i > $line - $for && $i < $line + $aft
                            && push @{$tri[-1]}, $_;
                        $i eq $line && push @tri, [];
                        $i++;
                    }
                    @tri = map {join "\n", @$_ } @tri
                }
                
                my $Bs = join "\n", @$l;
                my $code = join "\n>>>>>>>>>>\n", map{
                    join "\n", map{"| ".$_} split "\n", $_
                } @tri if @tri;
                
                my $li = [split "\n", $ba];
                if (@$li > 30) {
                    my (@st,@ar);
                    push @st, shift @$li while @$li && @st < 30;
                    while (@$li && @ar < 5) {
                        push @ar, shift @$li;
                    }
                    $ba = join "\n", @st, @ar ? ("...snip ".(@$li)."...", @ar) : ();
                }
                
                $ba = join "\n\n", grep {defined} $Bs, $code, $ba, $obya;
                
                # die...\n keeps first line number
                return $ba."\n";
StackSyncy: | # identifies bits of the caller() (smaller) stack and returns it
    # index landmarks
    my $na = {};
    my $Bs = {%{B.sc},%{B.c}};
    Bs.G = $G;
    Bs.T = $T;
    Bs.Dw = D.y.argumented if D.y.argumented;
    each gk,v $Bs {
        next unless $gk =~ /^..?$/;
        next unless ref $v;
        my $r = "$v";
        $na.>$r = "$gk";
    }
    my $i = 1;
    
    for my $v (@{Bs&Me||[]}) {
        my $r = "$v";
        $na.>$r = "arg".$i++;
    }
    for my $n (2..5,'up','up.up','up.up.up') {
        my $k = "A$n";
        my $Y = $A;
        if ($n =~ /\./) {
            my @ks = split /\./, $n;
            $Y = $Y.>$n || next for @ks;
            $Y || next;
        }
        else {
            $Y = $Y.>$n || next;
        }
        ref $Y || next;
        my $r = "$Y";
        $na.>$r = $k;
        if (my $C = Y.c && Y.c.s) {
            my $k = $n."C";
            my $r = "$C";
            $na.>$r = $k;
        }
        if (my $T = Y.c && Y.c.T) {
            my $k = $n."T";
            my $r = "$T";
            $na.>$r = $k;
        }
    }
    
    # find landmarks in callstack
    my $st = Bs&stack;
    for my $t (@$st) {
        t.t = delete ts&file;
        t.t = 'h' if t.t eq $hs_file;
        ts&Mes =~ s/\Q$_\E/$na.>$_/
            && do { ts&matches->{ $na.>$_ }++ }
            for keys %$na;
    }
    $st;
StackShuf: | # shove B stack over the illuminated middle of caller() stack
    # split callstack around B stack
    # near the beginning of it should be our h call
    # < deduce every h, just to first and from last
    my ($lit) = my ($for,$aft) = ([],[]);
    for my $t (@$st) {
        $lit = $aft if t.t eq 'h';
        push @$lit, $t;
    }
    
    # beyond h/B stack
    if (!@$for) {
        my ($t) = @$for = shift @$aft if !@$for;
        if (t.t eq 'h') {
            eval {
            $d = G&t,i=>'h';
            };
            sayre "Tried to show you h" if $@;
            # dying in G&h, you probably want to know where it came from tho
        }
    }
    
    my $destack =&t{
        t.t ?
            sprintf(" - %-18s %4s: %s", t.t, ts&line, ts&Mes)
        :   sprintf(" ? %s", G&aC,$t )
    };
    my $l = [map{ $destack->($_) }@$for];
    
    my @Ds; # picture of B
    
    # climb Byout
    # < rename Byup?
    # Bc&s is the first argument to h, may be a D
    my $deB = &B{
        sprintf(" B %-4s %4s %8s", B.t,
            (B.y.cv ne '0.1' && B.y.cv),
            (ref Bc&s eq 'HASH' ? Bc&s.t : Bc&s),
        );
    };
    
    my @Bs;
    my $BB = $B;
    while ($BB) {
        push @Bs, $BB;
        $BB = BB.y.out;
    }
    $BB = $B;
    for my $B (@Bs) {
        # tell aboves we did this
        Bs&foot = $BB;
        
        my $D = G&Ct,[B.t,'',{s=>$deB->($B)},{B=>$B}];
        
        if ($B eq $BB) { # extra sense for last B
            my $i = 1;
            my $o; # grap arg1 to ar
            my $or; # arg$n that are ar bits
            my $ra; # ar bits not covered by an arg$n
            if (B.t eq 'w' && Bs&Me) {
                my $ar = Bs&Me->[0];
                ref $ar eq 'HASH' || die "Yul";
                $ar = {%$ar};
                $ra = {%$ar};
                each k,v $ar {
                    my $i;
                    my $is;
                    for (@{Bs&Me||[]}) {
                        $i++;
                        $is = $i if $v eq $_;
                    }
                    if ($is) {
                        delete $ra.>$k;
                        $ar.>$k = "<arg$is>";
                        $or.>$is = "$k";
                    }
                }
                # was $ar for whittled oneline $ar
                o.1 = $ra;
            }
            for my $r (@{Bs&Me||[]}) {
                my @l;
                if (my $ar = $o.>$i ) {
                    for my $k (sort keys %$ar) {
                        my $v = $ar.>$k;
                        my $s = ref $v ? ki $v : slim 50, $v;
                        push @l, sprintf("%12s  %s",$k,ki $v );
                    }
                }
                else {
                    my $s = ki $r;
                    my @also;
                    if ($r eq $d) {
                        $s = G&aC,$r;
                        my $sc = ki r.sc;
                        $s =~ s/%.+$/%: $sc/;
                        @also = "      * described below";
                    }
                    my $or = $or.>$i;
                    $or = "/$or" if $or;
                    push @l, sprintf("%12s  %s","arg$i$or",$s), @also;
                }
                $i++;
                push @{Ds&zs||=[]}, @l;
            }
            Dc&s .= " args:ds&args";
        }
        push @Ds, $D
    }
    
    my $o;
    for my $D (reverse @Ds) {
        my $B = Ds&B;
        for (qw'A C') {
            my $v = B.sc.>$_ || next;
            $v eq $o.>$_ && next;
            $o.>$_ = $v;
            (my $cv = v.y.cv) =~ s/^0\.//;
            my $sc = "  -vs&pi" if vs&pi ;
            Dc&s .= "  $_:v.t $cv$sc";
        }
    }
    push @$l, join "\n", _c&s, @{_s&zs||[]} for @Ds;
    
    my @fin;
    for my $t (reverse @$aft) {
        last if t.t eq 'h';
        push @fin, $destack->($t);
    }
    if (@fin) {
        push @$l, reverse @fin;
    }
    
    @$l = reverse @$l;
    ($l,$for)

