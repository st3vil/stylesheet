Sound: |
    # arecord -f dat -D hw:3,0 eo.wav

    # mix down to mono:
    # mplayer     -ao pcm:fast:waveheader:file=output.wav     -af pan=1:0.5:0.5     -vo null -vc null     onecha.wav
    
    # into flac:
    # arecord -f dat -D hw:3,0 | flac - -o MorganSophie9.flac
    
    # to 19twok ogg:
    # $arecording | oggenc - -q 6 -r -o MorganSophie4.ogg
    
    # for spectrograms:
    # apt-get install spek
    sayyl "Your:\t". sjson([gab=>"zoy\tblab"])
    
Atool: | # reliable/old A
    u i
    # snakinf
    Aup:
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        return $Ats;
        
Jig: | # initiates W to store somewhere
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    # awareness of G gou in G gou is feedback, in G view is not
    A.7.t = 'via';
    
    # to be toplevel code stitch and branching controller
    #   G ionvolk.
    # but really, wrap a bunch of Lize beings, like tests
    # with W commits of gou -> stay
    # system may feed back
    =pod
    
    super
    soft
    ''
    hard
    far
    
    with a why exuder (female) and death circuitty
    terminal input, flying hold (tripany);
    the place says T
    
    TODO
    
    the code has lost its 
    catch it in the throat maker
    
    =cut
    
    # - put wrapper on any W
    my $l = [];
    G&elph,Trips=>[tripany=>$_] for &acgt{
        return unless $l;
        # avoid W for the mind or the oscillator
        # deals with land itself
        return if A.up.up.t =~ /^(u|s)$/;
        # nor the Storage or any other agents
        return if C.t =~ /^(Stro)$/;
        
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        push @$l, G&aC,$C . "\t" . $Ats;
        
        # before method wrapper, returning $d to c&phind
        c&phin = 'Experience';
    };
    
    # - the Jigups invoke Experience/writing into bay
    # supplement that with a linier storage format
    Rw AWriter;
    
    =pod
    n Placement
    n Sequencing
    n Intel
    n ForJ
    n Tangle
    n Stuff
    
    n Art
    
    n Storage
    n Elvising
    n Tripical
    =cut
    
    for my $t (qw'Atool Placement Sequencing Intel ForJ') {
        #next unless $t =~ /^P/;
        my $eh = hitime();
        n $t
        my $tr = T.op;

        my $ts = hitime() - $eh;
        my $delta = Rw mass $s:ts;

        my @l = ("took: $delta", G&op );
        n $t=>-od=>{dl=>2,s=>\@l}
    }
    undef $l;
Jigdo: | # bootstrap a G from W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    A.6.t = 'via';
    G.c.bay = 'bay';
    
    my $eh = hitime();
    
    my $set = [];
    my $M = [];
    for my $t (qw'Atool Placement Sequencing Intel ForJ') {
        my $f = G&Locate_read,$t;
        $f .= "/1";
        -f $f || die "NO such $t ($f ?)";
        if ($set) {
            push @$set, $f;
            next;
        }
        my $N = G&Beach,$f;
        push @$M, @$N;
    }
    if ($set) {
        my @suub;
        for ([Beach=>'f'],[Believe=>'N']) {
            my ($t,$args) = @$_;
            my $s = G.way.>$t || die "No $t";
            my $C = G&Ct,[$t=>1=>{s=>$s},{args=>$args,of=>'w'}];
            G&perlcode,$C;
            push @suub, 'my $'.$t.' = '.c&s;
        }
        my $bab = &s{
            my $C = G&Ct,["someba"=>1=>{s=>$s}];
            G&CoBabbler;
            C.c.s
        };
        
        my @inc = 'G';
        my $l = join "\n\n",
            G.way.strictwarn,
            'use FindBin qw($Bin);',
            'use lib "$Bin/othlia";',
            'use lib "$Bin/slib";',
            (map{"use $_;"}@inc),
            'my ($A,$C,$G,$T);',
            @suub,
            'my @f = ('.join(",",map{"'$_'"}@$set).');',
            $bab->(<<'');
                saygr 'Some more';
                my $N = [map{ @{ $Beach->($_) } }@f];
                my $A = $Believe->($N);
                G.c.mas = sub {
                    my ($A,$C,$G,$T,$s) = @_;
                    1 && saygr "Es: $s";
                };
                A.t = 'toplevel';
                G.h = A.i.h || die "No h";
                G.i.t = A.i.t || die "No t";
                G.c.bay = 'bay';
                1 && sayre "Ontop";
                
                G.ydrop = 1;
                my @ha =  G&Aup;
                $A = G&A,'twanga';
                push @ha,  G&Aup;
                1 && sayyl wdump 3, [Thes=>@ha]
        
        my $f = "q\.pl";
        write_file $f, $l;
        `chmod +x $f`;
        sayre "Done";
        exit;
        #
    }
    my $Y = G&Believe,$M;
    my @seen;
    for my $A ($Y) {
        A.t = 'top';
        my $G = {};
        1 && sayre "Doing:". q{
        push @seen, G&Aup;
        };
        G.ydrop = 1;
        push @seen, G&Aup;
        1 && sayre "Toka";
        $A = G&A,'tokative';
        1 && sayre "Two";
        push @seen, G&Aup;
        1 && sayre "Ze";
        
    }
    
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    n tripes=>4=>"took: $delta"
    
    n seen=>2=>{s=>\@seen};
    
    #n file=>''=>"File is $f"
    # < clicking od not reliving Beach
    n re=>-od_3=>{s=>$Y,dl=>3}
    #
    
Jigna: | # see heads
    G.c.leakmax = 40;
    n "G.c.bay/{gou,stay}"=>-lies_02=>"/*{,/j/*,/j/*/j/*}/head"
    my ($l) = G&op;
    n _.t=>-sea_2=>{s=>$_} for $l;
    
    n sev=>7=>3489
    n theA=>3=>{s=>$A}
    # users (A.3) will stratify (into J) stages of their transform
    # unless the input looks the same
    # 
pi/sea: | # more awareness of the differing point
    Js&fam = 't hsize hago';
    S
    # if large, prefer xoics
    # be able to ask for lum from 
    s&ago = int hitime() - ss&mtime;
    s&hago = Rw mass $s:s&ago;
    s&hsize = Rw sciun $s:ss&size;
    S
    #y.at.dos = 'Continues';
    #Js&ope > Js&bowls || return;
    #Js&bowls++;
    return;
    my $v = read_file(C.t);
    my $d = Load($v);

    n t=>o1=>C.t
    n see=>''=>wdump(4,$d);
Lize: | # watch ghost/wormhole watcher
    Jc&tape = 'Dejo';
    # see stylehouse openness/movingness
    #n Besider
    # see latest them
    n "G.c.bay/via"=>-lies=>"*/5",'%qz'
    S
    
    my $eh = hitime();
    # < get any lies that changed, redome w/W outent
    n waved=>-jackpole=>{s=>T.op},'%qz'
    my $lies = T.op;
    
    n edge=>-respec=>{s=>T.op}
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;
    n tripes=>4=>"took: $delta"
    
    # look at everything
    #m zome=>-beli=>{s=>$lies}
    # next things take that ^ as input
    # and continue/restart branches of thinking
    # until something comes out the other end
    # to contain phases of Matu
    # some computations are possible to re/unswim parts of and restitch the result
    # at the very least it will be triggering and calming down 
    
    # Beaching the changed stuff, relinking all involved w and W
    # have a surfacey w for all
    # know history to W, sets most-W-owning
    # and build a possibly meshy hierarchy to click changes through, like JJ
    
    
pi/respec: | # compare w/W situations
    # FactorEase w/*
    each kv s.y.tw {
        my $ub = &Cd{ C.y = {cv=>C.y.cv}; ki $C };
        my @stu = G&ind,$v,$ub;
        n "so$k" => 1=> "$k: ".join("\n", @stu,'')
    }
    return;
    my ($w,$W,$K) = map{ T.op = s.y.tw.>$_ || die "No $_ given"; [ G&op ]}qw'w W K';
    for my $k (qw'w W K') {
        my $v = s.y.tw.>$k;
        T.op = $v;
        my @l = G&op;
        my $l = join "\n", map { "  ".G&aC,$_ } @l;
        n $k=>''=>"Tocheck $k: $l\n\n";
    }
    #
    my $W = s.y.tw.W;
    my $W = s.y.tw.K;
pi/jackpole: | # map bay/$W/5 to $W and collect w/W outputs
    # to 5ile, way, W in, W out
    my $types = {};
    my $in = &KCD{
        my $K = $types.>$K ||= G&Ct,[$K=>2];
        my $B = K.y.tw.>C.t ||= $C; # known/w
        # Bs&* == Cs&*, except z
        # < more than one version of something? FactorEase
        return unless $D;
        my $E = B.y.tw.>D.t ||= $D; # unknown/W
    };
    T.op = $s;
    for my $D ( G&op ) {
        my $N = G&Beas,Dc&s;
        my ($F) = @$N;
        my $t = F.t;
        
        my $K = G&Ct,[$t=>1=>{s=>D.t}=>{%{F.sc}}];
        delete Ks&z;
        $in->(K=>$K);
        
        for my $d (@{Fs&z}) {
            for my $B (@{ds&z}) {
                $B = G&hup,$B;
                my $C = G&Ct,[$t=>1];
                if (d.t eq 'W') {
                    # our version of it under us
                    $in->(W => $C => $B );
                }
                else {
                    # us under it
                    $in->(d.t => $B => $C );
                }
            }
        }
    }
    # tw to zs
    my $twz = &C{
        my @z = sort {a.t cmp b.t} values %{delete(C.y.tw)||{}};
        s&z = \@z if @z;
        @z
    };
    my $ub = &Cd{ ki $C };
    each kC $types {
        $twz->($_) for $twz->($C);
        saybl "$k\t$_" for G&ind,$C,$ub,{nohup=>1};
        n $C
    }
    
    # so now
    # K is for each W:
    #   cs where it came from, sc (-z) copied from its 9
    
    # W is each W including other W (one piece hierarchy)
    #   the s&ha/version there needs checked against K, what it is now
    
    # w is each way with s&dige being used by other W
    #   usually the pin
pi/lies: | # watch wormhole (mtimes)
    local A.V = 0;
    # page i increases in flood
    # stretches out lim to keep reading until it hits old news
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = "C.t/$s" if $s =~ /^\W/;
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &s{
        my $sc = {};
        (sc.size,sc.mtime) = (stat $s)[7,9];
        sc.link = readlink $s if -l $s;
        $s=>1=>{},$sc
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = G&Experience;
    
    # osc changing atom loads contents
    @$M = Rw Modulate $d $list $forms;
    
    1s&sels.mtime.>$_ = &acgt{
        if (s&size > 2000 && s&large <  2) {
            s&large = 1;
            return;
        }
        c&s = read_file(C.t);
    } for 1,3;
    
    # imparting to self again, next thing will require version bump
    # since there is no hashing the reverse of travel yet
    
 
Modulate: | # loadup M news
    # stop when old news found
    my $done;
    my $list_done;
    my $seen;
    my @l;
    my $page = 1;
    my $M = [];
    my $keen; # whether to read into the rest of the page
              # once something same has been found
    until ($done && (!$keen || !@l)) {
        if (!@l && !$done) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep { !$seen.>$_ } @{s&sz};
            @l || last;
        }
        my $s = shift @l;
        $seen.>$s = 1;
        
        my @C = $forms->($s);
        my $C = G&Ct,\@C;
        my $c = d.y.tw.>C.t;
        
        my $cha;
        
        # could use the thing beneath o
        my $l = G&Ct,[c.t=>''=>{s=>$c}];
        my $o = G&Ct,[C.t=>''=>{s=>$C}];
        G&Chang,$l,$o;
        $cha = oc&cha;
        
        # or just
        $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        else {
            sayyl "Done upon C.t";
            $done = 1;
        }
        push @$M, $C;
    }
    
    each t,C d.y.tw {
        next if $seen.>$t;
        next if !-e $t;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
pi/beli: | # wormhoe
    T.op = $s;
    my $ub = &Cd{ G&aC };
    my @stu = G&ind,$s,$ub,{nohup=>1};
    n beli=>-pud=>{dl=>6,s=>\@stu}
    #[ G&op ]}
    

