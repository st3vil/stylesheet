NutDung: | # things and use
    # use
    n NutThing
    # loose
    n NutMelt
    # misuse
    n NutBung
    # mullinatials
    n NutCore
    # mutate - has I.om, must be mixed in
    #n NutText
    
NutThing: | # name of thing, outside I?
    u j
    n \'of:eye'
    # bring W (the named bunches of C) from outside
    #   see NutMelt for search path
    
    # and the I (souped together (functi|pers)onality) from W
    #   see NutMinds
    
    # they live in:
    #   4s&mind - A:u' for a u thing, unpacks into I, see NutMinds
    #   nowhere - W remotes/heres/put/ghets
    #   5.I.w - way, see NutThing (this)
    # so NutMinds wants to use G&t to get NutThings
    # and G&t produces a trace of seeing,
    #  in 5s&in ?
    # under $remote_t, the host/place we know about, with address on it
    # and .y.tv of things imported/asked for, and at the lightening a contract for update is drawn up, maybe just G&ting it every now and again
    #   these be cW thing, projectiles
    #    
    #  as 5s&in.$remote_t = $remote_sWC .y.tw.$
    
    # together into a namespace
    # serve requests for names
    # < bring things in via A:u'
    # <   or even A:n
    # < suggest writes
    # < throw async unless A agrees to accept an A:u' and wait, somehow
    
    # so G&t tends to go A:u' or A:n it up if not in A.I ...
    
    # I has the I/? and the I/?/? (as I.?.y.tw.?)
    # ? means a C.t, possibly cv multitude via some .y.next
    # I/? or s is a personality or embryo, picked up by thro
    # I/?/? or t is a thing or part of the sequence to thro
    
    # they (eg I/i) are in another W as C.t=i
    #   but cW=of or cW=javascript
    #     the encoder that made them, yet it is as if sW=i (implied)
    #   the cW of a coding is empiricle in its use for connecting to the sW matter   
    
    # though it (W:i) may not be in Where,
    # I/? (W:i) gets talked about/projected by many W
    # I/?/? (W:i's t 1 (G&t)) get clobbered as I/? mix
    
    # so all W-ish things are equal,
    # I persons (believed W's W talkings)
    # W themselves...
    # way
    # any name
    
    # it's just where you look
    # could even find that some remote W contains an I.? thing it wants,
    # and decide to use it
    
    # all from this G&t function
    #   should it interactive and T off W things?
    #   then we could adventure a searchy endpoinT
    
    # it looks up to 5, who could have:
    #   I.W.? a list of W
    #   a way to elvis for it
    #   or some other way/function forward (stylehouse's G&t's Ys&tby)
    
    # re j/4, using things as J:
    # J has store/thaw suggestions in NutMelt:
    #   pi/mine does the job of an A:u' for a storage area (list of W)
    #     lacking A:u' for things pulled in, via G&t or J thaw
    #     but having the ability to grab J happening with A.u
    #       strongly suggest to thaw them if existent in eg sac, or
    #       and auto-save them in eg sac_sc, a patchway to sac
    
    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    # want a type, like http's Accept header,
    #   so G&ting can upstantiate it
    #   things coming alive because of this will have thresholdia
    #   do you want to trust someone else's version of t,
    #   or do you run all the simulations yourself?
    
    # your I should be able to compile from the documentation
    
    #c have subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO G.i.* = A.I.i.y.tw.*.c.code, for slight inlining in JBabz
    h: %acgt:s so st sh sf si
        $z = s;
        if (typeof s === 'string') {
            z = G.t(A,C,G,T,'eye',s);
            z ||= G.t(A,C,G,T,'i',s);
        }
        !z and throw "No h: "+s;
        $t = typeof s == 'object' ? ss&js+'/'+s.t+'@'+s.y.cv : z.t;
        $d = {t:t,y:{},c:{},sc:{z:[]}};
        $B = Gc&B;
        B and Bs&z.push(d); d.y.up = B; dc&d = (Bc&d || 0) + 1;
        Gc&B = d;
        ds&D = T.D = z;
        ds&C = C; ds&A = A;
        
        $r = z.c.code(A,C,G,T,so,st,sh,sf,si);
        
        Gc&B = B;
        return r
    
    #c get thing
    # maybe this is the way to do s=C?
    # and have something besides J.I?
    #   if cJ:
    #     look in Js&Jtv, create?
    #   if cW:
    #     look in storage, figure where to put it
    t: %acgt:s t
        typeof s == 'object' and throw "Nevers";
        $D;
        for (var n = 1; n <= 5; n++) {
            $Y = A[n];
            !Y and continue
            $I = Y.I;
            !I and continue
            # container/personality/embryo
            D = I[s];
            # thing/step/nodule/item
            D && t != null and D = D.y.tw[t];
            D and break
        }
        return D;
    
    #c waylay can happen by itself
    waylay: %acgt:t ar delay cb
        typeof ar != 'object' and delay = ar; ar = {};
        typeof delay == 'function' and cb = delay; delay = 0;
        cb ||= &s{};
        if (delay) {
            # wait and then way
            # < expect download's tiny delay as well?
            G&delay:delay,&{ G&waylay,t,ar,0,cb };
            ~waylayter: t, delay
            return
        }
        #~waylaydo: t
        G&way,t,ar,cb
    
    #c way fancy subroutine call
    # simple keep downloading fresh code mechanism
    #    async if downloading, uses cb or 1s&N=A && throw
    #  t - name of a way
    #  ar - hash of named arguments
    #  cb - callback containing a sync G&way call 
    #    if cb is &s{...}, give it the return value of the way
    #    if cb is 'noop', do nothing, return 1 if way is ready
    #  no cb 
    #   (going async)
    #   tries to resync the A that needed it via 1s&N
    #   causing a J unprepared for what ways its way depends on,
    #   to resolve one at a time as they occur,
    #   finally downloading the whole codepath
    #  a cb of &{} should run the thing real soon if not immediately
    #  no cb, as most way will be, will resync the J 6
    #    so a way should know what ways you might run into inside it,
    #    so resources can be loaded before J:6, which should sleep
    #     and only happen when it needs to, in tiny ordered parts, etc.
    # < assume w without s&now live forever?
    way: %acgt:t ar cb
        $w = typeof t == 'object' ? t : G&t,'w',t;
        $ttl = 4c&ttl || 5;
        !(w && ws&now && G&time,ws&now,ttl) and w = null
        
        if (!w) {
            cb == 'noop' and cb = &{};
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            $get = '/way/'+t;
            $is_done;
            $done = &s,how,c{
                is_done = 1;
                how != 'success' and throw "Failed request: "+how, c;
                $dige = c.getResponseHeader('Dige');
                $w = G&Cye,[t,1,{s:s},{of:'w',dige:dige}];
                A.5.I ||= {};
                $D = A.5.I.w = A.5.I.w || G&Cye,['w','',{},{z:[]}];
                D.y ||= {};
                D.y.tw ||= {};
                D.y.tw[t] = w;
                ws&now = G&time;
                # < check it compiles? but we don't know its args,
                #   unless they are vaguely known by bumping into compile errors
                #   awaiting better field recording (MelTest frontier of)
                a&ready = 1;
                #~w!: t
                if (cb) {
                    if (G&arfgunc,cb == "s") {
                        # wants its return value with given ar...
                        #~w cb s: t
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the w back?
                        #~w cb: t
                        cb(t,ar,w);
                    }
                }
            };
            $r = $.ajax(get);
            r.done(done);
            $checks = 5;
            $check = &{
                is_done and return;
                !r.statusText && checks-- > 0 and return G&yl,150,check;
                r.statusText == 'Not Found' and throw "No way: "+t
                r.statusText != 'OK' and throw "Weird ajaxtus: "+r.statusText
                #~>57 waylo: t
                done(r.responseText, 'success', r);
            };
            check();
            #~w?: t
            !cb and G&TuneTimeMachine,'w:'+t
            return
        }
        
        ar ||= {};
        $args = G&ks,ar;
        args != wc&code_args and delete wc&code;
        # code is already JaBabz'd
        # < CoArgulate for ar, put as knowable source file?
        # < make it c.code and G&h for a B?
        if (!wc&code) {
            $name = 'w_'+w.t+'_'+ws&dige+'_'+args;
            name = name.replace(/\W+/g,'_');
            4s&namedcode ||= {};
            $code = 4s&namedcode[name];
            if (code) {
                wc&code = code;
            }
            else {
                $tar = 'ar';
                args and tar += ','+args;
                # help Ban find its source
                Gc&B.sc.way = w;
                $code = 'wc&code = function '+name+"(A,C,G,T,"+tar+"){\n"+wc&s+"}";
                eval(code);
                # now compiled, we are not "in" it until run
                delete Gc&B.sc.way;
                4s&namedcode[name] = wc&code;
            }
            args and wc&code_args = args;
        }
        cb == 'noop' and return
        $arm = [];
        $ark = args.split(',');
        each ik ark {
            arm.push(k);
        }
        $so = ar[arm[0]];
        $st = ar[arm[1]];
        $sh = ar[arm[2]];
        $sf = ar[arm[3]];
        $si = ar[arm[4]];
        
        # help Ban find its source
        Gc&B.sc.way = w;
        return wc&code(A,C,G,T,ar,so,st,sh,sf,si);
    
        
NutMelt: | # puddles of W
    u j
    n \'of:k'
    
    # how/when/where to make deals to:
    #  - bring things in from outside
    #  - write them outside
    #  - take over that outside
    
    0 &&
    hmm:
        5s&stores =  [
            # place to thaw u from
            G&e,sac=>-mine=>{}=>'implies:thaw,if:A-clusping' ,

            # posit for sac all other u things?
            G&e,sac_sc=>-mine=>{}=>'otherwise:use,if:A-clusping' ,

            # to continue, must write
            # < knows resumey jay bits vs whole W versioning
            G&e,gou=>-mine=>{}=>'implies:resume' ,

            # becoming a process
            G&e,G=>-mine=>{}=>'otherwise:resume,if:CcWea=G' ,

            # becoming a process
            G&e,Co=>-mine=>{}=>'otherwise:resume,if:CcWea=Co' ,

            # default write location
            G&e,neu=>-mine=>{}=>'implies:write' ,
        ];
    
    
NutCore: | # doc universals, map room
    return;
    u k
    # a dialect/personality for relationships
    # or boundary effects
    # stuff to one day compile into the throat
    # points for things with scattered use by other things
    # including clues for the likes of -od
    
    # cv is loftiness of use
    
    ttl 4: %on:G
        # time to trust remote resources: way, u things, etc
        # default 5 seconds, needs increase when debugging
    on 1: %on:A.
        # the html element om el 3 will build in
    on 8: %un:k
        # where/what (to o) object can this name be:
        # s        C.sc (default)
        # c        C.c
        # a        A.sc
        # A        A.c
        # A.       A itself
        # G           G.c
        # g           g.sc
        # J        J.sc
        # j        j.c
    un 8:
        # what dialect (u name) this name happens in
        
    
    N: %on:a,J
        # it contains A with desire to thro
        # can nest on any Js&N, most importantly 4s&N
        #   the out-J should resolve any in-Js&N,
        #   put edge to the pile of intention,
        #   before attention drifts away
    
    ready: %on:a
        # bool - is the A ready to resync
        # set to 1 when request is served
        # N groupey A may slightly wait for a consensus of readyness
        # 
    e:
        # likes to be elvised, usu s string or z as jod string
    # oscillator steps
    u s
    J 4:
        # see if we should listen or if its got news 
    
NutBung: | # getting W from I, D from B, and errorifics
    u j
    n \'of:eye'
    
    # the edge of the mind is these items...
    # they could know their 4s&mind?
    add_script: %acgt:src cb
        var script = document.createElement('script');
        script.setAttribute('src', src);
        script.setAttribute('type', 'text/javascript');
        cb and script.onload = &e{ cb(script,e) };
        A.4.on.appendChild(script);
        return script

    # when error
    # < communicate to thro if handley
    # generic linkage to source finding?
    # TODO error object maker (er != string)
    # via window.onerror, msg like "Uncaught "+er
    # the throw async is an abort rather than error,
    #   things should be tested to handle such things properly
    #   domes should add checkpoints to abort to
    # TODO make a devtools link? B stack crawler/playback?
    Ban: %acgt:er msg url lineNo colNo
        $B = Gc&B;
        B = B.y.up;
        if (typeof er == 'string') {
            msg ||= er;
            ~>9 throwstring: er+''
        }
        # msg sometimes stringified er, message is less noisy
        er.message and msg = er.message;
        if (msg.slice(0,5) == 'async') {
            # test for unhandled asyncs
            #G&waylay,'checkov_async',{B:B}
            G&c:'>9 '+msg;
            er.nobigdeal = 1;
            return
        }
        msg.slice(0,5) == 'waits' and er.nobigdeal = 1;
        
        msg = msg.replace(/^Uncaught /,'');
        $m = [
            G&intag:'>97 !'
            ,G&intag:'>75:Wtitle'
            ,G&intag:'>9:Bangmsg '+msg
            ,G&intag:'>8:weirdness'
            ,G&intag:'>4:subinfo ?'
        ];
        if (er.tc) {
            m.push( G&intag:'>2:tnc '+ki(er.tc,3) );
            m.push(m.splice(-2,1));
        }
        
        $it = G&c:m.join(' ');
        
        $w = Bs&way;
        $cat = er.catches; # places of rethrow
        # may get restacked when rethrowing
        #   if running chrome < 2012 ?
        $stack = er.stack;
        cat and stack = cat[0].stack;
        !stack and return;
        $k = stack.split("\n");
        k.shift();
        $end = k[0];
        console.log("er: ",msg,url,lineNo,er,w,cat,end);
        url && location.href == url and url = null
        $beyond = 0;
        G.er = er;
        
        while (k.length) {
            end = k.shift();
            
            beyond and it.set('weirdness','+'+beyond);
            
            # anon sub if way
            $m = end.match(/<anonymous>:(\d+):(\d+)\)$/);
            if (m) {
                url && !url.match(/\/js\/NutMachine[^\/]*\.js$/) and debugger;
                !w and debugger;
                
                it.set('Wtitle', 'w:'+w.t);
                $l = wc&s.split("\n")[m[1] - 1 - 1];
                it.set('subinfo', l);
                return
            }

            # a url if <script>
            $m = end.match(/ \((.+?\/js\/.+?):(\d+):(\d+)\)$/);
            if (m) {
                url = m[1];
                lineNo = m[2];
                colNo = m[3];
                G&Ban_url,it,er,msg,url,lineNo,colNo;
                return
            }
            
            beyond++;
        }
        
        #debugger;
        ~92 Neither url or way:
        
    #c /js/ reverse engineering
    # < TES get good at just using B etc
    Ban_url: %acgt:it er msg url lineNo colNo
        # make sense of the resource
        $v = new URL(url);
        $src = v.pathname;
        $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
        
        if (!m) {
            # other js resource
            return it.set('subinfo', '?: '+url)
        }
        
        # should be some A:u'
        $W = m[1];
        it.set('Wtitle',W);
        
        # get the lines, in the <script> already?
        $.ajax(src).done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            $W = m[1];
            $ver = m[2];
            $lines = s.split("\n");
            $l = lines[lineNo-1];
            $prior = 1;
            $sub
            while (1) {
                prior++;
                $line = lines[lineNo-prior];
                line == null and break;
                $fu = line.match('^function '+W+'_'+ver
                    +'_(\\w+)_(\\d+)_(\\w+)_(\\d+)\\(');
                !fu and continue
                $cv = '';
                fu[4] != '1' and cv = fu[4]
                sub = fu[1]+cv+'/'+fu[3];
                break
            }
            sub ||= "?: "+src;
            $m = [
                G&intag:'>2:subtitle '+sub
                ,G&intag:'>45:subline '+l
            ];
            it.set('subinfo', m.join(': '));
        });
        
        # check if current
        $.ajax('/js/'+W).done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
            $rep = c.getResponseHeader('Location');
            src != rep and it.set('Wtitle',"(old)",1);
        });
        
        
checkov_async: |
    console.log("Investigate: ",B);

Wade: | # serve /W/$t to G&t
    # defines one place get/set name scheme
    
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.Wache ||= {};
        
        # read t, write if s
        # all there
        $t = "W/$t";
        # char safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1
        my $f = "$t/1";
        
        # returns json:
        my $re = {ok=>0};
        
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($pa && $pa ne $cache.>$f ) {
                re.er = 'not ffwd';
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            # it should have a dig
            my $dig = slm(12,dig($s));
            $cache->{$f} = $dig;
            re.dige = $dig;
            re.s = $s;
            # if they know its hash, assume they don't need the string again
            if (my $ha = $c->param('have')) {
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
        }
        $c->render(text=>sjson($re));
    };
NutIns: | # new stuff
    u j
    n \'of:eye'
    
    # newthing
    # gets I/c&of/C.t
    # if in A.1-5.I, trust up to date
    # otherwise ask (async) some remote
    
    # G&t,'e'        -> I/e
    #    - return an entire personality
    
    # G&t,'i','peel' -> I/i/peel
    #     - returns that thing (what G&peel does) of the i personality
    
    # and things that fit here defiantly
    # given s=C it can use more smarts, async
    
    #   I/W/Expectation - gives s&top of saved W
    #     there is a list of them floating around,
    #     as:
    #         placeofplaces 9
    #           Expectation  c&W:W
    #              ...
    #           ...
    #     they each may have s&I,
    #       which G&t is usually selecting from the general availability of
    
    #   I/js/Expectisma - gives s&I from that W, with code via <script>
    
    #    I/w/Expect - returns the one w/Expect thing, not a W
    #        < it must be in some I/W/*/$w
    #      have an index (w/way/$w) to use for now
    
    
    # otherwise the latter three (of=W,js,w) can become async
    #  resourcing quests needing question time
    
    # < s = G&Cye,s if Array?
    ting: %acgt:s t
        $C = {};
        if (typeof s == 'object') {
            C = s;
            s = c&of;
            t and throw "C & t";
            t = C.t;
        }
        else {
            C.t = null == t ? '' : t;
            C.y = {};
            C.c = {of:s};
            !c&of and throw "Gt without an of";
            C.sc = {};
        }
        
        # trusted as current beacuse 4/5 are alive
        # covered by the version of Normal attached to everything
        $D = G&t,c&of,C.t;
        D and return D;
        
        # otherwise send question/pull into 5 to keep up to date
        #  C - the question
        #  P - the pull/import state 
        #  D - the item
        
        # C (question) should get Ds&v (and more?)
        #   often it shall be deciding to wake up if news
        
        # P (pull) lives in 5s&in
        #   and any ra&in where it's used,
        #    and hoists to 1-3s&in
        #     so they can be traced into the dome that G&t'd it
        
        # s&in should be of/t/pointer = P
        
        # pointer usually a W, or maybe several conjoined by \t
        #   like elvis points paths into things
        # pointer could be '' if it's something in 5,
        #   then the version of 5 (or Normal) is something's upstream
        # pointer may be something (W) visible on 4/5's bays,
        #   or deep inside somewhere
        
        # as s&in disappears down inside a W,
        #   shall its pointers stay focused A.3,
        #   or start pointing upwards:
        #     because it could use s&in to take input from itself
        #   a lark for now,
        #   getting them to pool on A.3 for A.3 would do the trick
        #   even without a remove-when-they-disappear thing, see s/swim
        
        # s&out could be pointer = s
        #  to everything it writes
        #   the path being W/page, or A.1.t/'',
        #   from the perspective of A.2
        
        # so s&in is qualified by of/t finding and pointer (a kind of url)
        #   and has P, a pull/remote/link item to track change,
        #     for Pc&s = D, the thing itself
        #   from that specific pointered remote
        #   the G&ting may end up with a different P,
        #   but would work it like a different version of the same P,
        #   the P you keep (branch becoming local?) must clone to heres&in
        
        # and s&out is qualified by pointer (a kind of url),
        #   1s&out:
        #     has a P-like push item to track change,
        #       with Pc&s = s, the brain, the prosthetic memory made
        #     or the perma-e that pulls it into storage...
        #   Ps&out:
        #     paths from 4 to any A.3 it is used 1s&in
        #     untidiable... unless updating because of it,
        #       the extra minder could see the lack of relation-creation
        #     the updator would join all 1s&in and 5s&in,
        #       know P changed and following Ps&out is cheating?
        #       spreading out to the users... is all-ahead-bendix
        # 5s&in -> 1s&in -> ss&in -> rs&in
        
        #c have the thing?
        # lets forget s&out until s pages and data surfs
        # and forget s&in hoisting
        # just clone 5s&in..P into 3s&in..P, let chaos clean up
        #   such an attention to detail that wants to turn into awake desire
        #     is interesting. model it.
        # we are importing these types (c&of) of thing (t)
        5s&in = 5s&in || {js:{}, W:{}, w:{}};
        !5s&in[c&of] and return
        $type = 5s&in[c&of];
        $thing = type[C.t] = type[C.t] || {};
        c&p and throw "pointers diffract where thing must be from"
        
        # G&t,[Wt,,$s] sets
        #  could be A:s? take up its string channel
        #   as string, not the decoded Pc&s object (that is returned)
        $saying = c&s != null;
        # s&P may be the thing it must replace if reusing Pull request to Push
        
        $found;
        # P coming from the first location... unless something
        each pP thing {
            c&p && c&p != p and continue
            found and throw "many points of thing", thing
            found = P
        }
        P = found;
        # is our cache too old
        $p = P; # may be able to check s&dige or so...
        if (P) {
            $ttl = 4c&ttl || 5;
            Pc&ttl_mult and ttl *= Pc&ttl_mult;
            Ps&now && !G&time,Ps&now,ttl and P = null
        }
        # formulate question or statement
        if (!P || saying) {
            P = G&Cye,[C.t,C.y.cv,{of:c&of},{}];
            $get; # how to ask
            $got; # response to P/c&s
            
            # they may have their own ways to use dige/v, p/P/s&P
            #c w|js
            if (c&of == 'w') {
                get = '/way/'+C.t;
                got = &P,s,c{
                    $w = G&Cye,[C.t,1];
                    wc&s = s;
                    ws&of = 'w';
                    # hash of the source, compiled in s
                    ws&dige = c.getResponseHeader('Dige');
                    Pc&s = w;
                };
            }
            if (c&of == 'js') {
                get = '/js/'+C.t;
                # T would put this c&v to wind back from bugs
                c&v and get += '-'+c&v;
                # < check dige/download if different in one request
                got = &P,s,c{
                    $src = c.getResponseHeader('Location');
                    $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                    $W = m[1];
                    $ver = m[2];
                    $W = G&Cye,[W,1];
                    $I = Ws&I = {};
                    Ps&v = Ws&v = ver;
                    Pc&s = W;
                    # js doesn't communicate much of the W 9, or anything not in I
                    
                    # move usual after-got() act to after this callback
                    $ready = c&ready;
                    delete c&ready;

                    $callback = &script,e{
                        # D & C in here refer to the of & the of/t
                        # < check for errors from that script?
                        $tocfunc = W.t+'_'+Ws&v;
                        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
                        $toc = window[tocfunc]();
                        $D;
                        each il toc {
                            $ind = v[0];
                            $C = G&Cye,[v[1],v[2],v[3],v[4]];
                            if (ind == '') {
                                D = I[t] = C;
                                D.y.tw = {};
                                D.y.tv = {};
                                Ds&z ||= [];
                            }
                            else if (ind == '  ') {
                                D.t != s&js and throw "Csjs not last D", C, D;
                                c&code = window[s&name];
                                typeof c&code != 'function' and throw "Cccode not function", C, D;
                                # grow I
                                D.y.tv[C.t] ||= {};
                                D.y.tv[C.t][C.y.cv] = C;
                                D.y.tw[C.t] = C;
                                $l = Ds&z.slice(-1);
                                l[0] and l[0].y.next = C;
                                Ds&z.push(C);
                                D.y.in ||= C;
                                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                                    G[C.t] = c&code;
                                }
                            }
                            else {
                                throw "deep C: "+W+"/"+t, v
                            }
                        }
                        
                        ready();
                    };

                    $have = $('body script[src="'+src+'"]');
                    have.length and return callback();
                    G&add_script,src,callback;
                };
            }
            #c of=W
            if (c&of == 'W') {
                get = {url:'/W/'+C.t};
                $d = get.data = {};
                # the first "can you hold on to..."
                if (s&P) {
                    # if G&ting,thesameC again
                }
                if (p) {
                    # the P disqualified
                }
                if (c&s) {
                    # wants to write
                    # must be replacing s&P
                }
                else {
                    # read
                    # have: s&P - a pull, this question has been answered before
                    #  and now it's 
                    if (s&P) {
                        # the pull, check same dige
                        # same dige could also come from
                    }
                }
                if (saying) {
                    # wants to write
                    get.type = 'post';
                    
                    # Core scuttle boundary, Q -> get/W
                    null != c&s and d.s = c&s;
                    null != c&patch and d.patch = c&patch;
                    
                    # if we should be careful about what we replace
                    d.patch && !s&P and throw "Pull before you Push a patch"
                    # the old P
                    s&P and d.parent = s&P.sc.dige;
                    # the new P
                    Ps&dige = dig(c&s);
                    Pc&String = c&s;
                }
                
                # dige we have floating around
                d.have = [];
                # p the possibly out of date
                # Qs&P from before
                # P the new pull, what will be...
                $poss = [p, s&P, P]
                    .filter(&p{ return p && pc&String && ps&dige })
                    .filter(&p{ return d.have.push(ps&dige) });
                !d.have.length and delete d.have
                else { d.have = d.have.join("\t") }
                
                got = &P,s,c{
                    $r = dej(s);
                    if (r.dige) {
                        # variance in perl/js dig()?
                        Ps&dige && Ps&dige != r.dige and debugger;
                        Ps&dige = r.dige;
                        # dige without s if it's cached here
                        if (null == r.s) {
                            each ip poss {
                                ps&dige == r.dige and r.s = pc&String
                            }
                            !r.s and throw "get/W implied we know", r, P
                        }
                    }
                    if (r.ok) {
                        s = '';
                        r.ok == 'created' and s = c&s
                        else
                        r.ok == 'found' and s = r.s
                        else
                        r.ok == 'updated' and s = c&s
                        else
                        r.ok == 'deleted' and s = null
                        else {
                            throw "other kind of ok",r.ok
                        }
                        Pc&String = s;
                        if (s) {
                            $N = G&readLines,s;
                            N.length != 1 and throw "Weird tW lines", s
                            s = N[0];
                            s.y.P = P;
                        }
                        Pc&s = s
                    }
                    else {
                        if (r.er == 'not ffwd') {
                            c&rebase and c&rebase()
                            else {
                                throw "not ffwd: "+C.t, r
                            }
                        }
                        else
                        r.er != 'not found' and throw "tW er", r.er
                        Pc&s = null
                    }
                };
            }
            
            #c ask,return
            $done = &s,c{
                # every pulling happened now
                Ps&now = G&time;
                # specific stuff moves from the response to P and Pc&s
                got(P,s,c);
                # stash the P on 5s&in
                Pc&p == null and Pc&p = '';
                thing[Pc&p] = P;
                # and on Cuestion
                s&P = P;
                # specific continuation
                c&ready and c&ready()
            };
            G&question,get,done;
            
            c&async and c&async(); throw "async didnt async"
            # returning undef (later) means nothing found
            # could c&l = netslopes (above 5) to look up... lumit
            G&TuneTimeMachine,c&of+':'+t
        }
            
            
        
        # stash
        if (P) {
            # hang ourselves on Ps&out?
            # copy P to your s&in
            Pc&p == null and throw "no Pcp, even if ''"
            P = G&Cye,P;
            3s&in ||= {};
            3s&in[Pc&of] ||= {};
            3s&in[Pc&of][P.t] ||= {};
            3s&in[Pc&of][P.t][Pc&p] = P;
            # give the question the link to the answer
            s&P = P;
            # return the answer
            return Pc&s;
        }
        # automatically mirror C in 5s&things.c&of.$t?
        #  tracking what things we think we know from outside
        #   the 4s&mind (A:u') has ttl and a&N back to users (A:u)
        #   the 5s&I.w.$way has ttl too, but shouldn't
        # could the 5s&thing, for each c&of/t,
        # be things to G&t again to compute ghostliness
        # and linking attention back to A.3s,
        #   maybe s&G thing like an I thing, but with minimal info
        #   that pools upward through J, s, domes, even individual C
    
    #c way/js questions as C
    # P import state
    # D the item
    quest_w: %acgt:t ar cb
        $Q = G&Cye,[t,'',{of:'w'}];
        Qc&ready = &{
            # Jin should accept this A again
            # < never set to 0, might speed it up if...
            a&ready = 1;
            # so wait for it...
            !cb and return
            if (G&arfgunc,cb == "s") {
                # way randomly happens, give return value to cb
                # without A lining up around it (it may do so itself)
                # see G&waylay for use case as delayed call
                $s = G&way,t,ar,'already_async';
                cb(s);
            }
            else {
                # containing a sync G&way call
                # or a way to get the context revisted?
                cb(t,ar,w);
            }
        };
        Qc&async = &{
            cb == 'noop' and cb = &{}
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            # Jin should avoid this A for a while
            a&ready = 0;
            # and throw/abort if no callback
            !cb and G&TuneTimeMachine,'w:'+t
        };
        $w = G&ting,Q;
        return w
        
    
    quest_js: %acgt:t
        $Q = G&Cye,[t,'',{of:'js'}];
        Qc&ready = &{
            A.cv = 0.4;
            # Jin should accept this A again
            # < never set to 0, might speed it up if...
            a&ready = 1;
        };
        Qc&async = &{
            a&ready = 0;
            4s&N.push(A);
            T.not = 1;
        };
        $W = G&ting,Q;
        #a&I = Ws&I;
        #a&v = Ws&v;
        return W
    
    #c rebuild tcp
    # < have A, so async in handler gets retried
    #    (or G&way noop deps just before handling)
    # < get or ws
    # retry, expire
    # c == r
    question: %acgt:get data cb
        $is_done;
        typeof data == 'function' and cb = data; data = null;
        data and get = {url:get,data:data};
        $r = $.ajax(get);
        $done = &s,how,c{
            is_done and return
            is_done = 1;
            r.status != '200' and throw "ques: "+r.status+": "+get, r
            cb(s,c)
        };
        r.done(done);
            
            $checks = 5;
            $check = &{
                is_done and return
                !r.status && checks-- > 0 and return G&yl,150,check
                done(r.responseText, 'maybe', r)
            };
            check();
    #c c&Four, c&G actuation
    u jc
    # of html? needs to give innard an element to be in
    # could do a kind of bootup osc for one thing...
    # have G&n return with the child running & grounded
    # or make the element first, etc, give to el333 to attach
    n \'of:om'
    # starts a child process - rename to G at some point
    #   see G&Four
    # s is a runlevel
    Four 6:
        $Y = 1s&child = G&Four,C.t;
        $p = Ys&parent = A.1;
        # doesn't have a clock running yet...
        # should n {C},{c:resyncin:20ms} and push the Jinloop button via e?
        $startup = &acgt{
            G&n,['Lunch'];
        };
        s >= 6 && ps&subphone and ps&subphone(startup);
        # 
        

