NutDung: | # things and use
    # use
    n NutThing
    # loose
    n NutMelt
    # misuse
    n NutBung
    # mullinatials
    n NutCore
    # mutate
    #n NutText
    
    
Shovel: | # run/mind the remote thing updatory
    G&heading;
    G&u,['NutIns'];
    G&clusp;
    #
    $mind = 4s&mind; 
    $way = A.5.I.w;
    $Tri = A.4.sc.Jtv.Tri[0.1];
    
    $compress = &s{
        # the other things are around, also via y.{tw,tv,in} etc
        delete ss&z;
        
        $mute = {c:['code'],sc:[]};
        each nk,gks mute {
            $he = s[nk];
            $out = [];
            each i,gk gks {
                null != he[gk] and out.push(gk); delete he[gk]; continue
                # data should be limited somehow...
            }
            # say that it is muted, eg c&mc = 'muted Cc keys'
            #  in a thing that could pretend to be a hash for simplicity...
            if (out.length) {
                $ou = 'm' + nk.slice(0,1);
                # join any there already?
                $was = s.c[ou];
                was and was.split(' ').map(&s{ out.push(s) });
                was = {};
                out.map(&s{ was[s] = 1 });
                s.c[ou] = Object.keys(was).sort().join(' ');
            }
        }
        # ^ or: sc&code and delete sc&code; sc&mc = 'code';
    };
    $cb = &s{
        try {
            compress(s);
            #return ki(s,2);
            return G&toLines,s
        }
        catch (er) {
            #debugger;
            return ki(s,2)+"   !! "+er
        }
    };
    
    $x = Tri.sc.s.sc.top;
    $l = G&ind,x,cb,{hup:1,dl:3};    
    
    G&n:["Inst3ad",15,{s:l},{hue:'139deg',ws:'pre'}]
    
    G&n:["Instead",2,{s:" 2  2 88   3  43 3   3    3 76   8 76   5 5  7 6"},{hue:'49deg',ws:'pre'}]
    
    
    
    
    
    
    #
NutIns: | # subverse valuar, for editables s&e
    u j
    # a functional guide to o
    #  produces a big Z, or N of all atoms (C), even those inside others
    # traverse! sweep into G&F
    # climb in/next/z of $s with a sub $y
    # returns big flat (Cora) list of the sub's returns
    # $y ||= &Cd{ $C }
    ind: %acgt:s y d
        $D = s;
        # setup
        d ||= {};
        if (!d.refs) {
            d.refs = []; # all things
            d.refid = {}; # those indices to d
        }
        y ||= &s{ return s }
        if (typeof y == 'string') {
            y == 'ki' and y = &s{ return ki(s) }
            else { 
                throw "ind y named", y
            }
        }
        
        # dedupe (s always an Object)
        $ri = d.refs.indexOf(s);
        if (ri < 0) {
            ri = d.refs.push(s) - 1;
            d.refid ||= {};
            d.refid[ri] = d;
        }
        else {
            $od = d.refid[ri];
            # dupe seeing very interesting for -jod
            return;
        }
        # depth limit vs depth
        d.dl && d.dl < d.d and return;
        
        if (d.hup) {
            # fills matched C.c with info about where it is
            # < a separate object, a map to the result of the map this is
            #d.infolate == null and d.infolate = 1;
            s = G&Cye,s;
            s.y.D = D;
        }
        
        $dd = &d{
            d = $.extend({},d);
            d.path = (d.path||[]).slice();
            return d
        };
        d = dd(d);
        d.s = s;
        d.path.push(s.t+' '+s.y.cv);
        d.ind == null and d.ind = '  ';
        # ^ accumulates on every depth's return of a string
        d.d ||= 0;
        d.d++;
        $out = [];
        $one;
        $my = [];
        
        d.cbfirst and one = y(s,d)
        d.not and return
        d.nofurther and return one
        
        # )
        #c the ways to go deep, should be all? will dedup
        # user throws something on any way
        if (ss&z) {
            $z = ss&z.filter(&s{ return 1 && s });
            d.zort and d.zort(z,s,d);
            each iD z {
                out.push( G&ind,D,y,d );
            }
        }
        
        if (s.y.in) {
            out.push( G&ind,s.y.in,y,d );
        }
        
        if (s.y.tw) {
            each tD s.y.tw {
                out.push( G&ind,D,y,d );
            }
        }
        
        if (s.y.tv) {
            each tvD s.y.tv {
                out.push( G&ind,D,y,d );
            }}
        }
        
        out = out.filter(&s{ return 1 && s });
        # flatten a bit, G&ind returns js arrays
        $oute = []; 
        out.map(&s{
            s.constructor == Array ? 
                s.map(&s{ oute.push(s) })
            : oute.push(s)
        });
        out = oute;
        
        out = out.filter(&s{ return 1 && s }).map(&s{
            if (typeof s == 'string')
                return s.split("\n").map(&s{ return d.ind+s }).join("\n")
            
            if (typeof s.constructor == Object) {
                if (d.infolate) {
                    if (!sc&ind) {
                        # (once) write where things are
                        # on the things themselves
                        sc&ind = d.d;
                        sc&inds = '';
                        $i = 0; # to d.d==1 for the first level
                        while (i++ < d.d)
                            sc&inds += '  ';
                        sc&inside = d.path;
                    }
                }
                my.push(s);
            }
            return s
        });
        
        if (s.y.next && !d.nonext) {
            $od = dd(d);
            od.path.pop();
            od.d--;
            out.push( G&ind,s.y.next,y,od );
        }
        
        !d.cbfirst and one = y(s,d)
        d.not and return
        out.unshift(one);
        
        out = out.filter(&s{ return 1 && s });
        !out.length and return
        $retrefs = out.filter(&s{ return typeof s != 'string' }).length > 0;
        
        if (d.d == 1 && !retrefs) {
            d.wantarray and return out
            return out.join("\n");
        }
        else {
            # an N with insidenesses, has been organised, located...
            # put insides (s&z,yin) in a z on the outside
            my.length && typeof one == Object and ones&z = my
            # return every C in N, each G&ind leaves [] to dissolve
            $flat = [];
            each is out {
                s.constructor != Array and flat.push(s); continue
                each IS s {
                    flat.push(S);
                }
            }
            return flat
        }
        
    #c c&Four, c&G
    u jc
    # of html?
    n \'of:om'
    # starts a child process - rename to G at some point
    #   see G&Four
    # s is a runlevel
    Four 6:
        $Y = 1s&child = G&Four,C.t;
        $p = Ys&parent = A.1;
        # doesn't have a clock running yet...
        # should n {C},{c:resyncin:20ms} and push the Jinloop button via e?
        $startup = &acgt{
            G&waylay,'con/Jinloop',{},0.001;
            G&n,['Lunch'];
        };
        s >= 6 && ps&subphone and ps&subphone(startup);
        # 
        
NutThing: | # name of thing, outside I?
    u j
    n \'of:eye'
    # bring W (the named bunches of C) from outside
    #   see NutMelt for search path
    
    # and the I (souped together (functi|pers)onality) from W
    #   see NutMinds
    
    # they live in:
    #   4s&mind - u chunks, see NutMinds
    #   nowhere - W remotes/heres/put/ghets
    #   5.I.w - way, see NutThing (this)
    # so NutMinds wants to use G&t to get NutThings
    # and G&t produces a trace of seeing,
    #  in 5s&in ?
    # under $remote_t, the host/place we know about, with address on it
    # and .y.tv of things imported/asked for, and at the lightening a contract for update is drawn up, maybe just G&ting it every now and again
    #   these be cW thing, projectiles
    #    
    #  as 5s&in.$remote_t = $remote_sWC .y.tw.$
    
    # together into a namespace
    # serve requests for names
    # < bring things in via A:u'
    # <   or even A:n
    # < suggest writes
    # < throw async unless A agrees to accept an A:u' and wait, somehow
    
    # so G&t tends to go A:u' or A:n it up if not in A.I ...
    
    # I has the I/? and the I/?/? (as I.?.y.tw.?)
    # ? means a C.t, possibly cv multitude via some .y.next
    # I/? or s is a personality or embryo, picked up by thro
    # I/?/? or t is a thing or part of the sequence to thro
    
    # they (eg I/i) are in another W as C.t=i
    #   but cW=of or cW=javascript
    #     the encoder that made them, yet it is as if sW=i (implied)
    #   the cW of a coding is empiricle in its use for connecting to the sW matter   
    
    # though it (W:i) may not be in Where,
    # I/? (W:i) gets talked about/projected by many W
    # I/?/? (W:i's t 1 (G&t)) get clobbered as I/? mix
    
    # so all W-ish things are equal,
    # I persons (believed W's W talkings)
    # W themselves...
    # way
    # any name
    
    # it's just where you look
    # could even find that some remote W contains an I.? thing it wants,
    # and decide to use it
    
    # all from this G&t function
    #   should it interactive and T off W things?
    #   then we could adventure a searchy endpoinT
    
    # it looks up to 5, who could have:
    #   I.W.? a list of W
    #   a way to elvis for it
    #   or some other way/function forward (stylehouse's G&t's Ys&tby)
    
    # re j/4, using things as J:
    # J has store/thaw suggestions in NutMelt:
    #   pi/mine does the job of an A:u' for a storage area (list of W)
    #     lacking A:u' for things pulled in, via G&t or J thaw
    #     but having the ability to grab J happening with A.u
    #       strongly suggest to thaw them if existent in eg sac, or
    #       and auto-save them in eg sac_sc, a patchway to sac
    
    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    # want a type, like http's Accept header,
    #   so G&ting can upstantiate it
    #   things coming alive because of this will have thresholdia
    #   do you want to trust someone else's version of t,
    #   or do you run all the simulations yourself?
    
    # your I should be able to compile from the documentation
    
    #c have subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO Gc&B stacking
    # TODO G.i.* = A.I.i.y.tw.*.c.code, for slight inlining in JBabz
    h: %acgt:s so st sh sf si
        $z = s;
        if (typeof s === 'string') {
            z = G.t(A,C,G,T,'eye',s);
            z ||= G.t(A,C,G,T,'i',s);
        }
        !z and throw "No h: "+s;
        $t = typeof s == 'object' ? ss&js+'/'+s.t+'@'+s.y.cv : z.t;
        $d = {t:t,y:{},c:{},sc:{z:[]}};
        $B = Gc&B;
        B and Bs&z.push(d); d.y.up = B; dc&d = (Bc&d || 0) + 1;
        Gc&B = d;
        ds&D = T.D = z;
        ds&C = C; ds&A = A;
        
        $r = z.c.code(A,C,G,T,so,st,sh,sf,si);
        
        Gc&B = B;
        return r
    
    #c get thing
    # maybe this is the way to do s=C?
    # and have something besides J.I?
    #   if cJ:
    #     look in Js&Jtv, create?
    #   if cW:
    #     look in storage, figure where to put it
    t: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
        $D;
        for (var n = 1; n <= 5; n++) {
            $Y = A[n];
            !Y and continue
            $I = Y.I;
            !I and continue
            # container/personality/embryo
            D = I[s];
            # thing/step/nodule/item
            D && t and D = D.y.tw[t];
            D and break
        }
        !D and s == 'js' and return G&t_js,c,t
        return D;
    
    # W:js $t means cW:js titled t, which is what we deal here...
    #  resourcing quests needing question time
    #   need you to follow them through
    t_js: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
    
    # if G&t of:js t=NutMachine turns up nothing,
    # it can use the /js/ meaniture, storing the resultant thing
    # into 5s&things.js.
    #c waylay can happen by itself
    waylay: %acgt:t ar delay cb
        typeof ar != 'object' and delay = ar; ar = {};
        typeof delay == 'function' and cb = delay; delay = 0;
        cb ||= &s{};
        if (delay) {
            # wait and then way
            # < expect download's tiny delay as well?
            G&delay:delay,&{ G&waylay,t,ar,0,cb };
            ~waylayter: t, delay
            return
        }
        #~waylaydo: t
        G&way,t,ar,cb
    
    #c way fancy subroutine call
    # simple keep downloading fresh code mechanism
    #    async if downloading, uses cb or 1s&N=A && throw
    #  t - name of a way
    #  ar - hash of named arguments
    #  cb - callback containing a sync G&way call 
    #    if cb is &s{...}, give it the return value of the way
    #    if cb is 'noop', do nothing, return 1 if way is ready
    #  no cb 
    #   (going async)
    #   tries to resync the A that needed it via 1s&N
    #   causing a J unprepared for what ways its way depends on,
    #   to resolve one at a time as they occur,
    #   finally downloading the whole codepath
    #  a cb of &{} should run the thing real soon if not immediately
    #  no cb, as most way will be, will resync the J 6
    #    so a way should know what ways you might run into inside it,
    #    so resources can be loaded before J:6, which should sleep
    #     and only happen when it needs to, in tiny ordered parts, etc.
    way: %acgt:t ar cb
        $w = typeof t == 'object' ? t : G&t,'w',t;
        $ttl = 4c&ttl || 5;
        !(w && ws&now && G&time,ws&now,ttl) and w = null
        
        if (!w) {
            cb == 'noop' and cb = &{};
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            $get = '/way/'+t;
            $is_done;
            $done = &s,how,c{
                is_done = 1;
                how != 'success' and throw "Failed request: "+how, c;
                $dige = c.getResponseHeader('Dige');
                $w = G&Cye,[t,1,{s:s},{of:'w',dige:dige}];
                A.5.I ||= {};
                $D = A.5.I.w = A.5.I.w || G&Cye,['w','',{},{z:[]}];
                D.y ||= {};
                D.y.tw ||= {};
                D.y.tw[t] = w;
                ws&now = G&time;
                # < check it compiles? but we don't know its args,
                #   unless they are vaguely known by bumping into compile errors
                #   awaiting better field recording (MelTest frontier of)
                a&ready = 1;
                #~w!: t
                if (cb) {
                    if (G&arfgunc,cb == "s") {
                        # wants its return value with given ar...
                        #~w cb s: t
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the w back?
                        #~w cb: t
                        cb(t,ar,w);
                    }
                }
            };
            $r = $.ajax(get);
            r.done(done);
            $checks = 5;
            $check = &{
                is_done and return;
                !r.statusText && checks-- > 0 and return G&yl,150,check;
                r.statusText == 'Not Found' and throw "No way: "+t
                r.statusText != 'OK' and throw "Weird ajaxtus: "+r.statusText
                #~>57 waylo: t
                done(r.responseText, 'success', r);
            };
            check();
            #~w?: t
            !cb and G&TuneTimeMachine,'w:'+t
            return
        }
        
        ar ||= {};
        $args = G&ks,ar;
        args != wc&code_args and delete wc&code;
        # code is already JaBabz'd
        # < CoArgulate for ar, put as knowable source file?
        # < make it c.code and G&h for a B?
        if (!wc&code) {
            $name = 'w_'+w.t+'_'+ws&dige+'_'+args;
            name = name.replace(/\W+/g,'_');
            4s&namedcode ||= {};
            $code = 4s&namedcode[name];
            if (code) {
                wc&code = code;
            }
            else {
                $tar = 'ar';
                args and tar += ','+args;
                # help Ban find its source
                Gc&B.sc.way = w;
                $code = 'wc&code = function '+name+"(A,C,G,T,"+tar+"){\n"+wc&s+"}";
                eval(code);
                # now compiled, we are not "in" it until run
                delete Gc&B.sc.way;
                4s&namedcode[name] = wc&code;
            }
            wc&code_args = args;
        }
        cb == 'noop' and return
        $arm = [];
        $ark = args.split(',');
        each ik ark {
            arm.push(k);
        }
        $so = ar[arm[0]];
        $st = ar[arm[1]];
        $sh = ar[arm[2]];
        $sf = ar[arm[3]];
        $si = ar[arm[4]];
        
        # help Ban find its source
        Gc&B.sc.way = w;
        return wc&code(A,C,G,T,ar,so,st,sh,sf,si);
    
        
NutMelt: | # puddles of W
    u j
    n \'of:k'
    
    # how/when/where to make deals to:
    #  - bring things in from outside
    #  - write them outside
    #  - take over that outside
    
    0 &&
    hmm:
        5s&stores =  [
            # place to thaw u from
            G&e,sac=>-mine=>{}=>'implies:thaw,if:A-clusping' ,

            # posit for sac all other u things?
            G&e,sac_sc=>-mine=>{}=>'otherwise:use,if:A-clusping' ,

            # to continue, must write
            # < knows resumey jay bits vs whole W versioning
            G&e,gou=>-mine=>{}=>'implies:resume' ,

            # becoming a process
            G&e,G=>-mine=>{}=>'otherwise:resume,if:CcWea=G' ,

            # becoming a process
            G&e,Co=>-mine=>{}=>'otherwise:resume,if:CcWea=Co' ,

            # default write location
            G&e,neu=>-mine=>{}=>'implies:write' ,
        ];
    
    
NutCore: | # doc universals, map room
    return;
    u k
    # a dialect/personality for relationships
    # or boundary effects
    # stuff to one day compile into the throat
    # points for things with scattered use by other things
    # including clues for the likes of -od
    
    # cv is loftiness of use
    
    ttl 4: %on:G
        # time to trust remote resources: way, u things, etc
        # default 5 seconds, needs increase when debugging
    on 1: %on:A.
        # the html element om el 3 will build in
    on 8: %un:k
        # where/what (to o) object can this name be:
        # s        C.sc (default)
        # c        C.c
        # a        A.sc
        # A        A.c
        # A.       A itself
        # G           G.c
        # g           g.sc
        # J        J.sc
        # j        j.c
    un 8:
        # what dialect (u name) this name happens in
        
    
    N: %on:a,J
        # it contains A with desire to thro
        # can nest on any Js&N, most importantly 4s&N
        #   the out-J should resolve any in-Js&N,
        #   put edge to the pile of intention,
        #   before attention drifts away
    
    ready: %on:a
        # bool - is the A ready to resync
        # set to 1 when request is served
        # N groupey A may slightly wait for a consensus of readyness
        # 
    e:
        # likes to be elvised, usu s string or z as jod string
    # oscillator steps
    u s
    J 4:
        # see if we should listen or if its got news 
    
NutBung: | # getting W from I, D from B, and errorifics
    u j
    n \'of:eye'
    
    # the edge of the mind is these items...
    # they could know their 4s&mind?
    add_script: %acgt:src cb
        var script = document.createElement('script');
        script.setAttribute('src', src);
        script.setAttribute('type', 'text/javascript');
        cb and script.onload = &e{ cb(script,e) };
        A.4.on.appendChild(script);
        return script

    # when error
    # < communicate to thro if handley
    # generic linkage to source finding?
    # TODO error object maker (er != string)
    # via window.onerror, msg like "Uncaught "+er
    # the throw async is an abort rather than error,
    #   things should be tested to handle such things properly
    #   domes should add checkpoints to abort to
    # TODO make a devtools link? B stack crawler/playback?
    Ban: %acgt:er msg url lineNo colNo
        $B = Gc&B;
        B = B.y.up;
        if (typeof er == 'string') {
            msg ||= er;
            ~>9 throwstring: er+''
        }
        # msg sometimes stringified er, message is less noisy
        er.message and msg = er.message;
        if (msg.slice(0,5) == 'async') {
            # test for unhandled asyncs
            #G&waylay,'checkov_async',{B:B}
            G&c:'>9 '+msg;
            er.nobigdeal = 1;
            return
        }
        
        msg = msg.replace(/^Uncaught /,'');
        $m = [
            G&intag:'>97 !'
            ,G&intag:'>75:Wtitle'
            ,G&intag:'>9:Bangmsg '+msg
            ,G&intag:'>8:weirdness'
            ,G&intag:'>4:subinfo ?'
        ];
        if (er.tc) {
            m.push( G&intag:'>2:tnc '+ki(er.tc,3) );
            m.push(m.splice(-2,1));
        }
        
        $it = G&c:m.join(' ');
        
        $w = Bs&way;
        $cat = er.catches; # places of rethrow
        # may get restacked when rethrowing
        #   if running chrome < 2012 ?
        $stack = er.stack;
        cat and stack = cat[0].stack;
        !stack and return;
        $k = stack.split("\n");
        k.shift();
        $end = k[0];
        console.log("er: ",msg,url,lineNo,er,w,cat,end);
        url && location.href == url and url = null
        $beyond = 0;
        
        while (k.length) {
            end = k.shift();
            
            beyond and it.set('weirdness','+'+beyond);
            
            # anon sub if way
            $m = end.match(/<anonymous>:(\d+):(\d+)\)$/);
            if (m) {
                url || !w and debugger;
                it.set('Wtitle', 'w:'+w.t);
                $l = wc&s.split("\n")[m[1] - 1 - 1];
                it.set('subinfo', l);
                return
            }

            # a url if <script>
            $m = end.match(/\] \((.+\/js\/.+):(\d+):(\d+)\)$/);
            if (m) {
                url = m[1];
                lineNo = m[2];
                colNo = m[3];
                G&Ban_url,it,er,msg,url,lineNo,colNo;
                return
            }
            
            beyond++;
        }
        
        #debugger;
        ~92 Neither url or way:
        
    #c /js/ reverse engineering
    # < TES get good at just using B etc
    Ban_url: %acgt:it er msg url lineNo colNo
        # make sense of the resource
        $v = new URL(url);
        $src = v.pathname;
        $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
        
        if (!m) {
            # other js resource
            return it.set('subinfo', '?: '+url)
        }
        
        # should be some A:u'
        $W = m[1];
        it.set('Wtitle',W);
        
        # get the lines, in the <script> already?
        $.ajax(src).done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            $W = m[1];
            $ver = m[2];
            $lines = s.split("\n");
            $l = lines[lineNo-1];
            $prior = 1;
            $sub
            while (1) {
                prior++;
                $line = lines[lineNo-prior];
                line == null and break;
                $fu = line.match('^function '+W+'_'+ver
                    +'_(\\w+)_(\\d+)_(\\w+)_(\\d+)\\(');
                !fu and continue
                $cv = '';
                fu[4] != '1' and cv = fu[4]
                sub = fu[1]+cv+'/'+fu[3];
                break
            }
            sub ||= "?: "+src;
            $m = [
                G&intag:'>2:subtitle '+sub
                ,G&intag:'>45:subline '+l
            ];
            it.set('subinfo', m.join(': '));
        });
        
        # check if current
        $.ajax('/js/'+W).done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
            $rep = c.getResponseHeader('Location');
            src != rep and it.set('Wtitle',"(old)",1);
        });
        
        
checkov_async: |
    console.log("Investigate: ",B);

