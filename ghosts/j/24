NutDung: | # things and use
    # use
    n NutThing
    # loose
    n NutMelt
    # misuse
    n NutBung
    # mullinatials
    n NutCore
    # mutate
    #n NutText
    
    
NutThing: | # name of thing
    u j
    n \'of:eye'
    # bring W and the I's insides (and more) together into a namespace
    # serve requests for names
    # < bring things in via A:u'
    # <   or even A:n
    # < suggest writes
    # < throw async unless A agrees to accept an A:u' and wait, somehow
    
    # so G&t tends to go A:u' or A:n it up if not in A.I ...
    
    # I has the I/? and the I/?/? (as I.?.y.tw.?)
    # ? means a C.t, possibly cv multitude via some .y.next
    # I/? or s is a personality or embryo, picked up by thro
    # I/?/? or t is a thing or part of the sequence to thro
    
    # they (eg I/i) are in another W as C.t=i
    #   but cW=of or cW=javascript
    #     the encoder that made them, yet it is as if sW=i (implied)
    #   the cW of a coding is empiricle in its use for connecting to the sW matter   
    
    # though it (W:i) may not be in Where,
    # I/? (W:i) gets talked about/projected by many W
    # I/?/? (W:i's t 1 (G&t)) get clobbered as I/? mix
    
    # so all W-ish things are equal,
    # I persons (believed W's W talkings)
    # W themselves...
    # way
    # any name
    
    # it's just where you look
    # could even find that some remote W contains an I.? thing it wants,
    # and decide to use it
    
    # all from this G&t function
    #   should it interactive and T off W things?
    #   then we could adventure a searchy endpoinT
    
    # it looks up to 5, who could have:
    #   I.W.? a list of W
    #   a way to elvis for it
    #   or some other way/function forward (stylehouse's G&t's Ys&tby)
    
    # re j/4, using things as J:
    # J has store/thaw suggestions in Intre:
    #   pi/mine does the job of an A:u' for a storage area (list of W)
    #     lacking A:u' for things pulled in, via G&t or J thaw
    #     but having the ability to grab J happening with A.u
    #       strongly suggest to thaw them if existent in eg sac, or
    #       and auto-save them in eg sac_sc, a patchway to sac
    
    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    # want a type, like http's Accept header,
    #   so G&ting can upstantiate it
    #   things coming alive because of this will have thresholdia
    #   do you want to trust someone else's version of t,
    #   or do you run all the simulations yourself?
    
    # your I should be able to compile from the documentation
    
    # get thing
    # maybe this is the way to do s=C?
    # and have something besides J.I?
    #   if cJ:
    #     look in Js&Jtv
    #   if cW:
    #     look in storage, figure where to put it
    t: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
        $D;
        $.each([1,2,3,4,5], &i,v{
            D and return;
            var Y = A[v];
            !Y and return;
            var I = Y.I;
            !I and return;
            D = I[s];
            D and t and D = D.y.tw[t];
        });
        !D and s == 'js' and return G&t_js,c,t
        return D;
    
    # W:js $t means W:js titled t, which is what we deal here...
    #  resourcing quests needing question time
    #   need you to follow them through
    t_js: %acgt:s t
        $c;
        typeof s == 'object' and c = s; s = c.of
    
    # if G&t of:js t=NutMachine turns up nothing,
    # it can use the /js/ meaniture, storing the resultant thing
    # into 5s&things.js.
    #c way that can happen by itself
    waylay: %acgt:t ar delay cb
        typeof ar != 'object' and delay = ar; ar = {};
        typeof delay == 'function' and cb = delay; delay = 0;
        cb ||= &s{};
        if (delay) {
            # wait and then way
            # < expect download's tiny delay as well?
            G&delay:delay,&{ G&waylay,t,ar,0,cb };
            ~waylayter: t, delay
            return
        }
        #~waylaydo: t
        G&way,t,ar,cb
    
    # fancy subroutine call
    # simple keep downloading fresh code mechanism
    #    async if downloading, uses cb or 1s&N=A && throw
    #  t - name of a way
    #  ar - hash of named arguments
    #  cb - callback containing a sync G&way call 
    #    if cb is &s{...}, give it the return value of the way
    #    if cb is 'noop', do nothing, return 1 if way is ready
    #  no cb 
    #   (going async)
    #   tries to resync the A that needed it via 1s&N
    #   causing a J unprepared for what ways its way depends on,
    #   to resolve one at a time as they occur,
    #   finally downloading the whole codepath
    #  a cb of &{} should run the thing real soon if not immediately
    #  no cb, as most way will be, will resync the J 6
    #    so a way should know what ways you might run into inside it,
    #    so resources can be loaded before J:6, which should sleep
    #     and only happen when it needs to, in tiny ordered parts, etc.
    way: %acgt:t ar cb
        $w = typeof t == 'object' ? t : G&t,'w',t;
        !(w && ws&now && G&time,ws&now,5) and w = null
        
        if (!w) {
            cb == 'noop' and cb = &{};
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            $get = '/way/'+t;
            $.ajax(get).done(&s,how,c{
                how != 'success' and throw "Failed request: "+how, c;
                $dige = c.getResponseHeader('Dige');
                $w = G&Cye,[t,1,{s:s},{of:'w',dige:dige}];
                A.5.I ||= {};
                $D = A.5.I.w = A.5.I.w || G&Cye,['w','',{},{z:[]}];
                D.y ||= {};
                D.y.tw ||= {};
                D.y.tw[t] = w;
                ws&now = G&time;
                
                a&ready = 1;
                #~w!: t
                if (cb) {
                    if (G&arfgunc,cb == "s") {
                        # wants its return value with given ar...
                        #~w cb s: t
                        $s = G&way,t,ar,'already_async';
                        cb(s);
                    }
                    else {
                        # containing a sync G&way call
                        # or a way to get the w back?
                        ~w cb: t
                        cb(t,ar,w);
                    }
                }
            });
            #~w?: t
            !cb and G&TuneTimeMachine
            return
        }
        
        # code is already JaBabz'd
        # < CoArgulate for ar, put as knowable source file?
        # < make it c.code and G&h for a B?
        if (!wc&code) {
            $name = 'w_'+w.t+'_'+ws&dige;
            4s&namedcode ||= {};
            $code = 4s&namedcode[name];
            if (code) {
                wc&code = code;
            }
            else {
                eval('wc&code = function '+name+"(A,C,G,T,ar){\n"+wc&s+"}");
                4s&namedcode[name] = wc&code;
            }
        }
        
        return wc&code(A,C,G,T,ar);
    
        
NutMelt: | # puddles of W
    u j
    n \'of:k'
    
    0 &&
    hmm:
        5s&stores =  [
            # place to thaw u from
            G&e,sac=>-mine=>{}=>'implies:thaw,if:A-clusping' ,

            # posit for sac all other u things?
            G&e,sac_sc=>-mine=>{}=>'otherwise:use,if:A-clusping' ,

            # to continue, must write
            # < knows resumey jay bits vs whole W versioning
            G&e,gou=>-mine=>{}=>'implies:resume' ,

            # becoming a process
            G&e,G=>-mine=>{}=>'otherwise:resume,if:CcWea=G' ,

            # becoming a process
            G&e,Co=>-mine=>{}=>'otherwise:resume,if:CcWea=Co' ,

            # default write location
            G&e,neu=>-mine=>{}=>'implies:write' ,
        ];
    
    
NutCore: | # doc universals, map room
    return;
    u k
    # a dialect/personality for relationships
    # or boundary effects
    # stuff to one day compile into the throat
    # points for things with scattered use by other things
    # including clues for the likes of -od
    
    # cv is loftiness of use
    
    on 1: %on:A.
        # the html element om el 3 will build in
    on 8: %in:k
        # where/what object can this name be:
        # s        C.sc (default)
        # c        C.c
        # a        A.sc
        # A        A.c
        # A.    in A
        # J        J.sc
        # j        j.c
    in 8:
        # what dialect (u name) this name happens in
        
    
    N: %on:a,J
        # it contains A with desire to thro
        # can nest on any Js&N, most importantly 4s&N
        #   the out-J should resolve any in-Js&N,
        #   put edge to the pile of intention,
        #   before attention drifts away
    
    ready: %on:a
        # bool - is the A ready to resync
        # set to 1 when request is served
        # N groupey A may slightly wait for a consensus of readyness
        # 
    e:
        # likes to be elvised, usu s string or z as jod string
    # oscillator steps
    u s
    J 4:
        # see if we should listen or if its got news 
    
NutBung: | # getting W from I, D from B, and errorifics
    u j
    n \'of:eye'
    
    # the edge of the mind is these items...
    # they could know their 4s&mind?
    addscript: %acgt:src cb
        var script = document.createElement('script');
        script.setAttribute('src', src);
        script.setAttribute('type', 'text/javascript');
        cb and script.onload = &e{ cb(script,e) };
        A.on.appendChild(script);
        return script

    # when error
    # < communicate to thro if handley
    # generic linkage to source finding?
    Ban: %acgt:msg url lineNo colNo er
        $style = "font-size:156%,color:red";
        // catch up innard
        $mid = Math.random().toPrecision().match('\.(\\d+)')[1];
        mid = 'id'+mid;
        $fil = &s,append{
            $lin = $('a#'+mid)[0];
            append and s = lin.innerHTML + s
            lin.innerHTML = s;
        };
        $say = msg+'<a id="'+mid+'" href="#" style="color:white">?<a>';
        
        $W
        $ver
        
        $v = new URL(url);
        $src = v.pathname;
        $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
        if (m) {
            W = m[1];
            ver = m[2];
        }
        $Wsay = '';
        W and Wsay = W+': ';
        $e = '<span style="'+style+'">! '+Wsay+say+'</span>';
        G&c,e;
        console.log("er: ",msg,url,lineNo,er);
        
        !m and return fil(url);
        
        // get the lines, in the <script> already?
        $.ajax(src).done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            $W = m[1];
            $ver = m[2];
            $lines = s.split("\n");
            $l = lines[lineNo-1];
            $prior = 1;
            $sub
            while (1) {
                prior++;
                $line = lines[lineNo-prior];
                line == null and break;
                $fu = line.match('^function '+W+'_'+ver
                    +'(\\w+)_(\\d+)_(\\w+)_(\\d+)\\(');
                !fu and continue
                $cv = '';
                fu[4] != '1' and cv = fu[4]
                sub = fu[1]+cv+'/'+fu[3];
                break
            }
            sub ||= "see "+v;
            fil(sub+": "+l);
        });
        
        // check if current
        $.ajax('/js/'+W).done(&s,how,c{
            how != 'success' and throw "Ban faile: "+how, c;
            $rep = c.getResponseHeader('Location');
            src != rep and fil("(old)",1);
        });
        
        
NutText: | # om suvber, be codemirror of a chunkalism
    u js
    # of html?
    n \'of:om'
    # 
    # s&e - elvisy, likes events, text, could be sliders, pads,
    #  something that emits c&e for itself
    
    # anything fragile and elvisable should have a dige on it,
    # which becomes es&parent when submit,
    # to know it's working off latest
    # and so it can send patches and check they worked
    # dig() in javascript?
    e 2: %of:n
        s&dige = c&s.length;
    
    # el 333 to not put c&s as .text, something should eat it
    e 2:
        a&noinnerText = 1;
    # every element has an A
    any 4: %any
        A.on.A = A;
    e 6:
        $cm = A.b.cm;
        
        $set = {mode:'perl',theme:'midnight',lineWrapping:true};
        if (cm) {
            each kv set {
                cm.setOption(k,v)
            }
        }
        else {
            cm = CodeMirror(A.on, set);
        }
        A.b.cm = cm;
        
        if (c&s) {
            # a string starts or updates
            $was = A.b.givens;
            $is = cm.getValue();
            if (was && is && was != is && is != c&s) {
                ~>27 Merge: A.1.t, C.t
                # look for a way to patch keeping both changes
                # a was->is and a was->c&s,
                # pi about it,
                # and give reset button, merge tool, but not lose any data:
                # send to the G:oner
                console.log("Merged off ",A.1.t,C.t,is);
            }
            cm.setValue(c&s);
            A.b.givens = c&s;
            A.b.dige = s&dige;
        }
        
        # an e springs through here for its id
        A.b.eintro = &e{
            e.t ||= 'says';
            ec&s = cm.getValue();
            es&parent = A.b.dige;
        };
        
        cm.refresh();
        G&yl:400,&{ cm.refresh() };
        
        $sav = &{ G&gev };
        cm.setOption('extraKeys', {Esc:sav});
        cm.on('focus',function(){G.clof();G.keof();});
        cm.on('blur',function(ev,of,inn){G.clon();G.keon();sav();});
    
    #    $('#'+id).css('width','15em','max-height','70%','overflow','scroll');
    #   $('#'+id+' > .CodeMirror');//.css('height','auto');
    
Tri: | # a javascript pin
    # waddley
    G&u,['MelTest'];
    G&u,['NutText'];
    G&clusp;
    
    
    G&n,['d33ee',3,{s:'Intri'},{e:1}];
    
    G&n,['other',1,{s:"steve!"},{jela:5}];
    
    G&n,['something',2,{s:"!!~!@r!"},{fs:'170%',hs:'345'}];
    
    
MelTest: |
    u js
    n \'of:n'
    
    jela 53:
        s&fs = (15 * s)+'%';
        
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # 
    # code folding J
    # start a tree of -jod
    
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline

