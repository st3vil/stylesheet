NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    # into an A:e, approach J/world with A:n?
    # J has quick ev respondo?
    gev: %acgt:ev J
        ev ||= event;
        ev.target.tagName == 'H2' and return
        G&Aye,'ev',9,{ev:ev}
    
    # G&e: see j/23 NutJayTo
    
    u jc
    n \'of:ev'
    
    # event details gathered, finds Js
    # build a C of elvis
    ev 1: %any
        G&way,'EleVisAn',{},'noop';
        G&way,'EleMento';
    
    # events handled real fast, OR plan for A:n made
    ev 2: %any
        G&way,'EleVisAn';
        T.el and return T.not = 1
    
    # A:n to a found J to go make change happen in
    ev 3: %any
        $n = a&wouldn;
        !n and return
        T.not = 1; # stop ev forever
        G&n,n;
        
    #  < ev or e can get lost/pointless/broke and should be helped
    # events may have to pile up to become meaningful?
    # < G&vent for handling various uncertainties in various situations
    ev 4: %any
        a&msg.set("state","no");
    
    
    #c A:n c&e springs into consciousness
    # A:e, tugged along with A:n/Jing every 0.1
    #  may until after 6 for event handlers (1s&ein) to clarify,
    #  or even after 7 for operations on tv
    
    # if some retry-ish thing is happening?
    # Y && (Y.t != 'ev' || e.y.ev != Y) and throw "Interesting e A: "+4s&ki(e);
    n \'of:n'
    e 2:
        $e = s;
        $Y = e.y.A;
        # spawn A:e after A:n@13, inherits A.1 = s&J
        $E = e.y.A = G&Aye,'e',2,{s:e};
        A.e = E;
        E.n = A;
        # wake us
        Es&N ||= [];
        Es&N.push(A);
        # happens in steps in sync with n wakeness
        G&thro,A.e,2
    0 &&
    e 3:
        G&thro,A.e,3
    e 4:
        G&thro,A.e,4
    e 5:
        G&thro,A.e,5
    0 &&
    e 6:
        G&thro,A.e,6
    0 &&
    e 7:
        G&thro,A.e,7
    e 8:
        G&thro,A.e,8;
        A.e.cv < 0.8 and ~>17 lost e: A.e.cv+'/'+A.cv+'@'+C.t, 4s&ki(c&e)
    
    n \'of:e'
    # look through handlers, or wait for clearer time...
    # J usu define api/event handlers in the first section of the pin
    #  then in the call that makes a section heading we have a chance to complete
    #  may need to be oscillated fully to process the request
    #  may want to wait for a quiet time, if it's a human
    einlookup 1: %any
        T.once = 1;
        $ein = 1s&ein;
        !ein and return T.not = 2;
        A&idea = ein[C.t];
        if (!A&idea) {
            $parts = C.t.split('+');
            each it parts {
                A&idea = ein[t];
            }
        }
        $id = A&idea ? 4s&ki(A&idea) : 'no ein';
        ~>86 elvis: A.1.t, C.t, id
        !A&idea and return T.not = 1;
    
    # liable to throw, thro repeating D would be annoying?
    # should only have one way to do,
    #   posit doing this way as a dome, so it can be onced?
    # J must be ready (or not)
    edo 4: %any
        T.el and return
        $ar = {};
        ar.M = 1s&M = 1s&M || [];
        $e = ar.e = C;
        ec&s and ar.s = ec&s;
        C = A.n.c.s;
        each way,pin A&idea {
            way != 'w' and throw "idea not a way: "+4s&ki(A&idea)
            G&way,pin,ar;
        }
        T.el = 1;
    
    # satisfaction?
    edone 5: %any
        if (T.el) {
            A.n.cv <= 0.6 and ~Can avoid J6ing:
            return;
        }
        T.not = 2;
    
    
EleMento: |        # #c ki
    #
        # ki leaves through here for singular squish factory,
        # optional c.keys
        $cvf = &cv{
            m = (cv+'').match(/^0\.(\d+)$/);
            return m && m.length ? m[1] : cv
        };
        $li = &s,c,k{
            $ks = c.ks;
            $was = c;
            $c = $.extend({},c);
            k != null and c.k = k; s = s[k]; c.up = was;
            delete c.ks;
            $M = [];
            $joiner = ',';
            if (s && typeof s == 'object') {
                if (!ks) {
                    ks = [];
                    each kv s {
                        ks.push(k);
                    }
                }
                $elem = 1;
                each ik ks {
                    # could look at c.drawn but we're before/in the mouth of es()
                    (c.type == 'A' || c.type == 'J') && c.k == 'y' && (k == 't' || k == 'y' || k == 'c' || k == 'sc') and continue
                    
                    v = s[k]; # ]
                    $d = $.extend({},c);
                    d.d += 1;
                    d.up = c;
                    d.k = k;
                    $ke = '';
                    c.saykey and ke = k+':';
                    
                    c.k == 'y' and d.d += 2;
                    $sa = ki(v,d);
                    
                    # a number on its own is the cv
                    c.k == 'y' && d.k == 'cv' && sa.drawn == 'string' and sa.s = cvf(v); ke = '';
                    
                    elem && sa.drawn != 'html' and elem = 0;
                    if (elem && sa.drawn == 'html') {
                        # shorten paths in (or out)
                        if (elem != 1) {
                            if (!(v.parentNode == elem
                                || elem.parentNode == v)) {
                                elem = 0
                            }
                        }
                        elem and elem = v;
                    }
                    if (sa.drawn == 'type:t') {
                        # its own type part of the key
                        k.match(sa.type+'$') and ke = k+';'; sa = v.t
                        c.type == 'a' and sa.s = sa.s.replace(/^{|}$/g,'');
                    }
                    if (sa.drawn == 'tycsc') {
                        # enclosed t y c sc
                        # smaller insides?
                        sa.s = '('+sa.s+')';
                    }
                    M.push([ke,sa]);
                }
                # #c whatjust 
                if (elem) {
                    joiner = '^'; # conjoiner of inside elements
                    each im M {
                        sa = m[1];
                        sa.s = sa.s.replace(/^\^|\^$/g,'');
                        
                    }
                }
                if (c.up && c.up.type == 'C' && c.k == 'y') {
                    each im M {
                        m[0] == 'cv:' and m[1] = cvf(m[1])
                    }
                }
                if (c.type == 'A' || c.type == 'J') {
                    # bits in each ks ^
                    if (c.k == 'y') {
                        # split out A.\d, points on wormhole slope
                        $Jnet = {};
                        $N = [];
                        $cvm;
                        each im M {
                            $sa = m[1];
                            # not es() intel object
                            typeof sa == 'string' and N.push(m); continue
                            # take out cv, prefix to Jnet
                            sa.k == 'cv' and cvm = m; continue
                            # take out Jnet numbers
                            sa.k.match(/^\d+$/) and Jnet[sa.k] = sa; continue
                            # we can see properties of string and undefined:
                            # J.2 usually == J.up
                            sa.k == 'up' && sa.v == c.v.2 and continue;
                            sa.k == 'I' and continue;
                            N.push(m);
                        }
                        # crunch them together implicitively
                        $Jnek = Object.keys(Jnet);
                        if (Jnek.length) {
                            Jnek.sort();
                            $E = [];
                            $la;
                            each in Jnek {
                                $d = Jnet[n];
                                d.type != 'J' and throw "JnetnotJ: "+ki(d)
                                $l = la && Jnet[la.k];
                                if (l) {
                                    # same J takes highest number
                                    l.v == d.v and E.pop()
                                }
                                if (n > 3) {
                                    n == 4 && !E.length and E.push('1-4')
                                    # leave off fqdn 4/5, if same as here
                                    d.v == A[n] and continue
                                }
                                # dont say 2 if its 4 
                                n == 2 && d.v == c.v.4 and continue
                                # and if 1,3 etc is it
                                d.v == c.v && d.v != c.v.4 and E.push(n); continue
                                E.push(d);
                                la = d;
                            }
                            $netname = [];
                            each id E {
                                typeof d != 'string' and d = d.v.t
                                netname.push(d);
                            }
                            netname = netname.join('.');
                            # cv can prefix a net name
                            if (cvm) {
                                netname = cvm[1] +'@'+ netname;
                                cvm = null;
                            }
                            N.unshift(['',netname]);
                        }
                        cvm and N.unshift(cvm);
                        M = N;
                    }
                    else
                    if (c.k == 'c' || c.k == 'sc') {
                        $E = [];
                        $N = [];
                        each im M {
                            c.k == 'c' && (m[0] == 'sip' || m[0] == 's' || m[0] == 'N') and E.push(m); continue
                            c.k == 'sc' && (m[0] == 'N' || m[0] == 's') and E.push(m); continue
                            N.push(m);
                        }
                        # will see later-defined things first, except for ^
                        N = N.reverse();
                        while (E.length)
                            N.unshift(E.pop())
                        M = N;
                    }
                }
                $N = [];
                each im M {
                    # 'key:' label and its drawing, an overloaded object
                    $str = m[0]+m[1];
                    N.push(str);
                }
                M = N;
            }
            else {
                $d = $.extend({},c);
                d.d += 1;
                d.up = c;
                M.push(''+ki(s,d));
            }
            $m = M.join(joiner);
            $strlim = c.lum * 20 + 5;
            m.length > strlim + 10 and m = m.substr(0,strlim)+'..*'+M.length
            
            # TODO lightningbolt? coloured metacharacters title=unicode info?
            # Cify the es() object, next/in all this stuff 
            m = m.replace(/\r|\n/g, "â†¯");
            
            return m
        };
        # #c more ki
        $arfgunc = &s{
            typeof s != 'function' and return
            $m = s.toString().match(/^function \((.+?)\)/);
            return m && m[1] || ''
        };
        $ki = &s,c{
            c && typeof c != 'object' and c = {dl:c};
            c ||= {dl:4};
            c.d ||= 1;
            c.d > 15 and throw "large ki";
            c.lum = c.dl - c.d;
            delete c.saykey;
            c.v = s;
            # turn c into string object, add knowing how it is drawn
            $es = &s,drawn{
                c.s = s;
                drawn and c.drawn = drawn;
                c.toString = &{ return ''+this.s };
                c.d == 1 and return ''+c;
                return c
            };
            
            
            if (s == null) {
                return "n*ll"
            }
            else
            if (typeof s == 'number' || typeof s == 'string') {
                !(s+'').match(/^[\+\w]+$/) and s = "'"+s+"'";
                return es(s,'string');
            }
            else
            if (s.constructor == Array) {
                c.type = 'a';
                !s.length and return '[]'
                c.lum < 2 and return '[*'+s.length+']'
                return '['+li(s,c)+']'
            }
            else
            if (s.constructor == Object) {
                c.saykey = 1;
                $ks = Object.keys(s);
                !ks.length and return '{}'
                $type = s.y ? s.y == s ? 'A' : 'C' : 'd';
                !(s.c && s.sc && s.t != null) and type = 'd';
                type == 'C' && ks.length > 4 and type = 'd';
                type == 'A' && s.1 == s and type = 'J'
                c.type = type;
                if (type != 'd') {
                    type == 'A' and c.lum -= 1
                    type == 'J' and c.lum -= 1
                    if (c.lum < 2 && type == 'A') {
                        $cv = cvf(s.cv);
                        return es('{'+type+':'+s.t+'@'+cv+'}','type:t')
                    }
                    c.lum < 1 and return es('{'+type+':'+s.t+'}','type:t')
                    # t y c sc mode, for a clean screen
                    # A.on will be seen through A.y.on
                    return es(
                        li(s,c,'t')+' '+li(s,c,'y')
                        +' '+li(s,c,'c')+' % '
                        +li(s,c,'sc'),
                        'tycsc')
                }
                else {
                    c.lum < 3 and return es('{*'+ks.length+'}')
                    return es('{'+li(s,c)+'}')
                }
                return ''+s
            }
            else
            if ((s.constructor+'').match(/^function HTML/)) {
                $t = s.getAttribute && s.getAttribute('t');
                t ||= s.tagName && s.tagName.toLowerCase();
                t ||= s;
                return es('^'+t+"^",'html')
                
            }
            else
            if (s.constructor == Function) {
                return '&'+ arfgunc(s) +'{*}';
            }
            else {
                return "?"+s+"?"
            }
        };  
        4s&ki = ki;
        
    #c find A, find J, find C
    # A may != the first A found up from event.target
    
        s = c&ev = A&ev;
        C.y.A = A;
        
        # one A:ev per event
        if (4s&last_event == s) {
            # < knowing why this happens
            G&Jinthe,'reset_event_listeners';
            T.not = 1;
            return ~toomanyevents
        }
        4s&last_event = s
        
        # allow 3 exceptions to 10Hz
        G&jam,10,3 and return T.not = 1;
        
        C.t = c&type = s.type;
        s&emotion = 3;
        
        # get info from event
        
        c&which = s.which;
        if (s.keyCode) {
            c&which != s.keyCode and ~differ which to keycode: s.which, s.keyCode
            
            # ignore shift, control, alt
            c&which >= 16 && c&which <= 18 and return

            c&key = String.fromCharCode(s.keyCode);
            c&which == 27 and c&key = 'esc'
            c&which == 32 and c&key = 'space'
            c&key == "\r" and c&key = "\n"
        }
        
        $mo = c&mode = {};
        s.shiftKey and mo.S = 1;
        s.ctrlKey and mo.C = 1;
        s.altKey and mo.A = 1;
        s.metaKey and mo.M = 1;
        !Object.keys(mo).length and delete c&mode;
        $spec = Object.keys(mo);
        spec = spec.join('+');
        
        # combine C.t = A, S+F, C+click, M+2+click
        # for typing into it with e.t...
        if (c&type == 'keydown' || c&type == 'click') {
            if (c&type == 'click') {
                # left 'click', middle '2+click'
                c&which != 1 and C.t = c&which+'+click';
                delete c&which;
            }
            if (c&type == 'keydown') {
                c&key.match(/[a-z0-9]/i) and C.t = c&key; delete c&which;
            }
            spec and C.t = spec+'+'+C.t
        }
        else {
            spec and c&spec = spec; # make into us&S, us&C etc?
        }
        
        if (c&type == 'click' && s.clientX) {
            # relative to page? no pixel 0?
            c&coord = s.clientX +','+ s.clientY;
            # pageXOffset etc?
        }
        
        $tag = $(s.target);
        # lots of things have a val,
        # only <input> or codemirror can input an empty string
        if (tag.val && tag.val().length
            || tag[0].constructor != Window
               && tag[0].nodeName == "INPUT") {
            $k = c&s != null ? 'val' : 's';
            C.c[k] = tag.val();
            C.t = 'input+'+C.t;
        }
        
        # C should now be interesting
        C.t == c&type and delete c&type;
        
        #c TODO s (event) already has a nice s.path
        # start looking at target
        if (s.target) {
            $S = s.target;
            # anything with a t/cv should make the usual us&p path
            # path after the last A outwards, for the last A.1 to know
            $m = c&path_yon = [];
            !S.A and m.push(S);
            while (!S.A) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
            !m.length and delete c&path_yon
            S.A and c&AS = S
        }
        
        # if A found, start proper list from there up
        if (c&AS) {
            $S = c&AS;
            delete c&AS;
            # path through all elements on/between A, for A.3 to -> A.1
            #   may be some elements S without .A?
            # makes it to <body> who .A = A:top, window.A, A.1 == A.4
            $m = c&path = [S];
            while (S && !(S.A && S.A.1 == A.4)) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
        }
        
        # path is elements, who might .A.1 = J
        if (c&path) {
            # reduce to unique Js
            $m = c&Jat = [];
            $la;
            each iS c&path {
                !S.A and continue
                $J = S.A.1;
                J == la and continue
                m.push(J)
                la = J;
            }
            !m.length and delete c&Jat
            !c&Jat and ~>77 No Js, not even 4: ki(C)
            
            #m[0] && !m[0].A and ~>77 NoA on first path: ki(m), ki(c&path_yon)
            #m[0] && m[0].A && m[0].A.1 != A.4 and ~>77 Didnt find 4 up: C
            
            $S = c&path.slice(-1)[0];
            $Y = S.A;
            !Y and ~last had no A:
            $giveth = Y.b && Y.b.eintro;
            if (giveth) {
                #~asking: ki(Y)
                giveth(C);
            }
        }
        
        # Jat path may have shape, A.2 != A.1.2, who knows
        
EleVisAn: | # event handler -> n someone
        ki = 4s&ki;
        
        $e = C;
        # group meanings
        e.t == 'input+esc' and e.t = 'says'
        
        # reorder hash, put lesser info later
        $bor = ['ev','coord'];
        each it bor {
            $v = e.c[t];
            delete e.c[t];
            e.c[t] = v;
        }
        
        # simplify keypress
        $norm = /^[A-Z] A;ev ev:\{\*\d+},type:keydown,key:[A-Z],path:\[body],Jat:\[J:Four] % emotion:3$/;
        $el = ki(e);
        el.match(norm) and el = e.t;
        
        e.t == 'keydown' && ec&which >=16 && ec&which <= 18 and return T.not = 1;
        
        a&msg =
        ~>8 ev: '>15:state', el
        e.y.ev = A;
        
        # from NutText,
        # unless wanting to watch typing as it happens,
        # throws out events like click, keypress other than esc/enter
        if (c&noisyinput) {
            if (c&type != 'blur' && c&key != 'esc' && c&key != "\n") {
                a&msg.set("state","noise");
                return T.not = 1;
            }
        }
        
        # satisfaction with the call/elvising?
        T.el = 1;
        
        # body genera
        if (ec&path && ec&path.length == 1) {
            ec&key == 'A' and c&doi = 'Jin'
            ec&key == 'C' and c&doi = 'Typ'
            ec&key == 'G' and c&doi = 'begoin'
            ec&key == 'T' and c&doi = 'Tri'
        
            if (ec&key == "\n") {
                return [1,2,3,4,5].filter(&{
                    ~>78 space:
                });
            }
        }
        c&doi and c&did = 'i'; return G&h,c&doi,e
        
        # become unsatisfied, seek handling in J
        delete T.el;
        
        a&msg.set("state","Jing");
        !c&Jat and return;
        
        $Js = c&Jat.slice();
        $W = [];
        each iJ Js {
            J.1 == J.3 and W.push(J);
        }
        W[0] == A.4 and W.shift();
        
        W.length > 1 and ~>9 Wnesting: ki(W)
        # Four listens to everything you say,
        # makes art as a way to store entropy
        !W.length and return
        W = W[0];
        
        $C = a&wouldn = [W.t,'W',{e:e}];
        #A.t = 'e';
        #4s&N.push(A);
        
    
ElTakeNote: | # event that-ers
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h
NutText: | # subverse valuar, for editables s&e
    u js
    # of html?
    n \'of:om'
    # 
    # s&e - elvisy, likes events, text, could be sliders, pads,
    #  something that emits c&e for itself
    
    # anything fragile and elvisable should have a dige on it,
    # which becomes es&parent when submit,
    # to know it's working off latest
    # and so it can send patches and check they worked
    # dig() in javascript?
    e 2: %of:n
        s&dige = c&s.length;
    
    # el 333 to not put c&s as .text, something should eat it
    e 2:
        a&noinnerText = 1;
        if (s == '2') {
            c&tag = 'input';
            s&inv = 1;
            s&textinput = 1;
        }
        else {
            s&codemirror = 1;
        }
    
    # every element has an A
    any 4: %any
        A.on.A = A;
    
    # file:///home/s/shed/public/codemirror/demo/complete.html
    codemirror 6:
        $cm = A.b.cm = A.b.cm || CodeMirror(
            A.on,
            {mode:'perl',theme:'midnight',lineWrapping:true}
        );
        # set options later:
        # cm.setOption(k,v)
        
        if (c&s) {
            # a string starts or updates
            $was = A.b.givens;
            $is = cm.getValue();
            if (was && is && was != is && is != c&s) {
                ~>97 Merge: A.1.t, C.t
                # look for a way to patch keeping both changes
                # a was->is and a was->c&s,
                # pi about it,
                # and give reset button, merge tool, but not lose any data:
                # send to the G:oner
                console.log("Merged off ",A.1.t,C.t,is);
            }
            cm.setValue(c&s);
            A.b.givens = c&s;
            A.b.dige = s&dige;
        }
        
        # an e springs through here for its id
        A.b.eintro = &e{
            e.t = 'says';
            ec&s = cm.getValue();
            es&parent = A.b.dige;
            ec&noisyinput = 1;
        };
        
        cm.refresh();
        G&yl:400,&{ cm.refresh() };
        
        $sav = &{ G&gev };
        cm.setOption('extraKeys', {
            'Esc': sav,
            # TODO doesn't work?
            "Ctrl-Q": &cm{ cm.foldCode(cm.getCursor()); },
        });
        
        # when markers can be used for these things:
        # cm.setOption('lineNumbers',true);
        # cm.setOption('foldGutter',true);
        # cm.setOption('gutters',
        #["CodeMirror-foldgutter"]);
        
        # TODO use/upload/download markers, fold with them
        # have them able to be open or closed to the next marker of same dp..
        # cm.foldCode(CodeMirror.Pos(21, 0));
        
        cm.on('focus',function(){G.clof();G.keof();});
        cm.on('click',function(){G.clof();G.keof();});
        cm.on('blur',function(ev,of,inn){G.clon();G.keon();sav();});
    
    #    $('#'+id).css('width','15em','max-height','70%','overflow','scroll');
    #   $('#'+id+' > .CodeMirror');//.css('height','auto');
    
    textinput 6:
        c&s != null and A.on.value = c&s;
        
        # an e springs through here for its id
        A.b.eintro = &e{
            e.t = 'says';
            # we default to ec&s $(A.on).val()
            # unless wanting to watch typing as it happens,
            # throws out events like click, keypress other than esc/enter
            ec&noisyinput = 1;
        };
        
        $(A.on).on('blur',function(ev,of,inn){G&gev });

