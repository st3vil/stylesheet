NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    # into an A:e, approach J/world with A:n?
    # J has quick ev respondo?
    gev: %acgt:ev J
        ev ||= event;
        G&Aye,'ev',9,{ev:ev}
        
    # ephemeral n without:
    # - clusping the mind, or
    # - attaching to this ground (usu for c.e)
    # < e could be reliabilitied by grounding and osc work
    # usually n \'of:mo' -> C.c.of=mo
    # but for e it A.c.of=mo, for eg nomem
    
    # babs
    # e other: thing: what          -> G&e,['other'],['thing','','what']
    #  then as n [other=>W=>{e:['thing','','what']}]
    # with A&nogro = 1
    
    # e {cstuff:4} this: stiil   -> G&e,{nAcstuff:4},['this','','stiil']
    # so can not put 
    # e C, this: -pi24             C, ['this',0.24,{pi:'this'}]
    # shows C this
    
    #  as an intention for process it can be slowed down when n same
    #  page for every elvising going on wanted,
    #  the script of its activity zoomintoable
    # the sudden datatype
    e: %acgt:c s
        !c || !s and throw "e carefully"
        C = c;
        c = {};
        C.constructor == Array and C = G&Cye,C
        s.constructor == Array and s = G&Cye,s
        # if first C is {} but not C it is A.c,
        # and second becomes first, so is like n with A.c spec
        !(C.y && C.c && C.sc) and c = C; C = s; s = null;
        
        # put second C on first as c&e
        s and c&e = s
        
        c.nogro = 1;
        c.s = C;
        
        $et = ''
        s and et = s.t;
        
        ~e: C.t, et
        
        G&Aye,'n',8,c;
        
        C

    u jc
    n \'of:ev'
    
    # that an event must emerge
    # and finds its A.12223 (in reverse, path, and what to W)
    # to be able to
    ev 1: %any
        console.log("ev 1");
        $cb = &s{
            console.log('Wayteis cb');
        };
        G&way,'Wayteis',{},cb;
        
        G&waylay,'ElOne';
        
    n \'of:e'
    # usu has an n of this J going on to make change happen in
    # or if coming from event rather than
    e 1:
        ~e: C.t, s.t, A&sip
    
    # A:n C.c.e = e, start e.y.A = A:e
    e 2: %of:n
        ~n-e: C.t, s.t, A&sip
        s.y.A ||= G&Aye,'e',2,{s:s};
        A.e = s.y.A;
        s.y.A.n = A;
    
    # once you need the A.n to be awake, you'll have to create it...
    0 &&
    elev:
        var cm = s;
        var d = {};
        G&entag,d,$(A.on);
        A.b.jus = d.code = cm.getValue();
        d.dig = $(A.on).attr('dig');
        console.log("elev",d);
        #G&socking,d;
    
    
    
Wayteis: |
    console.log('Wayteis');
ElOne: |
    # find A, find J, find C
    # A may != the first A found up from event.target
    # A.b.eintro
    s = c&ev = A&ev;
    ~ev: s.type
    console.log("HEl");
    c&type = s.type;
    s&emotion = 3;
    
    # A.b.eintro

    
    
        C.t = "Know";
        $e = C;
        C = A&s = G&Cye,["Typ"];
        c&e = e;
        
        A.t = 'e';
        
        4s&N.push(A);
        
    
ElTakeNote: | # event that-ers
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h

