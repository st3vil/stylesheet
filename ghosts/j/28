NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    # into an A:e, approach J/world with A:n?
    # J has quick ev respondo?
    gev: %acgt:ev J
        ev ||= event;
        ev.target.tagName == 'H2' and return
        G&Aye,'ev',9,{ev:ev}
        
    # ephemeral n
    #   doesn't inherently mean elvising (c&e = act)
    # usual traceless way to send stuff over there
    
    # without clusping or grounding here
    # elvising if two args of C, first.c.e = second
    # directives for A:n.c if first arg !C (rare?)
    
    # < you could also n elvising to reliabilitate it
    #   < osc plays tcp with it
    
    # babs about how to divide sweet notation into two flat C
    # e other: thing: what          -> G&e,['other'],['thing','','what']
    #  then as n [other=>W=>{e:['thing','','what']}]
    
    # e {cstuff:4} this: stiil   -> G&e,{nAcstuff:4},['this','','stiil']
    # so can not put 
    # e C, this: -pi24             C, ['this',0.24,{pi:'this'}]
    # shows C this
    
    #  as an intention for process it can be slowed down when n same
    #  page for every elvising going on wanted,
    #  the script of its activity zoomintoable
    # the sudden datatype
    e: %acgt:c s
        !c || !s and throw "e carefully"
        C = c;
        c = {};
        C.constructor == Array and C = G&Cye,C
        s.constructor == Array and s = G&Cye,s
        # if first C is {} but not C it is A.c,
        # and second becomes first, so is like n with A.c spec
        !(C.y && C.c && C.sc) and c = C; C = s; s = null;
        
        # put second C on first as c&e
        s and c&e = s
        
        c.nogro = 1;
        c.s = C;
        
        $et = ''
        s and et = s.t;
        
        ~e: C.t, et
        
        G&Aye,'n',8,c;
        
        C

    u jc
    n \'of:ev'
    
    # event details gathered, finds Js
    # build a C of elvis
    ev 1: %any
        G&way,'EleVisAn',{},'noop';
        G&way,'EleMento';
    
    # events handled real fast, OR plan for A:n made
    ev 2: %any
        G&way,'EleVisAn';
        T.el and return T.not = 1
    
    # A:n to a found J to go make change happen in
    #  and switches A.t to 'e', done with being an event,
    #   build an A:n C to c&e this A:e C, and take over flow control
    
    # make a new T for continuing
    #  could T.seek.2=A:n?
    ev 3: %any
        $n = a&wouldn;
        !n and return
        A&T = $.extend({},T);
        T.whack = 1;
        A.t = 'e';
        G&n,n;
        
    #  < ev or e can get lost/pointless/broke and should be helped
    # events may have to pile up to become meaningful?
    ev 4: %any
        ~broken event: C.t
    
    n \'of:e'
    # $E = A:e, $e = A:n's c&e
    # stereo channel for J with e acting itself out somehow
    # the A:e used to be A:ev, if it was from an event (starts at 2)
    ewalksin 1: %any
        ~eONE: C.t, s.t, A&sip
    
    # A:n c&e springs into consciousness
    #  (or A:ev resumes itself as A:e, from an A:n contacting clickee)
    # A:e is tugged along with A:n/Jing every 0.1
    #  unless its waiting for event handlers to clarify
    e 2: %of:n
        $e = s;
        # springs
        ~ne: C.t, e.t
        $E = e.y.A = e.y.A || G&Aye,'e',2,{s:e};
        A.e = E;
        E.n = A;
        G&thro,A.e,2;
    
    # look through handlers, or wait for clearer time...
    # J usu define api/event handlers in the first section of the pin
    #  then in the call that makes a section heading we have a chance to complete
    #  may need to be oscillated fully to process the request
    #  may want to wait for a quiet time, if it's a human
    esurveys 2: %any
        # look
        ~elvis enters: A.1.t
    
    
    
EleMento: |        # #c ki
    #
        # ki leaves through here for singular squish factory,
        # optional c.keys
        $cvf = &cv{
            m = (cv+'').match(/^0\.(\d+)$/);
            return m && m.length ? m[1] : cv
        };
        $li = &s,c,k{
            $ks = c.ks;
            $was = c;
            $c = $.extend({},c);
            k != null and c.k = k; s = s[k]; c.up = was;
            delete c.ks;
            $M = [];
            $joiner = ',';
            if (s && typeof s == 'object') {
                if (!ks) {
                    ks = [];
                    each kv s {
                        ks.push(k);
                    }
                }
                $elem = 1;
                each ik ks {
                    # could look at c.drawn but we're before/in the mouth of es()
                    (c.type == 'A' || c.type == 'J') && c.k == 'y' && (k == 't' || k == 'y' || k == 'c' || k == 'sc') and continue
                    
                    v = s[k]; # ]
                    $d = $.extend({},c);
                    d.d += 1;
                    d.up = c;
                    d.k = k;
                    $ke = '';
                    c.saykey and ke = k+':';
                    
                    c.k == 'y' and d.d += 2;
                    $sa = ki(v,d);
                    
                    c.k == 'y' && d.k == 'cv' && !sa.k and sa = cvf(sa); ke = '';
                    
                    elem && sa.drawn != 'html' and elem = 0;
                    if (elem && sa.drawn == 'html') {
                        # shorten paths in (or out)
                        if (elem != 1) {
                            if (!(v.parentNode == elem
                                || elem.parentNode == v)) {
                                elem = 0
                            }
                        }
                        elem and elem = v;
                    }
                    if (sa.drawn == 'type:t') {
                        # its own type part of the key
                        k.match(sa.type+'$') and ke = k+';'; sa = v.t
                        c.type == 'a' and sa.s = sa.s.replace(/^{|}$/g,'');
                    }
                    if (sa.drawn == 'tycsc') {
                        # enclosed t y c sc
                        # smaller insides?
                        sa.s = '('+sa.s+')';
                    }
                    M.push([ke,sa]);
                }
                # #c whatjust 
                if (elem) {
                    joiner = '^'; # conjoiner of inside elements
                    each im M {
                        sa = m[1];
                        sa.s = sa.s.replace(/^\^|\^$/g,'');
                        
                    }
                }
                if (c.up && c.up.type == 'C' && c.k == 'y') {
                    each im M {
                        m[0] != 'cv:' and continue
                        m[1] = cvf(m[1])
                    }
                }
                if (c.type == 'A' || c.type == 'J') {
                    # bits in each ks ^
                    if (c.k == 'y') {
                        # the y of the A drawn tycsc
                        $L = [];
                        $E = [];
                        $N = [];
                        # last m[0] ke: label
                        $le;
                        # last m[1] sa thingstring
                        $la;
                        each im M {
                            $sa = m[1];
                            #typeof sa == 'string' and N.push(m); continue
                            if (typeof sa == 'string') {
                            }
                            else
                            if (sa.k.match(/^\d+$/)) {
                                la && la.s != sa.s and E.push([le,la]); la = 0
                                le = la ?
                                    le.replace(/(-\d+)?$/,'-'+sa.k)
                                :
                                    sa.k;
                                la = sa;
                                continue;
                            }
                            sa.k == 'I' and continue;
                            N.push(m);
                        }
                        
                        la and E.push([le,la]);
                        
                        while (E.length)
                            N.unshift(E.pop())
                        while (L.length)
                            N.unshift(L.pop())
                        M = N;
                    }
                    else
                    if (c.k == 'c' || c.k == 'sc') {
                        $E = [];
                        $N = [];
                        each im M {
                            c.k == 'c' && (m[0] == 'sip' || m[0] == 's' || m[0] == 'N') and E.push(m); continue
                            c.k == 'sc' && (m[0] == 'N' || m[0] == 's') and E.push(m); continue
                            N.push(m);
                        }
                        # will see later-defined things first, except for ^
                        N = N.reverse();
                        while (E.length)
                            N.unshift(E.pop())
                        M = N;
                    }
                }
                $N = [];
                each im M {
                    # 'key:' label and its drawing, an overloaded object
                    $str = m[0]+m[1];
                    N.push(str);
                }
                M = N;
            }
            else {
                $d = $.extend({},c);
                d.d += 1;
                d.up = c;
                M.push(''+ki(s,d));
            }
            $m = M.join(joiner);
            $strlim = c.lum * 20 + 5;
            m.length > strlim + 10 and m = m.substr(0,strlim)+'..*'+M.length
            
            # TODO lightningbolt? coloured metacharacters title=unicode info?
            # Cify the es() object, next/in all this stuff 
            m = m.replace(/\r|\n/g, "â†¯");
            
            return m
        };
        # #c more ki
        $ki = &s,c{
            c && typeof c != 'object' and c = {dl:c};
            c ||= {dl:4};
            c.d ||= 1;
            c.d > 15 and throw "large ki";
            c.lum = c.dl - c.d;
            delete c.saykey;
            # turn c into string object, add knowing how it is drawn
            $es = &s,drawn{
                c.s = s;
                drawn and c.drawn = drawn;
                c.toString = &{ return ''+this.s };
                c.d == 1 and return ''+c;
                return c
            };
            
            
            if (s == null) {
                return "n*ll"
            }
            else
            if (typeof s == 'number' || typeof s == 'string') {
                s+''.match(/^\w+$/) and return s;
                return "'"+s+"'";
            }
            else
            if (s.constructor == Array) {
                c.type = 'a';
                !s.length and return '[]'
                c.lum < 2 and return '[*'+s.length+']'
                return '['+li(s,c)+']'
            }
            else
            if (s.constructor == Object) {
                c.saykey = 1;
                $ks = Object.keys(s);
                !ks.length and return '{}'
                $type = s.y ? s.y == s ? 'A' : 'C' : 'd';
                !(s.c && s.sc && s.t != null) and type = 'd';
                type == 'C' && ks.length > 4 and type = 'd';
                type == 'A' && s.1 == s and type = 'J'
                c.type = type;
                if (type != 'd') {
                    type == 'A' and c.lum -= 1
                    type == 'J' and c.lum -= 1
                    c.lum < 2 and return es('{'+type+':'+s.t+'}','type:t')
                    # t y c sc mode, for a clean screen
                    # A.on will be seen through A.y.on
                    return es(
                        li(s,c,'t')+' '+li(s,c,'y')
                        +' '+li(s,c,'c')+' % '
                        +li(s,c,'sc'),
                        'tycsc')
                }
                else {
                    c.lum < 3 and return es('{*'+ks.length+'}')
                    return es('{'+li(s,c)+'}')
                }
                return ''+s
            }
            else
            if ((s.constructor+'').match(/^function HTML/)) {
                $t = s.getAttribute && s.getAttribute('t');
                t ||= s.tagName && s.tagName.toLowerCase();
                t ||= s;
                return es('^'+t+"^",'html')
                
            }
            else
            if (s.constructor == Function) {
                return '&'+ G&arfgunc,s +'{*}';
            }
            else {
                return "?"+s+"?"
            }
        };  
        4s&ki = ki;
        
    #c find A, find J, find C
    # A may != the first A found up from event.target
    
        s = c&ev = A&ev;
        C.y.A = A;
        
        # one A:ev per event
        if (4s&last_event == s) {
            # < knowing why this happens
            G&Jinthe,'reset_event_listeners';
            T.not = 1;
            return ~toomanyevents
        }
        4s&last_event = s
        
        # allow 3 exceptions per oscillation to 10Hz
        G&jam,10,3 and return
        
        C.t = c&type = s.type;
        s&emotion = 3;
        
        # get info from event
        
        c&which = s.which;
        if (s.keyCode) {
            c&which != s.keyCode and ~differ which to keycode: s.which, s.keyCode
            
            # ignore shift, control, alt
            c&which >= 16 && c&which <= 18 and return

            c&key = String.fromCharCode(s.keyCode);
            c&which == 27 and c&key = 'esc'
            c&which == 32 and c&key = 'space'
            c&key == "\r" and c&key = "\n"
        }
        
        $mo = c&mode = {};
        s.shiftKey and mo.S = 1;
        s.ctrlKey and mo.C = 1;
        s.altKey and mo.A = 1;
        s.metaKey and mo.M = 1;
        !Object.keys(mo).length and delete c&mode;
        $spec = Object.keys(mo);
        spec = spec.join('+');
        
        # combine C.t = A, S+F, C+click, M+2+click
        # for typing into it with e.t...
        if (c&type == 'keydown' || c&type == 'click') {
            if (c&type == 'click') {
                # left 'click', middle '2+click'
                c&which != 1 and C.t = c&which+'+click';
                delete c&which;
            }
            if (c&type == 'keydown') {
                c&key.match(/[a-z0-9]/i) and C.t = c&key; delete c&which;
            }
            spec and C.t = spec+'+'+C.t
        }
        else {
            spec and c&spec = spec; # make into us&S, us&C etc?
        }
        
        if (c&type == 'click' && s.clientX) {
            # relative to page? no pixel 0?
            c&coord = s.clientX +','+ s.clientY;
            # pageXOffset etc?
        }
        
        $tag = $(s.target);
        if (tag.val && tag.val().length) {
            $k = c&s != null ? 'val' : 's';
            C.c[k] = tag.val();
            C.t = 'input+'+C.t;
        }
        
        # C should now be interesting
        C.t == c&type and delete c&type;
        
        #c TODO s (event) already has a nice s.path
        # start looking at target
        if (s.target) {
            $S = s.target;
            # anything with a t/cv should make the usual us&p path
            # path after the last A outwards, for the last A.1 to know
            $m = c&path_yon = [];
            !S.A and m.push(S);
            while (!S.A) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
            !m.length and delete c&path_yon
            S.A and c&AS = S
        }
        
        # if A found, start proper list from there up
        if (c&AS) {
            $S = c&AS;
            delete c&AS;
            # path through all elements on/between A, for A.3 to -> A.1
            #   may be some elements S without .A?
            # makes it to <body> who .A = A:top, window.A, A.1 == A.4
            $m = c&path = [S];
            while (S && !(S.A && S.A.1 == A.4)) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
        }
        
        # path is elements, who might .A.1 = J
        if (c&path) {
            # reduce to unique Js
            $m = c&Jat = [];
            $la;
            each iS c&path {
                !S.A and continue
                $J = S.A.1;
                J == la and continue
                m.push(J)
                la = J;
            }
            !m.length and delete c&Jat
            !c&Jat and ~>77 No Js, not even 4: ki(C)
            
            #m[0] && !m[0].A and ~>77 NoA on first path: ki(m), ki(c&path_yon)
            #m[0] && m[0].A && m[0].A.1 != A.4 and ~>77 Didnt find 4 up: C
            
            $S = c&path.slice(-1)[0];
            $Y = S.A;
            !Y and ~last had no A:
            $giveth = Y.b && Y.b.eintro;
            if (giveth) {
                ~asking: ki(Y)
                giveth(C);
            }
        }
        
        # Jat path may have shape, A.2 != A.1.2, who knows
        
EleVisAn: | # event handler -> n someone
        ki = 4s&ki;
        
        
        $norm = /^[A-Z] A;ev ev:\{\*28},type:keydown,key:[A-Z],path:\[body],Jat:\[J:Four] % emotion:3$/;
        $el = ki(C);
        el.match(norm) and el = C.t;
        
        ~>8 ev: el
        $e = C;
        
        e.t == 'A' and c&doi = 'Jin'
        e.t == 'C' and c&doi = 'Typ'
        e.t == 'G' and c&doi = 'begoin'
        e.t == 'T' and c&doi = 'Tri'
        
        e.t == 'input+esc' and e.t = 'say'
        
        # satisfaction with the call/elvising?
        T.el = 1;
        if (ec&key == "\n") {
            return [1,2,3,4,5].filter(&{
                ~>78 space:
            });
        }
        c&doi and c&did = 'i'; return G&h,c&doi
        delete T.el;
        
        !c&Jat and return;
        
        $Js = c&Jat.slice();
        $W = [];
        each iJ Js {
            J.1 == J.3 and W.push(J);
        }
        W[0] == A.4 and W.shift();
        
        W.length > 1 and ~>9 Wnesting: ki(W)
        # Four listens to everything you say,
        # makes art as a way to store entropy
        !W.length and return
        W = W[0];
        
        a&wouldn = [W.t,'W',{e:C}];
        
        #A.t = 'e';
        #4s&N.push(A);
        
    
ElTakeNote: | # event that-ers
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h
NutText: | # subverse valuar, for editables s&e
    u js
    # of html?
    n \'of:om'
    # 
    # s&e - elvisy, likes events, text, could be sliders, pads,
    #  something that emits c&e for itself
    
    # anything fragile and elvisable should have a dige on it,
    # which becomes es&parent when submit,
    # to know it's working off latest
    # and so it can send patches and check they worked
    # dig() in javascript?
    e 2: %of:n
        s&dige = c&s.length;
    
    # el 333 to not put c&s as .text, something should eat it
    e 2:
        a&noinnerText = 1;
    # every element has an A
    any 4: %any
        A.on.A = A;
    
    # file:///home/s/shed/public/codemirror/demo/complete.html
    e 6:
        $cm = A.b.cm;
        
        $set = {mode:'perl',theme:'midnight',lineWrapping:true};
        if (cm) {
            each kv set {
                cm.setOption(k,v)
            }
        }
        else {
            cm = CodeMirror(A.on, set);
        }
        A.b.cm = cm;
        
        if (c&s) {
            # a string starts or updates
            $was = A.b.givens;
            $is = cm.getValue();
            if (was && is && was != is && is != c&s) {
                ~>97 Merge: A.1.t, C.t
                # look for a way to patch keeping both changes
                # a was->is and a was->c&s,
                # pi about it,
                # and give reset button, merge tool, but not lose any data:
                # send to the G:oner
                console.log("Merged off ",A.1.t,C.t,is);
            }
            cm.setValue(c&s);
            A.b.givens = c&s;
            A.b.dige = s&dige;
        }
        
        # an e springs through here for its id
        A.b.eintro = &e{
            e.t = 'says';
            ec&s = cm.getValue();
            es&parent = A.b.dige;
        };
        
        cm.refresh();
        G&yl:400,&{ cm.refresh() };
        
        $sav = &{ G&gev };
        cm.setOption('extraKeys', {
            'Esc': sav,
            # TODO doesn't work?
            "Ctrl-Q": &cm{ cm.foldCode(cm.getCursor()); },
        });
        
        # when markers can be used for these things:
        # cm.setOption('lineNumbers',true);
        # cm.setOption('foldGutter',true);
        # cm.setOption('gutters',
        #["CodeMirror-foldgutter"]);
        
        # TODO use/upload/download markers, fold with them
        # have them able to be open or closed to the next marker of same dp..
        # cm.foldCode(CodeMirror.Pos(21, 0));
        
        cm.on('focus',function(){G.clof();G.keof();});
        cm.on('blur',function(ev,of,inn){G.clon();G.keon();sav();});
    
    #    $('#'+id).css('width','15em','max-height','70%','overflow','scroll');
    #   $('#'+id+' > .CodeMirror');//.css('height','auto');
    

