NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    # into an A:e, approach J/world with A:n?
    # J has quick ev respondo?
    gev: %acgt:ev J
        ev ||= event;
        G&Aye,'ev',9,{ev:ev}
        
    # ephemeral n without:
    # - clusping the mind, or
    # - attaching to this ground (usu for c.e)
    # < e could be reliabilitied by grounding and osc work
    # usually n \'of:mo' -> C.c.of=mo
    # but for e it A.c.of=mo, for eg nomem
    
    # babs
    # e other: thing: what          -> G&e,['other'],['thing','','what']
    #  then as n [other=>W=>{e:['thing','','what']}]
    # with A&nogro = 1
    
    # e {cstuff:4} this: stiil   -> G&e,{nAcstuff:4},['this','','stiil']
    # so can not put 
    # e C, this: -pi24             C, ['this',0.24,{pi:'this'}]
    # shows C this
    
    #  as an intention for process it can be slowed down when n same
    #  page for every elvising going on wanted,
    #  the script of its activity zoomintoable
    # the sudden datatype
    e: %acgt:c s
        !c || !s and throw "e carefully"
        C = c;
        c = {};
        C.constructor == Array and C = G&Cye,C
        s.constructor == Array and s = G&Cye,s
        # if first C is {} but not C it is A.c,
        # and second becomes first, so is like n with A.c spec
        !(C.y && C.c && C.sc) and c = C; C = s; s = null;
        
        # put second C on first as c&e
        s and c&e = s
        
        c.nogro = 1;
        c.s = C;
        
        $et = ''
        s and et = s.t;
        
        ~e: C.t, et
        
        G&Aye,'n',8,c;
        
        C

    u jc
    n \'of:ev'
    
    # that an event must emerge
    # and finds its A.12223 (in reverse, path, and what to W)
    # to be able to
    ev 1: %any
        G&waylay,'EleOne';
    
    n \'of:e'
    # usu has an n of this J going on to make change happen in
    # or if coming from event rather than
    e 1:
        ~e: C.t, s.t, A&sip
    
    # A:n C.c.e = e, start e.y.A = A:e
    e 2: %of:n
        ~n-e: C.t, s.t, A&sip
        s.y.A ||= G&Aye,'e',2,{s:s};
        A.e = s.y.A;
        s.y.A.n = A;
    
    # once you need the A.n to be awake, you'll have to create it...
    0 &&
    elev:
        var cm = s;
        var d = {};
        G&entag,d,$(A.on);
        A.b.jus = d.code = cm.getValue();
        d.dig = $(A.on).attr('dig');
        console.log("elev",d);
        #G&socking,d;
    
    
    
EleOne: |
    # find A, find J, find C
    # A may != the first A found up from event.target
    # A.b.eintro
        s = c&ev = A&ev;
        
        c&type = s.type;
        s&emotion = 3;
        
        # get info from event
        
        c&which = s.which;
        if (s.keyCode) {
            c&which != s.keyCode and ~differ which to keycode: s.which, s.keyCode
            
            # ignore shift, control, alt
            c&which >= 16 && c&which <= 18 and return

            c&key = String.fromCharCode(s.keyCode);
            c&which == 27 and c&key = 'esc'
        }
        
        $mo = c&mode = {};
        s.shiftKey and mo.S = 1;
        s.ctrlKey and mo.C = 1;
        s.altKey and mo.A = 1;
        s.metaKey and mo.M = 1;
        !Object.keys(mo).length and delete c&mode;
        $spec = Object.keys(mo);
        spec.push(c&key);
        spec = spec.join('+');
        
        # start looking at target
        if (s.target) {
            $S = s.target;
            # anything with a t/cv, to make the usual us&p path
            # path from last A outwards
            $m = c&path_yon = [S];
            while (!S.A) {
                S = S.parentNode;
                !S and break
                m.unshift(S)
            }
            # path through all A elements
            #   may be some elements (S) without .A?
            $m = c&path = [S];
            while (S && !(S.A && S.A.1 == A.4)) {
                S = S.parentNode;
                !S and break
                m.unshift(S)
            }
            # makes it to <body> who .A = A:top, window.A, A.1 == A.4
            m[0] && m[0].A.1 != A.4 and ~>77 Didnt find 4 up: C
            # reduce to unique Js
            $m = c&Jat = [];
            each iS c&path {
                !S.A and continue
                $la = m.slice(-1)[0];
                la && la.1 == S.A.1 and continue
                m.push(S.A.1)
            }
        }
        
        if (c&path) {
            $S = c&path.slice(-1)[0];
            $Y = S.A;
            !Y and ~last had no A:
            $giveth = Y.b && Y.b.eintro;
            giveth and giveth(C);
        }
        
        # C should now be interesting
        
        $say = ['J:'];
        each iJ c&Jat {
            say.push(J.t)
        }
        say.push('E:');
        each iS c&path {
            say.push(S.nodeName)
        }
        
        say = say.join(" ");
        ~ever: s.type, spec, say
        
        # #c ki
        # ki leaves through here for singular squish factory,
        # optional c.keys
        $li = &s,c{
            $ks = c.ks;
            delete c.ks;
            if (!ks) {
                ks = [];
                each kv s {
                    ks.push(k);
                }
            }
            $M = [];
            each ik ks {
                v = s[k];
                $d = $.extend({},c);
                d += 1;
                $ke = '';
                saykey and ke = k+':';
                M.push(ke+ki(v,d));
            }
            $m = M.join(",");
            $strlim = c.lum * 10 + 5;
            m.length > strlim + 10 and m = m.substr(0,strlim)+'..*'+M.length
            return m
        };
        
        $ki = &s,c{
            c ||= {};
            typeof c != 'object' and c = {dl:4};
            c.d ||= 1;
            c.d > 5 and throw "large ki";
            $lum = c.lum = c.dl - c.d;
            
            if (typeof s == 'number' || typeof s == 'string') {
                return "'"+s+"'";
            }
            else
            if (s.constructor == Array) {
                !s.length and return '[]'
                lum < 2 and return '[*'+s.length+']'
                lum < 3 and return '['+li(s,c)+']'
            }
            else
            if (s.constructor == Object) {
                c.saykey = 1;
                $ks = Object.keys({});
                !ks.length and return '{}'
                ks = ['t','y','c','sc']; # idealism
                $type = s.y ? s.y == s ? 'A' : 'C' : 'd';
                type == 'A' && s.1 == s and type = 'J'
                if (type != 'd') {
                    type == A and lum -= 1
                    lum < 2 and return '{'+type+':'+s.t+'}'
                    type == C and return s.t+' '+s.y.cv+li(s.c,c)+'%'+li(s.sc,c)
                    c.ks = ks;
                    return li(s,c)
                }
                else {
                    return li(s,c)
                }
                
            }
            else
            if (s.constructor && 0) {
            
            }
            else {
                return "?"+s+"?"
            }
        };  
        
        # #c get A:n
        
        console.log(s,C);
        
        $limit = 10;
        $gp
        
        $e = C;
        C = A&s = G&Cye,["Typ"];
        c&e = e;
        
        #A.t = 'e';
        #4s&N.push(A);
        
    
ElTakeNote: | # event that-ers
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h

