NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    #   into an A:n for the J/place as C:Wthing with c&e={act} A:n + A:e
    #   quick respondo can be via ec&doi set from Y.b.eintro
    gev: %acgt:ev J
        ev ||= event;
        ev.target.tagName == 'H2' and return
        # locate A:top of A:4
        if (!ev.target) {
            A&event_A and A = A&event_A;
        }
        else {
            $S = ev.target;
            while (S && !(S.A && S.A.4)) {
                S = S.parentNode;
            }
            # must be clicking <body>, <html>
            #   or something above .A element space
            !S and return
            $Four = S.A.4;
            A = Four.up;
            !A and throw "out of cone";
            A&event_A = A;
        }
        if (A&event_A) {
            A&event_A != A and ~innerA: A.4.t
            A = A&event_A;
        }
        G&Aye,'ev',9,{ev:ev}
    
    # G&e: see j/23 NutJayTo
    
    # G&E: see j/28 NutFactorEase
    #   safe/autovivifying data grabs at c&e
    
    u jc
    n \'of:ev'
    
    # event details gathered, finds Js
    # build a C of elvis
    ev 1: %any
        G&way,'EleVisAn',{},'noop';
        G&way,'EleMento';
    
    # events handled real fast, OR plan for A:n made
    ev 2: %any
        G&way,'EleVisAn';
        T.el and return T.not = 'satisfied ev@2'
    
    # A:n to a found J to go make change happen in
    ev 3: %any
        $n = a&wouldn;
        !n and return
        T.not = 'A:n ev@3'; # stop ev forever
        G&n,n;
        
    #  < ev or e can get lost/pointless/broke and should be helped
    # events may have to pile up to become meaningful?
    # < G&vent for handling various uncertainties in various situations
    ev 4: %any
        a&msg.set("state","no");
    
    
    #c A:n c&e springs into consciousness
    # A:e, tugged along with A:n/Jing every 0.1
    #  may until after 6 for event handlers (1s&ein) to clarify,
    #  or even after 7 for operations on tv
    
    # if some retry-ish thing is happening?
    n \'of:n'
    e 2:
        $e = s;
        $E = e.y.A;
        E && E.t == 'ev' and E = null;
        if (!E) {
            # spawn A:e after A:n@13, inherits A.1 = s&J
            E = e.y.A = G&Aye,'e',2,{s:e};
            A.e = E;
            E.n = A;
            # wake us
            Es&N ||= [];
            Es&N.push(A);
        }
        E.n != A and throw "A:e.n not us", E, A
        A.e != E and throw "A:n.e not elvis", A, E
        # happens in steps in sync with n wakeness
        G&thro,A.e,2
    0 &&
    e 3:
        G&thro,A.e,3
    e 4:
        G&thro,A.e,4
    e 5:
        G&thro,A.e,5
    0 &&
    e 6:
        G&thro,A.e,6
    0 &&
    e 7:
        G&thro,A.e,7
    e 8:
        G&thro,A.e,8;
        A.e.cv < 0.8 and ~>17 lost e: A.e.cv+'/'+A.cv+'@'+C.t, 4s&ki(c&e)
    
    n \'of:e'
    # look through handlers, or wait for clearer time...
    # J usu define api/event handlers in the first section of the pin
    #  then in the call that makes a section heading we have a chance to complete
    #  may need to be oscillated fully to process the request
    #  may want to wait for a quiet time, if it's a human
    einlookup 1: %any
        T.once = 1;
        $Js = c&Jat ? c&Jat.slice() : [A.1];
        $anein = 0;
        Js.reverse();
        each iJ Js {
            # last resort/undelivered
            J == J.4 and break
            # if near attention should try to create the handler
            #J == J.3
            # A.1 will not be correct...
            # < isolate reaction down this Jath
            #J != J.3
            # otherwise, the usual...
            
        $ein = Js&ein;
        !ein and continue
        anein = 1
        #!ein and return T.not = 2;
        
        A&idea = ein[C.t];
        if (!A&idea) {
            $parts = C.t.split('+');
            each it parts {
                A&idea = ein[t];
            }
        }
        typeof A&idea == 'function' and A&idea = {i:A&idea}
        
        $id = A&idea ? 4s&ki(A&idea) : 'no ein';
        ~>86 elvis: ki(J,2), C.t, id
        # first/deepest one
        A&idea and break
        
        }
        !anein and return T.not = 2;
        !A&idea and return T.not = 1;
        
    
    #c e/edo
    # liable to throw, thro repeating D would be annoying?
    # should only have one way to do,
    #   posit doing this way as a dome, so it can be onced?
    # J must be ready (or not)
    edo 4: %any
        T.once = 1;
        T.el and return
        # some vars
        $ar = {};
        ar.M = 1s&M = 1s&M || [];
        $e = ar.e = C;
        ec&s and ar.s = ec&s;
        C = A.n.c.s;
        # two ways about it
        each way,pin A&idea {
            if (way == 'w') {
                G&way,pin,ar;
            }
            else
            if (way == 'i') {
                $l = G&arfgunc,pin;
                # s = e.c.s? good for NutText/typing which 'says'
                l == 'A,C,G,T,s' and pin(A,C,G,T,ar.s)
                elsif (l == 'A,C,G,T,s,c') {
                    # < Ec is the most pointed to thing... see Ch
                    $c = G&E:'hC -1';
                    pin(A,C,G,T,ar.s,c)
                }
                else {
                    throw "Buildargs: "+l, s
                }
            }
            else {
                throw "idea not i/w", A&idea
            }
        }
        # can repeat: e.t -> A&idea -> here ^
        T.seek and return delete T.once;
        T.el = 1;
    
    # satisfaction?
    # T.el == handled & want to awake
    # T.ok == handled & no change/J6 can sleep
    edone 5: %any
        if (T.ok) {
            A.cv = 0.9;
            if (A.n.cv <= 0.6) {
                ~Can avoid J6ing:
                T.not = 1;
                $oT = nA&T;
                oT.not = 1;
                # put a 5 block e doing id
                oT.leaves = 'elvis';
                return;
            }
            ~Could avoid J6 next time:
        }
        T.not = 2;
    
    music 8: %any
        # yep
    
EleMento: | # find A/J/C as tossed in the elements
    # < guts-tuck into A:ev
    # A may != the first A found up from event.target
    
        s = c&ev = A&ev;
        C.y.A = A;
        
        # one A:ev per event SEMI-GONE
        # < unifying all A:e-ings here
        #   from one event triggering lots of handlers
        #     as event.afterHandling or 1ms async
        if (4s&last_event == s) {
            # failing to off() when you on() events used to
            G&Jinthe,'reset_event_listeners';
            T.not = 1;
            return ~toomanyevents
        }
        4s&last_event = s
        
        # allow 3 exceptions to 10Hz
        G&jam,10,3 and return T.not = 1;
        
        C.t = c&type = s.type;
        s&emotion = 3;
        
        # get info from event
        
        c&which = s.which;
        if (s.keyCode) {
            c&which != s.keyCode and ~differ which to keycode: s.which, s.keyCode
            
            # ignore shift, control, alt
            c&which >= 16 && c&which <= 18 and return

            c&key = String.fromCharCode(s.keyCode);
            c&which == 27 and c&key = 'esc'
            c&which == 32 and c&key = 'space'
            c&key == "\r" and c&key = "\n"
        }
        
        $mo = c&mode = {};
        s.shiftKey and mo.S = 1;
        s.ctrlKey and mo.C = 1;
        s.altKey and mo.A = 1;
        s.metaKey and mo.M = 1;
        !Object.keys(mo).length and delete c&mode;
        $spec = Object.keys(mo);
        spec = spec.join('+');
        spec and a&spec = spec;
        
        # combine C.t = A, S+F, C+click, M+2+click
        # for typing into it with e.t...
        if (c&type == 'keydown' || c&type == 'click') {
            if (c&type == 'click') {
                # left 'click', middle '2+click'
                c&which != 1 and C.t = c&which+'+click';
                delete c&which;
            }
            if (c&type == 'keydown') {
                c&key.match(/[a-z0-9]/i) and C.t = c&key; delete c&which;
            }
        }
        
        if (c&type == 'click' && s.clientX) {
            # relative to page? no pixel 0?
            c&coord = s.clientX +','+ s.clientY;
            # pageXOffset etc?
        }
        
        $tag = $(s.target);
        # lots of things have a val,
        # only <input> or codemirror can input an empty string
        if (tag[0].constructor != Window && (
            tag.val && tag.val().length
            || tag[0].nodeName == "INPUT")) {
            $k = c&s != null ? 'val' : 's';
            C.c[k] = tag.val();
            C.t = 'input+'+C.t;
        }
        
        # C should now be interesting
        C.t == c&type and delete c&type;
        
        #c TODO s (event) already has a nice s.path (?)
        # start looking at target
        if (s.target) {
            $S = s.target;
            # anything with a t/cv should make the usual us&p path
            # path after the last A outwards, for the last A.1 to know
            $m = c&path_yon = [];
            !S.A and m.push(S);
            while (!S.A) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
            !m.length and delete c&path_yon
            S.A and c&AS = S;
        }
        
        # if A found, start proper list from there up
        if (c&AS) {
            $S = c&AS;
            S.A.noelvis and return
            delete c&AS;
            # path through all elements on/between A, for A.3 to -> A.1
            #   may be some elements S without .A?
            # makes it to <body> who .A = A:top, window.A, A.1 == A.4
            $m = c&path = [S];
            while (S && !(S.A && S.A.1 == A.4)) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S);
                S.A && S.A.noelvis and return
            }
        }
        
        # path is elements, who might .A.1 = J
        if (c&path) {
            # reduce to unique Js
            $m = c&Jat = [];
            $la;
            each iS c&path {
                !S.A and continue
                $J = S.A.1;
                J == la and continue
                m.push(J)
                la = J;
            }
            !m.length and delete c&Jat
            !c&Jat and ~>77 No Js, not even 4: ki(C)
            
            #m[0] && !m[0].A and ~>77 NoA on first path: ki(m), ki(c&path_yon)
            #m[0] && m[0].A && m[0].A.1 != A.4 and ~>77 Didnt find 4 up: C
            
            $S = c&path.slice(-1)[0];
            $Y = S.A;
            !Y and ~last had no A:
            $giveth = Y.b && Y.b.eintro || S.eintro;
            if (giveth) {
                #~asking: ki(Y)
                giveth(C);
            }
            elsif (c&path_yon) {
                each in c&path_yon {
                    n.eintro && n.eintro(C);
                }
            }
        }
        
        # Jat path may have shape, A.2 != A.1.2, who knows
        
EleVisAn: | # event handler -> n someone
        ki = 4s&ki;
        
        $e = C;
        # group meanings
        e.t == 'input+esc' and e.t = 'says'
        a&spec and C.t = a&spec+'+'+C.t
        
        # reorder hash, put lesser info later
        $bor = ['ev','coord'];
        each it bor {
            $v = e.c[t];
            v == null and continue;
            delete e.c[t];
            e.c[t] = v;
        }
        
        # simplify keypress
        $norm = new RegExp("^[A-Z] A;ev type:keydown,key:[A-Z],path:\\[body],Jat:\\[J:"+A.4.t+"],ev:\\{\\*\\d+} % emotion:3$")
        $el = ki(e);
        el.match(norm) and el = e.t;
        
        e.t == 'keydown' && ec&which >=16 && ec&which <= 18 and return T.not = 1;
        
        a&msg =
        ~>8 ev: '>15:state', el
        e.y.ev = A;
        
        # from NutText,
        # unless wanting to watch typing as it happens,
        # throws out events like click, keypress other than esc/enter
        if (c&noisyinput) {
            if (c&type != 'blur' && c&key != 'esc' && c&key != "\n") {
                a&msg.set("state","noise");
                return T.not = 1;
            }
            elsif (typeof c&noisyinput == 'function') {
                c&noisyinput();
            }
        }
        
        # satisfaction with the call/elvising?
        T.el = 1;
        
        # body genera
        $har = {e:e};
        if (ec&path) {
            if (ec&path.length == 1) {
                ec&key == 'A' and c&doi = 'Jin'
                ec&key == 'C' and c&doi = 'Typ'
                ec&key == 'G' and c&doi = 'begoin'
                ec&key == 'T' and c&doi = 'Tri'
            }
            if (ec&key == "\n") {
                return [1,2,3,4,5].filter(&{
                    ~>78 space:
                });
            }
            # look at the last C
            $y = ec&path.slice(-1)[0];
            $K = y && y.A && y.A.c.s
            if (K) {
                Ks&doi and c&doi = Ks&doi;
                Ks&dow and c&dow = Ks&dow;
                if (Ks&doe) {
                    C.t = Ks&doe == '1' ? K.t : Ks&doe;
                    a&msg.set('state','doe:'+C.t);
                }
                har.c = K;
            }
        }
        
        # formulate the A:n from what is pointed to
        $do_Jing = &{
            a&msg.set("state","Jing");
            $C = A&s;
            !C || !c&Jat and return;

            $Js = c&Jat.slice();
            $W = [];
            each iJ Js {
                J.1 == J.3 and W.push(J);
            }
            W[0] == A.4 and W.shift();

            W.length > 1 and ~>9 Wnesting: ki(W)
            # Four listens to everything you say,
            # makes art as a way to store entropy
            !W.length and return
            W = W[0];

            a&wouldn = [W.t,'W',{e:e}];
            #A.t = 'e';
            #
        };
        
        $async_Tcheck = &s{
            T.el and return;
            do_Jing();
            A.cv = 0.3;
            delete T.not;
            4s&N.push(A);
            # messes with cv: G&TuneTimeMachine,"Telnoanswer"
        };
        # could also be s&dosi
        c&doi and c&did = 'i'; G&h,c&doi,e
        else
        c&dow and c&did = 'w'; ~dow: c&dow; G&waylay,c&dow,har,async_Tcheck
        else {
            # become unsatisfied, seek handling in J
            delete T.el;
        }
        T.el and return
        $F;
        each iJ c&Jat {
            J.1 == J.4 and F = J
        }
        # keys not sure which G to go to
        $ela = F && Fc&elvrupto || 4s&elvrupto || Gs&elvrupto || window.elvrupto;
        if (ela) {
            # different kind of stylehouse takes it
            T.not = "satistylehoused: "+(F&&F.t||"somehow");
            ela(A,C,G,T);
            return
        }
        do_Jing();
        
    
NutFactorEase: | # make data moves (and e tools)
    u j
    n \'of:eye'
    
    # Extract from the request,
    #  one-string G&F-like spec, naming the first thing:
    #   may autovivify aspects of e (get_hC)
    # TES should we use e = A.e.c.s.c.e or C.c.e?
    E:
        $d = s.split(' ');
        s = d.shift();
        $e = c&e;
        !e and throw "Where's e?"
        
        s == 'hC' and s = ec&hC = ec&hC || G&get_hC,e;
        else { throw "What data? "+s }
        
        !d.length and return s
        d = d.join(' ');
        return G&F,s,d
    
    # autovivify aspects of e
    #    hC is the point as found in 1s&ss&top,
    #      from t/cvs from ec&path (elements with .A)
    get_hC: %acgt:e
        !1s&s and throw "Never osc'd", A.1;
        $r = 1s&s.sc.top;
        
        $path = G&F:ec&path,'s.A.c.s since yA1 == A1';
        
        $tv = r.y.tv;
        ec&hC = [];
        each iD path {
            # climbing s&Js&ss&top
            !tv && Dc&root and tv = D.y.tv || D.y.OC.y.tv; continue
            if (tv && tv[D.t] && tv[D.t][D.y.cv]) {
                $o = tv[D.t][D.y.cv];
                ec&hC.push(o);
                tv = o.y.tv;
            }
            else {
                $res = tv ? "404" : "notv";
                ~>96 point: res, i+' in:', ki(path,2)
                break; #throw "Broken pointer"
            }
        }
        return ec&hC
    
    #c F FactorEase: grep/map, know structure
    # s:data, d:instruction
    # also wants to apply a schema, ignore or freak-note things
    # climb down indexes (like each/G&ind)
    F: %acgt:s d
        $m;
        $p = &r{
            m = d.match(r);
            !m and return
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        $dstart = d;
        $v;
        
        # all Array of items, assume the spec also de-arrays it
        s.constructor == Object and s = [s];
        
        # calling it C means grep for
        # < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            $typology = m[0];
            $nk = m[1];
            $gk = m[2];
            s = s.filter(&s{ 
                s && s[nk] && s[nk][gk] != null and v = s[nk][gk]; return 1
            });
        }
        
        # calling it s means grep for and move to
        # items replace with something that must be true
        if (p(/^(s\.A\.c\.s) ?/)) {
            s = s.map(&s{ return s.A && s.A.c.s }).filter(&s{ return s });
        }
        
        # remove items until...
        if (p(/^(since) (yA1) (==) (A1) ?/)) {
            while (s.length) {
                $z = s[0]; # ]
                z.y.A && z.y.A && z.y.A.1 == A.1 and break;
                s.shift();
            }
        }
        
        # Array of items -> item
        
        # last one
        if (p(/^-1 ?/)) {
            s = s.slice(-1)[0]
        }
        
        # end of being item as collection of properties
        
        # peel:a:b:c given v=e:r:t:y gives {a:e,b:r,c:'t:y'}
        if (p(/^peel:([\w:\@]+) ?/)) {
            !v and throw "no value", dstart
            # ref v could be done, eg C t:cs the center,
            #   unless keys appear in sc
            typeof v != 'string' and throw "value not string", dstart
            $ar = {};
            $spec = m[0].split(':');
            $vars = v.split(':');
            while (spec.length) {
                $k = spec.shift();
                $array = k.slice(0,1) == '@';
                array and k = k.replace(/^\@/,'');
                ar[k] = spec.length ? vars.shift() :
                    array ? vars : vars.join(':');
            }
            s = ar
        }
        
        d.length and throw "FE spec leftover: "+d
        
        return s
    

