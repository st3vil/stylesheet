NutEl: | # be in
    u j
    n \'of:eye'
    # process any event
    # into an A:e, approach J/world with A:n?
    # J has quick ev respondo?
    gev: %acgt:ev J
        ev ||= event;
        G&Aye,'ev',9,{ev:ev}
        
    # ephemeral n without:
    # - clusping the mind, or
    # - attaching to this ground (usu for c.e)
    # < e could be reliabilitied by grounding and osc work
    # usually n \'of:mo' -> C.c.of=mo
    # but for e it A.c.of=mo, for eg nomem
    
    # babs
    # e other: thing: what          -> G&e,['other'],['thing','','what']
    #  then as n [other=>W=>{e:['thing','','what']}]
    # with A&nogro = 1
    
    # e {cstuff:4} this: stiil   -> G&e,{nAcstuff:4},['this','','stiil']
    # so can not put 
    # e C, this: -pi24             C, ['this',0.24,{pi:'this'}]
    # shows C this
    
    #  as an intention for process it can be slowed down when n same
    #  page for every elvising going on wanted,
    #  the script of its activity zoomintoable
    # the sudden datatype
    e: %acgt:c s
        !c || !s and throw "e carefully"
        C = c;
        c = {};
        C.constructor == Array and C = G&Cye,C
        s.constructor == Array and s = G&Cye,s
        # if first C is {} but not C it is A.c,
        # and second becomes first, so is like n with A.c spec
        !(C.y && C.c && C.sc) and c = C; C = s; s = null;
        
        # put second C on first as c&e
        s and c&e = s
        
        c.nogro = 1;
        c.s = C;
        
        $et = ''
        s and et = s.t;
        
        ~e: C.t, et
        
        G&Aye,'n',8,c;
        
        C

    u jc
    n \'of:ev'
    
    # that an event must emerge
    # and finds its A.12223 (in reverse, path, and what to W)
    # to be able to
    ev 1: %any
        G&waylay,'EleOne';
    
    n \'of:e'
    # usu has an n of this J going on to make change happen in
    # or if coming from event rather than
    e 1:
        ~e: C.t, s.t, A&sip
    
    # A:n C.c.e = e, start e.y.A = A:e
    e 2: %of:n
        ~n-e: C.t, s.t, A&sip
        s.y.A ||= G&Aye,'e',2,{s:s};
        A.e = s.y.A;
        s.y.A.n = A;
    
    # once you need the A.n to be awake, you'll have to create it...
    0 &&
    elev:
        var cm = s;
        var d = {};
        G&entag,d,$(A.on);
        A.b.jus = d.code = cm.getValue();
        d.dig = $(A.on).attr('dig');
        console.log("elev",d);
        #G&socking,d;
    
    
    
EleOne: |        # #c ki
    #
        # ki leaves through here for singular squish factory,
        # optional c.keys
        $li = &s,c,k{
            $ks = c.ks;
            $c = $.extend({},c);
            k and c.k = k; s = s[k];
            delete c.ks;
            $M = [];
            $joiner = ',';
            if (s && typeof s == 'object') {
                if (!ks) {
                    ks = [];
                    each kv s {
                        ks.push(k);
                    }
                }
                $elem = 1;
                each ik ks {
                    v = s[k]; # ]
                    $d = $.extend({},c);
                    d.d += 1;
                    d.up = c;
                    d.k = k;
                    $ke = '';
                    c.saykey and ke = k+':';
                    
                    c.k == 'y' and d.d += 1;
                    $sa = ki(v,d);
                    
                    elem && sa.drawn != 'html' and elem = 0;
                    if (elem && sa.drawn == 'html') {
                        # shorten paths in (or out)
                        if (elem != 1) {
                            if (!(v.parentNode == elem
                                || elem.parentNode == v)) {
                                elem = 0
                            }
                        }
                        elem and elem = v;
                    }
                    if (sa.drawn == 'type:t') {
                        # its own type part of the key
                        k.match(sa.type+'$') and ke = k+';'; sa = v.t
                        c.type == 'a' and sa.s = sa.s.replace(/^{|}$/g,'');
                        
                    }
                    M.push([ke,sa]);
                }
                if (elem) {
                    joiner = '^';
                    each im M {
                        sa = m[1];
                        sa.s = sa.s.replace(/^\^|\^$/g,'');
                        
                    }
                }
                $N = [];
                each im M {
                    N.push(m[0]+m[1]);
                }
                M = N;
            }
            else {
                $d = $.extend({},c);
                d.d += 1;
                d.up = c;
                M.push(ki(s,d));
            }
            $m = M.join(joiner);
            $strlim = c.lum * 20 + 5;
            m.length > strlim + 10 and m = m.substr(0,strlim)+'..*'+M.length
            return m
        };
        $ki = &s,c{
            c ||= {dl:4};
            c.d ||= 1;
            c.d > 15 and throw "large ki";
            c.lum = c.dl - c.d;
            delete c.saykey;
            # turn c into string object, add knowing how it is drawn
            $es = &s,drawn{
                c.s = s;
                drawn and c.drawn = drawn;
                c.toString = &{ return this.s };
                return c
            };
            
            
            if (s == null) {
                return "n*ll"
            }
            else
            if (typeof s == 'number' || typeof s == 'string') {
                s+''.match(/^\w+$/) and return s;
                return "'"+s+"'";
            }
            else
            if (s.constructor == Array) {
                c.type = 'a';
                !s.length and return '[]'
                c.lum < 2 and return '[*'+s.length+']'
                c.lum < 3 and return '['+li(s,c)+']'
                # '
            }
            else
            if (s.constructor == Object) {
                c.saykey = 1;
                $ks = Object.keys(s);
                !ks.length and return '{}'
                $type = s.y ? s.y == s ? 'A' : 'C' : 'd';
                type == 'A' && s.1 == s and type = 'J'
                c.type = type;
                if (type != 'd') {
                    type == A and c.lum -= 1
                    c.lum < 2 and return es('{'+type+':'+s.t+'}','type:t')
                    if (type == 'C') {
                        return li(s,c,'t')+' '+li(s,c,'y')
                            +' '+li(s,c,'c')+' % '
                            +li(s,c,'sc')
                    }
                    c.ks = ['t','y','c','sc']; # idealism
                    return '{'+li(s,c)+'}'
                }
                else {
                    c.lum < 3 and return '{*'+ks.length+'}'
                    return '{'+li(s,c)+'}'
                }
            }
            else
            if (s.constructor+''.match(/^function HTML/)) {
                $t = s.getAttribute && s.getAttribute('t');
                t ||= s.tagName && s.tagName.toLowerCase();
                t ||= s;
                return es('^'+t+"^",'html')
                
            }
            else {
                return "?"+s+"?"
            }
        };  
        
    #c find A, find J, find C
    # A may != the first A found up from event.target
        s = c&ev = A&ev;
        
        C.t = c&type = s.type;
        s&emotion = 3;
        
        # get info from event
        
        c&which = s.which;
        if (s.keyCode) {
            c&which != s.keyCode and ~differ which to keycode: s.which, s.keyCode
            
            # ignore shift, control, alt
            c&which >= 16 && c&which <= 18 and return

            c&key = String.fromCharCode(s.keyCode);
            c&which == 27 and c&key = 'esc'
        }
        
        $mo = c&mode = {};
        s.shiftKey and mo.S = 1;
        s.ctrlKey and mo.C = 1;
        s.altKey and mo.A = 1;
        s.metaKey and mo.M = 1;
        !Object.keys(mo).length and delete c&mode;
        $spec = Object.keys(mo);
        spec = spec.join('+');
        
        # combine C.t = A, S+F, C+click, M+2+click
        # for typing into it with e.t...
        if (c&type == 'keydown' || c&type == 'click') {
            if (c&type == 'click') {
                # left 'click', middle '2+click'
                c&which != 1 and C.t = c&which+'+click';
                delete c&which;
            }
            if (c&type == 'keydown') {
                c&key.match(/[a-z0-9]/i) and C.t = c&key; delete c&which;
            }
            spec and C.t = spec+'+'+C.t
        }
        else {
            spec and c&spec = spec; # make into us&S, us&C etc?
        }
        
        
        
        # start looking at target
        if (s.target) {
            $S = s.target;
            # anything with a t/cv should make the usual us&p path
            # path after the last A outwards, for the last A.1 to know
            $m = c&path_yon = [];
            !S.A and m.push(S);
            while (!S.A) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
            !m.length and delete c&path_yon
            S.A and c&AS = S
        }
        
        # if A found, start proper list from there up
        if (c&AS) {
            $S = c&AS;
            delete c&AS;
            # path through all elements on/between A, for A.3 to -> A.1
            #   may be some elements S without .A?
            # makes it to <body> who .A = A:top, window.A, A.1 == A.4
            $m = c&path = [S];
            while (S && !(S.A && S.A.1 == A.4)) {
                !S.parentNode and break
                S = S.parentNode;
                m.unshift(S)
            }
        }
        
        # path is elements, who might .A.1 = J
        if (c&path) {
            # reduce to unique Js
            $m = c&Jat = [];
            $la;
            each iS c&path {
                !S.A and continue
                $J = S.A.1;
                J == la and continue
                m.push(J)
            }
            !m.length and delete c&Jat
            !c&Jat and ~>77 No Js, not even 4: ki(C)
            
            #m[0] && !m[0].A and ~>77 NoA on first path: ki(m), ki(c&path_yon)
            #m[0] && m[0].A && m[0].A.1 != A.4 and ~>77 Didnt find 4 up: C
            
            $S = c&path.slice(-1)[0];
            $Y = S.A;
            !Y and ~last had no A:
            $giveth = Y.b && Y.b.eintro;
            if (giveth) {
                ~asking: ki(Y)
                giveth(C);
            }
        }
        
        # Jat path may have shape, A.2 != A.1.2, who knows
        
        # C should now be interesting
        C.t == c&type and delete c&type;
        
        $say = ['J:'];
        each iJ c&Jat {
            say.push(J.t)
        }
        say.push('E:');
        each iS c&path {
            say.push(S.nodeName)
        }
        
        say = say.join(" ");
        ~ever: s.type, spec, say
        
        # #c get A:n
        
        
        ~>48 elvis: ki(C)
        console.log(s,C);
        
        $limit = 10;
        $gp
        
        $e = C;
        C = A&s = G&Cye,["Typ"];
        c&e = e;
        
        #A.t = 'e';
        #4s&N.push(A);
        
    
ElTakeNote: | # event that-ers
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h

