Taste: | # waylay self TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
    my $i = Js&bowls++ + 1;
    Jc&tape = 'W';
    S
    $i += 0.2 if $i == 2;
    n Figuration=>1=>"Luxe Elan",{fs=>4*$i}
    
    my $cb = &{ 4s&toy->({to=>[C.t]}); };
    $i < 3 &&
    G&time,1,$cb;
Thaste: | # several selves TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
    my $i = Js&bowls++ + 1;
    Jc&tape = 'W';
    S
    my $e = &{
        my $t = shift;
        push @_, '' if @_ < 2; # not W
        G&e:ThasteYe=>[$t=>''=>{s=>G&Ct,[@_] }];
    };
    if ($i == 1) {
        $e->(folk=>"Sandy Bull");
        $e->(folk=>"Swamp Doctor"=>''=>{}=>{xu=>6});
        $e->(folk=>"Plocato");
        $e->(folk=>"Synter"=>''=>{}=>{xu=>7});
        $e->(folk=>"Steve"=>''=>{}=>{xu=>8});
    }
    if ($i == 2) {
        $e->(folk=>"Telaviv"=>{}=>{xu=>6});
        $e->(defolk=>"Plocato");
    }
    if ($i == 3) {
        $e->(folk=>"Masslve"=>{}=>{xu=>7});
    }
    n ThasteYe=>V
    my @res = G&op,'pi:thaste';
    y.n = 3;
    m _.t=>''=>_.t=>'fs:'.int(9+_s&xu) for @res;
    
    
    my $cb = &{ 4s&toy->({to=>[C.t]}); };
    $i < 4 &&
    G&time,1,$cb;
ThasteYe: |
    Jc&tape = 'W';
    Js&ein.t.folk.sMJ = &sMJ{
        ss&order = Js&order++;
        m $s
    };
    Js&ein.t.defolk.sMJ = &sMJ{
        @$M = grep {_.t ne s.t} @$M;
    };
    S
    y.res = 100;
    m _.t=>-thaste for sort { as&xu <=> bs&xu || (-1 * as&order <=> bs&order) } @{Js&M};
pi/thaste: |
    my $huh = sum map {ord $_} split '', C.t;
    $huh /= 10 until $huh < 9;
    $huh = int $huh;
    n t=>1=>C.t=>"hs:${huh}76"
Tofing: | # use u/n TTTTTTTTTTTTTT
    Jc&save = 1;
    u TofingU
    u TofingUlar
    S
    n $_=>''=>G&lowca,$_ for 3,5,6;
    n "using Ular goverup"=>3=> G&goverup,4  
TofingU: |
    man:
        all this is figuring
    u i
    lowca:
        my $v = $s * 3;
        G&variate:$v,"Blind Lemons";
    u a
    molate 11: %of:mo
        push @{1s&singing||=[]}, $C;
    u i
    goverup:
        $s * 2
    
TofingUlar: |
    u i
    goverup:
        $s * 5
    variate:
        my @m;
        my @ze = (map{split'',$_}$s,@Me);
        while (@ze) {
            push @m, shift @ze;
            push @m, pop @ze if @ze;
        }
        join "-",@m;
    
    
TookPersonel: |
    1c&GenMeta = 1;
    1c&save = 1;
    #Rw Tiot;
    #Rw GiveTime;
    S
    u i
    merry:
        # band
    oph:
        # guitars
    n TookPre
    lang:
        # planing
    sayre "Blankning you!";
    G.ydrop = 1;
    u ''
    my $i =
    n somehi=>4=>'hi'
    is&z = [
        G&e,TookMore=>'W'
    ];
    
TookPre: |
    1c&GenMeta = 1;
    1c&save = 1;
    u i
    vang:
        # gal
    oph:
        # making
    lang:
        # twisting
TookMore: |
    1c&GenMeta = 1;
    1c&save = 1;
    u i
    lad:
        G&le
    
Volup: |
    Jc&tape = 1;
    Rw Tiot;
    Js&ein.pi.see.sMJ = &sMJje{
        1 && saygr "J.t: Adding $s";
        m e.t=>''=>{s=>$s}
    };    
    S
    
    n seeing=>-od_3=>{dl=>4,s=>Js&M}
GenMeta: | # explicit grouping of universals we wanty to sum together from children
    # meta: $type (bunch/of/qualia)* = sum-able value
    
    # 
    
    my $mt = {}; # types
    # meta self
    my $meta = {};
    T.has ||= {};
    each type,qua T.has {
        $mt.>$type = 1;
        if ($type eq 'way') {
            meta.way = $qua
        }
        else {
            # Tsuck for live Scuttle addition of any other T.has
            die "Has Thas $type: ".ki $qua;
        }
    }
    
    # meta others comes from any J's meta,
    # with their location first, which gets squished
    my $M = []; # with universal types
    for my $K (@{os&Cora}) {
        my $v = K.y.C; # pre-K squish
        my $J = vs&J || next;
        # get path to them including this 9,
        # want to include things that matter as input not specified in output?
        my @S = my $S = $v;
        while ($S = S.y.up) {
            push @S, $S;
        }
        my $p = join "/",map{_.t} reverse @S;
        
        # Jpage
        my $s = Js&s;
        my $meta = ss&meta || next;
        for my $type (keys %$meta) {
            $mt.>$type = 1;
        }

        m v.t=>''=>{path=>$p},$meta
    }
    
    # s&meta = meta self + others
    my @oth;
    s&meta = {};
    each type,v $mt {
        my $xo = $meta.>$type;
        my $N = [grep{ exists _.sc.>$type } @$M];
        for my $v (@$N) {
            my $ox = v.sc.>$type;
            # Scuttle
            if ($type eq 'way') {
                each pin,dige,freq $ox {
                    $xo.>$pin.>$dige += $freq
                }}
            }
            else {
                die "Has othhas $type: ".ki $xo;
            }
            push @oth, saybl "A.1.t: vc&path adds $type: ".ki($xo)."  +  ".ki$ox;
        }
        s&meta.>$type = $xo;
    }
    
    G&e:Volup=>["Root of ".G&sn =>-see=>{s=>$C}];
    

