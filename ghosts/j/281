Clalia: | # drag n learn
    G&heading;
    ys&ab = '1';
    ys&height = '30%';
    ys&width = '60%';
    A.noelvis = 1;
    # to make html+javascript that lives a life of its own
    
    $t = window.t = 3s&t = {};
    
    n Classes -Pupula $s:<<'' %ab:1,width:100%,height:100%
    Engineering	4000
      seeing	439	%st:being,pow:24
        c s: |
          Lovely and sighted.
          Takes hold.
        Riddiford	%day:1,time:900-1040
        Riddiford	%day:3,time:1300-1450
        Taxiderm	%day:2,time:1300-1340
      triangle	469	%st:geometrica,pow:12
        c s: |
          Bring togs.
        Riddiford	%day:4,time:1120-1340
        Riddiford	%day:3,time:1400-1550
        Taxiderm	%day:2,time:1500-1640
      weld	468	%st:geometrica,pow:9
        c s: |
          Ceramic?
        Riddiford	%day:1,time:900-1040
        Riddiford	%day:3,time:1300-1450
        Taxiderm	%day:2,time:1300-1340
    Art	8000
      weld	868	%st:enjoyment,pow:9
        c s: |
          But with plenty of slop.
        Riddiford	%day:1,time:900-1040
    
    t.emplate = <<'';
    <div id="bits"> Classes </div>
    <div id="week"> Week </div> 
    <div id="info"> Info </div>
    
    t.days = 5;
    t.fracday = &s{
        $m = (''+s).match(/^(\d?\d)(\d\d)$/);
        !m and throw "not a time: "+s
        return (m[1] * (1/24)) + (m[2] * (1/1440))
    };
    t.daystart = t.fracday('0900');
    t.dayend = t.fracday('1700');
    t.Start = &{
        $('#bits').replaceWith(t.emplate);
        #$('table td').css('vertical-align','top');
        
        # classes
        $cl = $('#bits').empty()
            .css('position','absolute')
            .css('width','30%')
            .css('height','100%');
        cl = $('<ul>').appendTo(cl)
        each ic t.group {
            $('<li>').appendTo(cl)
                .attr('id',c.id).text(c.t)
                .on('click',t.togGroup);
        }
        
        # week
        $we = $('#week').empty()
            .css('position','absolute')
            .css('left','30%')
            .css('width','40%')
            .css('height','100%');
        $width = 100 / t.days;
        $side = 0;
        for (var day = 1; day <= t.days; day++) {
            $d = $('<div id="day'+day+'">')
                .css('width',width+'%')
                .css('height','100%')
                .css('position','absolute')
                .css('background','rgba('+(day*30)+',120,120,0.3)');
            side and d.css('left', side+'%')
            we.append(d);
            side += width;
        }
        
        # info
        $we = $('#info').empty()
            .css('position','absolute')
            .css('white-space','pre')
            .css('left','70%')
            .css('width','40%')
            .css('height','100%');
        we.css('background','rgba(120,40,40,0.3)');
        we.text('Click on a class');
    };
    #c tog grasp time
    t.togGroup = &{
        $g = t.group[this.id];
        !g and return;
        $cl = $(this);
        if (cl.attr('ope')) {
            cl.attr('ope','');
            cl.children().remove();
            return;
        }
        cl.attr('ope',1);
        cl = $('<ul>').appendTo(cl)
        each ic g.z {
            $('<li>').appendTo(cl)
                .attr('id',c.id).text(c.t)
                .on('click',t.graspClass);
        }
    };
    t.graspClass = &e{
        e.stopPropagation();
        $cla = t.class[this.id];
        !cla and return
        $te = [];
        cla.t and te.push(cla.t)
        # Placed $attime  or Placing
        cla.st and te.push("St: "+cla.st)
        cla.pow and te.push("Pow: "+cla.pow)
        cla.desc and te.push(cla.desc)
        cla.z and te.push(ki(cla.z,5))
        te.length and $('#info').text(te.join("\n\n"));
        # plot
        $('#week .potential').remove();
        each ic cla.z {
            $day = $('#week #day'+c.day);
            $time = c.time.split('-');
            $starts = t.fracday(time[0]) - t.daystart;
            $endures = t.fracday(time[1]) - starts;
            endures < 0.1 and endures = 0.1;
            $plot = $('<span>')
                .css('position','absolute')
                .css('width','100%')
                .css('top',(starts*100)+'%')
                .css('height',(endures*100)+'%')
                .css('background','rgba(176,140,130,0.6)');
            plot.text(starts+' - '+endures);
            plot.attr('class','potential');
            plot.appendTo(day);
            
        }
    };
    
    

    
    G&yl:0.05,&s{ t.Start() };
    
    #
pi/Pupula: |
    $io = G&way,'iooia';
    ys&id = 'bits';
    ys&width = '30%';
    
    n t 1 $s:C.t
    
    if (typeof s == 'string') {
        $uni = G&readLines,s;
        # now we have a university using C
        # make a few bits of csv since reality
        $tables = 3s&t;
        $ids = {};
        $everything = [];
        $insert = &type,s{
            $c = ex({},s.sc);
            c.type = type;
            
            s.y.cv != 0.1 and c.id = (s.y.cv+'').replace(/^0\./,'')
            else {
                ids[type] ||= 0;
                c.id = ids[type]++
            }
            
            c.t = s.t;
            sc&s and c.desc = sc&s
            everything.push(c);
            $table = tables[type] ||= {};
            table[c.id] = c;
            return c
        };
        # < io/S at many indent levels... call em ay,by,cy,dy...
        $ta = 3s&tables = {};
        $uni = G&Cye,['uni','','',{z:uni}];
        o $uni/:group/:class/:time
        io.nz().ind(&s,t{
            #debugger;
            ~Aye: t.ark, ki(s,2)
            t.ark == 'uni' and return
            $c = insert(t.ark,s);
            c.z = [];
            $up = t.parenting;
            up and up.z.push(c)
            return c
        });
        everything.map(&c{ c.z && !c.z.length && delete c.z });
        #n thing  $s:eny(tables) %ws:pre,dis:block
        #return
    }
    
    
    
    
Sevo: | # seive o
    $io = G&way,'iooia';
    io.iz = 1;
    G&heading;
    # anything
    n anything 2 s:anyething %fs:300%,blr:3px
    =pod
    
    A is causality cones,     spreading
    C is causing thing,       growing
    G is a receptive ground,  filled
    T is a trouble hoist,     empty
    
    We shall get diff/patch speaking quietly over websockets to the babz,
    eventually getting everything in js and building castles all over.
    
    24 NutThing has:
     h to call a function, looking for t[0]='i', t[1]=name via:
     t looks up a thing (named) or two (named in named)
    24 NutIns began:
     ting looking further (async) for things to push/pull and protocol
    
    the only global, called H(A,C,G,T,[of,t],args[],c,sc)
    so immediately localised along A
    looking for something to do such with
    the such is C-like, so it could have:
      where that particular thing should be (of,t or more fuzzy)
      a push/pull supplied,
        brokered by a protocol/boundary-handler J
        with H gating usage to up-to-dateness,
          entering existing E sidetrack if...
      a melted down compilation one day
    H is a join (or separation) of two pieces
      notions -> actuality
    
    < still coded G&func?
    
    io will have to travel A as well... looking for t, A
    
    =cut
    $me = c&me ||= {};
    me.H = &acgttycs{
        typeof t == 'string' and t = ['i',t]
        typeof y == 'object' and c = {args:y}
        c ||= {};
        $sc = s || {};
        c.push and throw "this thing wants to be this thing"
        c.pull and throw "this thing is wanted"
        # < pull also acquired from looking
        
    };
    me.timestamp = &{ return(new Date).toISOString() };
    G&way,'Soogle',{},'noop';
    G&way,'Packle',{},'noop';
    #$w = G&t,'w','Soogle';
    #debugger;
    me.start = &{
        $Y = G&Aye,'Four';
        A = Y;
        #A.noelvis = 1;
        me.io = io;
        A&me = me;
        A.1 = A.3 = A.4 = A;
        
        4s&NormalI = A.I; # TOGO
        # in favour of random codes upon 4:
        # inits and continues methods on me
        # unco:
        4s&N = [];
        
        G&way,'Soogle';
        G&way,'Packle';
    
        A.on = el;
        el.A = A;
        C = A&s = {t:me.timestamp(),y:{},c:{},sc:{}};
        #$G = {y:{},c:{},sc:{}};
        T = {y:{},c:{},sc:{}};
        
        me.star(A,C,G,T);
    };
    
    
    $el;
    $colour;
    $i = 0;
    $flip = &{
        colour = colour == 'pink' ? 'blue' : 'pink';
        $(el).css('border','2px solid '+colour)
        i++ > 20 and return
        i == 2 and me.start();
        G&yl,(1000/432)*13,&{flip()}
    };
    
    #G&way,'Steev';
    A&shook = &s{
        el = sc&on;
        flip();
        $('body div.v7').remove();
        el =
        $('<div class="v7" style="position:absolute;'
            +'white-space:pre;font-size:70%;'
            +'top:0%;left:55%;height:20%;width:43%">')
        .appendTo('body')[0];
    };
    
    
Soogle: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    4c&fps = 1;
    
    # loop comebacks between attentions
    me.star = &acgt{
        !A.on.ownerDocument.contains(A.on) and return 4s&dead = "Unplugged"
        $me = A&me;
        $starts = G&time;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&fps;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000
        G&yl,frames,&{me.star(Y,C,G,T)};
        
        try { me&starc }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }
        
        $ends = G&time,starts;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    # cast gazet
    me.starc = &acgt{
        $A = G&Aye,'star';
        $g = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        
        # clusp
        4c&pause and return
        
        # already part of some self-reflexive time
        4s&upghost and me&doupghost
        4s&downghost and me&dodownghost
        
        # surJey
        $Y = A;
        4c&elvrupto = &acgt{
            c&Jat[0] != Y.4 and c&Jat.shift();
            Y.4.sc.elvising = C;
            # < push for immediacy
            $l = [];
            each iD c&Jat {
                l.push(D.c.s);
            }
            ~Insideon: ki(l,2)
        };
        
        # any textual output:
        4s&raw = [];
        
        if (A&sip.slice(-1)[0] == 0) {
            me&otherandcontinue;
        }
        
        me&J,'wobulus';
    };
    #c sidetrack
    me.otherandcontinue = &acgt{
        if (4s&log) {
            4s&log = 4s&log.filter(&l{
                return G&time,ls&now > 15
            });
        }
        if (4s&N) {
            4s&N = 4s&N.filter(&Y{
                if (Y.4 && G.DNS[Y.4.t] != Y.4) {
                   #~TheirAnd: ki(Y.4)
                }
                else { return 1 }
            });
        }
    };
    # one ws per A.1, for its t
    me.ws = &acgts{
        A = 1c&ws ||= G&Aye,'ws';
        $ws = A&ws;
        ws && ws.readyState == 1 and return A
        ws = A&ws ||= new WebSocket(
            'ws://'+location.host+'/'+A.1.t);
        ws.onclose = &ev,la{
        };
        ws.onerror = &ev,la{
            debugger;
        };
        ws.onopen = &ev,{
            ws !== A&ws and return ~sockalivedupe: A&ws
            ~connected: ws.url
            A&open and return A&open(ws)
        };
        ws.onmessage = &ev,la{
            4s&dead and return ws.close()
            $s = ev.data;
            if (A&receive) {
                A&receive(s)
            }
            elsif (A&receives) {
                $l = s.split("\n");
                l.slice(-1)[0] == '' and l.pop()
                A&receives(l)
            }
            else {
                throw "unhandled ws", ws.url, s
            }
        }
        return A
    };
    
    
    #c Eighto
    # to draw, onto A.on
    # initially A.4 = div.v7
    # looking for some child to represent C
    # A.on.A.c.s = C
    # leaving it open to elements being rearranged by the user
    
    # s might be an elvis or thing to go wide on
    # s/all the osc together escape linear code
    me.osc = &acgts{
        A&s != C || C.y.A != A and throw "exosc";
        
        # last A
        $Y = 1c&on && 1c&on.A;
        # has a recursive TV receiver
        # for old into new
        # and refs, and .y.C etc moves sourceward
        A&X = {};
        # a list of atoms
        A&ds = [];
        $du = &s,d{
            A&ds.push(d);
            
            $n = s.y.A;
            # yon J has it from here
            if (n && n.1 != A.1) {
                d.nofurther = 1;
                $J = n.1;
                !Jc&on and debugger
                d.J = J;
            }
            
            $bit = d.path.slice(-1)[0];
            
            # pull out pathcase
            d.X ||= A&X;
            $X = d.X = d.X[bit] ||= {};
            X.z ||= [];
            X.z.length and ~dup
            X.z.push(d);
            
            # history at te top
            d.V ||= Y && Yc&X || {};
            # caused by the passed, causing the future
            $V = d.V && d.V[bit] || {};
            # if there was something there
            $b = V && V.z && V.z.shift();
            # only goners remain
            b && !V.z.length and delete d.V[bit]
            # children inherit the parent, can weird:
            # the vision
            d.V = V || {};
            d.b = b;
            
            return ki(s)
        };
        $l = G&ind,C,du,{cbfirst:1};
        #c then, really
        each id A&ds {
            $b = d.b;
            $s = d.s;
            b && b.s == d.s and throw "Crefsame"
            # reuse elements, affect changes
            d.on ||= b && b.on;
            d.on ||= $("<stylehouse>")[0];
            
            # OSC 3, drawing out what is
            
            if (!b) {
                $(d.on).attr('title',s.t+' '+s.y.cv)
            }
            
            if (!b && !3c&oscer) { # on init
                if (d.d > 1) {
                    $(d.on).css('margin-left',(d.d-1)+'em');
                }
                # < go wide and reuse elements moving around
            }
            
            $V = d.V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    d.gone ||= [];
                    d.gone.push(p);
                }
            }
            d.cha = d.gone || !b;
            
            #s.t == 'edges' and debugger
            if (d.J) {
                # be a nothing
                # < still wants some picturing
                $(d.on).css('display','block');
                $J = d.J;
                d.in = Jc&on;
                b && d.in != b.in and d.cha = 1
            }
            elsif (1 && 3c&oscer) {
                !me[3c&oscer] and throw "No me."+3c&oscer
                me[3c&oscer](A,s,G,T,d);
                #s.t == 'edges' and debugger;
            }
            else {
                # gen picture/comparable/muddlable
                $picture = me.picture(s);
                $lot = &n,s{
                    picture += "\n"+ G&intag:'>'+n+' '+s
                }; #}

                
                #lot(85,"Gone: "+ki(i))
                #lot(67,ki(d.path,3));
                d.picture = picture+"\n";
                
                # d.s now vs b.s then

                # children gone, self appear or differ
                b && d.picture != b.picture and d.cha = 1;
            }
            # child needs parent to attach it
            # < less often
            d.cha && d.up and d.up.cha = 1
        }
        each id A&ds {
            $s = d.s;
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC";
                s.y.A.on = d.on;
                d.on.A = s.y.A;
            }
            if (s == C) {
                C != A&s and throw "notC";
                i > 0 and throw "sC>0"
                1c&on = d.on;
            }
            s == C && (!s.y.A || s.y.A != A) and debugger;
            !d.up and continue
            d.up.down ||= [];
            d.up.down.push(d);
        }
        
        #c put each in another
        $rev = A&ds.slice().reverse();
        each id rev {
            #!d.cha and continue
            # what is
            $had = d.on.childNodes;
            # what will be
            $have = [];
            d.picture &&
                have.push('<cs>'+d.picture+'</cs>');
            each ip d.down {
                have.push(p.on);
            }
            if (d.J) {
                $J = d.J;
                !Jc&on and throw "noJon";
                have.push(Jc&on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor position + focus) could be made up somehow
            # hadnt - what we didn't know was there
            # havent - what goes
            # rearrange, carefully. or just:
            $(d.on).empty();
            each i,on have {
                $(d.on).append(on);
            }
            
        }
        
        if (A.2 == A.4) {
            !A.4.on and throw "No A4on"
            if (!A.4.on.contains(A.on)) {
                ~>2 Fours: A.1.t, ki(d.s)
                $(A.on).appendTo(A.4.on);
                # if it was already, take it as an unplug?
                # or find new parent, get adopted
            }
        }
        
        A.1.t != 'wobulus' and return
        $(A.on).find('p').remove();
        $(A.on).append("<p>"+l).find('p').on('click',&e{
            4c&pause = !4c&pause
        });
        #A.on.innerHTML = G&ind,C,du;
        return;
        
        each it 4s&raw {
            $la = $('<p>T</p>').appendTo(A.on);
            la.text(t);
        }
        
        $la = $('<p>T</p>').appendTo(A.on);
        la.on('click', &e{
            e.stopPropagation();
            me&upghost,'Soogle';
        });
        la.css('font-size','280%');
    };
    me.picture = &s{
        $Y = s.y.A;
        $usu = Y && Y.t == 'n';
        if (usu && sc&J && ss&J) {
            s = hup(s);
            sc&J == s.t and delete sc&J;
            sc&W == s.t and delete sc&W;
            #ss&W == s.t and delete ss&W;
            delete ss&z;


        }
        $k = ki(s);
        usu and k = k.replace(/,A;n/,'');
        return k
    };
    
Packle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    #c Jay
    me.J = &acgts{
        # do a J
        $C = typeof s == 'string' && [s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        $j = G&n,C,5;
        C = jc&s;
        !me.J[c&J] and throw "unknown me.J: "+c&J
        
        j.ground = C;
        
        me.J[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        
        if (c&M) {
            $cv = 0.3;
            each in c&M {
                n.y.cv and continue
                # suggest y.cv of 30i+
                n.y.cv = G&desca,cv,8;
                cv += 0.001;
                G&n,n;
            }
        }
        
        me.osc(j,C,G,T);
        
        return C;
    };
    
    me.J.wobulus = &acgt{
        =pod
        n A4sc  $s:A.4.sc
        n A4on  $s:A.4.on
        n A  $s:A
        n Aup  $s:A.up
        n Aupup  $s:A.up.up
        n Aon  $s:A.on
        n AonA  $s:A.on.A
        n AonA1  $s:A.on.A.1
        n A1  $s:A.1
        =cut
        
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4
        n tongs 5 s:lovelyyyy
        n tongs 6 s:lovelyy
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'edges';
    };
    me.J.edges = &acgt{
        A.3 = A.1;
        3c&oscer = 'Carb';
        
        n things 2
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising}];
    };
    me.J.od = &acgts{
        n t  $s:C.t %fs:25
        
        n c  $s:ki(Object.keys(s.c))
        
        $M = c&M = [];
        each kv s.c {
            m k  $s:k
            m v  $s:ki(v,3) %fs:4
        }
    };
    # dress d.on
    me.Carb = &acgtd{
        # c&s != null and d.on.innerText = c&s
        $el = d.on;
        
        $diff = &di,ff,dd{
            typeof di != 'object' and return di != ff
            $wh = {gone:{},diff:{},new:{},same:{}};
            each kv di {
                null == ff[k] and wh.new[k] = {};
                ff[k] != di[k] and wh.diff[k] = {};
                wh.same[k] = {};
            }
            each kv ff {
                null == di[k] and wh.gone[k] = {};
            }
            each qua,k,ha wh {
                qua == 'same' and continue
                dd && dd.ignore == k and continue
                return 1
            }}
        };
        if (s&J) {
            # expand/see into Js&v, write on this atom
        }
        
        $b = d.b;
        $x = b && b.s || {};
        $cha = diff(C.c,x.c||{})
            || diff(C.sc,x.sc||{},{ignore:'z'});
        cha and d.cha = 1;
        
        if (typeof c&s == 'string') {
            d.picture = c&s;
            # ^ element's text gets set with children. later:
            c&ht and d.html = c&s;
            else
            d.text = c&s;
        }
        
        !d.cha and return
        
        s&fs and $(d.on).css("font-size",(s&fs * 10)+'%');
    };
    #c way
    
    # to receive way notifies
    me.J.digwaypoll = &acgt{
        1c&eyei ||= 0;
        c&ieye = 1c&eyei++;
        
        $w = A.5.I.w;
        4s&raw.push('A.53: '+ki(A.1));
        
        $ws = me&ws,A.1.t;
        wsc&open = &w{
            # assert what we care about
            each ti me.importo {
                me&waytime,t,null;
                w.send(t);
            }
        };
        wsc&receives = &l{
            each is l {
                me&upghost,s
            }
        };
    }
    me.waytime = &acgtts{
        $wa = A.5.I.w; # alien stash
        !wa and throw "no wa", t
        $w = wa.y.tw[t]; # has G&ways we use
        !w and throw "no w", t
        s == null and s = G&time + 3600
        ws&now = s; # unixtime, forces update
    };
    me.upghost = &acgtt{
        t ||= 'Soogle';
        me&waytime,t,1;
        4s&upghost ||= [];
        4s&upghost.indexOf(t) < 0 and 4s&upghost.push(t)
    };
    # < merely starts fetching new copy
    #   next frame will carry out the update
    $w = me.importo = {};
    # the way to trigger, or simply the way to trigger
    w.Soogle = 1;
    w.Packle = 1;
    
    me.doupghost = &acgt{
        each it 4s&upghost {
            # make sure it's out of date
            me&waytime,t,1;
            # noop, ttl = 1 hour
            $cb = &t,ar,w{ ws&now = G&time + 3600 };
            G&way,t,{},cb;
            !w[t] and continue
            4s&downghost ||= [];
            4s&downghost.indexOf(t) < 0 and 4s&downghost.push(t)
        }
        delete 4s&upghost
    };
    me.dodownghost = &acgt{
        each it 4s&downghost {
            ~>3 downung: t
            G&way,t
            ~>3 downund//1: t
        }
        delete 4s&downghost
    };
    
pi/god: | # surf all
    # #
    #
    n t  $s:C.t %fs:45

