Clalia: | # drag n learn
    G&heading;
    ys&ab = '1';
    ys&height = '30%';
    ys&width = '60%';
    A.noelvis = 1;
    # to make html+javascript that lives a life of its own
    
    $t = window.t = 3s&t = {};
    
    n Classes -Pupula $s:<<'' %ab:1,width:100%,height:100%
    Engineering	4000
      seeing	439	%st:being,pow:24
        c s: |
          Lovely and sighted.
          Takes hold.
        Riddiford	%day:1,time:900-1040
        Riddiford	%day:3,time:1300-1450
        Taxiderm	%day:2,time:1300-1340
      triangle	469	%st:geometrica,pow:12
        c s: |
          Bring togs.
        Riddiford	%day:4,time:1120-1340
        Riddiford	%day:3,time:1400-1550
        Taxiderm	%day:2,time:1500-1640
      weld	468	%st:geometrica,pow:9
        c s: |
          Ceramic?
        Riddiford	%day:1,time:900-1040
        Riddiford	%day:3,time:1300-1450
        Taxiderm	%day:2,time:1300-1340
    Art	8000
      weld	868	%st:enjoyment,pow:9
        c s: |
          But with plenty of slop.
        Riddiford	%day:1,time:900-1040
    
    t.emplate = <<'';
    <div id="bits"> Classes </div>
    <div id="week"> Week </div> 
    <div id="info"> Info </div>
    
    t.days = 5;
    t.fracday = &s{
        $m = (''+s).match(/^(\d?\d)(\d\d)$/);
        !m and throw "not a time: "+s
        return (m[1] * (1/24)) + (m[2] * (1/1440))
    };
    t.daystart = t.fracday('0900');
    t.dayend = t.fracday('1700');
    t.Start = &{
        $('#bits').replaceWith(t.emplate);
        #$('table td').css('vertical-align','top');
        
        # classes
        $cl = $('#bits').empty()
            .css('position','absolute')
            .css('width','30%')
            .css('height','100%');
        cl = $('<ul>').appendTo(cl)
        each ic t.group {
            $('<li>').appendTo(cl)
                .attr('id',c.id).text(c.t)
                .on('click',t.togGroup);
        }
        
        # week
        $we = $('#week').empty()
            .css('position','absolute')
            .css('left','30%')
            .css('width','40%')
            .css('height','100%');
        $width = 100 / t.days;
        $side = 0;
        for (var day = 1; day <= t.days; day++) {
            $d = $('<div id="day'+day+'">')
                .css('width',width+'%')
                .css('height','100%')
                .css('position','absolute')
                .css('background','rgba('+(day*30)+',120,120,0.3)');
            side and d.css('left', side+'%')
            we.append(d);
            side += width;
        }
        
        # info
        $we = $('#info').empty()
            .css('position','absolute')
            .css('white-space','pre')
            .css('left','70%')
            .css('width','40%')
            .css('height','100%');
        we.css('background','rgba(120,40,40,0.3)');
        we.text('Click on a class');
    };
    #c tog grasp time
    t.togGroup = &{
        $g = t.group[this.id];
        !g and return;
        $cl = $(this);
        if (cl.attr('ope')) {
            cl.attr('ope','');
            cl.children().remove();
            return;
        }
        cl.attr('ope',1);
        cl = $('<ul>').appendTo(cl)
        each ic g.z {
            $('<li>').appendTo(cl)
                .attr('id',c.id).text(c.t)
                .on('click',t.graspClass);
        }
    };
    t.graspClass = &e{
        e.stopPropagation();
        $cla = t.class[this.id];
        !cla and return
        $te = [];
        cla.t and te.push(cla.t)
        # Placed $attime  or Placing
        cla.st and te.push("St: "+cla.st)
        cla.pow and te.push("Pow: "+cla.pow)
        cla.desc and te.push(cla.desc)
        cla.z and te.push(ki(cla.z,5))
        te.length and $('#info').text(te.join("\n\n"));
        # plot
        $('#week .potential').remove();
        each ic cla.z {
            $day = $('#week #day'+c.day);
            $time = c.time.split('-');
            $starts = t.fracday(time[0]) - t.daystart;
            $endures = t.fracday(time[1]) - starts;
            endures < 0.1 and endures = 0.1;
            $plot = $('<span>')
                .css('position','absolute')
                .css('width','100%')
                .css('top',(starts*100)+'%')
                .css('height',(endures*100)+'%')
                .css('background','rgba(176,140,130,0.6)');
            plot.text(starts+' - '+endures);
            plot.attr('class','potential');
            plot.appendTo(day);
            
        }
    };
    
    

    
    G&yl:0.05,&s{ t.Start() };
    
    #
pi/Pupula: |
    $io = G&way,'iooia';
    ys&id = 'bits';
    ys&width = '30%';
    
    n t 1 $s:C.t
    
    if (typeof s == 'string') {
        $uni = G&readLines,s;
        # now we have a university using C
        # make a few bits of csv since reality
        $tables = 3s&t;
        $ids = {};
        $everything = [];
        $insert = &type,s{
            $c = ex({},s.sc);
            c.type = type;
            
            s.y.cv != 0.1 and c.id = (s.y.cv+'').replace(/^0\./,'')
            else {
                ids[type] ||= 0;
                c.id = ids[type]++
            }
            
            c.t = s.t;
            sc&s and c.desc = sc&s
            everything.push(c);
            $table = tables[type] ||= {};
            table[c.id] = c;
            return c
        };
        # < io/S at many indent levels... call em ay,by,cy,dy...
        $ta = 3s&tables = {};
        $uni = G&Cye,['uni','','',{z:uni}];
        o $uni/:group/:class/:time
        io.nz().ind(&s,t{
            #debugger;
            ~Aye: t.ark, ki(s,2)
            t.ark == 'uni' and return
            $c = insert(t.ark,s);
            c.z = [];
            $up = t.parenting;
            up and up.z.push(c)
            return c
        });
        everything.map(&c{ c.z && !c.z.length && delete c.z });
        #n thing  $s:eny(tables) %ws:pre,dis:block
        #return
    }
    
    
    
    
Sevo: | # seive o
    $io = G&way,'iooia';
    io.iz = 1;
    G&heading;
    # anything
    n anything 2 s:anyething %fs:300%,blr:3px
    =pod
    
    A is causality cones,     spreading
    C is causing thing,       growing
    G is a receptive ground,  filled
    T is a trouble hoist,     empty
    
    We shall get diff/patch speaking quietly over websockets to the babz,
    eventually getting everything in js and building castles all over.
    
    24 NutThing has:
     h to call a function, looking for t[0]='i', t[1]=name via:
     t looks up a thing (named) or two (named in named)
    24 NutIns began:
     ting looking further (async) for things to push/pull and protocol
    
    the only global, called H(A,C,G,T,[of,t],args[],c,sc)
    so immediately localised along A
    looking for something to do such with
    the such is C-like, so it could have:
      where that particular thing should be (of,t or more fuzzy)
      a push/pull supplied,
        brokered by a protocol/boundary-handler J
        with H gating usage to up-to-dateness,
          entering existing E sidetrack if...
      a melted down compilation one day
    H is a join (or separation) of two pieces
      notions -> actuality
    
    < still coded G&func?
    
    io will have to travel A as well... looking for t, A
    
    =cut
    
    #c runtime! as Sevo's s done hook.
    # Starts a new G/4, loads me, io, A.I
    # 
    
    $me = c&me ||= {};
    me.Ja = {}; # pins
    me.H = &acgttycs{
        typeof t == 'string' and t = ['i',t]
        typeof y == 'object' and c = {args:y}
        c ||= {};
        $sc = s || {};
        c.push and throw "this thing wants to be this thing"
        c.pull and throw "this thing is wanted"
        # < pull also acquired from looking
        
    };
    me.timestamp = &{ return(new Date).toISOString() };
    G&way,'Soogle',{},'noop';
    G&way,'Packle',{},'noop';
    G&way,'Coffle',{},'noop';
    #$w = G&t,'w','Soogle';
    #debugger;
    
    me.start = &{
        $Y = G&Aye,'Four';
        A = Y;
        delete A.ground;
        delete A.r;
        #delete A.up;
        delete A.n;
        
        #A.noelvis = 1;
        me.io = io;
        A&me = me;
        A.1 = A.3 = A.4 = A;
        
        4s&NormalI = A.I; # TOGO
        # in favour of dispatch table towards 4:
        # inits and continues methods on me
        # unco:
        4s&N = [];
        
        # make m ... add to A.ground z, as well as JCc&M?
        $m = A.I.eye.y.tw.m;
        if (!ms&altered) {
            ms&altered = 1;
            $was = mc&code;
            mc&code = &acgtMs{
                $C = was(A,C,G,T,M,s);
                # attach to whatever ground is,
                #  for ordering amongst n things
                $g = A.ground;
                gs&z ||= [];
                gs&z.push(C);
                $Jc = 1c&s;
                if (Jc && Jcc&M && Jcc&M != M) {
                    # M probably the z of something inside
                    # allocate cv from J
                    #debugger;
                    Jcc&M.push(C);
                }
                return C
            };
        }
        
        G&way,'Soogle';
        G&way,'Packle';
        G&way,'Coffle';
        document.title = 'zpot';
    
        A.on = el;
        el.A = A;
        C = A&s = {t:me.timestamp(),y:{},c:{},sc:{}};
        #$G = {y:{},c:{},sc:{}};
        T = {y:{},c:{},sc:{}};
        
        me.star(A,C,G,T);
    };
    
    
    $el;
    $colour;
    $i = 0;
    $flip = &{
        colour = colour == 'pink' ? 'blue' : 'pink';
        $(el).css('border','2px solid '+colour)
        i++ > 20 and return
        i == 2 and me.start();
        G&yl,(1000/432)*13,&{flip()}
    };
    
    #G&way,'Steev';
    A&shook = &s{
        el = sc&on;
        flip();
        $('body div.v7').remove();
        el =
        $('<div class="v7" style="position:absolute;'
            +'white-space:pre;font-size:70%;'
            +'top:0%;left:55%;height:20%;width:43%">')
        .appendTo('body')[0];
    };
    
    
Soogle: |
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    4c&fps = 1;
    
    # loop comebacks between attentions
    $lastwas = 0;
    me.star = &acgt{
        !A.on.ownerDocument.contains(A.on) and return 4s&dead = "Unplugged"
        $me = A&me;
        $starts = G&time;
        lastwas and 4s&nonms = G&time,lastwas;
        $Y = A;
        A.on.A = A;
        #A.noelvis = 1;
        $frames = 1000/A&fps;
        frames += A&brake ||= 0;
        A&brake > 0 and ~braking: A&brake
        A&brake > 7000 and A&brake = 7000
        4c&callback ||= &{ me.star(Y,C,G,T) };
        $sing = 4c&callback.singly = {};
        G&yl:frames,&{ sing == 4c&callback.singly && 4c&callback() };
        
        try { me&starc }
        catch (e) {
            $async = e.message.match(/^async/);
            # assume requests complete between framerates
            if (!async) {
                # or staccato explosions
                A&brake += 2000;
                throw e, 'star'
            }
            ~Ytp: e.message
        }
        
        $ends = G&time,starts;
        4s&ms = ends;
        lastwas = G&time;
        # aim for a third of our time in the loop
        ends > (frames * 0.1) and A&brake += 200
        elsif (A&brake) { A&brake -= 100 }
        4s&busyratio = ends / frames;
        4s&busyratio < 0.001 and delete 4s&busyratio;
    };
    me.pause = &acgt{
        return 4c&pause = !4c&pause
    };
    # cast gazet
    # this is a bag of marbles, they are free and together
    me.starc = &acgt{
        $A = G&Aye,'star';
        $g = A.ground = G&Cye,[me.timestamp(),{},{root:1},{}];
        
        # clusp
        4c&pause and return
        
        # already part of some self-reflexive time
        4s&upghost and me&doupghost
        4s&downghost and me&dodownghost
        !me.inita.ed and me&inita
        
        # any textual output:
        4s&raw = [];
        
        # 1/10th attend
        A&sip.slice(-1)[0] == 0 and me&otherandcontinue
        
        4s&Jays = 0;
        
        me&J,'wobulus';
    };
    #c elvis/S reroute
    me.inita = &acgt{
        me.uY = A;
        # for 25/Domes/S
        4c&Srupto = &A,C,G,T,s,t,talk,params{
            return me&Srupto,s,t,talk,params
        };
        # for w EleVisAn
        4c&elvrupto = &acgt{
            $Y = me.uY;
            c&Jat[0] != Y.4 and c&Jat.shift();
            c&Jat[0] == Y.4 and c&Jat.shift();
            # <body>
            c&path.shift();
            A = Y;
            # < push for immediacy
            c&JC = c&Jat.map(&J{ return Jc&s });
            # on.C = C
            $full = c&path.slice();
            c&path_yon and full.push(...c&path_yon);
            c&slope = [];
            each in full {
                $c = n.C;
                !c || c == c&slope.slice(-1)[0] and continue
                c&slope.push(c);
            }
            me&handelvis,'';
        };
        me.inita.ed = 1;
    };
    #c sidetrack
    me.otherandcontinue = &acgt{
        if (4s&log) {
            4s&log = 4s&log.filter(&l{
                return G&time,ls&now < 15
            });
        }
        if (4s&N) {
            4s&N = 4s&N.filter(&Y{
                if (Y.4 && G.DNS[Y.4.t] != Y.4) {
                   #~TheirAnd: ki(Y.4)
                }
                else { return 1 }
            });
        }
    };
    # J's ws to themselves on the other side
    me.ws = &acgts{
        A = 1c&ws ||= G&Aye,'ws';
        $ws = A&ws;
        ws && ws.readyState == 1 and return A
        ws = A&ws ||= new WebSocket(
            'ws://'+location.host+'/'+A.1.t);
        ws.onclose = &ev,la{
        };
        ws.onerror = &ev,la{
            debugger;
        };
        ws.onopen = &ev,{
            ws !== A&ws and return ~sockalivedupe: A&ws
            ~connected: ws.url
            A&open and return A&open(ws)
        };
        ws.onmessage = &ev,la{
            4s&dead and return ws.close()
            $s = ev.data;
            if (A&receive) {
                A&receive(s)
            }
            elsif (A&receives) {
                $l = s.split("\n");
                l.slice(-1)[0] == '' and l.pop()
                A&receives(l)
            }
            else {
                throw "unhandled ws", ws.url, s
            }
        }
        return A
    };
    
    #c Cav-on 7dress html
    # and whatever after the state of atoms is got (osc/3)
    # really it does 4 here - catching state of properties changing
    #   some sleep/wake
    # < inc versions of styles applied
    # 5 + 6 in Css, translating properties to another language
    # but could end up in multifaceted games, showing working, etc...
    me.Cavon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $C = Rs&C || Rc&s;
            Rs&on ||= b && bs&on;
            Rs&on ||= $("<stylehouse>")[0];
            
            # each A.1 does os, plants sequencer of 
            if (Rs&J) {
                $(Rs&on).css('display','block');
                $J = Rs&J;
                # 1s&on noticed
                Rs&in = Jc&on || Js&on;
                b && Rs&in != bs&in and me&chR,R,'Jin'
                continue
            }
            # more to think mode?
            if (s&J) {
                # expand/see into Js&v, write on this atom
            }
            # C.sc etc decorate
            me&Cscon,R;
        }
    };
    # apply styles to html.. expand unto copies of this thing,
    #   allowing a compressed notation to turn into styles,
    #     giving space to dream of altering the situation
    #     as the matter forks along a path of progress
    #   (we may use d to collect & export workings)
    #     and the whole osc atomism
    #   into css styles
    $verbose = 0; # causes window.styletos to list styles
    $robust = 0; # applies all css properties every time
    me.Cscon = &acgtR{
        $isnew = !Rc&b;
        # past self
        $b = Rc&b || {c:{},sc:{}};
        # om details no longer relevant:
        s&e and throw "used to eval(s&e)"
        s&nobody and throw "used to reselect d.on"
        if (s&tag || bs&tag) { # or historically
            if (bs&tag != s&tag) {
                # recreating the d.on clears applieds
                Rs&on = $("<"+(s&tag || 'stylehouse')+">")[0];
                delete bs&attr;
                delete bs&css;
            }
            s&tag and Rs&tag = s&tag
        }
        # < hammerhead stylings wanting some cache api
        #   alike, C fork down paths repeatable
        # < title should be replaced by hover -> question elvis
        $attr = ex({title:C.t+' '+(C.y.cv||'')}, s&attr||{});
        if (attr || bs&attr) {
            $notin = ex({},bs&attr||{});
            Rs&attr = {};
            each kv attr {
                # '' makes a bareword attribute, ease coding in a peel
                v == '!' and v = ''
                Rs&attr[k] = v;
                delete notin[k];
                !robust && bs&attr && bs&attr[k] == v and continue
                $(Rs&on).attr(k,v);
            }
            each kv notin {
                $(Rs&on).removeAttr(k);
            }
            !hak(Rs&attr) and delete Rs&attr
        }
        # more simpler translatoes
        $css = {};
        # ^ merge into me&styler:
        # also s&cod/NutText
        # and Stylaplicants's dropdown
        
        $st = 4s&styler ||= me&styler;
        
        st(C,css);
        
        
        # css stamped on on
        if (hak(css) || bs&css) {
            $notin = ex({},bs&css||{});
            each kv css {
                delete notin[k];
                bs&css && bs&css[k] == v and continue
                $(Rs&on).css(k,v);
            }
            each kv notin {
                $(Rs&on).css(k,'')
            }
            hak(css) and Rs&css = css
        }
        
        # Cs say their c&s
        if (typeof c&s == 'string') {
            if (c&ht) {
                Rs&html = c&s;
                b && Rs&html != bs&html and me&chR,R,'html'
            }
            else {
                Rs&text = c&s;
                b && Rs&text != bs&text and me&chR,R,'text'
            }
            # Cupon sets Rs&on's text/html content as a child
            # which is why to cause Rs&cha? might work without
            # supposing the element will surely be there...
        }
    }
    #c Cup-on 8html output: put each in another
    # the html elements are closer to the C this time,
    #  used to always output a C-patch
    # s gets s&on
    me.Cupon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            $up = R.y.up;
            # child needs parent to attach it
            # < TES less often, if b.on still == d.on?
            Rs&cha && up and me&chR,up,'Inner:'+R.t
            
            !Rs&on and debugger;
            # how else shall we entangle R/on/C/A?
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC"
                s.y.A.on = Rs&on;
                Rs&on.A = s.y.A;
            }
            if (s == C && s&J && s&J == A.1) {
                C != A&s and throw "notC"
                i > 0 and throw "sC>0"
                # 1s&on set to thing, big deal
                1s&on = Rs&on;
            }
            #s == C && (!s.y.A || s.y.A != A) and debugger;
            !up and continue
            # ups&down here Babz A.up.sc.down
            # < make R an A, work these functions with A/C
            up.sc.down ||= [];
            up.sc.down.push(R);
        }
        
        $rev = N.slice().reverse();
        each iR rev {
            #R.t == 's ' and debugger;
            Rs&on.C = Rc&s;
            Rc&s.y.A and Rs&on.A = Rc&s.y.A;
            Rc&s.y.R = R;
            !Rs&cha and continue
            # what is
            $had = Rs&on.childNodes;
            # what will be
            $have = [];
            # text/html
            Rs&html and have.push('<cs>'+Rs&html+'</cs>');
            Rs&text and have.push($('<cs>').text(Rs&text)[0]);
            # children
            each ir Rs&down {
                have.push(rs&on);
            }
            if (Rs&J) {
                $J = Rs&J;
                # yon 1s&on put into Rs&on
                $on = Jc&on || Js&on;
                !on and throw "noJon";
                have.push(on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor + focus)
            #       could be made up somehow
            # hadnt - what we didn't know was there
            # havent - what goes
            # leaving it open to elements being rearranged by the user?
            # rearrange, carefully. or just:
            $dif = 0;
            each i,on have {
                $ha = had[i];
                on == ha and continue
                typeof on == 'string' && ha && on == ha.outerHTML and continue
                # different...
                dif++;
            }
            if (1 || dif) {
                $(Rs&on).empty();
                each i,on have {
                    $(Rs&on).append(on);
                }
            }
        }
        #$move = N.filter(R => Rs&cha);
        #$(Rs&on).append('<p>~ '+
        #move.length and ~moveing: ki(A&chR)
        #move.map(R => Rc&s.t).join(', ')
        #~move: A.1.t, ki(move), '/', A&R.length
        
        $h = N[0];
        $on = hs&on;
        if (A.2 == A.4) {
            !A.4.on and throw "No A4on"
            if (!A.4.on.contains(on)) {
                ~>2 Fours: A.1.t
                $(on).appendTo(A.4.on);
                # if it was already, take it as an unplug?
                # or find new parent, get adopted
            }
        }
    };
    
    #c styler
    me.styler = &acgt{
        # generate noise
        # s&mh -> the proper css name: max height
        #  and a formatting function
        $data = [
        'numb z index',
        #'numb+plus:-20 z ig^^index',
        #'numb+plus:-10 z ie^^index',
        'empc letter spacing',
        'empc wo^rd spacing',
        'empc line height',
        'empc margin left,right,top,bottom',
        'empc padding left,right,top,bottom',
        'empc ma^rgin',
        'empc mi^n width,height',
        'empc max width,height',
        'empc lef^t,ri^ght,top^,bot^tom',
        'empc left^,right^,bottom^',
        'empc width^,height^',
        'empc wi^dth,he^ght',
        'empc border radius',
        
        ' over^flow',
        ' float^',
        ' bo^rder',
        'hsle bo^rder color',
        ' bo^rder left,right,top,bottom color,style,width',
        'sca opa^city',

        ' tr^ansform origin',
        'radun ^transform rad^^rotate',
        ' ^transform scale^',
        'saypx ^filter blr^^blur',
        ' ^filter sat^urate',
        ' ^filter con^trast',
        ' ^filter bri^ghtness',
        'saydeg ^filter hue^-rotate',
        ' ^filter sep^ia',
        ' ^filter inv^ert',
        ' ^filter gray^scale',
        'sayurl background gi^^image', // bgi
        ' bg^^background',
        'hsle bgh^^background-color',
        'hunine font size',
        'hundr font si^ze',
        'hundr font weight',
        
        'shadole ^text sha^dow',
        'cole co^lor',
        'hsle hs^^color',
        'defsa:underline ^text deco^ration',
        'ori:none~all poi^nter ^events',
        'whipre white space',
        'ori:normal~break-word~break-all word break',
        'ori:none~block~inline-block~table-row dis^play'
        ];
        # was/will be mind
        $N = [];
        each il data {
            l = l.split(' ');
            $format = l.shift();
            $g = {}; # a bunch of css properties
            $set = [g];
            each is l {
                $get = [];
                each ig set {
                    $poss = s.split(',');
                    $gb = g;
                    each iz poss {
                        $g = ex({},gb);
                        $m = [];
                        # different name
                        if (m = z.match(/^(.*)\^\^/)) {
                            g.gk ||= '';
                            g.gk += m[1];
                            z = z.replace(/^(.*)\^\^/,'');
                        }
                        # part of name
                        elsif (m = z.match(/^(.*)\^/)) {
                            g.gk ||= '';
                            g.gk += m[1];
                            z = z.replace(/^(.*)\^/,m[1]);
                        }
                        # tiniest part of name
                        else {
                            g.gk ||= '';
                            g.gk += z[0];
                        }
                        g.cssks = (g.cssks||[]).slice();
                        g.cssks.push(z);
                        get.push(g);
                    }
                }
                set = get;
            }
            each ig set {
                !g.cssks and throw "nocsskeys"
                g.cssk = g.cssks.join('-');
                delete g.cssks;
                
                if (format) {
                    $m = format.split(':');
                    m[1] and g.options = m[1].split('~')
                    g.format = m[0]
                }
            
                N.push({t:g.gk,y:{},c:{},sc:g});
            }
        }
        
        $auto = 'geo ab'.split(' ');
        each in auto {
            N.push({t:n,y:{},c:{},sc:{gk:n,format:'do_'+n}});
        }
        #c formatty things
        $co = {};
        # GOING (otherhow) scale into such a space (changes C)
        co.scaly = &acgtsl{
            l ||= 15;
            s&fs ||= 9;
            $d = l - s.length;
            d /= l/3.14159;
            s&fs += d;
            d < -0.6 and s&width = co.ron((6+l/2.13169),1);
            s&fs < 3 and s&fs = 3
            s&fs > 17 and s&fs = 17
        };
        co.ron = &s,precision{
            return +(+s).toFixed(precision || 4)
        };
        co.do_geo = &s,opt,css{
            $s = s.split(' ');
            $aung = s[0].match(/^a(\d+)/); #]
            if (aung) {
                s.shift();
                # s&ab = aung[1] # can't set sc from here
                co.do_ab(aung[1],{},css);
            }
            s = {x:s[0],y:s[1],rad:s[2],scale:s[3],tro:s[4]};
            css.top = (s.y * 100)+'%';
            css.left = (s.x * 100)+'%';
            css['transform-origin'] = '0% 0%';
            s.tro and css['transform-origin'] = s.tro;
            s.rad and css['transform-rotate'] = s.rad+'rad';
            s.scale and css['transform-scale'] = s.scale;
        };
        co.do_ab = &s,opt,css{
            if (s == '100') {
                css.width = '100%';
                css.height = '100%';
            }
            css.position = 'absolute';
        };
        # hex value colouring, converted to 0-255
        co.cole = &s{
            if (s.length == 1) {
                # as ~messages?
            }
            else {
                # rgb(a)
                if (s.length == 3 || s.length == 4) {
                    s = s.split('').map(&s{ return s+''+s });
                }
                else {
                    $l = [];
                    while (s.length) {
                        l.push(s.slice(0,2))
                        s = s.slice(2);
                    }
                    s = l;
                }
                each in s {
                    s[i] = +eval('0x'+n)
                }
                $called = 'rgb';
                s[3] and s[3] = s[3] / 255; called += 'a'
                return called+'('
                    +s.map(&s{ return co.ron(s) }).join(',')
                +')'
            }
        };
        co.hsle = &s{
            $z = s.split(' ').map(&s{ return (+s) / 100 });
            s = z.length > 1 && z
                || s.split('').map(&s{ return (+s) / 10 });
            s[0] = co.ron(s[0] * 360,0);
            s[1] = (s[1]*100)+'%';
            s[2] = (s[2]*100)+'%';
            $called = 'hsl';
            s[3] != null and s[3] = co.ron(s[3],3); called += 'a'
            return called+'('+s.join(',')+')'
        };
        co.empc = &s{
            s += '';
            !s.match(/%|em|px/) and s += 'em'
            return s
        };
        co.defsa = &s,opt{
            return s == '1' ? opt[0] : s
        };
        co.ori = &s,opt{
            opt.length == 1 and return opt[0]
            if (isnum(s)) {
                opt[s] == null and throw "Not a choice: "+s, opt
                return opt[s]
            }
            return s
        };
        co.whipre = &s{
            s += '';
            return s.match(/^[2n]/) ? 'nowrap'
                : s.match(/^[3l]/) ? 'pre-line'
            : 'pre';
        }
        co.shadole = &s{
            s = s.split(' ');
            $colour = s.length == 4 && s.pop();
            colour and colour = co.cole(colour)
            return s.map(&s{ return d+'px' }).join(' ')
                + (colour ? ' '+colour : '')
        }
        # number of radians in a 90 degrees?
        co.radian = 1.57079633;
        # wind radial info only once around
        co.radun = &s{
            $o = co.radian*4;
            $swish = o;
            s < 0 and swish *= -1;
            $i = 0;
            while (s > o || s < o*-1) {
                s -= swish;
                i > 5 and throw "muchwinding"
            }
            return co.ron(s,8)
        };
        
        # 1 -> 100%
        co.hundr = &s{
            return co.ron((+s)*100,0)+'%';
        };
        # 9 -> 81%
        co.hunine = &s{
            return co.ron((+s)*9,0)+'%';
        };
        co.numb = &s{
            return co.ron(+s)
        };
        # adds jargon
        co.say = &s,unit{
            return s.includes(unit) ? s : s+unit
        };
        co.saypx = &s{ return co.say(s,'px') };
        co.saydeg = &s{ return co.say(s,'deg') };
        co.sayurl = &s{ return "url('"+s+"')" };

        
        #
        
        
        #c applied

        
        # index by gk
        $ext = {};
        $tos = [];
        each iD N {
            !Ds&gk and continue
            ext[Ds&gk] and throw "two gk:"+Ds&gk+": "+Ds&cssk+" or "+ext[Ds&gk].sc.cssk;
            ext[Ds&gk] = D
            verbose and tos.push(Ds&cssk+'   '+Ds&gk)
        }
        verbose and window.styletos = tos.join("\n");
        
        # styles: that(are) group(ed)
        $po = {};
        po.transform = ['rotate','scale'];
        po.filter = ('blur saturate brightness sepia'
            +' hue-rotate invert grayscale').split(' ');
        
        return &C,css{
            # apply C -> css
            each gk,D ext {
                $v = C.sc[gk];
                v == null and continue
                if (Ds&format) {
                    $f = co[Ds&format];
                    !f and throw "No format: "+Ds&format
                    typeof v == 'number' and v = ""+v
                    v = f(v,Ds&options,css);
                    #gk == 'fs' and ~Formats: gk, Ds&format, v
                }
                !Ds&cssk and continue;
                css[Ds&cssk] = v
            }
            
            # grouped
            each tik po {
                $lie = t+'-'+k;
                css[lie] == null and continue
                css[t] ||= {};
                css[t][k] = css[lie];
                delete css[lie];
            }}
            # string grouped
            each kv css {
                typeof v != 'object' and continue
                $val = [];
                each KV v {
                    val.push(K+'('+V+')')
                }
                css[k] = val.join(' ')
            }
            if (css.filter) { # old chrome
                css['-webkit-filter'] = css.filter;
                delete css.filter;
            }
        };
    };
    

    #c Ja.od
    # each of these to present furthers,
    # and watch/let go intermediaries as they squish from focus
    # visualising the shifting yet sameness
    me.Modu = &acgtNM{
        each in N {
            if (ns&swal) {
                $C =
                m $n
                !me[n.t] and throw "no swal cb: "+n.t
                me[n.t](A,C,G,T,nc&s);
            }
            else {
                throw "nonswal";
            }
        }
    };
    me.Ja.od = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&bgh = '1115';
        s&bo ||= '3px dotted #235';
        s&br = '3';
        s&zi = -2;
        
        
        $d = me&scan,s;
        delete d.s;
        $is = d.is || d.sym;
        $ym =
        n sym  $s:is %fs:15,ab,mt:-0.1,ml:-0.1,zi:-1,hs:4955
        
        $check = &{
            $el = 1c&on;
            $le = ym.y.A.on;
            $(le).css('font-size', $(el).height()+'px');
        };
        #G&yl:300,check;
        # the minor modulate gang hang at mid-swallow (y)
        $swal = d.modu ? &{ me&Modu,d.modu,M; swal = &{} } : &{};
            # the swept up (behind/as y) pile of junk
            #   in the hallway of infinity, outside a room
            #   but essentially not in a door we believe in that much
            #   everything will be C soon
        
        each ik d.ks {
            A.ground = C;
            if (d.C) {
                if (k == 't') {
                    # no label, underlined
                    n t 2 $s:s.t %fs:15,deco
                }
                elsif (k == 'y' && 0) {
                    # no label, balled...
                }
                else {
                    swal();
                    # C.*
                    
                    #$g = A.ground =
                    #n $k  lef %ml:1
                    #gs&bo ||= '3px dotted #235';
                    #gs&dis ||= 1;
                    m k  $s:k %fs:21,lh:42%
                    #m k  $s:k %hs:0000
                    each qv s[k] {
                        #]
                        m k  $s:q %hs:748
                        $pow = 3;
                        k == 'y' and pow = 2
                        c&smallish and pow--;
                        k == 'c' && q == 'N' and pow = 2
                        m v  $s:ki(v,pow) %fs:8
                    }
                }
            }
            elsif (c&forit) {
                $v = s[k];
                me&J,[C.t+c&forit+k,'-od',{s:v,smallish:1}];
            }
            else {
                $v = s[k]; #]
                m k  $s:k %lh:4
                m v  $s:ki(v,3) %fs:8
                if (c&fora) {
                    $vv = v[c&fora];
                    m vt  $s:c&fora
                    #vv = vv.c.s ? vv.c.s : vv;
                    me&J,['foracs'+c&fora+k,'-od',{s:vv}];
                }
            }
        }
        swal();
        
        if (d.C) {
                $psc = {bo:'3px dotted #784'};
                psc.bolw = '19px';
                sc&slope &&
                    me&J,['slope','-od',{s:sc&slope.map(n=>n.t)},psc];
                ss&solvey &&
                    me&J,['solvey','-od',{s:ss&solvey,forit:'C'},psc];
        }
        each in M {
            n.t == 'k' and ns&hs ||= 748
        }
        A.ground = C;
        #n scan 8 $s:ki(d) %hs:857
    };
    #c a non-ind d, osc data tool
    $obs = {
        C:{ks:'t y c sc'.split(' ')},
        A:{as:'C',but:'d.ks>4'},
        J:{as:'A',but:'s.1==s'},
        netty:{as:'JA',ks:'1 2 3 4 5'.split(' '),swal:'netty'}
    };
    $arin = &sz{
        return 0 <= z.indexOf(s)
    };
    me.scan = &acgts{
        $d = {s:s};
        if (s instanceof Array) {
            d.sym = '[';
            d.ks = [];
            each kv s {
                d.ks.push(k);
            }
        }
        elsif (typeof s == 'object') {
            d.sym = '{';
            d.ks = [];
            each kv s {
                d.ks.push(k);
            }
        }
        elsif (typeof s == 'string' || typeof s == 'number') {
            d.sym = "'";
            d.isp = ki(s);
        }
        elsif (typeof s == 'function') {
            d.sym = "&";
            d.isp = ki(s);
        }
        else {
            d.sym = '?';
            d.isp = ki(s);
        }
        if (d.sym == '{') {
            $M = d.modu ||= [];
            # apply some observations
            each tD obs {
                if (D.ks) { # keys to have
                    $match = 0;
                    each ik d.ks {
                        # see 
                        0 <= D.ks.indexOf(k) and match++
                        elsif (!D.swal) {
                            $wk = d.weirdkeys ||= [];
                            wk.push(k);
                        }
                    }
                    if (match == D.ks.length) {
                        if (D.swal) {
                            # group some details:
                            # envelopes some d.ks with a d.modu[C]
                            # eg netty, keys 1-5
                            # swallows 1-5 from d.weirdkeys (misfits for C)
                            # and d.ks, keys shown
                            # < diving in, bursting the representation,
                            #   the illusion becoming items in the medium
                            $r =
                            m $D.swal  $s:s %swal
                            rs&ks = D.ks;
                            d.weirdkeys = d.weirdkeys.filter(k=>!arin(k,D.ks));
                            d.ks = d.ks.filter(k=>!arin(k,D.ks));
                            #A.1.t == 'delicio' and debugger
                        }
                        else {
                            d.is = t;
                            d.ks = d.ks.filter(&k{
                                return 0 > D.ks.indexOf(k);
                            });
                            $ks = D.ks.slice().reverse();
                            each ik ks {
                                d.ks.unshift(k);
                            }
                        }
                    }
                }
                D.as && !D.as.includes(d.is) and continue
                D.but == 'd.ks>4' && d.ks.length > 4 and d.is = t
                D.but == 's.1==s' && s.1 == s and d.is = t
                d.is == 'A' && s.y == s and d.ks = d.ks.filter(&k{ return k != 'y' });
                d.is == 'C' and d.C = 1
            }
            if (d.weirdkeys) {
                $r =
                m weirdkeys  $s:s %swal
                rs&ks = d.weirdkeys;
                d.ks = d.ks.filter(k=>!arin(k,d.weirdkeys));
            }
            !d.modu.length and delete d.modu
        }
        return d
    };
    #c alabroise netty
    me.weirdkeys = &acgts{
        $M = s&z = [];
        $ks = s&ks;
        s&ml = 1;
        #m weirdkeys  $s:ki(ks) %dis,hs:490
        each ik ks {
            m wk_k  $s:k %hs:748
            m wk_v  $s:ki(s[k],3) %fs:8
        }
    };
    me.netty = &acgts{
        # osc app? prints netname relative to surrounding netnames
        # borrowed from 251 ki
        # split out A.\d, points on wormhole slope
        $ks = [];
        each kv s {
            k.match(/^\d+$/) and ks.push(k);
        }
        !ks.length and return
        # crunch them together implicitively
        ks = ks.sort();
        $Js = [];
        $la;
        $is = [];
        $isness = &{
            !is.length and return
            E.push(is.length == 1 ? is[0] : is.shift()+'-'+is.pop())
            is = [];
        };
        # n->s match, call it again (eg 1+3) by its lowest number
        $has = [];
        $hast = [];
        $E = [];
        #debugger;
        each in ks {
            n *= 1;
            $v = s[n]; #]
            v.1 != v and throw "JnetnotJ"
            
            if (v == s) {
                is.push(n);
                la = v;
                continue
            }
            isness();
            if (la == v) {
                continue
            }
            $st = v;
            # call it again (eg 1+3) by its lowest number
            $was = has.indexOf(v);
            if (was >= 0) {
                st = was;
            }
            has[n] = v;
            hast[n] = st;
            E.push(st);
            la = v;
        }
        isness();
        
        if (has.4 == A.4 && has.5 == A.5) {
            # omit .Four.Five if simple
            hast.4 == A.4 && hast.5 == A.5 and E.pop(); E.pop();
        }
        
        $netname = [];
        each id E {
            typeof d == 'object' and d = d.t
            netname.push(d);
        }
        netname = netname.join('.');
        
        s&fs = 6;
        s&hs = 848;
        $M = s&z = [];
        #netname += "\n";
        m netname  $s:netname
    };
    
    #c way
    
    # to receive way notifies
    me.Ja.digwaypoll = &acgt{
        A&o = 'IndofC';
        1c&eyei ||= 0;
        c&ieye = 1c&eyei++;
        
        $w = A.5.I.w;
        4s&raw.push('A.53: '+ki(A.1));
        
        $ws = me&ws,A.1.t;
        wsc&open = &w{
            # assert what we care about
            each ti me.importo {
                me&waytime,t,null;
                w.send(t);
            }
        };
        wsc&receives = &l{
            each is l {
                me&upghost,s
            }
        };
    }
    me.waytime = &acgtts{
        $wa = A.5.I.w; # alien stash
        !wa and throw "no wa", t
        $w = wa.y.tw[t]; # has G&ways we use
        !w and throw "no w", t
        s == null and s = G&time + 3600
        ws&now = s; # unixtime, forces update
    };
    me.upghost = &acgtt{
        t ||= 'Soogle';
        me&waytime,t,1;
        4s&upghost ||= [];
        4s&upghost.indexOf(t) < 0 and 4s&upghost.push(t)
    };
    # < merely starts fetching new copy
    #   next frame will carry out the update
    $w = me.importo = {};
    # the way to trigger, or simply the way to trigger
    w.Soogle = 1;
    w.Packle = 1;
    w.Coffle = 1;
    
    me.doupghost = &acgt{
        each it 4s&upghost {
            # make sure it's out of date
            me&waytime,t,1;
            # noop, ttl = 1 hour
            $cb = &t,ar,w{ ws&now = G&time + 3600 };
            G&way,t,{},cb;
            !w[t] and continue
            4s&downghost ||= [];
            4s&downghost.indexOf(t) < 0 and 4s&downghost.push(t)
        }
        delete 4s&upghost
    };
    me.dodownghost = &acgt{
        each it 4s&downghost {
            ~>3 downung: t
            G&way,t
            ~>3 downund//1: t
        }
        delete 4s&downghost
    };
    
    #c random
    me.heading = &acgts{
        s && s.slice(-1) == '3' and s = s.slice(0,-1); A.3 = A.1;
        $n = G&n,['t',0.01,{s:C.t},{ab:1,zi:-20}];
        ns&fs = A.1 == A.3 ? 19 : 13;
        ns&mt = '-0.7';
        #ns&dow = 'do/Shrinkage';
        
        $r = C;
        rs&mt = '1em';
        rs&mih = '2em';
        
        rs&dis = 'block';
        #A.1 == A.3 and rs&width = '50%';
        
        if (s) {
            if (s == '55') {
                rs&left = '50%';
                rs&width = '100%';
                rs&ab = '1';
            }
            elsif (s == 'pac') {
                1s&count ||= 0;
                $count = ''+1s&count++;
                n i  $s:count %medo:Jause
                if (1s&pausing) {
                    n paused  s:paused %medo:Jause
                    1s&paused = 1;
                }
            }
            else {
                throw "unknown heading style", s
            }
        }
    };
    me.Jause = &acgtD{
        $Y = D.y.A;
        Y = Y.1;
        Ys&pausing = !Ys&pausing;
        !Ys&pausing and delete Ys&paused
    };
    
    # suggest y.cv of 30i+
    me.cvdeal = &acgtMv{
        v ||= 3;
        v >= 1 and v /= 10
        each in M {
            n.y.cv and continue
            n.y.cv = G&desca,v,8;
            v += 0.001;
        }
    };
    
    # Mw - named M, generated Catchment
    # R spawn grits into these trays
    #   may datagram them to sleep
    # and use them to intro more R, when asyncable
        # how much to draw/fall in...
        #  these M might be named in future,
        #  compositive to 3s&Me, a tv of M bits
        #    good shape for magazine ladel
    me.Mw = &acgtR{
        Rs&Mw ||= {};
        $M = Rs&Mw[t] ||= [];
        return M
    };
    # the idea of collapsing named M, assigning to 3-ish
    #   sorting expensively
    me.Mwix = &acgtR{
        $M = [];
        (Rs&M || Rc&M || []).map(n => M.push(n));
        if (Rs&Mw) {
            each win Rs&Mw {
                #M.indexOf(n) >= 0 and continue
                M.push(n)
            }}
        }
        inM: while (1) {
            each in M {
                !n.c.not and continue
                M = M.filter(&t{
                    return !(t == n || n.t == t.t
                    && n.y.cv == t.y.cv)
                });
                continue inM
            }
            break
        }
        me&cvdeal,M;
        $N = [];
        each in M {
            me&sortin,N,n;
        }
        Rs&M and Rs&M = N
        else { Rc&M = N }
    };
    
    # insert C to z after cv ==, before cv >
    me.sortin = &acgtzC{
        $i = 0;
        while (1) {
            $s = z[i];
            !s and return z.push(C)
            C.y.cv < s.y.cv and return z.splice(i,0,C)
            i > 100 and debugger;
            i++;
        }
    };
pi/god: | # surf all
    # #
    #
    n t  $s:C.t %fs:45

