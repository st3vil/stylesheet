Zequines: | # 1 centered self process
    # how A
    n Atool
    # tube helpers
    n To
    # tubes of self
    n Tubes
Atool: | # reliable/old A
    u i
    # snake outwards by A.up
    # < move other ways
    # verging on FactorEaseity
    Aup:
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        wantarray ? @A : join' ',reverse map{_.t} @A;
        
    # sort by many y.As
    sortysip:
        my $so;$so = sub {
            my ($i,@try) = @_;
            my ($yk) = @try;
            my ($c,$d) = (a.y->{$yk},b.y->{$yk});
            $c && $d || return;
            ($c,$d) = (c.c.ip,d.c.ip);
            $c && $d || die "sort noy$yk ip";
            unless (exists $c->[$i] || exists $d->[$i]) {
                shift @try;
                return $so->(0,@try) if @try;
                die "ip sort ran out:\n  ".ki($a)."\n  ".ki($b);
            }
            $c->[$i] <=> $d->[$i]
            || $so->($i+1,@try);
        };
        sort {$so->(0,@Me)} @$s;

    # describe A net
    sn:
        if (ref $s eq 'HASH' && s.y eq $s) {
            ($A,$s) = ($s);
        }
        $s ||= 6;
        my @net = ('y',1,2,3,4,5);
        shift @net if $s < 6;
        pop @net if $s < 5;
        pop @net if $s < 4;
        
        my ($s,$h,$la);
        for my $i (@net) {
            my $Y = $A->{$i} || die "Npo $i on ".ki $A;
            ref $Y eq 'HASH' || die "Got $i from A.t: ".ki $Y;
            my ($cvb) = Y.cv =~ /^0\.(\d+)$/ if $Y eq $A;
            my $sep = '.' if $s;
            $sep = '@' if $la eq $A;
            my $th = Y.t;
            if (my $ii = $h.>$Y ) {
                # number position if seen before
                $th = ','.$ii;
                $sep = '';
            }
            $h.>$Y ||= $i;
            if ($la eq A.2) {
                # can go funny directions
                if ($la ne A.5 && $la ne A.4 && la.3 ne A.3) {
                    # J inherit 12345 before its set right
                    $sep = "(".($la eq la.3 ? "" : "la.3.t)");
                }
            }
            $s .= "$sep$th$cvb";
            $la = $Y;
        }
        $s =~ s/\(,/(/g;
        $s
    
To: | # party controls
    u i
     # for tubes of rhythm
    # A transfiguring A
    
    # complicated delete
    Tnot:
        A.cv = 0.9;
    # moves/spawns in time (cv)
    # eventually T.Z.56.3 = [$C] or $A means when pipe is at 56 do from 3
    Tz: %acgt:D
        my ($to,$ba) = keys %{T.Z};
        $ba && die "Too many TZ: ".ki [sort keys %{T.Z}];
        my $wh = delete T.Z.>$to;
        delete T.Z;
        $wh eq $A || die "Too complic TZ: ".ki T.Z;
        $to /= 10 while $to > 1;
        A.cv = $to - 0.001;
        T.nocvz = 1;
    # catch up children every 0.1 (before our 0.1)
    tugA:
        $s = G&A,$s,@Me;
        G&entug,$s;
        $s
    entug:
        my $o = A.c.tug->{s.c.sip};
        A.c.tug->{s.c.sip} = $s;
        delete A.c.tog if $o ne $s;
        $s
    # TODO go wide by 0.1?
    tug:
        my $og = A&tog ||= [sort keys %{A&tug}];
        saybl "A&sip A.t tugs $s -> ".@$og;
        for (@$og) {
            my $m = A&tug.>$_;
            next if my&cv >= $s;
            next if mc&tugblock && mc&tugblock->();
            my $A = $m;
            A&ov = $s;
            G&throat
        }
    block:
        A&tugblock = $s;
        $s->();
    timer: %acgt:d cb
        Mojo::IOLoop->timer($d,$cb);
Tubes: | # G&A spawns A, G&throat progresses A, working on C
    u i
    # be a A.y = A (means is full of wires)
    # J are A that inherit from each other
    # as A wave connection to them
    A: %acgt:s ov c sc
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            A.up = $i;
            A.c.ip = [@{A.up.c.ip||[]}, A.up.c.ipi++];
            A.c.sip = join' ',@{A.c.ip};
            delete A.V if A.V == 2;
            delete A.C;
            delete A.T;
            trip At/$s
            saygr "A.c.sip A.t from i.t";
        }
        %{A.c} = (%{A.c},%$c) if $c;
        %{A.sc} = (%{A.sc},%$sc) if $sc;
        @Me && die "No more trailing A Me: ".ki \@Me;
        if ($ov) {
            $ov /= 10 while $ov >= 1;
            A.c.ov = $ov;
            G&throat;
        }
        return $A

    # go A - rows a T
    # .t a We thing to actuate consciousness
    # net look up to 3
    throat:
        $T = A.c.T ||= {};
        return if T.not;
        $s ||= A.c.of || A.t;
        my $z = G&t,$s
            || return sayre "Not found: $s: ".G&sn;
        #snooze 500;
        my $uov = A.c.ov;
        my $ntug = 0.1;
        my $keep; # going many same cv
        while ($z) {
            next if z.c.W;
            next if z.y.cv <= A.y.cv && (!$keep || z.y.cv > keep.y.cv);
            $keep = $z;
            
            say "For A.cv - $uov ( z.y.cv z.t (A.t)";
            
            last if $uov && z.y.cv > $uov;
            my $etug = $ntug;
            if (A.c.tug && $ntug <= z.y.cv) {
                $ntug += 0.1 until $ntug >= z.y.cv;
                G&tug,$ntug;
            }
            my $C = A.c.s ||= {y=>{A=>$A}};
            my @is = (A.c.N || $z);
            
            # z wants C.?.?
            if (zs&nk) {
                exists $C.>zs&nk || next;
                @is = $C.>zs&nk;
                if (zs&gk) {
                    exists $C.>zs&nk.>zs&gk || next;
                    @is = $C.>zs&nk.>zs&gk;
                }
            }
            # z wants anything more from C, compiles to ip
            if (zs&t) {
                ref zs&ip eq 'HASH' || die "Dsct ip not: ".ki$z;
                # whole z.sc could arg/solute things
                my $sc = z.sc;
                my $u = {};
                G&ip,zs&ip,$C,$u || next;
                my @u = grep{defined} map{_.s} values %$u;
                if (@u > 1) {
                    sayre "Many picked via ".ki(sc.ip).":\n".ki $u;
                    @u = $u[0];
                }
                @is = @u if @u;
            }
            
            # z readies
            if (z.sc.acgt && !z.c.code) {
                my $y = eval z.c.s;
                die "Throcompile z.y.cv: z.t: ".ind('  ',$@)."\n" if $@;
                z.c.code = $y;
            }
            #
            say "A.c.sip \t Onto A.t A.y.cv ~ C.t ~ z.t z.y.cv";
            T.D = $z;
            trip Acv/z.y.cv
            $z = T.D;
            #
            # happens
            for my $s (@is) {
                z.sc.acgt eq 's' || die "nonacgts".wdump $z;
                T.D = $z;
                my $y = z.c.code;
                ref $y || die "Compile z.y z.y.cv!";
                G.i.h->($A,$C,$G,$T,$z,$s);
                
                T.ut && G&Tut,$s;
                T.Z && G&Tz,$z;
                G.tuberay && G.tuberay->($A,$C,$G,$T);
                T.whack = T.nocvz = delete T.whock if T.whock;
                last if T.not || T.whack;
            }
            # back
            delete T.ut;
            
            A.y.cv = z.y.cv unless delete T.nocvz;
            last if delete T.whack || T.not || T.seek;
        }
        continue {
            $z = z.y.in || z.y.next; # or timeout, mass comb via A.m
        }
        if (delete T.seek) {
            return G&throat;
        }
        # leaving
        A.c.tug && G&tug,A.y.cv;
        delete A.c.ov;
        T.not && G&Tnot;
        saybl "A.c.sip \t<--  A.t A.cv";
        # TODO cycle all A.c.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    
    

