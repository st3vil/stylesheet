pi/map: | # volts above list of names
    # make list of reorderable names
    # vanishings live in the nearest -orphanage
    Jc&origin = c&o || die "no origin?";
    s.y && s.y.cv == 0.9 || die "What is s? ".ki $s;
    my @z = @{ss&z};
    # sembla t/t y/t com
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:mapin';
    #sc.width = 4;
    #sc.height = 3;
    sc.dig = s&dig if s&dig;
    my $s = join "\n", map {_.t} @z;
    n "z fo" =>1 =>{s=>$s},$sc
    
    y.at.cssdel = 'transform';
mapin: | # rearrange names of -way
    # like codein but taking reordering -way's $M
    # sho
    my $o = jc&origin;
    # deals pi
    my $z = [grep{_s&pi}@{os&z||[]}];
    my $pi = do { # what kind of pi
        my $pitw;
        $pitw.>$_ ++ for map {_s&pi} @$z;
        keys %$pitw == 1 || die "many kinds of pi: ".ki$pitw;
        (keys %$pitw)[0]
    };
    
    my $tw; # the bunch of pins it has
    $tw.>_.t = $_ for @$z;
    
    # new order of pins
    my $s = us&code || die "Nocode to mapin";
    my @l = grep{length}split "\n", $s;
    
    my ($h,$new,$gone);
    my $M;
    for (@l) {
        $h.>$_ ++;
        if ($tw.>$_ ) {
            m $tw.>$_
        }
        else {
            m $_=>''
            $new.>$_ ++;
        }
    }
    $gone.>$_ ++ for grep{!$h.>$_ }keys %$tw;
    
    for my $C (@$M) {
        next if sÏ€
        # look for the name in an orphanage 
        
        # otherwise...
        # the intake method should handle no c.s as an empty item
        # for way that means it's '# <'
    }
pi/worms: | # G.t enTrances
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    my $s = C.t || die "nowhere"; # our c&s disappears...
    n lies=>-lise_1=>$s,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    # each t shows its uniqueness beyond its parent
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            $C = Rw Min/bits + $dos=EatPi;
            s&pi = 'worm';
            s&ma = 0.1;
            if (c&depth) {
                # short
            }
            else {
                c&s = $1 if C.t =~ /^\Q$s\E\/([^\/]+)$/;
                s&ml = 0.4;
            }
            s&fs = 17 - 4 * c&depth;
            s&fs = 3 if s&fs < 3;
            delete s&ml;
            delete s&dis;
        }
    }
pi/worm: | # the enTrancement of G.t
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    Jc&ETmode = 2;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    my $f = C.t;
    $f =~ s/^s\/// || die "-worm not in s: $f";
    
    
    
    # can locate 
    n w=>-wormin=>{f=>$f},qz
    #,qz
    
    # < sleep these on o of the y.C we are
    
    n ways=>-ways_2=>{s=>T.op}
    
    Rw EditLatter;
    
    
EditLatter: | # Alterate into editing the last pi form
    # in t only list, allowing easy rejig
    # collect orphans
    #   names get started as "#", or alienated
    #      zap them back in when put somewhere else on this Te
    
    # when title is shift-clicked
    1s&Simp = 'Alterate';
    return unless 1c&Alterating;
    # qz the last C entered, edit it
    my $t = T.op;
    my @z = Rw fe/since;
    my @pi = grep {_s&pi} @z;    
    @pi != 2 && die "editing for 2 pi process: ".ki \@pi;
    # o: origin, should have pi/*/intake
    # l: pose, probably -way
    my ($o,$l) = @pi;
    l.t eq t.t || die "last since not T_op".ki[$l,$t];
    
    ls&qz = 1;
    
    n wedit=>-od_3=>{s=>[os&J.sc.top.sc.z,ls&J.sc.top.sc.z]}
    
    n edit=>-map_4=>{o=>$o,s=>$t}
    
Alterate: |
    sayyl "Altering j.t on J.t";
    jc&Alterating = !jc&Alterating;
    3c&ET &&
    Rw ET 2;
pi/wormin: | # open anything useful
    # what 1-2
    # how 2-3
    # ways 3-4
    # shapes 4-5
    Rw fe/since;
    my $v =
    n c&f=>''=>{W=>c&f,pin=>'WormCo',Wea=>'Co'}
    my $j = vs&J;
    my ($w) = grep{_.t eq 'w'} 
        Rw fe/since their;
    
    my $s = join"\n", G&ind,$w,'aC';
    n c&f=>''=>{s=>$s}
    n "c&f od"=>-od=>{s=>$w}
    
    y.n = 3;
    y.u = 4;
    for my $o (@{ws&z}) {
        my $C =
        m $o
        s&pi = 'ofw';
    }
    # be the source of these...
    
    
pi/wormin/intake: | # write worm  from $M
    # collect M, elvis to WormCo
    die"Send -ofw, got: ".join("-",map{_s&pi}@$M)."
        ".ki$M 
    unless @$M && @$M == grep{_s&pi eq 'ofw'} @$M;
    
    G&give,Budge=>[ofw_intake=>''=>{s=>$M}];
WormCo: | # be another
    # receive updates to self via elvis
    
    saybl "WormCo C.t  A&must_save_in ".ki Js&top && Js&top.sc.z;
    delete Js&M;
    Rw FeedTape;
    delete _c&J for @$M;
    #@$M = grep { _.t eq 'w' } @$M;
    return;
    #glap: %of:w
    #    figuration
FeedTape: |
    if (!Js&M) {
        # init saved/feedback
        my $t = Js&top;
        my $M = Js&M = [];
        m $_ for @{ts&z||[]};
    }
    m $_ for @{Js&M||[]};
    
    #delete _.y.cv for @$M;
    _c&pi = delete _s&pi for grep{_s&pi} @$M;
    
    #_s&mix = 1 for @$M;
    
    Rw DeStyleM;

