pi/worms: | # G.t enTrances
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    my $s = C.t || die "nowhere"; # our c&s disappears...
    n lies=>-lise_1=>$s,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    # each t shows its uniqueness beyond its parent
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            $C = Rw Min/bits + $dos=EatPi;
            s&pi = 'worm';
            s&ma = 0.1;
            if (c&depth) {
                # short
            }
            else {
                c&s = $1 if C.t =~ /^\Q$s\E\/([^\/]+)$/;
                s&ml = 0.4;
            }
            s&fs = 17 - 4 * c&depth;
            s&fs = 3 if s&fs < 3;
            delete s&ml;
            delete s&dis;
        }
    }
pi/worm: | # the enTrancement of G.t
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    Jc&ETmode = 2;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    my $f = C.t;
    $f =~ s/^s\/// || die "-worm not in s: $f";
    
    
    
    # can locate 
    my $w =
    n w=>-wormin=>{f=>$f},qz
    #,qz
    $w = delete wc&win; # the W=$t
    
    # < sleep these on o of the y.C we are
    my $z = T.op;
    #n waysev=>-od_13=>{s=>$z}
    #n "C.t win"=>-od_15=>{s=>$w}
    n ways=>-ways_2=>{s=>$z}
    
    Rw EditLatter;
    
    
pi/wormin: | # open anything useful, to -ofw
    Jc&save = Jc&tape = 1;
    y.n = 3;
    y.u = 4;
    y.res = 100;
    1s&piduces = 'ofw';
    # sources 1-2
    # how 2-3
    # ways 3-4
    # shapes 4-5
    Rw fe/since;
    my $t = c&f || die "Send cf";
    my $v =
    n $t=>''=>{W=>$t,pin=>'WormCo',Wea=>'Co'},'noii'
    
    my $j = vs&J;
    my ($w) = grep{_.t eq 'w'} 
        Rw fe/since their;
    
    c&win = $w;
    if (1 == 8) {
        my $s = join"\n", G&ind,$w,'aC';
        n c&f=>2=>{s=>$s}
        n "c&f od"=>-od_2=>{s=>$w}
    }
    #return;
    
    for my $o (@{ws&z}) {
        my $C =
        m $o
        delete C.y.cv; # isolate Swim's ||= 0.1
        #delete s&of;
        s&pi = 'ofw';
    }
    # be the source of these...
    
    
pi/wormin/intake: | # write worm  from $M
    # collect M, elvis to WormCo
    my $t = j.t; # here is the -worm
    my $f = "s/$t";
    -d $f || die "$f not there! am j.c.s.sc.pi ".G&sn,$j;
    
    # New names-only want to be inflated to empty
    for (@{ar.N||[]}) {
        # make copy that will be in -codetta form,
        # convert that to -code to get yaml around it
        # < rename -code -ycode?
        die "Making blank _.t?";
        my $C = G&hup,$_;
        s&pi ||= 'codetta';
        c&s ||= "#";
        s&note ||= "new";
        my $M = [$C];
        my $o = Rw pi/codetta/to/ofw $M;
        G&xo,$_,$o;
    }
    
    
    Rw cz/M $M $pi=ofw;
    
    G&e:$t=>W=>{W=>$t,pin=>'WormCo',Wea=>'Co',e=>G&Ct,[M=>''=>{M=>$M}] };
    
    G&give:Budge=>[ofw_intake=>''=>{s=>[G&sn,$j ,j.c.s.sc.pi, $w,$o,$M]}];
pi/codetta/from/ofw: | # -ofw to M-codettas
    my $o = $s;
    os&pi eq 'ofw' || die "to codify from -os&pi";
    # < option to not, edit whole yaml chunk
    # < centralise code splits with underneaths of Bablar?
    my $hashc = '#'.'c';
    my @l = split "\n",oc&s;
    # last atom/beginning, with title, note, etc...
    my $n = G&Ct,[o.t=>-codetta=>{},{%{o.sc}}];
    
    my $i = 0;
    for my $l (@l) {
        $i++;
        # is it a chunk heading
        my $t = $1 || $2 if $l =~ /^([\/\w]+):|$hashc.*?(\w\w+)/;
        $t && $1 && $n && die "seems to have ways in way: ".ki($n)."\n line $i: $l";
        
        if ($t) {
            my ($pren,$note) = split /\b\Q$t\E\b/, $l, 2;
            s/^: \|//
            # keep leading whitespace? indent the hashc or the comment after...
            ,s/^\s*//, s/^\s*$hashc\s*//,
            s/# // for $note;
            $n =  
            m $t=>-codetta=>{}
            ns&note = $note if length $note; # other notes e
            ns&prenote = $pren if length $pren; # never?
            #sayyl "Sectioned by $l\n    n: ".G&aC,$n;
            # title is outside the babble, in named bubble code (yaml)
            next;
        }
        $n || die "No title line $i: $l";
        
        push @{ns&l||=[]}, $l;
    }
    
    for (@$M) {
        _s&l || die "Nothing in _.t?";
        _c&s = join "\n", @{delete _s&l};
        _c&s .= "\n" if _c&s =~ /[^\n]$/;
        _s&dige = slm(12, dig _c&s); # chunk of way, sans indent dige
    }
    
    
    G&give,Budge=>[madeup=>''=>{s=>$M}];
    die "madeup";
pi/codetta/to/ofw: | # REVERSE M-codettas to -ofw
    # as -code without the yaml surround/indent
    my $hashc = '#'.'c';
    my $M = [grep{_c&pi eq 'codetta' || _s&pi eq 'codetta'} @$M];
    my ($f) = @$M;
    my $o;
    o.t = f.t;
    
    my @l = (
        map {
            my @l = split "\n", $_;
            pop @l while @l && $l[-1] =~ /^\s*$/;
            @l
        }
        map {
            my @l;
            if ((_s&note || _s&pren) && $_ ne $f) {
                @l = (_s&pren||"")."$hashc".(_s&note&&" # _s&note")
            }
            (@l, _c&s)
        } @$M
    );
    oc&s = join "\n", @l;
    oc&s .= "\n" if oc&s !~ /\n$/;
    
    o.sc = {%{f.sc}};
    # s&note etc must come too, but not randomness
    Rw DeStyleM $M:o $etc=1;
    # should be same unless chunky (@$M > 1)
    os&dige = slm(12, dig oc&s);
    os&pi ||= 'ofw';
    $o
    
WormCo: | # be another
    # receive updates to self via elvis
    # run/elvised eg:
    #   G&e:$t=>W=>{W=>$t,pin=>'WormCo',Wea=>'Co',e=>G&Ct,[M=>''=>{M=>$M}] };
    # which is similar to there being a 
    saybl "WormCo C.t  A&must_save_in ".ki Js&top && Js&top.sc.z;
    Rw FeedTape;
    if (my $m = e&cM ) {
        sayyl "To install: ".ki $m;
        @$M = ();
        m $_ for @$m;
        _.y.cv = '' for @$M;
        _s&of ||= 'w' for @$M;
        Jc&save = 'once';
    }
    delete(_c&pi), delete _s&pi for @$M;
    saygr "We C.t: ", map { G&aC,$_ } @$M;
    Jc&save = 1;
    @$M = grep { _.t ne 'w' } @$M;
    return;
    glap: %of:w
        figuration
    
    
    # dige any way sitting here?
Knows: | # be a j within another J
    #
    
    
    #

