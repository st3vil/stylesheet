EditLatter: | # Alterate into editing the last pi form
    # in t only list, allowing easy rejig
    # collect orphans
    #   names get started as "#", or alienated
    #      zap them back in when put somewhere else on this Te
    
    # when title is shift-clicked
    1s&Simp = 'Alterate';
    return unless 1c&Alterating;
    # qz the last C entered, edit it
    my $t = T.op;
    my @z = Rw fe/since;
    my @pi = grep {_s&pi} @z;    
    @pi != 2 && die "editing for 2 pi process: ".ki \@pi;
    # o: origin, should have pi/*/intake
    # l: pose, probably -way
    my ($o,$l) = @pi;
    l.t eq t.t || die "last since not T_op".ki[$l,$t];
    
    ls&qz = 1;
    # hide usual listing $l and -map the $o-rganism it is from
    # or maybe it's better to -map the $l, if it's a more useful subset?
    # but we go with editables being in cv 3-4
    #  G&op,3 returns them when T.op = os&Js&top
    # $o herein means this os&J
    
    n edit=>-map_4=>{s=>os&J}
    
Alterate: |
    sayyl "Altering j.t on J.t";
    jc&Alterating = !jc&Alterating;
    3c&ET &&
    Rw ET 2;
pi/map: | # volts above list of names
    # make list of reorderable names
    # vanishings live in the nearest -orphanage
    
    # the J whose s&tops&z is to be rearranged
    my $o = Jc&organism = $s || die "no organism?";
    o.y eq $o || die "organism not J: ".ki $o;
    
    local T.op = os&top || die "notop on o.t";
    my @z = G&op,3;
    
    # sembla t/t y/t com
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:mapin';
    #sc.width = 4;
    #sc.height = 3;
    sc.dig = s&dig if s&dig;
    my $s = join "\n", map {_.t} @z;
    n "z fo" =>1 =>{s=>$s},$sc
    
    y.at.cssdel = 'transform';
mapin: | # rearrange list of names
    # like codein but taking reordering -way's $M
    # sho
    my $o = jc&organism || die "No organism on: ".G&sn,$j;
    o.y eq $o || die "o should be J: ". $o;
    my $opi = oc&s.c.pi || die "o should be pi, moC: ".ki oc&s;
    
    local T.op = os&top || die "notop on o.t";
    my $z = [G&op,3 ];
    # deals pi
    my $pi = do { # what kind of pi
        my $pitw;
        $pitw.>$_ ++ for map {_s&pi} @$z;
        keys %$pitw == 1 || die "many kinds of pi: ".ki$pitw;
        (keys %$pitw)[0]
    };
    
    my $tw; # the bunch of pins it has
    $tw.>_.t = $_ for @$z;
    
    # new order of pins
    my $s = us&code || die "Nocode to mapin";
    my @l = grep{length}split "\n", $s;
    
    my ($h,$new,$gone);
    my $M = [];
    for (@l) {
        $h.>$_ = do {
            if ($tw.>$_ ) {
                m $tw.>$_  
            }
            else {
                $new.>$_ =
                m $_=>''  
            }
        }
    }
    $gone.>$_ = $tw.>$_ for grep{!$h.>$_ }keys %$tw;
    
    # explicitly renamed things, subset of $M, with s&twas
    # see pi/codolf/intake, because t is hard coded for -code
    # and we dont wanna re -code when renaming
    my $R = [];
    if (keys %$gone == 1 && keys %$new == 1) {
        # swap em in, called Chem in fe/Nab
        my ($g,$n) = (values %$gone, values %$new);
        (n.c,n.sc) = (g.c,g.sc);
        ns&twas = g.t;
        push $R, $n;
    }
    else {
        # goners orphaned
        my $se = [grep{$gone.>_.t } @$z];
        @$se &&
        G&elph,Orphanage=>["j.2.2.t/j.2.t"=>-orphan=>{s=>$se}];
    }
    
    my $N = []; # explicitly new things, subset of $M
    for my $C (@$M) {
        next if s&pi ;
        # look for the name in an orphanage
        # < the origin/above could have its own
        Rw fe/Nab $C $W=Orphanage;
        #Rw NabOrphan $C if $orphans;
        next if s&pi ;
        # otherwise...
        # the intake method should handle no c.s as an empty item
        # for way that means it's '# <'
        push @$N, $C;
    }
    
    # apply organising to organism
    Rw pi/$opi/intake + $j:o.2 $M $N $R;
    
    # turn off -map
    Rw Alterate + $j:j.2;
    # ^ generates ET as well as v
    # < see them merge
    # the un-qz of the -way/display is not understood?
    o.2.c.imping++;
    3c&ET &&
    Rw ET + $wake:o 1;
cl/Wake: | # the impulse to wake a vector
    # should allow ETing or similar?
    # collect that other thing again
    for (@{ar.m}) {
        if ($_ eq 'casually') {
            ref $W && die "Wake ref W may misshape 4 cto?";
            G&timer:0.1,&{ 4s&toy->({to=>[$W]}) };
        }
        else {
            die "Dont know how to wake $_";
        }
    }
fe/Nab: | # select from $W using index definition and $C for parameters
    # work in progress, work die out
    #  loop to recurse any index
    #   wants to be under large map functions/o
    my $o =
    n $W=>V
    my $j = os&J || return;
    
    # choose which index to use
    my $ind = js&indexen;
    $ind && values %$ind == 1 || die "strange $W sc_indexen: ".ki$ind;
    my ($k,$i) = %$ind;
    my $or = j.sc.>$k || die "no index $k on $W";
    
    # look at the definition of that index
    my $in = [@$i];
    my $it = pop @$in; # how to handle the item
    @$in == 2 || die "$W $k must be 2sphere, not: ".ki $in;
    $in->[0] =~ /\*$/ || die "$W $k step 1 must be glob, is $in->[0]";
    $in->[1] eq 't' || die "$W $k step 2 must be t, is $in->[1]";
    
    # < should work off tv as well as this shady $or
    for my $f (keys %$or) { # or $in[0]
        my $rp = $or.>$f;
        my $g = $rp.>C.t; # or $in[1]
        $g || next;
        
        for my $do (split '-', $it) {
            if ($do eq 'Chem') {
                (C.c,C.sc) = (g.c,g.sc);
            }
            elsif ($do eq 'leaves') {
                delete $rp.>C.t;
                delete $or.>$f if !keys %{$or.>$f };
                Rw cl/Wake $W casually;
            }
            else {
                die "unknown doing $do for $W index $k: @$in $it";
            }
        }
        last;
    }
    #
Orphanage: | # (pi) objects apparently vanishing from other places
    Rw Tiot;
    # so they can be got back when their name turns
    #   up in a slighly different place
    Js&ein.pi.orphan.sMJ = &sMJje{
        my $z = ref $s eq 'ARRAY' ? $s : [$s];
        my $or = Js&orphans ||= {};
        my $fr = $or.>e.t ||= {};
        $fr.>_.t = $_ for @$z;
    };
    S
    # explains self
    Js&indexen.orphans ||= [qw'from* t Chem-leaves'];
    my $or = Js&orphans ||= {};
    #n roll=>-od=>{s=>$or}
    
    y.n = 3;
    for my $f (sort keys %$or) { # from name
        my $rp = $or.>$f;
        if (!keys %$rp) {
            delete $or.>$f;
            next;
        }
        m $f=>''=>$f=>"fs:7,hs:588,dis"
        for my $t (sort keys %$rp) { # name
            m $t=>''=>$t=>"float:left,ma:0.4"
        }
    }
pi/worms: | # G.t enTrances
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    my $s = C.t || die "nowhere"; # our c&s disappears...
    n lies=>-lise_1=>$s,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    # each t shows its uniqueness beyond its parent
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            $C = Rw Min/bits + $dos=EatPi;
            s&pi = 'worm';
            s&ma = 0.1;
            if (c&depth) {
                # short
            }
            else {
                c&s = $1 if C.t =~ /^\Q$s\E\/([^\/]+)$/;
                s&ml = 0.4;
            }
            s&fs = 17 - 4 * c&depth;
            s&fs = 3 if s&fs < 3;
            delete s&ml;
            delete s&dis;
        }
    }
pi/worm: | # the enTrancement of G.t
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    Jc&ETmode = 2;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    my $f = C.t;
    $f =~ s/^s\/// || die "-worm not in s: $f";
    
    
    
    # can locate 
    n w=>-wormin=>{f=>$f},qz
    #,qz
    
    # < sleep these on o of the y.C we are
    
    n ways=>-ways_2=>{s=>T.op}
    
    Rw EditLatter;
    
    
pi/wormin: | # open anything useful
    # what 1-2
    # how 2-3
    # ways 3-4
    # shapes 4-5
    Rw fe/since;
    my $v =
    n c&f=>''=>{W=>c&f,pin=>'WormCo',Wea=>'Co'}
    my $j = vs&J;
    my ($w) = grep{_.t eq 'w'} 
        Rw fe/since their;
    
    my $s = join"\n", G&ind,$w,'aC';
    n c&f=>''=>{s=>$s}
    n "c&f od"=>-od=>{s=>$w}
    
    y.n = 3;
    y.u = 4;
    for my $o (@{ws&z}) {
        my $C =
        m $o
        s&pi = 'ofw';
    }
    # be the source of these...
    
    
pi/wormin/intake: | # write worm  from $M
    # collect M, elvis to WormCo
    my $f = j.t;
    -f $f || die "$f not there! am ".G&sn,$j;
    
    # New names-only want to be inflated to empty
    for (@{ar.N||[]}) {
        # make copy that will be in -codetta form,
        # convert that to -code to get yaml around it
        # < rename -code -ycode?
        my $C = G&hup,$_;
        s&pi ||= 'codetta';
        c&s ||= "#";
        s&note ||= "new";
        my $M = [$C];
        my $o = Rw pi/codetta/to/code $M;
        G&xo,$_,$o;
    }
    
    Rw cz/M $M $pi=ofw;
    
    G&give,Budge=>[ofw_intake=>''=>{s=>$M}];
cz/M: | # Czech M, check nonempty and all are a certain pi
    my $pi = ar.pi || die "whatnow";
    return if ar.emptyok && !@$M;
    die"Send -$pi, got: ".join("-",map{_s&pi}@$M)."
        ".ki$M 
    unless @$M && @$M == grep{_s&pi eq $pi} @$M;
WormCo: | # be another
    # receive updates to self via elvis
    
    saybl "WormCo C.t  A&must_save_in ".ki Js&top && Js&top.sc.z;
    delete Js&M;
    Rw FeedTape;
    delete _c&J for @$M;
    #@$M = grep { _.t eq 'w' } @$M;
    return;
    #glap: %of:w
    #    figuration
FeedTape: |
    if (!Js&M) {
        # init saved/feedback
        my $t = Js&top;
        my $M = Js&M = [];
        m $_ for @{ts&z||[]};
    }
    m $_ for @{Js&M||[]};
    
    #delete _.y.cv for @$M;
    _c&pi = delete _s&pi for grep{_s&pi} @$M;
    
    #_s&mix = 1 for @$M;
    
    Rw DeStyleM;

