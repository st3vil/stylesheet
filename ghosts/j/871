EditLatter: | # Alterate into editing the last pi form
    # in t only list, allowing easy rejig
    # collect orphans
    #   names get started as "#", or alienated
    #      zap them back in when put somewhere else on this Te
    
    # when title is shift-clicked
    1s&Simp = 'Alterate';
    return unless 1c&Alterating;
    # qz the last C entered, edit it
    my $t = T.op;
    my @z = Rw fe/since;
    my @pi = grep {_s&pi} @z;    
    @pi != 2 && die "editing for 2 pi process: ".ki \@pi;
    # o: origin, should have pi/*/intake
    # l: pose, probably -way
    my ($o,$l) = @pi;
    l.t eq t.t || die "last since not T_op".ki[$l,$t];
    
    ls&qz = 1;
    
    #n wedit=>-od_3=>{s=>[os&J.sc.top.sc.z,ls&J.sc.top.sc.z]}
    
    n edit=>-map_4=>{o=>os&J,s=>$t}
    
Alterate: |
    sayyl "Altering j.t on J.t";
    jc&Alterating = !jc&Alterating;
    3c&ET &&
    Rw ET 2;
pi/map: | # volts above list of names
    # make list of reorderable names
    # vanishings live in the nearest -orphanage
    
    # the J whose s&tops&z is to be rearranged
    my $o = Jc&origin = c&o || die "no origin?";
    o.y eq $o || die "origin not J: ".ki $o;
    
    # anything else whose s&z is to be rearranged
    #   should mirror $o's set but with less complexity?
    #   could be a subset of $o, reorganise only those things...
    s.y && s.y.cv == 0.9 || die "What is s? ".ki $s;
    my @z = @{ss&z};
    # sembla t/t y/t com
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:mapin';
    #sc.width = 4;
    #sc.height = 3;
    sc.dig = s&dig if s&dig;
    my $s = join "\n", map {_.t} @z;
    n "z fo" =>1 =>{s=>$s},$sc
    
    y.at.cssdel = 'transform';
mapin: | # rearrange names of -way
    # like codein but taking reordering -way's $M
    # sho
    my $o = jc&origin || die "No origin on: ".G&sn,$j;
    o.y eq $o || die "o should be J: ". $o;
    my $opi = oc&s.c.pi || die "o should be pi, moC: ".ki oc&s;
    
    local T.op = os&top || die "notop on o.t";
    my $z = [G&op,3 ];
    # deals pi
    my $pi = do { # what kind of pi
        my $pitw;
        $pitw.>$_ ++ for map {_s&pi} @$z;
        keys %$pitw == 1 || die "many kinds of pi: ".ki$pitw;
        (keys %$pitw)[0]
    };
    
    my $tw; # the bunch of pins it has
    $tw.>_.t = $_ for @$z;
    
    # new order of pins
    my $s = us&code || die "Nocode to mapin";
    my @l = grep{length}split "\n", $s;
    
    my ($h,$new,$gone);
    my $M = [];
    for (@l) {
        $h.>$_ = do {
            if ($tw.>$_ ) {
                m $tw.>$_  
            }
            else {
                $new.>$_ =
                m $_=>''  
            }
        }
    }
    $gone.>$_ = $tw.>$_ for grep{!$h.>$_ }keys %$tw;
    
    if (keys %$gone == 1 && keys %$new == 1) {
        # swap em in, called Chem in fe/Nab
        my ($g,$n) = (values %$gone, values %$new);
        (n.c,n.sc) = (g.c,g.sc);
    }
    else {
        # goners orphaned
        my $se = [grep{$gone.>_.t } @$z];
        @$se &&
        G&elph,Orphanage=>["j.2.2.t/j.2.t"=>-orphan=>{s=>$se}];
    }
    
    for my $C (@$M) {
        next if s&pi ;
        # look for the name in an orphanage
        # < the origin/above could have its own
        Rw fe/Nab $C $W=Orphanage;
        #Rw NabOrphan $C if $orphans;
        next if s&pi ;
        # otherwise...
        # the intake method should handle no c.s as an empty item
        # for way that means it's '# <'
    }
    
    Rw pi/$opi/intake $M;
    3c&ET &&
    Rw ET $wake:o 2;
cl/Wake: | # the impulse to wake a vector
    # should allow ETing or similar?
    # collect that other thing again
    for (@{ar.m}) {
        if ($_ eq 'casually') {
            ref $W && die "Wake ref W may misshape 4 cto?";
            G&timer:0.1,&{ 4s&toy->({to=>[$W]}) };
        }
        else {
            die "Dont know how to wake $_";
        }
    }
fe/Nab: | # select from $W using index definition and $C for parameters
    # work in progress, work die out, recurse
    #   wants to be udder of large map functions
    my $o =
    n $W=>V
    my $j = os&J || return;
    
    # choose which index to use
    my $ind = js&indexen;
    $ind && values %$ind == 1 || die "strange $W sc_indexen: ".ki$ind;
    my ($k,$i) = %$ind;
    my $or = j.sc.>$k || die "no index $k on $W";
    
    # look at the definition of that index
    my $in = [@$i];
    my $it = pop @$in; # how to handle the item
    @$in == 2 || die "$W $k must be 2sphere, not: ".ki $in;
    $in[0] =~ /\*$/ || die "$W $k step 1 must be glob, is $in[0]";
    $in[1] eq 't' || die "$W $k step 2 must be t, is $in[1]";
    
    # < should work off tv as well as this shady $or
    for my $f (keys %$or) { # or $in[0]
        my $rp = $or.>$f;
        my $g = $rp.>C.t; # or $in[1]
        $g || next;
        
        for my $do (split '-', $it) {
            if ($do eq 'Chem') {
                (C.c,C.sc) = (g.c,g.sc);
            }
            elsif ($do eq 'leaves') {
                delete $rp.>C.t;
                delete $or.>$f if !keys %{$or.>$f };
                Rw Wake $W casually;
            }
            else {
                die "unknown doing $do for $W index $k: @$in $it";
            }
        }
        last;
    }
    #
NabOrphan: | # remember C.t
    my $W = 'Orphanage';
    my $o =
    n $W=>V
    Rw fe/fi $C sJ stop sz
    my $j = os&J || die "No Orphanage";
    my $or = js&orphans || return;
    for my $f (%$or) { # from name
        if (my $g = delete $f.>C.t ) {
            (C.c,C.sc) = (g.c,g.sc);
            # send update
            Rw Wake $W casually;
            last;
        }
    }
    
    
Orphanage: | # (pi) objects apparently vanishing from other places
    Rw Tiot;
    # so they can be got back when their name turns
    #   up in a slighly different place
    Js&ein.pi.orphan.sMJ = &sMJje{
        my $z = ref $s eq 'ARRAY' ? $s : [$s];
        my $or = Js&orphans ||= {};
        my $fr = $or.>e.t ||= {};
        $fr.>_.t = $_ for @$z;
    };
    S
    # explains self
    Js&indexen.orphans ||= [qw'from* t Chem-leaves'];
    my $or = Js&orphans ||= {};
    #n roll=>-od=>{s=>$or}
    
    y.n = 3;
    for my $f (sort keys %$or) { # from name
        my $rp = $or.>$f;
        if (!keys %$rp) {
            delete $or.>$f;
            next;
        }
        m $f=>''=>$f=>"fs:7,hs:588,dis"
        for my $t (sort keys %$rp) { # name
            m $t=>''=>$t=>"float:left"
        }
    }
pi/worms: | # G.t enTrances
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    my $s = C.t || die "nowhere"; # our c&s disappears...
    n lies=>-lise_1=>$s,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    # each t shows its uniqueness beyond its parent
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            $C = Rw Min/bits + $dos=EatPi;
            s&pi = 'worm';
            s&ma = 0.1;
            if (c&depth) {
                # short
            }
            else {
                c&s = $1 if C.t =~ /^\Q$s\E\/([^\/]+)$/;
                s&ml = 0.4;
            }
            s&fs = 17 - 4 * c&depth;
            s&fs = 3 if s&fs < 3;
            delete s&ml;
            delete s&dis;
        }
    }
pi/worm: | # the enTrancement of G.t
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    
    s&open = 1;
    Jc&ETmode = 2;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    my $f = C.t;
    $f =~ s/^s\/// || die "-worm not in s: $f";
    
    
    
    # can locate 
    n w=>-wormin=>{f=>$f},qz
    #,qz
    
    # < sleep these on o of the y.C we are
    
    n ways=>-ways_2=>{s=>T.op}
    
    Rw EditLatter;
    
    

pi/wormin: | # open anything useful
    # what 1-2
    # how 2-3
    # ways 3-4
    # shapes 4-5
    Rw fe/since;
    my $v =
    n c&f=>''=>{W=>c&f,pin=>'WormCo',Wea=>'Co'}
    my $j = vs&J;
    my ($w) = grep{_.t eq 'w'} 
        Rw fe/since their;
    
    my $s = join"\n", G&ind,$w,'aC';
    n c&f=>''=>{s=>$s}
    n "c&f od"=>-od=>{s=>$w}
    
    y.n = 3;
    y.u = 4;
    for my $o (@{ws&z}) {
        my $C =
        m $o
        s&pi = 'ofw';
    }
    # be the source of these...
    
    
pi/wormin/intake: | # write worm  from $M
    # collect M, elvis to WormCo
    die"Send -ofw, got: ".join("-",map{_s&pi}@$M)."
        ".ki$M 
    unless @$M && @$M == grep{_s&pi eq 'ofw'} @$M;
    
    G&give,Budge=>[ofw_intake=>''=>{s=>$M}];
WormCo: | # be another
    # receive updates to self via elvis
    
    saybl "WormCo C.t  A&must_save_in ".ki Js&top && Js&top.sc.z;
    delete Js&M;
    Rw FeedTape;
    delete _c&J for @$M;
    #@$M = grep { _.t eq 'w' } @$M;
    return;
    #glap: %of:w
    #    figuration
FeedTape: |
    if (!Js&M) {
        # init saved/feedback
        my $t = Js&top;
        my $M = Js&M = [];
        m $_ for @{ts&z||[]};
    }
    m $_ for @{Js&M||[]};
    
    #delete _.y.cv for @$M;
    _c&pi = delete _s&pi for grep{_s&pi} @$M;
    
    #_s&mix = 1 for @$M;
    
    Rw DeStyleM;

