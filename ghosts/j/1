Experience: |
    # wakeup, dome, goto sleep
    # domes build like carpentry
    # force needs ways to build across language
    
    # in: be somewhere you've been betfore:
    A.6.t ||= 'stay';
    # out: bet somewhere else:
    A.7.t ||= 'gou';
    
    # remember aft s
    1c&sang = &acgt{
        local A.V = 2;
        Rw Write;
    };
    
    # wake up now
    Rw Read;
Locate: | # A J and its space
    my $s = ar.s;
    # looking for/center of us
    my @J = ar.t || A.1.t;
    
    # right: our osc page by /s/$s, if not ''
    # layers/partitions upon a piece of the tree
    push @J, s=>$s if $s;
    
    # left up to A.3, Word to the overmind, amongst A.4/G
    # inners join by W(/j/j.t)+
    unless (ar.t || A.1 eq A.3) {
        my $j = A.1;
        while (j.2) {
            $j = j.2;
            unshift @J, j.t=>'j';
            last if $j eq j.3;
        }
    }
    
    # make safe
    s/\W+/-/gs for @J;
    
    # most left, beyond all sense
    my $star = G.c.bay || die "no community of G";
    my $read = ar.read;
    
    # second most left, edge of sense
    my $t; # G having W
    # run cateGories we orGanise chaos into, a Gravity of W
    # G is a moving path, many may have a J
    # there is a moving part between infinity and finity
    # we may work off and onto several G
    # place of work, the worker and the Gallery
    # travelling process sense and wormhole sense                              
    # probably all: A.4.t, same name as worker
    my @search = $read ?
        # 6 for travel instructor
        #     can wire readonly chunks
        # 5 mind factory/stable but not ours to write to
        # 4 for usual reading ourselves
        (6,5,4)
        # 7 for explicit output place, a branch
        # 4 for usual overwriting ourselves
        # with A.8 having a stabilised A.4.t and running tests through forks
      : (7,4);
    # < any of them implementing a more complicated search/resolver
    
    my $f; # path to dir full of head/xo/c/etc files and s/j/etc dirs
    my $gd; # the G dir its in, before Jing
    for my $num (@search) {
        my $j = $A.>$num;
        next if !$j;
        my $jt = j.t;
        $jt =~ s/\W+/-/gs;
        $gd = join '/', $star, $jt;
        $f = join '/', $gd, @J;
        my $e = -e $f;
        $read && !$e && next;
        $t = j.t;
        last;
    }
    
    return if $read && !$t;
    ($f,$gd)
Read: | # the J you're in remembers itself
    # having created a place for it to land
    my $s = ''; # TODO osc channel, api here too Jeneral
    my $f = Rw Locate $s $read=1
        || saybl("Nothing to read A.1.t") && return;
    Jc&read_from = $f;
    #saybl "Read located: $f";
    my $head = "$f/head";
    my $d = 1s&Read.>$head ||= {};
    my $m = (stat $head)[9];
    if (ds&meta.mtime eq $m) {
        # sleep J?
    }
    else {
        -f $head || die "Read no $head";
        $d = LoadFile("$f/head");
        ds&meta.mtime = $m;
        1s&Read.>$f = $d;
    }
    
    return $d
Write: | # the 
    # C is a completed s, Jc&sang = &acgt{ to get here
    c&imp || die "C not completed s: ".ki$C;
    
    my ($f,$gd) = Rw Locate $write=1;
    #saybl "Write located: $f";
    1c&write_to = $f;
    1c&write_bay = $gd;
    
    my $write = &C{
        # forked, C is the top (9)
        `mkdir -p $f`;
        DumpFile("$f/head",$C);
        
        if (my $m = s&meta) {
            # applies to the Reading s
            # separately for map makers
            if (my $xo = m.A.xo) {
                DumpFile("$f/xo",$xo);
            }
            if (my $c = m.c) {
                DumpFile("$f/c",$c);
            }
        }
        
        if (my $y = 7s&writer) {
            $y->($A,$C,$G,$T);
        }
    };
    # fork and disconnect subtle/wirings
    # but keep in/next/tv etc connected
    # wants to output lines of [C] but for the same ref Tricks
    G&stowexp,$write;
Stylehousing: |
    #
    n Zequines
    
Zequines: |
    # ja
    n DAy
DAy: | # world primitives
    u i
    # sympathetic to design some stuff
    # see 64 got
    # hidey machine thats giving you things
    G:
        $G = {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'};
        G.h = G.i.h;
        
        # make G.way.$pin retrieve code
        # going once G&t does way all over
        {
            package Wormhole;
            use G;
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my %o;
                %o = (%o, %{$_}) for @_;
                return bless [{},\%o], $class;
            }
            sub STORE {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                die "Storign o: $v" if $k eq 'o';
                if (o.nonyam) {
                    o.dige->{$k} = slm 12, dig $v unless ref $v;
                }
                $s->{$k} = $v;
            }
            sub FETCH {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                return $o if $k eq 'o';
                $s->{$k} || STORE($e,$k, do {
                    my $il = join('/', grep{defined} o.dir, $k);
                    my $f = o.base.'/'.$il;
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole', $o, {dir=>$il};
                        \%Di;
                    }
                    elsif (-f $f) {
                        o.nonyam ?
                        scalar read_file($f)
                        :
                        LoadFile($f);
                    }
                    else {
                        warn "Wormhole sens nothing: $f";
                        undef
                    }
                });
            }
        }
        my %way;
        tie %way,'Wormhole','w/way',{nonyam=>1};
        G.way = \%way
        $G
    # args (i,ii,W,w) $s
    #  ii/We things by default
    #  W and w know how to look in Gspaces for names
    # find local things, look up trail of con centers
    # could also look down/allways for elvis proto
    t: %acgt:s c y
        ($y,$c) = ($c,$y) if ref $c eq 'CODE';
        $C = ref $s ? $s : {t=>$s,y=>{},c=>($c||{})};
        c&on ||= 'ii';
        c&max ||= 5;
        c&min ||= 0;
        for my $i (c&min .. c&max) {
            my $from = $i == 0 ? $A : $A.>$i;
            $from || next;
            
            my $on = $from.>c&on || next;
            
            my $t = $on.>C.t || next;
            $t = $y->($t,$from,$i) if $y;
            $t || next;
            c&from = $from;
            c&inet = $i;
            return $t;
        }
        return
    
    # look for thing named $s in We thing named $of, on A net
    wup: %acgt:s of
        $of ||= 'w';
        my $want = sub {
            my ($t,$f,$i) = @_;
            # if i > netmask
            # if t mentions some other way to get it
            keys %$t < 2 && sayre "wup t looks funny: ".ki($t)."\n  ".G&sn;
            my $tw = t.y.tw || die "w $s found no ytw on"
                ." A.1.t s A.t @ $i (f.t): ".ki$t;
            $tw.>$s
        };
        G&t,$of,$want;
    
    # wup including G.way (going)
    wops:
        my $w = G&wup,$s;
        
        # or the old way,
        if (!$w) {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            $w = {t=>$s};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
        }
        $w
    
    # W is the of=W, could be pointer to load the rest
    # 
    Wup: %acgt:s of
        $of ||= 'W';
        my $W = G&wup,$s,$of || return;
        my $s = W.c.s;
        ref $s eq 'HASH' || die "No Wup $of: $s: ".ki $W;
        $s;
    

