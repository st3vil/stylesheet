Experience: |
    # wakeup, dome, goto sleep
    # domes build like carpentry
    # force needs ways to build across language
    
    # in: be somewhere you've been betfore:
    A.6.t ||= 'stay';
    # out: bet somewhere else:
    A.7.t ||= 'gou';
    
    # remember aft s
    1c&sang = &acgt{
        local A.V = 2;
        Rw Write;
    };
    
    # wake up now
    Rw Read;
Locate: | # A J and its space
    my $s = ar.s;
    # center of us
    my @J = A.1.t;
    
    # right: our osc page by /s/$s, if not ''
    # layers/partitions upon a piece of the tree
    push @J, s=>$s if $s;
    
    # left up to A.3, Word to the overmind, amongst A.4/G
    # inners join by W(/j/j.t)+
    if (A.1 ne A.3) {
        my $j = A.1;
        while (j.2) {
            $j = j.2;
            unshift @J, j.t=>'j';
            last if $j eq j.3;
        }
    }
    
    # make safe
    s/\W+/-/gs for @J;
    
    # most left, beyond all sense
    my $star = G.c.bay || die "no community of G";
    my $read = ar.read;
    
    # second most left, edge of sense
    my $t; # G having W
    # run cateGories we orGanise chaos into, a Gravity of W
    # G is a moving path, many may have a J
    # there is a moving part between infinity and finity
    # we may work off and onto several G
    # place of work, the worker and the Gallery
    # travelling process sense and wormhole sense
    # probably all: A.4.t, same name as worker
    my @search = $read ?
        # 6 for travel instructor
        #     can wire readonly chunks
        # 5 mind factory/stable but not ours to write to
        # 4 for usual reading ourselves
        (6,5,4)
        # 7 for explicit output place, a branch
        # 4 for usual overwriting ourselves
        # with A.8 having a stabilised A.4.t and running tests through forks
      : (7,4);
    # < any of them implementing a more complicated search/resolver
    
    my $f; # path to dir full of head/xo/c/etc files and s/j/etc dirs
    for my $num (@search) {
        my $j = $A.>$num;
        next if !$j;
        $f = join '/', $star, j.t, @J;
        my $e = -e $f;
        $read && !$e && next;
        $t = j.t;
        last;
    }
    
    return if $read && !$t;
    $f
Read: | # the J you're in remembers itself
    # having created a place for it to land
    my $s = ''; # TODO osc channel, api here too Jeneral
    my $f = Rw Locate $s $read=1
        || saybl("Nothing to read A.1.t") && return;
    saybl "Read located: $f";
    my $head = "$f/head";
    my $d = 1s&Read.>$head ||= {};
    my $m = (stat $head)[9];
    if (ds&meta.mtime eq $m) {
        # sleep J?
    }
    else {
        -f $head || die "Read no $head";
        $d = LoadFile("$f/head");
        ds&meta.mtime = $m;
        1s&Read.>$f = $d;
    }
    
    return $d
Write: | # the 
    # C is a completed s, Jc&sang = &acgt{ to get here
    c&imp || die "C not completed s: ".ki$C;
    
    my $f = Rw Locate $write=1;
    saybl "Write located: $f";
    
    my $write = &C{
        # forked, C is the top (9)
        `mkdir -p $f`;
        DumpFile("$f/head",$C);
        
        if (my $m = s&meta) {
            # applies to the Reading s
            # separately for map makers
            if (my $xo = m.A.xo) {
                DumpFile("$f/xo",$xo);
            }
            if (my $c = m.c) {
                DumpFile("$f/c",$c);
            }
        }
    };
    # fork and disconnect subtle/wirings
    # but keep in/next/tv etc connected
    # wants to output lines of [C] but for the same ref Tricks
    G&stowexp,$write;
    

