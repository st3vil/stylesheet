Experience: |
    # wakeup, dome, goto sleep
    # domes build like carpentry
    # force needs ways to build across language
    
    # be somewhere you've been betfore:
    A.6.t = 'stay';
    # bet somewhere else:
    A.7.t = 'gou';
    
Locate: | # A J and its space
    my $s = ar.s;
    # center of us
    my @J = A.1.t;
    
    # right: our osc page by /s/$s, if not ''
    # layers/partitions upon a piece of the tree
    push @J, s=>$s if $s;
    
    # left up to A.3, Word to the overmind, amongst A.4/G
    # inners join by W(/j/j.t)+
    if (A.1 ne A.3) {
        my $j = A.1;
        while (j.2) {
            $j = j.2;
            unshift @J, j.t=>'j';
            last if $j eq j.3;
        }
    }
    
    # make safe
    s/\W+/-/ for @J;
    
    # most left, beyond all sense
    my $star = G.c.bay || die "no community of G";
    my $read = ar.read;
    
    # second most left, edge of sense
    my $t; # G having W
    # run cateGories we orGanise chaos into, a Gravity of W
    # G is a moving path, many may have a @J
    # there is a moving part between infinity and finity
    # we may work off and onto several G
    # place of work, the worker and the Gallery
    # travelling process sense and wormhole sense
    # probably all: A.4.t, same name as worker
    my @search = $read ?
        # 6 for travel instructor
        #     can wire readonly chunks
        # 5 mind factory/stable but not ours to write to
        # 4 for usual reading ourselves
        (6,5,4)
        # 7 for explicit output place, a branch
        # 4 for usual overwriting ourselves
        # with A.8 having a stabilised A.4.t and running tests through forks
      : (7,4);
    # < any of them implementing a more complicated search/resolver
    
    my $f; # path to dir full of head/xo/c/etc files and s/j/etc dirs
    for my $num (@search) {
        my $j = $A.>$num;
        next if !$j;
        $f = join '/', $star, j.t, @J;
        my $e = -e $f;
        $read && !$e && next;
        $t = j.t;
        last;
    }
    
    return if $read && !$t;
    $f
Read: | # the J you're in remembers itself
    # having created a place for it to land
    my $s = ''; # TODO osc channel, api here too Jeneral
    my $f = Rw Locate $s $read=1;
    my $d = 1s&Read.>$f ||= {};
    my $m = (stat $f)[9];
    if (ds&meta.mtime eq $m) {
        # sleep J?
    }
    else {
        $d = LoadFile($f);
        ds&meta.mtime = $m;
        1s&Read.>$f = $d;
    }
    
    return $d
    
    
    
    my $f = $na->(A.4.t, c.t);
    if (e&t eq 'put') {
        my $p = $na->(A.4.t, c.t, '');
        DumpFile($f,$c);
        if (G.c.Stash) {
        }
        C.c.V && sayyl "Store $f";
    }
    elsif (e&t eq 'get') {
        unless (-f $f && -s $f) {
            my $t = G.c.t6 || return;
            # travel agency, like A.6.t
            # a loosely in pile by the gondola in this bay
            # could ask for net with A.8
            # our pull/push in A.7
            # another place to check for W src
            # stores (not auto?) in our place (A.4.t)
            $f = $na->($t, c.t);
            -f $f && -s $f || return;
        }
    }
    else { G&vent,"NHogo" }
Write: | # the 
    # C is a completed s, Jc&sang = &acgt{ to get here
    c&imp || die "C not completed s: ".ki$C;
    
    my $f = Rw Locate $write=1;
    
    my $write = &C{
        # forked, C is the top (9)
        `mkdir -p $f`;
        DumpFile("$f/head",$C);
        
        if (my $m = s&meta) {
            # applies to the Reading s
            if (my $xo = m.A.xo) {
                DumpFile("$f/xo",$xo);
            }
            if (my $c = m.c) {
                DumpFile("$f/c",$c);
            }
        }
    };
    # fork and disconnect subtle/wirings
    # but keep in/next/tv etc connected
    # wants to output lines of [C] but for the same ref Tricks
    G&stowexp,$write;
    

