SelfConsciousness: | # your fish brain
    n FishBrain
    
    n Houp
    n Koul
BuildFish: |
    my $e = djson <<'';
        {"c":{"W":"Jig","e":{"c":{"pi":"Gdo","s":"Especially"},"sc":{"everything_under":"SelfConsciousness","z":[{"c":{"W":"SelfConsciousness"},"t":"SelfConsciousness"},{"c":{"W":"Process"},"t":"Process"},{"c":{"W":"HaMachine"},"t":"HaMachine"}]},"t":"peace/new","y":{"cv":""}}},"sc":{},"t":"Jig","y":{"cv":""}}
    
    Rw CloningProcess;
    #
    Gc&bay = 'peace';
    n $e
    
    sayre "Become thingz!";
    exit;
    
FishBrain: | # beginning middle and end superimposed on J's state
    u i
    s: %acgt:c sc
        sayyl "oscillating!";
        $A = G&A,s=>0=>$c,$sc;
        # s could order a particular ground
        Rw FishBrains $A;
PostO: | # make O's a&swim elvises happen, feed into r.y.tv
    # all current O, even asleep/A&el=8
    my @aO = map { _.y.OA || die "noOA: ".ki$_ }
        #map { _.y.OA || die "NoOC: ".ki($_)."\n\ny: ".ki _.y; }
        @{A&Cora};
    
    # phil:
        # wOrms, in-wormholes
        #   where thing is our part of some sharing of truth
        # is one-ish with:
        # < waves of language solvents
        # all basically generating ongoing job lists
        # usually pumping so-classified things through some filter
        # everything moving comes classified as some elvis
        #   so s&of encodings happen now
        #   and W doings on other hosts emit through Op
        #   W doing might be updating it on the news...
        
        # another use for o be the upping/downing of indexes
        # amongst sources that may not all be awake.
        
        
    # take Os&swom (via J), Os&swim (from C) through concludoors
    # in usual yt order, may be dupey,
    # to clobber in o ut
    # < the elvising (of,javascript) to have more sense
    #   about whether we should already o things to it,
    #   depending on weight...
    # - but code might appreciate having competitors compiled?
    
    # swom things are lower priority than swim things
    for my $O (@aO) {
        my $c = Oc&s;
        my $swom = Os&swom || next;
        each W,Wt,Wcv,Dt,Dcv,D $swom {
            Os&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv ||= $D;
        }}}}}
    }
    
    for my $O (@aO) {
        my $c = Oc&s;
        my $swim = Os&swim || next;
        each W,Wt,Wcv,Dt,Dcv,D $swim {
            if (my $i = a&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv ) {
                my $d = i.c.s;
                saygr G&sn ." c.t c.y.cv overs $Wt/$Dt $Dcv from d.t d.y.cv";
            }
            a&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv = $O;
        }}}}}
    }
    
    each W,Wt,Wcv,Dtv a&swim {
        # sleep based on each set's sources being stable
        # < stuff hoisted via J is already encoded
        # < and may be linkable, depending on that repository's nature
        #   avoiding re-elvising laws undisputed
        my $move = 1;
        if (my $his = s&swim.>$W.>$Wt.>$Wcv ) {
            $move--;
            each Dt,Dcv,O $Dtv {
                Oc&el ne '8' && $move++;
                my $o = $his.>$Dt.>$Dcv;
                $o && oc&s.t eq Oc&s.t 
                && oc&s.y.cv eq Oc&s.y.cv || $move++;
            }}
            each Dt,Dcv,o $his {
                my $O = $Dtv.>$Dt.>$Dcv;
                $o && oc&s.t eq Oc&s.t 
                && oc&s.y.cv eq Oc&s.y.cv || $move++;
            }}
        }
        unless ($move) {
            a&swum.>$Wcv.>$Wt = s&swum.>$Wcv.>$Wt || die "no swum $Wcv $Wt";
            sayre G&sn ."Seems to be the same... $W $Wt $Wcv";
            # elvis checks his stuff is still at the hut
        }
        else {
            my $z = [];
            for my $O (@aO) {
                my $Dtv = Os&swim && Os&swim.>$W.>$Wt.>$Wcv || next;
                # random order here, o ut will sort
                each Dt,Dcv,D $Dtv {
                    # D pushed thing, clone if C
                    $D = G&hup,$D if $D eq Oc&s;
                    push @$z, $D;
                }}
            }
            die "Nothing ordered $W $Wt $Wcv?" if !@$z;
            # todo elvising
            my $w = a&We.>$Wcv.>$Wt;
            my $W = a&We.>$Wcv.>$Wt = G&Ct,[$Wt=>$Wcv,{W=>$W}];
            Wc&nogro = 1; # ?
            my $e = Wc&e = G&Ct,[Swim=>3];
            ec&z = $z;
            
            $w && die "We already: ".ki($w)."\nvs: ".ki$W;
        }
    }}}
    
    
    # sort what to do could get smaller if we go by aO
    for my $Wcv (sort keys %{a&We}) {
        my $Wts = a&We.>$Wcv;
        for my $Wt (sort keys %$Wts) {
            my $W = $Wts.>$Wt;
            # sends to the particular language workshop
            # nomem = its J (of,javascript) won't hang around
            $W = G&e,\'nomem',$W;
            # makes a cW=of
            my $D = G&Ct,[$Wt=>$Wcv,{W=>Ws&W}];
            # compilations come back
            Ds&z = Ws&z;
            Ds&z ||= Wc&e.c.z;
            Ds&z || sayre "W no z ".ki$W;
            
            a&swum.>$Wcv.>$Wt = $D;
        }
    }
    
    # add them under root 9
    # extra z goes after/over OCs
    # z plane clobber them...
    each Wcv,Wt,D a&swum {
        my $w = r.y.tv.>$Wt.>$Wcv;
        r.y.tv.>$Wt.>$Wcv = $D;
        $w && !A&thaw && saygr G&sn ." D: ".ki($D)."\n\n $Wt $Wcv probably swum over by ".ki$w;
    }}
    
    # live on the live on-er
    s&swum = a&swum;
    s&swim = a&swim;
    # stuff gets noticed in K
    
     #c coil feeds unification causes all We things' things
     # the rs&coil identifies a universal,
     # the C with it identifies the way
     # < at many roots upward (certain) coils may coil
        if (my $o = rs&coil) { # root.sc/y.at
            my $N = []; # I thing's things
            # ! no order
            each Wcv,Wt,D a&swum {
                push @$N, @{Ds&z||[]}
            }}
            for my $o (split ' ',$o) {
                my $s = $1 if $o =~ s/:(.+)//;
                # ^ guidance more likely from the
                #   C using this point to unify:
                for my $C (grep { _.sc.>$o }@$N) {
                    my $way = C.sc.>$o;
                    my $s = $way =~ s/:(.+)// ? $1 : $s;
                    Rw $way $C $N $s
                }
            }
        }
        
Houp: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        # is OC
        # OA=O, A=o
        my $o = C.y.A;
        o.t eq 'o' || die "No oA: ".ki $o;
        
        A&el = oc&el;
        
        # put O
        C.y.OA = $A;
        
        # < more recur?
        
        # < making this stick...
        T.not = 1 if C.sc.not eq '1';
        
        # < something else
        #   goners copy last clone, which would have changed...
        T.Z.8 = $A if A&el eq '9';
        
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of', 'js') {
            if (my $Wt = C.sc.>$W) {
                my $W = $W eq 'js' ? 'javascript' : $W;
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W  ".G&aC,$C;
            }
        }
        
        # indexed ground within universals
        if (my $J = !s&noii && s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.I; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scI $t/D.t no in";
                    while ($S) {
                        a&swom.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W  ".G&aC,$S;
                        $S = S.y.next;
                    }
                    $D = D.y.over; # the next ii?
                }
            }
        }
        
        # do when el is so
        if (my $sel = 1s&sels || 1s&seld) {
            # limited to those under 9?
            # C.y.up is drain here...
            $sel = {} unless 1s&seld || C.y.A.c.ind == 1;
            each k,els $sel {
                exists C.sc.>$k || next;
                each el,do $els {
                    A&el eq $el || A&el eq '2' && $el eq '1' ||
                    $el eq '5' && A&el < 4 || next;
                    G&h,$do;
                }
            }
        }
    
    # O 56 muchofany Style if joiner
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv,
    # Scuttle
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
SenseCertainty: | # clamorous industrial junkseeing
    # travelling bit outliner
    # < becomes subordinate to FactorEase
    n SirKill
    
    
    
    # travelling somethingers
    # < use G&o instead
    n Walkit
BuildSir: |
    my $e = djson <<'';
        {"c":{"W":"Jig","e":{"c":{"pi":"Gdo","s":"An Update"},"sc":{"z":[{"c":{"W":"SirKill"},"t":"SirKill"},{"c":{"W":"SenseCertainty"},"t":"SenseCertainty"},{"c":{"W":"Process"},"t":"Process"},{"c":{"W":"HaMachine"},"t":"HaMachine"}]},"t":"peace/new","y":{"cv":""}}},"sc":{},"t":"Jig","y":{"cv":""}}
    
    Rw CloningProcess;
    #
    Gc&bay = 'peace';
    n $e
    
    sayre "Become thingz!";
    exit;
    
SirKill: | # crawl datastructure
    u i
    o: %acgt:s c sc
        my $isC = &C{
            ref $C eq 'HASH' &&
            defined C.t && C.y && (C.c || C.sc)
        };
        
        1s&sayo && saygr "Do o: c.t ".ki $s;
        $A = G&A,o=>0=>$c,$sc;
        my $V = A.V;
        
        my $on = A&liveon || A.1;
        $on = on.sc.o ||= {} if $isC->($on);
        A&t ||= A.c.ip[-1]; # the number of our A in enclosing A
        my $o = A&s = $on.>A&t ||= {t=>A&t};
        o.y = $o;
        
        my $name = 'o'.o.t; # eg oin
        oc&ysource = 'C'; # upstream
        # or $name.'D'; # oinD, in drain
        # might be handy to Scuttle these away like hilltops
        # but so the entire causal bead-chain is
        oc&clones = [$name.'C']; # oinC, on record?
        
        # catch nkgk, etc
        oc&map = A&map if A&map;
        
        # eg gen=lv, should maybe []
        push @{oc&clones}, A&gen if A&gen;
        
        # make a clone to throw into next process, eg OC
        # and link the drained C.y.OC = $OC
        if (A&yoff) {
            oc&sourcey = A&yoff;
            push @{oc&clones}, A&yoff;
        }
        
        # many A=o hold cs=C
        my $io = {%$A, t=>'o',up=>$o,c=>{s=>$s},sc=>{}};
        my @L = io.y = $io;
        my @R;
        # builds up from z/in/tw/tv
        while (@L || @R) {
            if (!@L) {
                @L = reverse @R;
                $V && saygr "Clunking r: ",
                    map{"  _c&ind, _c&s.t _c&s.y.cv"
                    } @L;
                @R = ();
            };
            my $A = shift(@L);
            A.c.ot = o.t;
            my $C = A&s;
            # < give these A/C to T for blowingup locator?
            (Gc&B.sc.aA, Gc&B.sc.aC) = ($A,$C) if Gc&B;
            $V && sayre "V ".join('',('  ') x A&ind)."  C.t  -- C.y.cv  "
                .ki({c=>C.c,sc=>C.sc});
            #1 && sayyl "Asck: ".join', ', sort keys %{A.sc};
            unless (A&last) { #c last reoccurs
                $V && saybl "0 last";
                # but first
                $isC->($C) || die "notC: ".ki$C;
                C.c ||= {};
                C.sc ||= {};
                A&ipi ||= 0; # increment per child
                my $l = upc&last || {};
                
                if (A&comp eq 'tv') {
                    A&last = ls&tv.>C.t.>C.y.cv || {};
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                elsif (A.up eq $o) {
                    # io has an A
                    A&last = os&lastA || {};
                }
                else {
                    A&ext || die "how to file";
                    A&last = ls&Tv.>A&ext || {};
                }
                # < different namespacing? crunch function?
                push @L, $A;
                next;
            }
            unless (A&insides) { #c insides
                $V && saybl "1 insides";
                my $st = {}; # same inside may appear many places
                # Scuttle should tell ways in
                # < checking that everything is found via each way
                #   mostly it will be filling up the connection of
                #   chucked together any way bits
                # < should know all y/c/sc that look C or [C+]
                # < and not push duplciatively into Tv things
                my @at;
                each nk,gk,v $C {
                    next if 'y'eq$nk; # distracto or handled
                    if (ref $v eq 'HASH') {
                        # no A for it if not C, may still be deduped
                        # via os&refs collected from C and ng/gks
                        next unless v.y ne $v; # not A
                        # not s (see push duplicatively^)
                        next if $nk eq 'c' && $gk eq 's';
                        next unless $isC->($v);
                        push @at, ["$nk $gk",[$v],{isTv=>1,nk=>$nk,gk=>$gk}];
                    }
                    elsif (ref $v eq 'ARRAY') {
                        next if $nk eq 'c' && $gk eq 'M'; # dodge
                        next if $nk eq 'sc' && $gk eq 'z'; # handled
                        next unless @$v == grep {
                            ref $_ eq 'HASH' && $isC->($_) } @$v;
                        push @at, ["$nk $gk",$v,{isTv=>1,nk=>$nk,gk=>$gk}];
                    }
                    else {
                    }
                }}
                A&insides = [ # A inner
                    map {
                        my ($t,$z,$c) = @$_;
                        map {
                            my $Y = $_;
                            Yc&ext = $t;
                            Yc&zip = A&ipi++;
                            Yc&ind = A&ind+1;
                            Y.c.>$_ = $c.>$_ for keys %{$c||{}};
                            my $s = "Yc&s";
                            push @{$st.>$s ||= []}, $Y;
                            _.y = $Y;
                        } map {
                            {%$A, t=>'o',up=>$A,c=>{s=>$_},sc=>{}}
                        } @$z
                    }
                    @at, # attributes we can see
                    # these all mean "inside", are in tv competition:
                    map { $_->[2] = {comp=>'tv'}; $_ }
                    grep{defined}
                    (C.y.in ? do {
                        my @S = my $S = C.y.in;
                        push @S, $S while $S = S.y.next;
                        ['y in', \@S]
                    } : undef),
                    (C.y.tw ? do {
                        ['y tw',[values %{C.y.tw}]]
                    } : undef),
                    (C.y.tv ? do {
                        ['y tv',[map{values %$_} values %{C.y.tv}]]
                    } : undef),
                    (C.sc.z ? do {
                        ['sc z',C.sc.z]
                    } : undef),
                ];
                # check $st for duplicate s
                each s,z $st {
                    @$z > 1 || next;
                    my @z = @$z;
                    @$z = pop @z;
                    A&Atrm.>$_ ++ for @z;
                }
                @{A&insides} = grep { !A&Atrm.>$_ } @{A&insides}
                    if A&Atrm;
                
                # so we know which values are things
                #   with their own differencing A
                A&ways_in = {};
                push @{A&ways_in.>_c&ext ||= []}, $_ for @{A&insides};
                
                $V && saygr " C.t has ".@{A&insides}." insides";
                unshift @L, @{A&insides};
                unshift @R, $A;
                next;
            }
            unless (A&hoisting) {
                $V && saybl "1.5 hoisting";
                # wipe our tv, write ourselves into up.tv
                #  - after insides find their A&last
                # attach to the above
                # < many
                if (A&comp eq 'tv') {
                    push @{ups&tv.>C.t.>C.y.cv ||= []}, $A;
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                elsif ($A eq $io) {
                    # io
                }
                else {
                    A&ext || die "how to file";
                    push @{ups&Tv.>A&ext ||= []}, $A;
                }
                
                A&hoisting = 1;
                # start going backwayds
                push @R, $A;
                next;
            }
            unless (A&diff) { #c difference, in reverse, insidest first
                $V && saybl "2 diff";
                # last A, compare a&ng
                my $d = A&last;
                my $D = A&diff = {};
                Ds&allnew = 1 if !dc&el;
                # Ds&neg - changed values nk/gk = q
                # Ds&pos - changed things index/$index = Y
                
                # the values
                # maintain Ds&ng nk/gk
                # change of Ds&neg nk/gk
                #  - this each Bablar will next on !ref t
                #  and avoid y, t/cv we write in
                each nk,gk,v $C {
                    # not things that will change superficially
                    next if $nk eq 'y';
                    next if A&ways_in->{"$nk $gk"};
                    
                    a&ng.>$nk.>$gk = $v;
                }}
                if (my $m = (A.map || oc&map)) {
                    # hooks receive a&ng as C
                    #   before we clone it to many E
                    #   or difference it - so your input matters
                    # it will be missing any A&ways_in and !cv y
                    my $E = a&ng;
                    E.t = C.t;
                    E.y.cv = C.y.cv;
                    if (my $y = $m && ms&any) {
                        if (!A&isTv || ms&evenTv) {
                            ref $y eq 'CODE' ? $y->($A,$E,$G,$T)
                            : die "answer map: ".ki($y)."\nat: ".ki$C;
                        }
                    }
                    if (my $nkgk = $m && ms&nkgk) {
                        # avoid warn for iterating a changing structure
                        my $oE = {%$E};
                        $oE.>$_ = {%{ $oE.>$_ }} for
                            grep {ref $oE.>$_ eq 'HASH'} keys %$oE;
                        each nk,gk,v $oE {
                            next if $nk eq 'y';
                            my $y = $nkgk.>$nk.>$gk || next;
                            $v = $E.>$nk.>$gk;
                            ref $y eq 'CODE' ? $y->($A,$E,$G,$T,$v)
                            : die "answer map: ".ki($y)."\nat: ".ki$C;
                        }}
                    }
                    delete E.y.cv;
                    delete E.t;
                }
                each nk,gk,v a&ng {
                    if (!exists ds&ng.>$nk.>$gk
                         ||     ds&ng.>$nk.>$gk ne $v) {
                        my $q = Ds&neg.>$nk.>$gk = {t=>$gk,c=>{s=>$v}};
                        qc&new = 1 if !exists ds&ng.>$nk.>$gk;
                        qc&was = ds&ng.>$nk.>$gk if !qc&new;
                    }
                }}
                each nk,gk,v ds&ng {
                    exists $C.>$nk.>$gk && next;
                    Ds&neg.>$nk.>$gk = {t=>$gk,c=>{was=>$v}};
                }}
                
                # the yin change Ds&pos (tv nk/gk | Tv exp)
                # tv and Tv are indexes that may flatten the many
                each t,cv,Y a&tv {
                    # last one wins
                    push @{a&many.tv.>$t.>$cv ||= []}, shift @$Y
                        while @$Y > 1;
                    $Y = shift @$Y;
                    a&tv.>$t.>$cv = $Y; # count it
                    
                    Yc&el eq '8' && next; # sleep
                    Ds&pos.tv.>$t.>$cv = $Y;
                }}
                each t,cv,Y ds&tv {
                    a&tv.>$t.>$cv && next;
                    Yc&el eq '9' && next;
                    # copy goers A so backlv C remain as they were
                    # does similar to each clone in ready
                    $Y = {%$Y,c=>{%{Y.c}},sc=>{%{Y.sc}}};
                    Yc&s.y.A = $Y;
                    Yc&el = '9';
                    delete Ys&ord;
                    delete Ys&ready;
                    Y.up = $A; # receive Es&z
                    a&tv.>$t.>$cv = # remover to sort in?
                    Ds&pos.tv.>$t.>$cv = $Y;
                }}
                
                # values that were things
                # - transport intact
                # its A works out its sleeping el=8
                # set value in a&ng as handled things skip
                each ext,v a&Tv {
                    push @{a&many.Tv.>$ext ||= []}, shift @$v
                        while @$v > 1;
                    $v = shift @$v;
                    a&Tv.>$ext = $v; # count it
                    
                    # set value/transport intact
                    vc&nk && vc&gk || die "No ext nkgk: $ext: ".ki $v;
                    a&ng.>vc&nk.>vc&gk = vc&s;
                    
                    vc&el eq '8' && next; # sleep
                    # < no el=3 possible?
                    Ds&neg.>vc&nk.>vc&gk = {t=>vc&gk,c=>{s=>vc&s}};
                }
                each ext,v ds&Tv {
                    a&Tv.>$ext && next;
                    vc&nk && vc&gk || die "No ext nkgk: $ext: ".ki $v;
                    # deletes the value
                    Ds&neg.>vc&nk.>vc&gk = {t=>vc&gk,c=>{was=>vc&s}};
                }
                
                # may not need to move
                A&el = '8' unless Ds&neg || Ds&pos
                    || Ds&allnew; # in case of an empty C
            }


            
            unless (a&clones) { #c generate replacable bodies, rev/insidest first
                $V && saybl "3 clones";
                my $d = A&last;
                my $D = A&diff;
                # a&ng is nk/gk = $v ground as is
                #   attributes including Tv things, they skipped diffing initially
                # Ds&neg is nk/gk = change C:
                #   c.s = $v if present, c.was if past
                #   be only trace of attribute/Tv thing if gone
                #   
                
                # a&tv.>$t.>$cv = $Y insides
                # Ds&pos.tv.>$t.>$cv = $Y also
                #   would be only trace of thing if gone,
                #     but needing to sort in the remover with a&tv
                #     should skip the Yc&el='9' when wiring non-lv
                #     but pop them out disconnected in Core
                
                # make clones, usu
                # - one to keep on record to diff
                # - one to give to processes unknown
                # - more? parallel
                # o is where ref integrity is most unlost/buried
                # < knowing all refs on $o, wire Cgen, pointerise lv
                for my $t (@{oc&clones}) {
                    my $E = {t=>C.t,y=>{cv=>C.y.cv}};
                    
                    if (1 && A&el eq '8') {
                        # cloning clones a semi-good idea
                        # < until we can sleep a limb
                        $E = ds&clones.>$t
                            || die "el8 had no clone $t";
                        # keep y.*
                        a&clones.>$t = $E = {%$E};
                        $E.>$_ = {%{$E.>$_ || {} }} for qw'y c sc';
                        E.y.A = $A;
                        Es&z = [] if Es&z;
                    }
                    elsif (A&el eq '9') {
                        # never happens:
                        #  - Tv goners are Ds&neg-ations
                        #  - tv goners are a&tv.>$t.>$cv = old $Y
                        #    will be brought back into play with a&ord
                        #    but shouldn't emit non-lv objects
                    }
                    else {
                        A&el ||= Ds&allnew ? '1' : '3';
                    
                    }
                    if ($t eq 'lv') {
                        Ec&el = A&el if !defined Ec&el;
                    } 
                    if (my $ys = oc&ysource) {
                        # oinD = in drain C
                        # or just C for upstream C
                        E.y.>$ys = $C;
                    }
                    if (my $sy = oc&sourcey) {
                        # in drain C.y.OC = $OC
                        C.y.>$sy = $E if $sy eq $t;
                    }
                    
                    if (A&isTv && $t ne 'lv') {
                        # if we are a Tv, transport intact?
                        # ups&ng will overwrite this anyway?
                        #   will find it through os&refs, be the same
                        #   but could change as this clone
                        $E = $C;
                    }
                    # the clone can see its A
                    E.y.A = $A;
                    
                    a&clones.>$t = $E;
                }
                
                # then sort in from first
                push @L, $A if A.up eq $o;
                next;
            }
            unless (a&ord) { #c ordering, gathering
                $V && saybl "4 ord";
                $V && saygr "Is io" if $A eq $io;
                # gathering refs, we already in order
                # first A's clones win pointing to
                # < is depth first tho...
                my $r = os&refs.>$C ||= {};
                #rc&s ne $C && die "refreplacing ".ki($r)."\n".ki$C;
                #rc&s = $C;
                push @{rs&Ys||=[]}, $A;
                
                # should know if v is:
                #   referenced somewhere else, for lv pointers
                #   a cloned C, to point to relevant clone
                #     dont y.out etc if trying to transport intact C
                each nk,gk,v a&ng {
                    ref $v || next;
                    my $r = os&refs.>$v ||= {};
                    a&whererefis.>$v = [$nk,$gk];
                    push @{rs&Ys||=[]}, $A;
                }}
                
                # now create more of that ^ order
                my @l;
                if (a&Tv) {
                    # eg Tv C masters yin C, unless Scuttled to hup
                    push @l, map { a&Tv.>$_ } sort keys %{a&Tv};
                }
                if (a&tv) {
                    # then cv/t
                    my $yttv;
                    each t,cv,Y a&tv {
                        $yttv.>$cv.>$t = $Y;
                    }}
                    for my $cv (sort keys %$yttv) {
                        my $tw = $yttv.>$cv;
                        for my $t (sort keys %$tw) {
                            my $Y = $tw.>$t;
                            push @l, $Y;
                        }
                    }
                    # sleepables here? refs compet should still work
                }
                a&ord = 'sure';
                # do these things before our next thing
                # to keep our order - unshift for @l would reverse it
                unshift @L, @l;
                # or our next us
                unshift @R, $A;
                next;
            }
            unless (a&ready) { #c set new values, forward
                $V && saybl "5 ready";
                $V && saygr "Is io" if $A eq $io;
                if ($A eq $io || A.up eq $o) {
                    # sort through the single pile of refs
                    $V && saygr "Looking through refs...";
                    my $refs = {};
                    each ref,r os&refs {
                        @{rs&Ys} > 1 || next;
                        (rs&Y) = @{rs&Ys};
                        $refs.>$ref = $r;
                        # becomes the definitive source of that ref
                        # may be its C for Tv/tv, some Cnkgk for ng
                        # so lv can be perfect
                    }
                    # leaves only doubled things
                    os&refs = $refs;
                }
                
                my $d = A&last;
                my $D = A&diff;
                
                # assign the correct refs
                # same order as refs won, so they should exist where pointed
                for my $t (@{oc&clones}) {
                    my $E = a&clones.>$t;
                    
                    if (A&el eq '9') {
                        a&clones.>$t = $E = {%$E};
                        $E.>$_ = {%{$E.>$_ || {}}} for qw'y c sc';
                        E.y.A = $A;
                    }
                    # plot entanglements amidst assigning values
                    #   unless we're to transport intact
                    #   will be $E by now, we're reassigning c/sc...
                    #
                        # avoid rewriting cloned clones
                        # or K's deletions would undo themselves
                    if (A&el ne '8') {
                    each nk,gk,v a&ng {
                        $E.>$nk.>$gk = $v;
                        
                        my $r = ref $v && os&refs.>$v || next;
                        my $Y = rs&Y || die "Looks aban: $v ".ki $r;
                        next if $A eq $Y;
                        # other has the one thing
                        #  < link C that knows where either one is
                        #    keeping refs on the yonder A will do
                        
                        # < more testing, having pointers in lv
                        # < doesn't change the thing, should if Yc&s?
                        if (my $nkgk = Ys&whererefis.>$v ) {
                            my $V = Ys&clones.>$t || die "noclone nkgk $t";
                            my ($nk,$gk) = @$nkgk;
                            if (!exists $V.>$nk.>$gk) {
                                # lv clone dropped it?
                                # KC clone muted & sleeping?
                                # we will probably drop it too...
                                $V = V.y.C;
                            }
                            my $vf = $V.>$nk.>$gk;
                            $vf eq $v
                                || sayre G&sn ."\nRefwasnotat (clone=$t) "
                                .ki([$v,$nkgk,$V])
                                ."\nversion from: ".G&aC,$V ."\n"
                                ."version source: ".G&aC,Yc&s ."\n"
                                ."  is: ".ki($vf)."\n"
                                ."  vs: ".ki($v)."\n"
                                ."at $nk $gk on: ".G&aC,$E;
                            # may differ if Scuttled to...
                            $v = $vf;
                        }
                        elsif ($v eq Yc&s) {
                            # is Tv implanting
                            #   or something in a ty somewhere
                            # should transport intact ref as clone
                            $v = Ys&clones.>$t || die "noclone $t";
                            # for an lv to tell of encoded properties
                            a&haveC.>$nk.>$gk = $v;
                        }
                        else {
                            die "TheresnorefonY ".wdump(5,[
                                "Were C.t A&ind, they are Y.c.s.t Y.c.ind",
                                "want $v from: ",[sort keys %{Ys&whererefis}],
                                Ys&whererefis,
                                $r,
                            ])
                            
                            .ki[$v,$Y];
                        }
                    }}
                    }
                    
                    if ($t eq 'lv') {
                        my $neg = Ds&neg;
                        # lv: t y el=9, no detail (in up z tho)
                        $neg = {} if A&el eq '9';
                        neg.y.cv = {};
                        # which are already there
                        each nk,gks $E {
                            ref $gks || next;
                            next if $nk eq 'y';
                            delete $E.>$nk.>$_ for
                                grep { !$neg.>$nk.>$_ } keys %$gks;
                        }
                        # to drop universals named in Ec&ds, etc
                        my $dn = {};
                        each nk,gk,q $neg {
                            next if !q.c;
                            if (!exists qc&s) {
                                $dn.>$nk.>$gk = 1;
                            }
                            else {
                                my $v = $E.>$nk.>$gk;
                                my $s = q.c.s;
                                $v eq $s && next;
                                if ($isC->($s)) {
                                    my $Y = s.y.A;
                                    $v eq $s || sayre "wasnt neg/ng"
                                        .ki([[$nk,$gk],$q,$E])."\n"
                                        ."Ours: ".ki($v)."\n"
                                        ."Theirs: ".ki($s)."\n"
                                        ."TheirA: Yc&sip somewhere\n"
                                        ;
                                }
                                else {
                                    die "wasnt neg/ng"
                                    .ki([[$nk,$gk],$q,$E])."\n"
                                    ."Ours: ".ki($v)."\n"
                                    ."Theirs: ".ki($s)
                                }
                            }
                        }}
                        # encoding this may need json
                        each nk,gks $dn {
                            $nk = 's' if $nk eq 'sc';
                            E.c->{"d$nk"} = join ' ', sort keys %$gks;
                        }
                        # the lv may a&haveC, locating C attr
                        #   and explaining their encoding
                        
                        # moment of life its for
                        Ec&el = A&el;
                        # the clone can (still) see its A
                        # clone of a clone might have E.y.OA
                        E.y.A = $A;
                    }
                    
                    # put for wiring to tv
                    unless (A&isTv || A.up eq $o) {
                        my $U = ups&clones.>$t || die "no upclone $t";
                        push @{Us&z||=[]}, $E;
                    }
                }
                a&ready = 1;
                push @R, $A;
                next;
            }
            unless (a&wiring) { #c link together, reverse
                $V && saybl "6 wiring";
                # to hoist the list of everything:
                #   Cora is where everything sorts into a flat list
                #   Core is same order with A&el=9 (removals) added
                #     and A&el=8 removed as far as order of everything is implied
                # then K makes a .prev if it's not Cora-order
                
                my $D = A&diff;
                
                for my $t (@{oc&clones}) {
                    my $E = a&clones.>$t;
                    # share clones their Cor(e|a) hoisty lists
                    my $net = a&clonet.>$t = {};
                    
                    
                    if (Es&z) {
                        # wire the tv plane, collect the big flat lists:
                        my $ra = []; # everything still there
                        my $re = []; # everything changing
                        my $la; # what to put before things in lv
                        for my $i (@{Es&z}) { # this clone's 
                            my $Y = i.y.A; # their A
                            my $wet = Ys&clonet.>$t;
                            $V && saygr "To the i.t i.y.cv and: ".ki wet.Cora;
                            
                            if (Yc&el ne '9') {
                                # the non-lv tv plane
                                push @$ra, $i;
                                # and load Cora
                                push @{net.Cora||=[]}, $i, @{wet.Cora||[]};
                            }
                            
                            # only re matters to lv, sparse negating C
                            # each y could link to tv reals
                            if (Yc&el ne '8') {
                                if ($t eq 'lv') {
                                    # throw in el=8 for the thing before
                                    # < working...?
                                    # < to 1 c after 9 b, could not 8 a
                                    my $p = Yc&s; # climb back on C
                                    my $d;
                                    if ($p = $d = p.y.prev) {
                                        $p = p.y.A;
                                        $p = ps&clones.lv;
                                    }
                                    if ($p && Yc&el < 3 && (!@$re || $re->[-1] ne $p)) {
                                        push @$re, $p;
                                    }
                                }
                                push @$re, $i;
                                push @{net.Core||=[]}, $i, @{wet.Core||[]};
                            }
                            $la = $i;
                        }
                        # lv wants to wire everything changing togehter
                        my $wi = $t eq 'lv' ? $re : $ra;
                        undef $la;
                        # cloned clones a possibility, why clonet.>$t = {} above
                        # would have these already
                        delete E.y.>$_ for qw'in out tw tv next prev fronts backs';
                        for my $i (@$wi) {
                            E.y.in ||= $i;
                            i.y.up = $E;
                            
                            my $was = E.y.tw.>i.t;
                            E.y.tw.>i.t = $i;
                            # would be easy to wire tw squish
                            (was.y.fronts,i.y.backs) = ($i,$was)
                                if $was;
                            # < lv comp fronts to cv of next bit
                            #   as topics' bits fly at you, to
                            #   signal when next bit is coming
                            
                            E.y.tv.>i.t.>i.y.cv = $i;
                            
                            if ($la) {
                                la.y.next = $i;
                                i.y.prev = $la;
                            }
                            $la = $i;
                        }
                        Es&z = $wi;
                    }
                    
                    # last clone (OC?) becomes A&s, or C if you steal this A's c/sc
                    A&s = $E;
                    # assume everything's parent will be active at the last hop
                    # so A&Core is everything changed and the top, nested in flat list
                    # look at C
                    a&Core = [(A&el ne '8' ? $E : ()),
                              @{net.Core||[]}];
                    a&Cora = [$E,@{net.Cora||[]}];
                }
                a&wiring = 1;
            }
        }
        
        $V && sayre "Finished ".ki $o;
        # export some io sc to o
        o.sc.>$_ = io.sc.>$_ for qw'Core Cora';
        #@{os&Core} = # everything changed
        #@{os&Cora} = # everything
        os&lastA = $io;
        oc&s = io.c.s;
        
        $o;
    
t/o_simple: |
    my $et = G&Ct,[je=>''=>{s=>33}];
    my $je = et.y.in = G&hup,$et;
    je.t = 'jet';
    et.c.s = 44;
    my $i;
    et.sc.z = [
        map {_.y.cv = "0.03".$i++;
            _.y.in.t .= "eee";
            _.y.in = G&hup,_.y.in;
            _s&delic = 3 * $i;
            $_}
        map { G&hup,$et } 1..4
    ];
    
    my $r = et.sc.z->[3];
    r.t = 'elab';
    r.c.s = 'deal';
    rs&z = [map{ G&Ct,['built'=>$_=>'several'] }1..4];
    et.t = "Entry";
    my $C = G&Ct,['o_simple'];
    
    my $da = {map{$_->[0], [split/\n/,$_->[1]] }
          [Cora_1=><<''],
            1Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            1  jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            1  je 0.030 (A C fronts in next prev tv tw up) s % delic z -- s=44  %  delic=3 z=[ jeteee ]
            1    jeteee  (A C up) s -- s=33  %  
            1  je 0.031 (A C OA backs fronts in next prev tv tw up) s % delic z -- s=44  %  delic=6 z=[ jeteeeeee ]
            1    jeteeeeee  (A C up) s -- s=33  %  
            1  je 0.032 (A C backs in next prev tv tw up) s % delic z -- s=44  %  delic=9 z=[ jeteeeeeeeee ]
            1    jeteeeeeeeee  (A C up) s -- s=33  %  
            1  elab 0.033 (A C in prev tv tw up) s % delic z -- s=deal  %  delic=12 z=[ jeteeeeeeeeeeee,built,built,built,built ]
            1    jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            1    built 0.1 (A C fronts next prev up) s -- s=several  %  
            1    built 0.2 (A C backs fronts next prev up) s -- s=several  %  
            1    built 0.3 (A C backs fronts next prev up) s -- s=several  %  
            1    built 0.4 (A C backs prev up) s -- s=several  %  


 
      [Core_1=><<''],
            1Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            1  jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            1  je 0.030 (A C fronts in next prev tv tw up) s % delic z -- s=44  %  delic=3 z=[ jeteee ]
            1    jeteee  (A C up) s -- s=33  %  
            1  je 0.031 (A C OA backs fronts in next prev tv tw up) s % delic z -- s=44  %  delic=6 z=[ jeteeeeee ]
            1    jeteeeeee  (A C up) s -- s=33  %  
            1  je 0.032 (A C backs in next prev tv tw up) s % delic z -- s=44  %  delic=9 z=[ jeteeeeeeeee ]
            1    jeteeeeeeeee  (A C up) s -- s=33  %  
            1  elab 0.033 (A C in prev tv tw up) s % delic z -- s=deal  %  delic=12 z=[ jeteeeeeeeeeeee,built,built,built,built ]
            1    jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            1    built 0.1 (A C fronts next prev up) s -- s=several  %  
            1    built 0.2 (A C backs fronts next prev up) s -- s=several  %  
            1    built 0.3 (A C backs fronts next prev up) s -- s=several  %  
            1    built 0.4 (A C backs prev up) s -- s=several  %  




    # nothing changes 
     
      [Cora_2=><<''],
            8Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            8  jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            8  je 0.030 (A C fronts in next prev tv tw up) s % delic z -- s=44  %  delic=3 z=[ jeteee ]
            8    jeteee  (A C up) s -- s=33  %  
            8  je 0.031 (A C OA backs fronts in next prev tv tw up) s % delic z -- s=44  %  delic=6 z=[ jeteeeeee ]
            8    jeteeeeee  (A C up) s -- s=33  %  
            8  je 0.032 (A C backs in next prev tv tw up) s % delic z -- s=44  %  delic=9 z=[ jeteeeeeeeee ]
            8    jeteeeeeeeee  (A C up) s -- s=33  %  
            8  elab 0.033 (A C in prev tv tw up) s % delic z -- s=deal  %  delic=12 z=[ jeteeeeeeeeeeee,built,built,built,built ]
            8    jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            8    built 0.1 (A C fronts next prev up) s -- s=several  %  
            8    built 0.2 (A C backs fronts next prev up) s -- s=several  %  
            8    built 0.3 (A C backs fronts next prev up) s -- s=several  %  
            8    built 0.4 (A C backs prev up) s -- s=several  %  

 
      [Core_2=><<''],
            8Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]



    

    
    # elab changes, je 030 goes
     
      
      [Cora_3=><<''],
            3Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            8  jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            8  je 0.031 (A C OA fronts in next prev tv tw up) s % delic z -- s=44  %  delic=6 z=[ jeteeeeee ]
            8    jeteeeeee  (A C up) s -- s=33  %  
            8  je 0.032 (A C backs in next prev tv tw up) s % delic z -- s=44  %  delic=9 z=[ jeteeeeeeeee ]
            8    jeteeeeeeeee  (A C up) s -- s=33  %  
            3  elab 0.033 (A C in prev tv tw up) s % delic z -- s=eye  %  delic=12 z=[ jeteeeeeeeeeeee,built,built,built,built ]
            8    jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            8    built 0.1 (A C fronts next prev up) s -- s=several  %  
            8    built 0.2 (A C backs fronts next prev up) s -- s=several  %  
            8    built 0.3 (A C backs fronts next prev up) s -- s=several  %  
            8    built 0.4 (A C backs prev up) s -- s=several  %  


      
      [Core_3=><<''],
            3Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            9  je 0.030 (A C fronts in next prev tv tw up) s % delic z -- s=44  %  delic=3 z=[ jeteee ]
            3  elab 0.033 (A C in prev tv tw up) s % delic z -- s=eye  %  delic=12 z=[ jeteeeeeeeeeeee,built,built,built,built ]


     
     
    # add some twa to je
    #   < the twa in ks&watch should not have y.in
    #     , or be in Core/a
    # map has made c&ha of s&delic
    
    
     
       [Cora_4=><<''],
            3Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            8  jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            3  je 0.031 (A C fronts in next prev tv tw up) ha s % delic z -- ha=c1dfd96ee s=44  %  delic=6 z=[ jeteeeeee ]
            8    jeteeeeee  (A C up) s -- s=33  %  
            3  je 0.032 (A C backs in next prev tv tw up) ha s % delic z -- ha=0ade7c2cf s=44  %  delic=9 z=[ jeteeeeeeeee,twa,twa,twa,twa ]
            8    jeteeeeeeeee  (A C next up) s -- s=33  %  
            1    twa 0.3 (A C fronts next prev up) s % hs -- s=Memb  %  hs=394
            1    twa 0.31 (A C backs fronts next prev up) s % hs -- s={  %  hs=394
            1    twa 0.32 (A C backs fronts next prev up) s % hs watch -- s=Memb  %  hs=294 watch={ t=twa y={ A=HASH(il31) cv=0.33 } c={ s=} } sc={ hs=395 } }
            1    twa 0.33 (A C backs prev up) s % hs -- s=}  %  hs=395
            3  elab 0.033 (A C in prev tv tw up) ha s % delic z -- ha=7b52009b6 s=eye  %  delic=12 z=[ jeteeeeeeeeeeee,built,talk,built ]
            8    jeteeeeeeeeeeee  (A C next up) s -- s=33  %  
            8    built 0.1 (A C fronts next prev up) s -- s=several  %  
            1    talk 0.29 (A C next prev up) gr % sun -- gr=tango  %  sun=4
            8    built 0.4 (A C backs prev up) s -- s=several  %  

       [Core_4=><<''],
            3Entry  (A C in tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            3  je 0.031 (A C fronts in next prev tv tw up) ha s % delic z -- ha=c1dfd96ee s=44  %  delic=6 z=[ jeteeeeee ]
            3  je 0.032 (A C backs in next prev tv tw up) ha s % delic z -- ha=0ade7c2cf s=44  %  delic=9 z=[ jeteeeeeeeee,twa,twa,twa,twa ]
            1    twa 0.3 (A C fronts next prev up) s % hs -- s=Memb  %  hs=394
            1    twa 0.31 (A C backs fronts next prev up) s % hs -- s={  %  hs=394
            1    twa 0.32 (A C backs fronts next prev up) s % hs watch -- s=Memb  %  hs=294 watch={ t=twa y={ A=HASH(il31) cv=0.33 } c={ s=} } sc={ hs=395 } }
            1    twa 0.33 (A C backs prev up) s % hs -- s=}  %  hs=395
            3  elab 0.033 (A C in prev tv tw up) ha s % delic z -- ha=7b52009b6 s=eye  %  delic=12 z=[ jeteeeeeeeeeeee,built,talk,built ]
            9    built 0.2 (A C backs fronts next prev up) s -- s=several  %  
            1    talk 0.29 (A C next prev up) gr % sun -- gr=tango  %  sun=4
            9    built 0.3 (A C backs fronts next prev up) s -- s=several  %  


    
    

    };
    # refs -> numbers
    my $muteNews = &s{
        my $ids = {};
        my $here = 3;
        my $idi = 1;
        my $idstu = &id,k{
            my $sid = $ids;
            $sid = $sid->{$k} ||= {} if $k;
            my $il = $sid->{$id} ||= $idi++;
            "il$here$il";
        };
        for (ref $s ? @$s : $s) {
            s/(id=)(\S+)/$1.$idstu->($2)/eg;
            s/((HASH|ARRAY|CODE)\()(\w+)/$1.$idstu->($3,$2)/eg;
            s/("(?:W|id)":")(\w+)(")/$1.$idstu->($2).$3/eg;
            s/("ids":\[")((?:\w+|",")+)("\])/$1.join('","',map{$idstu->($_)}split'","', $2).$3/eg;
            s/(\=\w+\/\w\/)(\w+)(\.\w)/$1.$idstu->($2).$3/eg;
            s/(life\/W\/)(\w+)(\.\w)/$1.$idstu->($2).$3/eg;
            while (1) {
                s/(opel=.+?)(")(\w{6,})("])/$1.$2.$idstu->($3).$4/eg
                && (s/($3)/$idstu->($1)/eg || 1) || last
            };
            s/(mtime=)(\d{2})(\d+)/$1.$2.join'', (('?') x length $3)/eg;
        }
        $s
    };
    
    

    local A.V = 0;
    my $s;
    my @fail;
    my $one = G&Ct,['One'=>1];
    for my $i (1..4) {
        my $et = $et;
        
        
        if ($i == 3) {
            shift @{et.sc.z};
            r.c.s = 'eye' if $i == 3;
        }
        if ($i == 4) {
            my $rz = r.sc.z;
            @$rz = (shift @$rz, G&Ct,['talk'=>29=>{gr=>'tango'},{sun=>4}] , pop @$rz);
            my $r = et.sc.z->[1];
            rs&z = [
                G&Ct,[twa=>3=>"Memb"=>"hs:394"] ,
                G&Ct,[twa=>31=>"{"=>"hs:394"] ,
                G&Ct,[twa=>32=>"Memb"=>"hs:294"] ,
                G&Ct,[twa=>33=>"}"=>"hs:395"] ,
            ];
            my $k = rs&z->[2];
            ks&watch = rs&z->[3];
        }
        
        #A.V = 1 if $i == 2;
        #exit if $i == 3;
        my $c = {};
        if ($i == 4) {
            my $m = c.map = G&Ct,[TheMap=>''];
            ms&nkgk.sc.delic = &acgts{
                C.c.ha = slm 9, dig $s;
            };
        }
        
        my $d = G&o,$et,{liveon=>$C,t=>'this',%$c};
        $s = dc&s;
        
        local A.V = 1;
        my $g = s.y.tv.je->{0.031};
        if ($i == 1) {
            g.y.OA = $one;
        }
        if ($i == 3) {
            my $t = "3.141 - keeps y-ering when sleeping";
            if (g.y.OA eq $one) {
                saygr "ok $t";
            }
            else {
                sayre "not ok $t";
                push @fail, $t;
            }
        }
        #sayyl "g.y.A.c.el: ". G&aC,$g;
        #saygr "Andyour: ". G&aC,$r;
        
        for (qw'Cora Core') {
            my $t = $_.'_'.$i;
            my @l = @{d.sc.>$_ || []};
            
            my $r = $da.>$t;
            my $l = [map{ $muteNews->($_) } map { 
                _.y.A.c.el. join('',('  ')x _.y.A.c.ind).
                G&aC,$_  ." -- ".ki(_.c)."  %  ".ki(_.sc)
            } @l];

            my $fail = 0;
            if (!$r) {
                $fail++;
            }
            else {
                my $miss; # show gaps
                for my $ls (@$l) {
                    my $rs = shift @$r;
                    ($rs) = '<undefined>', $fail++ if !defined $rs;
                    if ($ls eq $rs) {
                        $miss = '...' if defined $miss;
                        next;
                    }
                    sayre $miss if $miss;
                    $miss = '';
                    sayre "Line: $ls", "Isnt: $rs";
                    $fail++
                }
                sayre "Line!", "Isnt: $_" for @$r;
            }

            my $i = ++Gc&oki;
            if ($fail) {
                sayre "not ok $i - $t";
                saybl ' ',' ',"      [$t=><"."<"."''],";
                saybl map { "            $_" } @$l;
                saybl '','','';
                push @fail, "$i - $t";
            }
            else {
                saygr "ok $i - $t";
            }
        }
    }
    @fail ? join(", ", @fail) : ();
Blan: |
    Jc&tape = 1;
    u 'pi/blad'=>''=><<'','of:w'
        Jc&save = Jc&tape = 1;
        if ($s > 1) {
            n seem=>-blad=>($s-1),'dis';
        }
        else {
            my $i = Js&bowls++ > 1 && 4;
            n Sem=>$i=>"Seol",'dis'
            m Semiot=>''=>"Bar $_",'dis' for 1..(6+Js&bowls);
            m Some=>''=>"FFF $_",'dis' for 1..(4+int(Js&bowls * 1.8));
            Js&bowls > 3 &&
            n so=>8=>"ou Js&bowls"
        }
    Js&bowls++ > 3 && y.imp++;
    n blador=>"-blad"=>2
    
Blad: |
    n Blan
    n Blan
    n Blan
    n Blan
    n Blan
Walkit: | # crawl tv
    u i
    
    # climb in/next/z of $s with a sub $y
    # returns big flat (Cora) list of the sub's returns
    # $y ||= &Cd{ $C }
    ind: %acgt:s y d
        my $D = $s;
        
        # dedupe for things via z and in, etc.
        my $ref = "$s";
        my $r = d.refs ||= {};
        $r.>$ref && return;
        $r.>$ref = $s;
        
        unless (d.nohup) {
            $s = G&hup,$s;
            s.y.D = $D;
        }
        $y ||= sub { shift };
        if (!ref $y) {
            if ($y eq 'aC') {
                $y = &C{ G&aC };
            }
            else {
                die "ind y named $y?";
            }
        }
        my $d = {%{$d||{}}};
        d.path = [@{d.path||[]}, "s.t s.y.cv"];
        d.ind = '  ' if !defined d.ind;
        # ^ accumulates on every depth's return
        d.d++;
        my @out;
        
        # the two ways to go deep, should both?
        if (my $z = ss&z) {
            @$z = grep{defined} @$z;
            d.zort && d.zort->($z,$s,$d);
            push @out, map{ G&ind,$_,$y,$d } @$z;
        }
        if (my $in = s.y.in) {
            push @out, G&ind,$in,$y,$d;
        }
        my $my = [];
        @out = map {
            ! ref$_ ? join "\n", map {d.ind."$_"} split "\n", $_ :
            ref $_ eq 'HASH' ? do{
                if (!d.noind) {
                    if (!_.c.ind) {
                        _.c.ind = d.d;
                        _.c.inds = join'', (d.ind) x d.d;
                        push @$my, $_;
                    };
                    unshift @{_.c.inside||=[]},s.t;
                }
                $_
            } :
            $_
        } grep {defined} @out;
        
        if (my $next = s.y.next) {
            my $d = {%$d};
            d.path = [@{d.path||[]}];
            pop @{d.path};
            push @out, G&ind,$next,$y,{%$d,d=>d.d-1};
        }
        
        unshift @out, $s = $y->($s,$d);
        
        @out = grep{$_} @out;
        return () if !@out;
        
        if (d.d == 1 && !grep{ref}@out) {
            @out = grep{defined} @out;
            wantarray ? @out : join "\n", @out;
        }
        else { # an $N?
            s.sc.z = $my if @$my && ref $s eq 'HASH';
            return grep{$_} @out;
        }
        
    # from s/84 Ghostig outdate-thinker
    # map reals with an acgt
    M:
        my $M = A&M || die "No M";
        my $su = A&suM; # superstructure
        my $go = {}; # leaving
        @$M = grep {!$go.>$_ } map {
            my $C = $_;
            if ($su.>$C ) {
                $C
            }
            else {
                my $new = $s->($A,$C,$G,$T);
                # as &h, have T checki
                # counts its keys around the call
                # that passes waved to throat
                # as W=Usual knows T.C, .Z/not/etc is throaty
                if (!$new || delete T.not) {
                    $new = $go.>$_ = $_ for {};
                }
                $new
            }
        } @$M;
        
    # GOING (s/6:nogindex)
    # tiny little git, hash stabiliser
    # reuses refs if they look the same
    superindex: %acgt
        my $had = {map { $_=>C.sc.>$_ } @Me};
        (sub {
            my $now = {map { $_=>C.sc.>$_ } @Me};
            
            ddump($had) eq ddump($now) || return;
            
            C.sc.>$_ = $had.>$_ for @Me;
            
        }, map { C.sc.>$_ = {} } @Me);
    

