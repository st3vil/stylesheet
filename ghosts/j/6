SelfConsciousness: | # your fish brain
    n FishBrain
    
    n Houp
    n Koul
BuildFish: |
    my $e = djson <<'';
        {"c":{"W":"Jig","e":{"c":{"pi":"Gdo","s":"Especially"},"sc":{"everything_under":"SelfConsciousness","z":[{"c":{"W":"SelfConsciousness"},"t":"SelfConsciousness"},{"c":{"W":"Process"},"t":"Process"},{"c":{"W":"HaMachine"},"t":"HaMachine"}]},"t":"peace/new","y":{"cv":""}}},"sc":{},"t":"Jig","y":{"cv":""}}
    
    Rw CloningProcess;
    #
    Gc&bay = 'peace';
    n $e
    
    sayre "Become thingz!";
    exit;
    
FishBrain: | # beginning middle and end superimposed on J's state
    u i
    s: %acgt:c sc
        sayyl "oscillating!";
        $A = G&A,s=>0=>$c,$sc;
        # s could order a particular ground
        Rw FishBrains $A;
PostO: | # make O's a&swim elvises happen, feed into r.y.tv
    # all current O, even asleep/A&el=8
    my @aO = map { _.y.OA || die "noOA: ".ki$_ }
        #map { _.y.OA || die "NoOC: ".ki($_)."\n\ny: ".ki _.y; }
        @{A&Cora};
    
    # phil:
        # wOrms, in-wormholes
        #   where thing is our part of some sharing of truth
        # is one-ish with:
        # < waves of language solvents
        # all basically generating ongoing job lists
        # usually pumping so-classified things through some filter
        # everything moving comes classified as some elvis
        #   so s&of encodings happen now
        #   and W doings on other hosts emit through Op
        #   W doing might be updating it on the news...
        
        # another use for o be the upping/downing of indexes
        # amongst sources that may not all be awake.
        
        
    # take Os&swom (via J), Os&swim (from C) through concludoors
    # in usual yt order, may be dupey,
    # to clobber in o ut
    # < the elvising (of,javascript) to have more sense
    #   about whether we should already o things to it,
    #   depending on weight...
    # - but code might appreciate having competitors compiled?
    
    # swom things are lower priority than swim things
    for my $O (@aO) {
        my $c = Oc&s;
        my $swom = Os&swom || next;
        each W,Wt,Wcv,Dt,Dcv,D $swom {
            Os&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv ||= $D;
        }}}}}
    }
    
    for my $O (@aO) {
        my $c = Oc&s;
        my $swim = Os&swim || next;
        each W,Wt,Wcv,Dt,Dcv,D $swim {
            if (my $i = a&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv ) {
                my $d = i.c.s;
                saygr G&sn ." c.t c.y.cv overs $Wt/$Dt $Dcv from d.t d.y.cv";
            }
            a&swim.>$W.>$Wt.>$Wcv.>$Dt.>$Dcv = $O;
        }}}}}
    }
    
    each W,Wt,Wcv,Dtv a&swim {
        # sleep based on each set's sources being stable
        # < stuff hoisted via J is already encoded
        # < and may be linkable, depending on that repository's nature
        #   avoiding re-elvising laws undisputed
        my $move = 1;
        if (my $his = s&swim.>$W.>$Wt.>$Wcv ) {
            $move--;
            each Dt,Dcv,O $Dtv {
                Oc&el ne '8' && $move++;
                my $o = $his.>$Dt.>$Dcv;
                $o && oc&s.t eq Oc&s.t 
                && oc&s.y.cv eq Oc&s.y.cv || $move++;
            }}
            each Dt,Dcv,o $his {
                my $O = $Dtv.>$Dt.>$Dcv;
                $o && oc&s.t eq Oc&s.t 
                && oc&s.y.cv eq Oc&s.y.cv || $move++;
            }}
        }
        unless ($move) {
            a&swum.>$Wcv.>$Wt = s&swum.>$Wcv.>$Wt || die "no swum $Wcv $Wt";
            sayre G&sn ."Seems to be the same... $W $Wt $Wcv";
            # elvis checks his stuff is still at the hut
        }
        else {
            my $z = [];
            for my $O (@aO) {
                my $Dtv = Os&swim && Os&swim.>$W.>$Wt.>$Wcv || next;
                # random order here, o ut will sort
                each Dt,Dcv,D $Dtv {
                    # D pushed thing, clone if C
                    $D = G&hup,$D if $D eq Oc&s;
                    push @$z, $D;
                }}
            }
            die "Nothing ordered $W $Wt $Wcv?" if !@$z;
            # todo elvising
            my $w = a&We.>$Wcv.>$Wt;
            my $W = a&We.>$Wcv.>$Wt = G&Ct,[$Wt=>$Wcv,{W=>$W}];
            Wc&nogro = 1; # ?
            my $e = Wc&e = G&Ct,[Swim=>3];
            ec&z = $z;
            
            $w && die "We already: ".ki($w)."\nvs: ".ki$W;
        }
    }}}
    
    
    # extra z goes after/over OCs
    # sort what to do could get smaller if we go by aO
    for my $Wcv (sort keys %{a&We}) {
        my $Wts = a&We.>$Wcv;
        for my $Wt (sort keys %$Wts) {
            my $W = $Wts.>$Wt;
            # sends to the particular language workshop
            # nomem = its J (of,javascript) won't hang around
            $W = G&e,\'nomem',$W;
            # makes a cW=of
            my $D = G&Ct,[$Wt=>$Wcv,{W=>Ws&W}];
            # compilations come back
            Ds&z = Ws&z;
            Ds&z ||= Wc&e.c.z;
            Ds&z || sayre "W no z ".ki$W;
            
            a&swum.>$Wcv.>$Wt = $D;
        }
    }
    
    # add them under root 9
    # z clobber them...
    each Wcv,Wt,D a&swum {
        my $w = r.y.tv.>$Wt.>$Wcv;
        r.y.tv.>$Wt.>$Wcv = $D;
        $w && saygr G&sn ." D: ".ki($D)."\n\n $Wt $Wcv probably swum over by ".ki$w;
    }}
    
    # live on the live on-er
    s&swum = a&swum;
    s&swim = a&swim;
    # stuff gets noticed in K
    
Houp: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        # is OC
        # OA=O, A=o
        my $o = C.y.A;
        o.t eq 'o' || die "No oA: ".ki $o;
        
        A&el = oc&el;
        
        # put O
        C.y.OA = $A;
        
        # < more recur?
        
        # < making this stick...
        T.not = 1 if C.sc.not eq '1';
        
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of', 'js') {
            if (my $Wt = C.sc.>$W) {
                my $W = $W eq 'js' ? 'javascript' : $W;
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W  ".G&aC,$C;
            }
        }
        
        # indexed ground within universals
        if (my $J = !s&noii && s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.I; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scI $t/D.t no in";
                    while ($S) {
                        a&swom.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W  ".G&aC,$S;
                        $S = S.y.next;
                    }
                    $D = D.y.over; # the next ii?
                }
            }
        }
        
        # do when el is so
        if (my $sel = 1s&sels) {
            # limited to those under 9?
            $sel = {} unless C.y.up eq A&r;
            each k,els $sel {
                exists C.sc.>$k || next;
                each el,do $els {
                    A&el eq $el || A&el eq '2' && $el eq '1' ||
                    $el eq '5' && A&el < 4 || next;
                    G&h,$do;
                }
            }
        }
    
    # O 56 muchofany Style if joiner
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv,
    # Scuttle
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;

