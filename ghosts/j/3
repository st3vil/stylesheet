LeMachine: | # drip feeding PiMachine
    # wants to have pointers to W
    # with the suggestion that you Believe them together
    # the stowexp fails gracefully enough since it's last thing to do
    # the believers of LeMachine (Jigdoer/stylehouse.pl) put it together from its /W 
    y.at.massive = 1;
    
    n Atool
    n Sequencing
    n Placement
    n Intel
    n ForJ
    n Tangle
    n Stuff
    
    n Stylehousing
    
    n Art
    
    n Storage
    n Elvising
    n Tripical
Atool: | # reliable/old A
    u i
    # snakinfo
    Aup:
        my $ay = $A;
        my @A = $ay;
        push @A, ($ay = ay.up) while ay.up && ay.up ne $ay;
        my $Ats = join' ',reverse map{_.t}@A;
        return $Ats;
        

Jigdoer: | # 0 bootstrap a G from W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    A.6.t = 'vil';
    A.5.t = 'via';
    G.c.bay || die "will need G";
    # < get traceably these things its adding...
    
    my $eh = hitime();
    
    # slurp these stored W for composing normal
    my @W = grep {$_} map { /^n (\w+) */ }
        split "\n", G.way.LeMachine;
    my @set = map {
        my $f = G&Locate_read,$_;
        $f .= "/1";
        -f $f || die "NO such $_ ($f ?)";
        $f
    } @W;
    
    # make $Believe->($N) able
    my @suub = map {
        my ($t,$args) = @$_;
        my $s = G.way.>$t || die "No $t";
        my $C = G&Ct,[$t=>1=>{s=>$s},{args=>$args,of=>'w'}];
        G&perlcode,$C;
        'my $'.$t.' = '.c&s;
    } [Beach=>'s,f'],[Believe=>'N'];
    
    my $bab = &s{
        my $C = G&Ct,["someba"=>1=>{s=>$s}];
        G&CoBabbler;
        C.c.s
    };
    
    my @inc = ('G');
    my $perl = join "\n\n",
        G.way.strictwarn,
        'use FindBin qw($Bin);',
        'use lib "$Bin/othlia";',
        'use lib "$Bin/slib";',
        (map{"use $_;"}@inc),
        'my ($A,$C,$G,$T);',
        @suub,
        'my @f = ('.join(",",map{"\n    '$_'"}@set)."\n);",
        $bab->(G.way.Begin);
    
    my $f = "stylehouse\.pl";
    write_file $f, $perl;
    `chmod +x $f`;
    sayre "Done";
    exit;
Begin: | # 0 stylehouse.pl starts Aing somehow, by Jigdoer
    saygr 'Some more';
    my $N = [map{ @{ $Beach->('',$_) } }@f];
    my $A = $Believe->($N);
    A.t = 'toplevel';
    G.h = G.i.h = A.i.h || die "No h";
    G.w = A.i.w || die "No w";
    G.i.t = A.i.t || die "No t";
    G.ii = A.ii;
    A&C = $C = G&Ct,['topCevel'=>1];
    A&T = $T = {};
    G&Gee; # gives G.way, going
    
    1 && sayre "Ontop";
    $A = G&A,'begin';
    
    my $ar = {};
    Rw Beginning;
    
    1 && saybl "ende.";
Bangular: |
    my $end;
    $SIG{__WARN__} = &{
        my ($s) = @_;
        return if $s =~ /Deep recursion on (anonymous )?subroutine/
            || $s =~ /masks earlier declaration in same/;
        $end->($s);
        warn "Warndg: $s";
    };
    my $lastts;
    $SIG{__DIE__} = $end = &s{
        return if $lastts >  hitime() - 1;
        sayre "SIGDIE began: ".slim(40,$s);
        $lastts =  hitime();
        $s && $@ && sayre "stackend with \$@ and arg0";
        $s ||= $@;
        $s ||= do { saygr "\$@ was blank"; $_[0] };
        local $@;
        eval { G::confess( 'yab' ) };
        my @stack = split m/\n/, $@;
        
        shift @stack for 1,2; # this sub and that eval ^
        if (0 || $stack[-1] =~ /^\s+Mojo::IOLoop::start/) {
            pop @stack until $stack[-1] !~ /Mojo|eval/;
        }
        
        my @stock;
        my $stacking;
        # suckup string spilling out of a line
        for my $l (@stack) {
            if ($stacking) {
                if ($l =~ /^\t\S/) {
                    $stacking = 0;
                    push @stock, $l;
                }
                else {
                    push @{$stock[-1]}, $l
                }
            }
            elsif ($l =~ /^\teval '/) {
                $stacking = 1;
                push @stock, [$l];
            }
            else {
                push @stock, $l;
            }
        }
        @stack = map { ref $_ ? join "\n", @$_ : $_ } @stock;
        
        @stack = map{
            my $l = {y=>{}};
            ls&dataline = $1 if s/, <DATA> line (\d+)\.\n?$//s;
            
            if (/^\s*(?:eval \{\.\.\.\} |([^\(\s]+)::([^\s\(]+?)\((.+)\) )called at (\S+|\(eval \S+\)) line (\d+)$/) {
                ls&pack = $1 if $1; # usu main, undef for eval{}
                ls&sub = $2 if $2; # usu __ANON__, "
                ls&Mes = $3 if $3; # stringified @_
                ls&file = $4 if $4; # usu (eval \d+) or stylehouse.pl
                ls&line = $5 if $5; # in the code above this call
            }
            elsif ($_ =~ /^\teval '(.+)' called .+?$/sgm) {
                ls&file = 'eval $s';
                ls&string = $1;
                lc&s = $_
            }
            else {
                lc&s = $_
            }
            $l
        } @stack;
        my $B = Gc&B;
        Bs&stack = \@stack;
        
        Bs&callers = [map{ [caller($_)] }0..4];
    };
    sayre "Bangular loaded";
Bangilate: |
    # T.h figured it safe from below
    Bs&hand && return;
    
    # bang polished, pass out
    # on each enclosing h
    # < look at caller() eval nums for more stack sync
    #   be good to have lines calling from last Jpin, w, and h
    Bs&foot && return $ba;
    
    Bc&h && die "< Have the handler to $ba things.";
    
    # Bc&s is the first argument to h, may be a D
    my $deB = &B{
        sprintf(" B %-4s %4s %8s", B.t,
            (B.y.cv ne '0.1' && B.y.cv),
            (ref Bc&s ? Bc&s.t : Bc&s),
        );
    };
    my $destack =&t{
        t.t ?
            sprintf(" - %-18s %4s: %s", t.t, ts&line, ts&Mes)
        :   sprintf(" ? %s", G&aC,$t )
    };
    
    # here
    my $D = Bs&D;
    my $d = Bs&bangC || delete(T.bangC) || $D;
    
    # index landmarks
    my $na = {};
    my $Bs = {%{B.sc},%{B.c}};
    Bs.G = $G;
    Bs.T = $T;
    Bs.Dw = D.y.argumented if D.y.argumented;
    each gk,v $Bs {
        next unless $gk =~ /^..?$/;
        my $r = "$v";
        $na.>$r = "$gk";
    }
    my $i = 1;
    for my $v (@{Bs&Me||[]}) {
        my $r = "$v";
        $na.>$r = "arg".$i++;
    }
    for my $n (2..5,'up','up.up','up.up.up') {
        my $k = "A$n";
        my $Y = $A;
        if ($n =~ /\./) {
            my @ks = split /\./, $n;
            $Y = $Y.>$n || next for @ks;
            $Y || next;
        }
        else {
            $Y = $Y.>$n || next;
        }
        my $r = "$Y";
        $na.>$r = $k;
        if (my $C = Y.c && Y.c.s) {
            my $k = $n."C";
            my $r = "$C";
            $na.>$r = $k;
        }
        if (my $T = Y.c && Y.c.T) {
            my $k = $n."T";
            my $r = "$T";
            $na.>$r = $k;
        }
    }
    
    # find landmarks in callstack
    # stack syncy to know G&h's eval number:
    my $hs_file = (caller(0))[1];
    my $st = Bs&stack;
    for my $t (@$st) {
        t.t = delete ts&file;
        t.t = 'h' if t.t eq $hs_file;
        ts&Mes =~ s/\Q$_\E/$na.>$_/
            && do { ts&matches->{ $na.>$_ }++ }
            for keys %$na;
    }
    
    # split callstack around B stack
    # near the beginning of it should be our h call
    # < deduce every h, just to first and from last
    my ($lit) = my ($for,$aft) = ([],[]);
    for my $t (@$st) {
        $lit = $aft if t.t eq 'h';
            #&& 5 == grep{ ts&matches.>$_ } qw'A C G T D';
        push @$lit, $t;
    }
    
    # beyond h/B stack
    if (!@$for) {
        my ($t) = @$for = shift @$aft if !@$for;
        if (t.t eq 'h') {
            eval {
            $d = G&t,i=>'h';
            };
            sayre "Tried to show you h" if $@;
            # dying in G&h, you probably want to know where it came from tho
        }
    }
    my $l = [map{ $destack->($_) }@$for];
    
    # 
    my @Bs;
    my $BB = $B;
    while ($BB) {
        push @Bs, $BB;
        $BB = BB.y.out;
    }
    $BB = $B;
    for my $B (@Bs) {
        # tell aboves we did this
        Bs&foot = $BB;
    
        push @$l, $deB->($B);
        
        next unless $B eq $BB;
        my $i = 1;
        for my $r (@{Bs&Me||[]}) {
            my $s = ki $r;
            my @also;
            if ($r eq $d) {
                $s = G&aC,$r;
                my $sc = ki r.sc;
                $s =~ s/%.+$/%: $sc/;
                @also = "      * described below";
            }
            
            push @$l, sprintf("    arg%d %5s",$i++,$s), @also;
        }
    }
    
    my @fin;
    for my $t (reverse @$aft) {
        last if t.t eq 'h';
        push @fin, $destack->($t);
    }
    if (@fin) {
        push @$l, reverse @fin;
    }
    
    #c codesplatter
    
    (my $clear = $ba) =~ s/, <DATA> line \d+\.//;
    my ($line) = $clear =~ /.+ line (\d+)/g;
    if (my $v = @$for == 1 && $for->[0]) {
        if (v.t =~ /^\(eval \d+\)$/) {
            1 && saygr "line $line really vs&line? from ".ki v.t;
            #$line = vs&line;
        }
    }
                
                my @tri;
                if ($line) {
                    1 && sayyl "Line is $line";
                    my @s = split "\n", dc&s;
                    my ($for,$aft) = (5,3);
                    @tri = ([]); # split into three
                    my $i = 1;
                    for (@s) {
                        $i eq $line && push @tri, [];
                        $i > $line - $for && $i < $line + $aft
                            && push @{$tri[-1]}, $_;
                        $i eq $line && push @tri, [];
                        $i++;
                    }
                    @tri = map {join "\n", @$_ } @tri
                }
                
                
                if(0) {
                my $la = {};
                my @Bs;
                for (@Bs) {
                    my @s = "_.t _.y.cv _s&D.t";
                    next if $s[0] eq 'i 0.1 h';
                    # notice particle hops
                    my $Y = _s&A;
                    if (Y.1 ne la.A.1) {
                        push @s, G&sn,$Y;
                        la.A = $Y;
                    }
                    # fold of=i 0.1 in same A, etc.
                    if (my $L = @s == 1 && $Bs[-1]) {
                        my ($Lt,$st) = map { /(\S+ \S+)/ } $L->[0],$s[0];
                        if ($Lt eq $st) {
                            $L->[0] .= ", _s&D.t";
                            next;
                        }
                    }
                    push @Bs,\@s;
                    # < the one line it came through in D?...
                }
                
                my $ind = '';
                my $Bs = join "\n", map {$_=$ind.$_;$ind.='  ';$_}
                    map{join'  ',@$_} @Bs;
                }
                my $Bs = join "\n", @$l;
                my $code = join "\n>>>>>>>>>>\n", map{
                    join "\n", map{"| ".$_} split "\n", $_
                } @tri if @tri;
                
                my $li = [split "\n", $ba];
                if (@$li > 30) {
                    my (@st,@ar);
                    push @st, shift @$li while @$li && @st < 30;
                    while (@$li && @ar < 5) {
                        push @ar, shift @$li;
                    }
                    $ba = join "\n", @st, @ar ? ("...snip ".(@$li)."...", @ar) : ();
                }
                
                $ba = join "\n\n", grep {defined} $Bs, $code, $ba;
                
                # die...\n keeps first line number
                return $ba."\n";



Zapulism: |
    u a
    0 &&
    mo 123:
        return sayyl "Ok: ".G&aC if C.y.cv >= 0.9;
        sayre "Not doing: ".G&aC;
        T.not = 1;
    nevers 4:
        # is it
    
Stylehousing: | # org Karamean new stuff
    # new t, old G.way
    n Zequines
    n Zunnel
    # muchofany
    n ThArt
    n Hoop
    n ImStatic
    
Zequines: | # 1 things from the network
    # ja
    n DAy
    n ThWay
DAy: | # world primitives
    u i
    # sympathetic to design some stuff
    #c ge, see 64 got
    # hidey machine thats giving you things
    # abstracts w/way/$pin to G.way.$pin
    # $pin must be like-this
    # makes G.way.o.dige.$pin when given overrides etc (House)
    Gee:
        # make G.way.$pin retrieve code
        # going once G&t does all readins
        {
            package Wormhole;
            use G;
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my %o;
                %o = (%o, %{$_}) for @_;
                return bless [{},\%o], $class;
            }
            sub STORE {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                die "Storign o: $v" if $k eq 'o';
                if (o.nonyam) {
                    o.dige->{$k} = slm 12, dig $v unless ref $v;
                }
                $s->{$k} = $v;
            }
            sub FETCH {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                return $o if $k eq 'o';
                $s->{$k} || STORE($e,$k, do {
                    my $il = join('/', grep{defined} o.dir, $k);
                    my $f = o.base.'/'.$il;
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole', $o, {dir=>$il};
                        \%Di;
                    }
                    elsif (-f $f) {
                        o.nonyam ?
                        scalar read_file($f)
                        :
                        LoadFile($f);
                    }
                    else {
                        warn "Wormhole sens nothing: $f";
                        undef
                    }
                });
            }
        }
        my %way;
        tie %way,'Wormhole',{base=>'w/way'},{nonyam=>1};
        G.way = \%way;
        $G
    
    #c te args (i,(ii),W,w) $t $t...
    # find local(ish) things
    # looking up the slope/trail of con centers A.1..5...
    #  ii/We things by default
    #  W and w know how to look in Gspaces for names,
    #  they may also be in ii.w but are too wide to load up
    # i stuff is subs, ii stuff is classes
    # you might also be only after 5uperficia, not the code itself
    # gently pulls in remote resources... if that A takes charge
    
    # only used by throat, possibly osc
    
    # G&t,I=>$of      # for an A.ii.$of/We thing
    #                    bunch of steps for throat
    # G&t,i=>$sub     # for an A.i.$sub/G&$sub
    # ^^ should be compiled nearby
    # G&t,w=>$w     # for a way
    # ^ vaugely nearby
    # G&t,W=>$W        # for a W
    
    # maybe:
    # G&t,'>'=>$W     # for where you can write a W
    # W would want to find themselves then write themselves...
    # < W come up knowing the next gd/staging area
    # < you might want some historic view of it...
    t: %acgt:s t c
        ($s,$t) = ('I',$s) if !$t;
        $t = t.t if ref $t eq 'HASH';
        $C = {t=>$t,y=>{},c=>($c||{})};
        $s = 'ii' if $s eq 'I'; # going
        c&on = $s; # i/ii/w/W
        if ($s eq 'i' || $s eq 'w' || $s eq 'W') {
            (c&on,c&andon) = ('ii',$s);
        }
        c&max ||= 5;
        c&min ||= 0;
        for my $i (c&min .. c&max) {
            my $Y = ($i == 0 ? $A : $A.>$i) || next;
            my $on = $Y.>c&on || next;
            # on = ii, +$t to We thing, what I wants
            if (c&andon) {
                # want We thing's things
                # put us on ii.W.y.tw
                $on = $on.>c&andon;
                $on = on.y.tw;
            }
            
            my $t = $on.>C.t;
            if (my $by = !$t && Ys&tby) {
                my $A = $Y;
                $t = G&$by,$s,$t;
            }
            $t || next;
            c&from = $Y;
            c&inet = $i;
            return $t;
            # t may be just a pointer, to negotiate with c&desire
        }
        return
    
    # an extension to this A's G&t capacity
    # < search path for w/W
    # < G&has linking resource to moment of use (G&w does)
    byt: %acgt:s t
        if ($s eq 'W') {
            my $f = G&Locate_read,$t;
            G&Ct,[$t=>1=>{resume=>$f}];
        }
        elsif ($s eq 'w') {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            my $w = {t=>$s,y=>{}};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
            $w
        }
        else {
            die "Unknown search $s $t";
        }
    
    # deprecated
    # look for thing named $s in We thing named $of, on A net
    wup:
        G&t,w=>$s
    Wup:
        my $l = 
        G&t,W=>$s;
        sayre "Wup not: $s" if !$l;
        $l
        
    
    #c ha make call, in i
    # looks up to 5 many rare/little subs
    # s is code or i t
    # Me precompiled args
    # contexts calls, kinds of frame:
    # B lexical cell joinery
    # D cell itself, T.D is of A throat
    # < T.h is an error handler
    h:
        my $y; # code
        my $D; # C about code
        if (ref $s eq 'CODE') {
            $y = $s;
            if (my $d = T.D) {
                # passed code, happens to be T.D
                $D = $d if dc&code && dc&code eq $y;
            }
        }
        elsif (!ref $s && A.i && A.i.>$s) {
            $y = A.i.>$s;
            if (my $i = A.ii && A.ii.i) {
                $D = i.y.tw.>$s;
            }
        }
        elsif (ref $s eq 'HASH' && ref s.c eq 'HASH' && ref sc&code eq 'CODE') {
            $y = sc&code;
            $D = $s;
        }
        else {
            # avoid using G&h inside G&h:
            $D = G.i.t->($A,$C,$G,$T,'i',$s);
            $D || die "t Look fail:  i/$s   from ".G&sn;
            $y = Dc&code;
        };
        $y || die "no h: $s";
        
        my $uB = Gc&B;# || {t=>'nowhere',sc=>{A=>A.up}};
        my $B = {t=>Ds&of||"?",y=>{cv=>D.y.cv||''}};
        if ($uB) {
            B.y.out = $uB;
            if (my $p = uB.y.in) {
                # uB yin points to first call
                p.y.next = $B;
                B.y.prev = $p;
            }
            else {
                uB.y.in = $B;
            }
        }
        Bs&y = $y;
        Bs&D = $D if $D;
        Bc&s = $s;
        Bc&h = delete T.h if T.h;
        Bs&A = $A;
        Bs&C = $C;
        Bs&Me = \@Me;
        Gc&B = $B;
        Gc&mas && Gc&mas->($A,$C,$G,$T," h B.t D.t");
        ref $y eq 'CODE' || ref \$y eq 'GLOB' || die "B.t not code: ($s) ".G&sn ."  $y ref:"
            .ref($y)."\n   refref".ref(\$y)."\n   ".ki($y)."\n   ".ki $D;
        
        my @r;
        if (wantarray || !Ds&raysens) {
            @r = eval { $DB::single = G.ydrop; $y->($A,$C,$G,$T,@Me) };
        }
        else {
            $r[0] = eval { $DB::single = G.ydrop; $y->($A,$C,$G,$T,@Me) };
        }
        Gc&mas && Gc&mas->($A,$C,$G,$T,"<h B.t D.t");
        Gc&B = $uB;
        
        # sum h
        if ($@) {
            (my$ba,$@) = ($@,'');
            my $s = Rw Bangilate $ba $B;
            die $s if $s;
        }
        wantarray ? @r : $r[0];
    
    
    
    
ThWay: | # meaning of word/contenter
    u i
    # compiles for given args
    w:
        my $ar = {};
        # their $ar (+)
        $ar = shift @Me if ref $Me[0];
        # their args
        my @o = @Me;
        while (@Me) {
            my $k = shift @Me;
            @Me || die "w odd hash after $k: ".ki\@o;
            my $v = shift @Me;
            $ar.>$k = $v;
        }
        ar.__D && die "w __D deprecated: ".ki$ar;
        my $nar;
        # use this w call's ACGT
        # replaced once our A finds code, before its h'd
        $nar.>$_ = delete $ar.>$_ for grep {exists $ar.>$_ } qw'A C G T';
        my @args = sort keys %$ar;
        my $args = join',','A,C,G,T,ar',@args;
        
        # look in of=w up the network to 5
        # they are pins near network of knowledge via T
        my $w = G&wup,$s;
        
        # or the old way,
        if (!$w) {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            $w = {t=>$s};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
        }
        $w || die "No way to $s (on A.1.t's A.t)";
        
        ws&dige || die "w no dige: ".ki$w;
        ws&of || die "w not of: ".ki$w;
        
        my $ark = G.sc.pinark ||= {};
        # dige same across all arg variations
        my $v = $ark.>w.t.>ws&dige.>$args ||= do {
            my $v = G&hup,$w;
            v.y.argumented = $w;
            vs&args = $args;
            G&perlcode,$v,"MakingWay";
            v.c.code || die "no ccode back: ".ki$v;
            $v;
        };
        v.sc.called++;
        
        G&has,\'mo'=>way=>w.t=>w.sc.dige=>1 if A.mo;
        
        T.w = $v;
        my $A = exists nar.A ? nar.A : $A;
        my $C = exists nar.C ? nar.C : $C;
        my $G = exists nar.G ? nar.G : $G;
        my $T = exists nar.T ? nar.T : $T;
        my @arg = map{ $ar.>$_ }@args;
        if (ref $A ne 'HASH') {
            die "Not hashA: ".wdump 3, [$nar,$ar];
        }
        A.i.h->($A,$C,$G,$T,$v,$ar,@arg);
        #vc&code ->($A,$C,$G,$T,$ar,@arg);
    
    # make s.c.code, see of (which sets dige)
    perlcode:
        $C = $s;
        # encapsulate sub with args
        G&CoArgulate;
        # translate into perl
        G&hoh,C.sc,$_ for grep{$_} G&CoBabbler;
        # c&code = eval c&s
        G&Code,$C,@Me;
    
    # c&code = eval c&s
    # l = name of situation
    Code: %acgt:s l
        ($s,$l) = ($C,$s) if !ref $s;
        $l = "$l: " if $l;
        my $Y = $Bun::A;
        delete Ys&stacktime;
        
        T.bangC = $s;
        if (my $B = Gc&B) {
            Bs&bangC = $s;
        }
        my $y = eval sc&s;
        die $l."Nocompile s.t:\n"
            .ind('  ',$@)."\n"
            if $@;
        die $l."Not code s.t: ".ki($s)
            if ref $y ne 'CODE' && !ss&subpeel;
        delete T.bangC;
        sayre join"\n", "Warning from $l s.t s.y.cv"
            if delete Ys&stacktime;
        
        sc&code = $y;
    
    n $_=>1=>G.way.>$_ for qw'CoArgulate CoBabbler';
    
    # compiler for old G.w
    n won=>'',join("\n",map{G.way->{$_} || die "no $_"}qw'CoArgulate CoBabbler')
    
    #
    
Zunnel: | # ground action
    u a
    #c n2 ground assembles mind
    n 2:
        my $u = A&u;
        return if A.1.t eq 'os' || A&nomind;
        if (!uc&o) {
            u.c.base = 'Normal'; # the PiMachine
            # base if grind (ground, needs root), whole if just theu
            my $rev = ".u.sc.ch" if u.sc.ch;
            my $V = A.1.t =~ /^[A-Z]/;
            my $gr = G&grind,$u;
            if ($gr) {
                G&A,n=>8=>$u=>[uuu=>9=>{root=>1}];
                # slowly opening & closing a J of the u better than ^
                # but also want to hold u n at 3 til cachable known
                # the relevant page of s (man sesh) then ^ getting whole=?
                # those u s pages get cached somewhere in 4stw.ucache
                #   if simple enough
            }
            saybl "resolves mind$rev: A.1.t".($gr && " (u)");
            # resolve our mind
            # < having the M of u to do now, cache with
            local A.trip;
            local A&trip;
            my $so = G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 1
            if (u.sc.ii) {
                # A.mo = the 6er this n is mindupping
                # A = this A, already fell off A.mo
                # A.1 = an fyi for the J, may want only the most something mind
                for (A.mo, $A, A.1) {
                    _.ii = u.sc.ii;
                    _.i = u.sc.i || die "No i on A.1.t u";
                }
                # the mo of A.2 minds from above til here
                # a J's mind has how to get into a J and do its mind
                # see Elvising for inside-outside cooperation
            }
            else {
                sayre "No ii on A.1.t u (o Whole TODO?)";
                1 && saygr "u looks: ".ki $u;
                1 && saygr "uss looks: ".ki u.sc.s;
                for (A.mo, $A, A.1) {
                    _.ii = A.4.ii;
                    _.i = A.4.i || die "No i on A.1.t u ish A.4.t not-whole";
                }
            }
            T.seek = 1;
        }
    #c o2 input protocols read bunches of C
    o 2:
        # resolving to stuff
        if (c&m eq 'A') {
            my $s = c&f = c&s;
            if (sc&s && ref sc&s eq 'HASH' && sc&s.t eq s.t && !s.y.in && !ss&top) {
                saybl G&aC,$s ."   becoming s: ".G&aC,sc&s ."   on ".G&sn;
                $s = c&f = sc&s;
                # from becmoes the real 9
            }
            my $top = ss&top || s.y.in
                || die "o A from no sc top or yin: ".ki$s;
            for my $k ('i','ii') {
                c&finds.>$k =
                    s.sc.>$k ? 1 :
                    s.y.s && s.y.s.sc.>$k ? 'ys' :
                    next;
            }
            c&s = $top;
            c&m = 'C';
        }
        
        # eating stuff
        # < space-for (C) < t < y [many o with .c.s = $e, o.y.etc = etc]
        my $oo = A.c.oo = {};
        my $oat = &o{
            push @{ oo.C.>o.t.>o.y.cv ||=[]}, $o;
        };
        
        # per other itself in 3, way in is noise-ish
        if (c&m eq 'zip') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                v.y && v.y eq $v || die "zip yon not A ".wdump 2, c&s;
                next if $v eq $A;
                next if vc&T && vc&T.not;
                # light cones holding C or doing another o bunch
                my $D = v.c.s;
                if (v.t eq 'o') {
                    # D is inner o's C - index windups
                    D.c.i eq c&i || die "o oth i C.c.i.t <-> D.c.i.t";
                    D.c.j && die "o D.c.t already got j";
                    D.c.jC && die "o D.c.t already got jC";
                    D.c.jC = $C;
                    my $ii = v.c.oo || die "Too early to oo: D.t";
                    my $i = 0;
                    for my $t (keys %{ii.C}) {
                        my $vs = ii.C->{$t};
                        for my $cv (keys %$vs) {
                            my $os = $vs->{$cv};
                            $oat->( G&hup,$_ ) for @$os;
                            $i++ for @$os;
                        }
                    }
                    say "A.t A.c.sip C.t claims $i from: v.t v.c.sip D.t";
                }
                else {
                    # D is J moment C material to shade
                    my $e = G&hup,$D;
                    my $o = G&Chs,$e;
                    o.y.D = $D;
                    o.y.R = $v;
                    o.y.k = $k;
                    $oat->($o);
                }
            }
        }
        elsif (c&m eq 'i') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # inflated t -> s
                my $e;
                e.t = $k;
                e.y.cv = 0.1;
                e.c.s = $v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                $oat->($o);
            }
        }
        elsif (c&m eq 'ii') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # t -> C
                my $e = G&hup,$v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                o.y.D = $v;
                $oat->($o);
            }
        }
        elsif (c&m eq 'C') {
            # C
            my $S = c&s;
            my $p;
            while ($S) {
                ref $S eq 'HASH' || die "NothashC: C.t: ".ki(c&s).":\n  ".ki $S;
                !defined S.t && die "Dodge o m=C: ".wdump 3,
                    ["ot: C.t",S=>$S,after=>$p];
                my $e = G&hup,$S;
                my $o = G&Chs,$e;
                o.y.D = $S;
                if ($p) {
                    os&oz.yprev = $p;
                    ps&oz.ynext = $o;
                }
                $oat->($o);
                $p = $o;
                $S = S.y.next;
                undef $S if c&nonext;
            }
        }
        elsif (c&m eq 'z') {
            # whole [ C... ], not rl
            for my $S (@{ c&s }) {
                ref $S eq 'HASH' || die "Nothashzin: C.t:\n ".ki(c&s).":\n  ".ki $S;
                !defined S.t && die "Dodge o m=z: ".wdump 3, [$S];
                my $e = G&hup,$S;
                my $o = G&Chs,$e;
                o.y.D = $S;
                $oat->($o);
            }
        }
        elsif (c&m eq 'rl') {
            # rl same array growing more el=3 updatey dives
            # make A.c.r from el=3
            die "code rl";
            T.Z.599 = 1;
        }
        else {
            die "How to read ".ki $C;
        }
        
    #c s2 peel ground moments
    s 2:
        # parameters plugged in to s.sc from Jc
        my $pl;
        pl.gripo = delete 1c&gripo;
        pl.base = 1c&base;
        pl.parts = delete upCc&parts;
        pl.whole = 1c&whole;
        while (my ($k,$v) = each %$pl) {
            delete(C.c.>$k), next if !defined $v;
            C.c.>$k = $v;
        }
        my $whole = c&whole;
        
        if (!c&parts && c&imparted) {
            # contains another imping s to resume branching from
            G&imparted;
        }
        
        if (delete 1c&imping) {
            # zipover/zopul/etc reoccur through
            delete C.sc.>$_ for qw'jo swim';
        }
        
        # TODO make C.t for the page of ground this s (C) is for
        # J.t can wander
        my ($zip,$ch) = G&grind,A.1;
        G&always,C.sc,ch=>$ch || die "Chinout: s&ch $ch";
        
        
        # complexity hider, T may want to tho
        $whole = delete c&base if c&base && !$zip;
        A&V = A.1 eq A.3 && A.2.t ne 'u' && A.1.t =~ /^[A-Z]/;
        
        if (my $W = $whole) {
            my $s = ref $W && $W || G&Wup,$W || G&t,$W || die "no $W on ".G&sn;
            # s is a top not an s, but has s.y.s for s
            sayre "WHole! s: A.1.t: s.t" if A&V;
            # m=A makes meta looks
            A&who = G&A,o=>8,$C,$s,'whole',{m=>'A'};
            # s C or J, s&top and/or y.in etc to copy
            # if s.sc.ii/s.y.s.sc.ii (etc) then copy too
            # repoint as tv to this side, to C.sc.ii
            # which is our top.y.s.sc.ii (etc)
            # 
            # gives us s&top, tv, i/ii like osc
            #   can make our own lv for our slice of it
            # letting us export it to the J in 8
            # place on us, eg u.sc.ii, you must 
            return T.Z.8 = $A;
        }
        
        # shade .c down to s (whole/imparted doesn't)
        my $oc = {shade=>1};
        my $tug;
        if (my $d = c&parts) {
            G&imparts;
            return T.Z.76 = $A if c&imparted;
            return T.Z.8 = $A if delete c&sameparts;
            $d = G&hup,$d;
            # have frozen stuff's top
            # make flat z that c&root elects top
            # so o histories (j) work for full J/zip
            my $z = [$d, @{ delete ds&z || []}];
            d.c.root = 1;
            # also, had ground before, now just parts
            undef $zip;
            # parts o are hoisted to zip o
            # things
            oc.nonext = oc.noyin = 1;
            tug.parts = G&A,o=>2,$C,$z,'parts';
        }
        if (my $W = c&base) {
            my $s = ref $W && $W || G&Wup,$W || G&t,$W || die "no $W on ".G&sn;
            sayyl "Base ! ".ki $s;
            my $z = ss&z || s.y.in;
            if (!$z && ref sc&s eq 'HASH' && sc&s.y.in) {
                saybl G&aC,$s ."   basecoming s: ".G&aC,sc&s ."   on ".G&sn;
                $z = sc&s.y.in;
            }
            # TODO know top C with settling clues
            # see s&top above
            tug.base = G&A,o=>2,$C,$z,'base';
        }
        if ($zip) {
            tug.ground = G&A,o=>2,$C,$zip,'zip';
        }
        $tug || die "No ground to A.1.t";
        
        
        c&zip = G&A,o=>6,$C,$tug,'zipover',$oc;
        G&A,c&zip=>6;
ThArt: | # collection of
    # Ang, of=Style etc which lives on 5
    # gives us a gateway over to it:
    n PaintedStripes
    
    n Zpace
    # ^ only compilable on Os
    
    #n Texture
    # know/make patterns for believer's beliefs
ImStatic: |
    u s
    # W in the sac stay themselves
    W 32: %of:mo
        return if c&e;
        return if defined T.H;
        my $safe = 'sac';
        local A.6.t = $safe;
        my $f = G&Locate_read,C.t;
        return unless $f =~ /\/$safe\//;
            my $d = G&Beach,"$f/1" if $f;
            if ($d) {
                sayre "Found C.t W in $f";
                ($d) = @$d;
                c&pretend = $d;
                # get Hosthing's thawJ to do the c&parts, T.Z.7ing
                # doesn't seem to work directly from here (early?)
                T.H = 1;
            }

