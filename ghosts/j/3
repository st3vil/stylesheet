Jaya: | # word particles and waves
    # how to sequence a J (ex Jelly, Sleep)
    n Jaying
    
    # contraptions of J (ex With, Tunnel)
    n Jtool
    
    # flux capacita
    n Sleap
    
BuildJa: |
    my $e = djson <<'';
        {"c":{"W":"Jig","e":{"c":{"pi":"Gdo","s":"An Update"},"sc":{"z":[{"c":{"W":"Jtool"},"t":"Jtool"},{"c":{"W":"Jaya"},"t":"Jaya"},{"c":{"W":"World"},"t":"World"},{"c":{"W":"HaMachine"},"t":"HaMachine"}]},"t":"peace/new","y":{"cv":""}}},"sc":{},"t":"Jig","y":{"cv":""}}
    
    Rw CloningProcess;
    #
    Gc&bay = 'peace';
    n $e
    
    sayre "Become thingz!";
    exit;
    
Jaying: | # how to sequence a J
    u a
    n \'of:mo'
    
    # A.ground? A.place? ||= 1s&place ||= G&sJ,'place'
    # haul long blogs into long J with many bits of place
    # or page or ...
    # they want to commit or abort, be histree for o
    # and be a collection of in-progress C for slow/scattery J
    mo 1:
        A.mo = $A;
        C.y.A = $A;
        # deal with real space?
        C.y.cv = 0.1 if C.y.cv eq '';
        C.y.cv *= -1 if C.y.cv < 0;
        C.y.cv *= 0.1 until C.y.cv < 1;
        if (my $g = !A&nogro && A.ground) {
            push @{gs&z||=[]}, $C
        }
    
    u c
    # various dynamics to the same basic particle
    pi 12:
        $pi || die "Give pi: ".ki$C;
        c&J = "pi/$pi";
    
    # just looking for W, maybe retrieve static?
    # < using T.Z somehow to say jump to 8 after 2,
    #   might be useful for always tripping trips
    V 12:
        c&W = $V;
        A&twotoeight = 1;
    
    # networkily named thing
    W 12:
        ref $s && die "ref cW";
        $W = c&W = C.t if !$W || $W eq '1';
        c&J = $W;
        A&Jup = A.4;
        A&Jcv = 0.1;
        s&W = $W;
    
    # look it up
    J 2:
        T.oT = A.mo.up.mo.c.T;
        my $J = s&J && return;
        A&Jup ||= A.1;
        A&Jcv ||= C.y.cv;
        
        $J = G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv
            unless A&nomem;
        
        s&J = $J;
        
        if (A&twotoeight) {
            T.oT.op = $J && Js&s && Js&s.sc.top;
            return T.not = 1;
        }
    
    # J encode Ï€ 
    # previous J is A.2, may differ from "above" J in J.2
    # esp in W-W situ, their J.2 is A.4/A&Jup
    J 3:
        s&J ||= do {
            !A&nogro && sayyl "J ! C.t".(c&pi && " C.y.cv -".c&pi);
            G&J,A&Jup,C.t;
        };
        A.2 = A.1;
        A.1 = s&J;
        A.3 = s&J.3 = s&J if c&W;
        1c&s = $C; # particle holds passing wave, may tangle
        1c&T = $T; # and that, why not
    
    pi 3:
        s&pi = $pi;
        1c&d = 2c&d + 1;
    
    # W 31 trips
    # W 31 typed - notes W-W connections
    # W 32 Static, if bay/sac/$W forces c&pretend = Beached
    # W 34 thawJ, operates c&pretend
    # e 36 tugs A=E for c&e
    
    #c J/W/pi are now set up in the universal hemisphere
    u s
    # humming - sleepology - osc exports that door us here
    # outside the fully self/u mind
    # can see network protocols of elvis
    # A&E would know if it wants to go in
    # which page we're working on?
    J 4:
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        
        Rw Js&amb $J if !c&e && Js&amb;
        
        # T wants ha or v wants T (by now, etc)
    
    # xoJ 44 - 1s&xo checks way, attracted by 3Cc&forxo, feeds A&want
    #   forxo given by Matu dispatched stuff
    
    
    # J 45 - A&want calculated
    
    # 5 ^ grinds desires into mode of go
    # may not do the whole pin, G&o inputs
    
    # visit the dome of this J
    # where we write pages of stuf
    J 6:
        T.nose && return sayyl "C.t 6 knows";
        
        A&pin ||= c&pin || c&J || s&J.t;
        
        # be Normal for new J
        A.I = A.4.I;
        
        # takeover ground/page ?
        my $ch = '';
        1s&grounds.>$ch = A.ground = G&Ct,[$ch=>1=>{},{J=>s&J}];
        # and sleep from 1s&drains, osc's impressions?
        
        # goner? T to throw in a u on below
        if (my $uz = !Jc&is && 2c&Wunderu) {
            u $_ for values %$uz;
        }
        my $ise = c&e && " (e:".c&e ->{t}.")";
        saybl "St J.t / A.1.t  (A&pin)$ise";
        
        my $c = {root=>1};
        my $y = {cv=>0.9};
        my $sc = y.at = {};
        my $M = [];
        1s&root = G&Ct,[J.t,$y,$c,$sc];
        # begin 9 mo now to give it a Normal A.I
        my $r = G&A,mo=>1=>{s=>1s&root};
        my $ar = c&ar || {};
        my $s = c&s;
        {
            local A.V = 2;
            c&phind = G&c&phin if c&phin;
            Rw A&pin + $J $y $M $s;
        }
        
        T.nose && return;
        1c&imping++ if delete y.imp; # reset lv
        
        c.M = $M if @$M;
        G&A,$r,8;
    
    # join moment to moment
    J 7:
        A&Jup.sc.Jtv.>C.t.>A&Jcv = s&J unless T.nose eq '1';
        # no osc us/ground you but keep J ^ (e to)
        T.not = 1 if T.nose eq '2';
        # was skipping out of 6
        delete T.nose if T.nose eq '7'; # 
        T.nose && return
            sayyl "C.t knows";
        # temp - of wants to load elvis understanding like route handlers
        
        G&s;
    
    # J leaves T.op just outside
    J 8:
        T.oT.op = 1s&s.sc.top;
    
    # < do til 9?
    
Jtool: | # contraptions of J
    u i
    
    # J, they inherit like a stretchier A
    J:
        my ($J,$s) = ref $s ? ($s,shift@Me) : (A.1,$s);
        $A = $J;
        $J = G&A,$s;
        J.1 = $J;
        J.2 = $A;
        $J
    
    # J's support crew
    # who keep normal
    # may be n'd and s'd
    sJ:
        my ($J,$s) = ref $s ? ($s,shift@Me) : (A.1,$s);
        J.sc.>$s ||= do {
            my $j = G&J,$J,$s;
            j.I = 5s&NormalI if 5s&NormalI;
            $j
        };
    
    # adds to ground
    # < sometimes given [C,C,C]?
    #   @$s = ([@$s]) unless ref $s->[0] eq 'ARRAY' 
    #     || ref $s->[0] eq 'HASH';
    n: %acgt
        pop @Me if $Me[-1] eq '';
        G&clusp;
        $C = G&Ct,\@Me;
        #saybl "in: ".G&aC,$C;
        G&A,mo=>8=>{s=>$C};
        #saybl "out: ".G&aC,$C .(s&of && "    of=s&of");
        $C
    
    # the many accumulate in $M, passed in
    # usually given and mo'd by J6
    m: %acgt:M
        pop @Me if $Me[-1] eq '';
        G&clusp;
        push @$M, G&Ct,\@Me;
    
    # ephemeral n without:
    # - clusping the mind, or
    # - attaching to this ground (usu for c.e)
    # < e could be reliabilitied by grounding and osc work
    # usually n \'of:mo' -> C.c.of=mo
    # but for e it A.c.of=mo, for eg nomem
    elph: %acgt
        G&e,@Me;
    e: %acgt
        return G&E,@Me if @Me == 1 && !ref $Me[0];
        pop @Me if $Me[-1] eq '';
        my $c;
        $c = shift @Me if ref $Me[0] eq 'SCALAR';
        $c = $c ? G&peel,$$c : {};
        c.nogro = 1;
        
        $C = G&Ct,\@Me;
        saybl "e: ".ki $C;
        saybl "c: ".ki $c;
        G&A,mo=>8=>{s=>$C,%$c};
        $C
    
    # adds to mind, G&clusp causes it to be made
    u: %acgt
        pop @Me if $Me[-1] eq '';
        my $u = G&sJ,'u';
        saybl "iu: ".G&aC,$C;
        push @{uc&N||=[]}, \@Me;
        
    # clasp u
    # 5s&NormalI is default if no u
    # 5s&NormalC is base, it's s&J holding I as usual
    #   O ii hoists faster than entering everything from the start
    # < only elvising altering We things
    # < lots of I.i things only being on 5 so this has less to chew
    # < knowing I.i never needs to know order/y.next... unless stored
    clusp:
        # before 5/House sets up
        return saybl G&aC ." u are early"
            unless 5s&NormalI;
        
        # u unchanged
        if (my $u = 1s&u) {
            return if uc&N && !@{uc&N};
        }
        my $u = G&sJ,'u';
        uc&is = 'mind';
        my $J = A.1;
        
        J.I = A.I = do {
            my $A = G&A,clusping=>0;
            A.1 = $u;
            A.2 = $J;
            my $N = 1c&N || [];
            1c&N = [];
            if (@$N) {
                local A.trip, A&trip;
                # this may be an alias for speed rather than canonical
                # name should include versions: Normal#3893a73, c#489bc58
                #   being ha, or c#1.42.492 for incremental version
                #   maybe wanting hostnames
                # the 5 might create some W for each mind it makes
                my $uname = slm 15, dig wdump 3, $N;
                1 && saygr G&sn ." u: ".ki $N;
                5s&ucache.>$uname ||= do {
                    1c&is = 'mind'; # static encouraged
                    # enter stuff to form mind
                    
                    my $ch = $uname;
                    1s&grounds.>$ch = A.ground = G&Ct,[$ch=>1=>{},{J=>A.1}];
                    
                    1s&root = G&Ct,[$uname=>9=>{root=>1}];
                    map { G&A,mo=>1=>{s=>$_} }
                    map { G&Ct,$_ }
                        # s&J holding I as usual
                        (5s&NormalC || die "create NormalC");
                    
                    map { G&A,mo=>8=>{s=>$_} }
                        # like a J6
                        1s&root, # must be findable in drain
                    map { G&Ct,$_ }
                        # entered stuff
                        @$N;
                    # 
                    my $s = G&s;
                    ss&I || die "clusp no I, $uname: ".ki $s;
                };
            }
            else {
                #1 && saygr G&aC ." normal I";
                # the 
                5s&NormalI
            }
        };
        # get this J's mo throat to reopen its mind
        T.seek = 1;
       
Sleap: | # desire, S, T, 
    u i
    
    # mark/point
    # sleep/engage mind
    # want to substrata bits of the ground,
    # or headers from bodies of work, making sleep if same
    # $e:
    #    name/Caboutname of how we are being
    #    all being is writing on some ground
    # $s:
    #    names sleep/wake features to have
    #    names/numbers groups of time/etc in the pin
    #      eg test frames
    S: %acgt:e s
        $e ||= 'doming';
        die "Featured e=".ki$e if $e ne 'doming';
        # index s and valve into A sleepmoding thing
        # Sleep has modes to deal
        
        if ($s eq 'no') { # backwards for once
            if (1c&want.once) { # got in somehow
                G&unrea,A.1;
                T.nose = 7; # still, osc
                return 0 # || returns from pin
            }
            else {
                1c&want.once = -7;
            }
        }
        
        G&Sle,$s if A.i.Sle;
        
        if (c&Se && $s =~ /^\d+$/) { # goto section
            my $w = T.w;
            my $max = w.sc.num;
            $max || die "No numbers in w.t";
            if (c&Se == $s) {
                # is it
                #1c&forks &&
                #    Rw Forks $s;
            }
            elsif (c&Se < $s) {
                T.more = 1;
                return 0; # next section later
                # Tesh keeps throwing them,
                # may want to tell something to do more
                # in yay timeframe
                # there go the sections of code that do stuff
            }
            else {
                if (c&Se <= $max) {
                    goto "S_".c&Se;
                }
                else {
                    return 0 # last
                }
            }
        }
        
        # grip mind
        G&clusp;
        
        $A = A.mo; # noop now?
        local A.V = 0;
        G&tug,0.6; # eg E can pos=1 awake
         
        1 unless "can" eq "sleep";
        
    # marks a point for ghost chopchoping, see ElvisDesi
    # also # 38 makes a numerical
    # know line in the way it came from
    # to disambiguate unnamed T points, which just say 'here'
    # we can wake J with T coverage (Tin)
    T: %acgt:e s
        if ($e ne 'doming') {
            # e type of moment of being
            # unknown should grab our attention
            # and/or make savepoint
            # they are runtime ice picks
            # like Escher joins in the space bends of the buildings
            # also similar to sending duplicate placements in lv
            # as if space was real
            die "Given e=$e s=$s";
        }
        G&S; # no s, just engage mind
        
        my $w = T.w || die "T no w: ".ki $T;
        (my $label = 'T_'.$s) =~ s/\W+/_/sgm;
        my $line = G&find_caller_line_labelled,$label;
        if (my $te = A.mo && A.mo.c.T) {
            G&has,\'mo'=>way=>w.t=>w.sc.dige=>1 if A.mo;
        
            # care for finding for way name > T name
            te.has.Tin.>w.t.>$s.>$line ++;
        }
        else {
            warn "T $s outerspace: ".G&sn
        }
        1;
    
    # could also look back for most h/w/throat/J6 call... somehow
    # c/64 Bun uses confess to find printed list of args
    # which we can lookup refs for A,
    # which could overload to print its t/ip
    find_caller_line_labelled:
        my @h;
        my $line; # to disambiguate unnamed T points
        for (0..7) {
            my $l;
            my @q = qw'package filename line subroutine hasargs
            wantarray evaltext is_require hints bitmask hinthash';
            my @ca = caller($_);
            $l.>$_ = shift @ca for @q;
            @q = qw'hinthash line subroutine';
            $l = {map{$_=>$l.>$_ }@q};
            push @h, $l;
            if (my $hh = l.hinthash) {
                if ($hh->{':'} eq $s) {
                    $line = l.line;
                    last;
                }
            }
        }
        $line || sayre "Cannot find $s above: ".ddump \@h;
        $line
        
    
    #c how J 4-5, 6 connection, desires
    # ways in to knowing which dream is where
    u c
    # note the connection
    # for particle knowing in Matu
    typed 31: %of:mo,v:W
        my $t = 1s&typed ||= {};
        my $k = c&e ? 'e' : 'W';
        $t.>$k.>A.2 = A.2;
    
    # should be anywhereable
    # softly linked program structure
    # for when this travel is only for xo.some.some* havers
    # or to do anything to any C at any A, or h/w/n
    # the hard won fishing pole locates truth
    # and:
    # to refresh changed xo.way
    # for just wandering around
    
    # see Ghoster for top level figured travels
    # TODO doesn't want to be u c with v:sJ?
    xoJ 44: %of:mo,v:J
        $J = s&J;
        my $xo = Js&xo || return;
        if (my $xo = 1s&xo) {
            if (my $or = 3Cc&forxo) {
                my $any;
                each name,xop $or {
                    G&pint,$xo,@$xop || next;
                    A&want.forxos.>$name = 1;
                    $any++;
                }
                # contends with xo.way
                A&want.forxo = 7 * ($any ? 1 : -1);
            }
            if (my $ow = xo.way) {
                for my $way (keys %$ow) {
                    my $w = G&wup,$way || next;
                    my $od = {%{ $ow.>$way }};
                    delete $od.>w.sc.dige;
                    if (keys %$od) {
                        A&want.pin = 6;
                        A&want.pins.>$way = 6;
                    }
                    else {
                        # tends to travel anyway
                    }
                }
            }
        }
    
    #c are we in or out
    J 45: %of:mo
        my $de;
        de.mo = A&want if A&want;
        de.C = c&want if c&want;
        de.J = 1c&want if 1c&want;
        $de || return; # continues without thinking
        local A.V = 2;
        my $des = "C.t C.y.cv ".G&sn,3 ." -> ".ki $de;
        
        # want.* is weight if numeric, explanation if ref
        my $eq;
        my @got;
        each ftc $de {
            next if ref $c;
            push @got, $t;
            $eq += $c;
        }}
        my $only = $got[0] if @got == 1;
        
        # want to add counterpoints
        # everything eventually sleeps way/u/W stuff
        
        if ($eq < 0) {
            $only eq 'once' ||
                saybl "Sleep $eq   $des";
            # we can skip 6, our mo C should re-sc from before
             
            my $ou = G&grist,A.2;
            my ($t) = grep {_s&J eq s&J} map {_c&s} values %$ou;
            die "MIssing ground for C.t c.y.cv: ".ki $t if ts&J ne s&J;
            C.sc = {%{t.sc}};
            
            my $to = $eq < -6 ? '8' : '7';
            T.Z.>$to = $A;
        }
        else {
            # FactorEase 
            keys %$de == 1 && de.mo && keys %{de.mo} == 1 && de.mo.elvis eq '6'
            ||
            saygr "Waker $eq   $des";
        }

