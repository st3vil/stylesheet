Stylehousing: | # org Karamean new stuff
    # new t, old G.way
    n Zequines
    
Jigdoer: | # 0 bootstrap a G from W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    A.6.t = 'via';
    G.c.bay = 'bay';
    
    my $eh = hitime();
    
    # slurp these stored W for composing normal
    my @set = map {
        my $f = G&Locate_read,$_;
        $f .= "/1";
        -f $f || die "NO such $_ ($f ?)";
        $f
    } qw'Atool Placement Sequencing Intel ForJ';
    
    # make $Believe->($N) able
    my @suub = map {
        my ($t,$args) = @$_;
        my $s = G.way.>$t || die "No $t";
        my $C = G&Ct,[$t=>1=>{s=>$s},{args=>$args,of=>'w'}];
        G&perlcode,$C;
        'my $'.$t.' = '.c&s;
    } [Beach=>'s,f'],[Believe=>'N'];
    
    my $bab = &s{
        my $C = G&Ct,["someba"=>1=>{s=>$s}];
        G&CoBabbler;
        C.c.s
    };
    
    my @inc = ('G');
    my $perl = join "\n\n",
        G.way.strictwarn,
        'use FindBin qw($Bin);',
        'use lib "$Bin/othlia";',
        'use lib "$Bin/slib";',
        (map{"use $_;"}@inc),
        'my ($A,$C,$G,$T);',
        @suub,
        'my @f = ('.join(",",map{"'$_'"}@set).');',
        $bab->(<<'');
            saygr 'Some more';
            my $N = [map{ @{ $Beach->('',$_) } }@f];
            my $A = $Believe->($N);
            G.c.mas = sub {
                my ($A,$C,$G,$T,$s) = @_;
                1 && saygr "Es: $s";
            };
            A.t = 'toplevel';
            G.h = A.i.h || die "No h";
            G.i.t = A.i.t || die "No t";
            G.c.bay = 'bay';
            1 && sayre "Ontop";
            
            my @ha =  G&Aup;
            $A = G&A,'twanga';
            push @ha,  G&Aup;
            1 && sayyl wdump 3, [Thes=>@ha]
    
    my $f = "stylehouse\.pl";
    write_file $f, $perl;
    `chmod +x $f`;
    sayre "Done";
    exit;

Zequines: | # 1
    # ja
    n DAy
DAy: | # world primitives
    u i
    # sympathetic to design some stuff
    #c ge, see 64 got
    # hidey machine thats giving you things
    Gee:
        # make G.way.$pin retrieve code
        # going once G&t does way all over
        {
            package Wormhole;
            use G;
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my %o;
                %o = (%o, %{$_}) for @_;
                return bless [{},\%o], $class;
            }
            sub STORE {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                die "Storign o: $v" if $k eq 'o';
                if (o.nonyam) {
                    o.dige->{$k} = slm 12, dig $v unless ref $v;
                }
                $s->{$k} = $v;
            }
            sub FETCH {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                return $o if $k eq 'o';
                $s->{$k} || STORE($e,$k, do {
                    my $il = join('/', grep{defined} o.dir, $k);
                    my $f = o.base.'/'.$il;
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole', $o, {dir=>$il};
                        \%Di;
                    }
                    elsif (-f $f) {
                        o.nonyam ?
                        scalar read_file($f)
                        :
                        LoadFile($f);
                    }
                    else {
                        warn "Wormhole sens nothing: $f";
                        undef
                    }
                });
            }
        }
        my %way;
        tie %way,'Wormhole',{base=>'w/way'},{nonyam=>1};
        G.way = \%way;
        $G
    
    #c te args (i,(ii),W,w) $t $t...
    # find local(ish) things
    # looking up the slope/trail of con centers A.1..5...
    #  ii/We things by default
    #  W and w know how to look in Gspaces for names,
    #  they may also be in ii.w but are too wide to load up
    # i stuff is subs, ii stuff is classes
    # you might also be only after 5uperficia, not the code itself
    # gently pulls in remote resources... if that A takes charge
    
    # only used by throat, possibly osc
    
    # G&t,I=>$of      # for an A.ii.$of/We thing/bunch of steps for throat
    # G&t,i=>$sub     # for an A.i.$sub/G&$sub
    # ^ should be compiled nearby
    # G&t,w=>$w     # for a way
    # ^ vaugely nearby
    # G&t,W=>$W        # for a W
    # maybe:
    # G&t,'>'=>$W     # for where you can write a W
    # W would want to find themselves then write themselves...
    # < W come up knowing the next gd/staging area
    # < you might want some historic view of it...
    t: %acgt:s t c
        ($s,$t) = ('I',$s) if !$t;
        $C = {t=>$t,y=>{},c=>($c||{})};
        $s = 'ii' if $s eq 'I'; # going
        c&on = $s; # i/ii/w/W
        if ($s eq 'i' || $s eq 'w' || $s eq 'W') {
            (c&on,c&andon) = ('ii',$s);
        }
        c&max ||= 5;
        c&min ||= 0;
        for my $i (c&min .. c&max) {
            my $Y = ($i == 0 ? $A : $A.>$i) || next;
            my $on = $Y.>c&on || next;
            if (c&andon) {
                # on = ii, go ii.W
                $on = on.y.tw.>c&andon;
            }
            
            my $t = $on.>C.t;
            if (my $by = !$t && Ys&tby) {
                my $A = $Y;
                $t = G&$by,$s,$t;
            }
            $t || next;
            c&from = $Y;
            c&inet = $i;
            return $t;
            # t may be just a pointer, to negotiate with c&desire
        }
        return
    
    # an extension to this A's G&t capacity
    # < search path for w/W
    # < G&has linking resource to moment of use (G&w does)
    byt: %acgt:s t
        if ($s eq 'W') {
            my $f = G&Locate_read,$t;
            G&Ct,[$t=>1=>{resume=>$f}];
        }
        elsif ($s eq 'w') {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            my $w = {t=>$s,y=>{}};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
            $w
        }
        else {
            die "Unknown search $s $t";
        }
    
    # deprecated
    # look for thing named $s in We thing named $of, on A net
    wup:
        G&t,w=>$s
    Wup:
        G&t,W=>$s
    

