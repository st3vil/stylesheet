Stylehousing: | # org Karamean new stuff
    # new t, old G.way
    n Zequines
    
Jigdoer: | # 0 bootstrap a G from W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    A.6.t = 'via';
    G.c.bay = 'bay';
    
    my $eh = hitime();
    
    # slurp these stored W for composing normal
    my @set = map {
        my $f = G&Locate_read,$_;
        $f .= "/1";
        -f $f || die "NO such $_ ($f ?)";
        $f
    } qw'Atool Placement Sequencing Intel ForJ';
    
    # make $Believe->($N) able
    my @suub = map {
        my ($t,$args) = @$_;
        my $s = G.way.>$t || die "No $t";
        my $C = G&Ct,[$t=>1=>{s=>$s},{args=>$args,of=>'w'}];
        G&perlcode,$C;
        'my $'.$t.' = '.c&s;
    } [Beach=>'s,f'],[Believe=>'N'];
    
    my $bab = &s{
        my $C = G&Ct,["someba"=>1=>{s=>$s}];
        G&CoBabbler;
        C.c.s
    };
    
    my @inc = ('G');
    my $perl = join "\n\n",
        G.way.strictwarn,
        'use FindBin qw($Bin);',
        'use lib "$Bin/othlia";',
        'use lib "$Bin/slib";',
        (map{"use $_;"}@inc),
        'my ($A,$C,$G,$T);',
        @suub,
        'my @f = ('.join(",",map{"'$_'"}@set).');',
        $bab->(<<'');
            saygr 'Some more';
            my $N = [map{ @{ $Beach->('',$_) } }@f];
            my $A = $Believe->($N);
            G.c.mas = sub {
                my ($A,$C,$G,$T,$s) = @_;
                1 && saygr "Es: $s";
            };
            A.t = 'toplevel';
            G.h = A.i.h || die "No h";
            G.i.t = A.i.t || die "No t";
            G.c.bay = 'bay';
            1 && sayre "Ontop";
            
            my @ha =  G&Aup;
            $A = G&A,'twanga';
            push @ha,  G&Aup;
            1 && sayyl wdump 3, [Thes=>@ha]
    
    my $f = "stylehouse\.pl";
    write_file $f, $perl;
    `chmod +x $f`;
    sayre "Done";
    exit;

Zequines: | # 1
    # ja
    n DAy
DAy: | # world primitives
    u i
    # sympathetic to design some stuff
    #c ge, see 64 got
    # hidey machine thats giving you things
    Gee:
        # make G.way.$pin retrieve code
        # going once G&t does way all over
        {
            package Wormhole;
            use G;
            use Tie::Hash;
            our @ISA = qw(Tie::ExtraHash);
            sub TIEHASH {
                my $class = shift;
                my %o;
                %o = (%o, %{$_}) for @_;
                return bless [{},\%o], $class;
            }
            sub STORE {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                die "Storign o: $v" if $k eq 'o';
                if (o.nonyam) {
                    o.dige->{$k} = slm 12, dig $v unless ref $v;
                }
                $s->{$k} = $v;
            }
            sub FETCH {
                my ($e,$k,$v) = @_;
                my ($s,$o,@o) = @$e;
                return $o if $k eq 'o';
                $s->{$k} || STORE($e,$k, do {
                    my $il = join('/', grep{defined} o.dir, $k);
                    my $f = o.base.'/'.$il;
                    if (-d $f) {
                        my %Di;
                        tie %Di, 'Wormhole', $o, {dir=>$il};
                        \%Di;
                    }
                    elsif (-f $f) {
                        o.nonyam ?
                        scalar read_file($f)
                        :
                        LoadFile($f);
                    }
                    else {
                        warn "Wormhole sens nothing: $f";
                        undef
                    }
                });
            }
        }
        my %way;
        tie %way,'Wormhole','w/way',{nonyam=>1};
        G.way = \%way
        $G
    
    #c te args (i,(ii),W,w) $t $t
    # find local(ish) things
    # looking up the slope/trail of con centers A.1..5...
    #  ii/We things by default
    #  W and w know how to look in Gspaces for names,
    #  they may also be in ii.w but are too wide to load up
    # i stuff is subs, ii stuff is classes
    # you might also be only after 5uperficia, not the code itself
    # gently pulls in remote resources... if that A takes charge
    t: %acgt:s c y
        ($y,$c) = ($c,$y) if ref $c eq 'CODE';
        $C = ref $s ? $s : {t=>$s,y=>{},c=>($c||{})};
        c&on ||= 'ii';
        c&max ||= 5;
        c&min ||= 0;
        for my $i (c&min .. c&max) {
            my $from = $i == 0 ? $A : $A.>$i;
            $from || next;
            
            my $on = $from.>c&on || next;
            
            my $t = $on.>C.t || next;
            $t = $y->($t,$from,$i) if $y;
            $t || next;
            c&from = $from;
            c&inet = $i;
            return $t;
        }
        return
    
    # look for thing named $s in We thing named $of, on A net
    #   old way to look inside a ii.$t thing
    wup: %acgt:s of
        $of ||= 'w';
        my $want = sub {
            my ($t,$f,$i) = @_;
            # if i > netmask
            # if t mentions some other way to get it
            keys %$t < 2 && sayre "wup t looks funny: ".ki($t)."\n  ".G&sn;
            my $tw = t.y.tw || die "w $s found no ytw on"
                ." A.1.t s A.t @ $i (f.t): ".ki$t;
            $tw.>$s
        };
        G&t,$of,$want;
    
    # wup including G.way (going)
    wops:
        my $w = G&wup,$s;
        
        # or the old way,
        if (!$w) {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            $w = {t=>$s};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
        }
        $w
    
    # W is the of=W, could be pointer to load the rest
    # 
    Wup: %acgt:s of
        $of ||= 'W';
        my $W = G&wup,$s,$of || return;
        my $s = W.c.s;
        ref $s eq 'HASH' || die "No Wup $of: $s: ".ki $W;
        $s;
    

