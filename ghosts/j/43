Wormhall: | # over sight
    nodes always send stuff outwards:
        stuff is string, may know the data it came from
        send may be give but prefer linkage
        outwards may be a host, bay/$G/$W, bay/p/G.t/$W
        $W to and $W is sameish...
    
    anyway
    
    show all the fork/listen/addressing action in this file...
Wall: | # your publisher
    # write them
    Jc&write = 1;
    if (c&route) {
        # send links to Ilan
        Jc&only = '7';
        Jc&route = c&route;
    }
    else {
        # write them in Wall
        Jc&tape = 'W';
        Jc&save = 'W';
    }
    # < put Writings, with journaling
    # also the furthest provider
    # A.5 gives some requests for things/way to it
    # you need local Wall way to use Wall to get more way
    
    Js&ein.t.get.sMJ = &sMJjeTCA{
        G&give:Budge=>["wants to get for ".G&sn => $e];
    };
    Js&ein.t.s.sMJ = &sMJjeTCA{
        G&give:Budge=>["wants to s for ".G&sn => $e];
    };
    # mostly takes what is from this process and externalises it
    Js&ein.t.put.sMJ = &sMJjeTCA{
        # should know about appending queues by its name, eg p/$$/in
        #G&give:Budge=>["wants to put for ".G&sn => $e];
        local A.V = 1;
        if (my $z = 1s&have.>s.t ) {
            sayyl "Updating s.t ss&Jo";
            %$z = %$s;
        }
        else {
            sayyl "Setting s.t ss&Jo";
            1s&have.>s.t =
            m $s
        }
        saybl "Nowat: ".G&aC,$_ for @$M;
        
    };
    S
    my $l = Js&Keld = {};
    l.ha.9 = &acgts{
        my $W = C.y.up;
        my $f = Ws&f || die "No fileer! ".ki $W;
        my $t = C.t;
        sayre "Want rm: ".G&aC;
        sayre "  rm $f/$t";
        
    };
    l.ha.5 = &acgts{
        my $W = C.y.up;
        my $f = Ws&f || die "No fileer! ".ki $W;
        
        my $s = c&s;
        my $ha = s&ha;
        my $hf = "h/".$ha;
        my $t = C.t;
        
        `mkdir -p $f/h` if !-d "$f/h";
        write_file("$f/$hf", $s) unless -e "$f/$hf";
        if ($t) {
            `unlink $f/$t` if -e "$f/$t";
            `ln -s h/$ha $f/$t`;
        }
        
        return if Jc&only && Jc&only ne $t;
        # < set by the T for the Opper...
        #return unless Jc&route;
        # want to elvis with net sense
        my $to = "Opper";
        my $w = Jc&route || "Elan";
        my $sc;
        $sc.>$_ = W.sc.>$_ for grep{!ref W.sc.>$_ } keys %{W.sc};
        Rw Wudder $to $s:_ for [$w=>[W=>''=>{f=>$f,t=>$t,ha=>$ha},$sc]];

        
        sayre "Want put: $f/$t: ".G&aC;
        1 && sayyl " -  ".G&aC,$W;
    };
    _.y.cv = 1 for @{Js&M||[]};
    m $_ for @{Js&M||[]};
    #_c&s = slm 9, _c&s for @$M;
    #_c&s =~ s/\W//g for @$M;
Elan: | # O's zip of U, W switchup
    # & tractor e into a new Udder
    Rw Tiot;
    Jc&tape = 'Dejo' if J.t eq 'Ilan';
    Jc&save = 'W';
    y.res = 100;
    y.at.left = '60%';
    y.at.top = '70%';
    y.at.ab = 1;
    Js&Simp = 'Sweeptapes';
    Js&Cimp = 'Pause';
    Jc&refit_t = &C{
        "s&so C.t"
    };
    Js&ein.t.plaz.sMJ = &sM{
        # from another self, sends a plaz
        sayre "Sendplaz";
        m $s
    };
    Js&ein.t.W.sMJ = &sMJje{
        # from Wall, crunch to W
        $s = G&hup,$e;
        if (ss&W eq J.t) {
            T.pos = 0;
            return sayre "Self J.t ing" 
        }
        s.t = delete ss&W;
        local A.V = 1;
        if (my $z = 1s&have.>s.t ) {
            sayyl "Updating J.t's s.t: ss&f ss&Jo";
            %$z = %$s;
        }
        else {
            sayyl "Setting J.t's s.t: ss&f ss&Jo";
            1s&have.>s.t =
            m $s
        }
        1 && saybl "Nowat: ".ki $M;
        1 && saybl "Hvae: ".wdump 4, $e;
    };
    Js&ein.t.f.sMJ = &sMJjeTCA{
        sayre "For f: $s";
        if ($s =~ m{(.+)/p/(\d+)/W/(\w+)\.(\d+)}) {
            my ($d,$p,$t,$i) = ($1,$2,$3,$4);
            my $in = Js&index ||= {};
            my $new;
            my $C = $in.>$t.>$p ||= do { $new++; {y=>{}} };
            C.t ||= $t;
            C.c.pi ||= 'plaz';
            s&flv ||= [];
            # ^ ref will keep between Js&M C and mo C
            # which pi/pin sees
            s&pid = $p;
            
            # find so/pa for self
            s&so ||= do {
                my $p = Rw Fishis $p;
                s&ppa = ps&ppa;
                ps&so;
            };
    
            # continuing W with parent pid
            if (my $p = delete $in.>$t.>s&ppa ) {
                s&ie = ps&ie;
                @$M = map { $_ eq $p ? $C : $_ } @$M;
                $new = 0;
                if (my $hi = ps&history) {
                    @$M = grep { _c&s ne $hi } @$M
                }
                my $M = c&forum = [];
                s&history = $p;
                ps&future = $C;
                m "$t ps&so"=>-pold=>{s=>$p}
                Js&blab = 1;
            }
            # same W stage appears from next fork
            elsif (s&so =~ /^((?:\d+ )+)?(\d+):/) {
                my ($tun,$ti) = ($1,$2);
                $ti--;
                if ($ti >= 0) {
                    my ($p) = grep { _s&so =~ /^$tun$ti:$t/ } @$M;
                    if ($p) {
                        my $t = "$t ps&so";
                        my $n = G&Ct,[$t=>-pold=>{s=>$p}];
                        @$M = grep { ps&progresses ne $_ } @$M;
                        ps&progress = $C;
                        s&progresses = $n;
                        @$M = map { $_ eq $p ? $n : $_ } @$M;
                        Js&blab = 1;
                    }
                }
            }
            
            Rw Rebase $C $d $p $t $i;
            
            if (my $f = s&flv->[-1]) {
                if (my $r = fs&lv->[0]) {
                    s&poe = rs&poe if rs&poe;
                    if (my $on = c&sit || rs&sit) {
                        c&sit = $on;
                        # 9 says hold over there
                        $on = $on.'lan' if 1 == length $on;
                        G&elph,$on=>[plaz=>{s=>$C}];
                        return T.pos = 0;
                    }
                }
            }
            return unless $new;
            
            # so takesover parent's t not insys
            #   spawning little differ above, as old self
            # 
            
            $new && push @$M, $C;
        }
        else {
            die "Other Ilan ting: $s";
        }
    };
    S
    y.imp++ if A.4.t eq 'Os' || !Gc&tapescontinue;
    Js&Pause && return 
        n Paused=>''=>"Paused"
    my $m = Js&M||[];
    @$m = map { @{delete(_c&forum)||[]}, $_ } @$m;
    #sayyl "A.1.t! ".wdump 3, Js&M;
    
    m $_ for @$m;
BayFishing: | # become Op/Ud node, see 822
    my $p = $$;
    $| = 1; # autoflush output channel
    # Ilan, W tape spool, trusts lvs to join sanely
    # else it y.imp++, replays everything per change
    Gc&tapescontinue = 1;
    
    # mkoJ called by Wout, sends lines with Ilan on Opper
    # Opper Ilan $f elvised by Ualve on Udders
    #     Ilan unifies names/routes points by elvising Win
    G.mkoJ = &Wc{
        c.holst = $W; # geoplace on desk section
        my $Y = Gc&B.sc.A;
        c.Y = $Y; # A coming from
        G&elph,NetPut=>[out=>1=>$c]
    };
    
    A.7.t ||= 'neu';
    
    # $bay passed through
    town: my $to = Rw ElvisYou;
    return sayre "< ElvisYou $p vs $$" unless $p eq $$;
    
    sleep 1;
    
    my $op;
    my $f = "$to/p/Opper";
    sayre "... $f ";
    sleep 1 until -l $f;
    $op = readlink $f;
    saygr "Waiting fr $op $f";
    waitpid($op,0);
    sayyl "Done! $op on $$";
    if (readlink("$f/will") =~ /restart/) {
        sayre "$f wills restart";
        goto town;
    }
    sayre "will restart..?";
    <STDIN>;
    goto town;
NetPut: | # Opper outputs W
    # 
    my $sendz = &z{
        ref $z eq 'ARRAY' || die "Give array to sendz";
        my $in = "Gc&bay/p/WebHost/in";
        -f $in || die "No WebHost?";
        $s = G&Ct,[SomeNetSpot=>[out=>1=>{},{z=>$z}]];
        write_file($in,{append=>1},sjson($s)."\n");
    };
    
    Js&ein.t.out.sMJ = &sMJje{
        my $Y = ec&Y || $A;
        my $z = ec&eat;
        my $h = ec&holst;
        
        1 && saygr "Webbing on G.t into $h, from ".G&sn,$Y ." y ".G&sn,Y.up.up;
        Jc&froe = ec&froe if ec&froe;
        
        Js&initGW ||= do {
            # create a sense of us before what we contain
            my $g = G&Ct,[GW=>1];
            # name to address
            gc&Mid = G.t || die "no G\.t?";
            gc&Wid = "G.c.bay/p/$$";
            # makes ephemeral container:
            gc&el = 2;
            gc&tag = 'ww';
            gs&ab = 100;
            gs&wi = '80%';
            gs&he = '80%';
            gs&ws = 'pre';
            gs&wb = 1;
            gs&poi = 'none';
            gs&ml = '5%';
            # this kind of request should establish all of the above
            $sendz->([$g]);
            $g
        };
        
        # dripfeed time
        my $deal = 0.3 if @$z > 1;
        # convert {C} to [t y c sc]
        # < make Lines (with json data BQ)
        my $elv;$elv = sub {
            my ($C,$d,$la) = @_;

            $C = G&hup,$C;
            my $aC = G&aC;
            C.y = C.y.cv;
            my $space = " ";

            if ($la && $d == 2) {
                if (1 && (C.sc.pi || 
                    $la && (C.y =~ /0\.(\d)/)[0]
                    ne ($la->[1] =~ /0\.(\d)/)[0])) {
                    c&s = "\n".c&s;
                    $space = "*";
                }
            }
            
            1 && sayyl join("  ",('')x$d).$space.(c&el||"-")." ".$aC;

            my $la;
            C.sc.z = [map{my$l=$elv->($_,$d+1,$la);$la=$l;}@{C.sc.z}] if C.sc.z;
            C.sc.deal ||= $deal if $deal;
            [C.t,C.y,C.c,C.sc]
        };
        my $j = G&Ct,['','',{W=>G.t},{z=>$z}];
        my $l = $elv->($j);
        $sendz->([$l]);
    };
    S
SomeNetSpot: |
    saygr "Netspot! on G.t";
    Js&ein.t.out.sMJ = &sMJje{
        for my $l (@{es&z}) {
            my $s = sjson $l;
            1 && saygr "Begins ".slim 9, $s;
            G.Websen->("$s");
        }
        T.pos = 0;
    };
    S
Wudder: | # start W as fork from Udder
    $s = G&Ct,$s if ref $s eq 'ARRAY';
    my $to = ar.to || "Udder";
    my $bay = ar.bay || Gc&bay;
    my $in = "$bay/p/$to/in";
    sayyl "Writing $in For ".ki $s;
    write_file($in,{append=>1},sjson($s)."\n");

