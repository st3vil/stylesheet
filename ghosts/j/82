Wants: | # W-transcending magmatics
    to spur garbage collection on Gs
    to cache lookings upon the click, so instant code foldouts
    to create more t/t/t/t looks
    static same Experience
    
    Gs have a unifier
    
Dogu: | # T room versing, self divising tree science
    Jc&tape = "Dejo";
    Jc&save = 1;
    Rw Tiot;
    Js&ein.bo = 'Doable';
    A.6.t = A.7.t;
    y.res = 100; # reassign m cv
    
    S
    #G&Experience;
    
    n vokate=>-lookins_02=>[qw'bay peace']
    
    m _.t=>-looking=>{s=>$_} for G&op;
    
    Js&lase &&
    m lase=>-od=>{s=>delete Js&lase}
pi/looking: | # a piece of intent
    # s=M fof things to check out
    #    G/
    y.at.dis = 1;
    s&dis = 3;
    y.at.ml = 1;
    c&s = c&s.y.OC if c&s.y.OC;
    
    # clickable features
    n lum=>o1=>'<'=>'dos:looking'
    # the node in the tree
    n t=>1=>" C.t "=>'hs:788'
    # the stuff we know about it
    exists ss&z && delete ss&z;
    n sbrack=>199=>"(",'ab,fs:18,hs:8454,ml:-0.3,lh:0.5'
    n s=>2=>ki(s.sc||{}),'ma:0.2'
    n sbrack=>201=>")",'ab,fs:18,hs:8454,ml:-0.3,lh:0.5'
    
    n gap=>22=>' '
    
    y.n = 4;
    unless (ss&lum > 1) { # describe this as one
        for my $o (@{c&zail||[]}) {
            $o = G&hup,$o;
            delete oc&s if oc&s eq C.t;
            os&dis = 2 if os&dis eq '3'; # table-row -> inline-block
            #saygr "One C.t descriptor: ".ki $o;
            m $o
        }
    }
    else { # open this as many
        n C.t=>-lookat_3
    }
lookinating: | # find relevant objects for -looking
    1 && sayyl "Looking at ".G&sn,$J;
    # last -looking has c&s = self
    # initial dos:looking other has yself = self
    
    # FactorEase e&hC (dos|pi)=looking -1 yC+ (y&self|c&s~C)
    # with the dos|pi ^ alternating if the later ^ selfing doesn't
    
    my ($l) = reverse grep {_s&dos eq 'looking'} e&_hC;
    $l = l.y.C while l.y.C;
    my $s = l.y.self || G&isC,lc&s && lc&s || do {
        # must be a dos=looking inside a pi=looking
        my $ol = $l;
        my ($l) = reverse grep {_s&pi eq 'looking'} e&_hC;
        $l = l.y.C while l.y.C;
        G&isC,lc&s && lc&s ||
            G&give:Suck=>[stillnoself=>'',{s=>[e&_hC ,AND=>$ol,LEADTO=>$l]}];
    };
    # gather the branch of self we're on
    my $z = $s;
    my @l = $z;
    unshift @l, $z while ($z = z.y.up) && !zs&J;
    s.t eq 'Ang' && 0 &&
    G&give:Suck=>[s=>'',{s=>[$s,$z,\@l]}];
    
    # get a change/commit ready at the place
    # < finding the -lookins to send updates, uses A.3
    my $c = Js&change ||= G&Ct,[change=>''];
    my $i; # nerve ending
    for my $l (@l) {
        $i = c.y.tw.>l.t ||= G&Ct,[l.t=>''];
        my $la = c.y.in ||= $i;
        la.y.next = $i if $la ne $i;
        $c = $i;
    }
    
    return (
        $i, # changes to copy into $s
        $s, # last (dos:|-)looking's $s
    );
    
looking: | # click at -looking puts update to source -lookins
    my ($i,$s) = Rw lookinating;
    
    # place changes
    is&lum = (ss&lum||1) + (ec&us.S ? -1 : 1);
    
    my $vsn = G&sn,$J;
    1 && saybl "With a: $vsn", G&ind,Js&change,'aC';
    1 && sayyl "3 to ".G&sn ." Ist: ".G&sn,A.3;
    
    #G&elph,A.3.t=>[verse=>''=>{us=>$us}];
    #T.pos = 0;
    
lotype: | # click/so at -lookat's type
    my ($p,$v,$i,$s) = Rw lookinating;
    
    saybl "Apply s from ".wdump 2, ec&us;
    is&type = ec&us.s || die "No type given";
    
    Js&lase = [
        p=>$p,
        v=>$v,
        i=>$i,
        s=>$s,
    ];
    
    
    
    
    #
pi/lookat: | # from -looking, a multitude of -lookings
    # for one (open) -looking, to the many within
    # see bay, G, W and further, from intent
    
    # the one knows:
    #   lum - attention/openness level
    #   type - of thing it basically is
    #   inter-pretation it wants to appear as
    # and more as elvising grows it
    # type ||= -files and watch for patterns
    
    # the many:
    #   is got by pi = (inter || type)
    #   put its head (<3) here
    #   wrap its Many in -lookings
    
    #   2Ccs&s is our intent/instruction
    
    # wants to do Lize step 1 to ack the wobble
    my $s = 2Cc&s;
    my $type = ss&inter || ss&type || 'files';
    
    my $filename = Rw GetFilename;
    
    
    my @types = qw'files';
    #push @types, 'lizes' if @Cs == 1;
    push @types, '?'; # to talkybox
    
    # < click instant dropdown/typein
    n ty=>1=>"-$type",'fs:6,hs:399,dos:lotype,sel:'.join('-',@types)
    
    n C.t=>1=>{pi=>$type,filename=>$filename},{not=>1}
    my @l = G&op;
    
    my ($head,$many) = ([],[]);
    for my $l (@l) {
        # back through the two o's of osc
        my $r = $l;
        $r = r.y.C while r.y.C;
        # y.a on the original C indicates M via A=L/a
        my $to = r.y.a ? $many : $head;
        # use origin as Styles will be computed in $l
        $r = G&hup,$r;
        push @$to, $r;
    }
    
    push @$head, G&Ct,[nohead=>1=>"<NoHead>"=>'%hs:399,fs:6'] if !@$head;
    
    # dedupe labels
    @$head = grep { !
        (_.t eq 't' && _c&s eq C.t)
    } @$head;
    
    n head=>2=>{}=>{z=>$head}
    
    @$many || return
    n nomany=>3=>"<NoMany>"=>'%hs:399,fs:6'
    
    y.n = 4;
    for my $l (@$many) {
        # should deal {}
        my $ss = s.y.tw.>l.t || G&Ct,[l.t=>{up=>$s}=>{new=>1}];
        m l.t=>-looking=>{s=>$ss,zail=>[$l]}
    }
    
GetFilename: | # for a J with -lookat's t and is=directory's c&s above it
    # FactorEase ^C-lookat C rev { _t } join'/'
    my $Y = A.1;
    my @Y; # whose Ct are filename bits
    my @dir; # leading in
    while ($Y) {
        my $C = Yc&s;
        push @Y, $Y if s&pi eq 'lookat';
        unshift @dir, c&s if s&is eq 'directory';
        $Y = Y.2 || last;
        $Y eq Y.3 && last;
    }
    my @Cs = map {_c&s} reverse @Y;
    my $filename = join("/",@dir,map{_.t}@Cs);
pi/files: | # base type of looking
    y.n = 4;
    n t=>1=>"C.t",'ma:0.2';
    my $f = c&filename || C.t; # < every -files type above
    my $type = &f{
        -d $f && "d" || -l $f && "l" || -f $f && "f" || "?"
    };
    my $ft = $type->($f);
    n filetype=>2=>$ft=>'%hs:889,ma:0.2'
    
    if ($ft eq 'd') {
        my @l = split"\n",''.`ls -1 $f`;
        for my $l (@l) {
            my $ft = $type->("$f/$l");
            # Ss&type suggested from here
            my $m = [];
            m $l=>''=>{s=>$l}=>{type=>"files",z=>$m,dis=>3}
            my $M = $m;
            m type=>1=>$ft=>'%hs:889,fs:7'
        }
    }
    elsif ($ft eq 'f') {
        my $s = (-s $f)." bytes";
        n size=>3=>$s=>'hs:199,fs:6'
    }
    elsif ($ft eq 'l') {
        my $l = readlink $f;
        n link=>3=>$l=>'hs:199,fs:7'
    }
    
pi/lizes: |
    n t=>1=>"C.t",'ma:0.2';
    my $f = c&filename || C.t; # < every -files type above
    -d $f || die "Not a dir: $f";
    
    my @l = split"\n",''.`ls -1 $f`;
    
    for my $l (@l) {
        if (!-d "$f/$l") {
            my $m = [];
            m $l=>''=>{s=>$l}=>{type=>"weird",z=>$m,dis=>3}
            my $M = $m;
            m weird=>1=>"notdir"=>'%hs:889,fs:7'
        }
        else {
            my $m = [];
            m $l=>''=>{s=>$l}=>{type=>"lize",z=>$m,dis=>3}
            my $M = $m;
            # Lize wants to see itself...
            (my $name = "$f/$l") =~ s/\W/-/g;
            my $d = Rw LowCat $bay:f $g=gou $t=Lize/$name/pile;
            my $size;
            my @prob;
            if ($d) {
                my $ub = &C{
                    push @prob, C.t if s&problems;
                    G&aC;
                };
                my @le = G&ind,$d,$ub;
                saybl "With Lize's pile of $name: ", @le;
                $size = @le;
                #n things=>2=>join("\n",@le,''),'hs:947,fs:7';
            }
            m lize=>2=>"x$size"=>'%hs:889,fs:7,dos:lizening'
            if (@prob) {
                my $pro = join(' ', uniq @prob);
                my $wha = @prob;
                m lize_problems=>3=>" !$wha"
            }
        }
    }
    
lizening: | # click towards lize
    my @l = grep {_s&pi eq 'looking'} e&_hC;
    @l == 2 || die "More than two steps for lize: ".ki @l;
    my ($bay,$g) = map { _.t } @l;
    
    Rw Wudder $s:_ for [Lize=>W=>{g=>$g,bay=>$bay}];
    T.pos = 0;

