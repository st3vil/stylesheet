Wants: |
    to spur garbage collection on Gs
    to cache lookings upon the click, so instant code foldouts
    to create more t/t/t/t looks
    static same Experience
    
    Gs have a unifier
    
Dogu: | # T room versing, self divising tree science
    Jc&tape = "Dejo";
    Js&ein.bo = 'Doable';
    y.res = 100; # reassign m cv
    # sees
    Rw AWriter;
    S
    #G&Experience;
    
    n vokate=>-lookins_02=>[qw'bay peace']
    
    m _.t=>-looking=>{s=>$_} for G&op;
    
    Js&lase &&
    m lase=>-od=>{s=>delete Js&lase}
pi/lookins: | # source of intent, remembers stuff about names
    y.res = 100; # reassign m cv
    
    my $d = G&Experience;
    my $c = delete 3s&change;
    
    if ($c) {
        my $ub = &C{ G&aC };
        my @le = G&ind,$c,$ub;
        1 && sayyl "HAve change: ",@le;
    }
    my $pos;$pos = &Ddctp{
        # t path
        $p = [@{$p||[]}];
        push @$p, $t;
        # descent suggested by d or c
        my $tw = {};
        my $d = d.y.tw.>$t;
        if ($d) {
            # what it was
            G&oh,D.sc,d.sc;
            $tw.>$_++ for keys %{d.y.tw||{}};
        }
        my $c = c.y.tw.>$t;
        if ($c) {
            # how its changing
            # < delete somehow
            1 && saygr G&sn ." Posits change to @$p: ".ki $c;
            G&hoh,D.sc,c.sc;
            $tw.>$_++ for keys %{c.y.tw||{}};
        }
        for my $t (sort keys %$tw) {
            my $z = G&Ct,[$t=>''=>{}=>{}];
            $pos->($z,$d,$c,$t,$p);
            push @{Ds&z||=[]}, $z;
        }
    };
    for my $t (@$s) {
        my $D = G&Ct,[$t=>''=>{}=>{}];
        $pos->($D,$d,$c,$t);
        if (Ds&z) {
            my $ub = &C{ G&aC };
            my @le = G&ind,$D,$ub;
            1 && sayyl "HAve depth: ",@le;
        }
        m D.t, '', D.c, D.sc
    }
    # resurp $d scs into ^
    
    
pi/looking: | # a piece of intent
    # s=M fof things to check out
    #    G/
    y.at.dis = 1;
    s&dis = 3;
    y.at.ml = 1;
    # clickable features
    n lum=>o1=>'<'=>'dos:looking'
    # the node in the tree
    n t=>1=>" C.t "=>'hs:788'
    # the stuff we know about it
    exists ss&z && delete ss&z;
    n sbrack=>199=>"(",'ab,fs:18,hs:8454,ml:-0.3,lh:0.5'
    n s=>2=>ki(s.sc||{}),'ma:0.2'
    n sbrack=>201=>")",'ab,fs:18,hs:8454,ml:-0.3,lh:0.5'
    
    
    y.n = 4;
    unless (ss&lum) { # describe this as one
        for my $o (@{c&zail||[]}) {
            $o = G&hup,$o;
            delete oc&s if oc&s eq C.t;
            os&dis = 2 if os&dis eq '3'; # table-row -> inline-block
            #saygr "One C.t descriptor: ".ki $o;
            m $o
        }
    }
    else { # open this as many
        n C.t=>-lookat_3
    }
looking: | # click at -looking puts update to source -lookins
    1 && sayyl "Looking at ".G&sn,$J;
    # FactorEase e&hC -looking -1 cs ^
    # the last -looking's s's origin J we send updates
    # e&hC -looking
    my @l = grep {_s&pi eq 'looking'} e&_hC;
    # -1
    my $l = $l[-1];
    # cs
    my $s = lc&s || die "looking not an s";
    #    may be madeup... need to look up through -lookings
    #    to find a real s from -lookin
    #    change our way out to the new s
    # ^
    $s = s.y.D if s.y.D;
    my $S = $l[0];
    $S = S.y.D if S.y.D;
    my $p = S.y.up;
    my $ps = p.y.s;
    my $v = ps.1;
    # tell this v to change this datum
    my $c = vs&change ||= G&Ct,[change=>''];
    my $i; # nerve ending
    for my $l (@l) {
        $i = c.y.tw.>l.t ||= G&Ct,[l.t=>''];
        my $la = c.y.in ||= $i;
        la.y.next = $i if $la ne $i;
        $c = $i;
    }
    if (delete ic&new) {
        is&lum = 1;
    }
    # place changes
    is&lum = ss&lum + (ec&us.S ? -1 : 1);
    
    my $ub = &C{ G&aC };
    my @le = G&ind,vs&change,$ub;
    my $vsn = G&sn,$v;
    saybl "With a: $v: $vsn", @le;
    
    Js&lase = [
        s=>$s,
        p=>$p, ps=>$ps,
        c=>$c,
        @le,
    ];
    #G&elph,A.3.t=>[verse=>''=>{us=>$us}];
    #T.pos = 0;
    
pi/lookat: | # from -looking, a multitude of -lookings
    # for one (open) -looking, to the many within
    # see bay, G, W and further, from intent
    
    # the one knows:
    #   lum - attention/openness level
    #   type - of thing it basically is
    #   inter-pretation it wants to appear as
    # and more as elvising grows it
    # type ||= -files and watch for patterns
    
    # the many:
    #   is got by pi = (inter || type)
    #   put its head (<3) here
    #   wrap its Many in -lookings
    
    #   2Ccs&s is our intent/instruction
    
    # wants to do Lize step 1 to ack the wobble
    my $s = 2Cc&s;
    my $type = ss&inter || ss&type || 'files';
    
    # FactorEase ^C-lookat C rev { _t } join'/'
    my $Y = A.1;
    my @Y;
    while ($Y) {
        push @Y, $Y if Y.c.s.sc.pi eq 'lookat';
        $Y = Y.2 || last;
        $Y eq Y.3 && last;
    }
    my @Cs = map {_c&s} reverse @Y;
    my $filename = join("/",map{_.t}@Cs);
    
    # < click instant dropdown/typein
    n ty=>1=>"-$type",'fs:6,hs:399'
    n C.t=>1=>{pi=>$type,filename=>$filename},{not=>1}
    my @l = G&op;
    
    if (0) {
    my $ub = &C{ G&aC };
    my @le = G&ind,$l[4],$ub;
    saybl "With a: ", @le;
    #n things=>2=>join("\n",@le,''),'hs:947,fs:7';
    }
    
    my ($head,$many) = ([],[]);
    for my $l (@l) {
        $l = l.y.D if l.y.D; # hup from G&op/ind
        # back through the two o's of osc
        my $r = l.y.r.c.o.y.D.y.r.c.o.c.s;
        # y.a on the original C indicates M via A=L/a
        my $to = r.y.a ? $many : $head;
        # use origin as Styles will be computed in $l
        $r = G&hup,$r;
        if (my $i = l.y.in) {
            # things inside it will not have Styles computed,
            # as s doesn't sequence them... but should
            # also this all wants to be FactorEase
            rs&z = [$i];
            push @{rs&z}, $i while $i = i.y.next;
        }
        push @$to, $r;
    }
    
    push @$head, G&Ct,[nohead=>1=>"<NoHead>"=>'%hs:399,fs:6'] if !@$head;
    
    # dedupe labels
    @$head = grep { !
        (_.t eq 't' && _c&s eq C.t)
    } @$head;
    
    n head=>2=>{}=>{z=>$head}
    
    @$many || return
    n nomany=>3=>"<NoMany>"=>'%hs:399,fs:6'
    
    y.n = 4;
    for my $l (@$many) {
        # should deal {}
        my $s = s.y.tw.>l.t || G&Ct,[l.t=>''=>{new=>1}];
        m l.t=>-looking=>{s=>$s,zail=>[$l]}
    }
    
pi/files: | # base type of looking
    y.n = 4;
    n t=>1=>"C.t",'ma:0.2';
    my $f = c&filename || C.t; # < every -files type above
    my $type = &f{
        -d $f && "d" || -l $f && "l" || -f $f && "f" || "?"
    };
    my $ft = $type->($f);
    n filetype=>2=>$ft=>'%hs:889,ma:0.2'
    
    if ($ft eq 'd') {
        my @l = split"\n",''.`ls -1 $f`;
        for my $l (@l) {
            my $ft = $type->("$f/$l");
            # Ss&type suggested from here
            my $m = [];
            m $l=>''=>{s=>$l}=>{type=>"files",z=>$m,dis=>3}
            my $M = $m;
            m type=>1=>$ft=>'%hs:889,fs:7'
        }
    }
    elsif ($ft eq 'f') {
        my $s = (-s $f)." bytes";
        n size=>3=>$s=>'hs:199,fs:6'
    }
    elsif ($ft eq 'l') {
        my $l = readlink $f;
        n link=>3=>$l=>'hs:199,fs:7'
    }
    

