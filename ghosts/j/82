Wants: |
    to spur garbage collection on Gs
    to cache lookings upon the click, so instant code foldouts
    to create more t/t/t/t looks
    static same Experience
    
    Gs have a unifier
    
Dogu: | # T room versing, self divising tree science
    Jc&tape = "Dejo";
    Js&ein.bo = 'Doable';
    y.res = 100; # reassign m cv
    # sees
    Rw AWriter;
    S
    #G&Experience;
    
    n vokate=>-lookins_02=>[qw'bay peace']
    
    m _.t=>-looking=>{s=>$_} for G&op;
    
    Js&lase &&
    m lase=>-od=>{s=>delete Js&lase}
pi/lookins: | # source of intent, remembers stuff about names
    y.res = 100; # reassign m cv
    
    my $d = G&Experience;
    my $c = delete Js&change;
    for my $s (@$s) {
        my $d = d.y.tw.>$s || G&Ct,[$s=>''=>{}=>{lum=>1}];
        if (my $c = c.y.tw.>$s) {
            # exclude but follow z into d and c
            # delete somehow
            saygr G&sn ." Posits change to $s: ".ki $c;
            G&oh,$d,$c;
        }
        m d.t, '', d.c, d.sc
    }
    # resurp $d scs into ^
    
pi/looking: | # a piece of intent
    # s=M fof things to check out
    #    G/
    y.at.dis = 3;
    n lum=>o1=>'<'=>'dos:looking'
    n t=>1=>" C.t "=>'hs:788'
    n sbrack=>199=>"(",'ab:1,fs:18,hs:8454'
    n s=>2=>ki(s.sc)
    n sbrack=>201=>")",'ab:1,fs:18,hs:8454,ml:0'
    
    y.n = 4;
    m $_ for @{c&zail||[]};
    
    ss&lum > 1 || return;
    n C.t=>-lookat_3;
looking: | # click at -looking puts update to source -lookins
    1 && sayyl "Looking at ".G&sn,$J;
    # FactorEase e&hC -looking -1 cs ^
    # the last -looking's s's origin J we send updates
    # e&hC -looking
    my @l = grep {_s&pi eq 'looking'} e&_hC;
    # -1
    my $l = $l[-1];
    # cs
    my $s = lc&s || die "looking not an s";
    # ^
    $s = s.y.D if s.y.D;
    my $p = s.y.up;
    my $ps = p.y.s;
    my $v = ps.1;
    # tell this v to change this datum
    my $c = vs&change ||= G&Ct,[change=>''];
    my $i = c.y.tw.>l.t ||= G&Ct,[l.t=>''];
    is&lum = ss&lum + (ec&us.S ? -1 : 1);
    
    Js&lase = [
        $s, $i
    ];
    #G&elph,A.3.t=>[verse=>''=>{us=>$us}];
    T.pos = 0;
    
pi/lookat: | # see bay, G, W and further, from intent
    # for one (open) -looking, to the many within
    
    # the one knows:
    #   lum - attention/openness level
    #   type - of thing it basically is
    #   inter-pretation it wants to appear as
    # and more as elvising grows it
    # type ||= -files and watch for patterns
    
    # the many:
    #   is got by pi = (inter || type)
    #   put its head (<3) here
    #   wrap its Many in -lookings
    
    #   2Ccs&s is our intent/instruction
    
    # wants to do Lize step 1 to ack the wobble
    y.at.dis = 3;
    my $s = 2Cc&s;
    my $type = ss&inter || ss&type || 'files';
    
    n ty=>1=>"-$type",'fs:6,hs:399'
    n C.t=>1=>{pi=>$type},{not=>1}
    my @l = G&op;
    
    my $ub = &C{ G&aC };
    my @le = G&ind,$l[4],$ub;
    saybl "With a: ", @le;
    
    #n things=>2=>join("\n",@le,''),'hs:947,fs:7';
    
    my ($head,$many) = ([],[]);
    for my $l (@l) {
        $l = l.y.D if l.y.D; # hup from G&op/ind
        # back through the two o's of osc
        my $r = l.y.r.c.o.y.D.y.r.c.o.c.s;
        # y.a on the original C indicates M via A=L/a
        my $to = r.y.a ? $many : $head;
        # use origin as Styles will be computed in $l
        $r = G&hup,$r;
        if (my $i = l.y.in) {
            # things inside it will not have Styles computed,
            # as s doesn't sequence them... but should
            # also this all wants to be FactorEase
            rs&z = [$i];
            push @{rs&z}, $i while $i = i.y.next;
        }
        saygr "The C.t has l.t: ".ki $r;
        push @$to, $r;
    }
    
    push @$head, G&Ct,[nohead=>1=>"<NoHead>"] if !@$head;
    n head=>2=>{}=>{z=>$head}
    
    y.n = 4;
    for my $l (@$many) {
        m l.t=>-looking=>{s=>{},zail=>[$l]},'ml:1'
    }
    
pi/files: | # base type of looking
    y.n = 4;
    n t=>1=>" C.t ";
    my $f = C.t; # < every -files type above
    my $type = &f{
        -d $f && "d" || -l $f && "l" || -f $f && "f" || "?"
    };
    my $ft = $type->($f);
    n filetype=>2=>$ft=>'%hs:889'
    
    if ($ft eq 'd') {
        my @l = split"\n",''.`ls -1 $f`;
        for my $l (@l) {
            my $ft = $type->("$f/$l");
            # Ss&type suggested from here
            my $m = [];
            m $l=>''=>$l=>{type=>"files",z=>$m,dis=>3}
            my $M = $m;
            m type=>1=>$ft=>'%hs:889,fs:7'
        }
    }
    elsif ($ft eq 'f') {
        my $s = (-s $f)." bytes";
        n size=>3=>$s=>'hs:199,fs:6'
    }
    elsif ($ft eq 'l') {
        my $l = readlink $f;
        n link=>3=>$l=>'hs:199,fs:7'
    }
    

