TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # piling stuff up
    =head
      TD
      to start raying together ghost/wormholes and travel
      so change becomes a crawling shadow,
      hammering facts, twisting heads
      and now was a good time to stop
      
      to be a sort of terminal... fuzzing trees, pushing
      want some key aiming,
        G should freeze time and give then fairly safely to A.4,
          who has moments to respond before A.5 blows it away to try again
        and all those Elvis vector things...
        following requests all the way through
      
      #msgs is getting composted in -rogram
        sequentia shall io make
      Duning and Doming are the same thing...
        shall indented S be subnetted? ya. make em fractions.
        fit whiles together inside each other, so that:
      S 4 feel queue
        S o queue/$w
          $w one by one code
      S 5 desire changes
        # etc
        that should be able to handle doing jobs interrupted
        everything A:oing what might be changing
          the generosity/paranoia of those wake/sleep diff scans
          is very test-honed
        M y cvs 0.300dome00sequ
      
      and geometry! through io/F
        speaking of everything,
        we need a G&something,<<'' Babz,
        whose wayings can reBab locally (on 4)
        the way is fundamentally about how to hold the stuff that code was
        as its use changes as it is born in a magma holder, to drain mystery,
        cell-divide and grow into a known I thing
      
      so run a little way village with io...
        virtualise some dream to do so
      
        
      
      
    
      teach perl/js via Thangers on:
        t.rows.indexOf(t.row)+' . '+t.i+'  '+ki(t.ar,6.23)+'        '+ki(t.next,2)
      watching is a goof, a drunk, a nun and a young programmer
          perl:   say =~ s/^\{|\}$/sg;
        js:     say = say.replace(/^\{|\}$/g,'');
      
      etc.
      
      other stuff:
        
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        Ladada
      ; matters much for no reason
      brackets also
      filigree?
      
      general \ at the end of the line to continue expression...
        strange one
        idea of cs and more to the C in some compression, out of tycsc mode
        would let base64 image data after sc...
      
      Babz:
       - do some stuff in javascript! the messiest and easiest things
       - n... wants loose t that concats $vars, so we can type endlessly
         until:
         since cv is always -jod or \d (or W)
         y can say :W instead of W, one c&thing == C.t could odify like that
           maybe more if the boundary is not text but a bubble
           when everything similarity matches itself
             and stretches tendons of divergence
      
      =cut
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
iooia: | # F > i/o > input/output
    =these will all be G&F, G&o, G&i...
    
    =head1 round until found
    
     other possible types of thisness:
     - G&s for writing notes for itself
       using traces left by i/oing etc nearby
       doing crazy implicit templating
       throwing universal weight around
      also s is where situations are strategised on
    
    =q[
         see if there's functions anywhere
         they are a separate logic to the pointy path
         < mix up as much as you want
         
         have a right to left flow, assigney
           i {funclast} pointy/path {funcfirst} o ...
         usu.
         
         functions map/grep
         < making rows
           do that via T? see via T
         should happen before descent into the d.path
           since values maybe sarked (@name) from what it does
         
         via T:
            like Swim things, they say:
              understand this name, then you look it up
                and figure out how to work it
              Core describes Knowables, like how to:
                input/output such index
                where/what/how it's going
                  where as in something in s should consume it
                  pretend to be a column or iterator
                  or it's rows/columns being added/replaced/removed
              T percolate out like errors/warnings if they are too unknown
                 may have a part to it specifying where,
                    like swim is to-cv
        
        <
          y*/separation is like a function,
          must rerow to represent any rearrangement
          so each thing throws up a new iterator
          link them?
          
    F is a culture of grasping syntax on top of o
    data formulae
    
    ]
    =cut
    $io = {}; # a bunch
    
    # a limb
    io.F = &s,d{ return G&way,'PseudoF',{s:s,d:d,io:io} };
    
    # the base datatype
    # see also G&datam and C
    io.isC = &s{
        return s && typeof s == 'object'
            && s.t != null && s.y && s.c && s.sc
    }
    
    #c parsetalk
    # parse out bits into m
    $parse;
        $m;
        $p = &r,place{
            m = parse.match(r);
            !m and return
            m.shift();
            place and place = place.split('').map(&i{ return m[i] }).join('');
            else { place = '' }
            parse = parse.replace(r,place);
            return 1
        };
    
    $ta = G.tiestowe = [];
    
    # compile time
    # see j/41/jababio
    # the string is basically a branch/path 
    #   params give values to columns, named with /^[$#]/
    #   params return or made available somewhere, per column, per row...
    # saving much typing!
    
    # can't really bab 1 line to many to set params
    # must return N
    #   it's what's expected? (at io (not F?))
    # and put iterator interface on T...
    #   later some way to do cursors,
    #     percolate and collaborate read-need-ness
    
    # but in an S:
    #  S can do io and then be iterating
    #  Babz setting params inside from T
    
    
    # general branch lingo
    # something for C-together
    # < making sql
    # params written as if string interpolated:
    # they create/read object or some reduced idea of an object:
    # the column will/must have/match the given param's value/identity,
    # $o - value
    # #o - looser/vaguer/processed copy of $o
    #      like spacers, with only C.t=o.t
    # word - spacer of C.t=word
    
    # < want o to find the exact object, not it's identity?
    
    # < unless it names a universal (1s&bareword) or so,
    #   then use that. inner lingosanctum.
    io.parsetalk = &talk,params,d{
        d ||= {};
        parse = talk;
        # do i ... for o ...
        p(/ ((i|o) .+)$/) and d.plumb = m[0]
        # plumbed bit gets parsed after its downstream,
        #   but runs before, so know what:
        p(/^(i|o) /) and d.is = m[0]
        # absorb the o lop ^
        talk = parse; 
        
        # Babz shall do params, see 'compile time' ^
        d.path = []; # pa+
        while (p(/^(\S+)\s*/)) {
            # < '{}:m' -> params contains a &acgts{ map/grep/sort }
            #   with implicit return lastline
            #   whose value becomes a column
            $path = m[0].split('/');
            $outer = parse;
            $pa;
            $dpa = &eatparam{
                if (eatparam) { # bind param to path bit
                    !params.length and throw "Not enough params", pa.t, pa, d
                    pa.v = params.shift();
                }
                d.path.push(pa)
            };
            each in path {
                parse = n;
                pa = {};
                
                #c grasp tokens
                # y clones C
                if (p(/^((\w+:)*)y(\S*?)(:\w+)?$/,'03'))
                    pa.separation = m[2] || 1;
                # set var/name column from path bit
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                # which ark specifically (usu all/sarked) to doof
                while (p(/^(\w+):/))
                     (pa.arkfor ||= []).push(m[0])
                # function
                p(/^((\w+:)*)\{(\w+)?\}$/) and pa.doof = m[0]||1; dpa(1); continue
                pa.separation and dpa(); continue
                pa.arkfor and throw "arkfor non-doof"
                # and use each of them
                #   name moves to new position (ark)
                p(/^@/) and pa.sark = 1; pa.ark ||= 1;
                # can be i $i/@#dee/$fings o $o/*:dee
                #   to copy spacers
                
                # get path bit/value of here from a variable:
                # t-only/squish/shaded clone of C, or
                # C itself
                # when o the C will match itself/navigate onwards
                # or i will input that squished C,
                #   and/or ark/return,
                #   and/or climb past it and input more stuff...
                # sheer spacer, made for a C
                #   eg where desired.t == wanted.t
                p(/^(\w+)?#/) and pa.isparam = 1; pa.relative = m[0] || 1;
                pa.sark and delete pa.isparam;
                
                # C itself for path bit got from param
                p(/^\$/) and pa.isparam = 1
                
                pa.t = parse;
                
                # anything, anything deeply, anything something matches
                if (pa.t[0] == '*') {
                    pa.glob = 1;
                    pa.t == '*' and pa.glob = 1
                    else
                    pa.t == '**' and pa.wander = 1
                    else
                    p(/^\*(\w+)$/) and pa.wander = pa.wanderer = m[0] || 1
                    else {
                        throw "wandery looking", pa.t
                    }
                }
                
                pa.ark == '1' and pa.ark = pa.t;
                
                # value of here from a:
                if (pa.isparam) { # variable/bind param
                    !params.length and throw "Not enough params", pa.t, pa, d
                    pa.v = params.shift();
                }
                else
                if (pa.glob) {} # anything
                else
                if (pa.sark) {} # name of a column in d.plumb...
                else { # bareword
                    pa.v = G&Cye,[pa.t,1]
                    # words are the lumber of the algorithm
                    pa.word = pa.spacer = 1;
                }
                # namespaceness of something
                if (pa.relative) {
                    pa.spacer = 1;
                }
                dpa();
            }
            parse = outer;
        }
        parse and throw "Unparsed", parse
        
        # 2
        $fi;
        each i,pa d.path {
            if (pa.separation) {
                $mode = pa.separation;
                mode == '1' and mode = 'C';
                parse = mode;
                # how to clone depth
                p(/\,$/) and pa.yshallow = 1;
                p(/\.$/) and pa.yalone = 1;
                # can yer through time, 'y' implies new.y.C = old
                mode = parse.split(',');
                pa.yto = mode[0];
                pa.yfrom = mode[1];
                pa.doof = 'separation';
            }
            if (pa.doof) {
                $known = pa.doof;
                if (known == '1') {
                    typeof pa.v != 'function' and throw "expecting doof",pa
                    # doof(acgts) each thing, or so
                }
                else {
                    typeof known != 'string' and throw "expecting doofstring",pa
                    !io[known] and throw "dont have doofer io."+known
                    # get thing to peel it already?
                    # then these d can be compiled in
                }
            }
            if (pa.wanderer) {
                $name = pa.wanderer;
                each i,da d.path {
                    !(da.arkfor && da.arkfor.indexOf(name) == 0) and continue
                    da.hijacked = pa;
                    pa.hijacks = da;
                }
                !pa.hijacked && !io[name] and throw "no wanderer "+name
            }
            if (pa.wander) {
                $rest = d.path.slice(i+1);
                $sensible = rest.filter(&s{ return !pa.doof });
                sensible.length and throw "Cannot unwander";
                # < because row must fit path
                #   be nice to find such cul de sacs after however far
                #   that's really what we want in a little while
                #   Arrays only kind of work with fractions, no indexOf it seems
                #     or a many-celled cell could do it...
            }
            !pa.doof && !fi and fi = pa
        }
        
        #c 3 implications create path
        
        # o word   implies   o A.r/word
        if (fi) {
            # first non-doofer
            if (fi.glob || fi.spacer) {
                # seems to have something to look at already
                !A.r and throw "unreal beginning, no Ar"
                # < may refer to a 1s&word?
                #   Babz must collect & maybe deposit them all somewhere
                #     would make good autodoc
                #   and so Domes and other tatters of process can be
                #   undef'd after a point, or to some sense....
                pa = {t:'r',implicit:1,v:A.r};
                d.path.splice(d.path.indexOf(fi),0,pa);
                # should leave out of rows, being implied?
            }
        }
        
        # o $d   implies   o $d/*
        if (d.is == 'o') {
            !fi and throw "no one?"
            if (d.path.length == 1 && fi.isparam)
                d.path.push({t:'*',glob:1})
        }
        
        # i $d o $o   implies   i $d/@s o $o/*:s
        if (d.plumb) {
            # < i $i/@#dee o $o/*:dee   to copy spacers
            if (!d.path.filter(&s{ return s.sark }).length)
                d.path.push({sark:1,t:'s'})
            # or, if d.plumb (iterator) has no ark:s
            #   < use path[-1] (default in d.plumb's h.Pmod's coli)
            #     should be here, where language sorts itself out
            # or if we have arks that don't exists over there:
            #   < find @lamb in $lambs/*
            #   
            # < other: io-ish syntax/tool these such operations ^
        }
        else {
            if (d.is == 'o') {
                # o ... y   implies   o y ...
                $i = 10;
                while (1) {
                    i-- < 1 and throw "many y..."
                    $pa = d.path.slice(-1)[0];
                    !pa.separation and break
                    d.path.push(d.path.pop());
                }
            }
        }
        # < without plumbing, i $d would do nothing?
        
        
        # 6/8 others, use up params
        d.plumb and d.plumb = io.parsetalk(d.plumb,params)
        
        # 7/8 sanity on dials, exact traction
        params.length and throw "Too many params", params
        
        # 8/9
        return d
    };
    
    #c doof: pour iterator through function, making another iterator
    # is a join from the rows already, but pretending its not
    # adds a column for return value
    io.doof = &D,t,pa{
        # supplied for pa.wanderer to pick atoms with
        pa.hijacked and debugger
        # take iterator
        !t.more and t = io.nz(t)
        if (pa.doof == '1') {
            $cb = pa.v;
            typeof cb != 'function' and throw "Not function", pa
        }
        else {
            # eg separation, must return a t (post-nz())
            return io[pa.doof](D,t,pa)
        }
        # copy schema + column for func return
        $d = {};
        d.path = t.path.slice();
        # it may be for what defines it (lastfunc)
        $funci = d.path.indexOf(pa);
        funci < 0 and d.path.unshift(pa);
        # how to operate
        $h = {};
        # iterations vote for/against row and a cell: {
        #   r: func return value
        #   row: in t.rows[t.i]
        #   s: in .row[i/t.d], the one unique object, the cell
        #   i: t.d (depth) or t.path[i], the column
        $inc = [];
        $exc = [];
        $doofings = []; # everything
        if ('grepping or mapping') {
            if ('uni') { # que objects, rhythm >= to rows
                t.partial = 1;
                t.ind(&s,t{
                    # C the item, s the iterator, to them
                    !io.isC(s) and throw "doof-grep-ind got !C s",s,t.row;
                    $si = t.row.indexOf(s);
                    si < 0 and throw "s not in trow?",s,t.row
                    $sa = t.path[si];
                    if (pa.arkfor) {
                        # only those for this y
                        pa.arkfor.indexOf(sa.ark || sa.t) < 0 and return
                    }
                    
                    $r = cb(A,s,G,T,t);
                    
                    $doofing = {
                        r: r,
                        row: t.row,
                        s: s,
                        i: t.d,
                    };
                    doofings.push(doofing);
                    (r ? inc : exc).push(doofing)
                });
            }
            else {
                throw "wants rows or the/other arks";
                # changing path/arks means another iterator?
                # or we just change em, t = nz(t)
            }
        }
        else {
            throw "mapping, doing, regrouping, signal gen, who knows"
        }
        # inc-ings vs exc-ings
        # to dedupe itering objects on the same row,
        # < pick the row that describes more matches at once?
        #     to avoid talking about stuff that didn't match?
        # < nonfirst objects on a row lose their return value,
        #     since we only have one doof column for it
        #     shapeliness problem
        #   assume they will use d.objects and d.returns
        #   
        #   < rowing itself should use input/output
        #     so any shapeliness problem can escalate and solve itself:
        #     nonfirst objects return values:
        #       could have column types,
        #       make the doof an array referring to other columns?
        #      so it can get really complicated,
        #      methods for schema/data
        #      ways of partitioning problems and stats near
        # anyone says yes
        # < we could tally results a bit
        #   before deciding how we are operating
        #     if they all seem boolean
        # < maybe they should pick the best one along the row?
        #   ie if we're looking for music, the live streams deep
        #     within the music collection should win
        # < the comp for attention
        d.objects = [];
        d.rows = [];
        d.returns = [];
        $la;
        each i,r inc {
            d.returns.push(r.r);
            d.objects.push(r.s);
            r.row == la and continue
            !r.r and continue
            la = r.row;
            $row = la.slice();
            funci < 0 and row.unshift(r.r)
            else {
                row[funci] = r.r
            }
            d.rows.push(row);
        }
        return io.nz(d)
    };
    
    #c separation - cloning process
    # pa is from a D.path consuming this t
    # happens as a firstfunc
    io.separation = &D,t,ya{
        # another iterator
        $d = {};
        d.plumb = t;
        d.separation = 1;
        # which should have clones
        # we could know how separatey things want to be,
        # see "universals can want attention"
        # see also "no find ark/column" for when they ...
        if (!ya.arkfor) {
            # defaults to stuff @heading Downstream
            ya.arkfor = [];
            each i,Pa D.path {
                Pa.sark and ya.arkfor[i] = Pa.t
            }
        }
        
        #A.debug and debugger;
        if (!t) {
            # funcfirst y, D.plumb would be t
            D.plumb and throw "funcfirst y !t D.plumb"
            if (D.is == 'o') {
                # is alias for funclast y, in parsetalk
                throw "o funcfirst y"
            }
            else {
                $first = 1;
                each i,Pa D.path {
                    Pa.doof and continue
                    first and first = 0; continue
                    !io.isC(pa.v) and continue
                    pa.v = io.separate(pa.v,Pa,Pa,ya)
                }
            }
            # remain !D.plumb
            return null
        }
        
        d.path = t.path.slice();
        d.rows = t.rows.slice();
        each i,row d.rows {
            row = d.rows[i] = row.slice();
            each is row {
                $pa = t.path[i];
                $Pa = d.path[i];
                #A.debug and debugger;
                if (ya.arkfor) {
                    # only those - arkfor keyed by sark in D path, not t/d path
                    ya.arkfor.indexOf(pa.ark || pa.t) < 0 and continue
                }
                # < separate other things,
                #   even indexes themselves,
                #     with a reroot-changed-hashes scheme like git
                !io.isC(s) and continue
                row[i] = io.separate(s,Pa,pa,ya);
                (ya.separated ||= []).push(s)
            }
        }
        
        #A.debug and debugger;
        return io.nz(d)
    };
    # could get complicated soon...
    # universals can want attention here
    io.separate = &s,Pa,pa,ya{
        # Pa - io going to's path bit
        # pa - io coming from's path bit
        # ya - the .separation path bit
        ya ||= {};
        ya.olds ||= [];
        ya.neus ||= [];
        $old = s;
        $neu; # may already be:
        $oi = ya.olds.indexOf(old);
        oi < 0 and oi = ya.olds.push(old)-1;
        else {
            $neu = ya.neus[oi];
            !neu and throw "olds/neus confuse"
            return neu
        }
        
        $neu = G&Cye,old;
        ya.neus.push(neu)-1 != oi and throw "olds/neus differ"
        
        # < what to do with its innards
        if (ya.yshallow) { # y,
            # only the top clones, keeps all innards
            #   whether path includes their depths or not
        }
        else
        if (ya.yalone) { # y.
            # disconnect innards
            # < elabourate input()
        }
        else { # y
            # clone everything
            # < T to wander more endlessly
            # path of 10 
            # t.partial
        }
        
        ya.yto and neu.y[ya.yto] = old
        ya.yfrom and old.y[ya.yfrom] = neu
        
        return neu
    };
    #c rowing: travel d.path for i/o hooks
    # < able to async, when A:o things
    io.rowing = &talk,params,d,h{
        # reduce or sprout iterator
        # rows multiply as deeper atoms many
        # - [r,1,1a]
        # - [r,1,1b]
        # - [r.2,null]
        # - [r,3,3a]
        # < or a mirror C set, like G&ind/G&o does
        # < find us for ind-like N, p.nz goes:
        #   [r,[1,[1a,1b],2,3,[3a]]]
        
        # being plumbed somewhere
        if (typeof talk == 'object') {
            # d already, if compiling enough (sjson(io.parsetalk()))
            # or we are plumbed in to something that parsed our talk
            params && params.length and throw "talkref + params";
            d and throw "talkref + d";
            d = talk
        }
        else {
            d ||= {};
            h.is && !d.is and d.is = h.is
            io.parsetalk(talk,params,d);
        }
        !d.path and throw "no path"
        # < bind params now so parsetalk can be compiletime,
        #     call io.i(sjson(parsetalk(talk
        
        #c plumb from somewhere
        if (d.plumb && !d.plumb.more) {
            $b = d.plumb;
            !b.is and throw "no plumb.is, i/o?"
            b.is != 'o' and throw "plumb not o"
            d.is != 'i' and throw "plumb to not i"
            # make the call
            io[b.is](b);
            # have the iterator
            d.plumb = io.nz();
        }
        # find any firstfuncs
        # d.plumb replaces itself
        # these remain in path,
        # so we can ark their return
        $i = d.path.length-1;
        while (d.path[i]) {
            $pa = d.path[i];
            # < support for mid-path doofing
            #   could decide what to put after finding options for where
            !pa.doof and break
            !d.plumb && !pa.separation and throw "firstfunc !y no plumb",pa
            # new iterator replaces old, so we can pipeline?
            d.plumb = io.doof(d,d.plumb,pa);
            i--;
        }
        # plumb rowmuddler
        if (d.plumb) {
            $t = d.plumb;
            # pa.sark and pa.v = their rows's ark
            # their (o's) rows are stitched in to ours
            #  < sarkumulative grouping... instruct a vals=[],valis=[]
            
            # P = [p], p.row = our row
            # p.pa be diverged from the one in d.path itself,
            #   so to split their pa.v (value entering/space identity)
            h.Pmod = &d,p,P{
                !P[0].row and throw "must be iterating the p.rows"
                P.length > 1 and throw "already multiplying row?"
                # if next bit of path is sarky
                $pa = d.path[p.i+1];
                !pa.sark and return P
                # ^ is the P[0].pa also
                # last sark thing has more rows
                $la;
                $pS = p;
                while (pS && !la) {
                    pS.pa && pS.sark and la = pS
                    else
                    pS.sark and throw "sark above not pa", pS
                    pS = pS.up
                }
                $R = [];
                each ib P {
                    # inject multiplicity into directions taken on the path
                    $rows;
                    if (la) {
                        !la.pa and throw "last sarking p without pa",la
                        !b.row[la.i] and throw "our row misses the last sark", b.row, la.i
                        !la.pa.rows and throw "last pa.sark didn't set pa.rows", la
                        # just their rows this row at that point dove into
                        rows = la.pa.rows
                    }
                    else {
                        # all they say
                        rows = t.rows;
                        # complete rows
                        if (!d.partial)
                            rows = rows.filter(&row{ return row.slice(-1)[0] })
                    }
                    
                    # locate sark as ark of theirs
                    # column number, for in d.path/p.row (G/W)
                    # < try making this t.arky
                    $coli = t.arks.indexOf(pa.t);
                    coli < 0 && pa.t == 's' and coli = t.path.length-1
                    # < if it's 'lamb' and they have 'lambs/*',
                    #   suppose s is a lamb
                    coli < 0 and throw "no find ark/column for",pa.t,t.arks
                    
                    #A.debug && p.i > 1 and debugger
                    # uniq the arked column's values
                    # group rows, put b.pa.rows for next regroup inward
                    $vals = [];
                    $valis = {};
                    each ir rows {
                        $v = r[coli];
                        $vi = vals.indexOf(v);
                        if (vi == -1) {
                            vi = vals.push(v)-1;
                            valis[vi] = [];
                        }
                        valis[vi].push(r);
                    }
                    b.plumbiplied = vals.length;
                    
                    # multiply b by possible vals
                    $B = b;
                    each iv vals {
                        b = ex({},B);
                        b.pa ||= d.path[b.i];
                        b.pa = ex({},B.pa);
                        # b.row needn't clone?
                        
                        b.pa.v = v;
                        $rows = 
                        b.pa.rows = valis[i];
                        !v and debugger;
                        #throw "nullish v! for rows",b.pa.rows
                        #~>78 plumba: ki(b.row), ki(v,3)
                        R.push(b)
                    }
                }
                p.plumbiplies = R.length;
                
                return R
            };
        }
        
        #c beginning
        h.first ||= &{};
        h.found ||= &{};
        $first = 1;
        $col = &q,p{
            p ||= {};
            p.i ||= q ? q.i+1 : 0;
            $pa = p.pa || d.path[p.i];
            !pa and throw "No pattern!: "+p.i
            
            if (pa.relative) {
                # relative spacers use the t+cv (space) of something
                # < are likely to not replace?
                pa.vorig = pa.v;
                !io.isC(pa.v) and throw "not C relative pav",pa,pa.v
                pa.v = G&Cye,[pa.v.t,1];
            }
            
            if (pa.doof) { # not a real step
                # lastfuncs at beginning of path
                #  - happen just before this io returns
                # firstfuncs at end of path
                #  - happen before we started, are now d.plumb
                # transparent?
                p.found = ['adoof'];
            }
            else
            if (first) {
                first = 0;
                !pa.v and debugger; #throw "nofirst"
                
                h.first(d,p,pa);
                p.found ||= [pa.v];
            }
            else {
                p.up = q;
                
                if (!q.found.length) {
                    # dont bother looking anywhere?
                    p.found = [];
                }
                else {
                    # onward
                    !p.row and throw "Nowhere"
                    $s = p.row.slice(-1)[0]; # or p.i?
                    !s and debugger; throw "doing empty"
                    
                    # what should be:
                    $v = pa.v;

                    # to the bits
                    $D = {asa:'tv'};
                    # to diversify...
                    pa.spacer and D.spacer = 1;
                    pa.glob and D.meta = ['*','*']
                    else
                    pa.sark and // should have been figured by now?
                    # cos we want to input each thing via pa.v...
                    else
                    !v and debugger; #throw "null pav?"
                    
                    # make more rows
                    h.found(d,p,pa,s,D,v);
                }
            }
            
            #c middle - multiply row into here
            # adds column + may multiply rows
            
            if (!p.row) {
                # starts - rows = [[r]]
                !p.found and throw "no row or found"
                p.rows = p.found.map(&s{ return [s] });
                p.nz = p.found.slice();
            }
            else
            if (!p.found.length) {
                # empty - full of null
                p.row.push(null);
                p.rows = [p.row];
                # p.nz shapely enough to nothing when nothing
            }
            else {
                # new column of many - 
                # keep wandering/grep possible (p.found) directions
                if (pa.wander) {
                    # grep possible directions
                    if (pa.wanderer) {
                        $name = pa.wanderer;
                        name == '1' and name = null
                        $da = pa.hijacks;
                        $cb;
                        if (da) {
                            !da.hijacked and throw "hijacks not hijacked",pa,da
                            cb = da.v;
                        }
                        else
                        name && io[name] and cb = io[name];
                        else {
                            throw "what wanderer?",pa
                        }
                        typeof cb != 'function' and throw "wanderer cb not function",pa,da
                        
                        # < might it want them all/a bunch? width first eventually
                        # < B cursors, so we can find everything...
                        #   chrome debugger itself does alright finding things
                        
                        p.found = p.found.filter(&s{
                            $r = cb(A,s,G,T,d);
                            r and return 1
                            # to show the limit of the search
                            # the edge of the d of light
                            (p.uninteresting ||= []).push(s);
                            return 1
                            # or not show it:
                            return 0
                        });
                    }
                    
                    if (p.found.length) {
                        # stretch path
                        $na = d.path[p.i+1];
                        if (!na || !na.wander) {
                            na = ex({},pa);
                            na.wandering = pa.wandering || pa;
                            d.path.splice(p.i+1,0,na);
                        }
                    }
                    else {
                        p.found.push(null)
                    }
                }
                # loop: finish rows whose [-1] is already row dont travel onward rows whose [-1] are also further back
                # such is loopy
                
                # duplicate this row out
                p.rows = p.found.map(&s,i{
                    ro = p.row.slice();
                    ro.push(s);
                    return ro
                });
                # q.nz absorbs inners after loop
                p.nz = p.found.slice();
            }
            # rows grow to the right
            # < go width first? ps&z
            !d.path[p.i+1] and return p
            
            #c end - an expanding map
            $rows = [];
            each i,row p.rows {
                # our next bit of path
                $b = {};
                b.i ||= p.i+1;
                b.row = row;
                b.pa = d.path[b.i];
                
                # can go down a path in multiple directions
                $P = [b];
                h.Pmod and P = h.Pmod(d,p,P)
                
                each ib P {
                    # protection from going in circles (esp if pa.wander)
                    $s = b.row.slice(-1)[0];
                    $si = b.row.indexOf(s);
                    if (typeof s == 'object' && si >= 0 && b.row.length-1 > si) {
                        # < only if the path .wanders before now?
                        # thing stated in row only twice
                        # kind of thing you'd T when it starts happening
                        d.loops ||= [];
                        d.loops.indexOf(s) < 0 and d.loops.push(s)
                        b.row.push(null);
                        rows.push(b.row);
                        continue
                    }
                    if (p.uninteresting // to pa.wanderer
                        && p.uninteresting.indexOf(s) >= 0) {
                        # after stating them once?
                        debugger;
                        rows.push(b.row);
                        continue
                    }
                    # go
                    $b = col(p,b);
                    (p.pond ||= []).push(b);

                    if (b.nz) {
                        # ...s... -> ...s, [s's many]...
                        $s = b.row.slice(-1)[0];
                        $i = p.nz.indexOf(s);
                        i < 0 and throw "manying row[-1] not in p.nz", s, p.nz
                        p.nz.splice(i+1,0,b.nz);
                    }

                    $r = b.rows;
                    !r and throw "rowing nothing"
                    # keeps pushing null once lost
                    !r.length and throw "not one row"
                    r.map(&ro{ rows.push(ro) })
                }
            }
            p.rows = rows;
            
            return p
        };
        $p = d.p = col();
        d.rows = p.rows;
        T.o = d;
        
        # find any lastfuncs
        $i = 0;
        $lastfuncs = [];
        while (d.path[i]) {
            $pa = d.path[i];
            # < support for mid-path doofing
            #   could decide what to put after finding options for where
            !pa.doof and break
            lastfuncs.push(pa)
            i++;
        }
        if (lastfuncs.length) {
            lastfuncs.reverse();
            each i,pa lastfuncs {
                # new iterator replaces old
                T.o = io.doof(d,T.o,pa)
            }
        }
        
        # ay separation?
        # ays&$arky = [grep{s} whole column]
        $ay = T.o;
        ay.talk = talk;
        io.realise(ay);
        ay.sc ||= {};
        # so [] in sc implies it's all stuff you should know
        # and usually the howness it is is sleeping (z)
        each ik ay.arky {
            ay.sc[k] and throw "have something ay.sc."+k, d
        }
        each i,row ay.rows {
            each ik ay.arky {
                !row[i] and continue
                $N = ay.sc[k] ||= [];
                N.slice(-1)[0] == row[i] and continue
                N.push(row[i])
            }
        }
        
        #   < and eat arrays as params as many somethings it could match?
        #     in a way that generates lots of permutations!
        #   so d would be an A:o, c.stroke: scarkyN
        #   a way to present foamy marks
        # < higher order stylehouse
        return ay
    };
    
    #c nz
    # converts p.rows to iteration or whatever
    # but first, name columns:
    io.realise = &t{
        # name columns [i: name]
        t.arks = [];
        each i,pa t.path {
            pa.ark and t.arks[i] = pa.ark;
        }
        
        t.arky = t.arks.slice();
        # add anything else we can name but wasn't asked for
        t.nonarks = {}; # tarky not in tarks
        $globs = 0;
        each i,pa t.path {
            !pa.t and continue
            t.arky[pa.t] || pa.ark and continue
            pa.glob and globs = i; # will never be 0, as i * implies i A.r/*
            pa.t.match(/\W/) and continue
            t.arky.indexOf(pa.t) >= 0 and continue
            t.arky[i] = pa.t;
            t.nonarks[i] = pa.t;
        }
        
        # Babz S io must know this
        if (globs) {
            # may have a wasn't-asked-for name and s
            $pa = t.path[globs];
            if (!pa.ark && t.arky.indexOf('s') < 0) {
                t.arky[globs] =
                t.nonarks[globs] = 's';
            }
        }
        if (!Object.keys(t.arky).length) {
            $i = t.path.length;
            while (t.path[--i]) {
                $pa = t.path[i];
                pa.doof and continue;
                break
            }
            # even an io of one doof must have some path from data chewed on
            !t.path[i] and throw "ran out of path looking for reals"
            t.arky[i] =
            t.nonarks[i] = 's';
        }
        # edge case: implicit thing should cede 'r' to ark
        #   else it is counted early
    };
    io.nz = &d{
        d ||= T.o;
        !d and throw "Can't find T.o"
        # takes over from o
        $t = ex({},d);
        
        # gets names
        !t.arky && io.realise(t);
        
        # iterate per row
        t.i = null;
        $pull = &{
            $row;
            while (1) {
                # t.i -> i starts null -> 0, then 0 -> 1, 1 -> 2
                $i = t.i == null ? 0 : t.i+1;
                row = t.rows[i];
                !row and return
                t.i = i;
                # only for complete rows
                !t.partial && row.slice(-1)[0] == null and continue
                break
            }
            return row
        };
        # grouping ar[k]=[v+] for implied names
        # < some way to exclude an ark from the 
        $parkar = &be{
            $ar = t.next; delete t.next;
            if (ar) {
                t.i = t.next_i; delete t.next_i;
                t.row = t.next_row; delete t.next_row;
            }
            else {
                t.row = pull();
                !t.row and return
                ar = {};
                each ik t.arky {
                    ar[k] = t.row[i];
                }
            }
            $ti = t.i;
            $trow = t.row;
            if (!t.ungrouped && !be) {
                # to group by, make sure enough of it changes
                # i #Con:/@#G:/@W o $mag/*:G/*:W
                # should iter for every Con and G
                #  with W=[W+] read ahead
                $first = 1;
                while (1) {
                    # get next one...
                    $be = parkar(1);
                    !be and break
                    $diff = 0;
                    each ik t.arks {
                        # if arked things change
                        be[k] != ar[k] and diff = 1
                    }
                    if (diff) {
                        t.next_i = t.i;
                        t.next_row = t.row;
                        t.next_row = be;
                        break
                    }
                    each ik t.nonarks {
                        # or accumulate nonarked things
                        first and ar[k] = [ar[k]]
                        ar[k].push(be[k]);
                    }
                    first = 0
                }
            }
            t.i = ti;
            t.row = trow;
            return ar
        };
        #
        t.more = &{
            $ar = parkar();
            !ar and return
            # hash of values
            t.ar and t.prev = t.ar
            t.ar = ar;
            #t.oned and return ar[t.oned]
            t.sc = t.ar;
            return t;
        };
        #c ind: callback per item, flat list with depth...
        t.ind = &cb{
            t.indstr ||= '  ';
            $la = [];
            $N = [];
            each i,row t.rows {
                t.row = row;
                # only for parents with children
                !t.partial && t.row.slice(-1)[0] == null and continue
                $unreal_depth = 0;
                each dv row {
                    v == null and continue
                    $pa = t.path[d];
                    pa.doof and unreal_depth++; continue
                    # same as last row, still at depth
                    la[d] == v and continue
                    # < t.d should probably be as row/path i...
                    t.d = d;
                    $s = cb(v,t);
                    s == null and continue;
                    if (typeof s == 'string') {
                        $ind = '';
                        each id,v row {
                            id == d-unreal_depth and break
                            ind += t.indstr
                        }
                        s = ind+s
                    }
                    N.push(s);
                }
                la = row;
            }
            return N
        }
        
        return t;
    };
    
    
    #c forS  
    io.forS = &talk,params{
        $ng = io.forSing ||= {};
        ng.talk && talk != ng.talk and delete ng.t;
        ng.talk = talk;
        if (!ng.t) {
            $d = io.parsetalk(talk,params);
            !d.is and throw "No d.is"
            d = io[d.is](d);
            ng.t = io.nz(d);
        }
        return ng.t.more()
    };
    #c io
    # modes of rowing awareness
    
    # i: somewhere someway somestuff
    # the dot of the i is somestuff, index the space, trunk way etc.
    # shall we use a talky Babz'd params-implied-by-$ thing? yes
    io.i = &talk,params,d{
        # talk: 
        #   'universal keyworded-by $thing'
        # the only universal available is A.r,
        #   if your first thing is a spacer
        # the only keyworded-by is /,
        #   means inside, by tv or so
        # find these things... barewords we have around?
        # usually a J universal like N,M,1,9, etc.
        # and somethinging to it:
        # talk='N $by', param=[$by]
        #   N means 3's A:n's r's cM, # caveful of atoms
        #      or M 1's A:n's r's cM  # just the people around you
        # < should kinda m:N $by,
        #   but with the o kind of universal awareness, not A:n
        # but simply as possible:
        # - make sure this is so!
        # as opposed to o:
        # o how is this?
        
        # < wandery globs, must grow rows, path?
        #     see separation + invent the talk for
        # < sometimes (to doof many times in one row)
        #   need a cell that corresponds to many other cells,
        #   but not much
        
        return io.rowing(talk,params,d,{
            found: &d,p,pa,s,D,v{
                # what should be
                # space to it gets filled in with hash
                # and when should existing objects be replaced,
                #   but indexes etc copied to the new one?
                #   upstream changes joining local modulation
                #   seems like s's buzz.
                
                # < input null to delete?
                p.found = [io.input(s,D,v)]
            },
            is: 'i',
        })
    };
    
    
    # o sketches use for A:o:
    # o gets you what you wanted from an intelligised pile
    #   midsection of o is the midsection of n
    #  S titles can use this to define iterators
    # operation of returning results from traversal,
    #   or advancing the A:o of the C, as in dome calmness check
    
    # o may ventually look like n,
    #   and n may eventually have blockquotes hanging on after it,
    #   even T things, grabbing whatever on/over/into Aing thereinout
    
    # hmmm. music collection will be lived by o,
    # QMS would be in a quarantine
    

    # there must be more
    # the o d will be... more infinite
    #   particularly grep/sort/map
    #  tal being apply
    # lingo shape glue session
    io.o = &talk,params,d{
        return io.rowing(talk,params,d,{
            found: &d,p,pa,s,D,v{
                # 6, only the last column
                p.found = io.output(s,D,v);
            },
            is: 'o',
        })
    };
    #c input see,
    # fills in an index with a value
    # total definition of z/tv indexes, which should be one of a few...
    # along with the z/tv positioning system, there's an element of
    #   wiring or linked lists via y&in, y&up, y&next, y&prev,
    #   left out for code volume
    # < index/join types should be curated nearby
    #   proto hard-coded...
    # tv:
    #    lots of C via tvs can hold anything, just stretched out.
    #      maybe if you're database you want to know things.
    #    < in exact mode should keep z sorted,  overwrite tv
    #    < in soft mode should not overwrite (el=1)
    #      throwing input from various sources into various light
    #      to model contended content
    #    
    # non-tv index/join types:
    #    I: could be known to be of/ov/t/cv?
    #    x/y/z: what's in space...
    #    beliefs in cv like subnets, having octaves of octaves,
    #      non-linear spaces, klein bottle public netspace
    #      lanes of stripes whipping around a torus, etc.
    #    of a drawing made
    #    of an id dealt by indexOf(s)
    # 
    # s = data
    # d = [pa,th], puts at that path
    # d = {path:[pa,th],dup:&s{}}
    # does a single weld, usually C-C
    # carbon joint, some language in each place?
    # ignores the next/last/in/up wiring, let o do once sorted
    #   when it gives a kind of gravity,
    #   linearity to the stage that may not ever be there
    io.input = &s,d,v{
        d = io.knowing(d,v);
        # return d here to extract what we know, kind of 2
        
        # now 3 deals with what really shall be and how we shall create it
        
        # climb container different? may A?
        # section of o, defined into several places... houses
        # this is the most high speed bit, copying bunches of C,
        # with a little lingeme sensitivity loaded in on the d,
        # which is a lunk for A, C, T rivering the reverberate of revision
        
        # climb index
        # d.ours ['nk','gk'], gets to the thing at the end of this thing
        # +
        # d.path ['Winning','0.1'] points of index, to the value
        # not the same d.path (or d) of i/o, is a lower level, manyer
        $path = (d.our||[]).slice();
        d.path and d.path.map(&p{ path.push(p) });
        
        $S = s;
        each ip path {
            i *= 1;
            $x = S[p];
            x && typeof x != 'object' and throw "index broken"
            # the last bit of our space: the universal
            #   could be something trascendant
            #   like being a thing with hooks, more our until path...
            d.our && i == d.our.length-1 and d.on_our = x
            # done, leave S on second to last thing
            i+1 == path.length and continue
            # hash usual
            x == null and x = S[p] = {}
            S = x;
        }
        
        # S[p] may now = x
        # S[p] soon will = v
        if (d.t == 'z') {
            # or include it
            x == null and x = S[p] = d.zefault || [];
            x.constructor != Array and throw "z broken"
            #$xi = x.indexOf(v);
            # exact object ^, also could be claiming a tv had already (up at tv)
            # we shall start simply adding on, mentioning things more than once, etc
            # no information lost!
            # except the time of day, which is easy to find
            # dups constitute weirdness that should be cleaned up...
            #   before the system with it in goes production
            # < z_dup: handled on the o end, as z things not in tv, and tv_dup
            x.push(v);
        }
        else {
            # set thing to thing
            if (x != null) {
                # already, noop?
                d.spacer || x == v and return x
                d.dup && d.dup(d,x,v) and return x
            }
            S[p] = v;
        }
        
        # multiple angles of have
        if (d.also) {
            each in d.also {
                typeof n == 'string' and io.input(s,n,v)
                else {
                    throw "What else", n
                }
            }
        }
        return v
    };
    
    #c output
    io.output = &s,d,v{
        d = io.knowing(d,v);
        # path =
        #   our  - reaches from thing to its universal (nk,gk)
        # + path - into index (t,cv)
        # not the same d.path (or d) of i/o
        #   is a lower level, manyer
        # meta applies to non-our path only.
        $path = (d.our || []).slice();
        $mi = path.length;
        d.path and d.path.map(&p{ path.push(p) });
        
        # we only need to capture the endmost atoms at this low level
        # < rows is S in input... could insert multiple times if crazy
        d.rows = [[s]]; 
        # flow
        $i = 0;
        while (path[i]) {
            $k = path[i];
            $pm = i >= mi && d.meta && d.meta[i-mi];
            $rows = [];
            each ri,row d.rows {
                $S = row.slice(-1)[0];
                if (0 && i == mi && S == null && s.sc && ss&z) {
                    d.our.join('') != 'ytv' and throw "have ss&z, null our thing, but what is dour?", d.our.join('')
                    # we got to y.tv, but it seems to use z instead
                    # A:o used to mix all attachment methods together...
                    # suppose this is fine:
                    $tv = s.y.tv = {};
                    each in ss&z {
                        tv[n.t] ||= {};
                        tv[n.t][n.y.cv] = n;
                    }
                    S = tv;
                }
                if (S == null) {
                    row.push(null);
                    rows.push(row);
                    i++;
                    continue
                }
                $ks;
                if (pm) { # loose match, may many
                    # use z order? grep by tv?
                    # in the order they were set
                    pm == '*' and ks = Object.keys(S)
                    else {
                        # for WHERE k=v to be k>5, k~re
                        throw "meta",pm
                    }
                }
                else { # exactly what path[i] says
                    # but when to cast it first? never I spose.
                    $ok = typeof k == 'string'
                        || typeof k == 'number';
                    !ok and debugger
                    !ok and throw "nonstringstep"
                    ks = [k];
                }
                # < to sort, know fractional cv,
                #   with freaks, histograms, history
                # < if !x we could try as if 1=='',
                #   misspellings, round until found,
                #   using z a sorted z to scope up a cv faster...
                #   even resurrecting a J that looks similar
                each ik,k ks {
                    $x = S[k];
                    # extend row
                    $ro = row.slice();
                    ro.push(x);
                    rows.push(ro);
                }
            }
            d.rows = rows;
            # and add column:
            i++;
        }
        # take off columns not in the formula (A.r)
        
        $last_column = d.rows
            .map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });
        return last_column
    };
    #c knowables
    io.knowing = &d,v{
        # glob tv wants to make some path
        v ||= {t:'*',y:{cv:'*'}};
        # a subtype, reenters at the end:
        d.asa and $other = d; d = other.asa;
        # types
        !io.isC(v) && !(v && v.t == '*') and debugger;
        d == 'tv' and d = {t:d,our:['y','tv'],path:[v.t,v.y.cv],usu:1};
        d == 'tw' and d = {t:d,our:['y','tw'],path:[v.t],usu:1}
        d == 'z' and d = {t:d,our:['sc','z']}
        # sheer bunch of keys
        d.constructor == Array and d = {path:d,usu:1}
        
        typeof d == 'string' and throw "intelligise", d, other
        
        other and ex(d,other);
        
        # apply the usual behaviour:
        #  - when duplicate, overwrite
        #    if tv, overwritings become linked lists
        if (d.usu) {
            if (d.t == 'tv') {
                # when not debugging:
                #d.also ||= ['tw','z']
            }
            d.dup = io.usu_dup;
        }
        return d
    };
    # this should be available as around or after method call..
    # or "the usual" that the actual d.dup works with or without
    io.usu_dup = &d,x,v{
                # can link duped things, new thing gets v.y.$to
                # as in, newthing.y.earlier = oldthing
                $from;
                $to;
                # make similar index to z to hold dupes, in order
                # as s&z grep !in tv might reveal
                $dupz;
                
                # revision of an item
                d.t == 'tv' and from = 'later'; to = 'earlier'; dupz = 1;
                # revision of name, moving through items
                d.t == 'tw' and from = 'begins'; to = 'continues'; dupz = 1;
                # < first relative thing keeps its position in tw
                # < check new/old position in z, to inform who takes tw
                #   hmmm, a flappy edge to the arrangement
                # stuff moves through words
                # these schema should be drawn out
                # become keywords to io
                # io will just work
                
                if (from || to) {
                    # which way is it going: new val stays, new val joins the queue
                    $backwards = from && x.y[from] || d.keep_first; #]
                    if (backwards) {
                        !from and throw "can't go backwards with no from?"
                        # ^ unless use in telling things that missed the spot who beat them
                        !d.keep_first and throw "protocol changed"
                        # we could -1 y&dup_tv index maybe?
                        # or add y&most_$from to the end of the linked list
                        # this should magnify into a huge democratic space for ...
                        # space for 'space for ...'
                        # or follow links:
                        $X = x;
                        # < all while loops should have some limit, spec learned
                        #   badge earned. all code is is bestowment.
                        $i = 100;
                        while (X.y[from]) {
                            i-- < 4 and throw "ixhaust"
                            X = X.y[from];
                        }
                        # now last in the trail:
                        X.y[from] = v;
                        to and v.y[to] = X;
                        # so tv stays something, but .y.later = v extends forever
                    }
                    else {
                        from and x.y[from] = v;
                        to and v.y[to] = x;
                        # now tv sets us.
                    }
                }
                
                # make tv_dup, index as tv but to [] of items at the point
                # the minter will care about such things, T clutter, minor errors, noise
                if (dupz) {
                    !d.our and throw "housing not given"
                    $p = {t:'z'};
                    p.our = d.our.slice();
                    $gk = p.our.pop();
                    p.our.push(gk+'_dup');
                    p.path = d.path.slice();
                    # dup should include the one already there
                    p.zefault = [x];
                    io.input(s,p,v);
                }
                
                d.keep_first and return 1
                # but we (as eg tv) shall go on to tw and z even dups
                # no information lost!
    };
    A&io = io;
    return io
    
t/iooia: |
    G&heading;
    $io = G&way,'iooia';
    G&way,'Doming',ar;
    
    $a = &t,talk,cetia,c{
        $params =
        cetia ?
            typeof cetia == 'object' ? cetia
            : cetia.split(' ')
              .map(&s{ return G&Cye,[s] })
        : [];
        
        $what = talk+(cetia ? " <--- "+ki(cetia) : '');
        m $t  $s:what %hue:200deg,dis:block
        
        $d = {};
        $r = io[t](talk,params,d);
        
        if (c) {
            # more awareness
            (c == 1 || c.show) &&
                m d_of_"+t+"  $s:d
        }
        $thing = t == 'parsetalk' ? r : r.sc;
        $n =
        m $t  $s:thing,dl:7.22
        typeof c == 'object' and ex(n.c,c)
        return r
    };
    
    S 1 respec-talk
    a('parsetalk','w/*:w');
    a('parsetalk','trouble/w:r/#w:t','weeee',1);
    a('parsetalk','$t o $w/*','tea weas');
    # from the story of -respec:
    # o w/*:w
    # if problem with $w:
    #   i trouble/w:r/#w:t
    #   ts&dige = supposedtobe
    #   i $t o $w/*
    
    S 2 respec
    A.r = G&Cye,['iooia',9,{M:[]}];
    $now = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','weeee');
    
    $aw = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','walso');
    
    $aw = a('o','w/*:w');
    
    $ay =
    a('i','trouble/w:r/#w:t','sweeee',1);
    $w = ays&t[0];
    ws&plat = 5;
    $aw = a('o','w/*');
    # too far
    $aw = a('o','w/*/*',0,1);
    $aw = a('o','trouble/w/*',0,1);
    
    $aw = a('o','*',0,{show:1,dl:5});
    
    
    $aw = a('o','*/*',0,{show:1,dl:5});
    
    
    #a('i','w:r/#w:t','well');
    #a('i','$t o $w/*','tea weas');
    
    
    S 3 i/o
    
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    $o = G&Cye,['blag','2',{s:'gakel'}];
    n attaching_to -fod $s:d,dl:14
    
    $N = io.i('$d/$o',[d,o]);
    $oN = io.o('$d/*',[d]);
    m enN -fod $s:N,dl:14
    m ouN -fod $s:oN,dl:14
    
    
    #c iteration
    S 4 iteration
    n ble 8 s:iteration %fs:600%,dis:block
    # so 'i $t' tv's each 'o $w/*:W', like 'i $t $W'+
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    'doofica latico matri vou'.split(' ').map(&s{
        $o = G&Cye,[s,'1'];
        i $d/$o
    });
    a('o','$d/*',[d],1);
    
    a('o','$d',[d],1);
    #$r =
    o $d/*:r
    
    $matri = G&Cye,['matri',1,{morematch:2}];
    
    $maN = a('o','$d/#matri',[d,matri]);
    
    $ma = maNs&matri[0];
    mas&cla = 'osi';
    
    $vong = G&Cye,['Viog',34];
    i $ma/$vong
    
    a('o','$d/*/*',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar.sc,dl:5
    }
    m iterator  $s:t,d:8.22 %fs:120%
    
    i $ma/#vong
    v = ays&vong[0];
    vs&latjkc = 42;
    a('o','$d/*:dui/*:s',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar.sc,dl:5
    }
    m anotherator  $s:t,d:8.22 %fs:120%
    
    # reuse this pile of C
    1s&sandy = d;
    
    #c Monday
    =Monday' for all of them together:
    
      nz - nz=[(C,nz?)*]
        array-indented C, as a format to build like d.rows
        just like the idea, no immediate use.
        why make data look more like indented Lines?
        mere exercise
      
      io.nz - convert it to whatever,
          see iteration
    
      plumb:
        join an i from an o
      Functions:
        also:
            i $d/@whur/@lamb { s&fat && "laughter" }:whur o $lambs/*
        which:
          greps (by default?) and assigns value to whur
            which becomes a bareword to the i
          deciding where lambs go
          should have \ at end of line to continue expression...
        if no :arks in an i, uses last column,
        
        
        on-name symbols:
      <  -name delete!
         @name referring to other name, from func or plumbing
         #name just t/cv of v, which is doesn`t have to be set to
         $name is a var parameterised into the call
      
       inbetween bits:
         { code code code }:name
           Babz auto return in sub`s last line
         becomes column
         greps if not named or named grep
         
         y
           cloning the C as it moves over...
           forget about using its .y.tv tho, see perspective
         yC,o
           means cloned.y.C = origin, origin.y.o = cloned
           and these have some knownness,
           should always be able to go C-ward?
         y-
           cloning C but disconnecting them from things we dont take with us
         
      perspective:
          as we i ... y o ...
          clones C as they pass into the i
          everything selected will need repointing to itself,
            as A:o does
        < wandering off to do that
        < trimming innards (no delete)
        < the S o things iterating dome
          < o words implying o words:/*:word
          < i @lamb implying the connected o lambs/*:lamb
            by changing the sark t on the receiver? + giving it an ark
          < ark = 1 anywhere?
        
      
      future:
        knowing the protocol space to a delete is nice
        and operating work-isolatingly from a big sleeping set
      
      #c on iteration:
        basically, get an iterator object:
          $t = io.nz()
        setup from T.o, the last i/o $d
        flat map like G&ind:
          t.ind(&s,t{ [t.d,s] })   # [ [depth,C]+ ]
          t.ind(&s,t{ ki(s) })     # [indented toLineses]
        iterate rows:
          ar = t.more() # named columns
          s = t.more() # if one ark/thing in total
        see code about grouping nonarks into [v+]s
        
        while(ar=t.more()) it
        or use Duning S with io in it
          which will be most of the time!
          the new way.
          once subnetting S so Swhiles of io can
            be used instead of for, each, etc.
            and the data-picking-through excercise can compile for specifics
        the $t then the cursor, which S shall:
          take care of, and:
            Babz: set vars from ar
            S: hold the cursor while J6s exchange, see J6ing
        
        < getting the corresponding p? who cares
        
        function should be able to set the ind fu
        
      
      J6ing
        a J6 is a J attempting to do itself,
          or something to do with itself, about dome consciousness
          and s if it works, like a commit
            or works enough for an s-level wake, like a savepoint
              and s should be the total picture of the game being J`d
        a J<6 is deciding on J6,
          doing small things, like e,
          then working out desire/skip/sleep potential,
            sometimes working on only such domes,
              but such work is J6ing.
        
        but 
      
      < pipelining, a rattley flood of A:o would...
          esp if they push certainty on each other
          as welding a long seam, its only a liquid for a little stretch
      
      other stuff:
      < specialise #things spacer creation (with a doof)
        what about loose matches?
          low levels want to take callback/expression?
          and how to steer the search nearby,
            or use datetime to seek when it was
            or where else in the schema it might have disappeared to
            if O knows when it disappeared?
      
        p could be C, etc,
          is more shapely and langholdey than rows
          they offer an alternative positioning system,
            according to the new gravity cast on it.
        and turn into A:o, a self-similar data-holding foam
        p could become o@3 compatible
        
        p could become aware of what's around what they're aware of,
          and then -od fields of data that show when stuff isn't on the screen changes
        
        d has now a sc for sc[k] = v (ar) when iterating,
          and before iteration begins is ar[k] = [v+] for unique and true v
        could be some kind of A:o then.
        they will have to handle travelling between representation modes
        A:o awakening is a process of walking through A&insides, A&clones
        
        this one is sc that is like ar[k] = v 
        before iteration begins its ar[k] = [v+]
        
      < write d>o instead of i $d/$o?
         magnetics want to... ranking, raking...
         for sorting the junkdrifts of culture

         < completing this -fod now so it sees d before io
           WHILE it`s an M thing would be something
           we will often be populating a populated space,
           starting a job with half the required information
        
    =cut
    # '
    
    #c hmmm 
    S 5 strange formats
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    o $d:lish/*/*
    # < solve this... if ark is singularly defined we could return it?
    #   and if many we could return them as whole columns...
    #   and only return last column when no arking
    m lish_var -jod $s:ays&lish
    
    $t = io.nz();
    
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m inded  $s:s %hue:80deg,ws:pre,dis:block
    
    t.partial = 1;
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    
    # plumbing
    S 6 i<-o plumbing
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    
    $n = G&Cye,['upsulat','1',{s:'gakl'}];
    i $n:an o $d/*
    # i can set vars... use T.o if you unsure of 1/+ness
    $t = io.nz();
    m andasio_To  $s:T.o
    m andasio_varset  $s:ays&an
    m andasio_tmore_once  $s:t.more().sc
    m andasio_tar  $s:t.ar
    m andasio_tmore_twice  $s:t.more().sc
    
    o $n/*/*
    $t = io.nz();
    m therowsofan  $s:t.rows,dl:8.16
    
    t.partial = 1;
    $s = t.ind(&s,t{ return G&toLines,s }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    # S
    S 7 domeration
    
    m todo  s:todo
    
    
    
    # grep
    S 8 functions
    
    m todo  s:todo
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 8.24;
    }
    
t/iooiata: | # func really
    G&heading;
    $io = G&way,'iooia';
    #1s&step = 2;
    G&way,'Doming',ar;
    
    $show = {};
    show.talk = 1;
    $a = &t,talk,params{
        if (t === '' && !talk) {
            m space   %fs:120%,hue:170deg,width:100%,height:3em,dis:block
            return
        }
        if (t == 'bug') {
            m bugreport  $s:talk %fs:120%,hue:170deg,dis:block
            return;
        }
        t && io[t](talk,params||[],{})
        $t = io.nz();
        
        show.talk &&
        m talk  $s:t.talk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
        
        m thistest  $s:talk %fs:160%,hue:120deg,dis:block
        
        show.t &&
        m iter  $s:t,dl:9.26
        
        t.partial = 1;
        #A.debug and debugger
        $s = t.ind(&s,t{
            $text = G&toLines,s;
            if (t.objects && t.objects.indexOf(s) >= 0) {
                # highlight t.objects (that doof matched)
                # < chucking rows with any object on matching
                # iterate objects if that's all you want
                text = G&intag:'>1 '+text
            }
            if (show.y) {
                # attach y, which hides most first
                $say = ki(s.y,6.24);
                say = say.replace(/^\{|\}$/g,'');
                text += "\t"+G&intag:'>3 '+say;
            }
            return text;
        }).join("\n");
        m inds  $s:s,ht:1 %hue:120deg,ws:pre,dis:block
        # lum for dumping state
        t.p = 'usual';
        return d
    };
    $nz = &show{
        $t = io.nz();
        t.partial = 1;
        t.ungrouped = 1;
        while (show && t.more()) {
            m apull  $s:t.sc,dl:8.26
            m srow  $s:t.row,dl:8.26
        }
        return t
    };
    S 1 make a dee, replicate to cee
    $start = 
      "upsulat\t\ts:gakl\n"
     +"  doofica\n"
     +"  latico\n"
     +"  matri\t\t\tcla:osi\n"
     +"    Viog\t\t\tlatjkc:42\n"
     +"    Viog\t34\n"
     +"  vou\n";
    $d = 1s&dee = G&readLines,start [0];
    show.t = 1;
    a('o','$d/*/*',[d]);
    
    o { Object.keys(C.sc).length }:tings $d/*/*
    a(0,'funclast grep by sc length');
    $t = nz();
    while (t.more()) {
        m apull  $s:t.sc,dl:4
        m srow  $s:t.row,dl:6
    }
    
    o { C.t = C.t.split('').reverse().join(''); 1 }:tings yD,o. $d:cee/*/*
    a(0,'funclast map tchange after separation, yD,o');
    $t = nz();
    while (t.more()) {
        1s&cee && t.sc.cee != 1s&cee and throw "cee (toplevel) irregular"
        1s&cee = t.sc.cee;
        m apull  $s:t.sc,dl:8.26
        m srow  $s:t.row,dl:8.26
    }
    
    #c 22
    S 2 change cee & see
    $o = G&Cye,['fall'];
    # < #@class bareword from non C (C.t = the string?
    #     or A:o map it in c&s and draw cartoon for C.t)
    #   making C hold weirdness
    $flav = /o/;
    $vat = &C{
        $j = C.t.match(flav);
        j and return G&Cye:["heard of "+C.t,4]
    };
    
    !1s&cee and throw "NO cee"
    #i $o/@klass/@doop va:{ va(C) }:klass 
    #A.debug = 1;
    o va:{ vat(C) }:klass 1s&cee/*:va/*:doop
    a(0,'only hear of va things having o');
    #debugger;
    $t = nz(1);
    o { vat(C) }:klass 1s&cee/*:va/*:doop
    a(0,'hear of things having o');
    
    
    #debugger;
    i $o/@klass/@doop va:{ vat(C) }:klass o 1s&cee/*:va/*:doop
    a(0,'cant i without full path');
    $t = nz();
    
    
    $o = G&Cye,['fall'];
    flav = /t/;
    i $o/@klass/@doop va:{ vat(C) }:klass o 1s&cee/*:va/*:doop
    a(0,'can i with full path, but only one doop matches...');
    # < load up all the doops?
    # > ar.klass == 1, in t.arky twice?
    $t = nz();
    #debugger;
    # < 1s&cee -> cee in talk
    
    $o = G&Cye,['fall'];
    flav = /i/;
    #A.debug = 1;
    i $o/@klass/oooo/@doop doop:{ vat(C) }:klass doop:y:doop o 1s&cee/*:va/*:doop
    a(0,'can i with full path, some separa');
    a('bug',"returns two ventures into 'heard of'"
        +" because two identical (but !=) @klasses happen, o ends up with one");
    #$t = nz();
    #A.debug = 0;
    
    # load up all the doops but returns klass/doop
    #   as well as klass/oooo/doop, looks like doing things twice
    # > ar.klass == 1, in t.arky twice?
    # < diy debug wedge, big words of code
    o $o/*/*/*:dof
    a(0,'o ends up with one pair of goiV');
    
    # lets try and circumvent that bug
    $o = G&Cye,['fall'];
    flav = /i/;
    #A.debug = 1;
    i $o/@#klass/oooo/@doop doop:{ vat(C) }:klass doop:y:doop o 1s&cee/*:va/*:doop
    a(0,'can i with full path, some separa');
    a('bug',"still branching too much... examine with tools later");
    #$t = nz();
    #A.debug = 0;
    
    # load up all the doops but returns klass/doop
    #   as well as klass/oooo/doop, looks like doing things twice
    # > ar.klass == 1, in t.arky twice?
    # < diy debug wedge, big words of code
    o $o/*/*/*:dof
    a(0,'o ends up with one pair of goiV');
    $t = nz();
    while (t.more()) {
        $dof = ts&dof;
        dofs&seen = 'overino';
    }
    
    show.y = 1;
    o $o/*/*/*
    a(0,'see o');
    o 1s&cee/*/*/*
    a(0,'see cee');
    o $o/*/*/*:dof
    a(0,'see o again');
    
    # make some more messes
    # < somewhere, someone wants to do this:
    #i $o/bolo/@ump/@dat dat:ysource,destiny zom:{ C.t.match(/oo/) }:dat zom:{ C.t.match(/al$/) }:ump o 1s&cee/*:zom
    #   needing doof to put the C in place of what match returns
    #   things unbounding, jumping through hoops, rebounding
    #  usually mean to not ark the function
    $seen = [];
    i $o/bolo/@zom ysource,destiny { seen.push(C); C.t.match(/al$/) } o 1s&cee/*:zom
    a(0,'adding al$ zom to bolo o');
    m whats  $s:ay.sc,dl:6.33
    m seenCfunc  $s:seen,dl:6.24
    #i $o/bolo/@ump/@dat { s&grabb = 1 } ysource,destiny zom:{ s&grabb = 1; C.t.match(/oo/) }:dat zom:{ C.t.match(/al$/) }:ump o 1s&cee/*:zom
    
    o $o/*/*/*:dof
    a(0,'see o again');
    o 1s&cee/*/*/*
    a(0,'see cee');
    
    1s&ooo = o;
    #c 33
    S 3 super nice
    show 
    $c = 1s&cee;
    $o = 1s&ooo;
    o $o/*:bit/*
    show.y = 1;
    a(0,'see o again');
    $t = io.nz();
    $oo = [];
    # F for stuff
    t.ind(&C,t{
        t.d <= 1 and return
        $na = C.t.match(/(o)/g);
        !na and return
        oo.push(na.slice(1))
        each in oo {
            $name = n.join('ii');
            $na = G&Cye,[name,3];
            ~>39 injecting: name
            i $C/branch/$na
        }
    });
    o $o/**
    a(0,'see o wanderingly');
    $t = io.nz();
    t.partial = 1;
    t.ungrouped = 1;
    $row;
    while (t.more()) {
        row = t.row;
        $s = row.slice(-2)[0];
        s.t != 'goiV' and continue
        i $s/$o
        break
    }
    m looped_tarky  $s:t.arky,dl:8.24
    m looped_trow  $s:t.row,dl:8.24
    m looped_row  $s:row,dl:8.24
    
    o $o/**
    a(0,'see o wanderingly with loop');
    
    $t = io.nz();
    t.partial = 1;
    t.ungrouped = 1;
    $row;
    while (t.more()) {
        row = t.row;
        $s = row.slice(-2)[0];
        s.t != 'fall' and continue
        break
    }
    m looped_tarky  $s:t.arky,dl:8.24
    m looped_trow  $s:t.row,dl:8.24
    m looped_row  $s:row,dl:8.24
    
    i $o/bolo/tank
    i $o/bolo/boil/river
    
    S flute: o $o/*:glib/*:glub/*
        glubs&direction = "Under "+glib.t;
        !(s && s.map) and debugger;
        s && s.map and glubs&supports = s.map(&s{ return s.t }).join(', ');
    S
    
    o $o/**
    a(0,'see o has become more self aware');
    
    
    =pod check out ar returnings
        i $d/@whur/@lamb { s&fat && "laughter" }:whur y { fai(C,s); s&ok = 1; s&depth * 3 } o $lambs/*
        i $d/@whur {dehydrate:5}:whur ye,C. {notch} y o $lambs/*
        i $d/@la/@dio la:{s&i++;1} dio:y o $ohp/*:la/#loc/da/*:dio
        o { Object.keys(C.sc).length } $d/*/*
    
    =cut 

    # < nz/somethingin finds toplevels
    # < hierarchy from flat tools in io
    #     you'd be building them on top probably...
    #       but providing safe data wandering
    # < clarify how to use to gather C on C
    # 
    A.debug = 1;
    # check:
    # {}:ting $d/*:ting # should have 1 ting column
    # searching for @names
    
    #a('$d
    
    # needs z interpreted as tv
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 12;
    }
StayToSleep: | # gentleness scan
    # 
t/BuildACastle: | # test Duning and io
    # ones
Fly: |
    G&heading;
    G&way,'t/iooiata',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
grow: | # spraw Js&ope qua
    # there must be a S/C/A clicky scheme attacher somewhere
    $Y = c.y.A.1;
    Ys&ope ||= 0;
    Ys&ope += e.t.includes('C') ? -1 : 1;
    ~Told: ki(Y), ki(Y.3)
pi/fod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # where was above? 2Cc&d was going to do this...
    $u = A.n.up.n.c.s;
    c&d ||= uc&d || 1;
    c&d > 1 and ys&ml = (c&d - 1)+'em'
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    $dl = c&dl || 3;
    1s&ope and dl += 1s&ope;
    
    $es = c&s;
    es = ex({},es);
    if (es.path) {
        $p = es.path;
        delete es.path;
        each in p {
            m path -fod $s:n,d:2,dl:7
        }
    }
    if (es.p) {
        $p = es.p;
        es.p = ki(p,4.22);
        c&p == 1 &&
        m psomething -fod $s:p,d:3,dl:7
        if (c&p && c&p != 1) {
            $s = p[c&p];
            m psomething -fod $s:s,d:3,dl:7
        }
    }
    if (es.plumb) {
        $p = es.plumb;
        delete es.plumb;
        m plumb -fod $s:p,d:3,dl:7
    }
    
    
    
    G&n,['Thing',3,{s:ki(es,dl)}];

