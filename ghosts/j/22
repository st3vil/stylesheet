TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # piling stuff up
    =head
        stop top posting
      TD
      to start raying together ghost/wormholes and travel
      so change becomes a crawling shadow,
        io doing it,
        also io bringing in the first bunch of code
        being non-throaty
        maybe thro/G&U
      
      taking errors, runs
      and io lugging the outyrageous warm shadow
        finding tests to run,
        depending on the concentricism of W around it
      
      would be worth finishing these tests tho...
        have to have pressurised angles to find breaking points
      
      ten it should bes, 11 would bes, 12 could bes?
        search/find and plant on memories forever more?
      
      hammering facts, talking heads
      and now was a good time to stop
      but, varta
      bit seeker while bits restart about
      
      
      to be a sort of terminal... fuzzing trees, pushing
      want some key aiming,
        G should freeze time and give then fairly safely to A.4,
          who has moments to respond before A.5 blows it away to try again
        and all those Elvis vector things...
        following requests all the way through
      
      #msgs is getting composted in -rogram
        sequentia shall io make
      Duning and Doming are the same thing...
        shall indented S be subnetted? ya. make em fractions.
        fit whiles together inside each other, so that:
      S 4 feel queue
        S o queue/$w
          $w one by one code
      S 5 desire changes
        # etc
        that should be able to handle doing jobs interrupted
        everything A:oing what might be changing
          the generosity/paranoia of those wake/sleep diff scans
          is very test-honed
        M y cvs 0.300dome00sequ
      
      and geometry! through io/F
        speaking of everything,
        we need a G&something,<<'' Babz,
        whose wayings can reBab locally (on 4)
        the way is fundamentally about how to hold the stuff that code was
        as its use changes as it is born in a magma holder, to drain mystery,
        cell-divide and grow into a known I thing
      
      so run a little way village with io...
        virtualise some dream to do so
      
        
      
      
    
      teach perl/js via Thangers on:
        t.rows.indexOf(t.row)+' . '+t.i+'  '+ki(t.ar,6.23)+'        '+ki(t.next,2)
      watching is a goof, a drunk, a nun and a young programmer
          perl:   say =~ s/^\{|\}$/sg;
        js:     say = say.replace(/^\{|\}$/g,'');
      
      etc.
      
      other stuff:
        
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        Ladada
      ; matters much for no reason
      brackets also
      filigree?
      
      general \ at the end of the line to continue expression...
        strange one
        idea of cs and more to the C in some compression, out of tycsc mode
        would let base64 image data after sc...
      
      Babz:
       - do some stuff in javascript! the messiest and easiest things
       - n... wants loose t that concats $vars, so we can type endlessly
         until:
         since cv is always -jod or \d (or W)
         y can say :W instead of W, one c&thing == C.t could odify like that
           maybe more if the boundary is not text but a bubble
           when everything similarity matches itself
             and stretches tendons of divergence
      
      =cut
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
iooia: | # F > i/o > input/output
    =these will all be G&F, G&o, G&i...
    
    =head1 round until found
    
     other possible types of thisness:
     - G&s for writing notes for itself
       using traces left by i/oing etc nearby
       doing crazy implicit templating
       throwing universal weight around
      also s is where situations are strategised on
    
    =q[
         see if there's functions anywhere
         they are a separate logic to the pointy path
         < mix up as much as you want
         
         have a right to left flow, assigney
           i {funclast} pointy/path {funcfirst} o ...
         usu.
         
         functions map/grep
         < making rows
           do that via T? see via T
         should happen before descent into the d.path
           since values maybe sarked (@name) from what it does
         
         via T:
            like Swim things, they say:
              understand this name, then you look it up
                and figure out how to work it
              Core describes Knowables, like how to:
                input/output such index
                where/what/how it's going
                  where as in something in s should consume it
                  pretend to be a column or iterator
                  or it's rows/columns being added/replaced/removed
              T percolate out like errors/warnings if they are too unknown
                 may have a part to it specifying where,
                    like swim is to-cv
        
        <
          y*/separation is like a function,
          must rerow to represent any rearrangement
          so each thing throws up a new iterator
          link them?
          
    F is a culture of grasping syntax on top of o
    data formulae
    
    ]
    =cut
    $io = {}; # a bunch
    
    # a limb
    io.F = &s,d{ return G&way,'PseudoF',{s:s,d:d,io:io} };
    
    # the base datatype
    # see also G&datam and C
    io.isC = &s{
        return s && typeof s == 'object'
            && s.t != null && s.y && s.c && s.sc
    }
    
    #c parsetalk
    # parse out bits into m
    $parse;
        $m;
        $p = &r,place{
            m = parse.match(r);
            !m and return
            m.shift();
            place and place = place.split('').map(&i{ return m[i] }).join('');
            else { place = '' }
            parse = parse.replace(r,place);
            return 1
        };
    
    $ta = G.tiestowe = [];
    
    # compile time
    # see j/41/jababio
    # the string is basically a branch/path 
    #   params give values to columns, named with /^[$#]/
    #   params return or made available somewhere, per column, per row...
    # saving much typing!
    
    # can't really bab 1 line to many to set params
    # must return N
    #   it's what's expected? (at io (not F?))
    # and put iterator interface on T...
    #   later some way to do cursors,
    #     percolate and collaborate read-need-ness
    
    # but in an S:
    #  S can do io and then be iterating
    #  Babz setting params inside from T
    
    
    # general branch lingo
    # something for C-together
    # < making sql
    # params written as if string interpolated:
    # they create/read object or some reduced idea of an object:
    # the column will/must have/match the given param's value/identity,
    # $o - value
    # #o - looser/vaguer/processed copy of $o
    #      like spacers, with only C.t=o.t
    # word - spacer of C.t=word
    
    # < want o to find the exact object, not it's identity?
    
    # < unless it names a universal (1s&bareword) or so,
    #   then use that. inner lingosanctum.
    io.parsetalk = &talk,params,d{
        d ||= {};
        parse = talk;
        # do i ... for o ...
        p(/ ((i|o) .+)$/) and d.plumb = m[0]
        # plumbed bit gets parsed after its downstream,
        #   but runs before, so know what:
        p(/^(i|o) /) and d.is = m[0]
        # absorb the o lop ^
        talk = parse; 
        
        # Babz shall do params, see 'compile time' ^
        d.path = []; # pa+
        while (p(/^(\S+)\s*/)) {
            # < '{}:m' -> params contains a &acgts{ map/grep/sort }
            #   with implicit return lastline
            #   whose value becomes a column
            $path = m[0].split('/');
            $outer = parse;
            $pa;
            $dpa = &eatparam{
                if (eatparam) { # bind param to path bit
                    pa.isparam ||= 1
                }
                d.path.push(pa)
            };
            each in path {
                parse = n;
                pa = {};
                
                #c grasp tokens
                # so i $o/yap will not param=$o, separation=ap
                $island = path.length == 1;
                
                # y clones C
                if (island && p(/^((\w+:)*)y(\S*?)(:\w+)?$/,'03'))
                    pa.separation = m[2] || 1;
                
                # delete all innards without returning em
                p(/-$/) and pa.delete = 'in';
                p(/^-/) and pa.delete = 'out';
                
                # where-iations on glob
                # on-a-pa function, talk for F-iltering
                #   for .found on whatever step
                #     abit{3/*{>1/*{c&of/*{s&of=i
                # greffing
                if (p(/\{([^\s\}]+\S*)\}?$/)) {
                    pa.gref = m[0];
                    $grefouter = parse;
                    parse = pa.gref;
                    while (p(/\$(\w[\w\[\]\.]*)/)) {
                        (pa.grefpara ||= []).push(m[0]);
                    }
                    parse = grefouter;
                    # implies globbing
                    parse == '' and parse = '*'
                }
                
                # set var/name column from path bit
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                # which ark specifically (usu all/sarked) to doof
                while (p(/^(\w+):/))
                     (pa.arkfor ||= []).push(m[0])
                # function
                p(/^((\w+:)*)\{(\w+)?\}$/) and pa.doof = m[0]||1; dpa(1); continue
                pa.separation and dpa(); continue
                pa.arkfor and throw "arkfor non-doof"
                # and use each of them
                #   name moves to new position (ark)
                p(/^@/) and pa.sark = 1; pa.ark ||= 1;
                # can be i $i/@#dee/$fings o $o/*:dee
                #   to copy spacers
                
                # get path bit/value of here from a variable:
                # t-only/squish/shaded clone of C, or
                # C itself
                # when o the C will match itself/navigate onwards
                # or i will input that squished C,
                #   and/or ark/return,
                #   and/or climb past it and input more stuff...
                # sheer spacer, made for a C
                #   eg where desired.t == wanted.t
                p(/^(\w+)?#/) and pa.isparam = 1; pa.relative = m[0] || 1;
                pa.sark and delete pa.isparam;
                
                # uses thing from params
                p(/^\$/) and pa.isparam = 1
                
                pa.t = parse;
                
                # anything, anything deeply, anything something matches
                if (pa.t[0] == '*') {
                    pa.glob ||= 1;
                    pa.t == '*' and // yep
                    else
                    pa.t == '**' and pa.wander = 1
                    else
                    p(/^\*(\w+)$/) and pa.wander = pa.wanderer = m[0] || 1
                    else {
                        throw "wandery looking", pa.t
                    }
                }
                
                pa.ark == '1' and pa.ark = pa.t;
                
                # value of here from a:
                if (pa.isparam) {} # variable/param, bind later
                else
                if (pa.glob) {} # anything
                else
                if (pa.sark) {} # name of a column in d.plumb
                else {
                    # words are the lumber of the algorithm
                    pa.word = pa.spacer = 1;
                }
                # low-resolution image of something, usu t and maybe cv?
                pa.relative and pa.spacer = 1
                dpa();
            }
            parse = outer;
        }
        parse and throw "Unparsed", parse
        
        #c 2 grasp better
        $fi;
        each i,pa d.path {
            # < many pathed fun, dimensions?
            if (pa.sark && pa.isparam) {
                # array of something, eg @#$names spacerises an array of t
                # is like Pmod in multicity
                pa.isother = 1;
            }
            if (pa.separation) {
                $mode = pa.separation;
                mode == '1' and mode = 'C';
                parse = mode;
                # how to clone depth
                p(/\,$/) and pa.yshallow = 1;
                p(/\-$/) and pa.yalone = 1;
                # can yer through time, 'y' implies new.y.C = old
                mode = parse.split(',');
                mode[0] and pa.yto = mode[0];
                mode[1] and pa.yfrom = mode[1];
                pa.doof = 'separation';
            }
            if (pa.wanderer) {
                $name = pa.wanderer;
                each i,da d.path {
                    !(da.arkfor && da.arkfor.indexOf(name) == 0) and continue
                    da.hijacked = pa;
                    pa.hijacks = da;
                }
                !pa.hijacked && !io[name] and throw "no wanderer "+name
            }
            if (pa.wander) {
                # implies shape may vary
                d.partial = 1;
                $rest = d.path.slice(i+1);
                $sensible = rest.filter(&s{ return !pa.doof });
                sensible.length and throw "Cannot unwander";
                # < because row must fit path
                #   be nice to find such cul de sacs after however far
                #   that's really what we want in a little while
                #   Arrays only kind of work with fractions, no indexOf it seems
                #     or a many-celled cell could do it...
            }
            if (pa.gref) {
                # parse gref, params bind their names (at compile time)
                pa.grefd = io.gref([],pa.gref,pa.grefpara.slice(),{not:1});
            }
            !pa.doof && !fi and fi = pa
        }
        if (d.path.length == 1) {
            d.path[0].separation and throw "mistook yword for separation?"
        }
        #c 3 implications create path
        
        # o word   implies   o A.r/word
        if (fi) {
            # first non-doofer
            if (fi.glob || fi.spacer) {
                # seems to have something to look at already
                !A.r and throw "unreal beginning, no Ar"
                # < may refer to a 1s&word?
                #   Babz must collect & maybe deposit them all somewhere
                #     would make good autodoc
                #   and so Domes and other tatters of process can be
                #   undef'd after a point, or to some sense....
                pa = {t:'r',implicit:1,v:A.r};
                d.path.splice(d.path.indexOf(fi),0,pa);
                # should leave out of rows, being implied?
            }
        }
        
        # o $d   implies   o $d/*
        if (d.is == 'o') {
            !fi and throw "no one?"
            if (d.path.length == 1 && fi.isparam)
                d.path.push({t:'*',glob:1})
        }
        
        # i $d o $o   implies   i $d/@s o $o/*:s
        if (d.plumb) {
            # < i $i/@#dee o $o/*:dee   to copy spacers
            if (!d.path.filter(&pa{ return pa.sark || pa.wander }).length)
                d.path.push({sark:1,t:'s'})
            # or, if d.plumb (iterator) has no ark:s
            #   < use path[-1] (default in d.plumb's h.Pmod's coli)
            #     should be here, where language sorts itself out
            # call it wruple, the wriggle of tuples
            # or if we have arks that don't exists over there:
            #   < find @lamb in $lambs/*
            # done just in time out in various places...
            # < other: io-ish syntax/tool these such operations ^
        }
        else {
            if (d.is == 'o') {
                # o ... y   implies   o y ...
                $i = 10;
                while (1) {
                    i-- < 1 and throw "many y..."
                    $pa = d.path.slice(-1)[0];
                    !pa.separation and break
                    d.path.push(d.path.pop());
                }
            }
        }
        # < without plumbing, i $d would do nothing?
        
        $before = 1;
        $after = 0;
        each i,pa d.path {
            before && !pa.doof and before = 0; # path begun
            !before && pa.doof and after = 1; # path finished
            after && !pa.doof and debugger; throw "two bits of path? "+talk
        }
        
        # 6/8 others, use up params
        d.plumb and d.plumb = io.parsetalk(d.plumb,params)
        
        # 7/8 in rowing, with params
        
        # without plumbings on
        typeof talk == 'string' and d.talk = talk;
        
        # 8/9
        return d
    };
    
    #c doof: through function
    # is a join from the rows already, but pretending its not
    # adds a column for return value
    io.doof = &D,t,pa{
        # supplied for pa.wanderer to pick atoms with
        pa.hijacked and debugger
        # take iterator
        !t.more and t = io.nz(t)
        if (pa.doof == '1') {
            $cb = pa.v;
            typeof cb != 'function' and throw "Not function", pa
        }
        else {
            # eg separation, must return a t (post-nz())
            return io[pa.doof](D,t,pa)
        }
        # copy schema, little else
        $d = {};
        d.talk = t.talk;
        d.plumb = t;
        d.path = t.path.slice();
        # try use the doof column for function's return
        $funci = d.path.indexOf(pa);
        funci < 0 and d.path.unshift(pa);
        # iterations vote for/against row and a cell: {
        #   r: func return value
        #   row: in t.rows[t.i]
        #   s: in .row[i/t.d], the one unique object, the cell
        #   i: t.d (depth) or t.path[i], the column
        $inc = [];
        $exc = [];
        $doofings = []; # everything
        if ('grepping or mapping') {
            if ('uni') { # que objects, rhythm >= to rows
                t.partial = 1;
                t.ind(&s,t{
                    # C the item, s the iterator, to them
                    !io.isC(s) and throw "doof-grep-ind got !C s",s,t.row;
                    $si = t.row.indexOf(s);
                    si < 0 and throw "s not in trow?",s,t.row
                    $sa = t.path[si];
                    if (pa.arkfor) {
                        # only those for this y
                        pa.arkfor.indexOf(sa.ark || sa.t) < 0 and return
                    }
                    
                    $r = cb(A,s,G,T,t);
                    
                    $doofing = {
                        r: r,
                        row: t.row,
                        s: s,
                        i: t.d,
                    };
                    doofings.push(doofing);
                    (r ? inc : exc).push(doofing)
                });
            }
            else {
                throw "wants rows or the/other arks";
                # changing path/arks means another iterator?
                # or we just change em, t = nz(t)
            }
        }
        else {
            throw "mapping, doing, regrouping, signal gen, who knows"
        }
        # inc-ings vs exc-ings
        # to dedupe itering objects on the same row,
        # < pick the row that describes more matches at once?
        #     to avoid talking about stuff that didn't match?
        # < nonfirst objects on a row lose their return value,
        #     since we only have one doof column for it
        #     shapeliness problem
        #   assume they will use d.objects and d.returns
        #   
        #   < rowing itself should use input/output
        #     so any shapeliness problem can escalate and solve itself:
        #     nonfirst objects return values:
        #       could have column types,
        #       make the doof an array referring to other columns?
        #      so it can get really complicated,
        #      methods for schema/data
        #      ways of partitioning problems and stats near
        # anyone says yes
        # < we could tally results a bit
        #   before deciding how we are operating
        #     if they all seem boolean
        # < maybe they should pick the best one along the row?
        #   ie if we're looking for music, the live streams deep
        #     within the music collection should win
        # < the comp for attention
        d.objects = [];
        d.rows = [];
        d.returns = [];
        $la;
        each i,r inc {
            d.returns.push(r.r);
            d.objects.push(r.s);
            r.row == la and continue
            !r.r and continue
            la = r.row;
            $row = la.slice();
            funci < 0 and row.unshift(r.r)
            else {
                row[funci] = r.r
            }
            d.rows.push(row);
        }
        return io.nz(d)
    };
    
    #c separation - cloning process
    # pa is from a D.path consuming this t
    # happens as a firstfunc
    io.separation = &D,t,ya{
        # another iterator
        $d = {};
        d.talk = t.talk;
        d.plumb = t;
        d.separation = 1;
        A.deyug and debugger;
        # which should have clones
        # we could know how separatey things want to be,
        # doof tends to run over everything/all depths,
        #   meaning we may have to clone for it
        # < compile what's moving where in the path,
        #   to give doof etc an orderly grasp of whats what
        # see "universals can want attention"
        # see also "no find ark/column" for when they ...
        if (!ya.arkfor) {
            # defaults to stuff @heading Downstream
            # < less column access ugliness
            #   repeating special cases for s
            # < imply .../@s when/how exactly?
            # < .../@s or @jhon or nothing should match .../jhon
            # < column accessors, knowing where looking from/through/to  
            ya.arkfor = [];
            $yai = D.path.indexOf(ya);
            each i,Pa D.path {
                Pa == ya and break
                # name wanted
                Pa.sark and ya.arkfor[i] = Pa.t
                else
                # name provided downstream
                if (Pa.ark && Pa.doof)
                    ya.arkfor = ya.arkfor.filter(&s{ return s != Pa.ark });
            }
            # make sure each sark we are adapting an arkfor from
            $arks = ya.arkfor.filter(&s{ return s });
            if (arks.length) {
                each i,pa t.path {
                    $ai = arks.indexOf(pa.ark || pa.t);
                    ai < 0 and continue
                    # is there
                    arks.splice(ai,1);
                }
            }
            if (arks.length == 1) {
                # find @lamb in $lambs/*
                $si = t.arky.indexOf('s');
                $k = t.arky[si-1];
                if (k == arks[0]+'s') {
                    $ta = t.path[si];
                    ya.arkfor = [ta.t];
                    !ta.glob and debugger;
                    arks.shift();
                }
            }
            if (arks.length == 1 && arks[0] == 's') {
                # @s defaults to their last column,
                #   which defaults to being named s only aft realise()
                $la = t.path.slice(-1)[0];
                la.doof and throw "they doof, looking for s, make column accessors"
                ya.arkfor[t.path.length-1] = la.t;
            }
            else {
                arks.length and debugger; throw "sarks unfound over there: "+arks.join(', ')
            }
            !arks.length and delete ya.arkfor
        }
        
        #A.debug and debugger;
        if (!t) {
            # funcfirst y, D.plumb would be t
            D.plumb and throw "funcfirst y !t D.plumb"
            if (D.is == 'o') {
                # is alias for funclast y, in parsetalk
                throw "o funcfirst y"
            }
            else {
                $first = 1;
                each i,Pa D.path {
                    Pa.doof and continue
                    first and first = 0; continue
                    !io.isC(pa.v) and continue
                    pa.v = io.separate(pa.v,Pa,Pa,ya)
                }
            }
            # remain !D.plumb
            return null
        }
        
        d.path = t.path.slice();
        d.rows = t.rows.slice();
        each i,row d.rows {
            row = d.rows[i] = row.slice();
            each is row {
                $pa = t.path[i];
                $Pa = d.path[i];
                #A.debug and debugger;
                if (ya.arkfor) {
                    # only those - arkfor keyed by sark in D path, not t/d path
                    ya.arkfor.indexOf(pa.ark || pa.t) < 0 and continue
                }
                # not the first thing, anticipating i $neu/** y, p $old/**
                i == 0 and continue
                # < separate other things,
                #   even indexes themselves,
                #     with new hash leading to changes, like git
                !io.isC(s) and continue
                row[i] = io.separate(s,Pa,pa,ya);
                (ya.separated ||= []).push(s)
            }
        }
        
        #A.debug and debugger;
        return io.nz(d)
    };
    #c separate
    # could get complicated soon...
    # universals can want attention here
    io.separate = &s,Pa,pa,ya{
        # Pa - io going to's path bit
        # pa - io coming from's path bit
        # ya - the .separation path bit
        ya ||= {};
        ya.olds ||= [];
        ya.neus ||= [];
        $old = s;
        $neu; # may already be:
        $oi = ya.olds.indexOf(old);
        oi < 0 and oi = ya.olds.push(old)-1;
        else {
            $neu = ya.neus[oi];
            !neu and throw "olds/neus confuse"
            return neu
        }
        
        $neu = G&Cye,old;
        ya.neus.push(neu)-1 != oi and throw "olds/neus differ"
        
        # < what to do with its innards
        if (ya.yshallow) { # y,
            # only the top clones, keeps all innards
            #   whether path includes their depths or not
            # Cye only rebuilds the C, not structures in it
            #   since not replacing them at io level
            #   so y.tv needs new hashes all over?
            #    < unless we go for rerooting indexes when anything changes
            #      then we could share a tv with an other, and when they
            #      change anything in it they would leave our instance
            #
            io.reindex(neu);
            # < to the bits
            #$D = {asa:'tv',pa:ya};
            #io.reindex(neu,D);
        }
        else
        if (ya.yalone) { # y.
            # disconnect innards
            # < elabourate input()
            io.deindex(neu);
        }
        else { # y
            # clone everything
            if (io.deindex(neu))
                i $neu/** y- o $old/**
        }
        A.deyug and debugger;
        
        ya.yto and neu.y[ya.yto] = old
        ya.yfrom and old.y[ya.yfrom] = neu
        
        return neu
    };
    #c rowing: travel d.path for i/o hooks
    # < able to async, when A:o things
    io.rowing = &talk,params,d,h{
        # should be compiled (on hut) so talk is still up front
        if (d && d.path) {
            typeof d != 'object' and throw "dnotob"
            typeof talk != 'string' and throw "talknotstring"
            d.talk = talk;
        }
        else
        if (typeof talk == 'object') {
            # d already, if compiling enough (sjson(io.parsetalk()))
            # or we are plumbed in to something that parsed our talk
            d and throw "talkref + d"
            d = talk;
        }
        else {
            # d sometimes passes through
            d ||= {};
            h.is && !d.is and d.is = h.is
            io.parsetalk(talk,params,d);
        }
        !d.talk and throw "no dtalk"
        !d.path and debugger;
        #throw "no path"
        
        #c plumbindoofins from somewhere
        # bind params nowish so parsetalk can be compiletime
        
        # bind params
        each i,pa d.path {
            if (pa.isparam) {
                !params.length and throw "Not enough params", pa.t, pa, d
                pa.v = params.shift();
            }
            if (pa.grefpara) {
                $m = pa.grefparam ||= [];
                each i,para pa.grefpara {
                    !params.length and throw "Not enough grefparams", para, pa, d
                    m.push(params.shift());
                }
            }
            # checks requiring params
            if (pa.doof) {
                !(pa.separation || pa.isparam) and throw "Doof no param"
                $known = pa.doof;
                if (known == '1') {
                    typeof pa.v != 'function' and throw "expecting doof",pa
                    # doof(acgts) each thing, or so
                }
                else {
                    typeof known != 'string' and throw "expecting doofstring",pa
                    !io[known] and throw "dont have doofer io."+known
                    # get thing to peel it already?
                    # then these d can be compiled in
                }
            }
        }
        
        # do upstream first, after params taken
        if (d.plumb && !d.plumb.more) {
            $b = d.plumb;
            !b.is and throw "no plumb.is, i/o?"
            b.is != 'o' and throw "plumb not o"
            d.is != 'i' and throw "plumb to not i"
            # compile-time
            d.not and b.not = 1
            # make the call
            io[b.is](b,params);
            # have the iterator
            #   or hold on to b again until $d is runtime (!not)
            d.plumb = d.not ? b : io.nz(b);
        }
        # 7/8 sanity on dials, exact traction
        params.length and throw "Too many params", params
        
        if (d.not) {
            # compile-time does:
            # $d = io.i(talk,params,{not:1})
            # changing the call to:
            # 'io.i(talk,params,'+sjson(d)+')'
            # so the more we can smart/moving part before now the better
            delete d.not;
            each i,pa d.path {
                pa.isparam and delete pa.v
                pa.grefparam and delete pa.grefparam
            }
            return d
        }
        
        # firstfuncs happen first, become upstream
        $i = d.path.length-1;
        while (d.path[i]) {
            $pa = d.path[i];
            # < support for mid-path doofing
            #   could decide what to put after finding options for where
            !pa.doof and break
            !(d.plumb || pa.separation) and throw "firstfunc !y no plumb",pa
            # new iterator replaces old
            # may have minimal kind of $d, no .talk
            # should have path/rows + ability to nz()
            d.plumb = io.doof(d,d.plumb,pa);
            i--;
        }
        #c d.plumb rowmuddler -one iterator multiplying itself in at several points
        if (d.plumb) {
            $t = d.plumb;
            # pa.sark and pa.v = their rows's ark
            # their (o's) rows are stitched in to ours
            #  < sarkumulative grouping... instruct a vals=[],valis=[]
            
            # P = [p], p.row = our row
            # p.pa be diverged from the one in d.path itself,
            #   so to split their pa.v (value entering/space identity)
            h.Pmod = &d,p,P,pa{
                !P[0].row and throw "must be iterating the p.rows"
                P.length > 1 and throw "already multiplying row?"
                # if next bit of our path is sarky or wandery
                !(pa.sark || pa.wander) and return P
                # ^ is the P[0].pa also
                # last sark thing has more rows
                $la;
                # climb p.up:
                $pS = p;
                while (pS && !la) {
                    pS.pa && pS.plumbpa and la = pS
                    else
                    pS.plumbpa and throw "plumbiplied above with no pa", pS
                    pS = pS.up
                }
                # ^ an io for that
                #   could it be t? a three-t? protocol, I and t (and direction?)
                #   are these d/p things protocols? or dialings?
                $R = [];
                each ib P {
                    # inject multiplicity into directions taken on the path
                    $rows;
                    if (la) {
                        !la.pa and throw "last sarking p without pa",la
                        !b.row[la.i] and throw "our row misses the last sark", b.row, la.i
                        !la.pa.rows and throw "last pa.sark didn't set pa.rows", la
                        # just their rows this row at that point dove into
                        rows = la.pa.rows
                    }
                    else {
                        # all they say
                        rows = t.rows;
                        # complete rows
                        if (!(d.partial || t.partial))
                            rows = rows.filter(&row{ return row.slice(-1)[0] })
                    }
                    
                    # la.column
                    # eat their rows:
                    # < hook to select what? around column accessors
                    $coli;
                    if (pa.sark) { # as named
                        # locate sark as ark of theirs
                        # column number, for in d.path/p.row (G/W)
                        # < try making this t.arky
                        coli = t.arks.indexOf(pa.t);
                        coli < 0 && pa.t == 's' and coli = t.path.length-1
                        if (coli < 0) {
                            # implicitly s after plural of what we want
                            # if it's 'lamb' and they have 'lambs/*', s is a lamb
                            $si = t.arky.indexOf('s');
                            $k = t.arky[si-1];
                            k == pa.t+'s' and coli = si
                        }
                        coli < 0 and throw "no find sark/column for",pa.t,t.arky
                    }
                    else
                    if (pa.wander) { # as they are
                        coli = la && la.plumb_coli;
                        if (coli == null) {
                            # our/their first wander,
                            # < plumbing sarks, then wandering the rest
                            each i,opa t.path {
                                opa.wander and coli = i * 1; break
                            }
                        }
                        else { coli = coli + 1 }
                    }
                    
                    # for uniq sarked values, group unsarked (so far)
                    #   on b.pa.rows next sarking inward
                    $vals = []; # coming out here, to a pa.v
                    $valis = []; # corresponding further branches (rows)
                    each ir rows {
                        $v = r[coli];
                        $vi = vals.indexOf(v);
                        if (vi < 0) {
                            vi = vals.push(v)-1;
                            valis[vi] = [];
                        }
                        valis[vi].push(r);
                    }
                    b.plumbiplied = vals.length;
                    b.plumbpa = t.path[coli];
                    b.plumb_coli = coli * 1;
                    
                    # multiply b by possible vals
                    $B = b;
                    each iv vals {
                        b = ex({},B);
                        b.pa ||= d.path[b.i];
                        b.pa = ex({},B.pa);
                        # b.row needn't clone?
                        
                        b.pa.v = v;
                        $rows = 
                        b.pa.rows = valis[i];
                        if (v == null) {
                            pa.wander and continue
                            #debugger;
                            #throw "nullish v! for rows",b.pa.rows
                        }
                        else {
                            #~>78 plumba: ki(b.row), ki(v,3)
                            R.push(b)
                        }
                    }
                }
                p.plumbiplies = R.length;
                
                return R
            };
        }
        #c isother Pmod, array for pa.v
        each i,pa d.path {
            !pa.isother and continue
            pa.Pmod and debugger
            pa.Pmod = &d,p,P,pa{
                !pa.isother and debugger
                # < might mean one bit of v per incoming row...
                P.length > 1 and throw "already multiplying row?"
                # < v func? C packet of expanding foam to let off here?
                $vals = pa.v;
                !(vals && typeof vals == 'object' && vals.constructor == Array) and debugger
                
                $R = [];
                each ib P {
                    # multiply b by possible vals
                    b.otheriplied = vals.length;
                    $B = b;
                    each iv vals {
                        b = ex({},B);
                        b.pa ||= d.path[b.i];
                        $ba = b.pa = ex({},B.pa);
                        if (!ba.relative && typeof v == 'string') {
                            # @$strings wanting consciousness?
                            # < 'get me a 2-94'
                            # make word, but via relative string v
                            ba.word = 1;
                        }
                        b.pa.v = v;
                        R.push(b);
                    }
                }
                b.otheriplies = R.length;
                return R
            };
        }
        
        #c beginning
        h.first ||= &{};
        h.found ||= &{};
        $first = 1;
        $col = &q,p{
            p ||= {};
            p.i ||= q ? q.i+1 : 0;
            $pa = p.pa || d.path[p.i];
            !pa and throw "No pattern!: "+p.i
            # Pmodding new pa for multiplying laters will change pa,
            #  to create space to hold values insisted in pa.v
            #  but later path must keep this multiplicity,
            #   so eg pa.word which does pa.v = C pa.v 1,
            #    doesn't happen again, when pa.v is not string
            # < pa.v should be on the path-happening part (p)
            pa != d.path[p.i] and d.pamultiplies = 1
            else
            d.pamultiplies and pa = p.pa = ex({},p.pa)
            
            
            if (pa.relative) {
                # relative spacers use the t+cv (space) of their param
                # < are likely to not replace?
                pa.vorig = pa.v;
                # < we could assume it's lvish + delete etc through here?
                #     and fraction ranges, via .y.in/out points instead
                #   .spacer wants to alienate the from C,
                #   but .relative assumes the C is already
                #   alien and for this operation?
                if (io.isC(pa.v)) {
                    pa.v = G&Cye,[pa.v.t,1];
                }
                else {
                    if (typeof pa.v == 'string') {
                        # < something@4, stuff>3
                        !pa.sark and throw "!isC !sark relative string pav",pa,pa.v
                        pa.v = G&Cye,[pa.v,1];
                    }
                    else {
                        throw "!isC relative pav",pa,pa.v
                    }
                }
            }
            if (pa.word) {
                # not expecting the word to be called another word,
                # see case of pa.v string in relative
                if (pa.v != null) {
                    typeof pa.v == 'string' and // word(s) called another name
                    else {
                        throw "word with pa.v, not string",pa
                    }
                }
                else {
                    pa.v = pa.t;
                }
                pa.v = G&Cye,[pa.v,1];
            }
            
            if (pa.doof) { # not a real step
                # lastfuncs at beginning of path
                #  - happen just before this io returns
                # firstfuncs at end of path
                #  - happen before we started, are now d.plumb
                # transparent?
                p.found = ['adoof'];
            }
            else
            if (first) {
                first = 0;
                !pa.v and debugger; #throw "nofirst"
                
                h.first(d,p,pa);
                p.found ||= [pa.v];
            }
            else {
                p.up = q;
                
                if (!q.found.length) {
                    # dont bother looking anywhere?
                    p.found = [];
                }
                else {
                    #c what matters
                    # onward
                    !p.row and throw "Nowhere"
                    $s = p.row.slice(-1)[0]; # or p.i?
                    !s and debugger; throw "doing empty"
                    
                    # what should be:
                    $v = pa.v;

                    # to the bits
                    $D = {asa:'tv',d:d,p:p,pa:pa};
                    # to diversify...
                    pa.spacer and D.spacer = 1;
                    # ** is a type of glob but gets plumbed in
                    # < i $h/*/something # just use many i/o
                    pa.glob && d.is != 'i' and D.meta = ['*','*']
                    else
                    pa.sark and // should have been figured by now?
                    # cos we want to input each thing via pa.v...
                    else
                    !v and debugger; #throw "null pav?"
                    
                    # make more rows
                    h.found(d,p,pa,s,D,v);
                    
                    if (pa.delete) {
                        each i,x p.found {
                            if (pa.delete == 'in') {
                                io.deindex(x);
                            }
                            else if(pa.delete == 'out') {
                                io.unlink(s,x);
                            }
                            else {
                                throw "delete mode "+pa.delete
                            }
                        }
                    }
                }
            }
            
            #c middle - multiply row into here
            # adds column + may multiply rows
            
            if (!p.row) {
                # starts - rows = [[r]]
                !p.found and throw "no row or found"
                p.rows = p.found.map(&s{ return [s] });
                p.nz = p.found.slice();
            }
            else
            if (!p.found.length) {
                # empty - full of null
                p.row.push(null);
                p.rows = [p.row];
                # p.nz shapely enough to nothing when nothing
            }
            else {
                # new column of many - 
                if (pa.gref) {
                    # usually filtering what glob found
                    # < expanding foam
                    # pa.gref is the talk
                    # pa.grefpara[i] param names/pa.t
                    # pa.grefparam[i] values to bind
                    p.found = io.gref(p.found,pa.gref,pa.grefparam,pa.grefd);
                }
                
                if (pa.wander) {
                    # grep found directions, keep wandering
                    if (pa.wanderer) {
                        $name = pa.wanderer;
                        name == '1' and name = null
                        $da = pa.hijacks;
                        $cb;
                        if (da) {
                            !da.hijacked and throw "hijacks not hijacked",pa,da
                            cb = da.v;
                        }
                        else
                        name && io[name] and cb = io[name];
                        else {
                            throw "what wanderer?",pa
                        }
                        typeof cb != 'function' and throw "wanderer cb not function",pa,da
                        
                        # < might it want them all/a bunch? width first eventually
                        # < B cursors, so we can find everything...
                        #   chrome debugger itself does alright finding things
                        
                        p.found = p.found.filter(&s{
                            $r = cb(A,s,G,T,d);
                            r and return 1
                            # to show the limit of the search
                            # the edge of the d of light
                            (p.uninteresting ||= []).push(s);
                            return 1
                            # or not show it:
                            return 0
                        });
                    }
                    if (p.found.length) {
                        # stretch path
                        $na = d.path[p.i+1];
                        if (!na || !na.wander) {
                            na = ex({},pa);
                            na.wandering = pa.wandering || pa;
                            d.path.splice(p.i+1,0,na);
                        }
                    }
                    else {
                        p.found.push(null)
                    }
                }
                
                # duplicate this row out
                p.rows = p.found.map(&s,i{
                    ro = p.row.slice();
                    ro.push(s);
                    return ro
                });
                # q.nz absorbs inners after loop
                p.nz = p.found.slice();
            }
            # rows grow to the right
            # < go width first? ps&z
            !d.path[p.i+1] and return p
            
            #c end - an expanding map
            $rows = [];
            each i,row p.rows {
                # our next bit of path
                $b = {};
                b.i ||= p.i+1;
                b.row = row;
                $pa = b.pa = d.path[b.i];
                
                # can go down a path in multiple directions
                $P = [b];
                h.Pmod and P = h.Pmod(d,p,P,pa)
                pa.Pmod and P = pa.Pmod(d,p,P,pa)
                
                each ib P {
                    # protection from going in circles (esp if pa.wander)
                    $s = b.row.slice(-1)[0];
                    $si = b.row.indexOf(s);
                    # < do this ^ for every atom (and then what?)
                    #   A:o (p for prototype) is all about much webbing
                    # short term solution, finish a row when it duplicates an object
                    if (typeof s == 'object' && si >= 0 && b.row.length-1 > si) {
                        # < only if the path .wanders before now?
                        # thing stated in row only twice
                        # kind of thing you'd T when it starts happening
                        d.loops ||= [];
                        d.loops.indexOf(s) < 0 and d.loops.push(s)
                        b.row.push(null);
                        rows.push(b.row);
                        continue
                    }
                    if (p.uninteresting // to pa.wanderer
                        && p.uninteresting.indexOf(s) >= 0) {
                        # after stating them once?
                        b.row.push(null);
                        rows.push(b.row);
                        continue
                    }
                    # go
                    $b = col(p,b);
                    (p.pond ||= []).push(b);

                    if (b.nz) {
                        # ...s... -> ...s, [s's many]...
                        $s = b.row.slice(-1)[0];
                        $i = p.nz.indexOf(s);
                        i < 0 and throw "manying row[-1] not in p.nz", s, p.nz
                        p.nz.splice(i+1,0,b.nz);
                    }

                    $r = b.rows;
                    !r and throw "rowing nothing"
                    # keeps pushing null once lost
                    !r.length and debugger; #throw "not one row"
                    r.map(&ro{ rows.push(ro) })
                }
                # no more recursion at end of wander in
                if (!P.length) {
                    pa.wander and rows.push(row)
                    else {
                        #debugger;
                    }
                }
            }
            p.rows = rows;
            
            return p
        };
        $p = d.p = col();
        d.rows = p.rows;
        T.o = d;
        
        # find any lastfuncs
        $i = 0;
        $lastfuncs = [];
        while (d.path[i]) {
            $pa = d.path[i];
            # < support for mid-path doofing
            #   could decide what to put after finding options for where
            !pa.doof and break
            lastfuncs.push(pa)
            i++;
        }
        if (lastfuncs.length) {
            lastfuncs.reverse();
            each i,pa lastfuncs {
                # new iterator replaces old
                T.o = io.doof(d,T.o,pa)
            }
        }
        
        #c ps
        # ay separation?
        # ays&$arky = [grep{s} whole column]
        $ay = T.o;
        io.realise(ay);
        ay.sc ||= {};
        # sc is a stage, it gets set in many ways
        # [] in sc implies it's all stuff you should know
        # and usually the howness it is is sleeping (z)
        each ik ay.arky {
            ay.sc[k] and throw "have something ay.sc."+k, d
        }
        each i,row ay.rows {
            each ik ay.arky {
                $pa = ay.path[i];
                # < sure?
                pa.doof and continue;
                if (pa.wandering) {
                    # nonfirst .wander globs are .wandering = the first
                    # the last should be empty, path exhausts things
                    # < spacetime limit while going wide will confuse this
                    # how much and what is implied by the k:
                    if (1 || k[0] < 'm') {
                        # easiest one to do already
                        # < last not entirely null column
                        pa = ay.path[--i];
                    }
                    else
                    if (k == 's' || k == 'S') {
                        # < gather (unique|all) objects
                        # art making
                    }
                    else {
                        # < last not null cell on each row
                    }
                }
                !row[i] and continue
                $N = ay.sc[k] ||= [];
                N.slice(-1)[0] == row[i] and continue
                N.push(row[i])
            }
        }
        
        #   < and eat arrays as params as many somethings it could match?
        #     in a way that generates lots of permutations!
        #   so d would be an A:o, c.stroke: scarkyN
        #   a way to present foamy marks
        # < higher order stylehouse
        return ay
    };
    
    #c realise
    # but first, name columns:
    io.realise = &t{
        # name columns [i: name]
        # < row/column accessors
        t.arks = [];
        each i,pa t.path {
            pa.ark and t.arks[i] = pa.ark;
        }
        
        t.arky = t.arks.slice();
        # add anything else we can name but wasn't asked for
        t.nonarks = []; # arky !arks
        $globs = 0;
        each i,pa t.path {
            !pa.t and continue
            t.arky[pa.t] || pa.ark and continue
            pa.glob and globs = i; # will never be 0, as i * implies i A.r/*
            pa.t.match(/\W/) and continue
            t.arky.indexOf(pa.t) >= 0 and continue
            t.arky[i] = pa.t;
            t.nonarks[i] = pa.t;
        }
        
        # < Babz S io must know this (** -> s)
        if (globs) {
            # may have a wasn't-asked-for name and s
            $pa = t.path[globs];
            if (!pa.ark && t.arky.indexOf('s') < 0) {
                # see io.rowing/ps for more...
                pa.wandering && t.path[globs-1] == pa.wandering and globs--
                t.arky[globs] =
                t.nonarks[globs] = 's';
            }
        }
        if (!t.arky.length) {
            $i = t.path.length;
            while (t.path[--i]) {
                $pa = t.path[i];
                pa.doof and continue;
                break
            }
            # even an io of one doof must have some path from data chewed on
            !t.path[i] and throw "ran out of path looking for reals"
            t.arky[i] =
            t.nonarks[i] = 's';
        }
        
        !t.arks.length and t.ungrouped = 'noarks'
        # edge case: implicit thing should cede 'r' to ark
        #   else it is counted early
    };
    #c nz $d/$ay -> $t so t.more()
    # converts d.rows to iteration or whatever
    io.nz = &d{
        d ||= T.o;
        !d and throw "Can't find T.o"
        # takes over from o
        $t = ex({},d);
        
        # gets names
        !t.arky && io.realise(t);
        
        # iterate per row
        t.i = null;
        $pull = &{
            $row;
            while (1) {
                # t.i -> i starts null -> 0, then 0 -> 1, 1 -> 2
                $i = t.i == null ? 0 : t.i+1;
                row = t.rows[i];
                !row and return
                t.i = i;
                # only for complete rows
                # < knowing pa.wander will stretch, use second to last?
                # < way to talk partiality
                !t.partial && row.slice(-1)[0] == null and continue
                break
            }
            return row
        };
        # grouping by arks, after which implied names ar[k]=[v+]
        # < naming stuff with arks, not grouping with them
        # < to ungrouped, partial, nz(), regroup, grep/map row/column/objects, 
        #     in one, ay.nz(3,&arks,_,nonarks{})?
        $parkar = &roundagain{
            $ar = t.next; delete t.next;
            # position save/load around grouping ahead
            if (ar) {
                t.i = t.next_i; delete t.next_i;
                t.row = t.next_row; delete t.next_row;
            }
            else {
                t.row = pull();
                !t.row and return
                ar = {};
                each ik t.arky {
                    # < mess by choosing first column with given k?
                    ar[k] ||= t.row[i];
                }
            }
            $ti = t.i;
            $trow = t.row;
            if (!t.ungrouped && !roundagain) {
                # to group by, make sure enough of it changes
                # i #Con:/@#G:/@W o $mag/*:G/*:W
                # should iter for every Con and G
                #  with W=[W+] read ahead
                $be;
                $first = 1;
                $groupstarts = Object.keys(t.arks)[0];
                $accumulate = &{
                    # d.path before the grouped stuff will never > 1
                    #   unless rows converged on one thing
                    #     with the same state, etc
                    each ik t.nonarks {
                        if (i < groupstarts) {
                            be && be[k] != ar[k] and throw "nonsimilar fore-grouped",k,be[k],ar[k],t
                            continue
                        }
                        first and ar[k] = [ar[k]]
                        be and ar[k].push(be[k]);
                    }
                };
                while (1) {
                    # get next one...
                    be = parkar(1);
                    !be and break
                    $diff = 0;
                    each ik t.arks {
                        # if arked things change
                        be[k] != ar[k] and diff = 1
                    }
                    if (diff) {
                        t.next_i = t.i;
                        t.next_row = t.row;
                        t.next = be;
                        be = null;
                        break
                    }
                    accumulate();
                    first = 0
                }
                first and accumulate();
            }
            t.i = ti;
            t.row = trow;
            return ar
        };
        #
        t.more = &{
            #A.debug and debugger;
            $ar = parkar();
            !ar and return
            # hash of values
            t.ar and t.prev = t.ar
            t.ar = ar;
            #t.oned and return ar[t.oned]
            t.sc = t.ar;
            return t;
        };
        #c ind: callback per item, flat list with depth...
        t.ind = &cb{
            t.indstr ||= '  ';
            $la = [];
            $N = [];
            each i,row t.rows {
                t.row = row;
                # only for parents with children
                !t.partial && t.row.slice(-1)[0] == null and continue
                $unreal_depth = 0;
                each dv row {
                    v == null and continue
                    $pa = t.path[d];
                    pa.doof and unreal_depth++; continue
                    # same as last row, still at depth
                    la[d] == v and continue
                    # < t.d should probably be as row/path i...
                    t.d = d;
                    $s = cb(v,t);
                    s == null and continue;
                    if (typeof s == 'string') {
                        $ind = '';
                        each id,v row {
                            id == d-unreal_depth and break
                            ind += t.indstr
                        }
                        s = ind+s
                    }
                    N.push(s);
                }
                la = row;
            }
            return N
        }
        
        return t;
    };
    
    
    #c forS  
    io.forS = &talk,params,T{
        $ng = 1s&forSing ||= {};
        ng.talk && talk != ng.talk and delete ng.t;
        ng.talk = talk;
        A.deSug and debugger;
        if (!ng.t) {
            $d = io.parsetalk(talk,params);
            !d.is and throw "No d.is"
            d = io[d.is](d,params);
            ng.t = io.nz(d);
        }
        $t = ng.t;
        T.ransact = t;
        t.in_progress and return t
        return t.more()
    };
    #c gref
    # < closer to FactorEase
    # < d should be C whose c&s is talk, s&r N...
    io.gref = &N,talk,params,d{
        if (d && d.path) {
            d.talk = talk;
        }
        else {
            d ||= {};
            debugger;
            io.parsegref(talk,params,d);
            d.talk = talk;
        }
        !d.talk and throw "no dtalk"
        !d.path and debugger;
        
        # bind params
        each i,pa d.path {
            !params.length and throw "gref not enough params "+ki(pa)
            pa.isparam and pa.v = params.shift();
            pa.word and pa.v = pa.t;
        }
        params.length and throw "gref Too many params", params
        if (d.not) {
            delete d.not;
            d.path.map(&pa{ delete pa.v });
            return d
        }
        
        # to filter/expand thus
        $reason;
        $M = [];
        each i,n N {
            $f = {}; # ABCDE
            $fail = &t{
                reason = t;
                fail = 0;
                break;
            };
            each i,pa d.path {
                if (pa.cel) {
                    !typeof n == 'object' and throw "cel nk/gk on nonobject", n
                    $S = n[pa.nk];
                    S != null && pa.gk != null and S = S[pa.gk];
                    f.E = S;
                }
                if (pa.word) {
                    f.E = pa.v;
                }
                if (pa.op) {
                    f.D = pa;
                    # A remains
                }
                if (hak(f,'E')) {
                    if (f.A) {
                        if (f.C) {
                            # try and be complete statement
                        
                        }
                    }
                    else {
                        # make up f.A
                        !f.E and fail();
                        f.A = f.E;
                    }
                }
                delete f.E;
            }
            M.push(n)
            fail == 0 and debugger;
        }
        return M
    };
    io.parsegref = &talk,params,d{
        d.path = [];
        parse = talk;
        $i = 20;
        while (1) {
            i-- < 1 and throw "out of i"
            $was = parse;
            $pa = {};
            $dpa = &isparam{
                isparam and pa.isparam = 1;
                debugger;
                d.path.push(pa);
                pa = {};
            };
            if (p(/^(?:(\w+)&)(\w+)/) ||
            p(/^(?:C\.(\w+)\.)(\w+)/)) {
                pa.cel = [m[0],m[1]]; dpa()
            }
            p(/^>/) and pa.op = 'gt'; dpa();
            p(/^</) and pa.op = 'lt'; dpa();
            # Babz should $1s&choo -> $choo by now
            p(/^\$(\w[\[\]\.\w]+)/) and pa.t = m[0]; dpa(1);
            p(/^(\w+)$/) and pa.t = m[0]; pa.word = 1;
            was == parse || parse == '' and break
        }
        each i,pa d.path {
            if (pa.cel) {
                $nk = pa.cel[0];
                nk == 's' and nk == 'sc';
                $gk = pa.cel[1];
                gk == 't' && !nk and gk = null; nk = 't';
                pa.nk = nk;
                !nk and throw "no read nk/gk "+ki(pa)
                gk != null and pa.gk = gk;
            }
        }
        return d
    };
    #c io
    # modes of rowing awareness
    
    # i: somewhere someway somestuff
    # the dot of the i is somestuff, index the space, trunk way etc.
    # shall we use a talky Babz'd params-implied-by-$ thing? yes
    io.i = &talk,params,d{
        # talk: 
        #   'universal keyworded-by $thing'
        # the only universal available is A.r,
        #   if your first thing is a spacer
        # the only keyworded-by is /,
        #   means inside, by tv or so
        # find these things... barewords we have around?
        # usually a J universal like N,M,1,9, etc.
        # and somethinging to it:
        # talk='N $by', param=[$by]
        #   N means 3's A:n's r's cM, # caveful of atoms
        #      or M 1's A:n's r's cM  # just the people around you
        # < should kinda m:N $by,
        #   but with the o kind of universal awareness, not A:n
        # but simply as possible:
        # - make sure this is so!
        # as opposed to o:
        # o how is this?
        
        # < wandery globs, must grow rows, path?
        #     see separation + invent the talk for
        # < sometimes (to doof many times in one row)
        #   need a cell that corresponds to many other cells,
        #   but not much
        
        return io.rowing(talk,params,d,{
            found: &d,p,pa,s,D,v{
                # what should be
                # space to it gets filled in with hash
                # and when should existing objects be replaced,
                #   but indexes etc copied to the new one?
                #   upstream changes joining local modulation
                #   seems like s's buzz.
                
                # < input null to delete?
                p.found = [io.input(s,D,v)]
            },
            is: 'i',
        })
    };
    
    
    # o sketches use for A:o:
    # o gets you what you wanted from an intelligised pile
    #   midsection of o is the midsection of n
    #  S titles can use this to define iterators
    # operation of returning results from traversal,
    #   or advancing the A:o of the C, as in dome calmness check
    
    # o may ventually look like n,
    #   and n may eventually have blockquotes hanging on after it,
    #   even T things, grabbing whatever on/over/into Aing thereinout
    
    # hmmm. music collection will be lived by o,
    # QMS would be in a quarantine
    

    # there must be more
    # the o d will be... more infinite
    #   particularly grep/sort/map
    #  tal being apply
    # lingo shape glue session
    io.o = &talk,params,d{
        return io.rowing(talk,params,d,{
            found: &d,p,pa,s,D,v{
                # 6, only the last column
                p.found = io.output(s,D,v);
            },
            is: 'o',
        })
    };
    #c input see,
    # fills in an index with a value
    # total definition of z/tv indexes, which should be one of a few...
    # along with the z/tv positioning system, there's an element of
    #   wiring or linked lists via y&in, y&up, y&next, y&prev,
    #   left out for code volume
    # < index/join types should be curated nearby
    #   proto hard-coded...
    # tv:
    #    lots of C via tvs can hold anything, just stretched out.
    #      maybe if you're database you want to know things.
    #    < in exact mode should keep z sorted,  overwrite tv
    #    < in soft mode should not overwrite (el=1)
    #      throwing input from various sources into various light
    #      to model contended content
    #    
    # non-tv index/join types:
    #    I: could be known to be of/ov/t/cv?
    #    x/y/z: what's in space...
    #    beliefs in cv like subnets, having octaves of octaves,
    #      non-linear spaces, klein bottle public netspace
    #      lanes of stripes whipping around a torus, etc.
    #    of a drawing made
    #    of an id dealt by indexOf(s)
    # 
    # s = data
    # d = [pa,th], puts at that path
    # d = {path:[pa,th],dup:&s{}}
    # does a single weld, usually C-C
    # carbon joint, some language in each place?
    # ignores the next/last/in/up wiring, let o do once sorted
    #   when it gives a kind of gravity,
    #   linearity to the stage that may not ever be there
    io.input = &s,d,v{
        d = io.knowing(d,v);
        # return d here to extract what we know, kind of 2
        
        # now 3 deals with what really shall be and how we shall create it
        
        # climb container different? may A?
        # section of o, defined into several places... houses
        # this is the most high speed bit, copying bunches of C,
        # with a little lingeme sensitivity loaded in on the d,
        # which is a lunk for A, C, T rivering the reverberate of revision
        
        # climb index
        # d.ours ['nk','gk'], gets to the thing at the end of this thing
        # +
        # d.path ['Winning','0.1'] points of index, to the value
        # not the same d.path (or d) of i/o, is a lower level, manyer
        $path = (d.our||[]).slice();
        d.path and d.path.map(&p{ path.push(p) });
        
        $S = s;
        each ip path {
            i *= 1;
            $x = S[p];
            x && typeof x != 'object' and throw "index broken"
            # the last bit of our space: the universal
            #   could be something trascendant
            #   like being a thing with hooks, more our until path...
            d.our && i == d.our.length-1 and d.on_our = x
            # done, leave S on second to last thing
            i+1 == path.length and continue
            # hash usual
            x == null and x = S[p] = {}
            S = x;
        }
        
        # S[p] may now = x
        # S[p] soon will = v
        if (d.t == 'z') {
            # or include it
            x == null and x = S[p] = d.zefault || [];
            x.constructor != Array and throw "z broken"
            #$xi = x.indexOf(v);
            # exact object ^, also could be claiming a tv had already (up at tv)
            # we shall start simply adding on, mentioning things more than once, etc
            # no information lost!
            # except the time of day, which is easy to find
            # dups constitute weirdness that should be cleaned up...
            #   before the system with it in goes production
            # < z_dup: handled on the o end, as z things not in tv, and tv_dup
            x.push(v);
        }
        else {
            # set thing to thing
            if (x != null) {
                # already, noop?
                d.spacer || x == v and return x
                d.dup && d.dup(d,x,v) and return x
            }
            S[p] = v;
        }
        
        # multiple angles of have
        if (d.also) {
            each in d.also {
                typeof n == 'string' and io.input(s,n,v)
                else {
                    throw "What else", n
                }
            }
        }
        return v
    };
    
    #c output
    io.output = &s,d,v{
        d = io.knowing(d,v);
        # path =
        #   our  - reaches from thing to its universal (nk,gk)
        # + path - into index (t,cv)
        # not the same d.path (or d) of i/o
        #   is a lower level, manyer
        # meta applies to non-our path only.
        $path = (d.our || []).slice();
        $mi = path.length;
        d.path and d.path.map(&p{ path.push(p) });
        
        # we only need to capture the endmost atoms at this low level
        # < rows is S in input... could insert multiple times if crazy
        d.rows = [[s]]; 
        # flow
        $i = 0;
        while (path[i]) {
            $k = path[i];
            $pm = i >= mi && d.meta && d.meta[i-mi];
            $rows = [];
            each ri,row d.rows {
                $S = row.slice(-1)[0];
                if (0 && i == mi && S == null && s.sc && ss&z) {
                    d.our.join('') != 'ytv' and throw "have ss&z, null our thing, but what is dour?", d.our.join('')
                    # we got to y.tv, but it seems to use z instead
                    # A:o used to mix all attachment methods together...
                    # suppose this is fine:
                    $tv = s.y.tv = {};
                    each in ss&z {
                        tv[n.t] ||= {};
                        tv[n.t][n.y.cv] = n;
                    }
                    S = tv;
                }
                if (S == null) {
                    row.push(null);
                    rows.push(row);
                    i++;
                    continue
                }
                $ks;
                if (pm) { # loose match, may many
                    # use z order? grep by tv?
                    # in the order they were set
                    pm == '*' and ks = Object.keys(S)
                    else {
                        # for WHERE k=v to be k>5, k~re
                        throw "meta",pm
                    }
                }
                else { # exactly what path[i] says
                    # but when to cast it first? never I spose.
                    $ok = typeof k == 'string'
                        || typeof k == 'number';
                    !ok and debugger
                    !ok and throw "nonstringstep"
                    ks = [k];
                }
                # < to sort, know fractional cv,
                #   with freaks, histograms, history
                # < if !x we could try as if 1=='',
                #   misspellings, round until found,
                #   using z a sorted z to scope up a cv faster...
                #   even resurrecting a J that looks similar
                each ik,k ks {
                    $x = S[k];
                    # extend row
                    $ro = row.slice();
                    ro.push(x);
                    rows.push(ro);
                }
            }
            d.rows = rows;
            # and add column:
            i++;
        }
        # take off columns not in the formula (A.r)
        
        $last_column = d.rows
            .map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });
        return last_column
    };
    
    #c misc lowlevelations
    # < finish, for tv/tw/z etc as well
    io.reindex = &s,d{ 
        d.glob = 1; # so .path shows its geometry
        d = io.knowing(d);
        
        $starts = d.our.length-1;
        $reindex = &s,i{
            if (i <= starts) {
                $p = d.our[i];
                !s[p] and return
                i < starts and reindex(s[p],i+1)
                else {
                    
                }
            }
            else {
                
                each k,v s {
                    d.path[i+1] and reindex(v,i+1);
                }
            }
        };
    };
    # rehashes tv
    io.reindex = &s{
        !s.y.tv and return
        $tv = {};
        each t,cv,v s.y.tv {
            tv[t] ||= {};
            tv[t][cv] = v;
        }}
        s.y.tv = tv;
    };
    # blanks tv
    io.deindex = &s{
        $was = s.y.tv;
        delete s.y.tv;
        return was
    };
    # removes from tv
    io.unlink = &s,x{
        $tv = s.y.tv;
        !tv and return
        !tv[x.t] and return
        delete tv[x.t][x.y.cv];
        if (Object.keys(tv[x.t]).length == 0) {
            delete tv[x.t];
            Object.keys(tv).length == 0 and delete s.y.tv;
        }
        # if unfound, check s&z.indexOf(x), which may indicate t/cv change
        #   suppose then look for x in tv[x.t], then all of tv
        # things should be isolated, change their names with el
        # so 4
    };
    #c knowables
    io.knowing = &d,v{
        # a subtype, reenters at the end:
        $p = d.p || {};
        d.asa and $other = d; d = other.asa;
        # types
        d == 'tv' and d = {t:d,our:['y','tv'],usu:1};
        d == 'tw' and d = {t:d,our:['y','tw'],usu:1}
        d == 'z' and d = {t:d,our:['sc','z']}
        # sheer bunch of keys
        d.constructor == Array and d = {path:d,usu:1}
        typeof d == 'string' and throw "intelligise", d, other
        
        other and ex(d,other)
        # glob tv wants to make some path
        !v and d.glob = 1; v = {t:'*',y:{cv:'*'}};
        !d.glob && !io.isC(v) and debugger;
        d.t == 'tv' and d.path ||= [v.t,v.y.cv]
        d.t == 'tw' and d.path ||= [v.t]
        
        # apply the usual behaviour:
        #  - when duplicate, overwrite
        #    if tv, overwritings become linked lists
        if (d.usu) {
            if (d.t == 'tv') {
                # when not debugging:
                #d.also ||= ['tw','z']
            }
            d.dup = io.usu_dup;
        }
        return d
    };
    # this should be available as around or after method call..
    # or "the usual" that the actual d.dup works with or without
    io.usu_dup = &d,x,v{
                # can link duped things, new thing gets v.y.$to
                # as in, newthing.y.earlier = oldthing
                $from;
                $to;
                # make similar index to z to hold dupes, in order
                # as s&z grep !in tv might reveal
                $dupz;
                
                # revision of an item
                d.t == 'tv' and from = 'later'; to = 'earlier'; dupz = 1;
                # revision of name, moving through items
                d.t == 'tw' and from = 'begins'; to = 'continues'; dupz = 1;
                # < first relative thing keeps its position in tw
                # < check new/old position in z, to inform who takes tw
                #   hmmm, a flappy edge to the arrangement
                # stuff moves through words
                # these schema should be drawn out
                # become keywords to io
                # io will just work
                
                if (from || to) {
                    # which way is it going: new val stays, new val joins the queue
                    $backwards = from && x.y[from] || d.keep_first; #]
                    if (backwards) {
                        !from and throw "can't go backwards with no from?"
                        # ^ unless use in telling things that missed the spot who beat them
                        !d.keep_first and throw "protocol changed"
                        # we could -1 y&dup_tv index maybe?
                        # or add y&most_$from to the end of the linked list
                        # this should magnify into a huge democratic space for ...
                        # space for 'space for ...'
                        # or follow links:
                        $X = x;
                        # < all while loops should have some limit, spec learned
                        #   badge earned. all code is is bestowment.
                        $i = 100;
                        while (X.y[from]) {
                            i-- < 4 and throw "ixhaust"
                            X = X.y[from];
                        }
                        # now last in the trail:
                        X.y[from] = v;
                        to and v.y[to] = X;
                        # so tv stays something, but .y.later = v extends forever
                    }
                    else {
                        from and x.y[from] = v;
                        to and v.y[to] = x;
                        # now tv sets us.
                    }
                }
                
                # make tv_dup, index as tv but to [] of items at the point
                # the minter will care about such things, T clutter, minor errors, noise
                if (dupz) {
                    !d.our and throw "housing not given"
                    $p = {t:'z'};
                    p.our = d.our.slice();
                    $gk = p.our.pop();
                    p.our.push(gk+'_dup');
                    p.path = d.path.slice();
                    # dup should include the one already there
                    p.zefault = [x];
                    io.input(s,p,v);
                }
                
                d.keep_first and return 1
                # but we (as eg tv) shall go on to tw and z even dups
                # no information lost!
    };
    A&io = io;
    return io
    
t/iooia: |
    G&heading;
    $io = G&way,'iooia';
    G&way,'Doming',ar;
    
    $a = &t,talk,cetia,c{
        $params =
        cetia ?
            typeof cetia == 'object' ? cetia
            : cetia.split(' ')
              .map(&s{ return G&Cye,[s] })
        : [];
        
        $what = talk+(cetia ? " <--- "+ki(cetia) : '');
        m $t  $s:what %hue:200deg,dis:block
        
        $d = {};
        $r = io[t](talk,params,d);
        
        if (c) {
            # more awareness
            (c == 1 || c.show) &&
                m d_of_"+t+"  $s:d
        }
        $thing = t == 'parsetalk' ? r : r.sc;
        $n =
        m $t  $s:thing,dl:7.22
        typeof c == 'object' and ex(n.c,c)
        return r
    };
    
    S 1 respec-talk
    a('parsetalk','w/*:w');
    a('parsetalk','trouble/w:r/#w:t','weeee',1);
    a('parsetalk','$t o $w/*','tea weas');
    # from the story of -respec:
    # o w/*:w
    # if problem with $w:
    #   i trouble/w:r/#w:t
    #   ts&dige = supposedtobe
    #   i $t o $w/*
    
    S 2 respec
    A.r = G&Cye,['iooia',9,{M:[]}];
    $now = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','weeee');
    
    $aw = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','walso');
    
    $aw = a('o','w/*:w');
    
    $ay =
    a('i','trouble/w:r/#w:t','sweeee',1);
    $w = ays&t[0];
    ws&plat = 5;
    $aw = a('o','w/*');
    # too far
    $aw = a('o','w/*/*',0,1);
    $aw = a('o','trouble/w/*',0,1);
    
    $aw = a('o','*',0,{show:1,dl:5});
    
    
    $aw = a('o','*/*',0,{show:1,dl:5});
    
    
    #a('i','w:r/#w:t','well');
    #a('i','$t o $w/*','tea weas');
    
    
    S 3 i/o
    
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    $o = G&Cye,['blag','2',{s:'gakel'}];
    n attaching_to -fod $s:d,dl:14
    
    $N = io.i('$d/$o',[d,o]);
    $oN = io.o('$d/*',[d]);
    m enN -fod $s:N,dl:14
    m ouN -fod $s:oN,dl:14
    
    
    #c iteration
    S 4 iteration
    n ble 8 s:iteration %fs:600%,dis:block
    # so 'i $t' tv's each 'o $w/*:W', like 'i $t $W'+
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    'doofica latico matri vou'.split(' ').map(&s{
        $o = G&Cye,[s,'1'];
        i $d/$o
    });
    a('o','$d/*',[d],1);
    
    a('o','$d',[d],1);
    #$r =
    o $d/*:r
    
    $matri = G&Cye,['matri',1,{morematch:2}];
    
    $maN = a('o','$d/#matri',[d,matri]);
    
    $ma = maNs&matri[0];
    mas&cla = 'osi';
    
    $vong = G&Cye,['Viog',34];
    i $ma/$vong
    
    a('o','$d/*/*',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar.sc,dl:5
    }
    m iterator  $s:t,d:8.22 %fs:120%
    
    i $ma/#vong
    v = ays&vong[0];
    vs&latjkc = 42;
    a('o','$d/*:dui/*:s',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar.sc,dl:5
    }
    m anotherator  $s:t,d:8.22 %fs:120%
    
    # reuse this pile of C
    1s&sandy = d;
    
    #c Monday
    =Monday' for all of them together:
    
      nz - nz=[(C,nz?)*]
        array-indented C, as a format to build like d.rows
        just like the idea, no immediate use.
        why make data look more like indented Lines?
        mere exercise
      
      io.nz - convert it to whatever,
          see iteration
    
      plumb:
        join an i from an o
      Functions:
        also:
            i $d/@whur/@lamb { s&fat && "laughter" }:whur o $lambs/*
        which:
          greps (by default?) and assigns value to whur
            which becomes a bareword to the i
          deciding where lambs go
          should have \ at end of line to continue expression...
        if no :arks in an i, uses last column,
        
        
        on-name symbols:
      <  -name delete!
         @name referring to other name, from func or plumbing
         #name just t/cv of v, which is doesn`t have to be set to
         $name is a var parameterised into the call
      
       inbetween bits:
         { code code code }:name
           Babz auto return in sub`s last line
         becomes column
         greps if not named or named grep
         
         y
           cloning the C as it moves over
           forget about using its .y.tv tho, see perspective
         yC,o
           means cloned.y.C = origin, origin.y.o = cloned
           and these have some knownness,
           should always be able to go C-ward?
         y.
           cloning C but disconnecting them from things we dont take with us
         
      perspective:
          as we i ... y o ...
          clones C as they pass into the i
          everything selected will need repointing to itself,
            as A:o does
        < wandering off to do that
        < trimming innards (no delete)
        < the S o things iterating dome
          < o words implying o words:/*:word
          < i @lamb implying the connected o lambs/*:lamb
            by changing the sark t on the receiver? + giving it an ark
          < ark = 1 anywhere?
        
      
      future:
        knowing the protocol space to a delete is nice
        and operating work-isolatingly from a big sleeping set
      
      #c on iteration:
        basically, get an iterator object:
          $t = io.nz()
        setup from T.o, the last i/o $d
        flat map like G&ind:
          t.ind(&s,t{ [t.d,s] })   # [ [depth,C]+ ]
          t.ind(&s,t{ ki(s) })     # [indented toLinesish]
        iterate rows:
          shift each ay.sc.$k (before nz())
          t = t.more() # named columns in t.sc.$k
        see code about grouping nonarks as arrays
        
        while(ar=t.more()) it
        or use Duning S with io in it
          which will be most of the time!
          the new way.
          once subnetting S so Swhiles of io can
            be used instead of for, each, etc.
            and the data-picking-through excercise can compile for specifics
        the $t then the cursor, which S shall:
          take care of, and:
            Babz: set vars from ar
            S: hold the cursor while J6s exchange, see J6ing
        
        < getting the corresponding p? who cares
        
        function should be able to set the ind fu
        
      
      J6ing
        a J6 is a J attempting to do itself,
          or something to do with itself, about dome consciousness
          and s if it works, like a commit
            or works enough for an s-level wake, like a savepoint
              and s should be the total picture of the game being J`d
        a J<6 is deciding on J6,
          doing small things, like e,
          then working out desire/skip/sleep potential,
            sometimes working on only such domes,
              but such work is J6ing.
        
        but 
      
      < pipelining, a rattley flood of A:o would...
          esp if they push certainty on each other
          as welding a long seam, its only a liquid for a little stretch
          with a rolloff/on
      
      other stuff:
      < specialise #things spacer creation (with a doof)
        what about loose matches?
          low levels want to take callback/expression?
          and how to steer the search nearby,
            or use datetime to seek when it was
            or where else in the schema it might have disappeared to
            if O knows when it disappeared?
      
        p could be C or A, etc,
          is more shapely and langholdey than rows
          they offer an alternative positioning system,
            according to the new gravity cast on it.
        and turn into A:o, a self-similar data-holding foam
        p could become o@3 compatible
        
        p could become aware of what's around what they're aware of,
          and then -od, fields of data that
          can show when stuff isn't on the screen changes
        
        d has now a sc for sc[k] = v (ar) when iterating,
          and before iteration begins is ar[k] = [v+] for unique and true v
        could be some kind of A:o then.
        they will have to handle travelling between representation modes
        A:o awakening is a process of walking through A&insides, A&clones
        
        this one is sc that is like ar[k] = v 
        before iteration begins its ar[k] = [v+]
        
      < write d>o instead of i $d/$o?
         magnetics want to... ranking, raking...
         for sorting the junkdrifts of culture

         < completing this -fod now so it sees d before io
           WHILE it`s an M thing would be something
           we will often be populating a populated space,
           starting a job with half the required information
        
    =cut
    # '
    
    #c hmmm 
    S 5 strange formats
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    o $d:lish/*/*
    # < solve this... if ark is singularly defined we could return it?
    #   and if many we could return them as whole columns...
    #   and only return last column when no arking
    m lish_var -jod $s:ays&lish
    
    $t = io.nz();
    
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m inded  $s:s %hue:80deg,ws:pre,dis:block
    
    t.partial = 1;
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    
    # plumbing
    S 6 i<-o plumbing
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    
    $n = G&Cye,['upsulat','1',{s:'gakl'}];
    i $n:an o $d/*
    # i can set vars... use T.o if you unsure of 1/+ness
    $t = io.nz();
    m andasio_To  $s:T.o
    m andasio_varset  $s:ays&an
    m andasio_tmore_once  $s:t.more().sc
    m andasio_tar  $s:t.ar
    m andasio_tmore_twice  $s:t.more().sc
    
    o $n/*/*
    $t = io.nz();
    m therowsofan  $s:t.rows,dl:8.16
    
    t.partial = 1;
    $s = t.ind(&s,t{ return G&toLines,s }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 8.24;
    }
    
t/iooiata: | # func really
    G&heading;
    $io = G&way,'iooia';
    #1s&step = 2;
    G&way,'Doming',ar;
    
    $show = {};
    show.talk = 1;
    $a = &t,talk,params{
        if (t === '' && !talk) {
            m space   %fs:120%,hue:170deg,width:100%,height:3em,dis:block
            return
        }
        if (t == 'bug') {
            m bugreport  $s:talk %fs:120%,hue:170deg,dis:block
            return;
        }
        if (t == '9') {
            m speech  $s:talk %hue:100deg,dis:block
            return;
        }
        t && io[t](talk,params||[],{})
        t = io.nz();
        
        show.talk &&
        m talk  $s:t.talk %fs:130%,hue:-40deg,dis:block,float:right,mw:50%
        
        m thistest  $s:talk %fs:160%,hue:120deg,dis:block
        
        show.t &&
        m iter  $s:t,dl:9.26
        
        !show.impartial and t.partial = 1;
        $s = t.ind(&s,t{
            $text = io.isC(s) ? G&toLines,s : "GARB: "+ki(s);
            if (t.objects && t.objects.indexOf(s) >= 0) {
                # highlight t.objects (that doof matched)
                # < chucking rows with any object on matching
                # iterate objects if that's all you want
                text = G&intag:'>1 '+text
            }
            if (show.y) {
                # attach y, which hides most first
                $say = ki(s.y,6.24);
                say = say.replace(/^\{|\}$/g,'');
                text += "\t"+G&intag:'>3 '+say;
            }
            return text;
        }).join("\n");
        s += "\n";
        m inds  $s:s,ht:1 %hue:120deg,ws:pre,dis:block
        # lum for dumping state
        t.p = 'usual';
        return d
    };
    $nz = &show{
        $t = io.nz();
        t.partial = 1;
        t.ungrouped = 1;
        while (show && t.more()) {
            m apull  $s:t.sc,dl:8.26
            m srow  $s:t.row,dl:8.26
        }
        return t
    };
    a.nz = nz;
    a.show = show;
    ar.atavism and return a
    S 1 make a dee, replicate to cee
    $start = 
      "upsulat\t\ts:gakl\n"
     +"  doofica\n"
     +"  latico\n"
     +"  matri\t\t\tcla:osi\n"
     +"    Viog\t\t\tlatjkc:42\n"
     +"    Viog\t34\n"
     +"  vou\n";
    $d = 1s&dee = G&readLines,start [0];
    show.t = 1;
    a('o','$d/*/*',[d]);
    
    o { Object.keys(C.sc).length }:tings $d/*/*
    a(0,'funclast grep by sc length');
    $t = nz();
    while (t.more()) {
        m apull  $s:t.sc,dl:4
        m srow  $s:t.row,dl:6
    }
    
    o { C.t = C.t.split('').reverse().join(''); 1 }:tings yD,o $d:cee/*/*
    a(0,'funclast map tchange after separation, yD,o');
    $t = nz();
    while (t.more()) {
        1s&cee && t.sc.cee != 1s&cee and throw "cee (toplevel) irregular"
        1s&cee = t.sc.cee;
        m apull  $s:t.sc,dl:8.26
        m srow  $s:t.row,dl:8.26
    }
    
    #c 22
    S 2 change cee & see
    $o = G&Cye,['fall'];
    # < #@class bareword from non C (C.t = the string?
    #     or A:o map it in c&s and draw cartoon for C.t)
    #   making C hold weirdness
    $flav = /o/;
    $vat = &C{
        $j = C.t.match(flav);
        j and return G&Cye:["heard of "+C.t,4]
    };
    
    !1s&cee and throw "NO cee"
    #i $o/@klass/@doop va:{ va(C) }:klass 
    #A.debug = 1;
    #A.deyug = 1;
    $seen = [];
    o va:{ seen.push(C); vat(C) }:klass 1s&cee/*:va/*:doop
    a(0,'only hear of va things having o');
    $t = nz(1);
    #debugger;
    $seen = [];
    o { seen.push(C); vat(C) }:klass 1s&cee/*:va/*:doop
    a(0,'hear of things having o');
    #debugger;
    
    #debugger;
    #A.debug = 1;
    i $o/@klass/@doop va:{ vat(C) }:klass o 1s&cee/*:va/*:doop
    #A.debug = 0;
    a(0,'cant i without full path: matri:va not /o/ so no :doop');
    $t = nz();
    
    
    $o = G&Cye,['fall'];
    flav = /t/;
    i $o/@klass/@doop va:{ vat(C) }:klass o 1s&cee/*:va/*:doop
    a(0,'can i with full path, but only one doop matches...');
    # < load up all the doops?
    # > ar.klass == 1, in t.arky twice?
    $t = nz();
    #debugger;
    # < 1s&cee -> cee in talk
    
    $o = G&Cye,['fall'];
    flav = /i/;
    #A.debug = 1;
    i $o/@klass/oooo/@doop doop:{ vat(C) }:klass doop:y:doop o 1s&cee/*:va/*:doop
    a(0,'can i with full path, some separa');
    a('bug',"returns two ventures into 'heard of'"
        +" because two identical (but !=) @klasses happen, o ends up with one");
    #$t = nz();
    #A.debug = 0;
    
    # load up all the doops but returns klass/doop
    #   as well as klass/oooo/doop, looks like doing things twice
    # > ar.klass == 1, in t.arky twice?
    # < diy debug wedge, big words of code
    o $o/*/*/*:dof
    a(0,'o ends up with one pair of Viog');
    
    # lets try and circumvent that bug
    $o = G&Cye,['fall'];
    flav = /i/;
    #A.debug = 1;
    i $o/@#klass/oooo/@doop doop:{ vat(C) }:klass doop:y:doop o 1s&cee/*:va/*:doop
    a(0,'can i with full path, some separa');
    a('bug',"still branching too much... examine with tools later");
    #$t = nz();
    #A.debug = 0;
    
    # load up all the doops but returns klass/doop
    #   as well as klass/oooo/doop, looks like doing things twice
    # > ar.klass == 1, in t.arky twice?
    # < diy debug wedge, big words of code
    o $o/*/*/*:dof
    a(0,'o ends up with one pair of goiV');
    $t = nz();
    while (t.more()) {
        $dof = ts&dof;
        dofs&seen = 'overino';
    }
    
    show.y = 1;
    o $o/*/*/*
    a(0,'see o');
    o 1s&cee/*/*/*
    a(0,'see cee');
    o $o/*/*/*:dof
    a(0,'see o again');
    
    # make some more messes
    # < somewhere, someone wants to do this:
    #i $o/bolo/@ump/@dat dat:ysource,destiny zom:{ C.t.match(/oo/) }:dat zom:{ C.t.match(/al$/) }:ump o 1s&cee/*:zom
    #   needing doof to put the C in place of what match returns
    #   things unbounding, jumping through hoops, rebounding
    #  usually mean to not ark the function
    $seen = [];
    i $o/bolo/@zom ysource,destiny { seen.push(C); C.t.match(/^la/) } o 1s&cee/*:zom
    a(0,'adding ^la zom to bolo o');
    m whats  $s:ay.sc,dl:6.33
    m seenCfunc  $s:seen,dl:6.24
    #i $o/bolo/@ump/@dat { s&grabb = 1 } ysource,destiny zom:{ s&grabb = 1; C.t.match(/oo/) }:dat zom:{ C.t.match(/^la/) }:ump o 1s&cee/*:zom
    
    o $o/*/*/*:dof
    a(0,'see o again');
    o 1s&cee/*/*/*
    a(0,'see cee');
    
    1s&ooo = o;
    #c 33
    S 3 super nice
    $c = 1s&cee;
    $o = 1s&ooo;
    o $o/*:bit/*
    show.y = 1;
    a(0,'see o again');
    $t = io.nz();
    $oo = [];
    # F for stuff
    t.ind(&C,t{
        t.d <= 1 and return
        $na = C.t.match(/(o)/g);
        !na and return
        oo.push(na.slice(1))
        each in oo {
            $name = n.join('ii');
            $na = G&Cye,[name,3];
            ~>39 injecting: name
            i $C/branch/$na
        }
    });
    o $o/**
    a(0,'see o wanderingly');
    $t = io.nz();
    t.partial = 1;
    t.ungrouped = 1;
    $row;
    while (t.more()) {
        row = t.row;
        $s = row.slice(-2)[0];
        !s and debugger;
        s.t != 'Viog' and continue
        i $s/$o
        break
    }
    m looped_tarky  $s:t.arky,dl:8.24
    m looped_trow  $s:t.row,dl:8.24
    m looped_row  $s:row,dl:8.24
    
    o $o/**
    a(0,'see o wanderingly with loop');
    
    $t = io.nz();
    t.partial = 1;
    t.ungrouped = 1;
    $row;
    while (t.more()) {
        row = t.row;
        $s = row.slice(-2)[0];
        s.t != 'fall' and continue
        break
    }
    m looped_tarky  $s:t.arky,dl:8.24
    m looped_trow  $s:t.row,dl:8.24
    m looped_row  $s:row,dl:8.24
    
    #c 44
    S 4 forS ittruati
    
    $c = 1s&cee;
    $o = 1s&ooo;
    i $o/bolo/tank
    i $o/bolo/boil/river
    S flute: o $o/*:glib/*:glub/*
        glubs&direction = "Under "+glib.t;
        glubs&supports = s.map(&s{ return s.t }).join(', ');
    S
    o $o/**
    a(0,'see o has become more self aware');
    
    
    a(9,'find a @lamb amongst $lambs/*');
    
    $reggae = G&Cye,['reggae',52];
    $lambs = G&Cye,['lambunch',67];
    i $lambs/lambert
    i $lambs/laminate
    i $lambs/lucien
    S lambs: o $lambs/**
        s.t.match(/am/) and ss&fat = 1;
    S
    a(0,'the lambs');
    o $reggae/**
    a(0,'the reggae');
    $seen = [];
    $fai = &C,s{ seen.push(C) };
    # this y shall do everything
    i $reggae/@#whur/@lamb { s&ae='ce'; s&fat && "laughter" }:whur y, { fai(C,s); s&ok = 1; s.d * 3 } o $lambs/*
    #debugger;
    a(0,'the lamb move');
    
    $t = nz();
    a(9,'lamb i more');
    while (t.more()) {
        m apull  $s:t.sc,dl:8.26
        m srow  $s:t.row,dl:8.26
    }
    $t = nz(ay.plumb);
    a(9,'lamb o more');
    while (t.more()) {
        m apull  $s:t.sc,dl:8.26
        m srow  $s:t.row,dl:8.26
    }
    
    m hadseen  $s:seen,dl:6.22
    
    o $lambs/**
    a(0,'the lambs');
    o $reggae/**
    a(0,'the reggae');
    
    =pod check out ar returnings
        i $d/@whur {dehydrate:5}:whur ye,C. {notch} y o $lambs/*
        i $d/@la/@dio la:{s&i++;1} dio:y o $ohp/*:la/#loc/da/*:dio
        o { Object.keys(C.sc).length } $d/*/*
    
    =cut 

    # < nz/somethingin finds toplevels
    # < hierarchy from flat tools in io
    #     you'd be building them on top probably...
    #       but providing safe data wandering
    # < clarify how to use to gather C on C
    # 
    # check:
    # {}:ting $d/*:ting # should have 1 ting column
    # searching for @names
    
    #a('$d
    
    # needs z interpreted as tv
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 12;
    }
t/iooiatal: |
    ar.atavism = 1;
    $a = G&way,'t/iooiata',ar;
    $nz = a.nz;
    a.show.y = 1;
    $io = A&io;
    #debugger;
    S 1 eparate
    
    # test out y/y,/y-
    $eyi = 2;
    $o;
    while (eyi--) {
        o = 1s&o = G&Cye,['yop',1];
        i $o/ting/lots
        # < pa.v = [] Pmods
        $ting = 'glap sip cap bee far chua hsing halma jhon jonne comedia musico'.split(' ');
        i $o/@#$ting
        ting = ting.slice(-4);
        i $o/@#$ting/wamptch/stul
        if (eyi == 1) {
            i $o/@$ting/mmm/er
        }
        else {
            i $o/@#$ting/mmm/er
        }
        ting.pop(); ting.shift();
        i $o/@#$ting/lum/iuty/voux
        o $o/**
        a(0,'look at all those '+(eyi == 1 ? '' : 'lovely ')+'hats');
        eyi == 1 and a(9,'wamptch/stul disappeared because @$ting not @#$ting')
    }
    
    
    # nothing
    i $o/cap/@s o $o/jonne
    # just the top thing
    i $o/cap/@s y, o $o/jonne/wamptch
    # everything
    i $o/cap/@s y o $o/jonne/lum
    # without things
    i $o/cap/@s y- o $o/jonne/mmm
    
    A.debug = 0;
    i $o/cap/hasothers
    S scribble on originals: o $o/jonne:leap/*:lap/*:lop
        leaps&boogie = 3;
        laps&eel = 33;
        lops&ded = 1;
    S
    # < alternations:
    #o $o/{cap,jonne}/**
    o $o/cap/**
    a(0,'jhon entirely transported to cap, not scribbled on');
    
    $h = G&Cye,['chair',3];
    #A.debug = 1;
    i $h/** y- o $o/**
    A.debug = 0;
    a(0,'each thing alone but reconnected by being in a flood of **');
    S o $h/**
        $r = ay.row[2];
        !r and continue
        rs&lapitude = 3;
    S
    o $o/*/*/**
    a(0,'$o-riginal not scribbled on');
    o $h/*/*/**
    a(0,'chair says lapitude all over');
    o $h/*/*
    a.show.impartial = 1;
    a(0,'h-two-three');
    
    S 2 separate again
    # for clarity...
    $o = G&Cye,['yruva',1];
    i $o/glangic/tibe
    i $o/glangic/ttt/bol/ate
    i $o/glangic/ttt/bol/ais
    i $o/glangic/true
    m some_ay  $s:ay.sc
    
    o $o/**
    a(0,'see a smaller bit')
    
    i $o/not/@s o $o/glangic
    a(0,'not y');
    
    i $o/yfully/@s y o $o/glangic
    a(0,'yfully y');
    
    i $o/yshallow/@s y, o $o/glangic
    a(0,'yshallow y,');
    
    i $o/yalone/@s y- o $o/glangic
    a(0,'yalone y-');
    
    S scribble on originals: o $o/glangic:leap/*:lap/*:lop
        leaps&boogie = 3;
        laps&eel = 33;
        lops&ded = 1;
    S
    o $o/**
    a(0,'see a less small bit')
    
    
    i $o/glangic/TALIS
    i $o/glangic/true/FALS
    o $o/**
    a(0,'tv clones?')
    
    1s&ooo = o;
    # < leads neatly into deletes, for mode:y.
    #   pathy: $thing. 
    
    #c 33 compile & run
    S 3 compiletime
    $o = 1s&ooo;
    $talk = '$o/flump/@#glump glangic:{}:glump o $o/glangic';
    $params = [o,&acgts{
        return "Falling sa "+C.t
    },o];
    $d = io.i(talk,params.slice(),{not:1});
    T.o == d and throw "seemed to T.o"
    m dee_lovely  $s:d
    1s&deecom = {talk:talk,params:params,d:enj(d)};
    
    S 4 runtime
    $de = 1s&deecom;
    io.parsetalk = &{
        throw "should not parsetalk"
    };
    $ay = io.i(de.talk,de.params.slice(),dej(de.d));
    a(0,"new shoes");
    
    
    
    S 5 deletes
    $o = 1s&ooo;
    o $o/glangic/**
    a(0,'what is glangic')
    
    i $o/glangic/ttt/bol-
    a(0,'empty bol')
    i $o/glangic/-TALIS
    a(0,'delete TALIS')
    
    o $o/glangic/**
    a(0,'what is glangic after')
    
    
    
    
    S 6 iterator transactions
    $o = 1s&ooo;
    1s&la ||= [];
    #A.deSug = 1;
    S o $o/glangic/*/*:tong
        1s&la.push(tong);
        tongs&guine ||= 0;
        tongs&guine++;
        if (!1s&hazard) {
            1s&hazard = 1;
            throw "Hazard"
        }
        tongs&great = 1;
    S
    
    m see_la  $s:1s&la
    i $o/limbics/@$1s&la
    a(0,"limbicals");
    
    
    S 7 one name, any fraction
    # <
    $o = 1s&ooo;
    $gre = 'm';
    o $o/{>$gre
    a.show.t = 1;
    a(0,"t more than m");
    a.show.t = 0;
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 8.22;
    }
StayToSleep: | # gentleness scan
    # 
t/BuildACastle: | # test Duning and io
    # ones
Fly: |
    G&heading;
    G&way,'t/iooiatal',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
grow: | # spraw Js&ope qua
    # there must be a S/C/A clicky scheme attacher somewhere
    $Y = c.y.A.1;
    Ys&ope ||= 0;
    Ys&ope += e.t.includes('C') ? -1 : 1;
    ~Told: ki(Y), ki(Y.3)
pi/fod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # where was above? 2Cc&d was going to do this...
    $u = A.n.up.n.c.s;
    c&d ||= uc&d || 1;
    c&d > 1 and ys&ml = (c&d - 1)+'em'
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    $dl = c&dl || 3;
    1s&ope and dl += 1s&ope;
    
    $es = c&s;
    es = ex({},es);
    if (es.path) {
        $p = es.path;
        delete es.path;
        each in p {
            m path -fod $s:n,d:2,dl:7
        }
    }
    if (es.p) {
        $p = es.p;
        es.p = ki(p,4.22);
        c&p == 1 &&
        m psomething -fod $s:p,d:3,dl:7
        if (c&p && c&p != 1) {
            $s = p[c&p];
            m psomething -fod $s:s,d:3,dl:7
        }
    }
    if (es.plumb) {
        $p = es.plumb;
        delete es.plumb;
        m plumb -fod $s:p,d:3,dl:7
    }
    
    
    
    G&n,['Thing',3,{s:ki(es,dl)}];

