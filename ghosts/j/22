TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # 
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
iooia: | # F > i/o > input/output
    # these will all be G&F, G&o, G&i...
    
                    # round until found
    
    # other possible types of thisness:
    # - G&s for writing notes for itself
    #   using traces left by i/oing etc nearby
    #   doing crazy implicit templating
    #   throwing universal weight around
    #  also s is where situations are strategised on
    
    # F is a culture of grasping syntax on top of o
    # formula
    $F = &s,d{ return G&way,'PseudoF',{s:s,d:d} };
    
    #c parsetalk
    # parse out bits into m
    $parse;
        $m;
        $p = &r{
            m = parse.match(r);
            !m and return
            m.shift();
            parse = parse.replace(r,'');
            return 1
        };
    
    $ta = G.tiestowe = [];
    
    # compile time
    # see j/41/jababio
    # the string is basically a branch/path 
    #   params give values to columns, named with /^[$#]/
    #   params return or made available somewhere, per column, per row...
    # saving much typing!
    
    # can't really bab 1 line to many to set params
    # must return N
    #   it's what's expected? (at io (not F?))
    # and put iterator interface on T...
    #   later some way to do cursors,
    #     percolate and collaborate read-need-ness
    
    # but in an S:
    #  S can do io and then be iterating
    #  Babz setting params inside from T
    
    
    # general branch lingo
    # something for C-together
    # < making sql
    # params written as if string interpolated:
    # they create/read object or some reduced idea of an object:
    # the column will/must have/match the given param's value/identity,
    # $o - value
    # #o - looser/vaguer/processed copy of $o
    #      like spacers, with only C.t=o.t
    # word - spacer of C.t=word
    
    # < want o to find the exact object, not it's identity?
    
    # < unless it names a universal (1s&bareword) or so,
    #   then use that. inner lingosanctum.
    $parsetalk = &talk,params,d{
        d ||= {};
        parse = talk;
        # do i ... for o ...
        p(/ o (.+)$/) and d.fromo = m[0]
        # absorb the o lop ^
        talk = parse; 
        
        # Babz shall do params, see 'compile time' ^
        d.path = []; # pa+
        while (p(/^(\S+)\s*/)) {
            $path = m[0].split('/');
            $outer = parse;
            each in path {
                parse = n;
                $pa = {};
                
                # set var from path bit
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                
                # get path bit/value of here from a variable:
                # t-only/squish/shaded clone of C, or
                # C itself
                # when o the C will match itself/navigate onwards
                # or i will input that squished C,
                #   and/or ark/return,
                #   and/or climb past it and input more stuff...
                
                # toy: a name-only sketch of C
                # sheer spacer, made for a C
                #   eg where desired.t == wanted.t
                p(/^#/) and pa.isparam = 1; pa.relative = 1;
                
                # C itself for path bit got from param
                p(/^\$/) and pa.isparam = 1
                
                pa.t = parse;
                
                pa.t == '*' and pa.glob = 1;
                
                # value of here from a:
                if (pa.isparam) { # variable/bind param
                    !params.length and throw "Not enough params", pa.t, pa, d
                    pa.v = params.shift();
                }
                else
                if (pa.glob) {} # anything
                else { # bareword
                    pa.v = G&Cye,[pa.t,1]
                    # words are the lumber of the algorithm
                    pa.word = pa.spacer = 1;
                }
                # namespaceness of something
                if (pa.relative) {
                    pa.o_v = pa.v;
                    pa.v = G&Cye,[pa.v.t,1];
                    # relative spacers hold a name for something
                    pa.spacer = 1;
                }
                
                d.path.push(pa);
            }
            parse = outer;
        }
        parse and throw "Unparsed", parse
        
        if (d.fromo) {
            # parse that talk too, to use up params
            d.oach = parsetalk(d.fromo,params);
        }
        
        params.length and throw "Too many params", params
        # maps, greps, sorts
        
        # so now we have a path:
        # i: make it so
        # o: read it out
        return d
    };
    
    #c knowables
    $knowing = &d,v{
        # glob tv wants to make some path
        v ||= {t:'*',y:{cv:'*'}};
        # a subtype, reenters at the end:
        d.asa and $other = d; d = other.asa;
        # types
        d == 'tv' and d = {t:d,our:['y','tv'],path:[v.t,v.y.cv],usu:1};
        d == 'tw' and d = {t:d,our:['y','tw'],path:[v.t],usu:1}
        d == 'z' and d = {t:d,our:['sc','z']}
        # sheer bunch of keys
        d.constructor == Array and d = {path:d,usu:1}
        
        typeof d == 'string' and throw "intelligise", d, other
        
        other and ex(d,other);
        
        # apply the usual behaviour:
        #  - when duplicate, overwrite
        #    if tv, overwritings become linked lists
        if (d.usu) {
            if (d.t == 'tv') {
                # when not debugging:
                #d.also ||= ['tw','z']
            }
            d.dup = usu_dup;
        }
        return d
    };
    # this should be available as around or after method call..
    # or "the usual" that the actual d.dup works with or without
    $usu_dup = &x{
                # can link duped things, new thing gets v.y.$to
                # as in, newthing.y.earlier = oldthing
                $from;
                $to;
                # make similar index to z to hold dupes, in order
                # as s&z grep !in tv might reveal
                $dupz;
                
                # revision of an item
                d.t == 'tv' and from = 'later'; to = 'earlier'; dupz = 1;
                # revision of name, moving through items
                d.t == 'tw' and from = 'begins'; to = 'continues'; dupz = 1;
                # stuff moves through words
                # these schema should be drawn out
                # become keywords to io
                # io will just work
                
                if (from || to) {
                    # which way is it going: new val stays, new val joins the queue
                    $backwards = from && x.y[from] || d.keep_first; #]
                    if (backwards) {
                        !from and throw "can't go backwards with no from?"
                        # ^ unless use in telling things that missed the spot who beat them
                        !d.keep_first and throw "protocol changed"
                        # we could -1 y&dup_tv index maybe?
                        # or add y&most_$from to the end of the linked list
                        # this should magnify into a huge democratic space for ...
                        # space for 'space for ...'
                        # or follow links:
                        $X = x;
                        # < all while loops should have some limit, spec learned
                        #   badge earned. all code is is bestowment.
                        $i = 100;
                        while (X.y[from]) {
                            i-- < 4 and throw "ixhaust"
                            X = X.y[from];
                        }
                        # now last in the trail:
                        X.y[from] = v;
                        to and v.y[to] = X;
                        # so tv stays something, but .y.later = v extends forever
                    }
                    else {
                        from and x.y[from] = v;
                        to and v.y[to] = x;
                        # now tv sets us.
                    }
                }
                
                # make tv_dup, index as tv but to [] of items at the point
                # the minter will care about such things, T clutter, minor errors, noise
                if (dupz) {
                    !d.our and throw "housing not given"
                    $p = {t:'z'};
                    p.our = d.our.slice();
                    $gk = p.our.pop();
                    p.our.push(gk+'_dup');
                    p.path = d.path.slice();
                    # dup should include the one already there
                    p.zefault = [x];
                    input(s,p,v);
                }
                
                d.keep_first and return 1
                # but we (as eg tv) shall go on to tw and z even dups
                # no information lost!
    }
    #c _o sketches use for A:o:
    # o gets you what you wanted from an intelligised pile
    #   midsection of o is the midsection of n
    #  S titles can use this to define iterators
    # operation of returning results from traversal,
    #   or advancing the A:o of the C, as in dome calmness check
    
    # o may ventually look like n,
    #   and n may eventually have blockquotes hanging on after it,
    #   even T things, grabbing whatever on/over/into Aing thereinout
    
    # hmmm. music collection will be lived by o,
    # QMS would be in a quarantine
    
    # there must be more
    # the o d will be... more infinite
    #   particularly grep/sort/map
    #  tal being apply
    # lingo shape glue session
    $o = &talk,params,d{
        d ||= {};
        parsetalk(talk,params,d);
        !d.path and throw "no path"
        
        $col = &q,p{
            p ||= {};
            p.i ||= q ? q.i+1 : 0;
            $pa = d.path[p.i];
            !pa and throw "No pattern!: "+p.i
            
            if (!q) {
                p.i > 0 and throw "no q, notfirst"
                if (pa.glob || pa.spacer) {
                    # has an implied starting point
                    p.i--;
                    !A.r and throw "unreal beginning, no Ar"
                    d.shiftzero = 1;
                    p.found = [A.r];
                }
                else {
                    !pa.v and throw "nofirst"
                    # begins space
                    p.found = [pa.v];
                }
            }
            else {
                p.up = q;
                
                if (!q.found.length) {
                    # dont bother looking anywhere?
                    p.found = [];
                }
                else {
                    # onward
                    !p.row and throw "Nowhere"
                    $s = p.row.slice(-1)[0]; # or p.i?
                    !s and throw "doing empty"
                    
                    # what should be:
                    $v = pa.v;

                    # via
                    $D = {asa:'tv'};
                    # to diversify...
                    pa.glob and D.meta = ['*','*'];
                    else
                    !v and throw "null pav?"
                    
                    # 6, only the last column
                    p.found = output(s,D,v);
                }
            }
            
            #c and so we can perceive incomplete rows
            # merge onto every row - after return/in more loop?
            
            if (!p.row) {
                # starts - rows = [[r]]
                !p.found and throw "no row or found"
                p.rows = p.found.map(&s{ return [s] });
                # then forever more:
                #   rows appended to multiplicitly to the right
                #   cols added to for q.cols
            }
            # adds column + some number of rows...
            else
            if (!p.found.length) {
                # empty - full of null
                p.row.push(null);
                p.rows = [p.row];
            }
            else {
                # new column of many - duplicate this row out
                p.rows = p.found.map(&s{
                    ro = p.row.slice();
                    ro.push(s);
                    return ro
                });
            }
            
            
            
            # rows grow to the right
            # < go width first
            $more = d.path[p.i+1];
            if (more) {
                $rows = [];
                each i,row p.rows {
                    $r = col(p,{row:row});
                    
                    !r and throw "rowing nothing"
                    # keeps pushing null once lost
                    !r.length and throw "not one row"
                    r.map(&ro{ rows.push(ro) })
                }
                p.rows = rows;
            }
            
            return p.rows
        };
        $rows = col();
        # reduce or sprout iterator
        # rows multiply as deeper atoms many
        # - [r,1,1a]
        # - [r,1,1b]
        # - [r.2,null]
        # - [r,3,3a]
        # or a mirror C set, like G&ind does
        # and/or ind-like N, maybe ioN goes:
        #   [r,[1,[1a,1b],2,3,[3a]]
        # deepest atoms for starters:
        
        # take off columns not in the formula (A.r)
        d.shiftzero and rows.map(&row{ row.shift() });
        
        $last_column = rows.map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });

        return last_column;
        # < ark, setup iterator
        throw "End"
    };
    #c output
    $output = &s,d,v{
        d = knowing(d,v);
        # path =
        #   our  - reaches from thing to its universal (nk,gk)
        # + path - into index (t,cv)
        # not the same d.path (or d) of i/o
        #   is a lower level, manyer
        # meta applies to non-our path only.
        $path = d.our || [];
        $mi = path.length;
        d.path and d.path.map(&p{ path.push(p) });
        
        # we only need to capture the endmost atoms at this low level
        # < rows is S in input... could insert multiple times if crazy
        d.rows = [[s]]; 
        # flow
        $i = 0;
        while (path[i]) {
            $k = path[i];
            $pm = i >= mi && d.meta && d.meta[i-mi];
            $rows = [];
            each ri,row d.rows {
                $S = row.slice(-1)[0];
                if (S == null) {
                    row.push(null);
                    rows.push(row);
                    i++;
                    continue
                }
                $ks;
                if (pm) { # loose match, may many
                    # use z order? grep by tv?
                    # in the order they were set
                    pm == '*' and ks = Object.keys(S)
                    else {
                        # for WHERE k=v to be k>5, k~re
                        throw "meta",pm
                    }
                }
                else { # exactly what path[i] says
                    # but when to cast it first? never I spose.
                    $ok = typeof k == 'string'
                        || typeof k == 'number';
                    !ok and debugger
                    !ok and throw "nonstringstep"
                    ks = [k];
                }
                # < to sort, know fractional cv,
                #   with freaks, histograms, history
                # < if !x we could try as if 1=='',
                #   misspellings, round until found,
                #   using z a sorted z to scope up a cv faster...
                #   even resurrecting a J that looks similar
                each ik,k ks {
                    $x = S[k];
                    # extend row
                    $ro = row.slice();
                    ro.push(x);
                    rows.push(ro);
                }
            }
            d.rows = rows;
            # and add column:
            i++;
        }
        # take off columns not in the formula (A.r)
        d.shiftzero and d.rows.map(&row{ row.shift() });
        
        $last_column = d.rows
            .map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });
        return last_column
    };
    
    #c i_ somewhere someway somestuff
    # the dot of the i is somestuff, index the space, trunk way etc.
    
    # shall we use a talky Babz'd params-implied-by-$ thing?
    # or just put thing on thing arguments?
    $i = &talk,params,d{
        d ||= {};
        parsetalk(talk,params,d);
        !d.path and throw "no path"
        
        # talk:
        #   'universal keyworded-by $thing'
        # find these things... barewords we have around?
        # usually a J universal like N,M,1,9, etc.
        # and somethinging to it:
        # talk='N $by', param=[$by]
        #   N means 3's A:n's r's cM, # caveful of atoms
        #      or M 1's A:n's r's cM  # just the people around you
        #   should kinda m:N $by,
        #   but with the o kind of universal awareness, not A:n
        # but simply as possible, until real use cased:
        # - make sure this is so!
        # as opposed to o:
        # o how is this?
        # 
        $row; # see 'crazy'
        # row may > path?
        each i,pa d.path {
            if (i == 0) {
                !pa.v and throw "null beginning"
                if (pa.spacer) {
                    !A.r and throw "unreal beginning, no Ar"
                    d.shiftzero = 1;
                    row = [A.r]
                }
                else {
                    row = [pa.v]
                    continue
                }
            }
            # formulate output()
            $D = {asa:'tv'};
            
            # when v is mere space identity, use what is found
            pa.spacer and D.spacer = 1
            # and when should existing objects be replaced,
            #   but indexes copied to the new one?
            #   seems like s's buzz.
            
            # what is - may be longer than path
            $s = row.slice(-1)[0];
            !s and throw "null step?"
            !s and row.push(null); continue;
            # what should be:
            $v = pa.v;
            !v and throw "null pav?"
            $r = input(s,D,v);
            row.push(r);
        }
        # take off things not in the formula (A.r)
        d.shiftzero and row.shift();
        # have to return singularly?
        A.debug and debugger;
        return row.slice(-1)[0];
        # < ark
    };
    
    
    #c input see,
    # fills in an index with a value
    # total definition of z/tv indexes, which should be one of a few...
    # along with the z/tv positioning system, there's an element of
    #   wiring or linked lists via y&in, y&up, y&next, y&prev,
    #   left out for code volume
    # < index/join types should be curated nearby
    #   proto hard-coded...
    # tv:
    #    lots of C via tvs can hold anything, just stretched out.
    #      maybe if you're database you want to know things.
    #    < in exact mode should keep z sorted,  overwrite tv
    #    < in soft mode should not overwrite (el=1)
    #    
    # non-tv index/join types:
    #    I: could be known to be of/ov/t/cv?
    #    x/y/z: what's in space...
    #    beliefs in cv like subnets, having octaves of octaves,
    #      non-linear spaces, klein bottle public netspace
    #      lanes of stripes whipping around a torus, etc.
    #
    # 
    # s = data
    # d = [pa,th], puts at that path
    # d = {path:[pa,th],dup:&s{}}
    # does a single weld, usually C-C
    # carbon joint, some language in each place?
    # ignores the next/last/in/up wiring, let o do once sorted
    #   when it gives a kind of gravity,
    #   linearity to the stage that may not ever be there
    $input = &s,d,v{
        d = knowing(d,v);
        # return d here to extract what we know, kind of 2
        
        # now 3 deals with what really shall be and how we shall create it
        
        # climb container different? may A?
        # section of o, defined into several places... houses
        # this is the most high speed bit, copying bunches of C,
        # with a little lingeme sensitivity loaded in on the d,
        # which is a lunk for A, C, T rivering the reverberate of revision
        
        # climb index
        # d.ours ['nk','gk'], gets to the thing at the end of this thing
        # +
        # d.path ['Winning','0.1'] points of index, to the value
        # not the same d.path (or d) of i/o, is a lower level, manyer
        $path = (d.our||[]).slice();
        d.path and d.path.map(&p{ path.push(p) });
        
        $S = s;
        each ip path {
            i *= 1;
            $x = S[p];
            x && typeof x != 'object' and throw "index broken"
            # the last bit of our space: the universal
            #   could be something trascendant
            #   like being a thing with hooks, more our until path...
            d.our && i == d.our.length and d.on_our = x
            # done, leave S on second to last thing
            i+1 == path.length and continue
            # hash usual
            x == null and x = S[p] = {}
            S = x;
        }
        
        # S[p] may now = x
        # S[p] soon will = v
        if (d.t == 'z') {
            # or include it
            x == null and x = S[p] = d.zefault || [];
            x.constructor != Array and throw "z broken"
            #$xi = x.indexOf(v);
            # exact object ^, also could be claiming a tv had already (up at tv)
            # we shall start simply adding on, mentioning things more than once, etc
            # no information lost!
            # except the time of day, which is easy to find
            # dups constitute weirdness that should be cleaned up...
            #   before the system with it in goes production
            # < z_dup: handled on the o end, as z things not in tv, and tv_dup
            x.push(v);
        }
        else {
            # set thing to thing
            if (x != null) {
                # already, noop?
                d.spacer || x == v and return x
                d.dup && d.dup(x) and return x
            }
            S[p] = v;
        }
        
        # seeds with seed pouches
        if (d.also) {
            each in d.also {
                n == 'tw' and input(s,'tw',v)
                else
                n == 'z' and input(s,'z',v)
                else {
                    throw "What else", n
                }
            }
        }
        return v
    };
    #c iover
    return {F:F,i:i,o:o,input:input,output:output,parsetalk:parsetalk}
t/iooia: |
    G&heading;
    $io = G&way,'iooia';
    # < does an out-Doming wait for an in-Doming?
    G&way,'Doming',ar;
    #A&async = 1;
    
    debugger;
    # Domes:
    # make an M cv space subnet per test?
    #   so we can write more nonlinear
    $a = &t,talk,cetia,c{
        $params = cetia ? cetia.split(' ')
            .map(&s{ return G&Cye,[s] })
          : [];
        
        $what = talk+(cetia ? " <--- "+ki(cetia) : '');
        m $t  $s:what %hue:200deg,dis:block
        
        $d = {};
        $r = io[t](talk,params,d);
        
        if (c) {
            # more awareness
            (c == 1 || c.show) &&
                m d_of_"+t+"  $s:d
        }
        $n =
        m $t  $s:r
        typeof c == 'object' and ex(n.c,c)
        return r
    };
    #debugger;
    S 1 respec-talk
    a('parsetalk','w/*:w');
    a('parsetalk','trouble/w:r/#w:t','weeee',1);
    a('parsetalk','$t o $w/*','tea weas');
    # from the story of -respec:
    # o w/*:w
    # if problem with $w:
    #   i trouble/w:r/#w:t
    #   ts&dige = supposedtobe
    #   i $t o $w/*
    
    S 2 respec
    A.r = G&Cye,['iooia',9,{M:[]}];
    $now = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','weeee');
    
    #A.debug = 1;
    $aw = a('o','w/*:w');
    #debugger;
    
    $iw = a('i','w:r/#w:t','walso');
    $aw = a('o','w/*:w');
    
    #A.debug = 1;
    $w =
    a('i','trouble/w:r/#w:t','sweeee');
    ws&plat = 5;
    $aw = a('o','w/*');
    # too far
    $aw = a('o','w/*/*');
    $aw = a('o','trouble/w/*',0,1);
    
    $aw = a('o','*',0,{show:1,dl:5});
    
    
    $aw = a('o','*/*',0,{show:1,dl:5});
    
    
    #a('i','w:r/#w:t','well');
    #a('i','$t o $w/*','tea weas');
    
    
    S 3 i/o
    if (1) {
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    $o = G&Cye,['blag','2',{s:'gakel'}];
    # bothered writing this?
    # i $d/$o
    # maybe we want 'd>o'
    # magnetics want to... ranking, raking...
    # for sorting the junkdrifts of culture
    
    # < completing this -fod now so it sees d before io
    m attaching_to -fod $s:d,dl:14
    $N = io.i('$d/$o',[d,o]);
    $oN = io.o('$d/*',[d]);
    m enN -fod $s:N,dl:14
    m ouN -fod $s:oN,dl:14
    # so 'i $t' tv's each 'o $w/*:W', like 'i $t $W'+
    # < do d.oach
    }
    
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    debugger;
    S 0
    debugger
    
    each in M {
        ns&hue and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
    
Duning: | # avalanche of activatuio
    # S as steps of transformations, some linear?
    # S as moments to do o, sleep/wake culture
    # S as functions to map things inside (M) or outside (N/U) this J
    #  M works on 1's M, what we have
    #  N works on 2's M, where we are
    #  U works on 3's M, Wunity of things we are foorming:
    #   3's M, as A-climbed to its A.r, root9 molecule,
    #    haver of domes, so these in-pi can collaborate
    #    look and respond waves going wide, weaving
    #    with one big object index, etc.
    #    craziness is being joined up on A.3
    
    # < S still for late osc? Swum things?
    #   S 8... could make &{} instead of while wrap
    #     B carefully when calling such
    # could be a nice place to reboot subroutines actually...
    # < S for elvis handle
    
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    
    
    # A-climb, for the right levelled A.r (pool, what)
    # which will eventually be the root and root dome and ground
    # 3's is a big room of stuff,
    #   hmmm
    $Ask = &s,k{
        typeof s != 'number' and throw "Ask for num"
        # climb up
        $Y = A;
        $lim = 30;
        $want = A[s];
        while (Y.1 != want) {
            Y = Y.up;
            !lim-- and throw "Ask huge"
        }
        # 
        k == '' and return Y
        if (k == 'rc&M') {
            $r = Y.r;
            # r R? the soft int
            !(rc&root || rc&dome) and throw "isDome"
            !rc&M and throw "not rcM",r
            return rc&M
        }
        if (k == 'C') {
            !Yc&s and throw "NoC!"
            # isC, when it inlines
            return Yc&s
        }
        throw "What at?", Y
    };
    # arg eater
    # eat args for S
    $meater = &d{
        $m = [];
        m[0] = &r{
            m = d.match(r); # += /(?: |$)/ somehow
            !m and return
            m.shift();
            d = d.replace(r,'');
            return m.length == 1 && m[0] ? m[0] : 1
        };
        return m
    };
        
    
    # sequences/numbered:
    #   could fractionate across A.3, shelved somehow...
    #   having a limb inside J6, wh
    # they diff island on the dome, working on array
    # 
    # Duning S might return a variable, making for iteration
    # < Babz this in somehow
    # or fetching (Ask()) something another M, 3's M is called N
    # < something should be able to takeover which S we want to go for, too...
    
    # for G&Ban to find these subs:
    $way = Gc&B.sc.way;
    A&S = &s,t{
        # B will be i/S
        Gc&B.sc.way = way;
        typeof s == 'number' and throw "doing seq"
        $g = A&doming(s);
        
        # non-iterative dome again?
        !g and return
        $m = meater(s);
        #debugger;
        $p = m[0];
        # $s='as last N'
        if (p(/as /)) {
            $limit = p(/(first|last) /);
            $M = p(/U/) ? Ask(3,'rc&M')
                :p(/N/) ? Ask(2,'rc&M')
                :p(/M/) ? Ask(1,'rc&M')
                : '';
            !M and throw "noM?",s
            if (limit) {
                $C = Ask(1,'C');
                $O = limit == 'first' ? M.slice(0,1)[0]
                    :limit == 'last'  ? M.slice(-1)[0]
                    :'';
                !O and throw "noO?",s
                C != O and return
            }
            return M
        }
        else {
            # T out the other
            #$M = 
            $notes = [s,t];
            m called_S -jod $s:notes
        }
        
        #throw 'edge of reality', [s, t]
        return 1;
    };
    
    #c A&doming like Doming:
    # For Duning:
    #  may not ground all domes,
    #  they may be ephemera, even error/message channels
    #  in a spinal nervous system awareness
    #  where hs&z makes for stuff toward rs&z
    #  but we might have hs&Errors, hs&Msgs... other dimensions
    
    #  should A.r be taken over by the current dome? supposedly.
    A&doming = &t{
        # resets a chunk of reality,
        # a group of o that may flatten or hide from s
        # A.ground.sc.z (or A.r.sc.z, or ra&z) is the main wWw
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A.ground = g;
        # soon:
        #!gc&root and throw "root of ground not", g;
        
        # one A&doming gives all the domes to ground
        # < what meaning for Duning?
        #   
        if (1s&domes && !gc&domed) {
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        if (h) {
            # never repeat Duning?
            # depends on the mode,
            # S and C iterator
            return;
            # 
            # reset, o maintains it in the beginning of s, 
            hs&z = [];
        }
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        # Duning doesn't step into the dome, merely holds it
        #A.ground = h;
        #G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
        return h;
    };
    
StayToSleep: | # gentleness scan
    # 
t/BuildACastle: | # test Duning and io
    # ones
Fly: |
    G&heading;
    G&way,'t/iooia',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
grow: | # spraw Js&ope qua
    # there must be a S/C/A clicky scheme attacher somewhere
    $Y = c.y.A.1;
    Ys&ope ||= 0;
    Ys&ope += e.t.includes('C') ? -1 : 1;
    ~Told: ki(Y), ki(Y.3)
pi/fod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # where was above? 2Cc&d was going to do this...
    $u = A.n.up.n.c.s;
    c&d ||= uc&d || 1;
    c&d > 1 and ys&ml = (c&d - 1)+'em'
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    $dl = c&dl || 3;
    1s&ope and dl += 1s&ope;
    
    $es = c&s;
    es = $.extend({},es);
    if (es.path) {
        $p = es.path;
        delete es.path;
        each in p {
            m path -fod $s:n,d:2,dl:7
        }
    }
    if (es.oach) {
        $p = es.oach;
        delete es.oach;
        m oach -fod $s:p,d:3,dl:7
    }
    
    
    
    G&n,['Thing',3,{s:ki(es,dl)}];

