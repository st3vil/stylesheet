TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # piling stuff up
    =head
    
      
      
      other stuff:
        
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        Ladada
      ; matters much for no reason
      brackets also
      filigree?
      
      general \ at the end of the line to continue expression...
        strange one
        idea of cs and more to the C in some compression, out of tycsc mode
        would let base64 image data after sc...
      
      Babz:
       - do some stuff in javascript! the messiest and easiest things
       - n... wants loose t that concats $vars, so we can type endlessly
         until:
         since cv is always -jod or \d (or W)
         y can say :W instead of W, one c&thing == C.t could odify like that
           maybe more if the boundary is not text but a bubble
           when everything similarity matches itself and stretches tendons of divergence
      
      =cut
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
iooia: | # F > i/o > input/output
    # these will all be G&F, G&o, G&i...
    
                    # round until found
    
    # other possible types of thisness:
    # - G&s for writing notes for itself
    #   using traces left by i/oing etc nearby
    #   doing crazy implicit templating
    #   throwing universal weight around
    #  also s is where situations are strategised on
    
    # F is a culture of grasping syntax on top of o
    # formula
    $F = &s,d{ return G&way,'PseudoF',{s:s,d:d} };
    $io = {}; # a bunch
    
    #c parsetalk
    # parse out bits into m
    $parse;
        $m;
        $p = &r{
            m = parse.match(r);
            !m and return
            m.shift();
            parse = parse.replace(r,'');
            return 1
        };
    
    $ta = G.tiestowe = [];
    
    # compile time
    # see j/41/jababio
    # the string is basically a branch/path 
    #   params give values to columns, named with /^[$#]/
    #   params return or made available somewhere, per column, per row...
    # saving much typing!
    
    # can't really bab 1 line to many to set params
    # must return N
    #   it's what's expected? (at io (not F?))
    # and put iterator interface on T...
    #   later some way to do cursors,
    #     percolate and collaborate read-need-ness
    
    # but in an S:
    #  S can do io and then be iterating
    #  Babz setting params inside from T
    
    
    # general branch lingo
    # something for C-together
    # < making sql
    # params written as if string interpolated:
    # they create/read object or some reduced idea of an object:
    # the column will/must have/match the given param's value/identity,
    # $o - value
    # #o - looser/vaguer/processed copy of $o
    #      like spacers, with only C.t=o.t
    # word - spacer of C.t=word
    
    # < want o to find the exact object, not it's identity?
    
    # < unless it names a universal (1s&bareword) or so,
    #   then use that. inner lingosanctum.
    $parsetalk = &talk,params,d{
        d ||= {};
        parse = talk;
        # do i ... for o ...
        p(/ ((i|o) .+)$/) and d.plumb = m[0]
        # plumbed bit gets parsed after its downstream,
        #   but runs before, so know what:
        p(/^(i|o) /) and d.is = m[0]
        # absorb the o lop ^
        talk = parse; 
        
        # Babz shall do params, see 'compile time' ^
        d.path = []; # pa+
        while (p(/^(\S+)\s*/)) {
            # < '{}:m' -> params contains a &acgts{ map/grep/sort }
            #   with implicit return lastline
            #   whose value becomes a column
            $path = m[0].split('/');
            $outer = parse;
            $pa;
            $dpa = &eatparam{
                if (eatparam) { # bind param to path bit
                    !params.length and throw "Not enough params", pa.t, pa, d
                    pa.v = params.shift();
                }
                d.path.push(pa)
            };
            each in path {
                parse = n;
                pa = {};
                
                #c clone C
                p(/^y(\S*)$/) and pa.separation = m[0]||1; dpa(); continue
                # set var from path bit
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                # function
                p(/^\{(\w+)?\}$/) and pa.doof = m[0]||1; dpa(1); continue
                # and use each of them
                p(/^@/) and pa.sark = 1
                # can be i $i/@#dee/$fings o $o/*:dee
                #   to copy spacers
                
                # get path bit/value of here from a variable:
                # t-only/squish/shaded clone of C, or
                # C itself
                # when o the C will match itself/navigate onwards
                # or i will input that squished C,
                #   and/or ark/return,
                #   and/or climb past it and input more stuff...
                # sheer spacer, made for a C
                #   eg where desired.t == wanted.t
                p(/^#/) and pa.isparam = 1; pa.relative = 1;
                pa.sark and delete pa.isparam;
                
                # C itself for path bit got from param
                p(/^\$/) and pa.isparam = 1
                
                pa.t = parse;
                
                pa.t == '*' and pa.glob = 1;
                
                # value of here from a:
                if (pa.isparam) { # variable/bind param
                    !params.length and throw "Not enough params", pa.t, pa, d
                    pa.v = params.shift();
                }
                else
                if (pa.glob) {} # anything
                else
                if (pa.sark) {} # name of a column in d.plumb...
                else { # bareword
                    pa.v = G&Cye,[pa.t,1]
                    # words are the lumber of the algorithm
                    pa.word = pa.spacer = 1;
                }
                # namespaceness of something
                if (pa.relative) {
                    pa.o_v = pa.v;
                    pa.v = G&Cye,[pa.v.t,1];
                    # relative spacers hold a name for something
                    pa.spacer = 1;
                }
                dpa();
            }
            parse = outer;
        }
        parse and throw "Unparsed", parse
        each i,pa d.path {
            if (pa.separation) {
                $mode = pa.separation;
                mode == '1' and mode = 'C';
                mode = mode.split(',');
                pa.yto = mode[0];
                pa.yfrom = mode[0];
                pa.doof = 'separation';
            }
            if (pa.doof) {
                $known = pa.doof;
                if (known == '1') {
                    typeof pa.v != 'function' and throw "expecting doof",pa
                    # doof(acgts) each thing, or so
                }
                else {
                    typeof pa.v != 'string' and throw "expecting doofstring",pa
                    # get thing to peel it already?
                    # then these d can be compiled in
                }
            }
        }
        
        # others, use up params
        d.plumb and d.plumb = parsetalk(d.plumb,params)
        
        params.length and throw "Too many params", params
        return d
    };
    
    #c knowables
    $knowing = &d,v{
        # glob tv wants to make some path
        v ||= {t:'*',y:{cv:'*'}};
        # a subtype, reenters at the end:
        d.asa and $other = d; d = other.asa;
        # types
        d == 'tv' and d = {t:d,our:['y','tv'],path:[v.t,v.y.cv],usu:1};
        d == 'tw' and d = {t:d,our:['y','tw'],path:[v.t],usu:1}
        d == 'z' and d = {t:d,our:['sc','z']}
        # sheer bunch of keys
        d.constructor == Array and d = {path:d,usu:1}
        
        typeof d == 'string' and throw "intelligise", d, other
        
        other and ex(d,other);
        
        # apply the usual behaviour:
        #  - when duplicate, overwrite
        #    if tv, overwritings become linked lists
        if (d.usu) {
            if (d.t == 'tv') {
                # when not debugging:
                #d.also ||= ['tw','z']
            }
            d.dup = usu_dup;
        }
        return d
    };
    # this should be available as around or after method call..
    # or "the usual" that the actual d.dup works with or without
    $usu_dup = &d,x,v{
                # can link duped things, new thing gets v.y.$to
                # as in, newthing.y.earlier = oldthing
                $from;
                $to;
                # make similar index to z to hold dupes, in order
                # as s&z grep !in tv might reveal
                $dupz;
                
                # revision of an item
                d.t == 'tv' and from = 'later'; to = 'earlier'; dupz = 1;
                # revision of name, moving through items
                d.t == 'tw' and from = 'begins'; to = 'continues'; dupz = 1;
                # < first relative thing keeps its position in tw
                # < check new/old position in z, to inform who takes tw
                #   hmmm, a flappy edge to the arrangement
                # stuff moves through words
                # these schema should be drawn out
                # become keywords to io
                # io will just work
                
                if (from || to) {
                    # which way is it going: new val stays, new val joins the queue
                    $backwards = from && x.y[from] || d.keep_first; #]
                    if (backwards) {
                        !from and throw "can't go backwards with no from?"
                        # ^ unless use in telling things that missed the spot who beat them
                        !d.keep_first and throw "protocol changed"
                        # we could -1 y&dup_tv index maybe?
                        # or add y&most_$from to the end of the linked list
                        # this should magnify into a huge democratic space for ...
                        # space for 'space for ...'
                        # or follow links:
                        $X = x;
                        # < all while loops should have some limit, spec learned
                        #   badge earned. all code is is bestowment.
                        $i = 100;
                        while (X.y[from]) {
                            i-- < 4 and throw "ixhaust"
                            X = X.y[from];
                        }
                        # now last in the trail:
                        X.y[from] = v;
                        to and v.y[to] = X;
                        # so tv stays something, but .y.later = v extends forever
                    }
                    else {
                        from and x.y[from] = v;
                        to and v.y[to] = x;
                        # now tv sets us.
                    }
                }
                
                # make tv_dup, index as tv but to [] of items at the point
                # the minter will care about such things, T clutter, minor errors, noise
                if (dupz) {
                    !d.our and throw "housing not given"
                    $p = {t:'z'};
                    p.our = d.our.slice();
                    $gk = p.our.pop();
                    p.our.push(gk+'_dup');
                    p.path = d.path.slice();
                    # dup should include the one already there
                    p.zefault = [x];
                    input(s,p,v);
                }
                
                d.keep_first and return 1
                # but we (as eg tv) shall go on to tw and z even dups
                # no information lost!
    }
    #c doof: pour iterator through function, making another iterator
    io.doof = &t,pa{
        # take iterator
        !t.more and t = io.nz(t)
        # copy schema + column for func return
        $d = {};
        d.path = t.path.slice();
        # it may be for what defines it (lastfunc)
        $funci = d.path.indexOf(pa);
        funci < 0 and d.path.unshift(pa);
        # how to operate
        $h = {};
        # iterations vote for/against row and a cell: {
        #   r: func return value
        #   row: in t.rows[t.i]
        #   s: in .row[i/t.d], the one unique object, the cell
        #   i: t.d (depth) or t.path[i], the column
        $inc = [];
        $exc = [];
        $doofings = []; # everything
        if ('grepping or mapping') {
            if ('uni') { # que objects, rhythm >= to rows
                t.partial = 1;
                $cb = pa.v;
                typeof cb != 'function' and throw "Not function", pa
                t.ind(&s,t{
                    # C the item, s the iterator, to them
                    $isC = s && typeof s == 'object'
                        && s.t != null && s.y && s.c && s.sc;
                    !isC and throw "doof-grep-ind got !C s",s,t.row;
                    $r = cb(A,s,G,T,t);
                    
                    t.row.indexOf(s) < 0 and throw "s not in trow?",s,t.row
                    $doofing = {
                        r: r,
                        row: t.row,
                        s: s,
                        i: t.d,
                    };
                    doofings.push(doofing);
                    (r ? inc : exc).push(doofing)
                });
            }
            else {
                throw "wants rows or the/other arks";
                # changing path/arks means another iterator?
                # or we just change em, t = nz(t)
            }
        }
        else {
            throw "mapping, doing, regrouping, who knows"
        }
        # inc-ings vs exc-ings
        # to dedupe itering objects on the same row,
        # < pick the row that describes more matches at once?
        #     to avoid talking about stuff that didn't match?
        # < nonfirst objects on a row lose their return value,
        #     since we only have one doof column for it
        #     shapeliness problem
        #   assume they will use d.objects and d.returns
        #   
        #   < rowing itself should use input/output
        #     so any shapeliness problem can escalate and solve itself:
        #     nonfirst objects return values:
        #       could have column types,
        #       make the doof an array referring to other columns?
        #      so it can get really complicated,
        #      methods for schema/data
        #      ways of partitioning problems and stats near
        # anyone says yes
        # < we could tally results a bit
        #   before deciding how we are operating
        #     if they all seem boolean
        # < maybe they should pick the best one along the row?
        #   ie if we're looking for music, the live streams deep
        #     within the music collection should win
        # < the comp for attention
        d.objects = [];
        d.rows = [];
        d.returns = [];
        $la;
        each i,r inc {
            d.returns.push(r.r);
            $oi = d.objects.indexOf(r.s);
            oi < 0 and d.objects.push(r.s)
            else {
                $obr =
                d.obirows[oi] ||= [];
                
            }
            r.row == la and continue
            !r.r and continue
            la = r.row;
            $row = la.slice();
            funci < 0 and row.unshift(r.r)
            else {
                row[funci] = r.r
            }
            d.rows.push(row);
        }
        return io.nz(d)
    };
    
    #c rowing: travel d.path for i/o hooks
    # < able to async, when A:o things
    $rowing = &talk,params,d,h{
        # reduce or sprout iterator
        # rows multiply as deeper atoms many
        # - [r,1,1a]
        # - [r,1,1b]
        # - [r.2,null]
        # - [r,3,3a]
        # < or a mirror C set, like G&ind/G&o does
        # < find us for ind-like N, p.nz goes:
        #   [r,[1,[1a,1b],2,3,[3a]]]
        
        # being plumbed somewhere
        if (typeof talk == 'object') {
            # d already, if compiling enough (sjson(parsetalk()))
            # or we are plumbed in to something that parsed our talk
            params && params.length and throw "talkref + params";
            d and throw "talkref + d";
            d = talk
        }
        else {
            d ||= {};
            parsetalk(talk,params,d);
        }
        !d.path and throw "no path"
        h.is && !d.is and d.is = h.is
        
        #c plumb from somewhere
        if (d.plumb && !d.plumb.more) {
            $b = d.plumb;
            !b.is and throw "no plumb.is, i/o?"
            b.is != 'o' and throw "plumb not o"
            d.is != 'i' and throw "plumb to not i"
            # make the call
            io[b.is](b);
            # have the iterator
            d.plumb = io.nz();
        }
        # find any firstfuncs
        # d.plumb replaces itself
        # these remain in path,
        # so we can ark their return
        $i = d.path.length-1;
        while (d.path[i]) {
            $pa = d.path[i];
            # < support for mid-path doofing
            #   could decide what to put after finding options for where
            !pa.doof and break
            # new iterator replaces old, so we can pipeline?
            d.plumb = io.doof(d.plumb,pa);
            i--;
        }
        # plumb rowmuddler
        if (d.plumb) {
            $t = d.plumb;
            # pa.sark and pa.v = their rows's ark
            # their (o's) rows are stitched in to ours
            #  < sarkumulative grouping... instruct a vals=[],valis=[]
            
            #  can be i $i/@#dee o $o/*:dee
            #   to copy spacers
            # i $d   implies   i $d/*  ?
            # i $d/* o $o/*   implies   i $d/*/@s o $o/*:s
            # so give i the thing saying build such-and-such:
            if (!d.path.filter(&s{ return s.sark }).length)
                d.path.push({sark:1,t:'s'})
            # < other: io-ish syntax/tool for such operations ^
            
            # P = [p], p.row = our row
            # p.pa be diverged from the one in d.path itself,
            #   so to split their pa.v (value entering/space identity)
            h.Pmod = &d,p,P{
                !P[0].row and throw "must be iterating the p.rows"
                P.length > 1 and throw "already multiplying row?"
                # if next bit of path is sarky
                $pa = d.path[p.i+1];
                !pa.sark and return P
                # ^ is the P[0].pa also
                # last sark thing has more rows
                $la;
                $pS = p;
                while (pS && !la) {
                    pS.pa && pS.sark and la = pS
                    else
                    pS.sark and throw "sark above not pa", pS
                    pS = pS.up
                }
                $R = [];
                each ib P {
                    # inject multiplicity into directions taken on the path
                    $rows;
                    if (la) {
                        !la.pa and throw "last sarking p without pa",la
                        !b.row[la.i] and throw "our row misses the last sark", b.row, la.i
                        !la.pa.rows and throw "last pa.sark didn't set pa.rows", la
                        # just their rows this row at that point dove into
                        rows = la.pa.rows
                    }
                    else {
                        # all they say
                        rows = t.rows;
                        # complete rows
                        if (!d.partial)
                            rows = rows.filter(&row{ return row.slice(-1)[0] })
                    }
                    
                    # locate sark as ark of theirs
                    # column number, for in d.path/p.row (G/W)
                    $coli = t.arks[pa.t];
                    coli == null && pa.t == 's' and coli = t.path.length-1
                    # < if it's 'lamb' and they have 'lambs/*',
                    #   suppose s is a lamb
                    coli == null and throw "no find column for",pa.t,t.arks
                    
                    # uniq the arked column's values
                    # group rows, put b.pa.rows for next regroup inward
                    $vals = [];
                    $valis = {};
                    each ir rows {
                        $v = r[coli];
                        $vi = vals.indexOf(v);
                        if (vi == -1) {
                            vi = vals.push(v)-1;
                            valis[vi] = [];
                        }
                        valis[vi].push(r);
                    }
                    pa.plumbiplied = vals.length;
                    
                    # multiply b by possible vals
                    $B = b;
                    each iv vals {
                        b = ex({},B);
                        b.pa ||= d.path[b.i];
                        b.pa = ex({},B.pa);
                        # b.row needn't clone?
                        
                        b.pa.v = v;
                        $rows = 
                        b.pa.rows = valis[i];
                        !v and throw "nullish v! for rows",b.pa.rows
                        #~>78 plumba: ki(b.row), ki(v,3)
                        R.push(b)
                    }
                }
                
                return R
            };
        }
        =func #c source
        =q[
         see if there's functions anywhere
         they are a separate logic to the pointy path
         < mix up as much as you want
         
         have a right to left flow, assigney
           i {funclast} pointy/path {funcfirst} o ...
         usu.
         
         funclast - map/grep everything selected
             wants to be fed ar per row...
           should use and generate an iterator,
           rows look the same + the column it defines...
           < or multiply if that's its game
         
         funcfirst - map/grep d.plumb,
             or be a function making rows
            do that via T? see via T
            should happen before descent into the d.path
              since values maybe sarked (@name) from what it does
            
            
         
         
         via T:
            like Swim things, they say:
              understand this name, then you look it up
                and figure out how to work it
              Core describes Knowables, like how to:
                input/output such index
                where/what/how it's going
                  where as in something in s should consume it
                  pretend to be a column or iterator
                  or it's rows/columns being added/replaced/removed
              T percolate out like errors/warnings if they are too unknown
                 may have a part to it specifying where,
                    like swim is to-cv
        
          y*/separation is like a function,
          must rerow to represent any rearrangement
          so each thing throws up a new iterator
          
          but they all start in the path, so may:
            lastfunc sees starting row, goes out,
              comes back with rows, does its thing, returns rows...
            firstfunc must operate first!
        ]
        =cut
        
        
        
        
        
        
        
        
        
        
        # so that path may get full of functions...
        # y and {} operate basically the same
        # p.row passes through
        
        #c beginning
        h.returns and d.sok = 1
        h.first ||= &{};
        h.found ||= &{};
        $first = 1;
        $col = &q,p{
            p ||= {};
            p.i ||= q ? q.i+1 : 0;
            $pa = p.pa || d.path[p.i];
            !pa and throw "No pattern!: "+p.i
            
            if (pa.doof) {
                # lastfuncs at beginning of path
                #  - happen just before this io returns
                # firstfuncs at end of path
                #  - happen before we started, are now d.plumb
                # suppose we continue with row as our rows, etc.
                p.found = [1];
            }
            else
            if (first) {
                first = 0;
                if (pa.glob || pa.spacer) {
                    # implies
                    !A.r and throw "unreal beginning, no Ar"
                    # < may refer to a 1s&word? 
                    pa = {t:'start',implicit:1,v:A.r};
                    d.path.unshift(pa);
                    # should leave out of rows, being implied
                }
                !pa.v and debugger; #throw "nofirst"
                
                h.first(d,p,pa);
                p.found ||= [pa.v];
            }
            else {
                p.up = q;
                
                if (!q.found.length) {
                    # dont bother looking anywhere?
                    p.found = [];
                }
                else {
                    # onward
                    !p.row and throw "Nowhere"
                    $s = p.row.slice(-1)[0]; # or p.i?
                    !s and throw "doing empty"
                    
                    # what should be:
                    $v = pa.v;

                    # to the bits
                    $D = {asa:'tv'};
                    # to diversify...
                    pa.spacer and D.spacer = 1;
                    pa.glob and D.meta = ['*','*']; d.sok=0;
                    else
                    pa.sark and // should have been figured by now?
                    # cos we want to input each thing via pa.v...
                    else
                    !v and debugger; #throw "null pav?"
                    
                    # make more rows
                    h.found(d,p,pa,s,D,v);
                }
            }
            
            #c middle - multiply row into here
            # adds column + may multiply rows
            
            if (!p.row) {
                # starts - rows = [[r]]
                !p.found and throw "no row or found"
                p.rows = p.found.map(&s{ return [s] });
                p.nz = p.found.slice();
            }
            else
            if (!p.found.length) {
                # empty - full of null
                p.row.push(null);
                p.rows = [p.row];
                # p.nz shapely enough to nothing when nothing
            }
            else {
                # new column of many - duplicate this row out
                p.rows = p.found.map(&s{
                    ro = p.row.slice();
                    ro.push(s);
                    return ro
                });
                # q.nz absorbs inners after loop
                p.nz = p.found.slice();
            }
            
            # rows grow to the right
            # < go width first? ps&z
            
            !d.path[p.i+1] and return p
            
            #c end - an expanding map
            $rows = [];
            each i,row p.rows {
                # our next bit of path
                $b = {};
                b.i ||= p.i+1;
                b.row = row;
                b.pa = d.path[b.i];
                
                # can go down a path in multiple directions
                $P = [b];
                h.Pmod and P = h.Pmod(d,p,P)
                
                each ib P {
                    $b = col(p,b);

                    if (b.nz) {
                        # ...s... -> ...s, [s's many]...
                        $s = b.row.slice(-1)[0];
                        $i = p.nz.indexOf(s);
                        i < 0 and throw "manying row[-1] not in p.nz", s, p.nz
                        p.nz.splice(i+1,0,b.nz);
                    }

                    $r = b.rows;
                    !r and throw "rowing nothing"
                    # keeps pushing null once lost
                    !r.length and throw "not one row"
                    r.map(&ro{ rows.push(ro) })
                }
            }
            p.rows = rows;
            
            return p
        };
        $p = d.p = col();
        d.rows = p.rows;
        T.o = d;
        
        # find any lastfuncs
        $i = 0;
        $lastfuncs = [];
        while (d.path[i]) {
            $pa = d.path[i];
            # < support for mid-path doofing
            #   could decide what to put after finding options for where
            !pa.doof and break
            lastfuncs.push(pa)
            i++;
        }
        if (lastfuncs.length) {
            lastfuncs.reverse();
            each i,pa lastfuncs {
                # new iterator replaces old, so we can pipeline?
                T.o = io.doof(T.o,pa)
            }
        }
        
        # deepest atoms:
        $rows = T.o.rows;
        $ss = rows.map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });

        A.debug and debugger
        d.sok && ss.length <= 1 and return ss[0]
        delete d.sok;
        #h.returns and debugger; #throw "Wanted to return s",ss,d
        return ss
    };
    
    #c i_ somewhere someway somestuff
    # the dot of the i is somestuff, index the space, trunk way etc.
    # shall we use a talky Babz'd params-implied-by-$ thing?
    # or just put thing on thing arguments?
    $i = io.i = &talk,params,d{
        # talk:
        #   'universal keyworded-by $thing'
        # find these things... barewords we have around?
        # usually a J universal like N,M,1,9, etc.
        # and somethinging to it:
        # talk='N $by', param=[$by]
        #   N means 3's A:n's r's cM, # caveful of atoms
        #      or M 1's A:n's r's cM  # just the people around you
        #   should kinda m:N $by,
        #   but with the o kind of universal awareness, not A:n
        # but simply as possible, until real use cased:
        # - make sure this is so!
        # as opposed to o:
        # o how is this?
        # 
        $row; # see 'crazy'
        # row may > path?
        # path should grow with it,
        #   unless they're really wandery globs, then you'd know...
        
        
        return rowing(talk,params,d,{
            found: &d,p,pa,s,D,v{
                # what should be
                # space to it gets filled in with hash
                # and when should existing objects be replaced,
                #   but indexes etc copied to the new one?
                #   upstream changes joining local modulation
                #   seems like s's buzz.
                
                # < input null to delete?
                p.found = [input(s,D,v)]
            },
            returns: 1,
            is: 'i',
        })
    };
    
    
    #c _o sketches use for A:o:
    # o gets you what you wanted from an intelligised pile
    #   midsection of o is the midsection of n
    #  S titles can use this to define iterators
    # operation of returning results from traversal,
    #   or advancing the A:o of the C, as in dome calmness check
    
    # o may ventually look like n,
    #   and n may eventually have blockquotes hanging on after it,
    #   even T things, grabbing whatever on/over/into Aing thereinout
    
    # hmmm. music collection will be lived by o,
    # QMS would be in a quarantine
    

    # there must be more
    # the o d will be... more infinite
    #   particularly grep/sort/map
    #  tal being apply
    # lingo shape glue session
    $o = io.o = &talk,params,d{
        return rowing(talk,params,d,{
            first: &d,p,pa{
                !pa.v and throw "nofirst"
                if (d.path.length == 1) { # <  && pa.isparam
                    # o $thing implies o $thing/*
                    d.path.push({t:'*',glob:1});
                }
            },
            found: &d,p,pa,s,D,v{
                # 6, only the last column
                p.found = output(s,D,v);
            },
            is: 'o',
        })
    };
    #c io.nz
    # converts p.rows to iteration or whatever
    $nz = &d{
        d ||= T.o;
        !d and throw "Can't find T.o"
        # takes over from o
        $t = ex({},d);
        
        # name columns
        t.arks = {};
        each i,pa d.path {
            pa.ark and t.arks[i] = pa.ark
        }
        # arks ||= {-1:s}
        # < Babz S io must know this
        if (!Object.keys(t.arks).length)
            t.arks[t.path.length - 1] = 's';
        
        t.oned = Object.keys(t.arks).length == 1;
        each ik t.arks {
            t.oned = k;
        }
        
        t.arky = ex({},t.arks);
        if (!t.arkimp) {
            # add anything else we can name but wasn't asked for
            t.arkimp = {}; # tarky not in tarks
            each i,pa t.path {
                !pa.t and continue
                t.arky[pa.t] || pa.ark and continue
                pa.t.match(/\W/) and continue
                t.arky[i] = pa.t;
                t.arkimp[pa.t] = i;
            }
        }
        
        # iterate per row
        t.i = 0;
        $pull = &{
            $row;
            while (1) {
                row = t.rows[t.i++];
                !row and return
                # only for complete rows
                !t.partial && row.slice(-1)[0] == null and continue
                break
            }
            return row
        };
        # grouping ar[k]=[v+] for implied names
        $parkar = &be{
            $ar = {};
            t.row = t.next || pull();
            !t.row and return
            delete t.next;
            each ik t.arky {
                ar[k] = t.row[i];
            }
            if (!t.ungrouped && !be) {
                # to group by, make sure enough of it changes
                # i #Con:/@#G:/@W o $mag/*:G/*:W
                # should iter for every Con and G
                #  with W=[W+] read ahead
                $first = 1;
                while (1) {
                    # get next one...
                    $be = parkar(1);
                    !be and break
                    $diff = 0;
                    each ik t.arks {
                        # if arked things change
                        be[k] != ar[k] and diff = 1
                    }
                    diff and t.next = be; break
                    each ik t.arkimp {
                        # or accumulate nonarked things
                        first and ar[k] = [ar[k]]
                        ar[k].push(be[k]);
                    }
                    first = 0
                }
            }
            return ar
        };
        #
        t.more = &{
            $ar = parkar();
            !ar and return
            # hash of values
            t.ar and t.prev = t.ar
            t.ar = ar;
            t.oned and return ar[t.oned]
            return ar
        };
        
        #c ind: callback per item, flat list with depth...
        t.ind = &cb{
            t.indstr ||= '  ';
            # recurse into p.nz?
            # < just like the idea of nz apparently,
            $la = [];
            $N = [];
            each i,row t.rows {
                t.row = row;
                # only for parents with children
                !t.partial && t.row.slice(-1)[0] == null and continue
                $unreal_depth = 0;
                each dv row {
                    v == null and continue
                    $pa = t.path[d];
                    pa.doof and unreal_depth++; continue
                    # same as last row, still at depth
                    la[d] == v and continue
                    # < t.d should probably be as row/path i...
                    t.d = d;
                    $s = cb(v,t);
                    s == null and continue;
                    if (typeof s == 'string') {
                        $ind = '';
                        each id,v row {
                            id == d-unreal_depth and break
                            ind += t.indstr
                        }
                        s = ind+s
                    }
                    N.push(s);
                }
                la = row;
            }
            return N
        }
        
        return t;
    };
    
    
    #c input see,
    # fills in an index with a value
    # total definition of z/tv indexes, which should be one of a few...
    # along with the z/tv positioning system, there's an element of
    #   wiring or linked lists via y&in, y&up, y&next, y&prev,
    #   left out for code volume
    # < index/join types should be curated nearby
    #   proto hard-coded...
    # tv:
    #    lots of C via tvs can hold anything, just stretched out.
    #      maybe if you're database you want to know things.
    #    < in exact mode should keep z sorted,  overwrite tv
    #    < in soft mode should not overwrite (el=1)
    #    
    # non-tv index/join types:
    #    I: could be known to be of/ov/t/cv?
    #    x/y/z: what's in space...
    #    beliefs in cv like subnets, having octaves of octaves,
    #      non-linear spaces, klein bottle public netspace
    #      lanes of stripes whipping around a torus, etc.
    #
    # 
    # s = data
    # d = [pa,th], puts at that path
    # d = {path:[pa,th],dup:&s{}}
    # does a single weld, usually C-C
    # carbon joint, some language in each place?
    # ignores the next/last/in/up wiring, let o do once sorted
    #   when it gives a kind of gravity,
    #   linearity to the stage that may not ever be there
    $input = &s,d,v{
        d = knowing(d,v);
        # return d here to extract what we know, kind of 2
        
        # now 3 deals with what really shall be and how we shall create it
        
        # climb container different? may A?
        # section of o, defined into several places... houses
        # this is the most high speed bit, copying bunches of C,
        # with a little lingeme sensitivity loaded in on the d,
        # which is a lunk for A, C, T rivering the reverberate of revision
        
        # climb index
        # d.ours ['nk','gk'], gets to the thing at the end of this thing
        # +
        # d.path ['Winning','0.1'] points of index, to the value
        # not the same d.path (or d) of i/o, is a lower level, manyer
        $path = (d.our||[]).slice();
        d.path and d.path.map(&p{ path.push(p) });
        
        $S = s;
        each ip path {
            i *= 1;
            $x = S[p];
            x && typeof x != 'object' and throw "index broken"
            # the last bit of our space: the universal
            #   could be something trascendant
            #   like being a thing with hooks, more our until path...
            d.our && i == d.our.length and d.on_our = x
            # done, leave S on second to last thing
            i+1 == path.length and continue
            # hash usual
            x == null and x = S[p] = {}
            S = x;
        }
        
        # S[p] may now = x
        # S[p] soon will = v
        if (d.t == 'z') {
            # or include it
            x == null and x = S[p] = d.zefault || [];
            x.constructor != Array and throw "z broken"
            #$xi = x.indexOf(v);
            # exact object ^, also could be claiming a tv had already (up at tv)
            # we shall start simply adding on, mentioning things more than once, etc
            # no information lost!
            # except the time of day, which is easy to find
            # dups constitute weirdness that should be cleaned up...
            #   before the system with it in goes production
            # < z_dup: handled on the o end, as z things not in tv, and tv_dup
            x.push(v);
        }
        else {
            # set thing to thing
            A.debug and debugger;
            if (x != null) {
                # already, noop?
                d.spacer || x == v and return x
                d.dup && d.dup(d,x,v) and return x
            }
            S[p] = v;
        }
        
        # multiple angles of have
        if (d.also) {
            each in d.also {
                typeof n == 'string' and input(s,n,v)
                else {
                    throw "What else", n
                }
            }
        }
        return v
    };
    
    #c output
    $output = &s,d,v{
        d = knowing(d,v);
        # path =
        #   our  - reaches from thing to its universal (nk,gk)
        # + path - into index (t,cv)
        # not the same d.path (or d) of i/o
        #   is a lower level, manyer
        # meta applies to non-our path only.
        $path = (d.our || []).slice();
        $mi = path.length;
        d.path and d.path.map(&p{ path.push(p) });
        
        # we only need to capture the endmost atoms at this low level
        # < rows is S in input... could insert multiple times if crazy
        d.rows = [[s]]; 
        # flow
        $i = 0;
        while (path[i]) {
            $k = path[i];
            $pm = i >= mi && d.meta && d.meta[i-mi];
            $rows = [];
            each ri,row d.rows {
                $S = row.slice(-1)[0];
                if (0 && i == mi && S == null && s.sc && ss&z) {
                    d.our.join('') != 'ytv' and throw "have ss&z, null our thing, but what is dour?", d.our.join('')
                    # we got to y.tv, but it seems to use z instead
                    # A:o used to mix all attachment methods together...
                    # suppose this is fine:
                    $tv = s.y.tv = {};
                    each in ss&z {
                        tv[n.t] ||= {};
                        tv[n.t][n.y.cv] = n;
                    }
                    S = tv;
                }
                if (S == null) {
                    row.push(null);
                    rows.push(row);
                    i++;
                    continue
                }
                $ks;
                if (pm) { # loose match, may many
                    # use z order? grep by tv?
                    # in the order they were set
                    pm == '*' and ks = Object.keys(S)
                    else {
                        # for WHERE k=v to be k>5, k~re
                        throw "meta",pm
                    }
                }
                else { # exactly what path[i] says
                    # but when to cast it first? never I spose.
                    $ok = typeof k == 'string'
                        || typeof k == 'number';
                    !ok and debugger
                    !ok and throw "nonstringstep"
                    ks = [k];
                }
                # < to sort, know fractional cv,
                #   with freaks, histograms, history
                # < if !x we could try as if 1=='',
                #   misspellings, round until found,
                #   using z a sorted z to scope up a cv faster...
                #   even resurrecting a J that looks similar
                each ik,k ks {
                    $x = S[k];
                    # extend row
                    $ro = row.slice();
                    ro.push(x);
                    rows.push(ro);
                }
            }
            d.rows = rows;
            # and add column:
            i++;
        }
        # take off columns not in the formula (A.r)
        
        $last_column = d.rows
            .map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });
        return last_column
    };
    
    #c iover
    io = ex(io,{F:F,i:i,o:o,input:input,output:output,parsetalk:parsetalk,nz:nz});
    return io;
    
t/iooia: |
    G&heading;
    $io = G&way,'iooia';
    G&way,'Doming',ar;
    
    $a = &t,talk,cetia,c{
        $params =
        cetia ?
            typeof cetia == 'object' ? cetia
            : cetia.split(' ')
              .map(&s{ return G&Cye,[s] })
        : [];
        
        $what = talk+(cetia ? " <--- "+ki(cetia) : '');
        m $t  $s:what %hue:200deg,dis:block
        
        $d = {};
        $r = io[t](talk,params,d);
        
        if (c) {
            # more awareness
            (c == 1 || c.show) &&
                m d_of_"+t+"  $s:d
        }
        $n =
        m $t  $s:r
        typeof c == 'object' and ex(n.c,c)
        return r
    };
    
    S 1 respec-talk
    a('parsetalk','w/*:w');
    a('parsetalk','trouble/w:r/#w:t','weeee',1);
    a('parsetalk','$t o $w/*','tea weas');
    # from the story of -respec:
    # o w/*:w
    # if problem with $w:
    #   i trouble/w:r/#w:t
    #   ts&dige = supposedtobe
    #   i $t o $w/*
    
    S 2 respec
    A.r = G&Cye,['iooia',9,{M:[]}];
    $now = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','weeee');
    
    $aw = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','walso');
    
    $aw = a('o','w/*:w');
    
    $w =
    a('i','trouble/w:r/#w:t','sweeee',1);
    ws&plat = 5;
    $aw = a('o','w/*');
    # too far
    $aw = a('o','w/*/*',0,1);
    $aw = a('o','trouble/w/*',0,1);
    
    $aw = a('o','*',0,{show:1,dl:5});
    
    
    $aw = a('o','*/*',0,{show:1,dl:5});
    
    
    #a('i','w:r/#w:t','well');
    #a('i','$t o $w/*','tea weas');
    
    
    S 3 i/o
    
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    $o = G&Cye,['blag','2',{s:'gakel'}];
    n attaching_to -fod $s:d,dl:14
    
    $N = io.i('$d/$o',[d,o]);
    $oN = io.o('$d/*',[d]);
    m enN -fod $s:N,dl:14
    m ouN -fod $s:oN,dl:14
    
    
    #c iteration
    S 4 iteration
    n ble 8 s:bmung %fs:600%,dis:block
    # so 'i $t' tv's each 'o $w/*:W', like 'i $t $W'+
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    'doofica latico matri vou'.split(' ').map(&s{
        $o = G&Cye,[s,'1'];
        i $d/$o
    });
    a('o','$d/*',[d],1);
    
    a('o','$d',[d],1);
    
    #$r =
    o $d/*:r
    
    $matri = G&Cye,['matri',1,{morematch:2}];
    
    $maN = a('o','$d/#matri',[d,matri]);
    
    $ma = maN[0];
    mas&cla = 'osi';
    
    $vong = G&Cye,['Viog',34];
    i $ma/$vong
    
    a('o','$d/*/*',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar,dl:5
    }
    m iterator  $s:t,d:8.22 %fs:120%
    
    $v =
    i $ma/#vong
    vs&latjkc = 42;
    
    a('o','$d/*:dui/*:s',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar,dl:5
    }
    m anotherator  $s:t,d:8.22 %fs:120%
    
    # reuse this pile of C
    1s&sandy = d;
    
    #c Monday
    =Monday' for all of them together:
    
      nz - nz=[(C,nz?)*]
        array-indented C, as a format to build like d.rows
        just like the idea, no immediate use.
        why make data look more like indented Lines?
        mere exercise
      
      io.nz - convert it to whatever,
          see iteration
    
      plumb:
        join an i from an o
      Functions:
        also:
            i $d/@whur/@lamb { s&fat && "laughter" }:whur o $lambs/*
        which:
          greps (by default?) and assigns value to whur
            which becomes a bareword to the i
          deciding where lambs go
          should have \ at end of line to continue expression...
        if no :arks in an i, uses last column,
        
        :whur ends up on the i tuple as a bareword, or C if C
        on-name symbols:
      <  -name delete!
         @name referring to other name, from func or plumbing
         #name just t/cv of v, which is doesn`t have to be set to
         $name is a var parameterised into the call
      <  name? calls match function?
      
       inbetween bits:
         { code code code }:name
           Babz auto return in sub`s last line
         becomes column
         greps if not named or named grep
         
         y
           cloning the C as it moves over...
           forget about using its .y.tv tho, see perspective
         yC,o
           means cloned.y.C = origin, origin.y.o = cloned
           and these have some knownness,
           should always be able to go C-ward?
         y-
           cloning C but disconnecting them from things we dont take with us
         
      perspective:
          as we i ... y o ...
          clones C as they pass into the i
          everything selected will need repointing to itself,
            as A:o does
          and trimming excess innards
          but maybe not if 
      
      future:
        knowing the protocol space to a delete is nice
        and operating work-isolatingly from a big sleeping set
      
      iteration:
        basically, get an iterator object:
          $t = io.nz()
        setup from T.o, the last i/o $d
        flat map like G&ind:
          t.ind(&s,t{ [t.i,s] })   # [ [depth,C]+ ]
          t.ind(&s,t{ ki(s) })     # [indented toLineses]
        iterate rows:
          ar = t.more() # named columns
          s = t.more() # if one ark/thing in total
        see code about grouping ar.unarkedfor into [v+]
        
        while(ar=t.more()) it
        or use Duning S with io in it
          which will be most of the time!
          the new way.
          once subnetting S so Swhiles of io can
            be used instead of for, each, etc.
            and the data-picking-through excercise can compile for specifics
        the $t then the cursor, which S shall:
          take care of, and:
            Babz: set vars from ar
            S: hold the cursor while J6s exchange, see J6ing
        
        < getting the corresponding p? who cares
        
        function should be able to set the ind fu
        
      
      J6ing
        a J6 is a J attempting to do itself,
          or something to do with itself, about dome consciousness
          and s if it works, like a commit
            or works enough for an s-level wake, like a savepoint
              and s should be the total picture of the game being J`d
        a J<6 is deciding on J6,
          doing small things, like e,
          then working out desire/skip/sleep potential,
            sometimes working on only such domes,
              but such work is J6ing.
        
        but 
      
      
      
      pipelining - no
      
      other stuff:
        function for #things spacer creation...
          is really mutating an object,
            creating a pointer to the origin
          could make loose matches too...
      
        p could be C, c&pa, s&z = [p+],
           s&found = [each s&zp`s row-1], etc
        multiplicity is strange
        want a grasp on the C got, something.c.s = C
          that can be many per p
        
        p A:o could A itself out:
        
        p could be A:o, becoming o@3 compatible via this open method
          so we can clone everything,
            but also disconnect the boundary to stuff unselected
          
          p could multiply so they can all c&s = $v ...
          they offer an alternative positioning system,
            according to the new gravity cast on it.
      
      
         bothered writing this?
         i $d/$o
         maybe we want 'd>o'
         magnetics want to... ranking, raking...
         for sorting the junkdrifts of culture

         < completing this -fod now so it sees d before io
           WHILE it`s an M thing would be something
           we will often be populating a populated space,
           starting a job with half the required information
        
    =cut
    # '
    
    #c hmmm 
    S 5 strange formats
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    o $d:lish/*/*
    # < solve this... if ark is singularly defined we could return it?
    #   and if many we could return them as whole columns...
    #   and only return last column when no arking
    m lish_var -jod $s:lish
    
    $t = io.nz();
    
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m inded  $s:s %hue:80deg,ws:pre,dis:block
    
    t.partial = 1;
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    
    # plumbing
    S 6 i<-o plumbing
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    
    $n = G&Cye,['upsulat','1',{s:'gakl'}];
    i $n:an o $d/*
    # i can set vars... use T.o if you unsure of 1/+ness
    $t = io.nz();
    m andasio_To  $s:T.o
    m andasio_varset  $s:an
    m andasio_tmore_once  $s:t.more()
    m andasio_tar  $s:t.ar
    m andasio_tmore_twice  $s:t.more()
    
    o $n/*/*
    $t = io.nz();
    m therowsofan  $s:t.p.rows,dl:8.16
    
    t.partial = 1;
    $s = t.ind(&s,t{ return G&toLines,s }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    # S
    S 7 domeration
    
    m todo  s:todo
    
    
    
    # grep
    S 8 functions
    
    m todo  s:todo
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 12;
    }
    
t/iooiata: | # func really
    G&heading;
    $io = G&way,'iooia';
    
    #G&way,'Doming',ar;
    S 1 LOvely
    $start = 
      "upsulat\t\ts:gakl\n"
     +"  doofica\n"
     +"  latico\n"
     +"  matri\t\t\tcla:osi\n"
     +"    Viog\t\t\tlatjkc:42\n"
     +"    Viog\t34\n"
     +"  vou\n";
    $d = 1s&dee = G&readLines,start [0];
    
    $a = &t,talk,params{
        if (t) {
            $d = {};
            io[t](talk,params||[],d);
        }
        $t = io.nz();
        m $talk  $s:t,dl:9.26
        
        t.partial = 1;
        $s = t.ind(&s,t{
            return G&toLines,s
        }).join("\n");
        m indy  $s:s %hue:120deg,ws:pre,dis:block
        
        t.p = 'usual';
        return d
    };
    
    a('o','$d/*/*',[d]);
    
    o { Object.keys(C.sc).length }:tings $d/*/*
    a(0,'funclast grep by sc length');
    
    
    
    #a('$d
    
    # needs z interpreted as tv
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 12;
    }
Duning: | # avalanche of activatuio
    # S as steps of transformations, some linear?
    # S as moments to do o, sleep/wake culture
    # S as functions to map things inside (M) or outside (N/U) this J
    #  M works on 1's M, what we have
    #  N works on 2's M, where we are
    #  U works on 3's M, Wunity of things we are foorming:
    #   3's M, as A-climbed to its A.r, root9 molecule,
    #    haver of domes, so these in-pi can collaborate
    #    look and respond waves going wide, weaving
    #    with one big object index, etc.
    #    craziness is being joined up on A.3
    
    # < S still for late osc? Swum things?
    #   S 8... could make &{} instead of while wrap
    #     B carefully when calling such
    # could be a nice place to reboot subroutines actually...
    # < S for elvis handle
    
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    
    
    # A-climb, for the right levelled A.r (pool, what)
    # which will eventually be the root and root dome and ground
    # 3's is a big room of stuff,
    #   hmmm
    $Ask = &s,k{
        typeof s != 'number' and throw "Ask for num"
        # climb up
        $Y = A;
        $lim = 30;
        $want = A[s];
        while (Y.1 != want) {
            Y = Y.up;
            !lim-- and throw "Ask huge"
        }
        # 
        k == '' and return Y
        if (k == 'rc&M') {
            $r = Y.r;
            # r R? the soft int
            !(rc&root || rc&dome) and throw "isDome"
            !rc&M and throw "not rcM",r
            return rc&M
        }
        if (k == 'C') {
            !Yc&s and throw "NoC!"
            # isC, when it inlines
            return Yc&s
        }
        throw "What at?", Y
    };
    # arg eater
    # eat args for S
    $meater = &d{
        $m = [];
        m[0] = &r{
            m = d.match(r); # += /(?: |$)/ somehow
            !m and return
            m.shift();
            d = d.replace(r,'');
            return m.length == 1 && m[0] ? m[0] : 1
        };
        return m
    };
        
    
    # sequences/numbered:
    #   could fractionate across A.3, shelved somehow...
    #   having a limb inside J6, wh
    # they diff island on the dome, working on array
    # 
    # Duning S might return a variable, making for iteration
    # < Babz this in somehow
    # or fetching (Ask()) something another M, 3's M is called N
    # < something should be able to takeover which S we want to go for, too...
    
    # for G&Ban to find these subs:
    $way = Gc&B.sc.way;
    A&S = &s,t{
        # B will be i/S
        Gc&B.sc.way = way;
        typeof s == 'number' and throw "doing seq"
        $g = A&doming(s);
        
        # non-iterative dome again?
        !g and return
        $m = meater(s);
        #debugger;
        $p = m[0];
        # $s='as last N'
        if (p(/as /)) {
            $limit = p(/(first|last) /);
            $M = p(/U/) ? Ask(3,'rc&M')
                :p(/N/) ? Ask(2,'rc&M')
                :p(/M/) ? Ask(1,'rc&M')
                : '';
            !M and throw "noM?",s
            if (limit) {
                $C = Ask(1,'C');
                $O = limit == 'first' ? M.slice(0,1)[0]
                    :limit == 'last'  ? M.slice(-1)[0]
                    :'';
                !O and throw "noO?",s
                C != O and return
            }
            return M
        }
        else {
            # T out the other
            #$M = 
            $notes = [s,t];
            m called_S -jod $s:notes
        }
        
        #throw 'edge of reality', [s, t]
        return 1;
    };
    
    #c A&doming like Doming:
    # For Duning:
    #  may not ground all domes,
    #  they may be ephemera, even error/message channels
    #  in a spinal nervous system awareness
    #  where hs&z makes for stuff toward rs&z
    #  but we might have hs&Errors, hs&Msgs... other dimensions
    
    #  should A.r be taken over by the current dome? supposedly.
    A&doming = &t{
        # resets a chunk of reality,
        # a group of o that may flatten or hide from s
        # A.ground.sc.z (or A.r.sc.z, or ra&z) is the main wWw
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A.ground = g;
        # soon:
        #!gc&root and throw "root of ground not", g;
        
        # one A&doming gives all the domes to ground
        # < what meaning for Duning?
        #   
        if (1s&domes && !gc&domed) {
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        if (h) {
            # never repeat Duning?
            # depends on the mode,
            # S and C iterator
            return;
            # 
            # reset, o maintains it in the beginning of s, 
            hs&z = [];
        }
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        # Duning doesn't step into the dome, merely holds it
        #A.ground = h;
        #G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
        return h;
    };
    
StayToSleep: | # gentleness scan
    # 
t/BuildACastle: | # test Duning and io
    # ones
Fly: |
    G&heading;
    G&way,'t/iooiata',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
grow: | # spraw Js&ope qua
    # there must be a S/C/A clicky scheme attacher somewhere
    $Y = c.y.A.1;
    Ys&ope ||= 0;
    Ys&ope += e.t.includes('C') ? -1 : 1;
    ~Told: ki(Y), ki(Y.3)
pi/fod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # where was above? 2Cc&d was going to do this...
    $u = A.n.up.n.c.s;
    c&d ||= uc&d || 1;
    c&d > 1 and ys&ml = (c&d - 1)+'em'
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    $dl = c&dl || 3;
    1s&ope and dl += 1s&ope;
    
    $es = c&s;
    es = ex({},es);
    if (es.path) {
        $p = es.path;
        delete es.path;
        each in p {
            m path -fod $s:n,d:2,dl:7
        }
    }
    if (es.p) {
        $p = es.p;
        es.p = ki(p,4.22);
        c&p == 1 &&
        m psomething -fod $s:p,d:3,dl:7
        if (c&p && c&p != 1) {
            $s = p[c&p];
            m psomething -fod $s:s,d:3,dl:7
        }
    }
    if (es.plumb) {
        $p = es.plumb;
        delete es.plumb;
        m plumb -fod $s:p,d:3,dl:7
    }
    
    
    
    G&n,['Thing',3,{s:ki(es,dl)}];

