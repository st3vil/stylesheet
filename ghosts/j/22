Wed: |
    # use Mojo, serve ghost/
    saygr "Being Wed in ".(Gc&ipd || Gc&dir);
    
    u Wedpagery
    
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    # divert mojo log statements from our err channel
    app->log->path((Gc&ipd || Gc&dir)."/mojo\.log")
        if Gc&dir || Gc&ipd;
    
    
    no warnings qw(uninitialized redefine);
    
    #G.c.listen = readlink('listen') if -l 'listen';
    my $s = Gc&bay . '-Wed';
    my $port = Rw Numstring $s;
    Gc&listen = '127.24.35.46:'.$port;
    my $s = Gc&listen || "s:10094";
    $s = "http://$s" if $s !~/^http:\/\//;
    
    S
    # forever
    n Baye
    
    # to remain verbose
    my $A = G&A,'requesto';
    A.V = 1;

    get '/' => &c{
        my $U = G&t,html=>'index';
        my $s = Uc&s;
        $s =~ /html/ || die "Not html? ".ki $U;
        sayre "Giving start";
        $c->render(text=>$s);
    };
    
    get '/thestart' => &c{
        my $i = $c->param('step') || 0;
        sayre "T wants to start at $i";
        my $next = "/thestart?step=".($i+1);
        my $s = Rw StartHut $i $nocache=1
            || return
                $c->render(text=>"document\.title = 'Gc&bay';"
                    ."G\.h(A,C,G,T,'c','starteeed');"
                    ."A\.sc\.start\.push('/andnow');");
        $c->render(text=>"A\.sc\.start\.push('$next');\n$s");
    };
    get '/andnow' => &c{
        $c->render(text=>"G\.h(A,C,G,T,'begoin');");
    };
    
    # W as <script> js include
    get '/js/:t' => &c{
        my $t = $c->param('t');
        $t =~ s/\.js$//;
        my $ver = $2 if $t =~ s/^(\w+)-(\w+)$/$1/;
        my $C = G&Ct,[$t,'',{ver=>$ver}];
        my $s = Rw NutServe $C;
        $s || return $c->res->code(404), $c->render(text=>"Not found\n");
        
        my $loca = '/js/'.C.t.'-'.c&ver.'.js';
        #$c->redirect_to($loca);
        $c->res->headers->append(Location => $loca);
        $c->render(text=>$s);
    };
    get '/earer' => &c{
        my $dat = $c->param('data');
        #$dat = djson($dat);
        my $s = G&Ct,[earer=>''=>{s=>$dat}];
        my $el = [give=>''=>{s=>$s}];
        my $W = [Wederr=>$el];
        G&timer:0.1,&{ 4s&toy->({to=>[$W]}) };
        $c->render(text=>"hmm\n");
    };
    #c other Wedery
    # handlers for image receiver
    Rw Tism;
    
    websocket '/s' => &s{
        1 && sayyl "Connect!";
        die "No GWebsock yet" unless G.Websock;
        G.Websock->($s);
    };
    
    Gc&clockon = &{
        Gc&startedclockalready ++ && return sayre "Trying to start again";
        1 && saybl "Starting  G.t     listens: $s";
        1 && saygr "Appstart: ". app->start('daemon', '--listen' => "$s");
    };
    
    # then later within the timer...
    
    my $txm = 1s&txm ||= [];
    my $pend = 1s&pending ||= [];
    my $rec = 1s&recent_ha ||= {};
    # handle each...
    G.Websock = &s{
        1 && say "Web is socked!";
        my $tx = $s->tx;
        push @$txm, $tx;
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        
        $s->on(message => &M,m{
            #}
            $m = encode_utf8($m);
            1 && sayyl "Message from $addr ".$m;
            
            my $ha = dig $m;
            $rec.>$ha ++ && sayre("Duplicate") && return
                Rw linkrement request_dupe;
            G&timer,0.3,$_ for &{ delete $rec.>$ha };
            
            
            my $d = eval { djson $m };
            $@ && die "Message doesnt decode: $@\n\n$m";
            
            ref $d ne 'HASH' && return saybl "Weird message: $m";
            
            
            if (my $W = d.W) {
                -d $W || die "Not a host: $W";
                my $in = "$W/in";
                my $s = G&Ct,[Win=>[jse=>''=>{s=>$d}]];
                write_file($in,{append=>1},sjson($s)."\n");
                sayre "sent $W: ".ki $d;
            }
            else {
                sayre "freak e: ".ki $d;
            }
        });
        
        $s->on(finish => &M,code,reason{
            @$txm = grep { $_ ne $tx } @$txm;
            1 && sayre "Gone: $addr $code $reason";
        });
        
        G.Websup->() if G.Websup;
        
        if (@$pend) {
            saygr "Sending pending messages: ".@$pend;
            G.Websen->($_) for @$pend;
            @$pend = ();
        }
    };
    
    G.Websen = &m{
        # $m = decode_utf8($m); # comes from inside
        unless (@$txm) {
            sayre "No client, pending: ".slim 50, $m;
            push @$pend, $m;
            return;
        }
        1 && saybl "Sending ".slim 2050, $m;
        for my $tx (@$txm) {
            $tx->send($m)
        }
    };
Wedpagery: | # starting page
    # use the js filter, store in ...
    index: %js:html
        <!DOCTYPE html>
        <html><head>
          <style type="text/css">
              @font-face {
                font-family: DVSM;
                src: url('DejaVuSansMono.ttf');
            }
            body {
                font-family: DVSM, mono;
            }
            ww *, .ww { pointer-events:none; }
            ww * *, .ww * { pointer-events:all; }
          </style>
          <link href="light.css" rel="stylesheet"></link>

          <script src="codemirror/lib/codemirror.js"></script>
          <link href="codemirror/lib/codemirror.css" rel="stylesheet">
          <link href="codemirror/theme/night.css" rel="stylesheet">
          <link href="codemirror/theme/midnight.css" rel="stylesheet">
          <link href="codemirror/theme/base16-dark.css" rel="stylesheet">
          <script src="codemirror/mode/perl/perl.js"></script>
          
          <script src="paper.js"></script>
          
          <script src="jquery.min.js" type="text/javascript"></script>
          <script src="js-yaml.min.js" type="text/javascript"></script>
        </head>
        <body style="margin: 0px; background: black; color: #0d2; height:100%; width:100%;">
          <div id='msgs' style="white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:50%;height:28%; overflow:hidden;padding:0.2em;color:#abc;z-index:200" onclick="G.keon();G.clon();G.togwid('#msgs','50%','5%');" > </div>
          <div id='ux' style="position:absolute;top:0em;
          right:0em;width:100%;height:100%;" class="ww"> </div>

          <canvas id="display" resize></canvas>

          <script type="text/javascript">
            var A = {c:{},sc:{}};
            var C = {};
            var G = {};
            var T = {};
            A[5] = A[1] = A;
            a&elvis = Math.random();
            a&start = ['thestart'];
            A&start = &s{
                if (s) {
                    eval(s);
                    //var m = s.split("\n");
                    //$.each(m,&i,v{ eval(v); });
                }
                if (a&start.length) {
                    $.ajax(a&start.shift()).done(A&start);
                }

            };
            $(document).ready(&{
                A&start();
            });
          </script>
          </body></html>
Wederr: |
    # is web dialect
    Rw Tiot;
    # accumulates errors
    Rw Elationist;
    S
    1s&M ||= [];
    1s&M->[-1] eq 1c&es || push @{1s&M}, 1c&es;
    my $i = 0;
    for (@{1s&M}) {
        my $c;
        c.s = $_;
        c.dl = 1 if $_ ne 1s&M->[-1];
        n $i++=>-od=>$c
    }
    
    
NutCore: | # core is a personality for relationships between things
    # stuff to one day compile into the throat
    # or boundary effects
    # points for things respected by other things
NutServe: | # turns js W into a <script> with toc in C
    delete G.way.NutServe;
    
    C.t && exists c&ver || die "C not like t/ver: ".ki$C;
    
    # look in the javascript u stash
    local A.6.t = 'je';
    my $f = G&Locate_read,C.t;
    $f || return;
    # storage dep
    my $l = "$f/1";
    my $li = readlink $l;
    # find version
    my ($ver) = $li =~ /^h\/(\w+)$/;
    $ver || die "not h/dig looking: $li";
    $li = "$f/$li";
    # specify version
    if (c&ver && c&ver ne $ver) {
        $li =~ s/$ver$/c&ver/ || die "Cant find $ver in $l";
        $ver = c&ver;
        -f $li || warn("Cant find C.t at ver=c&ver,"
            ." try the $ver?"), return;
    }
    c&ver = $ver;
    # get C
    my $d = G&Beach,$li if $li;
    $d || die "No such C.t in Gc&bay je etc ($li)";
    
    sayre "Found C.t W in $li";
    ($d) = @$d;
    T.op = $d;
    my @W = G&op,'cW:javascript';
    
    # cache by t/ver
    # first function, on the first line, should be a toc
    # one item per line of it, including line number ranges
    my $D = G&Ct,[C.t,'',{},{ver=>c&ver}]; # toc
    my $zI = Ds&z = []; # Is
    my $N = []; # flat list, to include toc
    for my $I (@W) {
        (my $Icv = I.y.cv) =~ s/^0\.//;
        for my $i (@{Is&z}) {
            (my $icv = i.y.cv) =~ s/^0\.//;
            my $name = join'_',C.t,c&ver,I.t,$Icv,i.t,$icv;
            $name =~ s/\W+/_/g;
            is&name = $name;
            ic&s =~ s/^function/function $name/
                || die "Doesn't ^function: ".ki $s;
            push @$N, $i;
        }
    }
    
    for my $i (@$N) {
        ic&s =~ /\n$/ || die "No trailing \\n: ".ki $i;
        my $lines = split "\n", ic&s;
        is&lines = $lines; # also ^function...{\n and \n}\n$
    }
    
    my @toc; # [ind t y c sc]+
    for my $I (@W) {
        (my $Icv = I.y.cv) =~ s/^0\.//;
        push @toc, ['',I.t,I.y.cv,I.c,I.sc];
        for my $i (@{Is&z}) {
            push @toc, ['  ',i.t,i.y.cv,i.c,i.sc];
        }
        delete Is&z;
    }
    
    my $toc_lines = @toc + 3; # also ^function...{\n and \n}\n$
    my $code_lines = 0;
    for my $i (@$N) {
        is&line = $toc_lines + $code_lines;
        $code_lines += is&lines;
    }
    
    my @codes = map { delete _c&s } @$N;
    
    my $name = join'_', C.t, c&ver ;
    $name =~ s/\W+/_/g;
    
    my $s = join "",
        "function $name () { return [\n",
        # data and code has indent
        (map { $_->[0].sjson($_).",\n" } @toc),
        "]}\n",
        @codes;
    
    return $s;
        
    
    return wdump 5, \@toc;
    
    
StyleNut: | # unify NutMachine (newer) and Stylehut
    n Stylehut
    # newer, absorb-all
    n NutMachine
HutNuts: | # extra ballsy refactoring starts (in Stylehut)
    # i pull things in
    # to be NutDung later
    u j
    begoin:
        A.on = $('body')[0];
        // preliminary
        $cb = &t,ver,script,e{
            G&Jinthe;
        };
        G&jsung,'NutMachine',null,cb;
    
    # A gets flock of A.I.? made from a W
    # as <script> via NutServe and the /js/$t-$ver handler 
    #  the G of the webserver and /je/ is Where
    # to mix as in u:
    #   several A get this function to fill their A.I somethings
    #   then they all get osc for a J, or A=u for speed
    #   then this sorting together of A.I can be much faster...
    # < a&async || die?
    # we get it first to read the proper Location
    #   so the <script> tag src is exact
    # < dependency/housing
    jsung: %acgt:t ver cb
        $get = '/js/'+t;
        ver and get += '-'+ver;
        $.ajax(get).done(&s,t,c{
            t != 'success' and throw "Failed request: "+t, c;
            $src = c.getResponseHeader('Location');
            $m = src.match('^\/js\/(\\w+)-(\\w+)');
            $W = m[1];
            $ver = m[2];
            $callback = &script,e{
                $tocfunc = W+'_'+ver;
                console.log("Have a toc: ",tocfunc);
                $toc = window[tocfunc]();
                $D;
                $.each(toc, &k,v{
                    $ind = v[0];
                    $t = v[1];
                    $cv = v[2];
                    $c = v[3];
                    $sc = v[4];
                    $C = {t:t, y:{cv:cv}, c:c, sc:sc};
                    if (ind == '') {
                        D = A.I[t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        Ds&z ||= [];
                    }
                    else if (ind == '  ') {
                        D.t != s&js and throw "Csjs not last D", C, D;
                        c&code = window[s&name];
                        typeof c&code != 'function' and throw "Cccode not function", C, D;
                        // grow I
                        D.y.tv[C.t] ||= {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        $l = Ds&z.slice(-1);
                        l[0] and l[0].y.next = C;
                        Ds&z.push(C);
                        D.y.in ||= C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = c&code;
                        }
                    }
                    else {
                        throw "deep C: "+W+"/"+t,v
                    }
                });
                
                
                cb(t,ver,script,e); 
            };
            G&addscript,src,callback;
        });
    
    addscript: %acgt:src cb
        var script = document.createElement('script');
        script.setAttribute('src', src);
        script.setAttribute('type', 'text/javascript');
        cb and script.onload = &e{ cb(script,e) };
        A.on.appendChild(script);
NutMachine: | # totality of core js-ness
    n NutWorld
    n NutProcess
    n NutErupts
    
NutWorld: | # 123 sheer being
    n NutSeq
    n NutDung
    n NutJay
NutProcess: | # TODO 456 resonance
    return;
    # the o
    n NutCertainty
    # the s
    n NutConsciousness
NutErupts: | # TODO standards
    # c&e/J requests
    #n NutElve
    
    # 72 load/save
    #   should be in Dung
    #n NutPlacement
    
    # 8 numbers
    #   nice ways above the tubing
    #n NutInt
    # ^ contains:
    # 9 talkying
    #n NutTal
    
    
    # house gets ThArt (StripesEdge, Space)
    #   StripesEdge is one thing with an index of Styles in Ang
    #     Ang is Stripes and Oscgrin,
    #     the universals that format and the functions that do so
    
    # hut/Nut should get its side of the styles...
    # 
NutSeq: | # self
    # some use of of=eye, which G&h searches like of=i
    # and StartHut/LoadI blows away each A.I.? it loads up
    # we shall om/receive news as N, functions in eye
    n NutAye
    n NutSea
    n NutTub
NutAye: | # A without tubeyness
    u j
    n \'of:eye'
    # begin being, A
    # they can take over names within their network
    #   // slopa, as def NutCore
    #   A.om ||= A;
    #   A.om == A.up and A.mo = A;
    #   but such a name may need update as B (sub calls) revamp
    # also drops A.V for verbose, use T
    Aye: %acgt:s ov c sc
        if (s && typeof s == 'object') {
            A = s;
        }
        else {
            $V = A;
            A = $.extend({},A);
            A.t = s;
            A.y = A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            
            A.up = V;
            A&ip = (upA&ip||[]).slice(0);
            upA&ipi ||= 0;
            A&ip.push(upA&ipi++);
            A&sip = A&ip.join(' ');
            
            // trip A
        }
        c and $.extend(A.c,c);
        sc and $.extend(A.sc,sc);
        
        if (ov && ov*1 == ov) {
            A&ov = G&sca,ov;
            G&thro;
        }
        return A
    
    # utils/inlineables
    #  is cv=0 allowed?
    sca: %acgt:s precision
        s && s*1 != s and return
        while (s >= 1)
            s /= 10
        return s.toPrecision(precision || 4)
    
    # descript/mapself
    
    
NutSea: | # line etc into C
    u j
    n \'of:eye'
    # 
    # ReadLines, G&m? G&A?
    # guess s={} = C
    # guess s=[] t y c sc, like n t y c sc
    # guess c='Line' or c.s='Line' c.as='z' c.from=upC, 
    #   so lines can have normalcy/decompression
    # the enclosure adds to the C,
    # with respect to the thing holding it, upC, C.y.up
    # putting in its ytv etc
    # C.t != null
    # where should C.y.cv ||= 0.1?
    # 
    Cye: %acgt:s c
        $C = {};
        if (s.constructor == Object) {
            if (null != s.t && C.y && C.c && C.s) {
                C.t = s.t;
                C.y={};C.c={};C.sc={};
                $.extend(C.y,s.y);
                $.extend(C.c,s.c);
                $.extend(C.sc,s.sc);
                return C
            }
            else {
                throw "Unhandle hash C: ", s
            }
        }
        else
        if (s.constructor == Array) {
            C.t = s[0];
            C.y = s[1];
            C.c = s[2];
            C.sc = s[3];
            typeof C.c  === 'string' and C.c =  G&peel,C.c
            typeof C.sc === 'string' and C.sc = G&peel,C.sc
            // < extra -pi
        }
        
        !typeof C.t === 'string' and throw "Non string t: ", C;
        
        if (typeof C.y == 'string' || typeof C.y == 'number') {
            C.y * 1 != C.y and throw "Non number y left: ", C
            C.y = {cv: C.y };
        }
        C.y.cv < 0 and C.y.cv *= -1;
        C.y.cv > 1 and C.y.cv = G&sca,C.y.cv;
        
        C.c ||= {};
        
        C.sc ||= {};
        return C;
    
    # utils/inlineables
    # peel, xo/xoh
    
    # and a bit of xotila
NutTub: | # A tubeyness
    u j
    n \'of:eye'
    
    # subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO Gc&B stacking
    # TODO G.i.* = A.I.i.y.tw.*.c.code
    hhh: %acgt:s so st sh sf si
        $z = s;
        typeof s === 'string' and z = G.t(A,C,G,T,'i',s);
        typeof s === 'string' && !z and z = G.t(A,C,G,T,'eye',s);
        !z and throw "No way: "+s;
        T.D = z;
        return z.c.code(A,C,G,T,so,st,sh,sf,si);
    
    # do I for C (A&s): go, stop, mode
    # jog job through embryo A.t
    # up to ov
    thro: %acgt:ov sC
        $T = A&T = A&T || {};
        T.not and return
        ov and A&ov = G&sca,ov;
        sC and A&s = sC;
        C = A&s;
        $t = G&t,A.t;
        !t and throw "thro no t: "+A.t, A;
        
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            T.not and break
            var D = z;
            z = z.y.next;
            
            A.c.cv > D.y.cv and continue
            C = A&s;
            if (!D.sc.any) {
                D.sc.nk and !C[D.sc.nk] and continue;
                D.sc.gk and !C[D.sc.nk][D.sc.gk] and continue;
            }
            $es;
            D.sc.gk and es = C[D.sc.nk][D.sc.gk];
            D.sc.s and es = D.sc.s;
            G.h(A,C,G,T,D,es);
            T.N and A.cv = 1; 1s&N
            T.not == '2' and return delete T.not;
            A.c.cv = D.y.cv;
        }
        return !T.not;
    
    
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    
    # toplevel n-tering
    om:
        A$ = G&A,'om';
        s and C = s;
        C$ = G&inC,C;
        C.y.A = A;
        t$ = T;
        T$ = {};
        if (t) {
            t.d and T.d = t.d + 1;
        }
        A&T = T;
        G&throat,2,C;
        T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
        s&css ||= {};
        s&anc ||= {};
        G&throat,7;
    
NutDung: | # getting things/I
    u j
    n \'of:eye'
    # bring W and the I's insides together into a namespace
    #    I has I.? and I.?.?
    #    I.? gets talked about by many W, projected by many
    #    though it (eg C.t='i') may not be in Where,
    #    it would be more realistic to mix into A etc from names,
    #    containing personalities
    # so all W-ish things are equal
    # could even find that some remote W contains an I.? thing it wants,
    # and decide to use it
    ting: %acgt:t ver
        // blocking unless a&async
        // get content from
        $get = '/js/'+t;
        ver and get += '/'+ver;
        $.get(get);

    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    # wants to be able to jump up the slope,
    # want a type, like http's Accept header,
    #   so G&ting can upstantiate it
    #   things coming alive because of this will have thresholdia
    #   do you want to trust someone else's version of t,
    #   or do you run all the simulations yourself?
    # 
    # < elvis a J for it
    #   esp. if you can resync when it's downloaded
    t: %acgt:s t
        var z;
        $.each([1,2,3,4,5], &i,v{
            z and return;
            var Y = A[v];
            !Y and return;
            var I = Y.I;
            !I and return;
            z = I[s];
            t and z = z.y.tw[t];
        });
        return z;
    
NutJay: | # persistent thing, all usual
    u j
    n \'of:eye'
    # quank the repeating part
    # s would be the W on the server to try and ws
    # begins
    # 1s&N are A/C wanting attention/typing in
    Jinthe:
        A&ws ||= 1;
        
        window.onerror = &e,r,o,l{
            console.log("Window error: ",e,r,o,l);
            return;
        };
        
        A.1 = A.2 = A.3 = A.4 = G&J,'Four';
        1s&N = []; // for A/C workload
        // 1s&z etc for showing state
        
        
        // our s&Jholder
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&cl,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&ke,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        // G&sockneck;
        4s&ws = G&Aye,'ws',9;
        
        G.clon(); G.keon();
        
        
    # run funnel
    Jin:
        1s&N
        G&A,A
    
    # sproutling
    J:
        $V = A;
        $A = A.1||A;
        $J = G&Aye;
        // on a chain
        J.2 = J.1;
        J.1 = J;
        // that pulls to Nine, like A
        Js&N ||= [];
        return J
    
    # each s/page/C context/sphere/drain it has,
    # has an up to dateness, where the other language joins on,
    #   like ws, can push/want updates through
    #   when drain C's yA's a&v (J-ish version) or A&sip changes
    #   or the C could be getting checked/o'd more often the usual
    #   
    #   looking at drain things' A's ip? or its A.c.v-ersion?
    #   or A.4+1's ip being more recent?
    #   want to wind up any A in drain <= 6?
    #   the s's M's As and Cs, the sources of what's on the page, change
    #   so there can be a way to encode a s's source/ingredients as an s
    #  and vaguely the last ip number of A.4+1 being > that remembered
    #    that remembererd ~= encoded as universal view of the A holding stuff
    #   means 
    # the ipi of the A.4+1 on the  
    
    
    # s&v will be a version/timestamp
    # t will be Where it is
    # cv some kind of trust/doneness feng shui,
    #   likely to separate many of the same J
    # c/sc ongoing house of definition,
    # to be sprung out by pin
    #  which is to draw the usual picture,
    #  and define hooks/elvising,
    #  so as to create services and lingo/policy for other morphologies
    #  and physics for interaction
    
    #
NutJaying: | # how to sequence a J
    u jc
    n \'of:n'
    
    # A.ground? A.place? ||= 1s&place ||= G&sJ,'place'
    # haul long blogs into long J with many bits of place
    # or page or ...
    # they want to commit or abort, be histree for o
    # and be a collection of in-progress C for slow/scattery J
    n 1:
        A.mo = $A;
        C.y.A = $A;
        # deal with real space?
        C.y.cv = 0.1 if C.y.cv eq '';
        C.y.cv *= -1 if C.y.cv < 0;
        C.y.cv *= 0.1 until C.y.cv < 1;
        if (my $g = !A&nogro && A.ground) {
            push @{gs&z||=[]}, $C
        }
    
    # various dynamics to the same basic particle
    pi 12:
        pi || die "Give pi: ".ki$C;
        c&J = "pi/$pi";
    
    # just looking for W, maybe retrieve static?
    # < using T.Z somehow to say jump to 8 after 2,
    #   might be useful for always tripping trips
    V 12:
        c&W = $V;
        A&twotoeight = 1;
    
    # networkily named thing
    W 12:
        ref $s && die "ref cW";
        $W = c&W = C.t if !$W || $W eq '1';
        c&J = $W;
        A&Jup = A.4;
        A&Jcv = 0.1;
        s&W = $W;
    
    # look it up
    J 2:
        T.oT = A.mo.up.mo.c.T;
        my $J = s&J && return;
        A&Jup ||= A.1;
        A&Jcv ||= C.y.cv;
        
        $J = G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv
            unless A&nomem;
        
        s&J = $J;
        
        if (A&twotoeight) {
            T.oT.op = $J && Js&s && Js&s.sc.top;
            return T.not = 1;
        }
    
    # J encode π 
    # previous J is A.2, may differ from "above" J in J.2
    # esp in W-W situ, their J.2 is A.4/A&Jup
    J 3:
        s&J ||= do {
            !A&nogro && sayyl "J ! C.t".(c&pi && " C.y.cv -".c&pi);
            G&J,A&Jup,C.t;
        };
        A.2 = A.1;
        A.1 = s&J;
        A.3 = s&J.3 = s&J if c&W;
        1c&s = $C; # particle holds passing wave, may tangle
        1c&T = $T; # and that, why not
    
    pi 3:
        s&pi = $pi;
        1c&d = 2c&d + 1;
    
    # W 31 trips
    # W 31 typed - notes W-W connections
    # W 32 Static, if bay/sac/$W forces c&pretend = Beached
    # W 34 thawJ, operates c&pretend
    # e 36 tugs A=E for c&e
    
NutSock: | # websockets
    u j
    n \'of:ws'
    # give A websocket
    #   winds itself back when disconnected
    # spawns:
    #   A=send when you G&h,a&send,'YourString'
    #   A=receive when the a&receive happens, which sends 
    #   and A receive (or whatever you set a&receive)
    #   put in a J=tel to be recording stuff,
    #     making compressions
    # use A to hold event-emitting things that will spring more A
    start 2:
        a&ws && a&ws.readyState == 1 and return
        
        A&ws ||= 'ws://'+location.host+'/s';
        
        $ws = a&ws = new WebSocket(A&ws);
        
        ws.onopen = &{
            ws !== a&ws  and return ~sockalivedupe: A&ws
            delete a&dead;
            
            ~connected: s.s
            $('body').stop().css('-webkit-filter', '');
        };
        
        ws.onclose = &{
            ws !== a&ws  and return ~sockalivedupe: A&ws
            a&dead = (a&dead||0) + 1
            
            ~closed: s.s
            $('body').stop().css('-webkit-filter',
                'blur(1px) brightness(1.3) contrast(2)');
            
            // wanting T.N=1 to do so
            A.cv = 0.1;
            1s&N.push(A);
            $delay = 250
            T.N.1.500;
        };
        
        ws.onmessage = &ev{
            a&receive(ev.data,ev);
        };
        
        // to be G&h,wss&send,'YourLines'
        a&send = &Y,C,G,T,s{
            $A = G&Aye,'ws',9,{Y:Y};
            // test coverage:
            c.readyState !== 1 and ~sockdropped: s, s
            // if too long?
            typeof s != 'string' and s = JSON.stringify(s);
            c.send(s);
        };
        //a&receive =
    
        // wanting T.N=6 to do so
        A.cv = 0.6
    
    
    # try sockneck again every .25 seconds
    # then every 2.5 seconds
    sockrecon:
        var t = 25000;
        s.fail++;
        s.fail < 100 and t = 250
        ~sockrecon: s.fail
        G&yl:t,&{ G&sockneck,s };
    

