TripDeck: | # note vortex, bakes patterns into info
    G&heading;
    1s&empathy = 4;
    1s&ein.have = &acgts{
        1s&have = s;
    };
    'Fly'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    S
    $s = 1s&have;
    #s ||= "UNDEFINED";
    n is -jod_2 $s:s
    $es = &{ return [1,2,3,4] };
    var N; if (N = es()) {
        m anatom -jod $s:N
        M.length > 2 and es = &{}
    }
    
    # this would be a good place to start
    # 
    
    $se = G&way,'PseudoF',{s:s,d:'*'};
    #n ies -jod_2 $s:se
    se = se.slice(0,10);
    each in se {
        #m istium -jod $s:n
        $t = "msg"+i;
        $c =
        m $t -ABf $s:n
        # cs&J = ns&J;
    }
    # where they will stash their A + any A noted nearby
    A.r.y.A.ontula = [];
    #A.ontula = [];
iooia: | # F > i/o > input/output
    # these will all be G&F, G&o, G&i...
    
                    # round until found
    
    # other possible types of thisness:
    # - G&s for writing notes for itself
    #   using traces left by i/oing etc nearby
    #   doing crazy implicit templating
    #   throwing universal weight around
    #  also s is where situations are strategised on
    
    # F is a culture of grasping syntax on top of o
    # formula
    $F = &s,d{ return G&way,'PseudoF',{s:s,d:d} };
    $io = {}; # a bunch
    
    #c parsetalk
    # parse out bits into m
    $parse;
        $m;
        $p = &r{
            m = parse.match(r);
            !m and return
            m.shift();
            parse = parse.replace(r,'');
            return 1
        };
    
    $ta = G.tiestowe = [];
    
    # compile time
    # see j/41/jababio
    # the string is basically a branch/path 
    #   params give values to columns, named with /^[$#]/
    #   params return or made available somewhere, per column, per row...
    # saving much typing!
    
    # can't really bab 1 line to many to set params
    # must return N
    #   it's what's expected? (at io (not F?))
    # and put iterator interface on T...
    #   later some way to do cursors,
    #     percolate and collaborate read-need-ness
    
    # but in an S:
    #  S can do io and then be iterating
    #  Babz setting params inside from T
    
    
    # general branch lingo
    # something for C-together
    # < making sql
    # params written as if string interpolated:
    # they create/read object or some reduced idea of an object:
    # the column will/must have/match the given param's value/identity,
    # $o - value
    # #o - looser/vaguer/processed copy of $o
    #      like spacers, with only C.t=o.t
    # word - spacer of C.t=word
    
    # < want o to find the exact object, not it's identity?
    
    # < unless it names a universal (1s&bareword) or so,
    #   then use that. inner lingosanctum.
    $parsetalk = &talk,params,d{
        d ||= {};
        parse = talk;
        # do i ... for o ...
        p(/ ((i|o) .+)$/) and d.plumb = m[0]
        # plumbed bit gets parsed after its downstream,
        #   but runs before, so know what:
        p(/^(i|o) /) and d.is = m[0]
        # absorb the o lop ^
        talk = parse; 
        
        # Babz shall do params, see 'compile time' ^
        d.path = []; # pa+
        while (p(/^(\S+)\s*/)) {
            # < '{}:m' -> params contains a &acgts{ map/grep/sort }
            #   with implicit return lastline
            #   whose value becomes a column
            $path = m[0].split('/');
            $outer = parse;
            each in path {
                parse = n;
                $pa = {};
                
                # set var from path bit
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                # and use each of them
                p(/^@/) and pa.sark = 1
                # can be i $i/@#dee o $o/*:dee
                #   to copy spacers
                
                # get path bit/value of here from a variable:
                # t-only/squish/shaded clone of C, or
                # C itself
                # when o the C will match itself/navigate onwards
                # or i will input that squished C,
                #   and/or ark/return,
                #   and/or climb past it and input more stuff...
                # sheer spacer, made for a C
                #   eg where desired.t == wanted.t
                p(/^#/) and pa.isparam = 1; pa.relative = 1;
                pa.sark and delete pa.isparam;
                
                # C itself for path bit got from param
                p(/^\$/) and pa.isparam = 1
                
                pa.t = parse;
                
                pa.t == '*' and pa.glob = 1;
                
                # value of here from a:
                if (pa.isparam) { # variable/bind param
                    !params.length and throw "Not enough params", pa.t, pa, d
                    pa.v = params.shift();
                }
                else
                if (pa.glob) {} # anything
                else
                if (pa.sark) {} # name of a column in d.plumb...
                else { # bareword
                    pa.v = G&Cye,[pa.t,1]
                    # words are the lumber of the algorithm
                    pa.word = pa.spacer = 1;
                }
                # namespaceness of something
                if (pa.relative) {
                    pa.o_v = pa.v;
                    pa.v = G&Cye,[pa.v.t,1];
                    # relative spacers hold a name for something
                    pa.spacer = 1;
                }
                
                d.path.push(pa);
            }
            parse = outer;
        }
        parse and throw "Unparsed", parse
        
        # others, use up params
        d.plumb and d.plumb = parsetalk(d.plumb,params)
        
        params.length and throw "Too many params", params
        return d
    };
    
    #c knowables
    $knowing = &d,v{
        # glob tv wants to make some path
        v ||= {t:'*',y:{cv:'*'}};
        # a subtype, reenters at the end:
        d.asa and $other = d; d = other.asa;
        # types
        d == 'tv' and d = {t:d,our:['y','tv'],path:[v.t,v.y.cv],usu:1};
        d == 'tw' and d = {t:d,our:['y','tw'],path:[v.t],usu:1}
        d == 'z' and d = {t:d,our:['sc','z']}
        # sheer bunch of keys
        d.constructor == Array and d = {path:d,usu:1}
        
        typeof d == 'string' and throw "intelligise", d, other
        
        other and ex(d,other);
        
        # apply the usual behaviour:
        #  - when duplicate, overwrite
        #    if tv, overwritings become linked lists
        if (d.usu) {
            if (d.t == 'tv') {
                # when not debugging:
                #d.also ||= ['tw','z']
            }
            d.dup = usu_dup;
        }
        return d
    };
    # this should be available as around or after method call..
    # or "the usual" that the actual d.dup works with or without
    $usu_dup = &d,x,v{
                # can link duped things, new thing gets v.y.$to
                # as in, newthing.y.earlier = oldthing
                $from;
                $to;
                # make similar index to z to hold dupes, in order
                # as s&z grep !in tv might reveal
                $dupz;
                
                # revision of an item
                d.t == 'tv' and from = 'later'; to = 'earlier'; dupz = 1;
                # revision of name, moving through items
                d.t == 'tw' and from = 'begins'; to = 'continues'; dupz = 1;
                # stuff moves through words
                # these schema should be drawn out
                # become keywords to io
                # io will just work
                
                if (from || to) {
                    # which way is it going: new val stays, new val joins the queue
                    $backwards = from && x.y[from] || d.keep_first; #]
                    if (backwards) {
                        !from and throw "can't go backwards with no from?"
                        # ^ unless use in telling things that missed the spot who beat them
                        !d.keep_first and throw "protocol changed"
                        # we could -1 y&dup_tv index maybe?
                        # or add y&most_$from to the end of the linked list
                        # this should magnify into a huge democratic space for ...
                        # space for 'space for ...'
                        # or follow links:
                        $X = x;
                        # < all while loops should have some limit, spec learned
                        #   badge earned. all code is is bestowment.
                        $i = 100;
                        while (X.y[from]) {
                            i-- < 4 and throw "ixhaust"
                            X = X.y[from];
                        }
                        # now last in the trail:
                        X.y[from] = v;
                        to and v.y[to] = X;
                        # so tv stays something, but .y.later = v extends forever
                    }
                    else {
                        from and x.y[from] = v;
                        to and v.y[to] = x;
                        # now tv sets us.
                    }
                }
                
                # make tv_dup, index as tv but to [] of items at the point
                # the minter will care about such things, T clutter, minor errors, noise
                if (dupz) {
                    !d.our and throw "housing not given"
                    $p = {t:'z'};
                    p.our = d.our.slice();
                    $gk = p.our.pop();
                    p.our.push(gk+'_dup');
                    p.path = d.path.slice();
                    # dup should include the one already there
                    p.zefault = [x];
                    input(s,p,v);
                }
                
                d.keep_first and return 1
                # but we (as eg tv) shall go on to tw and z even dups
                # no information lost!
    }
    #c rowing: travel d.path for i/o hooks
    $rowing = &talk,params,d,h{
        # reduce or sprout iterator
        # rows multiply as deeper atoms many
        # - [r,1,1a]
        # - [r,1,1b]
        # - [r.2,null]
        # - [r,3,3a]
        # < or a mirror C set, like G&ind/G&o does
        # < find us for ind-like N, p.nz goes:
        #   [r,[1,[1a,1b],2,3,[3a]]]
        
        # being plumbed somewhere
        if (typeof talk == 'object') {
            # d already, if compiling enough (sjson(parsetalk()))
            # or we are plumbed in to something that parsed our talk
            params && params.length and throw "talkref + params";
            d and throw "talkref + d";
            d = talk
        }
        else {
            d ||= {};
            parsetalk(talk,params,d);
        }
        !d.path and throw "no path"
        h.is && !d.is and d.is = h.is
        
        #c plumb from somewhere
        if (d.plumb) {
            $b = d.plumb;
            !b.is and throw "no plumb.is, i/o?"
            b.is != 'o' and throw "plumb not o"
            d.is != 'i' and throw "plumb to not i"
            io[b.is](b);
            $t = io.nz();
            # their rows's arks we sark from
            #  < sarkumulative grouping... instruct a vals=[],valis=[]
            #   
                
                # next p {row,pa} 
                #  must multiply:
                # their (o's) rows are stitched in to ours
                # at each sark point of path,
                # diverge pa for each row of pa.v they have
                #$ss = b.p.rows.map(&row{ return row.slice(-1)[0] })
                #    .filter(&s{ return s });
                
            
            # t.arks = {};
            $sarks = {}; # sarky pa by path i
            each i,pa (d.path) {
                !pa.sark and continue
                sarks[i] = pa;
            }
            # i $d/* o $o/*   implies   i $d/*/@s o $o/*:s
            !Object.keys(sarks).length and d.path.push({sark:1,t:'s'})
            
                # can be i $i/@#dee o $o/*:dee
                #   to copy spacers
            
                # or i $d/* o $o/*
                # to get each *
                
            # P = [p], p.row = row, p.pa may = {} instead of a d.path
            h.Pmod = &d,p,P{
                !P[0].row and throw "must be iterating the p.rows"
                P.length > 1 and throw "already multiplying row?"
                # if next bit of path is
                $pa = sarks[p.i+1];
                !pa and return P
                # remember last sark thing
                $la;
                $pS = p;
                while (pS && !la) {
                    pS.pa && pS.sark and la = pS
                    else
                    pS.sark and throw "sark above not pa", pS
                    pS = pS.up
                }
                $R = [];
                each ib P {
                    # our next bit of path
                    b.i ||= p.i+1;
                    # get multiplicity
                    $rows;
                    if (la) {
                        !b.row[la.i] and throw "our row misses the last sark", b.row, la.i
                        !la.pa.rows and throw "last pa.sark didn't set pa.rows", la
                        # just their rows this row at that point dove into
                        rows = la.pa.rows
                    }
                    else {
                        # all they say
                        rows = t.p.rows;
                        # complete rows
                        if (!d.partial)
                            rows = rows.filter(&row{ return row.slice(-1)[0] })
                    }
                    
                    # uniq objects on their sark column
                    $coli = t.arks[pa.t];
                    coli == null && pa.t == 's' and coli = t.path.length-1
                    coli == null and throw "no find column for",pa.t,t.arks
                    # for f(y)/[y+]
                    $vals = [];
                    $valis = {};
                    each ir rows {
                        $v = r[coli];
                        $vi = vals.indexOf(v);
                        if (vi == -1) {
                            vi = vals.push(v);
                            valis[vi] = [];
                        }
                        valis[vi].push(r);
                    }
                    
                    # multiply b by possible vals
                    $B = b;
                    each iv vals {
                        b = ex({},B);
                        b.pa ||= d.path[b.i];
                        b.pa = ex({},b.pa);
                        
                        b.pa.v = v;
                        b.pa.rows = valis[i];
                        !v and throw "nullish v! for rows",b.pa.rows
                        R.push(b)
                    }
                }
                
                return R
            };
        }
        
        h.returns and d.sok = 1
        h.first ||= &{};
        h.found ||= &{};
        $col = &q,p{
            p ||= {};
            p.i ||= q ? q.i+1 : 0;
            $pa = p.pa || d.path[p.i];
            !pa and throw "No pattern!: "+p.i
            
            if (!q) {
                p.i > 0 and throw "no q, notfirst"
                if (pa.glob || pa.spacer) {
                    # implies
                    !A.r and throw "unreal beginning, no Ar"
                    # < may refer to a 1s&word? 
                    pa = {t:'start',implicit:1,v:A.r};
                    d.path.unshift(pa);
                    # should leave out of rows, being implied
                }
                !pa.v and debugger; #throw "nofirst"
                
                h.first(d,p,pa);
                p.found ||= [pa.v];
            }
            else {
                p.up = q;
                
                if (!q.found.length) {
                    # dont bother looking anywhere?
                    p.found = [];
                }
                else {
                    # onward
                    !p.row and throw "Nowhere"
                    $s = p.row.slice(-1)[0]; # or p.i?
                    !s and throw "doing empty"
                    
                    # what should be:
                    $v = pa.v;

                    # to the bits
                    $D = {asa:'tv'};
                    # to diversify...
                    pa.spacer and D.spacer = 1;
                    pa.glob and D.meta = ['*','*']; d.sok=0;
                    else
                    pa.sark and // should have been figured by now?
                    # cos we want to input each thing via pa.v...
                    else
                    !v and debugger; #throw "null pav?"
                    
                    # make more rows
                    h.found(d,p,pa,s,D,v);
                }
            }
            
            #c merge onto every row - after return/in more loop?
            
            if (!p.row) {
                # starts - rows = [[r]]
                !p.found and throw "no row or found"
                p.rows = p.found.map(&s{ return [s] });
                p.nz = p.found.slice();
            }
            # adds column + may multiply rows
            else
            if (!p.found.length) {
                # empty - full of null
                p.row.push(null);
                p.rows = [p.row];
                # p.nz shapely enough to nothing when nothing
            }
            else {
                # new column of many - duplicate this row out
                p.rows = p.found.map(&s{
                    ro = p.row.slice();
                    ro.push(s);
                    return ro
                });
                # q.nz absorbs inners after loop
                p.nz = p.found.slice();
            }
            
            # rows grow to the right
            # < go width first? ps&z
            
            !d.path[p.i+1] and return p
            
            # an expanding map
            $rows = [];
            each i,row p.rows {
                $P = [{row:row}];
                if (h.Pmod) {
                    P = h.Pmod(d,p,P);
                }
                each ib P {
                    $b = col(p,b);

                    if (b.nz) {
                        # ...s... -> ...s, [s's many]...
                        $s = b.row.slice(-1)[0];
                        $i = p.nz.indexOf(s);
                        i < 0 and throw "manying row[-1] not in p.nz", s, p.nz
                        p.nz.splice(i+1,0,b.nz);
                    }

                    $r = b.rows;
                    !r and throw "rowing nothing"
                    # keeps pushing null once lost
                    !r.length and throw "not one row"
                    r.map(&ro{ rows.push(ro) })
                }
            }
            p.rows = rows;
            
            return p
        };
        $p = d.p = col();
        T.o = d;
        
        # deepest atoms:
        $rows = p.rows;
        $ss = rows.map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });

        A.debug and debugger
        d.sok && ss.length <= 1 and return ss[0]
        #h.returns and debugger; #throw "Wanted to return s",ss,d
        return ss
    };
    
    #c i_ somewhere someway somestuff
    # the dot of the i is somestuff, index the space, trunk way etc.
    # shall we use a talky Babz'd params-implied-by-$ thing?
    # or just put thing on thing arguments?
    $i = io.i = &talk,params,d{
        # talk:
        #   'universal keyworded-by $thing'
        # find these things... barewords we have around?
        # usually a J universal like N,M,1,9, etc.
        # and somethinging to it:
        # talk='N $by', param=[$by]
        #   N means 3's A:n's r's cM, # caveful of atoms
        #      or M 1's A:n's r's cM  # just the people around you
        #   should kinda m:N $by,
        #   but with the o kind of universal awareness, not A:n
        # but simply as possible, until real use cased:
        # - make sure this is so!
        # as opposed to o:
        # o how is this?
        # 
        $row; # see 'crazy'
        # row may > path?
        # path should grow with it,
        #   unless they're really wandery globs, then you'd know...
        
        
        return rowing(talk,params,d,{
            found: &d,p,pa,s,D,v{
                # what should be
                # space to it gets filled in with hash
                # and when should existing objects be replaced,
                #   but indexes etc copied to the new one?
                #   upstream changes joining local modulation
                #   seems like s's buzz.
                
                # < input null to delete?
                p.found = [input(s,D,v)]
            },
            returns: 1,
            is: 'i',
        })
    };
    
    
    #c _o sketches use for A:o:
    # o gets you what you wanted from an intelligised pile
    #   midsection of o is the midsection of n
    #  S titles can use this to define iterators
    # operation of returning results from traversal,
    #   or advancing the A:o of the C, as in dome calmness check
    
    # o may ventually look like n,
    #   and n may eventually have blockquotes hanging on after it,
    #   even T things, grabbing whatever on/over/into Aing thereinout
    
    # hmmm. music collection will be lived by o,
    # QMS would be in a quarantine
    

    # there must be more
    # the o d will be... more infinite
    #   particularly grep/sort/map
    #  tal being apply
    # lingo shape glue session
    $o = io.o = &talk,params,d{
        return rowing(talk,params,d,{
            first: &d,p,pa{
                !pa.v and throw "nofirst"
                if (d.path.length == 1) { # <  && pa.isparam
                    # o $thing implies o $thing/*
                    d.path.push({t:'*',glob:1});
                }
            },
            found: &d,p,pa,s,D,v{
                # 6, only the last column
                p.found = output(s,D,v);
            },
            is: 'o',
        })
    };
    #c io.nz
    # converts p.rows to iteration or whatever
    $nz = &d{
        d ||= T.o;
        !d and throw "Can't find T.o"
        # takes over from o
        $t = ex({},d);
        
        # name columns
        t.arks = {};
        each i,pa d.path {
            pa.ark and t.arks[i] = pa.ark
        }
        # arks ||= {-1:s}
        # < Babz S io must know this
        if (!Object.keys(t.arks).length)
            t.arks[t.path.length - 1] = 's';
        
        # iterate per row
        t.i = 0;
        t.more = &{
            $ar = {};
            while (1) {
                t.row = t.p.rows[t.i++];
                !t.row and return
                # only for complete rows
                !t.partial && t.row.slice(-1)[0] == null and continue
                break
            }
            each ik t.arks {
                ar[k] = t.row[i];
            }
            # single value
            if (Object.keys(t.arks).length == 1)
                return ar[k]
            # hash of values
            return ar
        };
        
        # do callback per item, with depth...
        t.ind = &cb{
            t.indstr ||= '  ';
            # recurse into p.nz?
            # < just like the idea of nz apparently,
            $la = [];
            $N = [];
            each i,row t.p.rows {
                t.row = row;
                # only for parents with children
                !t.partial && t.row.slice(-1)[0] == null and continue
                each dv row {
                    v == null and continue
                    # same as last row, still at depth
                    la[d] == v and continue
                    t.d = d;
                    $s = cb(v,t);
                    s == null and continue;
                    if (typeof s == 'string') {
                        $ind = '';
                        each id,v row {
                            id == d and break
                            ind += t.indstr
                        }
                        s = ind+s
                    }
                    N.push(s);
                }
                la = row;
            }
            return N
        }
        
        return t;
    };
    
    
    #c input see,
    # fills in an index with a value
    # total definition of z/tv indexes, which should be one of a few...
    # along with the z/tv positioning system, there's an element of
    #   wiring or linked lists via y&in, y&up, y&next, y&prev,
    #   left out for code volume
    # < index/join types should be curated nearby
    #   proto hard-coded...
    # tv:
    #    lots of C via tvs can hold anything, just stretched out.
    #      maybe if you're database you want to know things.
    #    < in exact mode should keep z sorted,  overwrite tv
    #    < in soft mode should not overwrite (el=1)
    #    
    # non-tv index/join types:
    #    I: could be known to be of/ov/t/cv?
    #    x/y/z: what's in space...
    #    beliefs in cv like subnets, having octaves of octaves,
    #      non-linear spaces, klein bottle public netspace
    #      lanes of stripes whipping around a torus, etc.
    #
    # 
    # s = data
    # d = [pa,th], puts at that path
    # d = {path:[pa,th],dup:&s{}}
    # does a single weld, usually C-C
    # carbon joint, some language in each place?
    # ignores the next/last/in/up wiring, let o do once sorted
    #   when it gives a kind of gravity,
    #   linearity to the stage that may not ever be there
    $input = &s,d,v{
        d = knowing(d,v);
        # return d here to extract what we know, kind of 2
        
        # now 3 deals with what really shall be and how we shall create it
        
        # climb container different? may A?
        # section of o, defined into several places... houses
        # this is the most high speed bit, copying bunches of C,
        # with a little lingeme sensitivity loaded in on the d,
        # which is a lunk for A, C, T rivering the reverberate of revision
        
        # climb index
        # d.ours ['nk','gk'], gets to the thing at the end of this thing
        # +
        # d.path ['Winning','0.1'] points of index, to the value
        # not the same d.path (or d) of i/o, is a lower level, manyer
        $path = (d.our||[]).slice();
        d.path and d.path.map(&p{ path.push(p) });
        
        $S = s;
        each ip path {
            i *= 1;
            $x = S[p];
            x && typeof x != 'object' and throw "index broken"
            # the last bit of our space: the universal
            #   could be something trascendant
            #   like being a thing with hooks, more our until path...
            d.our && i == d.our.length and d.on_our = x
            # done, leave S on second to last thing
            i+1 == path.length and continue
            # hash usual
            x == null and x = S[p] = {}
            S = x;
        }
        
        # S[p] may now = x
        # S[p] soon will = v
        if (d.t == 'z') {
            # or include it
            x == null and x = S[p] = d.zefault || [];
            x.constructor != Array and throw "z broken"
            #$xi = x.indexOf(v);
            # exact object ^, also could be claiming a tv had already (up at tv)
            # we shall start simply adding on, mentioning things more than once, etc
            # no information lost!
            # except the time of day, which is easy to find
            # dups constitute weirdness that should be cleaned up...
            #   before the system with it in goes production
            # < z_dup: handled on the o end, as z things not in tv, and tv_dup
            x.push(v);
        }
        else {
            # set thing to thing
            A.debug and debugger;
            if (x != null) {
                # already, noop?
                d.spacer || x == v and return x
                d.dup && d.dup(d,x,v) and return x
            }
            S[p] = v;
        }
        
        # multiple angles of have
        if (d.also) {
            each in d.also {
                typeof n == 'string' and input(s,n,v)
                else {
                    throw "What else", n
                }
            }
        }
        return v
    };
    
    #c output
    $output = &s,d,v{
        d = knowing(d,v);
        # path =
        #   our  - reaches from thing to its universal (nk,gk)
        # + path - into index (t,cv)
        # not the same d.path (or d) of i/o
        #   is a lower level, manyer
        # meta applies to non-our path only.
        $path = d.our || [];
        $mi = path.length;
        d.path and d.path.map(&p{ path.push(p) });
        
        # we only need to capture the endmost atoms at this low level
        # < rows is S in input... could insert multiple times if crazy
        d.rows = [[s]]; 
        # flow
        $i = 0;
        while (path[i]) {
            $k = path[i];
            $pm = i >= mi && d.meta && d.meta[i-mi];
            $rows = [];
            each ri,row d.rows {
                $S = row.slice(-1)[0];
                if (S == null) {
                    row.push(null);
                    rows.push(row);
                    i++;
                    continue
                }
                $ks;
                if (pm) { # loose match, may many
                    # use z order? grep by tv?
                    # in the order they were set
                    pm == '*' and ks = Object.keys(S)
                    else {
                        # for WHERE k=v to be k>5, k~re
                        throw "meta",pm
                    }
                }
                else { # exactly what path[i] says
                    # but when to cast it first? never I spose.
                    $ok = typeof k == 'string'
                        || typeof k == 'number';
                    !ok and debugger
                    !ok and throw "nonstringstep"
                    ks = [k];
                }
                # < to sort, know fractional cv,
                #   with freaks, histograms, history
                # < if !x we could try as if 1=='',
                #   misspellings, round until found,
                #   using z a sorted z to scope up a cv faster...
                #   even resurrecting a J that looks similar
                each ik,k ks {
                    $x = S[k];
                    # extend row
                    $ro = row.slice();
                    ro.push(x);
                    rows.push(ro);
                }
            }
            d.rows = rows;
            # and add column:
            i++;
        }
        # take off columns not in the formula (A.r)
        
        $last_column = d.rows
            .map(&row{ return row.slice(-1)[0] })
            .filter(&s{ return s });
        return last_column
    };
    
    #c iover
    io = ex(io,{F:F,i:i,o:o,input:input,output:output,parsetalk:parsetalk,nz:nz});
    return io;
    
t/iooia: |
    G&heading;
    $io = G&way,'iooia';
    G&way,'Doming',ar;
    
    $a = &t,talk,cetia,c{
        $params =
        cetia ?
            typeof cetia == 'object' ? cetia
            : cetia.split(' ')
              .map(&s{ return G&Cye,[s] })
        : [];
        
        $what = talk+(cetia ? " <--- "+ki(cetia) : '');
        m $t  $s:what %hue:200deg,dis:block
        
        $d = {};
        $r = io[t](talk,params,d);
        
        if (c) {
            # more awareness
            (c == 1 || c.show) &&
                m d_of_"+t+"  $s:d
        }
        $n =
        m $t  $s:r
        typeof c == 'object' and ex(n.c,c)
        return r
    };
    
    S 1 respec-talk
    a('parsetalk','w/*:w');
    a('parsetalk','trouble/w:r/#w:t','weeee',1);
    a('parsetalk','$t o $w/*','tea weas');
    # from the story of -respec:
    # o w/*:w
    # if problem with $w:
    #   i trouble/w:r/#w:t
    #   ts&dige = supposedtobe
    #   i $t o $w/*
    
    S 2 respec
    A.r = G&Cye,['iooia',9,{M:[]}];
    $now = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','weeee');
    
    $aw = a('o','w/*:w');
    
    $iw = a('i','w:r/#w:t','walso');
    
    $aw = a('o','w/*:w');
    
    $w =
    a('i','trouble/w:r/#w:t','sweeee',1);
    ws&plat = 5;
    $aw = a('o','w/*');
    # too far
    $aw = a('o','w/*/*',0,1);
    $aw = a('o','trouble/w/*',0,1);
    
    $aw = a('o','*',0,{show:1,dl:5});
    
    
    $aw = a('o','*/*',0,{show:1,dl:5});
    
    
    #a('i','w:r/#w:t','well');
    #a('i','$t o $w/*','tea weas');
    
    
    S 3 i/o
    
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    $o = G&Cye,['blag','2',{s:'gakel'}];
    n attaching_to -fod $s:d,dl:14
    
    $N = io.i('$d/$o',[d,o]);
    $oN = io.o('$d/*',[d]);
    m enN -fod $s:N,dl:14
    m ouN -fod $s:oN,dl:14
    
    
    #c iteration
    S 4 iteration
    n ble 8 s:bmung %fs:600%,dis:block
    # so 'i $t' tv's each 'o $w/*:W', like 'i $t $W'+
    $d = G&Cye,['upsulat','1',{s:'gakl'}];
    'doofica latico matri vou'.split(' ').map(&s{
        $o = G&Cye,[s,'1'];
        i $d/$o
    });
    a('o','$d/*',[d],1);
    
    a('o','$d',[d],1);
    
    #$r =
    o $d/*:r
    
    $matri = G&Cye,['matri',1,{morematch:2}];
    
    $maN = a('o','$d/#matri',[d,matri]);
    
    $ma = maN[0];
    mas&cla = 'osi';
    
    $vong = G&Cye,['Viog',34];
    i $ma/$vong
    
    a('o','$d/*/*',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar,dl:5
    }
    m iterator  $s:t,d:8.22 %fs:120%
    
    $v =
    i $ma/#vong
    vs&latjkc = 42;
    
    a('o','$d/*:dui/*:s',[d],1);
    $t = io.nz();
    $ar; while (ar = t.more()) {
        m calledit  $s:ar,dl:5
    }
    m anotherator  $s:t,d:8.22 %fs:120%
    
    # reuse this pile of C
    1s&sandy = d;
    
    #c Monday
    =Monday' for all of them together:
    
      mere exercise
      nz - nz=[(C,nz?)*]
        array-indented C, as a format to build like d.rows
        just like the idea, no immediate use.
        why make data look more like indented Lines?
      
      io.nz - convert it to whatever,
          esp [A,B,C]+, so :arks can be mapped on
        even [C+] and [p+], for the last column
        G&ind used to do N=[(C|s)+],
          adding indent if returning strings
    
    Join i-o:
      T.o - last i/o`s iterator state
        to join an i from an o 
        use it somehow?
        so S can Duning with it:
            S o $thing/*
        ...doesnt
            o $thing
        imply $thing/*
        s be the default ark
        
      
      i for o implies:
        for the last column returned:
          an extra step in the path 
        else
          the vars coming from o can be used in the i:
             as @whur or @lamb below:
      
       that i $d/pock o $w/*
       once at $d/pock, add path to each thing
         pa.multi = [column] to multiply rows by
      
      
      Functions:
        also:
            i $d/@whur/@lamb { s&fat && "laughter" }:whur o $lambs/*
        which:
          greps (by default?) and assigns value to whur
            which becomes a bareword to the i
          deciding where lambs go
          should have \ at end of line to continue expression...
        if no :arks in an i, uses last column,
        :whur ends up on the i tuple (nz?)
          
      
      and i`s usual singularity is now a multitude,
      should be iterator source as well, for the inserted things
      
      iteration:
          $N =
        o $i
        turns into iterator... hmm
        we could ask for an iterator:
          it flows $W $i
        T.o should link each other,
        so the right bunch of variables can be found
        
        and do we think we are done when:
          value/row of vars is pulled out?
          looped over again?
        probably a completed 6 has seen all the things,
            and wants to get new things later
          even if it bailed out when satisfied
             with what it was constructing
          async or so should persist until it has really done that thing
        
        but basically, get an iterator object
        for the last T.o
        put it in a while loop yourself
        or use Duning S most of the time
      
      pipelining - no
      
      
      
      other stuff:
        function for #things spacer creation...
          is really mutating an object,
            creating a pointer to the origin
          could make loose matches too...
      
        p should be C, c&s = C/target, etc
        p being our grasp on the C got
          they offer an alternative positioning system,
            according to the new gravity cast on it.
      
        # Domes:
        # make an M cv space subnet per test?
        #   so we can write more nonlinear

        # bothered writing this?
        # i $d/$o
        # maybe we want 'd>o'
        # magnetics want to... ranking, raking...
        # for sorting the junkdrifts of culture

        # < completing this -fod now so it sees d before io
        #   WHILE it`s an M thing would be something
        #   we will often be populating a populated space
        
      
      other stuff:
      
        
      making if/while/etc indent sensitive:
        if $something > 3
            Doofalism
            if $still
               More
            else
               Some
        Ladada
      ; matters much for no reason
      brackets also
      filigree?
      
      general \ at the end of the line to continue expression...
        strange one
        idea of cs and more to the C in some compression, out of tycsc mode
        would let base64 image data after sc...
      
      
      
    =cut
    # '
    
    #c hmmm 
    S 5 strange formats
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    o $d/*/*
    $t = io.nz();
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m inded  $s:s %hue:80deg,ws:pre,dis:block
    
    t.partial = 1;
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    
    # plumbing
    S 6 i<-o plumbing
    
    $d = 1s&sandy;
    !d and throw "SANTY"
    
    $n = G&Cye,['upsulat','1',{s:'gakl'}];
    i $n:an o $d/*
    # i can set vars... use T.o if you unsure of 1/+ness
    m andasio_varset  $s:an
    
    o $an/*/*
    $t = io.nz();
    m therowsofan  $s:t.p.rows
    
    t.partial = 1;
    $s = t.ind(&s,t{ return ki(s) }).join("\n");
    m indy  $s:s %hue:120deg,ws:pre,dis:block
    
    
    # S
    S 7 domeration
    
    m todo  s:todo
    
    
    
    # grep
    S 8 functions
    
    m todo  s:todo
    
    S 0
    # everytime dome:
    # perhaps not by being last but by being named
    # has agenda to do slice of sequential or a certain name,
    # or just run in to things.
    each in M {
        ns&hue || ns&pi and continue
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl ||= 12;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
    
Duning: | # avalanche of activatuio
    # S as steps of transformations, some linear?
    # S as moments to do o, sleep/wake culture
    # S as functions to map things inside (M) or outside (N/U) this J
    #  M works on 1's M, what we have
    #  N works on 2's M, where we are
    #  U works on 3's M, Wunity of things we are foorming:
    #   3's M, as A-climbed to its A.r, root9 molecule,
    #    haver of domes, so these in-pi can collaborate
    #    look and respond waves going wide, weaving
    #    with one big object index, etc.
    #    craziness is being joined up on A.3
    
    # < S still for late osc? Swum things?
    #   S 8... could make &{} instead of while wrap
    #     B carefully when calling such
    # could be a nice place to reboot subroutines actually...
    # < S for elvis handle
    
    # < Swim-like, something the throat can not know about,
    #   but ensure it is answered for
    
    
    # A-climb, for the right levelled A.r (pool, what)
    # which will eventually be the root and root dome and ground
    # 3's is a big room of stuff,
    #   hmmm
    $Ask = &s,k{
        typeof s != 'number' and throw "Ask for num"
        # climb up
        $Y = A;
        $lim = 30;
        $want = A[s];
        while (Y.1 != want) {
            Y = Y.up;
            !lim-- and throw "Ask huge"
        }
        # 
        k == '' and return Y
        if (k == 'rc&M') {
            $r = Y.r;
            # r R? the soft int
            !(rc&root || rc&dome) and throw "isDome"
            !rc&M and throw "not rcM",r
            return rc&M
        }
        if (k == 'C') {
            !Yc&s and throw "NoC!"
            # isC, when it inlines
            return Yc&s
        }
        throw "What at?", Y
    };
    # arg eater
    # eat args for S
    $meater = &d{
        $m = [];
        m[0] = &r{
            m = d.match(r); # += /(?: |$)/ somehow
            !m and return
            m.shift();
            d = d.replace(r,'');
            return m.length == 1 && m[0] ? m[0] : 1
        };
        return m
    };
        
    
    # sequences/numbered:
    #   could fractionate across A.3, shelved somehow...
    #   having a limb inside J6, wh
    # they diff island on the dome, working on array
    # 
    # Duning S might return a variable, making for iteration
    # < Babz this in somehow
    # or fetching (Ask()) something another M, 3's M is called N
    # < something should be able to takeover which S we want to go for, too...
    
    # for G&Ban to find these subs:
    $way = Gc&B.sc.way;
    A&S = &s,t{
        # B will be i/S
        Gc&B.sc.way = way;
        typeof s == 'number' and throw "doing seq"
        $g = A&doming(s);
        
        # non-iterative dome again?
        !g and return
        $m = meater(s);
        #debugger;
        $p = m[0];
        # $s='as last N'
        if (p(/as /)) {
            $limit = p(/(first|last) /);
            $M = p(/U/) ? Ask(3,'rc&M')
                :p(/N/) ? Ask(2,'rc&M')
                :p(/M/) ? Ask(1,'rc&M')
                : '';
            !M and throw "noM?",s
            if (limit) {
                $C = Ask(1,'C');
                $O = limit == 'first' ? M.slice(0,1)[0]
                    :limit == 'last'  ? M.slice(-1)[0]
                    :'';
                !O and throw "noO?",s
                C != O and return
            }
            return M
        }
        else {
            # T out the other
            #$M = 
            $notes = [s,t];
            m called_S -jod $s:notes
        }
        
        #throw 'edge of reality', [s, t]
        return 1;
    };
    
    #c A&doming like Doming:
    # For Duning:
    #  may not ground all domes,
    #  they may be ephemera, even error/message channels
    #  in a spinal nervous system awareness
    #  where hs&z makes for stuff toward rs&z
    #  but we might have hs&Errors, hs&Msgs... other dimensions
    
    #  should A.r be taken over by the current dome? supposedly.
    A&doming = &t{
        # resets a chunk of reality,
        # a group of o that may flatten or hide from s
        # A.ground.sc.z (or A.r.sc.z, or ra&z) is the main wWw
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A.ground = g;
        # soon:
        #!gc&root and throw "root of ground not", g;
        
        # one A&doming gives all the domes to ground
        # < what meaning for Duning?
        #   
        if (1s&domes && !gc&domed) {
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        if (h) {
            # never repeat Duning?
            # depends on the mode,
            # S and C iterator
            return;
            # 
            # reset, o maintains it in the beginning of s, 
            hs&z = [];
        }
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        # Duning doesn't step into the dome, merely holds it
        #A.ground = h;
        #G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
        return h;
    };
    
StayToSleep: | # gentleness scan
    # 
t/BuildACastle: | # test Duning and io
    # ones
Fly: |
    G&heading;
    G&way,'t/iooia',ar;
    return;
    
    1s&empathy = 4;
    1s&Gro ||= [];
    

    
    
    if (0) {
    each tvJ 4s&Jtv {
        m $t $s:J
    }}
    each in 1s&Gro {
        m $n
    }
    }
    each in M {
        nc&pi = 'fod';
        ns&dos = 'grow';
        nc&dl = 15;
    }
    
    $N = M.slice();
    n M -fod $s:N %hue:160deg
grow: | # spraw Js&ope qua
    # there must be a S/C/A clicky scheme attacher somewhere
    $Y = c.y.A.1;
    Ys&ope ||= 0;
    Ys&ope += e.t.includes('C') ? -1 : 1;
    ~Told: ki(Y), ki(Y.3)
pi/fod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # where was above? 2Cc&d was going to do this...
    $u = A.n.up.n.c.s;
    c&d ||= uc&d || 1;
    c&d > 1 and ys&ml = (c&d - 1)+'em'
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    $dl = c&dl || 3;
    1s&ope and dl += 1s&ope;
    
    $es = c&s;
    es = ex({},es);
    if (es.path) {
        $p = es.path;
        delete es.path;
        each in p {
            m path -fod $s:n,d:2,dl:7
        }
    }
    if (es.p) {
        $p = es.p;
        es.p = ki(p,4.22);
        c&p == 1 &&
        m psomething -fod $s:p,d:3,dl:7
        if (c&p && c&p != 1) {
            $s = p[c&p];
            m psomething -fod $s:s,d:3,dl:7
        }
    }
    if (es.plumb) {
        $p = es.plumb;
        delete es.plumb;
        m oach -fod $s:p,d:3,dl:7
    }
    
    
    
    G&n,['Thing',3,{s:ki(es,dl)}];

