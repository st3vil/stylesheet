rez/thier: | # flat t=(sip|fraction|etc) -> depth, s&bit difference, ordered?
    my @p; # the path
    my $sepr = ar.sep ? qr/\W+/ : '';
    for my $C (sort {a.t cmp b.t} @$z) {
        delete C.y.next;
        delete C.y.in;
        insi: while (@p) {
            my $l = $p[-1];
            # dirs split / and ips split .
            if (C.t =~ /^l.t($sepr)(.*)$/) {
                #sayre "^ l.t  $1 -> $2";
                C.y.parent = $l;
                s&sep = $1 if $1;
                s&bit = $2;
                push @{ls&z||=[]}, $C;
                last insi;
            }
            else {
                pop @p;
            }
        }
        push @p, $C;
    }
    # < order after s&bit separates and know numberology
    grep {!_.y.parent} @$z

ind/sort: | # clone/flatlist with rearrangement
    # only sorts on each s&z
    my $gk = ar.gk || 'bit';
    my $cb = &Cd{
        @{s&z} = sort {
            exists a.sc.>$gk && exists b.sc.>$gk
                && a.sc.>$gk <=> b.sc.>$gk
        } @{s&z} if s&z;
        $C
    };
    G&ind,$C,$cb,{cbfirst=>1};

Min/bits: | # entre for new life
    # becomes local-est cs
    my $te = defined s&bit ? s&bit : C.t;
    # as depth knower
    my $sc;
    sc.ml = c&ind;
    sc.dis = 1;
    sc.dos = ar.dos if ar.dos;
    
    m C.t=>{C=>$C}=>{depth=>c&ind,s=>$te},$sc
