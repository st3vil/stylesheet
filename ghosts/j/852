rez/thier: | # flat t=(sip|fraction|etc) -> depth, s&bit difference, ordered?
    my @p; # the path
    my $sepr = ar.sep ? qr/\W+/ : '';
    for my $C (sort {a.t cmp b.t} @$z) {
        delete C.y.next;
        delete C.y.in;
        insi: while (@p) {
            my $l = $p[-1];
            # dirs split / and ips split .
            if (C.t =~ /^l.t($sepr)(.*)$/) {
                #sayre "^ l.t  $1 -> $2";
                C.y.parent = $l;
                s&sep = $1 if $1;
                s&bit = $2;
                push @{ls&z||=[]}, $C;
                last insi;
            }
            else {
                pop @p;
            }
        }
        push @p, $C;
    }
    # < order after s&bit separates and know numberology
    grep {!_.y.parent} @$z
ind/sort: | # clone/flatlist with rearrangement
    # only sorts on each s&z
    my $gk = ar.gk || 'bit';
    my $cb = &Cd{
        @{s&z} = sort {
            exists a.sc.>$gk && exists b.sc.>$gk
                && a.sc.>$gk <=> b.sc.>$gk
        } @{s&z} if s&z;
        $C
    };
    G&ind,$C,$cb,{cbfirst=>1};
Min/bits: | # entre for new life
    # becomes local-est cs
    my $te = defined s&bit ? s&bit : C.t;
    # as depth knower
    my $sc;
    sc.ml = c&ind;
    sc.dis = 1;
    sc.dos = ar.dos if ar.dos;
    if (ar.keep) {
        $sc.>$_ = C.sc.>$_ for split ',', ar.keep;
    }
    
    m C.t=>{C=>$C}=>{depth=>c&ind,s=>$te},$sc
ef/Bs: | # describe callstack, a little
    my @l;
    my $B = ar.B || Gc&B;
    my $S=$B;
    my $i;
    push @l,$B while $B = $i++<10 && B.y.out;
    
    my ($n,$o) = @{ar.m||[]};
    $o && die "more m";
    map { shift @l } 1..$n if $n;
    
    if (ar.t) {
        my @r;
        shift @l until $l[0]->{t} eq ar.t;
        push @r, shift @l while $l[0]->{t} eq ar.t;
        @l = @r;
    }
    
    join"->", reverse map {
        ar.t && ref _c&s ? _c&s.t : _.t;
    } @l;

