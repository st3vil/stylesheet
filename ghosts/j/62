SenseCertainty: | # clamorous industrial junkseeing
    # travelling bit outliner
    # < becomes subordinate to FactorEase
    n SirKill
    
    # not too useful
    #n Compliers
    
    # travelling somethingers
    # < use G&o instead
    n Walks
    # dead ends of A.t=o
    n Stashi
BuildSir: |
    my $e = djson <<'';
        {"c":{"W":"Jig","e":{"c":{"pi":"Gdo","s":"An Update"},"sc":{"z":[{"c":{"W":"SirKill"},"t":"SirKill"},{"c":{"W":"SenseCertainty"},"t":"SenseCertainty"},{"c":{"W":"Process"},"t":"Process"},{"c":{"W":"HaMachine"},"t":"HaMachine"}]},"t":"peace/new","y":{"cv":""}}},"sc":{},"t":"Jig","y":{"cv":""}}
    
    Rw CloningProcess;
    #
    Gc&bay = 'peace';
    n $e
    
    sayre "Become thingz!";
    exit;
    
SirKill: | # crawl datastructure
    u i
    o: %acgt:s c sc
        my $isC = &C{
            defined C.t && C.y && C.c && C.sc
        };
        
        saygr "Do o: ".ki $s;
        my $V = A.V;
        $A = G&A,o=>0=>$c,$sc;
        
        my $on = A&liveon || A.1;
        $on = on.sc.o ||= {} if $isC->($on);
        A&t ||= A.c.ip[-1]; # the number of our A in enclosing A
        my $o = A&s = $on.>A&t ||= {t=>A&t};
        
        my $name = 'o'.o.t; # eg oin
        oc&ysource = $name.'D'; # oinD, in drain
        oc&clones = [$name.'C']; # oinC, on record?
        
        # eg gen=lv, should maybe []
        push @{oc&clones}, A&gen if A&gen;
        
        # make a clone to throw into next process, eg OC
        # and link the drained C.y.OC = $OC
        if (A&yoff) {
            oc&sourcey = A&yoff;
            push @{oc&clones}, A&yoff;
        }
        
        # many A=o hold cs=C
        my $io = {t=>'o',up=>$o,c=>{s=>$s},sc=>{}};
        my @L = io.y = $io;
        my @R;
        # builds up from z/in/tw/tv
        while (@L || @R) {
            if (!@L) {
                @L = reverse @R;
                $V && saygr "Clunking r: ",
                    map{"  _c&ind, _c&s.t _c&s.y.cv"
                    } @L;
                @R = ();
            };
            my $A = shift(@L);
            my $C = A&s;
            # < give these A/C to T for blowingup locator?
            (Gc&B.sc.aA, Gc&B.sc.aC) = ($A,$C) if Gc&B;
            $V && sayre "V ".join('',('  ') x A&ind)."  C.t  -- C.y.cv  "
                .ki({c=>C.c,sc=>C.sc});
            #1 && sayyl "Asck: ".join', ', sort keys %{A.sc};
            unless (A&last) { #c last reoccurs
                $V && saybl "0 last";
                # but first
                $isC->($C) || die "notC: ".ki$C;
                A&ipi ||= 0; # increment per child
                my $l = upc&last || {};
                
                if (A&comp eq 'tv') {
                    A&last = ls&tv.>C.t.>C.y.cv || {};
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                elsif (A.up eq $o) {
                    # io has an A
                    A&last = os&lastA || {};
                }
                else {
                    A&ext || die "how to file";
                    A&last = ls&Tv.>A&ext || {};
                }
                # < different namespacing? crunch function?
                push @L, $A;
                next;
            }
            unless (A&insides) { #c insides
                $V && saybl "1 insides";
                my $st = {}; # same inside may appear many places
                # Scuttle should tell ways in
                # < checking that everything is found via each way
                #   mostly it will be filling up the connection of
                #   chucked together any way bits
                # < should know all y/c/sc that look C or [C+]
                my @at;
                each nk,gk,v $C {
                    next if 'y'eq$nk; # distracto or handled
                    if (ref $v eq 'HASH') {
                        # no A for it if not C, may still be deduped
                        # via os&refs collected from C and ng/gks
                        v.y ne $v || next;
                        $isC->($v) || next;
                        push @at, ["$nk $gk",[$v],{nk=>$nk,gk=>$gk}];
                    }
                    elsif (ref $v eq 'ARRAY') {
                        next if $nk eq 'c' && $gk eq 'M'; # dodge
                        next if $nk eq 'sc' && $gk eq 'z'; # handled
                        next unless @$v == grep {
                            ref $_ eq 'HASH' && $isC->($_) } @$v;
                        push @at, ["$nk $gk",$v,{isTv=>1,nk=>$nk,gk=>$gk}];
                    }
                    else {
                    }
                }}
                A&insides = [ # A inner
                    map {
                        my ($t,$z,$c) = @$_;
                        map {
                            my $Y = $_;
                            Yc&ext = $t;
                            Yc&zip = A&ipi++;
                            Yc&ind = A&ind+1;
                            Y.c.>$_ = $c.>$_ for keys %{$c||{}};
                            my $s = "Yc&s";
                            push @{$st.>$s ||= []}, $Y;
                            _.y = $Y;
                        } map {
                            {t=>'o',up=>$A,c=>{s=>$_},sc=>{}}
                        } @$z
                    }
                    @at, # attributes we can see
                    # these all mean "inside", are in tv competition:
                    map { $_->[2] = {comp=>'tv'}; $_ }
                    grep{defined}
                    (C.y.in ? do {
                        my @S = my $S = C.y.in;
                        push @S, $S while $S = S.y.next;
                        ['y in', \@S]
                    } : undef),
                    (C.y.tw ? do {
                        ['y tw',[values %{C.y.tw}]]
                    } : undef),
                    (C.y.tv ? do {
                        ['y tv',[map{values %$_} values %{C.y.tv}]]
                    } : undef),
                    (C.sc.z ? do {
                        ['sc z',C.sc.z]
                    } : undef),
                ];
                # check $st for duplicate s
                each s,z $st {
                    @$z > 1 || next;
                    my @z = @$z;
                    @$z = pop @z;
                    A&Atrm.>$_ ++ for @z;
                }
                @{A&insides} = grep { !A&Atrm.>$_ } @{A&insides}
                    if A&Atrm;
                
                # so we know which values are things
                #   with their own differencing A
                A&ways_in = {};
                push @{A&ways_in.>_c&ext ||= []}, $_ for @{A&insides};
                
                $V && saygr " C.t has ".@{A&insides}." insides";
                unshift @L, @{A&insides};
                unshift @R, $A;
                next;
            }
            unless (A&hoisting) {
                $V && saybl "1.5 hoisting";
                # wipe our tv, write ourselves into up.tv
                #  - after insides find their A&last
                # attach to the above
                # < many
                if (A&comp eq 'tv') {
                    push @{ups&tv.>C.t.>C.y.cv ||= []}, $A;
                }
                elsif (A&comp) {
                    die "comp A&comp"
                }
                elsif ($A eq $io) {
                    # io
                }
                else {
                    A&ext || die "how to file";
                    push @{ups&Tv.>A&ext ||= []}, $A;
                }
                
                A&hoisting = 1;
                # start going backwayds
                push @R, $A;
                next;
            }
            unless (A&diff) { #c difference, in reverse, insidest first
                $V && saybl "2 diff";
                # last A, compare a&ng
                my $d = A&last;
                my $D = A&diff = {};
                Ds&allnew = 1 if !dc&el;
                # Ds&neg - changed values nk/gk = q
                # Ds&pos - changed things index/$index = Y
                
                # the values
                # maintain Ds&ng nk/gk
                # change of Ds&neg nk/gk
                #  - this each Bablar will next on !ref t
                #  and avoid y, t/cv we write in
                each nk,gk,v $C {
                    # not things that will change superficially
                    next if $nk eq 'y';
                    next if A&ways_in->{"$nk $gk"};
                    
                    a&ng.>$nk.>$gk = $v;
                    if (ds&ng.>$nk.>$gk ne $v) {
                        my $q = Ds&neg.>$nk.>$gk = {t=>$gk,c=>{s=>$v}};
                        qc&new = 1 if !exists ds&ng.>$nk.>$gk;
                        qc&was = ds&ng.>$nk.>$gk if !qc&new;
                    }
                }}
                each nk,gk,v ds&ng {
                    exists $C.>$nk.>$gk && next;
                    Ds&neg.>$nk.>$gk = {t=>$gk,c=>{was=>$v}};
                }}
                
                # the yin change Ds&pos (tv nk/gk | Tv exp)
                # tv and Tv are indexes that may flatten the many
                each t,cv,Y a&tv {
                    # last one wins
                    push @{a&many.tv.>$t.>$cv ||= []}, shift @$Y
                        while @$Y > 1;
                    $Y = shift @$Y;
                    a&tv.>$t.>$cv = $Y; # count it
                    
                    Yc&el eq '8' && next; # sleep
                    Ds&pos.tv.>$t.>$cv = $Y;
                }}
                each t,cv,Y ds&tv {
                    a&tv.>$t.>$cv && next;
                    Yc&el eq '9' && next;
                    Yc&el = '9';
                    delete Ys&ord;
                    delete Ys&ready;
                    Y.up = $A; # receive Es&z
                    a&tv.>$t.>$cv = # remover to sort in?
                    Ds&pos.tv.>$t.>$cv = $Y;
                }}
                
                # values that were things
                # - transport intact
                # its A works out its sleeping el=8
                # set value in a&ng as handled things skip
                each ext,v a&Tv {
                    push @{a&many.Tv.>$ext ||= []}, shift @$v
                        while @$v > 1;
                    $v = shift @$v;
                    a&Tv.>$ext = $v; # count it
                    
                    # set value/transport intact
                    vc&nk && vc&gk || die "No ext nkgk: $ext: ".ki $v;
                    a&ng.>vc&nk.>vc&gk = vc&s;
                    
                    vc&el eq '8' && next; # sleep
                    # < no el=3 possible?
                    Ds&neg.>vc&nk.>vc&gk = {t=>vc&gk,c=>{s=>vc&s}};
                }
                each ext,v ds&Tv {
                    a&Tv.>$ext && next;
                    vc&nk && vc&gk || die "No ext nkgk: $ext: ".ki $v;
                    # deletes the value
                    Ds&neg.>vc&nk.>vc&gk = {t=>vc&gk,c=>{was=>vc&s}};
                }
                
                # may not need to move
                A&el = '8' unless Ds&neg || Ds&pos;
            }


            
            unless (a&clones) { #c generate replacable bodies, rev/insidest first
                $V && saybl "3 clones";
                my $d = A&last;
                my $D = A&diff;
                # a&ng is nk/gk = $v ground as is
                #   attributes including Tv things, they skipped diffing initially
                # Ds&neg is nk/gk = change C:
                #   c.s = $v if present, c.was if past
                #   be only trace of attribute/Tv thing if gone
                #   
                
                # a&tv.>$t.>$cv = $Y insides
                # Ds&pos.tv.>$t.>$cv = $Y also
                #   would be only trace of thing if gone,
                #     but needing to sort in the remover with a&tv
                #     should skip the Yc&el='9' when wiring non-lv
                #     but pop them out disconnected in Core
                
                # make clones, usu
                # - one to keep on record to diff
                # - one to give to processes unknown
                # - more? parallel
                # o is where ref integrity is most unlost/buried
                # < knowing all refs on $o, wire Cgen, pointerise lv
                for my $t (@{oc&clones}) {
                    my $E = {t=>C.t,y=>{cv=>C.y.cv}};
                    
                    if (1 && A&el eq '8') {
                        # cloning clones a semi-good idea
                        # < until we can sleep a limb
                        $E = a&clones.>$t = ds&clones.>$t
                            || die "el8 had no clone $t";
                        Es&z = [] if Es&z;
                    }
                    elsif (A&el eq '9') {
                        # never happens:
                        #  - Tv goners are Ds&neg-ations
                        #  - tv goners are a&tv.>$t.>$cv = old $Y
                        #    will be brought back into play with a&ord
                        #    but shouldn't emit non-lv objects
                    }
                    else {
                        A&el ||= Ds&allnew ? '1' : '3';
                    
                    }
                    if ($t eq 'lv') {
                        Ec&el = A&el if !defined Ec&el;
                    }
                    if (my $ys = oc&ysource) {
                        # oinD = in drain C
                        E.y.>$ys = $C;
                    }
                    if (my $sy = oc&sourcey) {
                        # in drain C.y.OC = $OC
                        C.y.>$sy = $E if $sy eq $t;
                    }
                    
                    if (A&isTv && $t ne 'lv') {
                        # if we are a Tv, transport intact?
                        # ups&ng will overwrite this anyway?
                        #   will find it through os&refs, be the same
                        #   but could change as this clone
                        $E = $C;
                    }
                    # the clone can see its A
                    E.y.A = $A;
                    
                    a&clones.>$t = $E;
                }
                
                # then sort in from first
                push @L, $A if A.up eq $o;
                next;
            }
            unless (a&ord) { #c ordering, gathering
                $V && saybl "4 ord";
                $V && saygr "Is io" if $A eq $io;
                # gathering refs, we already in order
                # first A's clones win pointing to
                # < is depth first tho...
                my $r = os&refs.>$C ||= {};
                #rc&s ne $C && die "refreplacing ".ki($r)."\n".ki$C;
                #rc&s = $C;
                push @{rs&Ys||=[]}, $A;
                
                # should know if v is:
                #   referenced somewhere else, for lv pointers
                #   a cloned C, to point to relevant clone
                #     dont y.out etc if trying to transport intact C
                each nk,gk,v a&ng {
                    ref $v || next;
                    my $r = os&refs.>$v ||= {};
                    a&whererefis.>$v = [$nk,$gk];
                    push @{rs&Ys||=[]}, $A;
                }}
                
                # now create more of that ^ order
                my @l;
                if (a&Tv) {
                    # eg Tv C masters yin C, unless Scuttled to hup
                    push @l, map { a&Tv.>$_ } sort keys %{a&Tv};
                }
                if (a&tv) {
                    # then cv/t
                    my $yttv;
                    each t,cv,Y a&tv {
                        $yttv.>$cv.>$t = $Y;
                    }}
                    for my $cv (sort keys %$yttv) {
                        my $tw = $yttv.>$cv;
                        for my $t (sort keys %$tw) {
                            my $Y = $tw.>$t;
                            push @l, $Y;
                        }
                    }
                    # sleepables here? refs compet should still work
                }
                a&ord = 'sure';
                # do these things before our next thing
                # to keep our order - unshift for @l would reverse it
                unshift @L, @l;
                # or our next us
                unshift @R, $A;
                next;
            }
            unless (a&ready) { #c set new values, forward
                $V && saybl "5 ready";
                $V && saygr "Is io" if $A eq $io;
                if ($A eq $io || A.up eq $o) {
                    # sort through the single pile of refs
                    $V && saygr "Looking through refs...";
                    my $refs = {};
                    each ref,r os&refs {
                        @{rs&Ys} > 1 || next;
                        (rs&Y) = @{rs&Ys};
                        $refs.>$ref = $r;
                        # becomes the definitive source of that ref
                        # may be its C for Tv/tv, some Cnkgk for ng
                        # so lv can be perfect
                    }
                    # leaves only doubled things
                    os&refs = $refs;
                }
                
                my $d = A&last;
                my $D = A&diff;
                
                # assign the correct refs
                # same order as refs won, so they should exist where pointed
                for my $t (@{oc&clones}) {
                    my $E = a&clones.>$t;
                    
                    # plot entanglements amidst assigning values
                    #   unless we're to transport intact
                    #   the right thing will be in Ys&clones by now
                    #
                    each nk,gk,v a&ng {
                        $E.>$nk.>$gk = $v;
                        my $r = ref $v && os&refs.>$v || next;
                        my $Y = rs&Y || die "Looks aban: $v ".ki $r;
                        next if $A eq $Y;
                        # other has the one thing
                        #  < link C that knows where either one is
                        #    keeping refs on the yonder A will do
                        if (my $nkgk = Ys&whererefis.>$v ) {
                            my $V = Yc&s;
                            my ($nk,$gk) = @$nkgk;
                            $V.>$nk.>$gk eq $v
                                || die "Refwasnotat ".ki[$v,$nkgk,$V];
                            $V = Ys&clones.>$t || die "noclone nkgk $t";
                            # may differ if Scuttled to...
                            $v = $V.>$nk.>$gk;
                        }
                        elsif ($v eq Yc&s) {
                            # is Tv implanting
                            #   or something in a ty somewhere
                            # should transport intact ref as clone
                            $v = Ys&clones.>$t || die "noclone $t";
                            # for an lv to tell of encoded properties
                            a&haveC.>$nk.>$gk = $v;
                        }
                        else {
                            die "TheresnorefonY ".wdump(5,[
                                "Were C.t A&ind, they are Y.c.s.t Y.c.ind",
                                "want $v from: ",[sort keys %{Ys&whererefis}],
                                Ys&whererefis,
                                $r,
                            ])
                            
                            .ki[$v,$Y];
                        }
                    }}
                    if ($t eq 'lv') {
                        my $neg = Ds&neg;
                        # lv: t y el=9, no detail (in up z tho)
                        $neg = {} if A&el eq '9';
                        # which are already there
                        each nk,gks $E {
                            ref $gks || next;
                            delete $E.>$nk.>$_ for
                                grep { !$neg.>$nk.>$_ } keys %$gks;
                        }
                        # to drop universals named in Ec&ds, etc
                        my $dn = {};
                        each nk,gk,q $neg {
                            if (!exists qc&s) {
                                $dn.>$nk.>$gk = 1;
                            }
                            else {
                                $E.>$nk.>$gk eq q.c.s || die "wasnt neg/ng"
                                    .ki[[$nk,$gk],$q,$E];
                            }
                        }}
                        # encoding this may need json
                        each nk,gks $dn {
                            $nk = 's' if $nk eq 'sc';
                            E.c->{"d$nk"} = join ' ', sort keys %$gks;
                        }
                        # the lv may a&haveC, locating C attr
                        #   and explaining their encoding
                        
                        # moment of life its for
                        Ec&el = A&el;
                        # the clone can (still) see its A
                        # clone of a clone might have E.y.OA
                        E.y.A = $A;
                    }
                    
                    # put for wiring to tv
                    if (!A&isTv && A.up ne $o) {
                        my $U = ups&clones.>$t || die "no upclone $t";
                        push @{Us&z||=[]}, $E;
                    }
                }
                a&ready = 1;
                push @R, $A;
                next;
            }
            unless (a&wiring) { #c link together, reverse
                $V && saybl "6 wiring";
                # to hoist the list of everything:
                #   Cora is where everything sorts into a flat list
                #   Core is same order with A&el=9 (removals) added
                #     and A&el=8 removed as far as order of everything is implied
                # then K makes a .prev if it's not Cora-order
                
                my $D = A&diff;
                $V && saygr "el=".A&el."  ".wdump 3, $D;
                
                for my $t (@{oc&clones}) {
                    my $E = a&clones.>$t;
                    # share clones their Cor(e|a) hoisty lists
                    my $net = a&clonet.>$t = {};
                    
                    
                    if (Es&z) {
                        # wire the tv plane, collect the big flat lists:
                        my $ra = []; # everything still there
                        my $re = []; # everything changing
                        my $la; # what to put before things in lv
                        for my $i (@{Es&z}) { # this clone's 
                            my $Y = i.y.A; # their A
                            my $wet = Ys&clonet.>$t;
                            $V && saygr "To the i.t i.y.cv and: ".ki wet.Cora;
                            
                            if (Yc&el ne '9') {
                                # the non-lv tv plane
                                push @$ra, $i;
                                # and load Cora
                                push @{net.Cora||=[]}, $i, @{wet.Cora||[]};
                            }
                            
                            # only re matters to lv, sparse negating C
                            # each y could link to tv reals
                            if (Yc&el ne '8') {
                                if ($la && $t eq 'lv' && Yc&el ne '3' && Yc&el ne '9') {
                                    # throw in el=8 for the thing before
                                    push @$re, $la if $ra->[-1] ne $la;
                                }
                                push @$re, $i;
                                push @{net.Core||=[]}, $i, @{wet.Core||[]};
                            }
                            $la = $i;
                        }
                        # lv wants to wire everything changing togehter
                        my $wi = $t eq 'lv' ? $re : $ra;
                        undef $la;
                        # cloned clones a possibility, why clonet.>$t = {} above
                        # would have these already
                        delete E.y.>$_ for qw'in out tw tv next prev fronts backs';
                        for my $i (@$wi) {
                            E.y.in ||= $i;
                            i.y.out = $E;
                            
                            my $was = E.y.tw.>i.t;
                            E.y.tw.>i.t = $i;
                            # would be easy to wire tw squish
                            (was.y.fronts,i.y.backs) = ($i,$was)
                                if $was;
                            # < lv comp fronts to cv of next bit
                            #   as topics' bits fly at you, to
                            #   signal when next bit is coming
                            
                            E.y.tv.>i.t.>i.y.cv = $i;
                            
                            if ($la) {
                                la.y.next = $i;
                                i.y.prev = $la;
                            }
                            $la = $i;
                        }
                        Es&z = $wi;
                    }
                    
                    # last clone (OC?) becomes A&s, or C if you steal this A's c/sc
                    A&s = $E;
                    # assume everything's parent will be active at the last hop
                    # so A&Core is everything changed and the top, nested in flat list
                    # look at C
                    a&Core = [$E,@{net.Core||[]}];
                    a&Cora = [$E,@{net.Cora||[]}];
                }
                a&wiring = 1;
            }
        }
        
        $V && sayre "Finished ".ki $o;
        # export some io sc to o
        o.sc.>$_ = io.sc.>$_ for qw'Core Cora';
        #@{os&Core} = # everything changed
        #@{os&Cora} = # everything
        os&lastA = $io;
        oc&s = io.c.s;
        
        $o;
    
t/o_simple: |
    my $et = G&Ct,[je=>''=>{s=>33}];
    my $je = et.y.in = G&hup,$et;
    je.t = 'jet';
    et.c.s = 44;
    my $i;
    et.sc.z = [
        map {_.y.cv = "0.03".$i++;
            _.y.in.t .= "eee";
            _.y.in = G&hup,_.y.in;
            $_}
        map { G&hup,$et } 1..4
    ];
    
    my $r = et.sc.z->[3];
    r.t = 'elab';
    r.c.s = 'deal';
    rs&z = [map{ G&Ct,['built'=>$_=>'several'] }1..4];
    et.t = "Entry";
    my $C = G&Ct,['o_simple'];
    
    my $da = {map{$_->[0], [split/\n/,$_->[1]] }
         [Cora_1=><<''],
            1Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            1  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            1    jeteee  (A othisD out) s -- s=33  %  
            1  je 0.031 (A backs fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeee ]
            1    jeteeeeee  (A othisD out) s -- s=33  %  
            1  je 0.032 (A backs in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            1    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            1  elab 0.033 (A in othisD out prev tv tw) s % z -- s=deal  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            1    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            1    built 0.2 (A backs fronts next othisD out prev) s -- s=several  %  
            1    built 0.3 (A backs fronts next othisD out prev) s -- s=several  %  
            1    built 0.4 (A backs othisD out prev) s -- s=several  %  

 
      [Core_1=><<''],
            1Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            1  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            1    jeteee  (A othisD out) s -- s=33  %  
            1  je 0.031 (A backs fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeee ]
            1    jeteeeeee  (A othisD out) s -- s=33  %  
            1  je 0.032 (A backs in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            1    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            1  elab 0.033 (A in othisD out prev tv tw) s % z -- s=deal  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            1    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            1    built 0.2 (A backs fronts next othisD out prev) s -- s=several  %  
            1    built 0.3 (A backs fronts next othisD out prev) s -- s=several  %  
            1    built 0.4 (A backs othisD out prev) s -- s=several  %  



    
    # nothing changes
          [Cora_2=><<''],
            8Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            8  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            8    jeteee  (A othisD out) s -- s=33  %  
            8  je 0.031 (A backs fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeee ]
            8    jeteeeeee  (A othisD out) s -- s=33  %  
            8  je 0.032 (A backs in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            8    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            8  elab 0.033 (A in othisD out prev tv tw) s % z -- s=deal  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            8    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            8    built 0.2 (A backs fronts next othisD out prev) s -- s=several  %  
            8    built 0.3 (A backs fronts next othisD out prev) s -- s=several  %  
            8    built 0.4 (A backs othisD out prev) s -- s=several  %  

        [Core_2=><<''],
            8Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]

    
    # elab changes, je 030 goes
    
          [Cora_3=><<''],
            3Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            8  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8  je 0.031 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeee ]
            8    jeteeeeee  (A othisD out) s -- s=33  %  
            8  je 0.032 (A backs in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            8    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            3  elab 0.033 (A in othisD out prev tv tw) s % z -- s=eye  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            8    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            8    built 0.2 (A backs fronts next othisD out prev) s -- s=several  %  
            8    built 0.3 (A backs fronts next othisD out prev) s -- s=several  %  
            8    built 0.4 (A backs othisD out prev) s -- s=several  %  


        [Core_3=><<''],
            3Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            9  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            3  elab 0.033 (A in othisD out prev tv tw) s % z -- s=eye  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]

    # add some twa to je, the twa in ks&watch should not have y.in, or be in Core/a
      [Cora_4=><<''],
            3Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            8  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8  je 0.031 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeee ]
            8    jeteeeeee  (A othisD out) s -- s=33  %  
            3  je 0.032 (A backs in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeeeeee,twa,twa,twa,twa ]
            8    jeteeeeeeeee  (A next othisD out) s -- s=33  %  
            1    twa 0.3 (A fronts next othisD out prev) s % hs -- s=Memb  %  hs=394
            1    twa 0.31 (A backs fronts next othisD out prev) s % hs -- s={  %  hs=394
            1    twa 0.32 (A backs fronts in next othisD out prev tv tw) s % hs watch z -- s=Memb  %  hs=294 watch={ t=twa y={ cv=0.33 } c={ s=} } sc={ hs=395 } } z=[ twa ]
            1      twa 0.33 (A othisD out) s % hs -- s=}  %  hs=395
            1    twa 0.33 (A backs othisD out prev) s % hs -- s=}  %  hs=395
            3  elab 0.033 (A in othisD out prev tv tw) s % z -- s=eye  %  z=[ jeteeeeeeeeeeee,built,talk,built ]
            8    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            1    talk 0.29 (A next othisD out prev) gr % sun -- gr=tango  %  sun=4
            8    built 0.4 (A backs othisD out prev) s -- s=several  %  

      [Core_4=><<''],
            3Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            3  je 0.032 (A backs in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeeeeee,twa,twa,twa,twa ]
            1    twa 0.3 (A fronts next othisD out prev) s % hs -- s=Memb  %  hs=394
            1    twa 0.31 (A backs fronts next othisD out prev) s % hs -- s={  %  hs=394
            1    twa 0.32 (A backs fronts in next othisD out prev tv tw) s % hs watch z -- s=Memb  %  hs=294 watch={ t=twa y={ cv=0.33 } c={ s=} } sc={ hs=395 } } z=[ twa ]
            1      twa 0.33 (A othisD out) s % hs -- s=}  %  hs=395
            1    twa 0.33 (A backs othisD out prev) s % hs -- s=}  %  hs=395
            3  elab 0.033 (A in othisD out prev tv tw) s % z -- s=eye  %  z=[ jeteeeeeeeeeeee,built,talk,built ]
            9    built 0.2 (A backs fronts next othisD out prev) s -- s=several  %  
            1    talk 0.29 (A next othisD out prev) gr % sun -- gr=tango  %  sun=4
            9    built 0.3 (A backs fronts next othisD out prev) s -- s=several  %  




    # 
    
    
    
    
    
    
    
    
    
    

    };
    my $s;
    my @fail;
    my $one = G&Ct,['One'=>1];
    for my $i (1..4) {
        my $et = $et;
        
        A.V = 0;
        
        if ($i == 3) {
            shift @{et.sc.z};
            r.c.s = 'eye' if $i == 3;
        }
        if ($i == 4) {
            my $rz = r.sc.z;
            @$rz = (shift @$rz, G&Ct,['talk'=>29=>{gr=>'tango'},{sun=>4}] , pop @$rz);
            my $r = et.sc.z->[1];
            rs&z = [
                G&Ct,[twa=>3=>"Memb"=>"hs:394"] ,
                G&Ct,[twa=>31=>"{"=>"hs:394"] ,
                G&Ct,[twa=>32=>"Memb"=>"hs:294"] ,
                G&Ct,[twa=>33=>"}"=>"hs:395"] ,
            ];
            my $k = rs&z->[2];
            ks&watch = rs&z->[3];
        }
        
        #A.V = 1 if $i == 2;
        #exit if $i == 3;
        
        my $d = G&o,$et,{liveon=>$C,t=>'this'};
        $s = dc&s;
        
        A.V = 1;
        my $eg = s.y.in.y.next.y.next;
        sayyl "eg.y.A.c.el: ". G&aC,$eg;
        
        for (qw'Cora Core') {
            my $t = $_.'_'.$i;
            my @l = @{d.sc.>$_ || []};
            
            #my ($to,$th) = @l[2,3];
            #saybl "Have: ".wdump 3, [to.y.in,th.y.in];

            my $r = $da.>$t;
            my $l = [map { 
                _.y.A.c.el. join('',('  ')x _.y.A.c.ind).
                G&aC,$_  ." -- ".ki(_.c)."  %  ".ki(_.sc)
            } @l];

            my $fail = 0;
            if (!$r) {
                $fail++;
            }
            else {
            
            my $miss; # show gaps
            for my $ls (@$l) {
                my $rs = shift @$r;
                ($rs) = '<undefined>', $fail++ if !defined $rs;
                if ($ls eq $rs) {
                    $miss = '...' if defined $miss;
                    next;
                }
                sayre $miss if $miss;
                $miss = '';
                sayre "Line: $ls", "Isnt: $rs";
                $fail++
            }
            sayre "Line!", "Isnt: $_" for @$r;
            
            }

            after: my $i = ++Gc&oki;
            if ($fail) {
                sayre "not ok $i - $t";
                saybl ' ',' ',"      [$t=><"."<"."''],";
                saybl map { "            $_" } @$l;
                saybl '','','';
                push @fail, "$i - $t";
            }
            else {
                saygr "ok $i - $t";
            }
        }
    }
    exit;
    @fail ? join(", ", @fail) : ();

