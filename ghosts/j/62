SenseCertainty: | # clamorous industrial junkseeing
    # travelling bit outliner
    # < becomes subordinate to FactorEase
    n SirKill
    
    # not too useful
    #n Compliers
    
    # travelling somethingers
    # < use G&o instead
    n Walks
    # dead ends of A.t=o
    n Stashi
BuildSir: |
    my $e = djson <<'';
        {"c":{"W":"Jig","e":{"c":{"pi":"Gdo","s":"An Update"},"sc":{"z":[{"c":{"W":"SirKill"},"t":"SirKill"},{"c":{"W":"SenseCertainty"},"t":"SenseCertainty"},{"c":{"W":"Process"},"t":"Process"},{"c":{"W":"HaMachine"},"t":"HaMachine"}]},"t":"peace/new","y":{"cv":""}}},"sc":{},"t":"Jig","y":{"cv":""}}
    
    Rw CloningProcess;
    #
    Gc&bay = 'peace';
    n $e
    
    sayre "Become thingz!";
    exit;
    
    #
t/o_simple: |
    my $et = G&Ct,[je=>''=>{s=>33}];
    my $je = et.y.in = G&hup,$et;
    je.t = 'jet';
    et.c.s = 44;
    my $i;
    et.sc.z = [
        map {_.y.cv = "0.03".$i++;
            _.y.in.t .= "eee";
            _.y.in = G&hup,_.y.in;
            $_}
        map { G&hup,$et } 1..4
    ];
    
    my $r = et.sc.z->[3];
    r.t = 'elab';
    r.c.s = 'deal';
    rs&z = [map{ G&Ct,['built'=>$_=>'several'] }1..4];
    et.t = "Entry";
    my $C = G&Ct,['o_simple'];
    
    my $da = {map{$_->[0], [split/\n/,$_->[1]] }
    
        [Cora_1=><<''],
            1Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            1  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            1    jeteee  (A othisD out) s -- s=33  %  
            1  je 0.031 (A fronts in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeee ]
            1    jeteeeeee  (A othisD out) s -- s=33  %  
            1  je 0.032 (A in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            1    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            1  elab 0.033 (A in othisD out prev tv tw) s % z -- s=deal  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            1    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            1    built 0.2 (A fronts next othisD out prev was) s -- s=several  %  
            1    built 0.3 (A fronts next othisD out prev was) s -- s=several  %  
            1    built 0.4 (A othisD out prev was) s -- s=several  %  

    
        [Core_1=><<''],
            1Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            1  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            1    jeteee  (A othisD out) s -- s=33  %  
            1  je 0.031 (A fronts in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeee ]
            1    jeteeeeee  (A othisD out) s -- s=33  %  
            1  je 0.032 (A in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            1    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            1  elab 0.033 (A in othisD out prev tv tw) s % z -- s=deal  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            1    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            1    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            1    built 0.2 (A fronts next othisD out prev was) s -- s=several  %  
            1    built 0.3 (A fronts next othisD out prev was) s -- s=several  %  
            1    built 0.4 (A othisD out prev was) s -- s=several  %  

    
    # nothing changes
    
        [Cora_2=><<''],
            8Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]
            8  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            8    jeteee  (A othisD out) s -- s=33  %  
            8  je 0.031 (A fronts in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeee ]
            8    jeteeeeee  (A othisD out) s -- s=33  %  
            8  je 0.032 (A in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            8    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            8  elab 0.033 (A in othisD out prev tv tw) s % z -- s=deal  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            8    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            8    built 0.2 (A fronts next othisD out prev was) s -- s=several  %  
            8    built 0.3 (A fronts next othisD out prev was) s -- s=several  %  
            8    built 0.4 (A othisD out prev was) s -- s=several  %  

    
        [Core_2=><<''],
            8Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,je,elab ]

    
    # elab changes, je goes
    
    
        [Cora_3=><<''],
            3Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            8  jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8  je 0.031 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteeeeee ]
            8    jeteeeeee  (A othisD out) s -- s=33  %  
            8  je 0.032 (A in next othisD out prev tv tw was) s % z -- s=44  %  z=[ jeteeeeeeeee ]
            8    jeteeeeeeeee  (A othisD out) s -- s=33  %  
            3  elab 0.033 (A in othisD out prev tv tw) s % z -- s=eye  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]
            8    jeteeeeeeeeeeee  (A next othisD out) s -- s=33  %  
            8    built 0.1 (A fronts next othisD out prev) s -- s=several  %  
            8    built 0.2 (A fronts next othisD out prev was) s -- s=several  %  
            8    built 0.3 (A fronts next othisD out prev was) s -- s=several  %  
            8    built 0.4 (A othisD out prev was) s -- s=several  %  

        [Core_3=><<''],
            3Entry  (A in othisD tv tw) s % z -- s=44  %  z=[ jeteeeeeeeeeeee,je,je,elab ]
            9  je 0.030 (A fronts in next othisD out prev tv tw) s % z -- s=44  %  z=[ jeteee ]
            3  elab 0.033 (A in othisD out prev tv tw) s % z -- s=eye  %  z=[ jeteeeeeeeeeeee,built,built,built,built ]

    
    
    
    
    
    
    
    
    
    
    

    };
    my $s;
    my @fail;
    for my $i (1..3) {
        my $et = $et;
        
        A.V = 0;
        
        if ($i == 3) {
            shift @{et.sc.z};
            r.c.s = 'eye' if $i == 3;
        }
        
        
        my $d = G&o,$et,{liveon=>$C,t=>'this'};
        $s = dc&s;
        A.V = 1;
        
        for (qw'Cora Core') {
            my $t = $_.'_'.$i;
            my @l = @{d.sc.>$_ || []};
            
            #my ($to,$th) = @l[2,3];
            #saybl "Have: ".wdump 3, [to.y.in,th.y.in];

            my $r = $da.>$t;
            my $l = [map { 
                _.y.A.c.el. join('',('  ')x _.y.A.c.ind).
                G&aC,$_  ." -- ".ki(_.c)."  %  ".ki(_.sc)
            } @l];

            my $fail = 0;
            if (!$r) {
                $fail++;
            }
            else {
            
            my $miss; # show gaps
            for my $ls (@$l) {
                my $rs = shift @$r;
                ($rs) = '<undefined>', $fail++ if !defined $rs;
                if ($ls eq $rs) {
                    $miss = '...' if defined $miss;
                    next;
                }
                sayre $miss if $miss;
                $miss = '';
                sayre "Line: $ls", "Isnt: $rs";
                $fail++
            }
            sayre "Line!", "Isnt: $_" for @$r;
            
            }

            after: my $i = ++Gc&oki;
            if ($fail) {
                sayre "not ok $i - $t";
                saybl '','',"    [$t=><"."<"."''],";
                saybl map { "            $_" } @$l;
                saybl '','','';
                push @fail, "$i - $t";
            }
            else {
                saygr "ok $i - $t";
            }
        }
    }
    @fail ? join(",", @fail) : ();

