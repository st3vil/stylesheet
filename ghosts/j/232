Topo: | # and - the activity DEST 25
    # Topo - single read/writer
    #   to know more W about Four/Five/etc than you need to
    #   for async G&t lookup and allocation
    #   writable stuff given to it, knows the 1-5 non-git form
    #   W pushed outside of the G must be commit
    
    # Tri - pushing G frontiers of language
    # Typ - molten C edits of stuff in G
    
    this file, rebuild everything hut,
    from om, html, bootstrapping Is through 4s&in, mixing, starting
    so that J Jins J, reelecty hierarchy
    and there are various safety mechanisms
Cluts: | # ore - the matrial
    # land upon body,
    # balance neuron attention
    # into time, around tasks
    G&heading,'Hz:50';
    1s&ein.have = &acgts{
        1s&have = s;
    };
    S
    n had -yod $s:1s&have
Ch: | # swim channel, check tv
    G&heading,'Hz:50';
    1s&store = &s{
        # Serialise s&top;
    };
    
    1s&the ||= {};
    # < elvis hook specifically for events on/in a thint
    G&u,['NutIns'];
    G&u,['NutText'];
    S
    
    n loadsave o1 s:<^v> %dis:block
    n surftv -tain s:Fly
    1s&M
pi/tain: | # access the network + chain effects
    G&heading;
    1s&the ||= 3s&the;
    1s&ein.says = &acgtsc{
        # c in here is the main point of the point,
        #   it may be below other vaguer intentions,
        #   and above tiny details
        # probably $d = G&E:'hC -1';
        1s&the[c.t] = s;
    };
    S
    # make editable starting point
    1s&the.W ||= 'Fly';
    n W 3  %e:2
    # show how that goes
    
    
    $n =
    n $1s&the.W V
    $j = ns&J;
    
    !j and return n waits -yod $s:n,dl:3 %
    $s = js&s;
    !s and return n waits 1 s:waitss %
    
    #delete js&brains;
    #return;
    $tops = ss&lv;
    #tops = [ss&top];
    
    each il tops {
        $l;
        try {
        $l = G&Serialise,l;
        }
        catch (er) { l = "Error: "+er+": "+ki(l) }
        $n =
        n toL 15 $s:l %hue:1$i+9deg,ws:pre,dis:block,ma:1em
        n.y.cv += 0.015 * i;
    }
    
    
    
pi/yod: | # dada dumper with an urge to wire up
    # see -jod for the normal this is a mode on
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    n te o1 $s:C.t %hue:60deg
    
    c&v &&
    n v o2 $s:c&v %hue:80deg
    
    $s = c&s;
    !isC(s) and return n Thing 3 $s:ki(c&s,c&dl||3)
    
    s&sym='C';
    n sym o2 $s:s&sym %bri:6,opa:0.4,fs:450%,poi:none,ab:1,lh:40%,zi:-5000
    
    n t o3 $s:s.t %hue:160deg,fs:133%
    
    s.y.cv != 0.1 &&
    n cv o31 $s:s.y.cv %hue:160deg,fs:133%
    
    n y -yit $s:s
    n c -yit $s:s
    n sc -yit $s:s %hue:30deg
pi/yit: |
    ys&ma = '0.4em';
    $S = c&s;
    typeof S != 'object' and return n other 1 $s:ki(S)
    $s = ex({},S[C.t]);
    C.t == 'y' and delete s.cv; # above
    
    
    n thing 3 $s:ki(s,4)
    
Who: | # lis, wandering We things
    G&heading;
    G&n,['Name',3,{s:"Fand"},{e:2}];
    
    
Typ: | # exact lounge
    # TO give at a glance a pretty good idea of where you are
    # in the colour code of
    G&heading;
    #G&u,['MelIns'];
    G&u,['MelTest'];
    G&u,['NutText'];
    G&clusp;
    1s&M ||= [];
    1c&ghosts ||= {};
    
    $me = 1c&methods = {};
    me.http = &to,s,cb{
        $da = {};
        s !== null and da.s = s
        $r = $.ajax({url:to,data:da});
        r.done(&ns,how,c{
            r.status != '200' and 1s&M.push("Bad "+to+": "+r.status);
            1s&M.push("Got "+how+": "+ns);
            cb and cb(dej(ns));
        });
    };
    
    1s&ein['says'] = {w:'says/Typ'};
    
    # store also
    1c&N ||= [ G&Cye,['Rests','-typ'] ];
    
        
    ~>3 Ze colour: 1s&i, '>1 one', '>2 two', '>3 three', '>4 four',  '>5 five',  '>6 six', '>7 seven', '>8 eight', '>9 nine'
    
    each in 1c&N {
        m $n
    }
    each in 1s&M {
        m SE -jod $s:n
    }
    
    #$m = G&n:['overflow:scroll','-jod_7',{s:A,dl:4}];
        
    #1c&save = "lo";
    
pi/typ: | # a code
    ys&dis = 'block';
    # 
    $init = !1s&brains;
    $me = 3c&methods;
    $s = 3c&ghosts[C.t];
    if (s == null) {
        s = '# ';
        if (init) {
            me.http('Getc/Ty/'+C.t,null,&d{
                d.ok != 'found' and return
                3c&ghosts[C.t] = d.s;
                ~Resolute: C.t
                G&yl:500,&{ G&e,['Typ'] };
            });
        }
    }
    G&n,['Name',3,{s:C.t},{e:2}];
    
    
    if (1s&alive == 2) {
        s != 1s&s.sc.top.y.tw.Content.c.s and 1s&alive = 1
    }
    if (1s&alive == 1) {
        $L = G&e,['Launch'] .sc.J;
        if (!Ls&child) {
            ~Chilute: C.t
            G&yl:700,&{ G&e,['Typ'] };
        }
        else {
            $Y = A;
            A = Ls&child;
            if (!Ls&shrank) {
                $(A.on.parentNode).css('top','20%').css('height','')
                .find('#msgs').css('min-height','20em');
                #Ls&shrank = 1;
            }
            G&e,[C.t];
            A = Y;
            1s&alive = 2;
        }
    }
    n o 31 s:o %ma:2em,hue:42deg,dos:typ/Live:C.t
    
    G&n,['Content',4,{s:s},{e:1}];
    
typ/Live: | # a life to a code
    # 
    G&e,['Launch'];
    $g = G&E,'hC' [1];
    g = gs&J;
    gs&alive = 1;
    
    #
    
says/Typ: | # handle putting
    $c = G&E:'hC -1';
    $g = G&E,'hC' [1];
    #debugger;
    $me = 1c&methods;
    if (c.t == 'Name') {
        g.t == ec&s and return
        $o = g.sc.J.sc.root.y.tw.Content;
        #debugger;
        o.t != 'Content' and debugger;
        
        me.http('Getc/Ty/'+g.t,'');
        me.http('Getc/Ty/'+ec&s,oc&s);
        each in 1c&N {
            n.t != g.t and continue
            n.t = ec&s;
        }
        delete 1c&ghosts[g.t];
        1c&ghosts[ec&s] = oc&s;
        ~Named: g.t, ec&s
        
        # change the name/write in a new place
        # < reset pre-name-change changes to Content, dividing history as:
        #   (thing became as it is), GAP, (changes to thing, renamed to thing2)
        #   with link between...
        
    }
    else
    if (c.t == 'Content') {
        if (cc&s != ec&s) {
            # diff and save
            ~Typ now sez: ec&s
            me.http('Getc/Ty/'+g.t,ec&s);
            3c&ghosts[g.t] = ec&s;
        }
    }
    ~>3 says/Typ:
    
Tyrade: | # Wed for Typ: crud of/t=strings, way with
    # adopted from 24 Wade, W change negotiator
    # see also 242 Spade, bulk version checkings
    # 
    any '/Getc/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        my $patch = $c->param('patch') && die "know patch";
        my $cache = G.Gache ||= {};
        
        my $pipe = $1 if $t =~ s/\|(\w+)$//;
        # read t, write if s
        # all there
        $t = "G/$t";
        # char safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        
        my $f = "$t";
        
        # returns json:
        my $re = {ok=>0};
        
        if (defined $s) {
            # optional safety - must replace such dige
            my $pa = $c->param('parent');
            if ($pa && $pa ne $cache.>$f ) {
                re.er = 'not ffwd';
                # could give out tree since...
                $s = '';
                # re.dige = $cache.>$f ;
            }
            elsif (!length $s) {
                `rm $f`;
                re.ok = 'deleted';
            }
            else {
                my $dirbit = $1 if $f =~ /^(.+)\/\w+$/;
                $dirbit || die "No dirbit";
                -d $dirbit || `mkdir -p $dirbit`;
                
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.er = 'not found'
            }
        }
        if (length $s) {
            # it should have a dig
            my $dig = slm(12,dig($s));
            $cache->{$f} = $dig;
            re.dige = $dig;
            re.s = $s;
            # if they know its hash, assume they don't need the string again
            if (my $ha = $c->param('have')) {
                delete re.s if grep {$_ eq $dig} split "\t", $ha
            }
        }
        $c->render(text=>sjson($re));
    };
Tri: | # travel
    G&heading;
    # sends G by setting T they sprout from
    # u t - declare find-and-change thing, usually into being
    #  making an I that matches (finds) and applies change,
    #ys&mb = '30%';
    
    # waddley
    G&u,['NutText'];
    G&clusp;
    
    # navigation/breadcrumb
    # < click to reposition/wake
    # < leave what you didn't interact with
    n other 1 s:Ge %jela:5,dos:SwitchupEl:4msgs:css:overflow:hidden/scroll
    n otheR 11 s:R %jela:5,dos:SwitchupEl:4msgs:css:position:absolute/fixed
    n rm 11 s:rm %jela:5,dos:SwitchupEl:4on:W:leftbehind:slideUp
    
    'Typ Fly Clalia Shovel Ch Launch Expect Ventur Revisit Bystand Sevo'
    .split(' ').map(&s{
        n $s 13 $s:s %ma:0.3em,dow:do/Launch
    });
    
    n Sevotic 13 s:Sevotic %ma:0.3em,dow:Sevoticate
    # the name, renamable
    G&n,['Name',3,{s:"Steve"},{e:2}];
    
    1s&ein['C+says'] = 'says:intent:overwrite';
    1s&ein['A+says'] = 'says:intent:expand';
    1s&ein['says'] = {w:'says/Tri'};
    
    
    # where latest ^ gets down
    $src = "$('body > nexpectn')[0].A[1].sc.s.sc.lv[3].sc.z";
    G&n,['Content',4,{s:src},{e:1}];
    
    1s&runput and G&n:['Wheer','-jod_6',{v:1s&runtime,s:1s&runput,dl:4}];
    
    if (1s&M.length) {
        each in 1s&M {
            i == 6 and G&n,['many',5,{s:'...'}]; break
            i = i * 0.001;
            G&n,['ane',4+i,{s:n},{dis:'block'}];
        }
    }
    
says/Tri: | # code is said
    $c = G&E:'hC -1';
    if (c.t == 'Name') {
        # change the name/write in a new place
        # < reset pre-name-change changes to Content, dividing history as:
        #   (thing became as it is), GAP, (changes to thing, renamed to thing2)
        #   with link between...
        
    }
    else
    if (c.t == 'Content') {
        if (cc&s != ec&s) {
            # diff and save
        }
        #debugger;
        $B = Gc&B;
        $was = Bs&way;
        Bs&way = e;
        
        # not finding any way to get line numbers from syntaxerrors in eval
        # TODO maybe jslint/jshint can help diagnosure?
        if (0) {
            $cod = "window.funcifunc = function() {\n"+ec&s+"\n}";
            try { 
            #eval(cod);
            var lu;
            #var lu = $('<script/>')[0]; $(lu).html(cod).appendTo($('head'))[0];
            var ul = Function(ec&s);
            #window.funcifunc;

            }
            catch(e) { var za = e }
            $(lu).remove();
            #debugger;
            $ln = za && za.lineNumber;
            $or = za;
            za and za = za.stack;
            console.log("EVA:",ln, ul, za, or);
        }
        
        $evaler = &s{
            # more of it
            return eval(s);
        };
        
        $r = evaler(ec&s);
        Bs&way = was;
        1s&runput = r;
        1s&runtime ||= 0;
        1s&runtime++;
    }
    ~>3 says/Tri:
    
Sevoticate: |
    G&e,['Sevo'],['C+click','',{p:'t'}];
    T.ok = 1;
    
Sevo: |
    G&heading;
    # anything
    n anything 2 s:anything %fs:300%,blr:3px
    =pod
    
    A is causality cones,     spreading
    C is causing thing,       growing
    G is a receptive ground,  filled
    T is a trouble hoist,     empty
    
    We shall get diff/patch speaking quietly over websockets to the babz,
    eventually getting everything in js and building castles all over.
    
    24 NutThing has:
     h to call a function, looking for t[0]='i', t[1]=name via:
     t looks up a thing (named) or two (named in named)
    24 NutIns began:
     ting looking further (async) for things to push/pull and protocol
    
    the only global, called H(A,C,G,T,[of,t],args[],c,sc)
    so immediately localised along A
    looking for something to do such with
    the such is C-like, so it could have:
      where that particular thing should be (of,t or more fuzzy)
      a push/pull supplied,
        brokered by a protocol/boundary-handler J
        with H gating usage to up-to-dateness,
          entering existing E sidetrack if...
      a melted down compilation one day
    H is a join (or separation) of two pieces
      notions -> actuality
    
    < still coded G&func?
    
    =cut
    $start = &{
        $A = {y:{},c:{},sc:{}};
        $C = {t:(new Date).toISOString(),y:{},c:{},sc:{}};
        $G = {y:{},c:{},sc:{}};
        $T = {y:{},c:{},sc:{}};
        A = H&A,'start';
        # < loop comebacks for all attentions
        # to check our light cone is still plugged in:
        #   A.el.ownerDocument.contains(el)
    };
    $H = &acgttycs{
        typeof t == 'string' and t = ['i',t]
        typeof y == 'object' and c = {args:y}
        c ||= {};
        $sc = s || {};
        c.push and throw "this thing wants to be this thing"
        c.pull and throw "this thing is wanted"
        # < pull also acquired from looking
        
    };
    
    G&way,'Steev';
    
    
    
    
    

