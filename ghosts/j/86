Gallip: |
    Gc&Glan = 'Elan' if G.d;
    # Lst Gs and their 5ings
    Rw Tiot;
    S
    
    
    n lies=>-lise_1=>"G.d/ip{,/*/{W,G}*}",'%qz,fs'
    
    n grouped=>-filspile_2=>{s=>T.op}
    return;
    #,'qz'
    
    n lies=>-od=>{s=>T.op}
    
    
    
pi/filspile: | # hier filses
    # put files inside one another
    # all separation points must be supplied
    # < group ooo2,ooo3 as ooo{2,3}
    # groups ips and dirs
    T.op = $s;
    my @l = G&op,'spi:fils';
    my @p; # the path
    
    n sse=>-od=>{s=>$s}
    for my $C (@l) {
        C.y.fils = C.y.D;
        while (@p) {
            my $l = $p[-1];
            if (C.t =~ /^l.t(.+)$/) {
                C.y.parent = $l;
                s&bit = $1;
                push @{ls&z}, $l;
                last;
            }
            else {
                pop @p;
            }
        }
        push @p, $C;
    }
    my @tops = grep { !C.y.parent } @l;
    die "No tops: ".ki\@l if !@tops && @l;
    
    my @l = map { G&ind,$_ } @tops;
    my $have;
    for my $C (@l) {
        $have.>C.t ++;
        sayyl "IOn: ".ki $C;
        next if c&ind > 2;
        m C.t=>-od=>{depth=>c&ind,s=>C.y.C}
    }
    if (my @dont = grep { !$have.>_.t } @l) {
        my $me = "(circular mounting?) Dont have "
            .ki\@dont;
        warn $me;
        n ohno=>o5=>"!! $me",'dis:1,hs:577'
    }
    
    
    some:
        thing
    some 3:
        else
    
    

