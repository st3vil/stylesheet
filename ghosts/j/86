Gallip: |
    Gc&Glan = 'Elan' if G.d;
    # Lst Gs and their 5ings
    Rw Tiot;
    S
    
    
    n lies=>-lise_1=>"G.d/ip{,/*/{W,G}*}",'%qz,fs'
    
    n grouped=>-filspile_2=>{s=>T.op}
    return;
    #,'qz'
    
    n lies=>-od=>{s=>T.op}
    
    
    
pi/filspile: | # hier filses
    u Walkit
    S
    # put files inside one another
    # all separation points must be supplied
    # < group ooo2,ooo3 as ooo{2,3}
    # groups ips and dirs
    T.op = $s;
    my @l = G&op;
    my @p; # the path
    
    #n est=>-od=>{s=>\@l}
    
    for my $C (@l) {
        saybl "C.t is";
        delete C.y.>$_ for qw'in next';
        C.y.fils = C.y.D;
        insi: while (@p) {
            my $l = $p[-1];
            # dirs split / and ips split .
            if (C.t =~ /^l.t(\W+)(.*)$/) {
                sayre "^ l.t  $1 -> $2";
                C.y.parent = $l;
                s&sep = $1;
                s&bit = $2;
                push @{ls&z||=[]}, $C;
                last insi;
            }
            else {
                pop @p;
            }
        }
        push @p, $C;
    }
    my @tops = grep { !_.y.parent } @l;
    die "No tops: ".ki\@l if !@tops && @l;
    
    
    my $y = &Cd{
        c&ind = d.d;
        d.hitip = 1 if s&sep eq '.';
        d.not = 1 if d.hitip && s&sep eq '/';
        $C
    };
    my @l = map { G&ind,$_,$y,{cbfirst=>1} } @tops;
    my $have;
    my @gl = map { G&aC,$_ } @l;
    for (@l) {
        my $t = defined _s&bit ? _s&bit : _.t;
        my $s = "_c&ind -- ".G&aC,$_;
        $s = " sep=_s&sep  _.t";
        m $t=>-od=>{depth=>_c&ind,s=>$s}
    }
    
    return;
    
    

