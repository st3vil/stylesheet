Impsev: | # restart lv when wil > 7
    if (ar.and eq 'init') {
        # normal-ish web state starting new log, eg Te
        # knows its last 1, restarts 7ing
        unless (1s&lastmo) {
            sayre "A.1.t's init imping";
            1c&imping = 1 
        }
    }
    if (my $s = 1s&s) {
        if (ss&wil > 7) {
            sayre "A.1.t's wil=ss&wil imping";
            1c&imping = 1
        }
    }
    A.mo.sc.lastmo = 1s&lastmo;
    1s&lastmo = A.mo;
EatsPi: | # add things you like to eat
    for my $pi (@{ar.m}) {
        Js&ein.pi.>$pi ->{sMJ} = &sMJje{
            1 && saybl "Havi J.t: ".G&aC,$e;
            Rw PutThingAfterSource $e $M;
        };
    }
PutThingAfterSource: | # stitch into M for EatsPi
    # $e is a $c, clicked on pi
    my $c =
    m e.t, {C=>$e,cv=>e.y.cv}, e.c, e.sc
    c.y.up && warn "M doesnt deyer";
    
    my $s = e.y.up || die "no eyup";
    $s = ss&J || die "no J";
    my $i = 1;
    my @S = $s;
    push @S, $s = s.2 until $i++ > 20 || s.2 eq s.3 || $s eq s.3;
    $i > 20 && die "2 follow Swierdness: ".ki \@S;
    
    my @is = grep { _.t eq s.1.t } @$M;
    if (@is == 1) {
        @$M = grep { $_ ne $c } @$M;
        @$M = map { $_ eq $is[0] ? ($_,$c) : $_ } @$M;
    }
EatPi: | # hope throwing this pi ($c) into somewhere (e J.t) will do something
    sayre "Hoping J.t will like ".G&aC,$c;
    G&elph,J.t=>$c;
    T.pos = '';
Remembers: | # feedback loop (piFeedTape) favouring Js&top over Js&M
    # resume, even as !W and without FourSleep
    Jc&save = 1;
    Js&top ||= Rw ReadMe;
    delete Js&M;
    # feedback from tv, since no Js&M ^
    Rw piFeedTape;
piFeedTape: | # your J state recovery - Js&M ||= Js&top for s&mix, s->cpi, dedupenames
    # Tiot shiftclick empties Js&M
    Js&Simp = 'Sweeptapes';
    Js&Cimp = 'Detapes';
    # writes s&mix=1 on everything to feedback
    if (!Js&M) {
        # init saved/feedback
        my $t = Js&top;
        my $M = Js&M = [];
        m $_ for grep{_s&mix} @{ts&z||[]};
    }
    if (!@{Js&M||[]}) {
        my $M = Js&M;
        if (my $d = ar.default) {
            m ref $d ? $d : split(":", $d)
        }
    }
    m $_ for @{Js&M||[]};
    
    delete _.y.cv for @$M;
    _c&pi = delete _s&pi for grep{_s&pi} @$M;
    if (0) {
    # pi sc become c ^
    # unless waiting for waves of things to come up...
    my $i = 1s&Feedbowlings++;
    for (grep{!$i && _s&pi eq 'way'} @$M) {
        _s&pi = delete _c&pi ;
        delete Jc&save;
    }
    Jc&save || G&timer:0.1,&{ 4s&toy->({to=>[J.t]}) };
    }
    
    _s&mix = 1 for @$M;
    my $tw;
    @$M = grep { !$tw.>_.t ++ } @$M;
    
    Rw DeStyleM;
    
t/CreateOrigin: | # storable J path of CyC+'s origin (-origin's s&location)
    # came from so elvistivity can fade out
    #   and find where to awake on push
    my @os = Rw fe/yCtrail $group=Ao+;
    
    if (@os < 2) {
        n argh=>3=>"Not enough history to find A.2.t's origin",'fs:7,dis,hs:566';
        Rw Origist;
        return;
    }
    @os > 2 && die "Lots of history";
    # first o'ing
    my $os = $os[0];
    # last o
    my $c = $os->[-1];
    my $Y = c.y.A;
    my $J = Y.1;
    J.3 ne A.3 && die "Origin not in J.t  "
        . G&give,Budge=>["gal"=>''=>{s=>$C}];
    
    my @J = Rw fe/upJs $J;
    A.3 eq shift(@J) || die  "Origin not in J.t";
    
    a&origin_hJ = \@J;
    
    join";",map{_.t} @J;
    
t/FindOrigin: | # later moment, look for our -origin's location, usu in 3
    my $j = A.3;
    js&top || die "3: j.t not ready!";
    
    my $p = [split ';', s&location ];
    push @$p, A.2.t; # < what our thing is called over there?
    my @J = Rw te/Jpin $M $J:j $p $Clast=1;
    my $c = pop @J;
    
    a&origin_hJ = \@J;
    $c
    
fe/upJpath: | # upJs as path, like CreateOrigin returns
    my @J = Rw fe/upJs $J;
    A.3 eq shift(@J) || die  "Origin not in J.t";
    my $s = join";",map{_.t} @J;
    wantarray ? ($s,@J) : $s
fe/upJs: | # Js above, not-1, 2+ and 3
    my @J = $J;
    my $i = 0;
    push @J, $J while $J = $i++ < 20 && $J ne J.3 && J.2;
    $i >= 20 && die "Many upJs";
    reverse @J
te/Jpin: | # point through Js beyond $J by t, and maybe the last C
    my @p = ref ar.p ? @{ar.p} : split ';', ar.p;
    my $j = $J;
    my $i = 1;
    my @J; # Js beyond $J
    my $c; # the last C
    my @fi; # debug
    for (@p) {
        js&top || js&Jtv || die "Lost @p    at $_ No top: ".G&aC,$j;
        my $f; # C with s&J
        my $J; # next J
        if (js&top) {
            $f = js&top.y.tw.>$_;
        }
        if ($f && !fs&J && $i < @p) {
            # more to go, look in Jtv, the f was probably thawed?
            undef $f;
        }
        if (!$f && js&Jtv) {
            my $jv = js&Jtv.>$_;
            if (keys %$jv != 1) {
                m "Lost @p at $_, maybe Jv:"=>-od=>{s=>[$j,$jv]}
                return
            }
            ($J) = values %$jv;
        }
        if (!$f && $J) {
            $f = Jc&s; # holds latest mo C
        }
        if ($f && !$J) {
            $J = fs&J;
            if (!$J) {
                if (@p > $i) {
                    m "Lost @p at $_"=>-od=>{s=>[@fi,js&top,$j]}
                    return
                }
                elsif (!ar.Clast) {
                    die "last thing in @p was only C: ".ki $f;
                }
                else {
                    # last hop can be C, no J
                }
            }
        }
        $c = $f;
        if ($J) {
            push @fi, "Found ".G&sn,$J ." on ".G&aC,$f;
            push @J, $J;
        }
        elsif (@p > $i) {
            die "Lost @p at $_ with no J on ".G&aC,$f ."   try Cytw not CsJstopytw?"
        }
        $j = $J;
        $i++;
    }
    ar.Clast ? (@J,$c) : @J;
fe/yCtrail: | # C.y.C trail
    my @l = my $S = $C;
    push @l, $S while $S = @l < 30 && S.y.C;
    @l >= 30 && die "many CyC";
    
    if (ar.group eq 'Ao+') {
        # find consecutive yA=o
        my @os; 
        my $l;
        for (reverse @l) {
            my $Y = _.y.A || next;
            if (Y.t eq 'o') {
                push @os, [] if !@os || $os[-1]->[-1] ne $l;
                push @{$os[-1]}, $_;
            }
            $l = $_;
        }
        return @os
    }
    
    return @l
    

fe/JC_hC: |
    # JC_hC:
    my @JCs = grep { _s&J && _.y.cv != 0.9 } e&_hC;
    
    return @JCs unless ar.s;
    
    # scheming like "-? -origin$"
    # < slide anywhere in the hC it likes,
    #   look in Js for housed lingo
    my $s = ar.s;
    
    my $fail = 0;
    my $prob = &sC{
        G&give:Budge=>[$s=>''=>{s=>[on=>$C,amongst=>e&hC ] }];
        $fail++;
        return
    };
        my $rev = $s =~ s/\$$//;
        my @s = split ' ', $s;
        @s = reverse @s if $rev;
        my @l = @JCs;
        my @r;
        my $name = "Jup";
        my $i;
        for my $s (@s) {
            my $C = $rev ? pop @l : shift @l;
            $C || die "out of bits for $_";
            if ($s =~ /^-(\S+)$/) {
                if ($1 eq '?') {
                    s&pi || $prob->("Jup$i should be pi",$C)
                }
                else {
                    s&pi eq $1 || $prob->("Jup$i should be pi=$1",$C)
                }
            }
            elsif ($s =~ /^([ycs])\&(\S+)$/) {
                my $nk = $1 eq 's' ? 'sc' : $1;
                $C.>$nk.>$2 || $prob->("wanted $nk\&$2: ",$C)
            }
            else {
                die "faes $s";
            }
            push @r, $C;
            $i || $i++;
            $i++;
            return if $fail;
        }
        
        @r = reverse @r if $rev;
        return @r;
fe/fi: | # see expectantly along nkgk path, check objects are
    my $s = $C;
    for my $m (@{ar.m}) {
        my ($nk,$gk) = $m =~ /^([ycs])(\w+)$/;
        $nk = 'sc' if $nk eq 's';
        my $S = $s.>$nk.>$gk;
        my $die = &r{
            die "$r at $nk $gk from: ".ki($s)."\n to: ".ki $S;
        };
        # < G&i,$s,J? # make an i-dent
        $m eq 'sJ' ?
            S.1 eq $S || $die->("notaJ")
        :
        $m eq 'stop' ?
            S.y ne $S && (S.c||S.sc||C.t) || $die->("notaC")
        :
        $m eq 'sz' ?
            ref $S eq 'ARRAY' # or any not C?
            || $die->("notaz")
        :
        $m eq 'yup' ?
            ref $S eq 'HASH' && S.y ne $S
            || $die->("notyup/C")
        :
        $m eq 'cs' ?
            ref $S eq 'HASH' && S.y ne $S
            || $die->("notcs/C")
        : die "make up sanity check for $m";
        $s = $S;
    }
    $s
fe/innards: | # gives you the s&Jtopz, or its reduction
    my $z = Rw fe/fi $C sJ stop sz;
    if (ar.pi) {
        $z = [grep{_s&pi eq ar.pi} @$z];
        @$z || die "No ar.pi in ".ki$z;
        ar.n && ar.n != @$z && die "Expecting ar.n ar.pi, got ".@$z.": ".ki$z;
    }
    ar.n == 1 ? $z->[0] : $z;
    
fe/Mitch: | # replace the like-$i in $M, or insert
    my $t = Rw fe/Map $M $t=i.t $n=1?;
    if (!$t) {
        if (my $w = ar.w) {
            # find $w's prev and add it next
            w.t eq i.t || die "How is w.t where i.t is?";
            my $p = w.y.prev;
            my $t = Rw fe/Map $M $t=p.t $n=1?;
            $t || die "Still can't find where to put i.t";
            @$M = map { $_ eq $t ? ($_,$i) : $_ } @$M
        }
        else {
            push @$M, $i
        }
    }
    else {
        @$M = map { $_ eq $t ? $i : $_ } @$M
    }
fe/Map: | # select/check $M for $pi, $not, $n=1 returns the one
    my $pi = ar.pi;
    my $m = [grep{
        my $v = $pi ? _s&pi eq $pi
            : defined ar.t ? _.t eq ar.t
            : die "looking for?";
        $v = !$v if ar.not;
        $v
    } @$M];
    $pi = ($pi&&"$pi && ")."t=ar.t" if defined ar.t && !ar.pi;
    if (defined ar.n) {
        my $n = ar.n;
        if ($n =~ /^(\d+)\?$/) { # that number or nothing
            $n = ar.n = $1;
            $n = 0 if @$m == 0;
        }
        if (ar.n =~ /^(\d+)?\+$/) {
            my $n = $1 || 1;
            @$m >= ($1||1) || die "Expected >= $n $pi, but got ".@$m.": ".ki @$m;
        }
        else {
            @$m == ar.n || die "Expected ar.n $pi, but got ".@$m.": ".ki @$m;
        }
    }
    my $d;
    if (ar.out) { # those not selected
        d.out = [grep{my$v=$_; 0==grep{$_ eq $v}@$m}@$M]
    }
    if (ar.n == 1) {
        $m = $m->[0];
    }
    #1 && saybl "Whav ".(wantarray && "ARRAY")." and ".@{d.out||[]};
    wantarray ? ($m,d.out) : $m
Origist: | # origin infographics, merge with above
    my @l = my $S = $C;
    push @l, $S while $S = @l < 30 && S.y.C;
    #
    @l = map { $_, _.y.A && G&sn,_.y.A || "noyA" } @l;
    n history=>-od_4=>{dl=>1,s=>\@l}

Diff: | # i<->o c&s
    my @l = map {
        my $f = "/tmp/valiput_Dif_$$".($i eq $_ && "_i" || "_o");
        write_file($f,_c&s||"NOTHING");
        $f
    } $i,$o;
    my $diff = `diff @l`;
    `rm $_` for @l;
    G&give:Budge=>["Diff i.t"=>''=>{s=>$diff}];
    #

