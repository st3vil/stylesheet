Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    #c Jay
    me.J = &acgts{
        # do a J
        $C = typeof s == 'string' && [s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        $j = G&n,C,5;
        #1c&newosc && j.2 == A.1 and j.1.c.newosc = 1
        C = jc&s;
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        c&newosc and j.1.c.newosc = 1;
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        
        if (c&M) {
            $cv = 0.3;
            $z = j.ground.sc.z;
            each in c&M {
                n.y.cv and continue
                # suggest y.cv of 30i+
                n.y.cv = G&desca,cv,8;
                cv += 0.001;
                z && z.indexOf(n) >= 0 and continue
                # do not re-C the C, or dups that == will in M occur
                #G&n,n;
            }
        }
        
        me.osc(j,C,G,T);
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        A&o = 'ind';
        # etc
        #debugger;
        
        =pod
        n A4sc  $s:A.4.sc
        n A4on  $s:A.4.on
        n A  $s:A
        n Aup  $s:A.up
        n Aupup  $s:A.up.up
        n Aon  $s:A.on
        n AonA  $s:A.on.A
        n AonA1  $s:A.on.A.1
        n A1  $s:A.1
        =cut
        
        // tayt #!!
        #=cut
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        n tongs 5 s:lovelyyyy
        n tongs 6 s:lovelyy
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'Fourier';
        
        me&J,'edges';
    };
    me.Ja.Fourier = &acgt{
        A.3 = A.1;
    
        me&J,['Fourier','-od',{s:A.4}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # wants to leap onto new osc gear (1c&newosc)
    me.Ja.edges = &acgt{
        A.3 = A.1;
        n t  $s:C.t %fs:20,hs:594
        #A&o = 'ind';
        1c&newosc = 1;
        s&blr = 10;
        
        n things 2
        
        if (0 || !1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicine
            Skys the autumn grey of a lonely wren

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    w == 'of' and z.lof = 'yea'; z.to={eo:{}};
                    z = z[w] ||= {};
                }
            }
            1s&es = s;
        }
        $s = 1s&es;
        
        n vedge 3 s:vedge %fs:23,hs:594,dis
        $tricks = "gala <pre>vi   ous";
        n vedge 4 $s:tricks %fs:23,hs:894,dis
        n vedge 5 $s:tricks,ht:1 %fs:14,hs:694,dis
        
        me&J,['expr','-go',{s:s}];
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising}];
    };
    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    # data sift/unpack/classify/pointerise with osc
    # be yinyander
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        1c&newosc = 1;
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be =
            me&J,['lookfortheedge','-globe',{s:s}];
        # and showing output
        me&J,['lookatlooking','-od',{s:be}];
        $j = bes&J;
        $s = jc&o.lookfortheedge;
        $see = sc&R.map(s => s.t);
        #me&J,['andJco','-od',{s:sc&chR}];
        #me&J,['andJcp','-od',{s:sc&R.slice(-1)[0]}];
        
        each ic sc&chR {
            me&J,['ch:'+i,'-od',{s:c}];
        }
        each iR sc&R {
            $sc = {};
            Rc&d and sc.ml = Rc&d
            $C = Rc&s;
            me&J,['isC'+i,'-od',{s:C,newosc:1},sc];
            if (i == 0) {
                me&J,['isRs\&X'+i,'-od',{s:Rs&X,newosc:1},sc];
                
            }
            R.t != 's ' and continue
            me&J,['isR'+i,'-od',{s:R,newosc:1},sc];
            $RX = Rs&X;
            me&J,['Rc\&X'+i,'-od',{s:Rc&X,newosc:1},sc];
            me&J,['Rs\&X'+i,'-od',{s:Rs&X,newosc:1},sc];
            $X = RX.Knowing;
            $K = X.z[0];
            me&J,['isKnowingR0'+i,'-od',{s:K,newosc:1},sc];
            me&J,['isKnowingcX'+i,'-od',{s:Kc&X,newosc:1},sc];
            me&J,['isKnowingsX'+i,'-od',{s:Ks&X.Display,newosc:1},sc];
            me&J,['isA'+i,'-od',{s:C.y.A,newosc:1},sc];
        }
        
    };
    #c facilitate_daydream
    #  c&s should -> s&z til explains
    me.Ja.globe = &acgts{
        n t  $s:C.t %fs:20,hs:594
        1c&newosc = 1;
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        #A&o = 'Glaze';
        A&CdaR = 'Gaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        n looks  $s:ki(s,17) %hs:298
        return;
        1s&counting ||= 1;
        
        1s&counting++;
        1s&counting > 5 and 1s&counting = 0;
        1s&counting > 3 &&
        n counts  s:counts
        s&medo = 'cra';
    };
    me.cra = &acgtD{
        $el = c&path_yon.slice(-1)[0];
        #debugger;
        #4s&elvising = C.c;
        ~etc: $(el).text();
    };
    
    #c Eightwo
    # osc again with separate oc-cu-lus ness,
    # s is the J, recurring C.t
    me.os = &acgts{
        # figure A-C and s
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
        }
        s ||= A;
        # the J is s
        s&J and s = s&J;
        # the s has an o.$page, A&V points to previum
        # > two indexes (o/C.t + V/R.t)
        #  for the thing on its mind...
        A&V ||= sc&o && sc&o[C.t];
        # was: $Y = 1c&on && 1c&on.A || 1c&osc;
        A&o ||= c&o || 'Carz';
        !me[A&o] and throw "No os me."+A&o
        me[A&o](A,C,G,T,s);
        
        sc&o ||= {};
        sc&o[C.t] = A;
    };
    
    me.Carz = &acgts{
        # C is the first thing
        # A&s is C
        # A&V previum A
        
        # A&R lists Rs
        # A&X indexes Rs
        # R&V index climbing Rs
        # R&b previum R via R&V's down A&V&X...
        $c = &sR{
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
            me&RbitX,R;
            
            # generate furthers - notices J as yA1 different
            me&CaR,s,R;
        };
        $R = me&ing,C,c;
        A&R = Rc&N;
        
        # 5 X notices leavings
        me&RbitXgonism,R;
        
        # 6 details
        #  may generate more R
        me&CdaR;
        
        # 7 display part
        me&Cavon,R;
        # 8 unify
        me&Cupon,R;
    };
    
    # CaR, daR - climb C/data generating R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtsR{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                Rc&emit({s:D})
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtsR{
        if (typeof s == 'object') {
            each kv s {
                Rc&emit({t:k,s:v})
            }
        }
    };
    #c name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRr{
        r = Rc&emit(r);
        # is not a dive for the above R-ing
        Rs&z.slice(-1)[0] != r and throw "unlast"
        Rs&z.pop();
        rc&d = 0;
        # nor its N (set)
        rc&N = [];
        # X/V (names in history)
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        rc&V = b && bs&X || {};
        return r
    };
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    me.Reis = &acgtR{
    
    };
    
    # Rbitology. history, ...
    me.RbitX = &acgtR{
        $bit = R.t;
        # an X is bits of index and .z=[R that are here
        A&X ||= {};
        # check in to it
        Rc&X ||= A&X;
        $X = Rc&X = Rc&X[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);

        # history at te top
        Rc&V ||= A&V && A&V.c.X || {};
        $V = Rc&V[bit] || {};
        if (V) {
            # care to leave history
            V = ex({},V);
            V.z and V.z = V.z.slice();
        }
        # only goners remain
        $b = V && V.z && V.z.shift();
        b && !V.z.length and delete Rc&V[bit]
        # children inherit this past
        Rc&V = V || {};
        Rc&b = b;
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c mid C os, take to details
    me.CdaR = &acgts{
        # run the set of R into another Ring
        # for C universals
        # resolving and diving like diamonds
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        #=pod
        each iR A&R {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
        #c Relosophy of C and R
        =pod
        
        A good bassline... just display
        Re further, diving into the C
         each Re is a mode of perception,
         A progress of expanding its pool of R
          and filling itself in for working through time
          once inflated...
         compiles vast change checkers, if daR is stretched across Cs,
          if anything changes then CaR, solve whatwhere again,
          if bits of the container re-ref but actuals remain
          told/finding how innards roll through time (A&ip++)
        what they are becomes, in layers.
        and tangles, hyperlinked.
        
        eg they could go into details of y/c/sc grime,
            finding micRo the same objects held in the macRo
              drawing the cellular boundary
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
          for going into the C and its state through time, etc
          in many pools, overlapping, notice objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        R can also look at R, getting into the mind.
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        so the protocols for drawing stuff with Cs want to use schemas
         to grab their jobs from C & R happenings..
        
        Anyway, the s in progress is for the 9
            which will want to Rate its s&z
            as usual - the C join the game
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
        
        SO, s finds itselves out there...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
        AND:
          visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
          whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/debase (+ rebase)
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
            
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        # similar but for unpackedness in general,
        #   including generatedness...
        #  maps of various resolution and sprawl
        
        =cut
        
        #c CdaR etcing
        !A&CdaR and return
        A&CdaR ||= 'Pond';
        !me[A&CdaR] and throw "No os me."+A&o
        me[A&CdaR](A,C,G,T,s);
        
        # and then generate C for this R time, attach to Rs&z?
        
    };
    
    # a set of os action
    me.Gaze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        ~Glaze: A.1.t, ki(C)
        me&Pond,s;
        # R motif leads to P, leads to R...
        # spring forth
        each iR A&R {
            $b = Rc&b;
            $C = Rc&s;
            !s&unknown and continue
            typeof c&s != 'object' and throw "unknown!ob"
            
            
            # A&R, refs and refR keep all
            # < refs dupe ignore at R bounds, overlap understandings
            $r = me&Re,R,{t:'Knowing',s:c&s};
            rc&middle = &sR{
                Rc&nl = 17;
                # 2 - know self
                # R.t set by daR
                me&RbitX,R;
                # data/object awareness
                $scan = me&scan,s;
                # for low lighting
                $b = Rc&b;
                b && bs&checksame;
                # < once all to here, gonism juggles
                
                # 3 - generate interesto
                # how much to draw/fall in...
                $M = Rs&M ||= [];
                m t  $s:R.t %fs:13,hs:288
                $is = scan.is || scan.sym;
                m sym  $s:is %fs:15,mt:-0.1,ml:-0.1,zi:-1,hs:4955
                # etc, drawing/falling in as ...
                # osc G&n -od?
                if (scan.is) { # object
                    return
                    m R.t -od $s:s
                }

                # generate furthers, until known?
                me&daR,s,R;
            };
            me&ing,'',r;
            me&RbitXgonism,r;

            # and anotheR to Cavon those M Cs,
            $d = me&Re,r,{t:'Display',s:r};
            dc&middle = &sR{
                me&RbitX,R;
                
                # generate furthers, until known?
                each iD ss&M {
                    Rc&emit({t:D.t,s:D,modulat:1})
                }
                each iD ss&z {
                    Rc&emit({t:D.t,s:D})
                }
            }
            me&ing,'',d;
            me&RbitXgonism,r;
            
            # throw styles over the 
            each in dc&N {
                ns&modulat and continue
                #ns&dis = 1
                # styles are coming from the Display R:
                $c = nc&s;
                #nc&d <= 1 and 
                cs&dis = 1; cs&ml = 1;
                cs&pa = '2px';
                
                #n.t == 'my' and ns&dis = 1;
            }
            
            # 7 display part
            me&Cavon,d;
            # 8 unify
            # join Display (d etc) directly under its cause (R)
            #  leaving out Knowing (r)
            d.y.interpreted = r;
            d.y.up = R;
            me&Cupon,d;

            Rs&what = "shall we? "+rc&N.length;
            Rs&disbit = d;
        }
        
    };
    #
    
        #c Cav-on 7dress html
    # and whatever after the state of atoms is got (osc/3)
    # really it does 4 here - catching state of properties changing
    #   some sleep/wake
    # < inc versions of styles applied
    # 5 + 6 in Css, translating properties to another language
    # but could end up in multifaceted games, showing working, etc...
    me.Cavon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $C = Rc&s;
            Rs&on ||= b && bs&on;
            Rs&on ||= $("<stylehouse>")[0];
            # each A.1 does os, plants sequencer of 
            if (Rs&J) {
                $(Rs&on).css('display','block');
                $J = Rs&J;
                # 1s&on noticed
                Rs&in = Jc&on || Js&on;
                b && Rs&in != bs&in and me&chR,R,'Jin'
                continue
            }
            # more to think mode?
            if (s&J) {
                # expand/see into Js&v, write on this atom
            }
            # C.sc etc decorate
            me&Cscon,R;
        }
    };
        # apply styles to html.. expand unto copies of this thing,
    #   allowing a compressed notation to turn into styles,
    #     giving space to dream of altering the situation
    #     as the matter forks along a path of progress
    #   (we may use d to collect & export workings)
    #     and the whole osc atomism
    #   into css styles
    $verbose = 0; # causes window.styletos to list styles
    $robust = 0; # applies all css properties every time
    me.Cscon = &acgtR{
        $isnew = !Rc&b;
        # past self
        $b = Rc&b || {c:{},sc:{}};
        # om details no longer relevant:
        s&e and throw "used to eval(s&e)"
        s&nobody and throw "used to reselect d.on"
        if (s&tag || bs&tag) { # or historically
            if (bs&tag != s&tag) {
                # recreating the d.on clears applieds
                Rs&on = $("<"+(s&tag || 'stylehouse')+">")[0];
                delete bs&attr;
                delete bs&css;
            }
            s&tag and Rs&tag = s&tag
        }
        # < hammerhead stylings wanting some cache api
        #   alike, C fork down paths repeatable
        # < title should be replaced by hover -> question elvis
        $attr = ex({title:C.t+' '+(C.y.cv||'')}, s&attr||{});
        if (attr || bs&attr) {
            $notin = ex({},bs&attr||{});
            Rs&attr = {};
            each kv attr {
                # '' makes a bareword attribute, ease coding in a peel
                v == '!' and v = ''
                Rs&attr[k] = v;
                delete notin[k];
                !robust && bs&attr && bs&attr[k] == v and continue
                $(Rs&on).attr(k,v);
            }
            each kv notin {
                $(Rs&on).removeAttr(k);
            }
            !hak(Rs&attr) and delete Rs&attr
        }
        # more simpler translatoes
        $css = {};
        # ^ merge into me&styler:
        # also s&cod/NutText
        # and Stylaplicants's dropdown
        
        $st = 4s&styler ||= me&styler;
        
        st(C,css);
        
        # css stamped on on
        if (hak(css) || bs&css) {
            $notin = ex({},bs&css||{});
            each kv css {
                delete notin[k];
                bs&css && bs&css[k] == v and continue
                $(Rs&on).css(k,v);
            }
            each kv notin {
                $(Rs&on).css(k,'')
            }
            hak(css) and Rs&css = css
        }
        
        # Cs say their c&s
        if (typeof c&s == 'string') {
            if (c&ht) {
                Rs&html = c&s;
                b && Rs&html != bs&html and me&chR,R,'html'
            }
            else {
                Rs&text = c&s;
                b && Rs&text != bs&text and me&chR,R,'text'
            }
            # Cupon sets Rs&on's text/html content as a child
            # which is why to cause Rs&cha? might work without
            # supposing the element will surely be there...
        }
    }
    #c Cup-on 8html output: put each in another
    # the html elements are closer to the C this time,
    #  used to always output a C-patch
    # s gets s&on
    me.Cupon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            $up = R.y.up;
            # child needs parent to attach it
            # < TES less often, if b.on still == d.on?
            Rs&cha && up and me&chR,up,'Inner:'+R.t
            
            !Rs&on and debugger;
            # how else shall we entangle R/on/C/A?
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC"
                s.y.A.on = Rs&on;
                Rs&on.A = s.y.A;
            }
            if (s == C && s&J && s&J == A.1) {
                C != A&s and throw "notC"
                i > 0 and throw "sC>0"
                # 1s&on set to thing, big deal
                1s&on = Rs&on;
            }
            s == C && (!s.y.A || s.y.A != A) and debugger;
            !up and continue
            # ups&down here Babz A.up.sc.down
            # < make R an A, work these functions with A/C
            up.sc.down ||= [];
            up.sc.down.push(R);
        }
        
        $rev = N.slice().reverse();
        each iR rev {
            #R.t == 's ' and debugger;
            !Rs&cha and continue
            # what is
            $had = Rs&on.childNodes;
            # what will be
            $have = [];
            # text/html
            Rs&html and have.push('<cs>'+Rs&html+'</cs>');
            Rs&text and have.push($('<cs>').text(Rs&text)[0]);
            # children
            each ir Rs&down {
                have.push(rs&on);
            }
            if (Rs&J) {
                $J = Rs&J;
                # yon 1s&on put into Rs&on
                $on = Jc&on || Js&on;
                !on and throw "noJon";
                have.push(on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor + focus)
            #       could be made up somehow
            # hadnt - what we didn't know was there
            # havent - what goes
            # leaving it open to elements being rearranged by the user?
            # rearrange, carefully. or just:
            each i,on have {
                $ha = had[i];
                on == ha and continue
                typeof on == 'string' && ha && on == ha.outerHTML and continue
                # different...
            }
            $(Rs&on).empty();
            each i,on have {
                $(Rs&on).append(on);
            }
        }
        $move = N.filter(R => Rs&cha);
        #$(Rs&on).append('<p>~ '+
        #move.length and ~moveing: ki(A&chR)
        #move.map(R => Rc&s.t).join(', ')
        #~move: A.1.t, ki(move), '/', A&R.length
        
        if (A.2 == A.4) {
            !A.4.on and throw "No A4on"
            if (!A.4.on.contains(A.on)) {
                ~>2 Fours: A.1.t
                $(A.on).appendTo(A.4.on);
                # if it was already, take it as an unplug?
                # or find new parent, get adopted
            }
        }
    };
    
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    # R.c inherits, R.y.up up/out and Rs&z down/in
    $Re = &Rs{
        $up = R;
        R = ex({},R);
        R.y = {};
        R.c = ex({},R.c);
        delete Rc&s;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        up and R.y.up = up;
        each kv s {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # dedupe/limit objects
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] = R;
        }
        else {
            $od = Rc&refR[ri];
            # < od[] for different layers
            #   should find one in this pool?
            Rs&anotheR = od;
            return limit('dup')
            # < to know circular links, converge
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        Rc&emit = &sr{
            r = Re((r||R),s);
            Rs&z ||= [];
            Rs&z.push(r);
            return r
        };
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rodulat
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0];
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };

    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    # overlap understandings
    me.Pond = &acgts{
        # etc and more
        S Somewheres $r
        ~somewheres for: ki(r)
        S Laterer
        ~ok
    };

