Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    #c Jay
    me.J = &acgts{
        # do a J
        $C = typeof s == 'string' && [s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        $j = G&n,C,5;
        C = jc&s;
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        
        if (c&M) {
            $cv = 0.3;
            $z = j.ground.sc.z;
            each in c&M {
                n.y.cv and continue
                # suggest y.cv of 30i+
                n.y.cv = G&desca,cv,8;
                cv += 0.001;
                z && z.indexOf(n) >= 0 and continue
                # do not re-C the C, or dups that == will in M occur
                #G&n,n;
            }
        }
        
        me.osc(j,C,G,T);
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        A&o = 'ind';
        
        =pod
        n A4sc  $s:A.4.sc
        n A4on  $s:A.4.on
        n A  $s:A
        n Aup  $s:A.up
        n Aupup  $s:A.up.up
        n Aon  $s:A.on
        n AonA  $s:A.on.A
        n AonA1  $s:A.on.A.1
        n A1  $s:A.1
        =cut
        
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        n tongs 5 s:lovelyyyy
        n tongs 6 s:lovelyy
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'liter';
        
        me&J,'edges';
    };
    me.Ja.liter = &acgt{
        A.3 = A.1;
    
        me&J,['delicio','-od',{s:A.4}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    me.Ja.edges = &acgt{
        A.3 = A.1;
        1c&newosc = 1;
        
        n things 2
        $st = <<''.split("\n");
        Long way going to
        Get my medicine
        Skys the autumn grey of a lonely wren
        Piano from a window played
        Gone tomorrow, gone yesterday
        I found it in the street
        At first I did not see
        Lying at my feet
        A trampled rose
        
        $s = {};
        each il st {
            l = l.split(" ");
            $z = s;
            each iw l {
                z = z[w] ||= {};
            }
        }
        
        
        me&J,['expr','-go',{s:s}];
        
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising}];
    };
    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    # data sift/unpack/classify/pointerise with osc
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be =
            me&J,['lookfortheedge','-gobe',{s:s}];
        # and showing output
        me&J,['lookatlooking','-od',{s:be}];
        
        each in bes&knowabout {
            $sc = {};
            n && n.c && nc&d and sc.ml = nc&d
            me&J,['k'+i,'-od',{s:n},sc];
        }
        
    };
    me.Ja.gobe = &acgts{
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        A&o = 'Gaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        s&medo = 'cra';
    };
    me.cra = &acgtD{
        $el = c&path_yon.slice(-1)[0];
        #debugger;
        #4s&elvising = C.c;
        ~etc: $(el).text();
    };
    
    #c Eighto
    # to draw your own conclusion
    # the hierarchy of ground reactions takes hold
    
    # the total applier of what is meaningful
    # the machine up to this point is lost vectoria notation
    # here we shall draw into an over-unity, as in
    #   GROWTHS
    
    # dispatch C has experience
    # it could be complete, as a work of art,
    # or it could be ingredients for several concealations
    # and then a work of art
    
    # s might be an elvis/A going wide
    # all the osc together escape linear code
    me.osc = &acgts{
        # if C is the A's, we are Jaying
        if (1c&newosc || A&s != C || C.y.A != A) {
            #and throw "exosc";
            return me&os,s;
        }
        # ^ take the A of C over this A?
        # 
        
        # OSC 1-2, see what is there
        A&o ||= c&o || 'Carb';
        A&ou ||= c&ou || 'OscUp';
        
        A&dive ||= 'C';
        
        $Y = 1c&on && 1c&on.A || 1c&osc;
        A&X = {};
        A&ds = [];
        $du = &s,d{
            A&ds.push(d);
            
            $n = s.y.A;
            # yon J has it from here
            if (n && n.1 != A.1) {
                d.nofurther = 1;
                $J = n.1;
                !Jc&on and throw "Yon J not ready: "+J.t
                d.J = J;
            }
            
            $bit = d.path.slice(-1)[0];
            
            d.X ||= A&X;
            $X = d.X = d.X[bit] ||= {};
            X.z ||= [];
            if (X.z.length) {
                # dups allowed, assumes same ordering
                if (X.z[0] == s) {
                    ~duup: ki(s,3), ki(X.z[0],3)
                }
            }
            X.z.push(d);
            
            # history at te top
            d.V ||= Y && Yc&X || {};
            $V = d.V && d.V[bit] || {};
            if (V) {
                # care to leave history
                V = ex({},V);
                V.z and V.z = V.z.slice();
            }
            # only goners remain
            $b = V && V.z && V.z.shift();
            b && !V.z.length and delete d.V[bit]
            # children inherit the parent, can strange
            d.V = V || {};
            d.b = b;
            
            #return ki(s)
        };
        $l = G&ind,C,du,{cbfirst:1};
        # atoms in locations, another lives
        each id A&ds {
            $b = d.b;
            $s = d.s;
            b && b.s == d.s and throw "Crefsame"
            
            $V = d.V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    d.gone ||= [];
                    d.gone.push(p);
                }
            }
            d.cha = d.gone || !b;
        }
        
        # knowing atomic-level motion here,
        # and unfolding qua in another:
        # OSC 3, drawing out of what is
        #   to run rhythms over the atoms,
        #   thinking of their subatomic meanings
        # resuming whenever the list of atoms adjusts

        # < go wide and reuse elements moving around
        #   persisting moving atoms,
        #     based pictures of subatomics
        #     a b in the d.V index leaving?
        #   TES
        $oscer = A&o || 'Carb';
        if (oscer) {
            # something knowing qualities
            !me[oscer] and throw "No me."+oscer
            me[oscer](A,C,G,T);
        }
        $oscup = A&ou;
        if (oscup) {
            # hoisting output
            !me[oscup] and throw "No me."+oscup
            me[oscup](A,C,G,T);
        }
    };
    #c Eightwo
    # osc again with separate oc-cu-lus ness, 
    me.os = &acgts{
        # figure A-C and s
        if (A&s != C) {
            throw "figure";
            C.y.A and A = C.y.A; # continue working on the A:n
            else
            !s and s = C; # hist on the C itself
        }
        s ||= A;
        # the J is s
        s&J and s = s&J;
        # the s has an o.$page, A&V points to previum
        $V = A&V ||= sc&o && sc&o[C.t];
        # was: $Y = 1c&on && 1c&on.A || 1c&osc;
        
        A&o ||= c&o || 'Carz';
        !me[A&o] and throw "No os me."+A&o
        me[A&o](A,C,G,T,s);
        
        
        sc&o[C.t] = A;
    };
    
    me.RbitX = &s,R,bit{
        
    };
    
    me.Carz = &acgts{
        # C is the first thing
        # A&s is C
        # A&V previum A
        
        # A&R lists Rs
        # A&X indexes Rs
        # R&V index climbing Rs
        # R&b previum R via R&V's down A&V&X...
        
        # an X is bits of index and .z=[R that are here
        A&X = {};
        A&R = [];
        
        $c = &sRe{
            A&R.push(R);
            
            # yon J, parts Aing,
            # < joins os?
            $n = s.y.A;
            if (n && n.1 != A.1) {
                d.nofurther = 1;
                $J = n.1;
                !Jc&on and throw "Yon J not ready: "+J.t
                d.J = J;
            }
            
            # find indexo
            $bit = s.t+' '+s.y.cv;
            
            # check in to it
            Rc&X ||= A&X;
            $X = Rc&X = Rc&X[bit] ||= {};
            X.z ||= [];
            if (X.z.length) {
                # dups allowed, assumes same ordering
                if (X.z[0] == s) {
                    ~duup: ki(s,3), ki(X.z[0],3)
                }
            }
            X.z.push(d);
            
            # history at te top
            Rc&V ||= A&V && A&V.c.X || {};
            $V = Rc&V[bit] || {};
            if (V) {
                # care to leave history
                V = ex({},V);
                V.z and V.z = V.z.slice();
            }
            # only goners remain
            $b = V && V.z && V.z.shift();
            b && !V.z.length and delete Rc&V[bit]
            # children inherit this past
            Rc&V = V || {};
            Rc&b = b;
            
            
        };
        $R = me&ing,C,c;
        
        
        # atoms in locations, another lives
        each id A&ds {
            $b = d.b;
            $s = d.s;
            b && b.s == d.s and throw "Crefsame"
            
            $V = d.V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    d.gone ||= [];
                    d.gone.push(p);
                }
            }
            d.cha = d.gone || !b;
        }
        
    };
    
    #c diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # 
    # R.c inherits, .up and s&z down
    $Re = &Rs{
        $up = R;
        R = ex({},R);
        R.y = {};
        R.c = ex({},R.c);
        delete Rc&s;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        up and R.y.up = up;
        each kv s {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = s;
        }
        return R;
    };
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s},sc:{}};
        cb and Rc&middle = cb;
        
        # dedupe/limit objects
        $s = Rc&s;
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] = R;
        }
        else {
            $od = Rc&refR[ri];
            # < to know circular links
            return;
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return
        Rc&nl && Rc&nl < Rc&refs.length and return
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        $emit = &sr{
            r = Re((r||R),s);
            Rs&z ||= [];
            Rs&z.push(r);
            return r
        };
        Rc&middle(Rc&s,R,emit);
        R.c.not and return
        
        # accepted into the list of atoms
        A&R ||= [];
        A&R.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    
    
    # ox/y gen
    me.Cring = &acgts{
    
    };
    me.dataring = &acgts{
        
    };
    me.SurfReal = &acgtD{
        # o origin C.c.s, because it's s&unknown
        $s = D.s;
        $rs = [];
        !(sc&s && typeof sc&s == 'object') and throw "noobject"
        $d = gin(sc&s,&s,d,df{
            rs.push(d);
            if (typeof s == 'object') {
                each kv s {
                    $D = df(d);
                    D.path.push(k);
                    D.k = k;
                    D.s = v;
                    d.z.push(D);
                }
            }
            return d.k+": "+d.path.join("-")
            #ki(s,2)
        });
    };
    
    # S for an osc pin
    me.Srupto = &A,C,G,T,s,t,talk,params{
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        ~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    #c 7gaze
    # really think about those properties, and whatever we might dive into
    # esp. the property of having no clear boundary to experience
    # try and get a nice full screen of stuff whatever is happening
    me.Gaze = &acgt{
        # we have travelled some C, but its content is unknown
        # play out schemes on its language
        # take suggestions, resume suggestioned
        #   rules about whatwhen, this may fluctuate
        
        # suggest trying to know the unknown,
        # generate like ind but for sheer datastructure,
        $k = s&knowabout = {};
        $le = [];
        each id A&ds {
            $b = d.b;
            $s = d.s;
            # resolve which atoms are pointing to/from which others...
            # last applied stratagem of suchness diffed with current one
            # steps taken to satisfy certains, leave uncertain interactive
            $is = 'not';
            if (ss&unknown) {
                d.digin = 'SurfReals';
                is = 'the unknown';
                !me[d.digin] and throw "No me."+d.digin
                $ret = me[d.digin](A,C,G,T,d);
                le.push(ret);
            }
            else {
                #k['not '+i] = s
            }
            k[is+' '+i] = s
        }
        S fe
        
        S lace
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        A&ou = 'GazNon';
        1c&on = le;
        1c&osc = A;
        return;
        $d = {};
        # similar but for unpackedness in general,
        #   including generatedness...
        #  maps of various resolution and sprawl
        }
    };

    me.GazNon = &acgt{
    };
    
    # A looker, taking C + d for a Gazed osc item
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    $gin = &syd{
        d ||= {};
        !d.refs and d.refs = []; d.refid = [];
        !y and throw "nocb"
        # dedupe objects
        $ri = d.refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = d.refs.push(s) - 1;
            d.refid ||= {};
            d.refid[ri] = d;
        }
        else {
            $od = d.refid[ri];
            # < to know circular links
            return;
        }
        d.dl && d.dl < d.d and return
        d.nl && d.nl < d.refs.length and return
        !d.d and d = df(d)
        # make a callback
        $l = y(s,d,df); #)
        # which gives us options to try
        $out = [l];
        each in d.z {
            d.not || n.not and continue
            $l = gin(n.s,y,n);
            out.push(l);
        }
        d.d == 1 and d.out = out.join("\n"); return d
        return out.filter(&s{ return 1 && s }).map(&s{
                return s.split("\n").map(&s{ return "  "+s }).join("\n")
            }).join("\n");
    };
    # inherit d
    $df = &d{
        $up = d.d && d;
        d = ex({},d);
        # < path as a function climbing d.up
        d.path = (d.path||[]).slice();
        d.z = [];
        up and d.up = up;
        d.d ||= 0;
        d.d++;
        return d
    };
    
    #c SurfReals
    me.SurfReals = &acgtD{
        # o origin C.c.s, because it's s&unknown
        $s = D.s;
        $rs = [];
        !(sc&s && typeof sc&s == 'object') and throw "noobject"
        $d = gin(sc&s,&s,d,df{
            rs.push(d);
            if (typeof s == 'object') {
                each kv s {
                    $D = df(d);
                    D.path.push(k);
                    D.k = k;
                    D.s = v;
                    d.z.push(D);
                }
            }
            return d.k+": "+d.path.join("-")
            #ki(s,2)
        });
        
        # ou to R, the display particles
        $rev = rs.slice().reverse();
        each id rev {
            $R = {y:{},c:{},sc:{}};
            R.t = d.k || "nothing!";
            R.y.d = d;
            Rc&s = "o "+d.k;
            d.d and Rs&ml = 1;
            Rs&dis = 1;
            d.Rz and Rs&z = d.Rz;
            $p = d.up;
            if (p) {
                p.Rz ||= [];
                p.Rz.push(R);
            }
            else {
                d.everything = R;
            }
        }
        
        # put d.everything through oscering...
        $r = d.everything;
        $j = me&J,['GazeR','-n',{},{z:[r]}];
        $on = j.y.A.on;
        
        # put that on into our 1c&on
        
        # becomes 1c&on, 
        return on;
        return d.out;
    };
    me.Ja.n = &acgt{
        n t 1 $s:C.t %hs:348,dis:block
        $z = A.ground.sc.z;
        z.unshift(z.pop());
        #
    };
    {

