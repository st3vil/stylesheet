Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    #c edges
    me.Ja.edges = &acgt{
        A.3 = A.1;
        3c&oscer = 'Carb';
        
        n things 2
        $st = <<''.split("\n");
        Long way going to
        Get my medicine
        Skys the autumn grey of a lonely wren
        Piano from a window played
        Gone tomorrow, gone yesterday
        I found it in the street
        At first I did not see
        Lying at my feet
        A trampled rose
        
        $s = {};
        each il st {
            l = l.split(" ");
            $z = s;
            each iw l {
                z = z[w] ||= {};
            }
        }
        
        
        me&J,['expr','-go',{s:s}];
        
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising}];
    };
    # data sift/unpack/classify/pointerise with osc
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be =
            me&J,['lookfortheedge','-gobe',{s:s}];
        # and showing output
        me&J,['lookatlooking','-od',{s:be}];
        
        each in bes&knowabout {
            $sc = {};
            n && n.c && nc&d and sc.ml = nc&d
            me&J,['k'+i,'-od',{s:n},sc];
        }
        
    };
    me.Ja.gobe = &acgts{
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        1c&oscer = 'Gaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        s&medo = 'cra';
    };
    me.cra = &acgtD{
        $el = c&path.slice(-1)[0];
        ~etc: el.outerHTML
    };
    
    #c 7gaze
    # really think about those properties, and whatever we might dive into
    # esp. the property of having no clear boundary to experience
    # try and get a nice full screen of stuff whatever is happening
    me.GazNon = &acgt{
    };
    
    # A looker, taking C + d for a Gazed osc item
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    $gin = &syd{
        d ||= {};
        !d.refs and d.refs = []; d.refid = [];
        !y and throw "nocb"
        # dedupe objects
        $ri = d.refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = d.refs.push(s) - 1;
            d.refid ||= {};
            d.refid[ri] = d;
        }
        else {
            $od = d.refid[ri];
            # < to know circular links
            return;
        }
        d.dl && d.dl < d.d and return
        d.nl && d.nl < d.refs.length and return
        !d.d and d = df(d)
        # make a callback
        $l = y(s,d,df); #)
        # which gives us options to try
        $out = [l];
        each in d.z {
            d.not || n.not and continue
            $l = gin(n.s,y,n);
            out.push(l);
        }
        d.d == 1 and d.out = out.join("\n"); return d
        return out.filter(&s{ return 1 && s }).map(&s{
                return s.split("\n").map(&s{ return "  "+s }).join("\n")
            }).join("\n");
    };
    # inherit d
    $df = &d{
        $up = d.d && d;
        d = ex({},d);
        # < path as a function climbing d.up
        d.path = (d.path||[]).slice();
        d.z = [];
        up and d.up = up;
        d.d ||= 0;
        d.d++;
        return d
    };
    me.SurfReals = &acgtD{
        # origin C, s&unknown
        $s = D.s;
        $rs = [];
        !(sc&s && typeof sc&s == 'object') and throw "noobject"
        $d = gin(sc&s,&s,d,df{
            rs.push(d);
            if (typeof s == 'object') {
                each kv s {
                    $D = df(d);
                    D.path.push(k);
                    D.k = k;
                    D.s = v;
                    d.z.push(D);
                }
            }
            
            return d.k+": "+d.path.join("-")
            #ki(s,2)
        });
        
        # run over rs, making R, the display particles
        
        
        # becomes 1c&on, 
        return d.out;
    };
    me.Gaze = &acgt{
        # we have an unknown coming in
        # play out schemes on its language
        # take suggestions, resume suggestioned
        #   rules about whatwhen, this may fluctuate
        
        # suggest trying to know the unknown,
        # generate like ind but for sheer datastructure,
        $k = s&knowabout = {};
        $le = [];
        each id A&ds {
            $b = d.b;
            $s = d.s;
            # resolve which atoms are pointing to/from which others...
            # last applied stratagem of suchness diffed with current one
            # steps taken to satisfy certains, leave uncertain interactive
            $is = 'not';
            if (ss&unknown) {
                d.digin = 'SurfReals';
                is = 'the unknown'
                !me[d.digin] and throw "No me."+d.digin
                $ret = me[d.digin](A,C,G,T,d);
                le.push(ret);
            }
            else {
                #k['not '+i] = s
            }
            k[is+' '+i] = s
            
            
        }
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        1c&oscup = 'GazNon';
        1c&on = le;
        1c&osc = A;
        return;
        $d = {};
        # similar but for unpackedness in general,
        #   including generatedness...
        #  maps of various resolution and sprawl
    };

