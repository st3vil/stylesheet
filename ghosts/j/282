Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    #c Jay
    me.J = &acgts{
        # do a J
        $C = typeof s == 'string' && [s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        $j = G&n,C,5;
        C = jc&s;
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        
        if (c&M) {
            $cv = 0.3;
            $z = j.ground.sc.z;
            each in c&M {
                n.y.cv and continue
                # suggest y.cv of 30i+
                n.y.cv = G&desca,cv,8;
                cv += 0.001;
                z && z.indexOf(n) >= 0 and continue
                # do not re-C the C, or dups that == will in M occur
                #G&n,n;
            }
        }
        
        me.osc(j,C,G,T);
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        A&o = 'ind';
        #1c&newosc = 1;
        # etc
        
        =pod
        n A4sc  $s:A.4.sc
        n A4on  $s:A.4.on
        n A  $s:A
        n Aup  $s:A.up
        n Aupup  $s:A.up.up
        n Aon  $s:A.on
        n AonA  $s:A.on.A
        n AonA1  $s:A.on.A.1
        n A1  $s:A.1
        =cut
        
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        n tongs 5 s:lovelyyyy
        n tongs 6 s:lovelyy
        
        1c&timeto ||= 0;
        if (1 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'liter';
        
        me&J,'edges';
    };
    me.Ja.liter = &acgt{
        A.3 = A.1;
    
        me&J,['delicio','-od',{s:A.4}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    me.Ja.edges = &acgt{
        A.3 = A.1;
        1c&newosc = 1;
        
        n things 2
        $st = <<''.split("\n");
        Long way going to
        Get my medicine
        Skys the autumn grey of a lonely wren
        Piano from a window played
        Gone tomorrow, gone yesterday
        I found it in the street
        At first I did not see
        Lying at my feet
        A trampled rose
        
        $s = {};
        each il st {
            l = l.split(" ");
            $z = s;
            each iw l {
                z = z[w] ||= {};
            }
        }
        
        
        me&J,['expr','-go',{s:s}];
        
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising}];
    };
    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    # data sift/unpack/classify/pointerise with osc
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be =
            me&J,['lookfortheedge','-gobe',{s:s}];
        # and showing output
        me&J,['lookatlooking','-od',{s:be}];
        
        each in bes&knowabout {
            $sc = {};
            n && n.c && nc&d and sc.ml = nc&d
            me&J,['k'+i,'-od',{s:n},sc];
        }
        
    };
    me.Ja.gobe = &acgts{
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        A&o = 'Gaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        s&medo = 'cra';
    };
    me.cra = &acgtD{
        $el = c&path_yon.slice(-1)[0];
        #debugger;
        #4s&elvising = C.c;
        ~etc: $(el).text();
    };
    
    #c Eightwo
    # osc again with separate oc-cu-lus ness, 
    me.os = &acgts{
        # figure A-C and s
        if (A&s != C) {
            throw "figure";
            C.y.A and A = C.y.A; # continue working on the A:n
            else
            !s and s = C; # hist on the C itself
        }
        s ||= A;
        # the J is s
        s&J and s = s&J;
        # the s has an o.$page, A&V points to previum
        A&V ||= sc&o && sc&o[C.t];
        # was: $Y = 1c&on && 1c&on.A || 1c&osc;
        
        A&o ||= c&o || 'Carz';
        !me[A&o] and throw "No os me."+A&o
        me[A&o](A,C,G,T,s);
        
        
        sc&o[C.t] = A;
    };
    
    me.Carz = &acgts{
        # C is the first thing
        # A&s is C
        # A&V previum A
        
        # A&R lists Rs
        # A&X indexes Rs
        # R&V index climbing Rs
        # R&b previum R via R&V's down A&V&X...
        A&R = [];
        $c = &sR{
            A&R = Rc&refR;
            
            # tv index, previum find indexo, Rc&b
            R.t = s.t+' '+(s.y ? s.y.cv : '');
            me&RbitX,s,R;
            
            # generate furthers - notices J as yA1 different
            me&CaR,s,R;
        };
        $R = me&ing,C,c;
        
        # X notices leavings
        me&RbitXgonism;
        # details
        me&CdaR;
        # display part
        me&Cavon;
        # unify
        me&Cupon,s;
    };
    
    # mid C os, take to details
    me.CdaR = &acgts{
        # run the set of R into another Ring
        # for C universals
        # resolving and diving like diamonds
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        
            # < me.scan
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };

            $x = b && bc&s || {};
            $cha = diff(C.c,x.c||{})
                || diff(C.sc,x.sc||{},{ignore:'z'});
            cha and Rs&cha = 1

    };
        #c 7dress html d.on
    # and whatever after the state of atoms is got (osc/3)
    # really it does 4 here - catching state of properties changing
    # 5 + 6 in Css, translating properties to another language
    # but could end up in multifaceted games, showing working, etc...
    me.Cavon = &acgt{
        each iR A&R {
            $b = Rc&b;
            $C = Rc&s;
            Rs&on ||= b && bs&on;
            Rs&on ||= $("<stylehouse>")[0];
            # each A.1 does os, implanted
            if (Rs&J) {
                $(Rs&on).css('display','block');
                $J = Rs&J;
                # no in/on and chase J?
                Rs&in = Jc&on;
                b && Rs&in != bs&in and Rs&cha = 1
                continue
            }
            # more to think mode?
            if (s&J) {
                # expand/see into Js&v, write on this atom
            }
            # C.sc etc decorate
            me&Cscon,R;
        }
    };
        # apply styles to html.. expand unto copies of this thing,
    #   allowing a compressed notation to turn into styles,
    #     giving space to dream of altering the situation
    #     as the matter forks along a path of progress
    #   (we may use d to collect & export workings)
    #     and the whole osc atomism
    #   into css styles
    $verbose = 0; # causes window.styletos to list styles
    $robust = 0; # applies all css properties every time
    me.Cscon = &acgtR{
        $isnew = !Rc&b;
        # past self
        $b = Rc&b || {};
        # om details no longer relevant:
        s&e and throw "used to eval(s&e)"
        s&nobody and throw "used to reselect d.on"
        if (s&tag || bs&tag) { # or historically
            if (bs&tag != s&tag) {
                # recreating the d.on clears applieds
                Rs&on = $("<"+(s&tag || 'stylehouse')+">")[0];
                delete bs&attr;
                delete bs&css;
            }
            s&tag and Rs&tag = s&tag
        }
        # < hammerhead stylings wanting some cache api
        #   alike, C fork down paths repeatable
        # < title should be replaced by hover -> question elvis
        $attr = ex({title:C.t+' '+C.y.cv}, s&attr||{});
        if (attr || bs&attr) {
            $notin = ex({},bs&attr||{});
            Rs&attr = {};
            each kv attr {
                # '' makes a bareword attribute, ease coding in a peel
                v == '!' and v = ''
                Rs&attr[k] = v;
                delete notin[k];
                !robust && bs&attr && bs&attr[k] == v and continue
                $(Rs&on).attr(k,v);
            }
            each kv notin {
                $(Rs&on).removeAttr(k);
            }
            !hak(Rs&attr) and delete Rs&attr
        }
        # more simpler translatoes
        $css = {};
        # ^ merge into me&styler:
        # also s&cod/NutText
        # and Stylaplicants's dropdown
        
        $st = 4s&styler ||= me&styler;
        
        st(C,css);
        
        # css stamped on on
        if (hak(css) || bs&css) {
            $notin = ex({},bs&css||{});
            each kv css {
                delete notin[k];
                bs&css && bs&css[k] == v and continue
                $(Rs&on).css(k,v);
            }
            each kv notin {
                $(Rs&on).css(k,'')
            }
            hak(css) and Rs&css = css
        }
        
        # Cs say their c&s
        if (typeof c&s == 'string') {
            Rs&picture = c&s;
            b && Rs&picture != bs&picture and Rs&cha = 1
            # ^ element's text gets set with children. later:
            c&ht and Rs&html = c&s;
            else
            Rs&text = c&s;
        }
    }
    #c 8html output: put each in another
    # the html elements are closer to the C this time,
    #  used to always output a C-patch
    # s gets c&on
    me.Cupon = &acgts{
        each iR A&R {
            $b = Rc&b;
            $s = Rc&s;
            $up = R.y.up;
            # child needs parent to attach it
            # < TES less often, if b.on still == d.on?
            Rs&cha && up and ups&cha = 1
            
            !Rs&on and  debugger;
            # how else shall we entangle R/on/C/A?
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC"
                s.y.A.on = Rs&on;
                Rs&on.A = s.y.A;
            }
            if (s == C && s&J && s&J == A.1) {
                C != A&s and throw "notC"
                i > 0 and throw "sC>0"
                1s&on = Rs&on;
            }
            s == C && (!s.y.A || s.y.A != A) and debugger;
            !up and continue
            ups&down ||= [];
            ups&down.push(d);
        }
        
        $rev = A&R.slice().reverse();
        each id rev {
            !Rs&cha and continue
            # what is
            $had = Rs&on.childNodes;
            # what will be
            $have = [];
            # text/html
            Rs&picture &&
                have.push('<cs>'+Rs&picture+'</cs>');
            # children
            each ip Rs&down {
                have.push(Rs&on);
            }
            if (Rs&J) {
                $J = Rs&J;
                !Js&on and throw "noJon";
                have.push(Js&on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor + focus)
            #       could be made up somehow
            # hadnt - what we didn't know was there
            # havent - what goes
            # leaving it open to elements being rearranged by the user?
            # rearrange, carefully. or just:
            each i,on have {
                $ha = had[i];
                on == ha and continue
                typeof on == 'string' && ha && on == ha.outerHTML and continue
                # different...
            }
            $(Rs&on).empty();
            each i,on have {
                $(Rs&on).append(on);
            }
        }
        
        if (A.2 == A.4) {
            !A.4.on and throw "No A4on"
            if (!A.4.on.contains(A.on)) {
                ~>2 Fours: A.1.t
                $(A.on).appendTo(A.4.on);
                # if it was already, take it as an unplug?
                # or find new parent, get adopted
            }
        }
    };
    
    #c ox/y gen Rs&z
    # s = C
    me.CaR = &acgtsR{
        # yon J, parts Aing,
        # < joins os?
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            !Jc&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                Rc&emit({s:D})
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtsR{
        if (typeof s == 'object') {
            each kv s {
                Rc&emit({t:k,s:v})
            }
        }
    };
    
    #c Rbit history/index Rs
    me.RbitX = &acgtsR{
        $bit = R.t;
        # an X is bits of index and .z=[R that are here
        A&X ||= {};
        # check in to it
        Rc&X ||= A&X;
        $X = Rc&X = Rc&X[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);

        # history at te top
        Rc&V ||= A&V && A&V.c.X || {};
        $V = Rc&V[bit] || {};
        if (V) {
            # care to leave history
            V = ex({},V);
            V.z and V.z = V.z.slice();
        }
        # only goners remain
        $b = V && V.z && V.z.shift();
        b && !V.z.length and delete Rc&V[bit]
        # children inherit this past
        Rc&V = V || {};
        Rc&b = b;
    };
    me.RbitXgonism = &acgt{
        # atoms in locations, another lives
        each id A&R {
            $b = Rc&b;
            $s = Rc&s;
            b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone || !b and Rs&cha = 1
        }
    };
    
    #c diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # 
    # R.c inherits, .up and s&z down
    $Re = &Rs{
        $up = R;
        R = ex({},R);
        R.y = {};
        R.c = ex({},R.c);
        delete Rc&s;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        up and R.y.up = up;
        each kv s {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = s;
        }
        return R;
    };
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s},sc:{}};
        cb and Rc&middle = cb;
        
        # dedupe/limit objects
        $s = Rc&s;
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] = R;
        }
        else {
            $od = Rc&refR[ri];
            # < to know circular links
            return;
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return
        Rc&nl && Rc&nl < Rc&refs.length and return
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        Rc&emit = &sr{
            r = Re((r||R),s);
            Rs&z ||= [];
            Rs&z.push(r);
            return r
        };
        Rc&middle(Rc&s,R);
        R.c.not and return
        
        # accepted into the list of atoms
        A&R ||= [];
        A&R.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    
    # S for an osc pin
    me.Srupto = &A,C,G,T,s,t,talk,params{
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        ~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    #c 7gaze
    # really think about those properties, and whatever we might dive into
    # esp. the property of having no clear boundary to experience
    # try and get a nice full screen of stuff whatever is happening
    me.Gaze = &acgt{
        # we have travelled some C, but its content is unknown
        # play out schemes on its language
        # take suggestions, resume suggestioned
        #   rules about whatwhen, this may fluctuate
        
        # suggest trying to know the unknown,
        # generate like ind but for sheer datastructure,
        $k = s&knowabout = {};
        $le = [];
        each id A&ds {
            $b = d.b;
            $s = d.s;
            # resolve which atoms are pointing to/from which others...
            # last applied stratagem of suchness diffed with current one
            # steps taken to satisfy certains, leave uncertain interactive
            $is = 'not';
            if (ss&unknown) {
                d.digin = 'SurfReals';
                is = 'the unknown';
                !me[d.digin] and throw "No me."+d.digin
                $ret = me[d.digin](A,C,G,T,d);
                le.push(ret);
            }
            else {
                #k['not '+i] = s
            }
            k[is+' '+i] = s
        }
        S fe
        
        S lace
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        A&ou = 'GazNon';
        1c&on = le;
        1c&osc = A;
        return;
        $d = {};
        # similar but for unpackedness in general,
        #   including generatedness...
        #  maps of various resolution and sprawl
        }
    };

    me.GazNon = &acgt{
    };
    
    # A looker, taking C + d for a Gazed osc item
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    $gin = &syd{
        d ||= {};
        !d.refs and d.refs = []; d.refid = [];
        !y and throw "nocb"
        # dedupe objects
        $ri = d.refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = d.refs.push(s) - 1;
            d.refid ||= {};
            d.refid[ri] = d;
        }
        else {
            $od = d.refid[ri];
            # < to know circular links
            return;
        }
        d.dl && d.dl < d.d and return
        d.nl && d.nl < d.refs.length and return
        !d.d and d = df(d)
        # make a callback
        $l = y(s,d,df); #)
        # which gives us options to try
        $out = [l];
        each in d.z {
            d.not || n.not and continue
            $l = gin(n.s,y,n);
            out.push(l);
        }
        d.d == 1 and d.out = out.join("\n"); return d
        return out.filter(&s{ return 1 && s }).map(&s{
                return s.split("\n").map(&s{ return "  "+s }).join("\n")
            }).join("\n");
    };
    # inherit d
    $df = &d{
        $up = d.d && d;
        d = ex({},d);
        # < path as a function climbing d.up
        d.path = (d.path||[]).slice();
        d.z = [];
        up and d.up = up;
        d.d ||= 0;
        d.d++;
        return d
    };
    
    #c SurfReals
    me.SurfReals = &acgtD{
        # o origin C.c.s, because it's s&unknown
        $s = D.s;
        $rs = [];
        !(sc&s && typeof sc&s == 'object') and throw "noobject"
        $d = gin(sc&s,&s,d,df{
            rs.push(d);
            if (typeof s == 'object') {
                each kv s {
                    $D = df(d);
                    D.path.push(k);
                    D.k = k;
                    D.s = v;
                    d.z.push(D);
                }
            }
            return d.k+": "+d.path.join("-")
            #ki(s,2)
        });
        
        # ou to R, the display particles
        $rev = rs.slice().reverse();
        each id rev {
            $R = {y:{},c:{},sc:{}};
            R.t = d.k || "nothing!";
            R.y.d = d;
            Rc&s = "o "+d.k;
            d.d and Rs&ml = 1;
            Rs&dis = 1;
            d.Rz and Rs&z = d.Rz;
            $p = d.up;
            if (p) {
                p.Rz ||= [];
                p.Rz.push(R);
            }
            else {
                d.everything = R;
            }
        }
        
        # put d.everything through oscering...
        $r = d.everything;
        $j = me&J,['GazeR','-n',{},{z:[r]}];
        $on = j.y.A.on;
        
        # put that on into our 1c&on
        
        # becomes 1c&on, 
        return on;
        return d.out;
    };
    me.Ja.n = &acgt{
        n t 1 $s:C.t %hs:348,dis:block
        $z = A.ground.sc.z;
        z.unshift(z.pop());
        #
    };
    {

