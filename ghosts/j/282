Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;


        # Relosophy of C and R
        =pod
    
    R similar to A, but want to fall faster
     could perhaps be throated together... maybe
      thRoat wants to return data iterations to step iterations in a pin
    bassline C get I->R+ from A&o pin/gear assortment of action
      juggling dives in, points and progress
        of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
    needs a playspout
         compiles fast change checkers (0-2) once inflated (8)
          so lowlevel changes (container re-ref) cause higher modes
          told/finding how innards roll through time (A&ip++)
    laying schemes on what objects are
          producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked.
    
    drawing macro cellular boundary
      based a bit on A.1 != Y.1 along the A
       then Rc&d and Ry&up, hy&up
    already micro cells (C) are bound,
      points lead through the pointy ones
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
        =head1 Srupto
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
          for going into the C and its state through time, etc
          in many pools, overlapping, notice objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        # similar but for unpackedness in general,
        
        # phases of aiming the display and adjusting things
        # latter -go wants to be pointed to not coded
        
        =cut
        
        
    #c Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    me.handelvis = &acgt{
        # go up C path until bingoed
        $lop = c&slope.slice().reverse();
        # - s&medo - instant, outside (A=4) (eg Jause)
        each in lop {
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            G&yl:400,&{ msg.set('what',ki(ret)) };
            return
        }
        # - s&med: 
        #   e -> 4c&elvising -> J:Fourier -> me.Elvising
        #   having gone inside (4c&callback)


        4s&elvising = C;
        ~Insideon: ki(c&slope,2)
        G&yl,0,4c&callback;
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel
    
    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if (e.t.includes('click') && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
    #c slope/pointer
    
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 75;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.cra = &acgtD{
        #$el = c&path_yon.slice(-1)[0];
        $M = s&solvey = [];
        $upwards = c&slope.slice().reverse();
        $c = {};
        each in upwards {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                c.1 != Y.1 and vs&J = Y.1
                c.1 = Y.1;
                # find W
                Y.1 == Y.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                Rs&elvis && !c.elvis and c.elvis = vs&elvis = Rs&elvis
            }
        }
        !c.elvis and ~sloping
        !c.elvis and return
        $p = [];
        each in M {
            ns&elvis and p.push(n); continue
            !p.length and continue
            p.unshift(n);
            ns&W and break
        }
        s&solvey = p;
        
        # < to c&pointer, to locate us in
        $M = c&pointer = [];
        # < a pile of travel, io T points to look at
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in p {
            $v =
            m $n.t  {}
            ny&cv != null and vy&cv = ny&cv
            # < io spacerised is just t
            i $el/#$n
            el = ays&n[0];
            if (ns&elvis) {
                T.qua = {};
                $R = ns&R;
                # make the adjustment
                me[ns&elvis](A,C,G,T,R);
                # save the state
                each kv T.qua {
                    el.sc[k] = v;
                }
                s&elvis = Rs&elvis;
            }
        }
        
        # < overplace set value
        # < boostulate requires A1..3 carry T wires
        #   for the rest R carry T wires
        #   so set value can be reintroduced
        # < check every T point was found
        #4s&elvising = C.c;
        #~etc: $(el).text();
    };
    
    #c Mboostia
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tin rc&ha {
            if (rc&N.indexOf(n) >= 0) {
                # R included
                $M = me&Mw,n,'Mlimits';
                m $t 89 s:* %deco,fs:7,lh:0.3
                t == 'dub' and continue
                # say where it originated
                $o = ns&refR[0];
                $namo = me&namup,o;
                $name = me&namup,n;
                $pup = [];
                each is namo {
                    if (!pup.length) {
                        s == name[i] and continue
                        if (name[i] != null) {
                            # up the n
                            pup.push(name.slice(i).map(la=>'^').join(''))
                        }
                    }
                    pup.push(s)
                }
                if (!pup.length) {
                    $ups = name.length - namo.length;
                    while (ups--) { pup.push('^') }
                    pup = [pup.join('')];
                }
                $nam = pup.join('/');
                m $t 892 $s:nam %deco,fs:7,hs:999
                continue;
            }
            else {
                # knows upward that is
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
        }}
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $zs = t+' < '+N.map(t=>t.t).join(',');
            $te = '*'+t;
            m $te 117 $s:zs %deco,fs:13
        }}
    };
    #c Js drive wiring from above
    me.JT = &acgts{
        delete 1s&Te;
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $v = p&tv $t;
        !v and return
        1s&Te = v;
    };
    # Rs inhale wiring from .y.up+s&Te
    # thenceforth getting
    # can resume pointering across Rs that don't
    # < checks all pointers were found
    me.Tie = &acgtRk{
        #R.t == 'Knowing' and debugger;
        if (!Rs&Te) {
            # attach travelvis once..
            Rs&Te = {};
            #$r = R == Rc&N[0] ? me&RupinC,R : R.y.up;
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            $Tet = v&tv $t;
            Tet and Rs&Te = Tet
        }
        $v = Rs&Te;
        !v || !v.c and return
        !k and return
        # once located, muddle with opportunity
        
        #vs&cb && vs&cb,R,t
        hak(v.sc,k) and R.sc[k] = v.sc[k]
        
    };
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        # ^ is somewherish. posits and deposits.
        1s&Te and me&Tie,R,'boost'
        
        if(0) {
        # returns from history
        $b = Rc&b;
        !(b && bs&boost) and return
        Rs&boost = bs&boost;
        }
        
        !Rs&boost and return
        4s&elvised.push(Rs&boost+' '+ki(me&namup,R ));
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : 'W';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,hue:$hu
            z.t += hu;
            i++;
        }
    };
    me.namup = &acgts{ 
        $nam = [s.t];
        while (s = s.y.up) {
            nam.push(s.t);
        }
        return nam.reverse();
    };
    me.Gazel = &acgtR{
        Rs&boost ||= 0;
        #debugger;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
    };
    #c Ring R-ing
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
    };
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    

    
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        
        $N = me[R.t](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    # Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        #debugger;
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        #c walk the tape, trying to do more
        $busy = 1;
        $sheer = 500;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # get its step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            
            hy&ov && hy&ov < ty&cv and debugger;
            
            # doing it:
            $T = {};
            if (ts&if) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='if'
                elsif (ts&if[0] == 's') {
                    !R.sc[ts&if.substr(1)] and T.not='if'
                }
                else {
                    throw "if "+ts&if
                }
            }
            
            if (!T.not) {
                # doming? T hook any G&n via A.ground...?

                $cb = tc&s;
                !hak(R.c,'s') and debugger;

                cb(A,C,G,T,R,Rc&s);

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c autoravel
    
    me.ravel = &acgtR{ return [
        ['She','1',&acgtRs{
            Rc&d == 0 and R.t = C.t;
            Rc&inC = R; # tells inner Displays to hoist to here
            Rc&nl ||= 175;
            Rc&dl ||= 15;
        }],
        ['She','3',&acgtRs{
            
                $C = Rs&C = G&Cye,[R.t,'',{}];
                me&boostulate,R;
                $Re = &tsg{
                    return me&Ret,R,{t:t,s:s,g:g||'sunknown'};
                };


                $M = me&Mw,R,'traw';
                m tere 1 $s:R.t %fs:13,hs:288
                
                
                $M = me&Mw,R,'maybe';
                m climbon 8 $s:A %anet
            
            
        }],
        ['anet','4',&acgtRs{
            $M = me&Mw,R,'traw';
            m tere 1 s:toland %fs:17,hs:288
            me&sunknown,R,s;
        },'if:sanet'],
        
        ['She','6',&acgtRs{
            $maybe = Rs&Mw && Rs&Mw.maybe;
            if (maybe) {
                delete Rs&Mw.maybe;
                if (!Rs&z) {
                    each in maybe {
                        $c = ex(ex({},n.c),n.sc);
                        c.t = n.t;
                        me&Ret,R,c;
                    }
                }
            }
        },'if:h'],
        ['Display','7',&acgtRs{
            $d = me&Display,R;
        },'if:h'],
    ] };
    #c Ringing unknown
    me.Cray = &acgtRs{ return [
        ['She','1',&acgtRs{
            Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 175;
            Rc&dl ||= 15;
        }],
        ['She','3',&acgtRs{
            $h = Rc&N[0];
            $p = Ry&up;
            Rs&inC = R;
            $C = Rs&C = G&Cye,[R.t,'',{}];

            # this R can be clicked big/small
            me&boostulate,R;
            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                $M = me&Mw,R,'traw';
                # make block,inline have same indento
                $iN = (ps&z||[]).indexOf(R) - 1;
                $f = iN >= 0 && ps&z[iN];
                f && fs&rowish and s&ml = 1
                s&fs = 7;
                m sym 12 not
                $pow = 2;
                Rs&boost and pow = 4;
                $string = ki(s,pow);
                string.length > 100 and string = string.substr(0,100)+'..'+(string.length - 100)
                m ki 3 $s:string
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });

            if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        }],
        ['She','7',&acgtRs{
            $d = me&Display,R;
        },'if:h'],
    ] };
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        # dedupe/limit objects already in this pool
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            each in RN {
                if (nc&N == Rc&N) {
                    limit('dup');
                    Rc&nofurther = 1;
                }
            }
            limit('dub');
            # < to know circular links, converge
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X, inwards
    #     X.z = [ R nodes
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    me.RbitX = &acgtR{
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # starting into Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        R.y.I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    # grow current R
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    # name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task = r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                h && hs&joinR and rc&N = hc&N
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    

