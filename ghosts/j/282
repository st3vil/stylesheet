Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;


        # Relosophy of C and R
        =pod
        
        A good bassline...
         R:I -> R:C the 9*, apply styles on the C
        and diving into the C:
          A&o Re further, each a mode of perception,
         A progress of expanding its pool of R
          and filling itself in for working through time
          once inflated...
    needs a playspout
         compiles vast change checkers, if daR is stretched across Cs,
          if anything changes then CaR, solve whatwhere again,
          if bits of the container re-ref but actuals remain
          told/finding how innards roll through time (A&ip++)
          laying schemes on what objects are
          producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked.
        
        eg they could go into details of y/c/sc grime,
            finding micRo the same objects held in the macRo
              drawing the cellular boundary
        
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
        =head1 Srupto
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
          for going into the C and its state through time, etc
          in many pools, overlapping, notice objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/debase (+ rebase)
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        # similar but for unpackedness in general,
        
        # phases of aiming the display and adjusting things
        # latter -go wants to be pointed to not coded
        
        =cut
        
        





        #c Cav-on 7dress html
    # and whatever after the state of atoms is got (osc/3)
    # really it does 4 here - catching state of properties changing
    #   some sleep/wake
    # < inc versions of styles applied
    # 5 + 6 in Css, translating properties to another language
    # but could end up in multifaceted games, showing working, etc...
    me.Cavon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $C = Rc&s;
            Rs&on ||= b && bs&on;
            Rs&on ||= $("<stylehouse>")[0];
            
            # each A.1 does os, plants sequencer of 
            if (Rs&J) {
                $(Rs&on).css('display','block');
                $J = Rs&J;
                # 1s&on noticed
                Rs&in = Jc&on || Js&on;
                b && Rs&in != bs&in and me&chR,R,'Jin'
                continue
            }
            # more to think mode?
            if (s&J) {
                # expand/see into Js&v, write on this atom
            }
            # C.sc etc decorate
            me&Cscon,R;
        }
    };
        # apply styles to html.. expand unto copies of this thing,
    #   allowing a compressed notation to turn into styles,
    #     giving space to dream of altering the situation
    #     as the matter forks along a path of progress
    #   (we may use d to collect & export workings)
    #     and the whole osc atomism
    #   into css styles
    $verbose = 0; # causes window.styletos to list styles
    $robust = 0; # applies all css properties every time
    me.Cscon = &acgtR{
        $isnew = !Rc&b;
        # past self
        $b = Rc&b || {c:{},sc:{}};
        # om details no longer relevant:
        s&e and throw "used to eval(s&e)"
        s&nobody and throw "used to reselect d.on"
        if (s&tag || bs&tag) { # or historically
            if (bs&tag != s&tag) {
                # recreating the d.on clears applieds
                Rs&on = $("<"+(s&tag || 'stylehouse')+">")[0];
                delete bs&attr;
                delete bs&css;
            }
            s&tag and Rs&tag = s&tag
        }
        # < hammerhead stylings wanting some cache api
        #   alike, C fork down paths repeatable
        # < title should be replaced by hover -> question elvis
        $attr = ex({title:C.t+' '+(C.y.cv||'')}, s&attr||{});
        if (attr || bs&attr) {
            $notin = ex({},bs&attr||{});
            Rs&attr = {};
            each kv attr {
                # '' makes a bareword attribute, ease coding in a peel
                v == '!' and v = ''
                Rs&attr[k] = v;
                delete notin[k];
                !robust && bs&attr && bs&attr[k] == v and continue
                $(Rs&on).attr(k,v);
            }
            each kv notin {
                $(Rs&on).removeAttr(k);
            }
            !hak(Rs&attr) and delete Rs&attr
        }
        # more simpler translatoes
        $css = {};
        # ^ merge into me&styler:
        # also s&cod/NutText
        # and Stylaplicants's dropdown
        
        $st = 4s&styler ||= me&styler;
        
        st(C,css);
        
        
        # css stamped on on
        if (hak(css) || bs&css) {
            $notin = ex({},bs&css||{});
            each kv css {
                delete notin[k];
                bs&css && bs&css[k] == v and continue
                $(Rs&on).css(k,v);
            }
            each kv notin {
                $(Rs&on).css(k,'')
            }
            hak(css) and Rs&css = css
        }
        
        # Cs say their c&s
        if (typeof c&s == 'string') {
            if (c&ht) {
                Rs&html = c&s;
                b && Rs&html != bs&html and me&chR,R,'html'
            }
            else {
                Rs&text = c&s;
                b && Rs&text != bs&text and me&chR,R,'text'
            }
            # Cupon sets Rs&on's text/html content as a child
            # which is why to cause Rs&cha? might work without
            # supposing the element will surely be there...
        }
    }
    #c Cup-on 8html output: put each in another
    # the html elements are closer to the C this time,
    #  used to always output a C-patch
    # s gets s&on
    me.Cupon = &acgtR{
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            $up = R.y.up;
            # child needs parent to attach it
            # < TES less often, if b.on still == d.on?
            Rs&cha && up and me&chR,up,'Inner:'+R.t
            
            !Rs&on and debugger;
            # how else shall we entangle R/on/C/A?
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC"
                s.y.A.on = Rs&on;
                Rs&on.A = s.y.A;
            }
            if (s == C && s&J && s&J == A.1) {
                C != A&s and throw "notC"
                i > 0 and throw "sC>0"
                # 1s&on set to thing, big deal
                1s&on = Rs&on;
            }
            s == C && (!s.y.A || s.y.A != A) and debugger;
            !up and continue
            # ups&down here Babz A.up.sc.down
            # < make R an A, work these functions with A/C
            up.sc.down ||= [];
            up.sc.down.push(R);
        }
        
        $rev = N.slice().reverse();
        each iR rev {
            #R.t == 's ' and debugger;
            !Rs&cha and continue
            # what is
            $had = Rs&on.childNodes;
            # what will be
            $have = [];
            # text/html
            Rs&html and have.push('<cs>'+Rs&html+'</cs>');
            Rs&text and have.push($('<cs>').text(Rs&text)[0]);
            # children
            each ir Rs&down {
                have.push(rs&on);
            }
            if (Rs&J) {
                $J = Rs&J;
                # yon 1s&on put into Rs&on
                $on = Jc&on || Js&on;
                !on and throw "noJon";
                have.push(on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor + focus)
            #       could be made up somehow
            # hadnt - what we didn't know was there
            # havent - what goes
            # leaving it open to elements being rearranged by the user?
            # rearrange, carefully. or just:
            each i,on have {
                $ha = had[i];
                on == ha and continue
                typeof on == 'string' && ha && on == ha.outerHTML and continue
                # different...
            }
            $(Rs&on).empty();
            each i,on have {
                $(Rs&on).append(on);
            }
            Rs&on.C = Rc&s;
            Rc&s.y.A and Rs&on.A = Rc&s.y.A;
        }
        #$move = N.filter(R => Rs&cha);
        #$(Rs&on).append('<p>~ '+
        #move.length and ~moveing: ki(A&chR)
        #move.map(R => Rc&s.t).join(', ')
        #~move: A.1.t, ki(move), '/', A&R.length
        
        $h = N[0];
        $on = hs&on;
        if (A.2 == A.4) {
            !A.4.on and throw "No A4on"
            if (!A.4.on.contains(on)) {
                ~>2 Fours: A.1.t
                $(on).appendTo(A.4.on);
                # if it was already, take it as an unplug?
                # or find new parent, get adopted
            }
        }
    };
    
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # dedupe/limit objects
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] = R;
        }
        else {
            $od = Rc&refR[ri];
            # < od[] for different layers
            #   should find one in this pool?
            Rs&anotheR = od;
            return limit('dup')
            # < to know circular links, converge
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    me.RbitX = &acgtR{
        $bit = R.t;
        # an X is bits of index and .z=[R that are here
        A&X ||= {};
        # check in to it
        Rc&X ||= A&X;
        $X = Rc&X = Rc&X[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);

        # history at te top
        Rc&V ||= A&V && A&V.c.X || {};
        $V = Rc&V[bit] || {};
        if (V) {
            # care to leave history
            V = ex({},V);
            V.z and V.z = V.z.slice();
        }
        # only goners remain
        $b = V && V.z && V.z.shift();
        b && !V.z.length and delete Rc&V[bit]
        # children inherit this past
        Rc&V = V || {};
        Rc&b = b;
        # no further
        b && bc&b and bc&b;
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0];
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # starting into Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        R.y.I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    # grow current R
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    # name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $h = Ic&head[r.t] ||= [];
                h.push(r);
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N = [];
        # X/V (names in history)
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        rc&V = b && bs&X || {};
        return r
    };
    
    
    #c Ring R-ing
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        # grasp task, eg Pond
        rs&task = r.t;
        me&Ring,r;
    };
    
    # insert C to z after cv ==, before cv >
    $sortin = &zC{
        $i = 0;
        while (1) {
            $s = z[i];
            !s and return z.push(C)
            C.y.cv < s.y.cv and return z.splice(i,0,C)
            i > 100 and debugger;
            i++;
        }
    };
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&Rs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&Rs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        
        me[R.t](A,C,G,T,R).map(n => sortin(z,G&Cye,n ));
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    # Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        #debugger;
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        $busy = 1;
        $sheer = 500;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                busy = 0;
                continue
            }
            #c walk the tape, trying to do more
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # get its step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            
            hy&ov && hy&ov < ty&cv and debugger;
            
            # what the step is called
            if (Ic&head[t.t]) {
                # spawn to R:C
            }
            
            if (ts&if) {
                ts&if == 'RcX' and !Rc&X and continue
                else {
                    throw "if "+ts&if
                }
            }
            
            # doming? T hook any G&n via A.ground...?
            
            $cb = tc&s;
            !hak(R.c,'s') and debugger;
            
            cb(A,C,G,T,R,Rc&s);
            
            # coupling to Pond
            #  initialise, come back to here inside
            #  iter R and whatever else it wants
            #  advance once all R are up to that level
            cz(R,zi);
            Rs&ci ++;
            
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    # overlap understandings
    me.Pond = &acgtM{
        return [
        ['She','1',&acgtRs{
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }],
        ['','3',&acgtRs{
            # generate furthers - notices J as yA1 different
            me&CaR,R,s;
        }],
        ['','6',&acgtRs{
            ~six: R.t
        }],
        ];
    };

