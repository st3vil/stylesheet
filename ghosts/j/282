Coffle: | # discussion
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    io.doz = 1;
    io.usu_dup = &{};
    G&waylay,'NutGravy';

    =head1 #prepare to A=A
    
    some goals:
    - efficiently educating on A passage of time
    - J to take < 200ms
    - not noticing anyway
    - Elvising running the shower
    - unpatch, failing, patch, passing in a few seconds
    
    =head3 future of sleep: Doming
    A starts works, D are their completion
    
       C   E
     A   D 
       C   C
    
    A C9[C...] completes D and elvises a clone
    
    D - the Aing grouping items sprout inside
      z C & A to include C/group A workload
      provide osc-like cha/continuity without osc,
        yet be the atomicness osc uses to commit,
        and load with decor/nativities to make for mediation
          R:I is now being the osc workload gatherer + commit
            which should work on >=1 'pages' of osc at a time
              eg elvising from ...
              or the whole/9er
            rolling the others,
            being able to async progress,
              do work in parallel or not...
    make unities early to sleep/calculate desires better
      eg. when A is @28, the state can be considered D:early
      eg. when Jpin, S makes domes, which can then be known about
    internal buzz. pages of its ground.
      get composited into D:top, C9[C...] post-osc
      which gets hoisted/elvised into J/W timespace elsewhere,
        the macro-J Doming-looking action: hosting stuff.
    so to:
      make arbitrary groups
        for groups sake:
          naming stuff
          handling streams
        to stabilise/refine our sense of activity
      transport C out of time,
        so J>7 can help J<7 (sleep)
        osc-think may play with things outside of osc,
         < holds that state in a dome it hopes to pull in?
      locate them as possible actions,
        as bumping into a S-ection kinda defines it
          < more at compile time
        and elvis handlers... 1s&ein.sayeth = &acgts{
      know inputs in a tracable way
        Elvising pointing in here,
          as Teing is
        giving Desire pathways to trace processes
    
    Domes may iterate X/V or some structure from another Dome,
      it may be important to iterate locally and do remotely,
        they become transactions
    Desire might want to do something,
    as a new elvis pointing into here would
     Teing is a kind of elvising
       and is the float:right upside down triangle of stuff
         the small network-edge pile coming down into
         the big contenty pile of isness
     Schemas too, float their potential/unfoldment
       down holes they start matching
    
    #c sleep/done =head2 sleep
    
    %slep/I:Slepingness & me&slan:
      Tool injects things (Te tangulate) with a %slep
        a way to map their changes fast and sleep
          change of container vs. the values within etc
          Teing (if versioned by Elvising %slep) also
     < could be faster/lessR: callback a huge ==-ish plucker,
       50ms 3%slep could get down to 4ms?
     < unicode everywhere. plants: 💮 🌸 🌷 🌹  🌺 🌻 🌼 🥀  🎕 ⚘ 🏵 🏶  🌱 🌽 🌾  ⸙ 🌰 🌿 🍀 🍁 🍂 🍃  🌵 🌴  🎋 🎄 🌲 🌳
     < Cye takes y=o89 -> ycv=0.089
     < put sdiff and dup etc in 11-ish (dup 1189)
     < C/sc/css compressions, in Line or not
     
    Tool openness
      configures those injectoids
      < more timely %differ growing out of it
      real interesting later
      < the nearest %Tool serves the purpose
        < %aTool in tests...
    
    < Elvisory re-slaning on %push to it?
       is the elvis delivery mechanism:
        give edifice of deliverableness
         resolve to best case or so:
       if it were a different J:
        enter it, changes input to thisJ
        decide to redome thisJ to involve that,
          or seeing our change come back to us
       Matu-ish out-of-time with %push gravitate reruns
      redo R building on changed elvisory?
      see 'rebuild %push to use e'
       %push currently injects the remote %ball%movingin
         which will not work if its asleep
         but it could be brought around about as fast if:
    < Te the %moves to Elvisory/anywhere
       with a watch for completion and callback/expiry
    < universal vision of rc&ha.dup,
    < replace ravel with Doming and Display2
    < TEST io.i z much
    
    # anyway
    
    back to Pass...
    
    # monday:
      random niceups
      all %testruns at once
        # nah, many %play at once instead
        # should be priority on the next Pass
        awaking only the relevant stuff each time
        %push gives T(..Co..) five clicks to find J,
          then it is woken up
    # tuesday:
      testing slep
        doesnt need a %Tool inside?
    # thursday:
      finish %Cit below, make lots of tests.
      slepology
      very good...
      < cursor for all/the last PuTe/edges/City,
        < faster/clearer uptake of Te change
        < storing patches instead of big slight changes
      < Lines that are lv diffs that can apply to Lines 
      differ looks to have gone weird.
      definitely want easy reaccepting changes already seen
      seeI 1.2: is one of the Is Mlimits diags wrong?
      a slep inside a slep has some history issue, keeps spawning
    # saturday:
      '< if cby .t are the same'
    # friday:
      new A4,
        < starts from a single /js/ with
          one screenful of prior knowledge
        A calmly pulls in its deps, sets foot...
    # friday:
      new I compiled fore-way,
        composited and storaged in Pass
        is a layer of tools on a type of wormhole,
         which we also need to grasp moving around
        the bunch of names, Lis
    
    o general Passness
      %ball+%whatwewant:
        %www copies to children
          thing type believers should roll around
            wash truth-presentation deception in 4d
        resistance (to s&J/s&H, or s&testrun)
          should be presented and overcome by Tes&boost,
           before it becomes Rs&boost
      %push:
        vanishing %exactly should half open
        call itself on move start/end Doing/Done, etc
      %Cit:
       %Citop starts a gel of, R.t!='Cit' makes title
        for s, anyone looking at anything stuff
         < more A/R/other understandings
         < making a refpool across the %testrun
           could be confusing to want dups from different R
           a W:City thing?
        shall configure in W:Das
          < while Pass is paused, vv.
        there they become/add City%doing for:
          a %Cit, with:
            c&s selected by c&points (usu previous %doings Wout)
            elvising re. crawling into W.y.R.c.X/V etc
          < %main-centric elvisory overtaking,
            so tested W can be Te~d separately,
              but so we can engage them
                properer $main=A.4?
        City converts Display to C and attaches/Lines it
          so %ball can stop/conjoin at y&lv
       
      %Cit across time &space:
       expect noise around the actual thing
        present change out of the essential scope of the check as such
         a %differ thing
        put notes in test data
         < compile ugly from that
      %testrun, attach to whatever we %play->%run
        implies ./%steps/%doings
          < ways to break from %doings,
            more result crunching in this/another A
            basically as W:City, does Cit + TeImplant
          
    #c goalism
    o test gonerism (XV)
    < with extra bits of %Cit asserting deeply
      'fixed' error in %push:
          between R:I and R:*, R:C wasnt using arriveRbitX etc
          was:
           state falls apart too easily after error:
            %ball%pushed has to give them %their every time
            %push%moves also,
           are hanging on me&rollbs, which depends on b
            apparently bogus
           cant be pushed back together with the other side because:
            push%move after the fall ends up Co inside Co
              not knowing about the Co/$Redo thing
              is a setup for the %testrun:
                A.5erver (Co) gives you a fresh A.4 ($Redo),
                  which you push steps to
                could be clearer than:
                 %move,from:Co,to:T,into
                 %move,from:Co,to:Co *
              TeCo could express such strategy,
                besides what is to be.
          Remember to avoid that next rebuild.
       
    o test sleepology
      with extra %ools for Pass to:
        be on Rc&Tool all y&up
          and 4s&Tool
            negotiate/nest if existant
            importo: get Rc&Tool in to every A.1/osc
              to check vitals (R0c&ha)
          accum messages so,
           lookup up A for a handler,
            linking B
        rec/play elvising:
          < at the [click=>{path...}] level
            or nearabouts, we could get started...
             the Tool %aTool
          however:
          T:nab picks T/$bit to PuTe%doing before (picks) %doing
            < braiding it in as you elvis $main/A.4
        < rolling change accepting
           from one %doing to later %doings,
            or W reoccurring, versions of versions...
           half accepting chunks
             even if the patch must be rearranged a bit
           from/for here.diff or their.diff
           as they are capturing state as it builds up,
            then playing it back destructively
        dump/stash configurations of %Cit
          as %doings for W:PuTe + W:Lookat etc
        < Tool doings at times injected to... (Ting)
          see also 'R looks at R', and the crazy names
            given to top-down instruction
        < diff of C switching places could look better
            tracing it somewhere, new + gone = move stuff
    
    o test tests (%play wanders %testrun)
    
    o test Pass itself (recurse another? later)
     o then Ring could try for more ordered order (by t cv or Rs&ci)
      o also wants T.Z back, lurk-until, do others (T.wide)
        there is a lexical ov in Ring, yadda.
        things stuck or behind prioritise
    
    # another
    o rebuild I via Babd ways
     o link G/ to W/G so we can update it ourselves
     o get a Lis rolling nicely
      o tests sign the version as it percolates
    o rebuild jsBab in js
     o fast way changes, lots of test results if you want
     o check against jsBabz for j/2/*
    
    o 'rebuild %push to use e'
      %checkout the tangley varieties of %push
    
    o unify name extrusion (see names extruding)
      like X but with where/when to D,
        alt names and fuzzentations (figure name changes)
          inc. crunchable path descriptions in various datalang
        universal gone/unnoticed system
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
    
    good study.
    perldoc -f study
    # < in general, knowing if the A is for a queue or for right now

    
    #c=head2 Maturation
    
    Gombulus hives elvising going in or coming out
    TX
    
    o a&z toplevel thinker
      and its localised sidecares
      a bunch of A not expecting J overhead
      rebuilding on the Co Joinup
        having it bring G (map of its dependencies) (see Give)
          as an %H of a different name
            once osc piles of whatever hoisting is?
              not much doc about osc hoisting:
               the W/of/t may W/what/ever/it/takes/t
               for stats/accounting
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    
    o and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and W-contiguous
            the simple funtimes embedded in the page,
            if browser compatible, Wake up and do anything
        I-ing up Sevo, then placing more A-ily,
    
    o names extruding, like X but with:
      connection to a dome:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
            done-ish by %slep
              could describe path or so
        decide once D:in !%more
          D:new == D:old to sleep, or:
          clone D:new to D:out and ...
            becomes someones D:in
              border control
        
    o Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    o elvising coming out or going in on the X
      and transacting the change of it
       as Domes, which have versions of Domes going into them
       an osc that keeps everything it sees would be first
        and be the wandering frontiers of change
     
    o making the R an A.
      compiling ravel into throat?
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further) (%slep)
     ongoing bisection of A
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    =head1 #bugs
    
      =head2 b-loss
        see about the b loss after a throw
          from not checking out Rc&X/V properly
         by elvising sensors into Elvising
 
         ^ holding up timing deunification/fast Display updates
      
      
    =head1 #voidable bugs  #c laterthisweek
    
    the editor
      keeps injecting the difference when you move a chunk marker
        remove, save, add back in to new place works
      freezes if you click+drag off the left
    
    the %kvstore %furthering into ting W/ doesnt settle
    
    io not doing a bunch more of the expression
     < do $s%ball/%ball
     < know to Rsync after messing with?
    would take care of me&ioty and me&input
    
    =head1 #I
    
    (see Give)
    for recompiling everything,
     G&t gets it from A*%believed
    that may be part of or leading to elvising,
      the hyper-everything trans-anyway maculata
        (see head1 Elvising)
     which lives in the same form:
     <Source> /Transform|Select\ <Output>
    any of that may need to live somewhere,
    for independent intelliglance:
     CodeChange
       To
         Experie
           $Doleux # the -e below, put for destination
       For
         Vang # W from here to grabber
           Doleux -e
             %here: Doleux # version of grabbed thing
             %etc: whathaveyou
    then Vang relives that %push
    and Experie knows its got stuff incoming
      which it might already have pulled in,
        (it must also disconnect)
      or is able to pull in with/without Vang being awake
    
    =head1 push
    
    is near simplifying
      G/W rebuild would realise calmable push boundaries
     and how hard the codon was entered
     and an overmind to wander around %tests
    
    =head1 Cnetobjet
    
    all %H within should gather atop
      garbage collection
        the wandery overmind
    rebuild this editor as a picture museum
    
     a juice - bioavailability of A prog C
     grab moment S, giving some kind of housing
     lexicals hang around,
     -the end- of computer science
     scene collapses into bubble
     try to get back to some kind of housing
     security is being stuck on the outside of some jeweled cavity
     
     once done a bunch of something, you can look at them.
     as gravity.
    
    #c=head1 A=A and the Give
    
    merge R into A.
    A is R, throat is Ring, sooner of things
      throat - where Instructions iterate over Culture
    # here we do the entire Ceeing instantly to the enclosing timeframe
    (taking pictures of state that is about to change)
    in general, knowing if the A is for a queue or for right now
     + the usual about how queues crud around
    patching time... all Cnetobj
     it will look like itself, except for where it ruptures/grows
    
    =head1 Srupto
    we want to allow pin Steps to be Instructions
      a way to grab anything at any rhythm
    
    the baseline C->osc mode may encode Instructions:
     Cont
       thinger 3 s:'s&er++' %of:Lat
    becomes:
     Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
    then:
     Cont transports
     Lat is I stuff (%W with %z), posited as being Lat
     thinger is encoded (Latc&W:of)
    such that it is mostly ready for action:
    A.3+ believes in Cont%W
    A.1 somewhere wants Lat
        (or thinger, knowing things like Lat might contain it)
     by elvising G/$pathtoA1/Lat,
      finding/choosing a Lat,
      which must 6 the whole of what it bit
        (W around might be only indexing of what can be got)
    do-ing
    then that elvising attaches to A.1/G/Lat/Cont
     which A.3 hoists/attaches/encodes/stores as some of:
       A.3/G/Cont # no idea wherefor but small edge
         # does updates for change at the large-object level
       A.3/G/Cont/$pathtoA1 # know where to send attention
         # andor where in the stream of Cont the change is!
       A.3/$pathtoA1/G/Lat/Cont # Q/A format per place
         # lends itself to network change sensitively
     easily all at once
     hyperspheres of definition named simply
    and store perhaps on the first line of the W in Lines:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Stuff   %produced
    and something incorporating Cont and more looks like:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
         thingo 3 s:'C.c.o++'
       thingo 3 s:'s&er++' %of:Lat
    
     when thinger blows up, inspected:
        thinging from AyeOne%W/Lat%Wz/thinger
        and as asking around about random things:
        find AyeOne%W/Cont%W (aka Cont%W) also has Lat/thinger
        things may be asleep about here,
        but may be able to show source code, compile/mutate it
    
    looking at the G would be lots of io-ing
      things packed into it
      checking those injection/projection points
      is bitXgonerism
      relying on percolating those things
        along things that we can relive
       or shut down, rearrange, tamper with
      as osc-compatible:
       various $Gish of $Wish may be attached to $Wish
         so long as osc understands what/how to involve/mixage
       even outside itself on $Woth/$pathtoWish/$Gish
        just as $Teing is an index of landstructions to go here
        we have the chance to take with us or trust to recreation anything
        
       they are understood by the I, made meaningful where $Wish is
      and hoist/dehoist its structures into other places
        with others doing the same thing
      and also just the giant tabulation
    
    #c ph (post R re-combobulation)
    osc does new A:I over the old one
      probably rolling everything
     A:C make separations of a thing or things
      lets its content be distributed and depended on
      pattern matched and made into elvisings out to W:of,
      putting into a further self
    
    so C may need separation to preserve various objectives:
     A:n C being the most-uphill thing
     A:C = C coming in
     A:s = C for doming/playing sc forward
     A:C = C going out
     A:W = C encoding/compressing
    they all have ways to know about their previous lives
    
    another life of the underlying shape:
    A - receivability
    C - received culture
    G - culture + momentum, implantations
    T - what could not fit in,
      its mysteries/problems/developments,
      its inclusion to/from the world
        to as in for Teing into some W-position,
        from as in its life was because of such insTruction
      the T is like the G
        dealing with a big tangle of comings & goings
    the T decides/dealswith the edge of the picture,
    by hoisting/making the content misfiture,
      such that a big C can have its anomalies adjusted
    
    the layer above io, provides mode ala c&el
      io needs to readwrite A&X/A&V/A&Xo
        to provide the memory of the current play
        in parallel to the previous one,
          noticing when C views should complete (gonerism)
    diversifying how to match $thing against $Thing,
      what we are looking for,
      what level of understanding to borrow what from
    yet producing that sc-lang about how it was written:
      Some%sounds = {index of direction to points of resonance}
    there could be:
      Cs making the structure of any kind of index
      direction Cs, coming from/with merge/over/with/etc
      resonating Cs, beings in a constellation unknown to themselves
    
    A:s would be driving towards a goal
     juggling dives in, points and progress
       of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
     compiles fast checkers of 0-2 wobble once inflated
      so lowlevel changes (container re-ref) cause higher modes
    needs a playspout
     told/finding how innards roll through time (A&ip++)
     pointing to things, as if regrouping into another
      laying schemes on what to do
       producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked, wandering
    
    drawing cellular boundary
      s&z = more C,
        so might its A&z = more A
      based a bit on A signage (A.so = $so)
        $so might be via Ay&up (would know if soA&ip aboves us)
        A.pileup of things involved/leading to A
          should cleanup per J or so,
          but provide being/groupology along A
      measures of depth/appropriateness
       A&d (A.c.d)
      thickness/gravitational of cultural boundary-ness
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
    #c ph Srupto Elvising 
    =head1 Srupto 
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while
            that returns to the enclosing handler
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
          throating is meeting several inputs at once:
           A:n->C+ dome-havers (leading to/with/during s for the J)
           Teing (Instruction overloading) from 'above'
           Regurgitants
        Js can be trusted to get their TGW meaning to a point,
         so they can be reset natively
          consuming all input, producing all output,
          for what is supposed to be here.
          inside J (s life) its expression is freer
           
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
         for going into the C and its state through time, etc
          onward, redo, step, pause at trouble...
         matching between many pools
          for same objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          and similarityin many pools, overlapping, notice objects had by each other
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head1 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        Geing stuff, departing pile of meaning
        # similar but for unpackedness in general,
        Teing suff, meaning of departing
        # phases of aiming the display and adjusting things
        a pi sewing machine:
        # latter -go wants to be pointed to not coded, initially
        
        =cut
        
        
    #c push - %ball's establishment of an outgoing projection
    # < working via elvising hung near
    # < better pointering & grabbing styles
    #    remember what things looked like,
    #    be generating grammars/I off the screen
    # in a %push on this %ball, rolling through time,
    # < disconnecting once the cause (me&push call) stops
    # 
    # returns the %pull (which will Ring soonish) unless:
    #  %pull%auto:
    #    %their = me&input,%there,%herec&s
    #    returns %their = %ball holding %herec&s under %there
    # 
    me.push = &acgtRpqtc{
        # the named %push + its mode (%auto if t,!c args)
        c ||= {auto:1};
        typeof c == 'string' and c = G&peel,c
        t and ex(c,typeof t == 'string' ? {t:t} : t)
        c.push ||= 1;
        !hak(c,'t') and c.t = ki(p,2)+' = '+ki(q,2)
        $l = me&Ret,R,c;
            me&zN,l;
        
        # and its items, from here
        # path to receiver %ball (inflated)
        #  < elvis pointing such that name changes/bits blow away when pushed
        $t = ls&there = me&pushpath,R,p;
        # the thing itself, where it is (also inflated)
        $h = ls&here = isC(q) ? q : me&pushpath,R,q;
        !t || !h and throw "falliball"
        
        # < pipelining of here as it goes there via ...
        #   so it can wander through a network started here
        
        # begin othering:
        if (ls&hard) {
            ac(t,'pushering',l)
        }
        elsif (ls&auto) {
            $thing = hc&s;
            ls&their = me&input,ls&there,thing;
            return ls&their
        }
        else {
            # no-push link (elviser knows who's nearly elvised them)
            ac(t,'pushish',l)
        }
        # %ball pushed to %there, practically
        # < %othering to %there,
        #   saving %balls of here/there for Cdar diff
        #   the %there%balls noticing our %push vanish
        return l
    };
    # %ball input limb, extra pathy
    # < to hang push intentions on %ball
    #   or on speculative balls for slow ...
    me.pushpath = &acgtRp{
        $r = R;
        each is p {
            $nr = s == '/' ?
                me.cby(r,&r{ return rs&gee })[0]
                :
                me&input,r,s
            !nr and throw "No "+s+" after "+r.t+" along "+ki(p)
            r = nr;
        }
        return r;
    };
    
    #c push
    me.Pushingness = &acgtR{ return [
        # %push = cv awake
        ['push','3',&acgtRs{
            me&rollbs,R,'moves,delivered';
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            #s&fs = 8;
            #Rs&arrow =
            n $R.t 13 s:⇒ %fs:24
            # certain/lowlevel types of %push
            Rs&auto || Rs&hard and return Rs&push = 9
            # log
            Rs&moves ||= []
        },'ift,D'],
        
        # %their
        # not currently pointed to and found:
        #   %there + %here = %their
        #     might mean disregard for %their state
        #     or ignorance, as elvis might clue
        #      with all the logistical infolation
        # ways the item 7s from afars:
        
        # %push%their = %balls reporting back
        ['ball+pushed','56',&acgtRs{
            # since ball 53 yfuture'd %pulled...
            $p = Ry&up;
            $above = ps&pushed || [];
            each il Rs&pushed {
                # %pushed here and not above
                above.indexOf(l) >= 0 and continue
                # < many?
                ls&their = R;
            }
        },'ift,D'],
        # %push%their = what %deliverer did (via %pushish)
        ['push+deliverer','56',&acgtRs{
            $d = Rs&deliverer;
            $ed = d && ds&delivered
            ed and Rs&their = ed
        },'ift,D'],
        # the %moves could lead somewhere
        ['push+moves','56',&acgtRs{
            each in Rs&moves {
                n.t == 'push' and Rs&lastpush = n
            }
            # last %move that was a push
            $lm = Rs&lastpush;
            if (lm) {
                # this %push when %move was started (had the %made)
                Rs&Doing = lmc&pusher;
                # this %push when %move was done
                Rs&Done = lmc&pushed;
            }
        },'ift,D'],
        
        # an error getting fixed
        # detects disconnected %their
        #  searches for likely candidate
        #   or however there/their is pointed
        ['push+losttheir','77',&acgtRs{
            delete Rs&losttheir;
            !Rs&lastpush and return
            $m = Rs&main || Rs&made || Rs&here;
            $th = Rs&there;
            !m || !th and throw "m-th"
            $t = me&ioty,th,'%ball' .filter(t => t.t == m.t) [0];
            n sun  $s:m,R %sun
            !t and return me&tsc,'notfindable','gonetheir','d'
            Rs&losttheir = t;
        },'ift,D'],
        
        # and puts it forth
        ['push+moves','56',&acgtRs{
            # for push+losttheir 77
            $b = Rc&b;
            $l = b && bs&losttheir;
            l and Rs&their = me&yfuture,l
        },'ift'],
        
        # the 59%push%does becomes %act
        ['push','59',&acgtRs{
            Rs&push >= 9 and return
            # attaching checks to its parts
            me&suggesc,Rs&here,'Lines';
            me&suggesc,Rs&their,'Lines';
            # %act from what it %does to get %made
            #  engaged now so it can tamper with <6%their
            Rs&does and Rs&act = Rs&does
        },'ift,D'],
        
        #c push-7 have encoded %balls wormhole through %moves
        #   received by this %push early enough to action
        ['push','7',&acgtRs{
            Rs&push >= 9 and return
            $t = Rs&their;
            $h = Rs&here;
            hs&Lines && !hs&string and return T.wide = 1
            
            # both sides should Lines
            me&sch_didLines,R,h;
            !t || me&sch_didLines,R,t;
            
            if (me&Mw,R,'err' .length ) {
                Rs&push = 9;
                return me&tsc,'push7_errrors','⊗','L'
            }
        },'ift,D'],
        
        ['push','73',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            $Done = Rs&Done;
            
            Done && !t and me&tsc,'va','vanishing!'
            !t and me&tsc,'notheir','⧁','L'
            
            # here <-> their if nothing organised (by 72%act)
            !Rs&diffya and me&diffya,R,'diff',h,t
            
            # their <-> their at the last push (negated by 72%act)
            $tdiff = t && Done && me&diffya,R,'theirs',t,Dones&their;
            if (tdiff) {
                # < handle changes we didn't push
                # < branch here <-> Dones&here, patch onto that
                # < a %differ tangle, wakes up to sort out a %push gone awry
                if (!tdiffs&exactly) {
                    # < explore what'll happen, run in reverse
                    #m pull $from:t,to:h %pull,pending,move
                    n pending  s:pull? %hs:588
                }
            }
            
            $dy = Rs&diffya;
            $diff = dy && dy.diff;
            if (diff) {
                # the main diff
                if (diffs&exactly) {
                    # %push%exactly if the diff named diff is exactly
                    #   used to find %push leaving equilibrium
                    Rs&exactly = 1;
                }
            }
        },'ift,D'],
        
        # %push makes %moves
        ['push','77',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            # collects %moves
            $M = Rs&moves;
            
            # the checkout on init trick
            if (Rs&checkout && !M.length && me&sch_ballonlyt,h ) {
                m checkout $from:t,to:h %pull
            }
            
            # transmit here or what we made of it
            Rs&made and h = Rs&made
            
            if (Rs&shove || Rs&boost > 1) {
                !Rs&shove and Rs&Te.sc.boost = 1;
                Rs&shove &&
                    n shovedby  $s:Rs&shove %hs:388,deco
                
                if (!t) {
                    t = Rs&there;
                    $into = '> '+t.t
                }
                ~PUSH: R.t, h.t, into||t.t
                # the usual
                $c =
                m push $from:h,to:t,pusher:R
                into and cc&into = 1
            }
        },'ift,D'],
        
        # random look
        ['push','8',&acgtRs{
            $b = Rc&b;
            Rs&act and s&dis = 1
            elsif (b) {
                # %push!%act with history
                # grow/shrink if leave/become exactly equal
                if (b && bs&exactly && !Rs&exactly && !Rs&boost) {
                    me&introqua,R,{boost:1};
                    Rs&boost = 1;
                }
                if (b && !bs&exactly && Rs&exactly && Rs&boost == '1') {
                    ~Flattened settling push: R.t
                    me&introqua,R,{boost:0};
                    Rs&boost = 0;
                }
            }
            (Rs&boost||0) < 1 and return
            
            s&fs = 13;
            s&dis = 1;
            #n thing  $s:R.sc,R %sun
        },'ift,D'],
        #c push-moves
        # 7%push sends its future self %moves to do
        #   objects (esp %from and %pusher) from that time
        # now early enough to make %ball%othering
        # < tell it to be awake
        # a %move is just a C, has:
        #   c&from/c&to: most of all
        #   c&push: %push when it started to move
        # if you:
        #   c&pusher: whatever/%push the move was designed in
        #  you get:
        #   c&pushed: yfutured/%push when move completed
        ['push+moves','4',&acgtRs{
            $M = Rs&moves;
            each in M {
                ns&done and continue
                # with items from late last time
                $f = nc&from;
                $t = nc&to;
                t ||= nc&into;
                !t || !ts&ball and throw "move not sure of t%ball"
                !t || !fs&ball and throw "move not sure of f%ball"
                # us, last time
                $p = nc&pusher;
                nc&push = R;
                # f is likely to be the last %here, unless reversing
                # t (usu c&to=%their) may still be c&into=%there
                $tp = t && ty&up;
                if (tp && tps&pushering) {
                    tp = me&yfuture,tp;
                    # parent mediates %push for some reason
                    #  eg to %kvstore %here%string
                    # not %their directly
                    ~pushering: t.t, R.t
                    ac(tp,'pushering',R,'ball',f)
                }
                else {
                    $to = t;
                    t = me&yfuture,t,R;
                    ~othering: t.t, R.t
                    0 > Rc&N.indexOf(t) and ns&warn = 'to!cur'
                    t == to             and ns&warn = 'to!futu'
                    ts&ball == '6'      and ns&err = 'toolate'
                    
                    if (!ns&err) {
                        # bit more pto
                        ns&move = 1;
                        ns&from = f;
                        ns&to = t;
                        ac(t,'movingin',n);
                    }
                    # usu othering %push%here,
                    # < the %moves making subcommits:
                    #   their own reselections of %ball
                }
                
                ns&sym = n.t == 'checkout' ? '↽' :
                    ns&pull ? (ns&pending ? '◅' : '◄') :
                    ns&step ? '‣' :
                    (ns&pending ? '▻' : '►');
                ns&err and ns&sym += '!'
                ns&done = 6;
                #n thereup  $s:ty&up,R %sun
                # t%ball%othering should get us
            }
            
        },'ift,D'],
        
        # moves talked about 
        ['push+moves','8',&acgtRs{
            $M = Rs&moves;
            M.length &&
                n moves $s:M,R %hadmoves
        },'ift,D'],
        # squishy shrinking ooze, preserving interesting events
        # more info at latest
        ['hadmoves','3',&acgtRs{
            $p = Ry&up;
            $forget = [];
            each in s {
                # done this round
                if (ns&done == 6) {
                    ns&done = 9;
                    $r = nc&pusher;
                    # branch at %push%their with %move
                    r and nc&pushed = me&yfuture,r,R
                }
                # id by name then symbol
                $sym = n.t;
                ns&sym and sym = ns&sym
                n $n.t  $s:sym %fs:12,hs:594
                
                ns&err and me&tsc,'error',ns&err,'d';
                ns&warn and me&tsc,'warn',ns&warn,'d';
                
                if ((Rs&boost||0) > 0) {
                    # TEST doesn't get out?
                    $t = "Cit:"+n.t;
                    n $t  $self:n,R %Reis:Cit,set:Cit
                }
                
                # condenses
                if (s.length > 5) {
                    $ne = s [i+1];
                    ne && n.t == ne.t and forget.push(i)
                }
            }
            
            forget.map(i => s.splice(i,1));
        },'ift,D'],
        

    ] };
    

    #c TeCo
    # minimal pin-like thing returner (harness acts)
    me.domething = &acgttc{
        !me[t] and throw "no me."+t
        !c.acgt and throw "somethingelse"
        $r = me[t](A,C,G,T, ...c.acgt);
        c.returns && !r and throw "me."+t+" !return"
        return r
    };
    # %act='TeCo' gets this %made
    #  make instructions for Co
    me.TeCo = &acgtRhtc{
        $s = hc&s;
        # s:
        # haps
        #   step_1
        #     WaTe %H:38247253
        #       someelvising
        #   step_2
        #     haps %H:38231253
        $Co = G&Cye,['Co',''];
        i $Co/$s
        # r is %made, all new rc&s
        $r = me&Copy,R,Co,{ov:16,Ropia:[h]};
        
        # want to just:
        # o $Co/*:main/*:step/*:do
        # with %ball layer, style main + do
        
        $main = me&ioty,r,'%ball' [0];
        $m = mainc&s;
        
        # ensure step_1
        !mains&z and me&input,main,'step_1';
        $steps = me&ioty,main,'%ball';
        each in steps {
            # ensure doing=main.t
            !ns&z and me&input,n,main.t;
            $does = me&ioty,n,'%ball';
            each id does {
                $n = dc&s;
                # whittle to instruction part
                # hiding whatever is here that is not it:
                # - the H object it should be
                ns&H and ds&H = delete ns&H
            }
        }
        
        # < any s&H still anywhere should be loaded in
        # < why only now can this have effect?
        $main = me&ioty,r,'%ball' [0];
        $m = mainc&s;
        
        delete rs&ov;
        rs&Lines = 3;
        # onward 2%ball Rsyncs, anything under r may ~
        me&Ring,r;
        
        $mains = me&ioty,r,'%ball';
        each im mains {
            # blows everything away when othered
            ms&clobberypushingz = 1;
            # limit othering of steps (to %run%currentstep?)
            ms&pushingnoz = 1;
            # if new steps are wanted, what W?
            ms&invent_step = m.t;
        }
        ~TeCo: main.t
        return r
    };
    #c act
    # where it must do a computation
    # the R that %push%made, relative to others
    # ie an elvising that sleeps
    me.Actingness = &acgtR{ return [
        # the R that %made
        ['push+act','721',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            # marked by %testrun, noop for the mo
            # < wandering around each %testrun
            if (!hs&testrun) {
                # < rollbs onto %ball
                $hs = hc&s;
                !hss&testrun and ~turning%testrun: hs.t
                hss&testrun = 1;
                hs&testrun = 1;
            }
            $t = Rs&their;
            # this R with %here + %made when %move was made
            $Doing = Rs&Doing;
            # negates theirs diffs
            Rs&diffya ||= {};
            Rs&diffya.theirs = 0;
            
            # diff the input with %made's input
            $mh = me&rollbs,R,'made_here';
            mh and $indiff = me&diffya,R,'input',h,mh
            if (indiff) {
                # input better understood as %made
                indiffs&sublated = 1;
                indiffs&exactly and Rs&made = Rc&b.sc.made
            }
            
            # %made ||= the act
            if (!Rs&made) {
                Rs&made = me&domething,Rs&act,{acgt:[R,h,t],returns:1};
                Rs&made_here = Rs&here
            }
            
            # diff %made to %made when move was made
            Doing and me&diffya,R,"diff",Rs&made,Doings&made
            
            if (t && t.t != h.t && t.t == 'Co') {
                Rs&mained = me&ioty,Rs&made,'%ball' .filter(n=>n.t == h.t)[0];
                !Rs&mained and throw "No Co/%mained thing";
            }
        },'ift,D'],
        
        # < as part of a %push%made%plan to make Co/%main/%steps
        
        # %made = Co [haps[step[do[elvis]]]]
        # is othered to %their instead of %here, so:
        # %mained = %made Co/haps
        # %main = %their Co/haps
        # two halves of living situation
        ['push+act','591',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            !h and return me&waits,'..h'
            $t = Rs&their;
            if (!t) {
                me&waits,'..t'
                Rs&losttheir = 1;
            }
            !t and return
            
            if (t.t != h.t && t.t == 'Co') {
                # locate their main thing (othered from %mained)
                $main = me&ioty,t,'%ball' .filter(n => n.t == h.t)[0];
                !main and return
                Rs&main = main;
                # Linesing per do
                $N = me&ioty,main,'%ball%ball';
                each id N {
                    #me&tsc,'indo','('+d.t+')','b';
                    me&suggesc,d,'Lines';
                }
            }
        },'ift,D'],
        #c push+act=made
        # Co/Hap/ Hap v1...
        # a bug chaser
        # make deals across the border so
        # a layer of task built onto a push
        # some complicated thing breaking out steps
        # < take %made/%step++ to %main/%step
        ['push+act','73',&acgtRs{
            s&bow = '3px';
            n act  $s:Rs&act %deco
            $h = Rs&here;
            $t = Rs&their;
            # persist %run per %main%ball c&s
            $mains = Rs&main && Rs&main.c.s;
            #  per clobberypushingz, restarts test run (drops J)
            $r = me&rollcounty,R,'run',{per:mains};
            # between two planes
            $N = me&ioty,Rs&main,'%ball'
            $Z = me&ioty,Rs&mained,'%ball';
            
            me&tsc,'thoughtclock',r.t+"@"+rs&count,'6' .sc.fs=7;
            me&tsc,'tot','('+N.length+'/'+Z.length+')','p'
            # 4%step and then 5%groksteps...
            n progress  R %groksteps
            
            # zip N-results to Z-expectations,
            #  allowing more N if all is %ok
            $i = 0;
            while (N[i] || Z[i] || i == 0) {
                $eye = i+1;
                $k = 'step_'+eye;
                n $k  $step:eye,got:N[i],exp:Z[i],R
                i++;
            }
        },'ift,D'],
        # groksteps
        #  playhead advances when more && ok
        #  boost to add steps
        # ⧐ from the top
        # ∿ big change
        # ~ small change
        # ☯
        # 
        ['groksteps','81',&acgtRs{
            $p = Ry&up;
            $steps = me&ioty,p,'%step';
            Rs&ok = 1;
            Rs&more = 0;
            each iS steps {
                $doings = me&ioty,S,'%doing';
                each in doings {
                    ns&doing == 1 and return T.wide = 1
                    !ns&got and Rs&more = 1; break
                    # results got must be ok
                    !ns&ok and Rs&ok = 0
                }
            }
            Rs&ok ? me&tsc,'ok'
                : me&tsc,'notok','!','B';
            # < pause/play/further from here
            # < redo = fork from last ok state?
            Rs&more ? me&waits,'more','≻','L'
                : me&waits,'moreanyway','⊁','L';
            
            if (Rs&ok && Rs&more) {
                if (ps&almost) {
                    me&tsc,'almost','>-'
                    return
                }
                ~okmore: R.t
                ps&boost >= 1 and Rs&wantstep = 1
            }
            Rs&boost > 0 and Rs&wantstep = 1; Rs&Te.sc.boost = 0
            
            Rs&wantstep and ps&stepforward = 1
        },'ift,D'],
        
        #c push+made=moves?
        # others a %main%step
        ['push+made','82',&acgtRs{
            $m = Rs&mained;
            $M = Rs&moves;
            # < become %aTool in the nearest %Tool,
            #   gently raised exception, shoulding to disappear
            $problem = 0;
            $prob = &s{
                problem = 1;
                return me&tsc,'noforward',s,'B'
            };
            if (Rs&stepforward) {
                # should be ready
                !m and prob('!mained')
                !Rs&main and prob('!main')
                !M and prob('!moves')
                problem and return
                
                # find step with no %got
                $N = me&ioty,R,'%step';
                $S = N.filter(S => !Ss&got)[0];
                if (!S) {
                    # go beyond expectations
                    $doing = ms&invent_step;
                    !doing and throw "no more steps"
                    typeof doing != 'string' and throw "doing"
                    doing = G&Cye,[doing,''];
                    
                    $la = N.slice(-1)[0];
                    $i = las&step + 1;
                    $S = G&Cye,['step_'+i,''];
                    S = me&Copy,R,S,18;
                    me&input,S,doing;
                    
                    delete Ss&ov;
                    Ss&Lines = 3;
                    # onward 2%ball Rsyncs, anything under S may ~
                    me&Ring,S;
                }
                else {
                    !Ss&exp and return me&tsc,'noforward',"nextstep!exp"
                    S = Ss&exp;
                }
                
                # S is now a new %mained %step's %ball (or looks like it)
                # push the new %step to %main
                m step $from:S,into:Rs&main,pusher:R %step
                S && Ss&string and me&tsc,'shipping',Ss&string,'6'
                #n stepth  $s:Rs&main,R %sun
                
                #$c =
                #m push $from:h,to:t,pusher:R
                #~wouldstep: R.t
            }
        },'ift,D'],
        #c step acceptor
        # %push's %step/%doings build up %ok
        # < hang %step on the %here %ball it's for
        ['step','2',&acgtRs{
            Rs&rowish = 1;
            $p = me&zoep,R,{up:'%push'},'step','S','';
            $m = me&rollcounty,R,'mem',{per:ps&run};
            
            # go main/mained %step -> %do
            $N = me&ioty,Rs&got,'%ball';
            $Z = me&ioty,Rs&exp,'%ball';
            
            $i = 0;
            while (N[i] || Z[i] || i == 0) {
                $eye = i+1;
                $k = 'doing_'+eye;
                n $k  $doing:eye,got:N[i],exp:Z[i],R
                i++;
            }
        },'ift,D'],
        ['doing','3',&acgtRs{
            $p = me&zoep,R,{up:'%step%push'},'doing','.','';
            $m = me&rollcounty,R,'mem',{per:ps&run};
            $M = ps&moves;
            $g = Rs&got;
            $x = Rs&exp;
            # helps %groksteps decide things are ready
            # (A below should be done by the time...)
            Rs&doing = 3;
            x && !g and return me&waits,'nogot','...'
            !x && !g and return me&waits,'noexpgot','..!'
            
            # prepare to %diff
            $dc = {};
            # was no %doing
            !x and dc.unexpected = 1
            else
            # was no %doing%H, the result
            # swaps x with nothing insides %diff
            !xs&H and dc.unexpected = 1; dc.expGhost = &{};
            else {
                # make it look Linesey
                xs&dige = xs&H;
                # decode contents if needed (for a diff_
                dc.expGhost = &{ return me&GhostOut,R,xs&H; }
                # < decompress vastnesses
                # < use trusted code to generate everything?
                #   a lobo A4 copying dispatches from a live instance
                #   clonesyncing as it transports between them
            }
            
            # got %ball = n
            $W = g && gc&s;
            # replaces instruction
            W && !Wy&C and return me&waits,'noWyC','n...'
            
            # diff
            if (g) {
                $d = me&diffya,R,R.t,g,x,dc;

                # < what happens to this?
                ds&new and me&tsc,'nothere','⧀','L'

                ds&exactly and Rs&ok = 1
            }
            
            Rs&ok and ms&ok = R
            elsif (ms&ok) {
                # results are allowed to wander off once ok
                # such info is interesting
                # < accept/test for history-warp
                d and ds&sublated = 1
                n accepted_before s:=)
                Rs&ok = 3
            }
            
            #c This
            # we have a diff, know if ok now/before
            # and all this:
            if (W) {
                if (Rs&boost < 0) {
                    # quick redo thing
                    # < when it <G
                    $p = g.y.up;
                    $ps = pc&s;
                    $pi = pss&z.indexOf(W);
                    pi < 0 and throw "nofind"
                    !Wy&C and throw "nooriginal"
                    W = Wy&C;
                    pss&z[pi] = W;
                    delete Wy&C;
                    W = null;
                    Rs&Te.sc.boost = 0;
                    return
                }
                # the object
                n Cit  $self:W,R %Reis:Cit,set:Cit
            }
            Rs&ok and return me&tsc,'ok','ok','p'
            
            if (W) {
                if (Ws&err) {
                    $skull = '☠';
                    me&tsc,'error',skull,'D';
                    me&tsc,'error',Ws&err,'d';
                }
            }
            
            # we have %here, find names for %step/%doing
            $S = Ry&up;
            $stepname = Ss&exp ? Ss&exp.t : S.t;
            $doingname = x ? x.t : 
                # to save an invented step/doing (!x) as got
                g ? g.t :
                R.t;
            
            # accept change
            if (g && Rs&boost > 0) {
                !Rs&shove and Rs&Te.sc.boost = 0;
                me&tsc,'accept',"<",'L';
                
                # find us from %here
                $step = me&input,ps&here,stepname;
                $doing = me&input,step,doingname;
                # store an object
                !gs&dige || !gs&string and throw "weird"
                me&GhostIn,R,gs&dige,gs&string;
                # put pointer
                $ds = doingc&s;
                dss&H = gs&dige;
                
                $dt = ds&Te;
                # reset diff about to become '='
                dt && dts&boost and dts&boost = 0
            }
        },'ift,D'],
        
    ] };
    #c pushy
    # operate on Ghost/kvstore remotely
    # < s&H object pointers wander borders
    me.GhostOut = &acgtRk{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $s = localStorage[k];
        !s and throw "noH: "+k
        # a %ball with %Lines=0
        return Ghosts&arrange_decoder(k,s);
    };
    # write-once storage
    me.GhostIn = &acgtRks{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $bs = localStorage[k];
        bs && bs != s and throw "hash collision?"
        localStorage[k] = s;
    };
    # the source of your information
    # o ^^%push %here %pushed'lookup' %there
    me.sGhost = &acgtR{
        $Ha = me.cby(R,&b{ return
            bs&pushed && bs&pushed[0].t == 'lookup'
        })[0];
        if (Ha) {
            $pl = Hac&pushed[0];
            $Ghost = pls&there;
        }
        else {
            #  %pushed falls off if throw
            $Ghost = me&pushpath,R,['/','G'];
        }
        return Ghost
    };

    #c Ring mind, doming
    # empties grounda&z into M or more R
    me.endome = &acgtR{
        !T.nN || !T.nN.length and return
        $N = T.nN;
        T.nN = [];
        $M = null;
        each in N {
            !nc&R && ns&R and nc&R = delete ns&R
            if (nc&stv) {
                # namespace del C
                $s = nc&s = delete nc&stv;
                n.t = s.t+' '+(s.y.cv||'')
            }
            if (nc&R) {
                $parent = R;
                if (nc&R != '1' && typeof nc&R == 'string') {
                    # c&R='mode' becomes sc.$mode = 1
                    # < ongoing type-of-name smurgery
                    n.sc[nc&R] = 1;
                    nc&R = 1;
                }
                else {
                    $s = nc&R;
                    if (s && Rc&N.indexOf(s) >= 0) {
                        parent = s;
                        s = null;
                    }
                }
                delete nc&R;
                # > R=$s sometimes
                nc&s and s = nc&s; delete nc&s
                ex(n.sc,n.c);
                $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
                parent != R and me&zN,r
                # to $r = n ... %R, follow:
                n.y.R = r;
            }
            else {
                # otherwise this mindthing grows M
                M ||= me&Mw,R,t.t;
                M.push(n)
            }
        }
    };
    
    # while the R.t == mind of this pool
    $osu = &Rt{
        $task = t || Rs&task || R.t;
        !me[task] and debugger;
        
        # bit of caching on the w.t=Coffle, closured from eval
        $mI = ws&makesI ||= {};
        mI[task] and return mI[task]
        
        # m ... BQ breaks code visibility (until proper u)
        $z = [];
        $N = me[task](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            
            # compile instructions
            if (ns&ift == '1') {
                $op = n.t.split('+');
                if (op.length > 1) {
                    # must have all these sc
                    ns&ifs = op
                }
                else {
                    ns&if = 's'+n.t
                }
            }
            elsif (ns&ift) {
                ns&if = 's'+ns&ift;
                ns&ifeq = n.t;
            }
            
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        mI[task] = z;
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => me&zN,z );
    };
    # Rs&z -> hc&N, validates as atom
    me.zN = &acgtR{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    #c Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtRq{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        $the = me&Timethe,'Ring:'+h.t;
        
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            me&zN,h;
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        # walk the 愛 tape, trying to do more
        $timing = 1s&Times;
        $direct = 0;
        $indirect = 0;
        # a concentration
        # if things don't happen in the correct order,
        # since we go wide fairly often
        #  the parent Acv > the child sometimes matters:
        #   to get Cit3/slep2 to be Cit27(getslep)/slep2
        if (q) {
            # on those q.inside=$R (or und, includes R)
            #  growing q.onlyRupto
            q.und and q.onlyRupto = [q.und]
            q.inside and q.onlyRupto = [q.inside]
            q.ov and q.ov = G&sca,q.ov
            # < R indexed by cv
            # or otherwise grouped for meaningful disruptability
            #  TimeWaves
            # < have cursors not bunged by asyncs
            #    which is doming, a general segmentation
        }
        
        $busy = 1;
        $sheer = 145000;
        $onlyt;
        while (1) {
            indirect++;
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (q && R && q.onlyRupto && R != q.und) {
                R == q.inside and continue
                $not = q.onlyRupto.indexOf(R) < 0;
                if (not && Rs&ci == null &&
                    q.onlyRupto.indexOf(Ry&up) >= 0) {
                    q.onlyRupto.push(R);
                    not = 0;
                }
                not and continue
            }
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                onlyt = null;
                $lowci = '';
                $ati;
                each in hc&N {
                    if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                        lowci = ns&ci;
                        ati = i;
                    }
                }
                #lowci != '' and hs&iN = ati-1
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            Ry&R ||= R;
            
            # step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            R.c.not and continue
            #onlyt && t != onlyt and continue
            
            hs&ov && hs&ov < ty&cv and continue
            q && q.ov && q.ov < ty&cv and continue
            
            #c from here is going to accept the step as done
            #  except if T.wide, late abort/comebacklater
            #   for when your dependencies haven't filled out
            #    < keeping loopage direct with TimeWaves,
            #      which try to gather at fully awake
            
            # deciding
            $T = {};
            if (Rs&sleeping) {
                # misses everything but sleeping spells
                !(ts&sleeping || t.t.substr(0,8) == 'sleeping') and T.not = 'sleeping'
            }
            if (ts&ifs && !T.not) {
                each ik ts&ifs {
                    R.sc[k] == null and T.not='ifs'
                }
            }
            if (ts&if && !T.not) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='ifh'
                elsif (ts&if[0] == 's') {
                    $v = R.sc[ts&if.substr(1)];
                    !v and T.not='if'
                    ts&ifeq && v != ts&ifeq and T.not='ifeq'
                }
                else {
                    throw "if "+ts&if
                }
            }
            if (timing) {
                indirect--;
                direct++;
                $k = h.t+'/'+t.t+'@'+t.y.cv;
                timing[k] ||= 0;
                $from = G&time;
                $thestep = &{
                    timing[k] += G&time,from
                };
            }
            
            if (!T.not) {
                $packdown = [];
                if (ts&D) {
                    # doming for n
                    T.nN = [];
                    packdown.push(&{
                        # empties T.nN into M or more R
                        me&endome,R;
                        delete T.nN;
                    });
                }

                $cb = tc&s;
                #!hak(R.c,'s') and debugger;
                
                cb(A,Rs&C||C,G,T,R,Rc&s);
                
                packdown.map(pd=>pd())

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            thestep and thestep()
            if (T.Rq) {
                $TRq = delete T.Rq;
                me&Ring,R,TRq;
            }
            if (T.wide) {
                Rs&widenings ||= 0;
                Rs&widenings++ > 30 and debugger;
                delete T.wide;
                busy = 1;
                continue;
            }
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            onlyt = t;
            busy = 1;
        }
        if (timing) {
            timing.direct ||= 0;
            timing.indirect ||= 0;
            timing.direct += direct;
            timing.indirect += indirect;
        }
        the();
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #    C.y.R = R:C
    #   sprouts some sc to R:$gk or so
    # < determine, certify version of etc involved
    # we have a village's machinery for progress
    # < teleporting in: knowing you want such sleep pattern
    #    for vibrating values (oscillation)
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c Flim pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    # inside W:Wobulus, after W:Fourier
    me.do_main = &acgt{
        if (1) {
            me&J,['Pass','W',{},{timing:0}]
            me&J,'Das','W';
            me&J,'Co','W';
        }
        else {
            me&J,['edges','W',{},{timing:0}];
        }
        #me&J,'Fours','W';
    };
    # PassDasCo
    # host attachable T with W + G around
    me.Ja.Fours = &acgt{
        me&Gomp;
        n 4sDasN  $s:4s&Jtv %rovo:ning
        n 4sDasN  $s:A.4.sc %sun
    };
    me.Ja.Pass = &acgt{
        me&Gomp;
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Ha  $Travel:el %ravel:gee
    };
    me.Ja.Das = &acgt{
        me&Gomp;
        $N = 4s&DasN ||= [];
        
        n 4sDasN  $s:N %ravel:spond
    };
    me.Ja.City = &acgt{
        me&Gomp;
        $z = delete s&z;
        $Te = C.y.zTe = z[0];
        $te =
        n Citey  $s:c&s,thisis:4 %ravel:Citying
        me&clearTe,1s&Te;
        tey&TeImplant = Te;
        # quiets T/City, about to get ^
        1s&runs == 1 &&
            me&sublatePassT,A.1.t;
    };
    # puts $W
    me.Ja.PuTe = &acgt{
        me&Gomp;
        $z = delete s&z;
        $Te = C.y.zTe = z[0];
        $el = 4s&elvisory;
        i $el/-#$Te
        i $el/$Te
    };
    me.clearTe = &acgtt{
        !t || !t.c and return
        delete ts&z;
        delete ty&tv;
    };
    #c Co
    # provide n to %main/%step/%doings
    me.Ja.Co = &acgt{
        me&Gomp;
        $t = 1s&Te;
        $ocb = delete c&ocb;
        $cb = &{
            me&doN,ts&z;
            ocb && ocb()
        };
        # too late for this J to include it
        t && ts&z and G&yl:0,cb;
    };
    # do only undone %main/%step/%doings
    me.doN = &acgtN{
        $Js = 1s&mainJs ||= {};
        each im N {
            # a main
            $mainJs = Js[m.t];
            if (!my&began) {
                # fresh run, clear memories
                each ti mainJs {
                    #~Cleans: m.t, t
                    delete 4s&Jtv[t];
                    i 4s&elvisory/-#$t
                }
                mainJs = Js[m.t] = {};
            }
            my&began ||= G&time;
            each iS ms&z {
                # a step
                ms&pause || Ss&pause and continue
                $tw = {};
                each iC Ss&z {
                    # a doing
                    if (C.y.C) {
                        # points to original when done
                        # becoming the latest of $t
                        tw[C.t] = C;
                        continue
                    }
                    if (c&points) {
                        c&s = tw[c&points];
                        !c&s and s&err = "No points: "+c&points; continue
                    }
                    $live = me&adoing;
                    lives&W and mainJs[C.t] = 1
                    # if another, keep it instead
                    tw[C.t] = C.y.D = live || C;
                    if (live && live != C) {
                        live.y.C = C;
                        Ss&z[i] = live;
                    }
                }
            }
        }
    };
    # n $C # returns another
    me.adoing = &acgt{
        $q = {q:'W'};
        try {
            q.part = 'Jin';
            me&J,C,q;
            q.part = 'Jreturned';
        }
        catch (er) {
            # < powow with Ban to surf Bstack
            C = q.C || C;
            s&err = ki(C,2)+"   !"+q.part+"! "+er;
            ~adoing_er: s&err
        }
        return q.C;
    };
    #c Tests now we will try to make software:
    me.Ja.lobbek =
    me.Ja.happenings = &acgt{
        me&Gomp;
        $bit = 1s&bithold ||= G&Cye,['Bit',''];
        $b =
        n abit  s:lau %fopia
        i $b/$bit
        bits&bobs ||= 0
        bits&bobs --;
        #bits&bobs == -2 and throw "Unfielded quark"
        
        n Plethoria  $s:<<'' %oph:s
            # glampiture
            n now  s:noow %fs:54
        
        # < get rid of ^'s /^\t\t\t/
    };
    me.Ja.seeI = &acgt{
        me&Gomp;
        $Is = ['ravel','Cit'];
        each ik Is {
            $N = osu(C,k);
            $l =
            n $k 3
            ls&z = [];
            each iI N {
                G&m,ls&z,[I.t,Iy&cv];
            }
        }
    };
    me.Ja.XV = &acgt{
        me&Gomp;
        s&Ring = 'XVer';
        $eye = 1s&count-1;
        
        n A 2 $s:33
        n Saucerful 2 $s:55
        eye < 1 &&
            n of 32 $s:33
        eye > 1 &&
            n Secrets 35 $s:22
        n thy  $s:eye
        
    };
    # see history work
    #   want to see Rc&X/V and Rs&X
    #   across all instances of time
    #   probably just from the top...
    
    # a bit of history use
    me.XVer = &acgtR{ return [
        ... me&DisplayTwoness ,
        ['Ring','2',&acgtRs{
            s&lv = 1;
            Rc&refs = [];
            Rc&refR = [];
            each in ss&z {
                n.t == 'thy' and Rs&count = nc&s;
                (ny&cv||0) < 0.2 and continue
                n $n.t  $stv:n,R %fr
            }
        },'if:h,D'],
        ['fr','2',&acgtRs{
            $p = Ry&up;
            if (s.t == 'Secrets' && ps&count == '2') {
                ps&Blewup = 1;
                pc&X.Blewup= 1;
                throw "chucka"
            }
            me&rollbs,R,'twang';
            
            Rs&twang ||= 0;
            Rs&twang < 8 and Rs&twang ++
            n twa  $s:sc&s %fs:16
            n for  $s:Rs&twang %hs:466
            ss&twan = Rs&twang
            
        },'ift,D'],
        ['Ring','4',&acgtRs{
            $b = Rc&b;
            each in Rs&gone {
                # yprev before
                $ni = bs&z.indexOf(n);
                $f = b.sc.z[ni-1];
                # now gets to know
                f = me&yfuture,f,R;
                ac(f,'remembers',nc&s.t)
            }
        },'if:h,D'],
        ['fr','6',&acgtRs{
            me&rollbs,R,'remembers';
            $r = Rs&remembers;
            r and ss&remembers = r.join(",");
        },'ift,D'],
    ] };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c ravel about their state,
    # become straight, become curvy, cellvey
    # have things wanting to be streamed uphill
    # showing interfaces where things can come across
    
    # h's ss&rovo='atype' -> Rs&atype = 1
    me.Rscinsideness = &acgtk{
        return [
        ['Rscinside','1',&acgtRs{
            $uh = Ry&up && Ry&up.c.N[0];
            uhs&task == Rs&task and return;
            isC(s) && s.sc[k] and R.sc[s.sc[k]] = 1
            Rc&dupl = 3;
        },'if:h']
        ]
    };
    me.sublatePassT = &acgtt{
        me&introqua,['Pass','Ha','ravel','T',t],{boost:-1}
    };
    me.ravel = &acgtR{ return [
        #... me&Displayingness ,
        ... me&DisplayTwoness ,
        ... me&Rscinsideness,'ravel' ,
        # the living - a situation
        # slow rolling wakeup
        # openness is travelled in
        # up into cell
        ['gee','3',&acgtRs{
            Rs&rowish = 1;
            # < stop relying on %ball%Lines to do %printDisplay
            Rc&nl = 50000;
            # %balls get shot into T
            #  giving a pi? real/veyd layers of sc?
            #  e /T -run . %does:TeCo %boost:2
            Rs&playsheet = {
                ball: &acgtR{
                    $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
                    Rs&Te && Rs&Te.sc.almost and ls&almost = 1;
                    ls&boost = 2;
                    me&introqua,l,{boost:1},'ifel1'
                },
            };
            # A.4 to/run/from, shared
            # is the local stage, our gear projected on
            # land of ignoring your own mind
            1s&runs == 1 &&
                me&sublatePassT,A.1.t;
            
            n T  $s:sc&Travel,R %ball,bgh:383,slan_digify,beawake
            
            # < stuff above the line of W here
            
            n Tool  R %Tool
            # < all Rz report to nearest Tool?
            
            n W  $lookup:s.t,R %ballse
            #,dragelvis:projvey
            
            
            n G  $kvstore:localStorage,R %ballse
        },'ift,D'],
        
        # lookup %ball/*.t in G
        # assorted W you asked for, bay of incoming remotes
        #   elvising/G&t-ish interface to mysterious places
        ['lookup','2',&acgtRs{
            $g = Ry&up.sc.z.filter(g=>g.t == 'G')[0];
            !gs&ball and return T.wide = 1;
            # W holds many, to sync to G
            # with %lookup: highest/starting point
            $t = Rs&lookup;
            if (t != '1') {
                # < be othering ourselves, lending content
                #   to get instant %ball for things
                #   and so disconnections keep objects
                #     for packdown/gc
                #   specifying types of ephemerality:
                #     runspace kept tidier than piles
                $n = me&push,R,[],[t],'purpose';
                # ensure it's first in z
                $zi = ss&z.indexOf(nc&s);
                zi > 0 and ss&z.unshift(ss&z.splice(zi,1)[0])
            }
            
            # ready all s/* as R/*%balls
            me&Rsync,R;
            
            $N = me&ioty,R,'%ball';
            each in N {
                # posit they %push(ish) to G
                $l = me&push,n,['/','G'],[],'lookup','checkout';
            }
        },'ift,D'],
        ['continuity markers','28',&acgtRs{
            !(Rs&ball || Rs&push) and return
            $b = Rc&b;
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        ... me&Ballingness ,
        ... me&Copyingness ,
        ... me&Pushingness ,
        ... me&Actingness ,
        ... me&Linesingness ,
        ... me&Diffingness ,
        
        ... me&Slepingness ,
        ... me&Toolingness ,
        #c kvstore
        # accept %pushish as a name lookup first
        #  names %decode'd and pushed here
        #   they have a %delivered %ball stuck in the past
        ['kvstore','2',&acgtRs{
            # t source
            # weak %push
            # %pushin helps project lives from s
            #   as decode
            # looks at %balls pushing to it,
            #  look for them here
            #   pushing there 
            #  accept their content if full enough
            !Rs&pushish and return T.wide = 1;
            # tell %push to do
            # < search children for %othering
            # < upgrade %othering sense to
            #   any of the objects
            Rs&pushering ||= [];
            me&rollbs,R,'rememb';
            
            Rs&get_key_for = &t{
                return ts&H || t.t
            };
            Rs&arrange_decoder = &ksl{
                # arrange decoder
                $re = Rs&rememb ||= {};
                $kd = k+dig(s);
                $bc = {task:'ravel',Lines:1,intoa:'ball',noDisplay:1};
                bc.remova = &{ delete re[kd] };
                # keep the %balls with the decoding Lines stuff
                $S = re[kd] ||= me&Reis,R,k,s,bc;
                $Ss = Sc&s;
                Ssy&decoder = S;
                Ss&keepy = 'decoder';
                if (l) {
                    # %pull%here=S, see below 
                    $L = me&push,R,[],S,'decode','hard';
                    # allow %their from ^ to look like l's %thing
                    ls&deliverer = L;
                }
                return S
            };
            
            each il Rs&pushish {
                $t = ls&here;
                # a remote %push, for some id
                $k = Rs&get_key_for(t);
                $s = localStorage[k];
                !s and ls&new = 1; continue
                
                Rs&arrange_decoder(k,s,l);
            }
        },'ift,D'],
        ['kvstore','4',&acgtRs{
            !Rs&pushering and return
            $i = 0;
            while (Rs&pushering[i]) {
                l = Rs&pushering[i];
                $t = (Rs&pushering_ball||[])[i] || ls&here;
                if (ls&hard) {
                    $S = tc&s;
                    # %here%ball must be the same
                    $still = ls&delivered && t == ls&delivered;
                    if (!still) {
                        i Rc&s/-#S.t
                        n ush  s:ush
                        ts&keepy = 'decoder';
                        ac(R,'pushing_z',l,'ball',t);
                        # becomes %push%their
                        ls&delivered = t;
                    }
                }
                else {
                    # must have a Lines done
                    !ts&ball || !ts&LinesN and throw "not %here=%ball%LinesN"
                    $good = ts&string && ts&string.length > 7
                    !good and throw "string dodgy"
                    # redecode, sets/does another ls&deliverer since lookup
                    #  checks it works,
                    #  %move%pushed%their gets what was pushed
                    $k = Rs&get_key_for(t);
                    Rs&arrange_decoder(k,ts&string,l);
                    localStorage[k] = ts&string;
                    # < check it's what %push knew about when it pushed
                    # < may contain several things to which you must link
                }
                i++;
            }
        },'ift,D'],
        #c further
        ['kvstore','6',&acgtRs{
            $N = me&ioty,R,'%ball';
            # hide innards
            each in N {
                ns&nofurtherDisplay = 1;
            }
            
            n fur  $selves:N,R %tfurther
        },'ift,D'],
        ['tfurther','3',&acgtRs{
            me&tsc,'tfurther','t','G','fs:12'
            (Rs&boost||0) < 1 and return
            Rs&rowish = 1;
            s&bo = '2px dotted green';
            s&hue = 30;
            s&br = 0.4;
            # create a bunch more lookups
            
            each in Rs&selves {
                n $n.t  $self:n,R %Wirror
            }
        },'ift,D'],
        # sync localStorage -> webserver
        # use 24/NutIns' new G&t (G&ting) and it's W mode
        # from the thing receiver outran the thing providor
        ['Wirror','3',&acgtRs{
            s&hue = 80;
            me&domesticate,R;
            $h = Rs&self;
            !hs&dige and h = hc&s.y.decoder
            !h and throw "nodecoder"
            $k = h.t;
            #k = 't/iooiatal';
            $C = me&rollcounty,R,'tinging',{per:k};
            
            # persist a Question
            $Q = s&Q ||= G&Cye,[k,'',{of:'W'}];
            # which may throw async
            $ting = &Q{
                $r;
                try { r =  G&ting,Q }
                catch (er) { }
                # gets stuck in pushing mode:
                delete Qc&s;
                return r
            };
            $r = ting(Q);
            # has a Pull, with the got content or not
            # almost looks ballish, a decoded C at c&s
            # < remotism, G tendrils of causality hung, shaft utils
            # < know if its state can be guaranteed by some news agent,
            #   prefer to hear of rather than go looking for news
            #   digwaypoll
            $P = Qs&P;
            
            !P and return me&tsc,'pleasewait','...','G'
            $del = G&time,Ps&now;
            del > 16 and me&tsc,'delta','>'+del+'s','b';
            me&tsc,'here','@'+hs&dige,'G'
            
            #n so  $self:C,R %sun
            !Pc&s and me&tsc,'notexist','⧁','G'
            else
            !Ps&dige and throw "eiwer"
            else
            Ps&dige == hs&dige and me&tsc,'equal','=','G';
            Pc&String == hs&string and me&tsc,'equals','==','G';
            else {
                # we have a P for the remote's branch
                # make it look like a ball so it can %diff
                Ps&ball = 1;
                Ps&Lines = 0;
                Ps&string = Pc&String;
                $d = me&diffya,R,'upstream',h,P,{hue:90};
            }
            
            (Rs&boost||0) < 1 and return delete s&qh
            Rs&rowish = 1;
            #c objects/names to copy
            $M = [];
            # write obj/$dige for versioning $h (if you know %H history)
            m h.t  $s:hs&string,dige:hs&dige
            
            # move depended objects first
            each in hs&LinesN {
                $s = nc&s;
                !ss&H and continue
                $string = localStorage[ss&H];
                !string and throw "Nolocal"
                
                $L = me.cby(n,&n{ return n == h });
                $path = L.map(n=>n.t).join('/');
                
                m $path  $s:string,aka:path,dige:ss&H
            }
            $qh = s&qh ||= {};
            $abug = 0;
            each in M {
                ns&ok = 1;
                $doq = &ts{
                    $q = qh[t] ||= G&Cye,[t,'',{of:'W'}];
                    $r = ting(q);
                    $P = qs&P;
                    $wai = &s{
                        ns&ok = 0;
                        ta(s);
                    };
                    $ta = &s{
                        $st = t[0] == 'o' ? '6' : '';
                        me&tsc,'waiting',t+s,st .sc.dis = 1;
                    };
                    # has a pull, has a result (decoded by G&ting)
                    !P and return wai('..')
                    Pc&String == s and return ta('==')
                    # BUG stop it continually doing this later:
                    #   losing P on update?
                    #  just gets by if all updates succeed once
                    abug = 0;
                    Pc&String ? wai('!=') : wai('...');
                    # write: add s to the question for next time
                    qc&s = s;
                    # next time
                };
                !nc&dige and throw "nodige"
                
                # a permanent object,
                #  excepting garbage collection (uninvented)
                #doq('obj/'+nc&dige,nc&s);
                
                # a place in the tree (Ha/Tothe/ThingthathasH)
                #   for some continuity in the git there
                nc&aka and doq(nc&aka,nc&s);
                
                if (!ns&ok) {
                    Rs&in_progress = 1;
                }
            }
            if (abug) {
                # see BUG ^
                n so  $self:C,R %sun
                return
            }
            Rs&in_progress and return
            # change what links it all together
            Qc&s = hs&string;
            
            delete Rs&Te.sc.boost
        },'ift,D'],
        
        
        #c haveth
        # interesting comment rubble from drained %pull:
        
        # t individuals in any place
        #     < new/gone similar -> moved
        # %haveth=to %ball vaguely
        # %other=from %ball specifica
            # once turned up, may have an in-t and an out-t
        # concat modulat 1-2?
            # < overall, has it pushed? 
            # < state change here/there click show in %ball
            #     that %ball's %pushed_ball will be historic,
            #         have sc.z %fix and etc
                # should show up as an item to push
                #   push/display change fairly easily
                # conversely, n.t only implodes:
                #   (sch_ballonlyt) -> G&t-ish, pull almost auto
                # needs some opposite to search with
            # wants to Rc&refs s now?
            # and the usual two-step confusible C-C nametag
        # < if engaged, %ball 5 notifies us?
                # engage drawing up of planes
                # becoming matter for idea/diff/apply
        
        # give idea of where on screen such ref is from here
        # eg up/prev/in = up, up/next/in = down
        # < up = left, in = right
        ['haveth','3',&acgtRs{
            if (!Rs&haveth) {
                n nohaveth  s:!
            }
            delete Rs&elvis;
            # draw an arrow between two R
            $we = me.cby(R,&R{ return Rs&cell });
            $th = me.cby(Rs&haveth,&R{ return Rs&cell });
            $direction = "v";
            each in we {
                $t = th[i];
                t == n and continue
                # path separates
                i == 0 and throw "different cells"
                $f = th[i-1];
                each il fs&z {
                    l == n and break
                    l == t and direction = '^'
                }
                break;
            }
            $d =
            n direction  $s:direction %fs:17,lh:0.05,hs:346
            
            $p = Ry&up;
            R.t == 'other' and direction == '^' and ps&upward = 1;
            
            if (!Rs&self) {
                # no yon %ball
                #R.t == 'self' and throw "self no self"
                R.t == 'self' &&
                    n ohno  s:!
                delete ds&hs; # green
            }
            # give other bigger arrow
            dc&s = dc&s == '^' ? '▲' : '▼';
            # < n should type styles into number etc
            R.t == 'other' and ds&fs = (ds&fs*1)+7
            # ◀ ▶
        },'ift,D'],
    ] };
    #c rovo, mounts current problem
    me.rovo = &acgtR{ return [
        ... me&DisplayTwoness ,
        #... me&Displayingness ,
        ... me&Rscinsideness,'rovo' ,
        ... me&Ballingness ,
        ... me&Diffingness ,
        ... me&Slepingness ,
        ... me&Actingness ,
        ... me&Toolingness ,
        # sleeperate the other thing
        # eg Elvisory%ball (or **)
        #  have a %slep injected by tangulate 27
        #  which checks %balls' input early with hindsight
        #    that means crawling around any %ball c&s
        #      < and the C%ball itself?
        #    and all other inputs
        #      which in the future
        #        all fall under Elvising
        #          and act like travelling X/V in tandem
        # %ball may %slan_digify:
        #   digs the landscape of each %ball down,
        #    into c&s.y.slandige
        #    and slan ignores it (or landscape would always change)
        # so then any Rs&Te.y.slandige is digs current elvising
        #   which can be saved with the work
        #     Ry&Te_slandige = Rs&Te.y.slandige
        #   which if conserving objects like Elvisory does,
        #     can be used to check if updates are within
        ['seeing','3',&acgtRs{
            Rs&rowish = 1;
            n Citula  $self:sc&s,R %Reis:Cit,set:Cit
        },'ift,D'],
        ['ning','3',&acgtRs{
            Rs&rowish = 1;
            s&lv = 1;
            $p = Ry&up;
            $D = pc&s;
            me&tsc,'arp','ning:'+D.t;
            
            if (D.t == 'seen') {
                # to deal sleep patterns/debug locally
                n Tool  R %Tool
                
                n visinghur  $s:1s&Te,R %ball,slan_digify
                
                if (4s&modeen) {
                    #4s&modeen = me&yfuture,4s&modeen;
                    n modeen  $s:4s&modeen,R %sun
                }
            }
            
            n Citula  $self:sc&s,R %Reis:Cit,set:Cit
            
            if (D.t == 'ajaying') {
                n vising  $self:A,R %Reis:Cit,set:Cit
                $vis = {sho:A.4};
                n visding  $gleep:vis,R %Citying
                
                $p = 4s&sleperp;
                p &&
                n pare  $self:p,R %Reis:Cit,set:Cit
                
                n visoring  $self:4s&elvisory,R %Reis:Cit,set:Cit
            }
        },'ift,D'],

    ] };
    
    #c Toolingness
    # medo for attachey/toggley %ball%fixes
    # < applying styles
    
    me.tangulate = &acgtR{
        $Te = Rs&Te;
        !Te and return
        if (Tes&Rz) {
            # just before R starts creating itself
            #  some forerbrain addons create themselves first
            $RN = Tes&z.filter(r => rc&R);
            each in RN {
                $z =
                n $n
                zs&Recipe = n;
                # anticipate becoming Real in Displayingness 27
                ny&Real = 1;
            }
            # insides get ahead
            T.Rq = {inside:R,ov:33};
            # and does Toolingness's 3%Recipe
        }
    };
    
    # prop up M, ensures a lug.c like c
    me.RMount = &acgtRc{
        $M = Rs&Mout;
        !M and throw "NoMout"
        $found = 0;
        each in M {
            # c checks n.c
            $ok = 1;
            each kv c {
                $s = n.c[k];
                s != v and ok = 0
                if (!ok) {
                    # just yfuture?
                    if (typeof v == 'object' &&
                        v.t == s.t) {
                        me&yfuture,s == v and ok = 1
                        else
                        me&yfuture,v == s and ok = 1
                        # < if cby .t are the same
                        #!ok and debugger;
                        # a slep inside a slep has some history issue
                        # keeps spawning
                        !ok and ~RMount nonmatch, same t: v.t
                        #ok = 1;
                    }
                    !ok and break
                }
            }
            !ok and continue
            found = 1;
            break
        }
        #found and ~>4 Found:
        found and return
        #~>4 Lugging:
        lug = Rs&modlug();
        # put identifying things into lug.c
        ex(lug.c,c);
        # put lug in M (permanent)
        lug =
        m $lug
        # put lug in Rc&s for %aTool etc
        Rs&Middle(lug);
    };
    # get local Tool, may search
    # < fatal
    # see 2%Tool "t'ing it out"
    me.RTool = &acgtR{
        !Rc&Tool and me.cby(R,&r{ return Rc&Tool = rc&Tool });
        $t = Rc&Tool;
        #!t and throw "NoTool"
        return Rc&Tool;
    }
    
    me.Toolingness = &acgtR{ return [
        # %Cit shows a thing
        ... me&Citingness ,
        # how %Cit etc can move around, become %doings
        ... me&Implantingness,
        # %displayon attaches Display units
        ... me&Renderingness,
        # newer diffing, for %slep_aTool
        ... me&Differingness,
        # < elvising to the local Tool to coordinate:
        #     wait for pattern
        
        # Real somewhere, made by %Recipe
        # insists on being in %Tool's M
        #   4%aTool gets %Recipe (later),
        #     also has %Remote, now Ry&up:
        ['Recipe','3',&acgtRs{
            $p = Ry&up;
            $r = Rs&Recipe;
            ry&Real != R and throw "NotRecipeReal"
            $t = me&RTool,R;
            !t and ~RecipeNoTool: p.t, '/', R.t
            !t and return
            #~>4 Recipeoutthere: p.t, '/', R.t
            # %Tool's M must have something like:
            $c = {Remote:p,Recipe:r,tool:R.t};
            me&RMount,t,c;
        },'ift,D'],
        
        
        #c Tool tray of icons to do tricks
        ['Tool','2',&acgtRs{
            Rs&rowish = 1;
            $J = A.1;
            Js&serial ||= 0;
            $M = Rs&Mout = Js&ToolMout ||= [];
            # controls for Tooling out there
            # < know dups with the scene but don't create any more
            # < generalised M-anagement
            
            # < take over Tool-ness for a locale
            # < t'ing it out, so it can become to R already departed
            me.cby(R).filter(r => rc&Tool = R);
            
            Rs&modlug = &{
                return G&Cye,['plug:'+(Js&serial++),'']
            };
            Rs&modeen = &acgtr{
                # r is not R
                $atool = r.t;
                $mode = rs&pickel || 'probe';
                # captures the next click
                T.pickel = &acgtr{
                    $lug = Rs&modlug();
                    lugc&tool = atool;
                    lugc&Remote = r;
                    lugc&Pointer = C;
                    if (mode == 'probe') {
                        # elvise probes into R
                        lugc&Recipe = me&Tein,r,'Rz',[atool,6,{R:atool}];
                        # insides should transplant to rack,
                        #  especially if they s&down already
                        #  eg Reis:Cray pushes Displays up
                        # < figure out why this sticks on/off
                        #ns&nofurtherDisplay = 1;
                    }
                    elsif (mode == 'nab') {
                        # Remote is
                    }
                    else {
                        throw "what pickel mode: "+mode
                    }
                    # bug:
                    T.wake = 1;
                    # keep together in %Tool
                    m $lug
                };
                ~picking: mode
            };
            n t  $s:R.t %hs:789
            n slep  s:● %fs:22,medo:modeen
            n sunn  s:● %fs:22,medo:modeen,inv
            n nab  s:∝ %fs:22,medo:modeen,inv:0.7,pickel:nab
            n testruns  s:⊧ %fs:22,medo:modeen,inv:0.5
            
            Rs&Middle = &n{
                !n.t and debugger;
                $z = me&Ret,R,{t:n.t,s:n,aTool:1,refpool:1};
                # < Ring/ing clarify particle onramp
                me&zN,z;
                #n $n.t  $s:n,R %aTool,refpool
                # < sort out that CyC leads sourceward,
                #   CyO where it went? or D?
                #  we have z.y.R = R created by z
                # %aTool%boost<-1 removes it
                zs&remova = &{
                    each im M {
                        m != n and continue
                        M.splice(i,1);
                        break
                    }
                    # and any elvising configuring it
                    i Ry&up.sc.Te/-Rs&Te
                    # through the doming?
                    z = zy&R;
                    # %aTool packdown/deprobe
                    zs&alsoremova and zs&alsoremova();
                };
            };
            each in M {
                Rs&Middle(n);
            }
            #n stop  s:■
            #n redo  s:◀
            # wander?
            n play  s:▶ %fs:22
        },'ift,D'],
        #c aTool
        ['aTool','4',&acgtRs{
            Rs&rowish = 1;
            # looks elvisy
            # Rc&s is $lug in Tool%M
            # < pool names children can use as the things
            # < yfuture to currently awake R... a Tool is usu nearby
            # < yfuture breakdown + refind by sc&Pointer,
            #     a click elvis we can relookfor
            $r = Rs&Remote = sc&Remote = me&yfuture,sc&Remote;
            me&tsc,'tool',sc&tool,'q' .sc.bg = '#000';
            me&tsc,'Remote',r.t,'G';
            if (sc&Recipe) {
                $n = Rs&Recipe = sc&Recipe;
                # Recipe already y&Real,
                #  so is rs&Te - another way to find future?
                ny&Real ||= 1;
                ny&Real && isC(ny&Real) and Rs&Real = ny&Real
                # remove Recipe from Remote
                Rs&alsoremova = &{
                    $Te = rs&Te;
                    i $Te/-Rs&Recipe
                };
            }
            
            (Rs&boost||0) < -1 and Rs&remova()
            # closed but not disabled
            (Rs&boost||0) < 0 and return
            # open
            
            # BUG: just %Cit doesn't work:
            #   and this, if deleted, sticks on the screen
            n Remote  $self:r,R %Reis:Cit,set:Cit
            
            # %slep_aTool out there
            # when ready if Recipe
            if (!Rs&Recipe || Rs&Real) {
                $k = sc&tool+'_aTool';
                n Perspect  $R:k
            }
            
            if (Rs&Recipe) {
                $z =
                n Recipe  $s:Rs&Recipe,R %ball
                # < Ring that can return ^ yReal already,
                #   though the %yRealism bit is D<6
                
                # < M-anagement, its lifecycle of crud
                # < io.i futurism, putting/syncing to many places
                # hooked by %ball%boost<-1:
                zs&remova = &{
                    # remove %aTool from Tool%M
                    Rs&remova();
                };
            }
            
            Rs&Real &&
                n Real  $s:Rs&Real,R %Realism
        },'ift,D'],
        
        # the yReal diveinto
        ['Realism','3',&acgtRs{
            !isC(s) and return me&tsc,'yReal','..',6
            Rs&rowish = 1;
            me&tsc,'yReal','Real','q';
            n its  $self:s,R %Reis:Cit,set:Cit
            n show  $self:s,R %displayon
        },'ift,D'],
        
        # < G&c/T'ing messages to a debug channel
        # inject R-ing to the 
        ['Telife','35',&acgtRs{
            #$disr = me&Reis,R,'Cray',re;
            #me&Reis,R,'Cray',Rs&down;
        },'ift,D'],
        
        #c Tools
        
        # see data out there
        # can be Recipe'd into place,
        # < Ring-transcending timing options
        ['sunn','69',&acgtRs{
            me&tsc,'sunno','sunn','q' .sc.bg = '#000';
            Rs&nofurtherDisplay = 1;
            # < ensure this Display gets somewhere
            me&Reis,R,'Cray',Ry&up,{refpool:1}
        },'ift,D'],
        
        # < put somewhere else:
        # Reis: completes an R:$Reis
        #  in an R, funneling its Display
        # always gives a new refpool,
        #  and first rs&self from Rs&self
        # Reis=Cit% does R:Cit %Cit
        # Reis=Cit%la does R:Cit %la
        ['Reis','3',&acgtRs{
            $c = {refpool:1,self:Rs&self};
            $k = Rs&Reis.split('%');
            c.task = k[0];
            k[1] != null and Rs&set = k[1] || k[0];
            Rs&set and c[Rs&set] = 1;
            # Rs&TeImplant is observed from below:
            c.rec = ex({},c);
            Rs&ReisR = me&Reis,R,R.t,null,c;
        },'ift,D'],
        
        
        #c nab_aTool
        ['nab_aTool','3',&acgtRs{
            $p = Ry&up;
            Rs&Remote = ps&Remote;
            !Rs&Remote and debugger;
            $s = pc&s;
            Rs&modeen = &acgtr{
                # r could be in a %run/%step or in W
                $template = r.t;
                if (rs&Hostup) {
                    $re = Rs&Remote;
                    !re and debugger;
                    sc&Host = rey&up;
                    sc&As = template;
                    return
                }
                # captures the next click
                T.pickel = &acgtr{
                    !ry&R == r and throw "pick an R"
                    sc&Host = r;
                    sc&As = template;
                    ~Pluycks
                };
            };
            # < re-find Host and Remote by path,
            #  < Remote = latest %step%ok
            #   < continuous push Te/edges->latest PuTe
            # < and copying the latest %step%ok,
            #   to keep %H so diff is of changes
            # < porting these to io knowing A%ball/C first-ish
            $mez = {
                forballs: &acgtR{
                    if (!Rs&ball) {
                        # to origin
                        Rs&push and R = Rs&here
                        else
                        Rs&exp and R = Rs&exp
                        
                        Rs&Ropy and R = Rs&Ropy
                    }
                    !Rs&ball and throw "No a ball: "+R.t
                    return Rc&s
                },
                link: &acgtR{
                    $h = mez&forballs,Rs&Host;
                    $r = mez&forballs,Rs&Remote;
                    i $h/$r
                    return r
                },
                move: &acgtR{
                    $r = mez&forballs,Rs&Remote;
                    $re = Rs&Remote;
                    re = mez&forballs,rey&up;
                    i $re/-$r
                    $r = mez&link,R;
                },
                clone: &acgtRc{
                    c ||= {};
                    $h = mez&forballs,Rs&Host;
                    $r = mez&forballs,Rs&Remote;
                    $s = me&Copy,R,r,12 .c.s;
                    c.aftCopy and c.aftCopy(s)
                    i $h/$s
                    return s
                },
                step: &acgtR{
                    # has set Host = Remotey&up %step
                    $c = {aftCopy:&s{
                        # rename/number increment before io.i (tv)
                        $title = s.t.split('_');
                        $n = isnum(title.slice(-1)[0]) && title.pop() || 0;
                        n++;
                        title.push(n);
                        s.t = title.join('_');
                    }};
                    mez&clone,R,c;
                },
            };
            # < ensure this Display gets somewhere
            if (sc&Host) {
                $reselect = me&rollbs,R,'Host' != sc&Host && Rs&Host;
                Rs&Host = sc&Host = me&yfuture,sc&Host;
                n Host  $self:Rs&Host,R %Reis:Cit%
                
                if (sc&As) {
                    Rs&As = sc&As;
                    $t = Rs&As+':';
                    $k = 'nab_'+Rs&As;
                    $mo =
                    n $Rs&As  $s:t %fs:11,medo:modeen
                    if (mez[Rs&As]) {
                        # some kinda...
                        me&rollbs,R,'done' and return me&tsc,"Done"
                        mez[Rs&As](A,C,G,T,R);
                        Rs&done = 1;
                    }
                    else {
                        # makes an R%nab_$As,
                        #  probably making an %$As:
                        moc&s = '%'+moc&s;
                        $tem =
                        n $Rs&As  R:1
                        tem.sc[k] = 1
                        reselect and tems&reselect = 1
                        reselect and me&tsc,'reselect',null,'g'
                    }
                }
            }
            else {
                # add/update %testrun %step W:PuTe%doing
                n PuTe  s:%PuTe? %fs:11,medo:modeen
                # copy somewhere
                n link  s:link %fs:9,ma:1,medo:modeen
                n move  s:move %fs:9,ma:1,medo:modeen
                n clone  s:clone %fs:9,ma:1,medo:modeen
                # not picking, set Host = Remotey&up
                n step  s:step %fs:9,ma:1,medo:modeen,Hostup
            }
        },'ift,D'],
        #c nab_PuTe
        ['nab_PuTe','5',&acgtRs{
            $n = Ry&up; # %nab_aTool
            $p = ny&up; # %aTool
            $s = pc&s; # Tool%M lug
            s&fs = 12;
            
            # find a step to put this in
            #   up to %run/%step/%doing
            #     or %ball(%testrun/(%step))
            # < new steps if %run
            # happens continuously,
            #  will chaos if for one of many City run through
            $S;
            $N = me.cby(sc&Host,&r{
                $p = ry&up;
                !p and return
                $s = pc&s;
                if (rs&doing || rs&step || rs&run ||
                    ps&ball && rs&ball && ss&testrun) {
                    return S = r
                }
            });
            $puts = &ts{
                n $t  $self:s,R %Reis:Cit%
            };
            if (!S) {
                return puts('StepNotFound',N)
            }
            if (!Ss&ball) {
                if (Ss&run) {
                    throw "new step %run?";
                    # S = make-new-step, as %push does
                    # then DoingFor = its doing (%ball)
                }
                if (Ss&doing) {
                    # PuTe before a doing
                    if (!Ss&exp) {
                        return puts('DoingNoExp',S)
                        #and throw "doingnoexp"
                    }
                    sc&DoingFor = S;
                    S = Sy&up;
                    !Ss&step and throw "!Step"
                }
                if (Ss&step) {
                    # PuTe before step's doings
                    !Ss&exp and throw "stepnoexp"
                    S = Ss&exp;
                }
                else {
                    throw "Nonball/step"
                }
            }
            # < ^ should be a few lines max
            !Ss&ball and throw "Not at ball"
            $D = sc&DoingFor;
            # locate the %doing in W/...
            $before;
            if (D) {
                $g = Ds&got;
                !g and me&tsc,"DoingFor!got",null,'6'
                $x = Ds&exp;
                !x and throw "DoingFor!exp"
                if (x.t == 'City') {
                    # forget nabbed thing?
                    #   update City/(*) got->exp
                    $z = gc&s;
                    $zTe = zy&zTe;
                    !zTe and return me&tsc,'?'
                    $Te = me&Copy,R,zTe,18 .c.s;
                    # < stream, differ?
                    !xs&ball and throw "x!ball"
                    # that is the one after TeCo,
                    #  goes directly to W/.../$exp s:
                    x = xs&Copy;
                    !x and throw "no prior"
                    !xs&z and throw "unz"
                    i $x/-#$Te
                    i $x/$Te
                    while (xs&z.length > 10) {
                        xs&z.shift();
                    }
                    n zTe_updating  $self:x,R %Reis:Cit%
                    return
                }
                $xo = xs&Ropy;
                if (!xo) {
                    n ExpNoRopy  $self:x,R %Reis:Cit%
                    return
                }
                !xo and throw "DoingFor exp !Ropy"
                !xos&ball and throw "Doing exp Ropy !ball";
                before = xoc&s;
                
                # might be !ball?
                n DoingFor  $self:D,R %Reis:Cit%
            }
            #c and the %step in W/...
            $st = Ss&Ropy;
            !st and throw "Step !Ropy"
            $step = stc&s;
            !step and throw "Step Ropy !C"
            # < looking at stc&ss&z (C) in sts&z (R)
            #   io handling A/C
            n Step  $self:S,R %Reis:Cit%
            
            $P = me&rollbs,R,'PuTe';
            P &&
            n PuTe  $self:P,R %Reis:Cit%
            before &&
            n before  $self:before,R %Reis:Cit%
            
            if (Rs&reselect) {
                P = null;
                
            }
            P && (Rs&boost||0) < 1 and return me&tsc,'stop','stop','g' .y.cv=0.7
            
            # wants a PuTe%doing:
            $P = Rs&PuTe = G&Cye,['PuTe',1];
            $r = me&Copy,R,sc&Remote,18 .c.s;
            # by ^ we have X for a bunch of new stuff
            i $P/$r
            # then $P into the test data:
            
            # PuTe%doing maybe already there
            $already;
            # or to be spliced into where %doing is (in W/.../%stepc&ss&z)
            $xi;
            if (before) {
                # ^ the W/.../%doingc&s for a %doing we clicked
                # put PuTe before this %doing
                xi = steps&z.indexOf(before);
                if (xi < 0) {
                    # try harder, resolve by name instead
                    o $step/#$before
                    before = ays&before[0];
                    !before and debugger
                    xi = steps&z.indexOf(before);
                }
                xi < 0 and debugger;
                # throw "No such doing in step"
                $xa = steps&z[xi-1];
                # update self:
                before.t == 'PuTe' and already = before
                else
                # update self, clicked %doing after it
                xa && xa.t == 'PuTe' and already = xa
            }
            else {
                # beginning of %step
                xi = 0;
                $xa = steps&z && steps&z[xi];
                xa && xa.t == 'PuTe' and already = xa; xo = null
            }
            if (already) {
                # see io z dupe bug in displayon
                i $step/-#$already
                i $step/$P
            }
            else {
                i $step/-#$P
                i $step/$P
            }
            
            if (xi != null) {
                $inow = steps&z.indexOf(P);
                inow < 0 and throw "fail"
                if (inow != xi) {
                    steps&z.splice(inow,1);
                    steps&z.splice(xi,0,P);
                }
            }
            # etc and just noticed:
            # BUG via testruns stops acceptance applying...
        },'ift,D'],
        
        
        #c testruns
        ['testruns','6',&acgtRs{
            $p = Ry&up;
            !ps&ball and throw "for %ball"
            $M = [];
            # find any %testrun in a few layers of %ball
            $lookfortestruns = &pd{
                d ||= 0;
                d++;
                d > 3 and return
                $N = me&ioty,p,'%ball';
                each in N {
                    $s = nc&s;
                    ss&testrun ? M.push(n)
                        : lookfortestruns(n,d)
                }
            };
            lookfortestruns(p);
            =pod
            o play %pushes
            o T%ball receives %moves
            o W:Co
            o T%ball again,
               for some %step/%doings
                 which each have been waiting since play %pushes
               which causes more %moves, goto 20
            
            asyncily without any async,
            unless something !ok, then stops.
            
            BUT THEN,
             it looks like all the %plays simultaneously works ok
            and besides, its complicated and subject to change.
            averted by tes&almost, all this other complicated stuff.
              wants T itself and really good visual A debugger.
            how clearly that thing could unfold in a namepond...
            
            =cut
            Rs&rowish = 1;
            me&tsc,'testruns';
            me&tsc,'count',M.length,'g';
            each in M {
                n n.t  $s:n.t %ma:0.5,fs:8
            }
            (Rs&boost||0) < 1 and return me&tsc,'dotestruns','?','G'
            delete Rs&Te.sc.boost;
            
            $current;
            $began = G&time;
            # %play them all (but dont start %moving (if almost))
            # collect %pushes 
            $P = [];
            $start_testruns = &{
                each in M {
                    $te = me&introqua,n,{};
                    # on and off?
                    tes&play and delete tes&play; delete tes&almost;
                    else {
                        tes&play = 1;
                        #tes&almost = 1
                    }
                    # collect the 8%push
                    $cb = tey&pushable_cb = &r{ P[i] = r }
                }
                # last one, callback with %moves made?
                tey&pushable_cb = &{
                    cb();
                    ~starts: R.t
                    next_testrun();
                };
            };
            # ^ async v
            # per %push, do out of time
            $next_testrun = &{
                current == null and current = 0
                else { current++ }
                $n = M[current];
                !n and return done_testing();
                # hijack the %push
                
                #ls&boost = 2;
                #me&Ring,l,{und:l};
                #me&Reis,R,'ravel',nc&s
                
            };
            $done_testing = &{
                Rs&testcomplete = G&time,$began;
                ~Done testing:
            }
            start_testruns();
        },'ift,D'],
        
    ]};
    
    #c Slepingness roadies
    #   once tests...
    me.Slepingness = &acgtR{ return [
        # hilight changing %balls if they yslandige
        # change style stays on once sleeping,
        #   time-limited styles?
        #   < style til new time for a frame but no frame
        ['ball','35',&acgtRs{
            !sy&slandige and return
            Ry&slandige = sy&slandige;
            $b = Rc&b;
            b && Ry&slandige == by&slandige and return
            # < on the title
            each tin Rs&Mw {
                n.t == 't' and ns&bri = 4
            }}
        },'ift,D'],
        
        # Slep, a Tool for checking sameness of a Dome/anything
        # scan happens early and late:
        #   late first, Long/** is awake, scan boosted around Rthings
        #   early thence, scan boosted (%Rthing'd) from before
        # Display 27 gets tangulate:
        #   they Ring ov=33 (ahead of slepy&up)
        # TheirSleepStrategy 28 gets this intel
        ['slep','3',&acgtRs{
            s&fs = 14;
            s&bo = '1px dotted green';
            me&tsc,'slep-ing','slep','6';
            # the top of the constellation of R with c&s
            $p = Ry&up;
            ps&slan_digify and Rs&digify = 1
            ps&beawake and Rs&beawake = 'p'
            # early should always receive history from late
            $b = Rc&b;
            !b and return me&tsc,'isnew','*','g'
            
            $re = me&slan,R,p,{early:1};
            # < it reusing this scan for whatever its doing
            Rs&slan = ps&slan = re;
            
            !rec&b and throw "slep Nohist early"
            
            # can be asked to display more, if you displayon for it
            # < clearer apis, 1s&ein-like
            # < express as 'dark cramped machine room,
            #   remote view scheme interestoids'
            Rs&nofurtherDisplay = 1;
            Rs&enlum ||= 0;
            me&Tie,R,'enlum' &&
                me&Reis,R,'Cray',re;
            
            if (res&sleepable && !Rs&beawake) {
                ps&sleeping = re;
                Rs&theysleep = 1;
                # keeps history/z of unhad children
                me&recycleRbitXz,R;
                # R:Display knows Rs&sleeping
                # implement a %sleeping%whatever to etc
            }
            
            (Rs&boost||0) < 1 and return
            me&tsc,'landscape',res&landscape,'6' .sc.dis = 1;
        },'ift,D'],
        
        # implement a %sleeping%whatever
        # ! must .t =~ /^sleeping/
        #     Ring avoids everything if Rs&sleeping
        # thing-specific reasoning/management
        # but mostly the %slep and things involved know/do all else:
        #   keeps history/z of unhad children
        #   R:Display knows Rs&sleeping
        ['sleeping+Cee','28',&acgtRs{
            $l = Rs&sleeping;
            $b = Rc&b;
            # Display - avoids Rs&sleeping
            #   must put its bs&on y&up
        },'ift,D'],
        ['sleeping+ball','28',&acgtRs{
            me&rollbs,R,'string,dige';
            # + make me.sch_didLines accept %sleeping !%Lines
            me&recycleRbitXz,R;
        },'ift,D'],
        
        ['slep','89',&acgtRs{
            Rs&theysleep and return
            $p = Ry&up;
            #~>3 Lately: p.t
            # leave one slep/slan, early trusts late's map
            Rs&slan and me&deleteRbitX,Rs&slan;
            
            $r = me&slan,R,p;
            Rs&slan = ps&slan = r
            #rc&b and ~hist late:
            rs&late = 1;
            
            (Rs&boost||0) < 1 and return
            me&tsc,'landscape',rs&landscape,'6' .sc.dis = 1;
            (Rs&boost||0) < 2 and return
            n slepe  $self:r,R %Reis:Cit,set:Cit
            n pare  $self:p,R %Reis:Cit,set:Cit
        },'ift,D'],
        
        #c slep_aTool configures a %slep in %aTool
        # < to show the slep in progress,
        #   must sit outside the %sleeping, or have its Display adopted
        # ᛍ c - sleeping
        # ᛟ othalan ethel o - awake
        # ᛤ cealc - dige
        # ᛄ ger - diff
        # ᛜ ingwaz - differ
        ['slep_aTool','3',&acgtRs{
            s&ma = 0.2;
            s&fs = 17;
            $p = Ry&up;
            $P = ps&Recipe;
            $r = ps&Real;
            $D = rs&slan;
            !D && Rs&paniq < 100 and Rs&paniq = (Rs&paniq||0)+1; return T.wide = 1;
            $s = pc&s;
            
            $they = rs&theysleep ? "ᛍ" : "ᛟ";
            me&tsc,'theysleep',they;
            me&tsc,'configure',"☞",'G';
            
            (Rs&boost||0) < 1 and return
            
            # various adjustables
            # wiring Time-things onto the Real or the On,
            #  for it has already begun,
            #   elvising must get any tampering to it prior
            # Recipe can be edited simply, it is a %ball
            #   mention modes we can attach,
            #   then once having %ball/%fix, embed knobs
            #     enriching the soil
            
            n beawake  s:ᛟ %medo:modeen
            n digify  s:ᛤ %medo:modeen
            n differ  s:ᛄ %medo:modeen,to:Te
            Rs&modeen = &acgtr{
                $mode = r.t;
                $to = rs&to == 'Te' ? Rs&Te : P;
                $v = to.sc[mode] = to.sc[mode] ? 0 : 1;
                ~modeen: mode+" = "+v
            };
            if (Rs&Te.sc.differ) {
                # BUG first time (test edges 2.2) 
                !D and return me&tsc,'noD(slan)?',"!D",'B'
                n differ  $s:D %R:differ,refpool
            }
            
        },'ift,D'],
    ] };
    
    #c slan
    # R-ing that maps/checks the data underlying Ring
    # straighter and sprawlier than a %scan,
    #  which it should eventually replace?
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        delete rc&refs;
        delete rc&inC;
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&arriveRbitX,R,R.t;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&goneRbitX,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        me&applyRbitX,r;
        return r
    };
    # there are two slep/scans
    # sharing history (deleteRbitX the early)
    me.slan = &acgtRpc{
        $the = me&Timethe,'slan';
        c ||= {};
        $oR = R;
        $firstRthing = p;
        $ot = p.t;
        $uptil = &Rkd{
            # < me.cbu having a boundary & return array
            $N = me.cby(R,&s{ return s == firstRthing 
                || typeof k == 'object' ? s == k : s.sc[k]
            });
            d and return N
            return N.length
        };
        
        # you can ignore a y.*
        ps&slan_igy and c.igy = ps&slan_igy
        # or put + ignore dige of the thing in the thing
        # < param this on the slep tool
        $digify = Rs&digify;
        digify == '1' and digify = 'slandige'
        digify and c.igy = c.digeity = digify
        
        
        $h;
        $r = Ron(R,'slan',pc&s,0,&Rs{
            if (Rc&d == 0) {
                h = R;
                $b = Rc&b;
                if (c.early) {
                    hs&early = 1;
                    !b and throw "early no hist"
                    # early one inherits %late
                    if (bs&late) {
                        #!bs&early and ~late->early: ot
                        Rs&late = bs&late;
                        Rs&earlied = 1;
                        #~early & late: ot
                    }
                    else {
                        ~Early not substracting late history: ot
                    }
                }
                else {
                    # TEST as if deleteRbitX didn't work?
                    #   when sleep interrupted
                    b && bs&early and ~late b%early:
                }
                Rs&Rthing = firstRthing;
                
                Rc&dl = 144;
                Rc&nl = 2211;
                delete Rc&dupl;
            }
            Rc&N.push(R);
            # < within the slan'ing, as uptil()
            $p = Ry&up;
            $pp = py&up;
            #c 2 know 1
            if (typeof s == 'object' && s != null) {
                if (s.constructor == Array) {
                    Rs&sym = '[';
                }
                elsif (isC(s)) {
                    Rs&Cthing = s.t || 1;
                    Rs&sym = 'C';
                    if (s.y == s) {
                        Rs&Athing = 1;
                        Rs&sym = 'A';
                        s.1 == s and Rs&sym = 'J';
                    }
                    else
                    s.y.R && s.y.R == s and Rs&sym = 'R';
                }
                else {
                    Rs&sym = '{';
                    if (R.t == 'y' && ps&Cthing) {
                        Rc&shrinky = 1;
                    }
                }
            }
            else {
                # 3 at a value
                Rs&text = typeof s == 'number' ? ''+s
                    : typeof s == 'string' ? '"'+s
                    : ki(s);
                $into = Rs&text.split("\n");
                if (into.length > 1) {
                    Rs&text = '"'+into[0]+'..dige:'+dig(Rs&text)
                }
                return
            }
            if (c.early) {
                # once early, %Rthing-ness comes from history
                #   vis. the same position of names
                # there are no origin Rs beyond first
                # download them from history
                !Rs&Rthing and me&rollbs,R,'Rthing'
            }
            # 4 or a thing we can feel out way to
            $N = uptil(R,'Rthing',1);
            $Rthingu = N[0];
            !Rthingu and throw "start on Rthing"
            if ('always detect Rthing') {
                # detect c&s in the last Rthing's pool
                # %Rthings are the origin R, have c&s we bump into
                # may happen even if c.early or theysleep
                $or = Rthingus&Rthing;
                !or and debugger;
                # < R=A, A.pool.c.N is the bunch,
                # < venn diagram to A.**.pool
                $ri = orc&refs.indexOf(s);
                if (ri >= 0) {
                    # the R;origins with this c&s
                    $refR = orc&refR[ri];
                    # < R=A, will have c&ip some day
                    each ir refR {
                        # look up til the last Rthing
                        #   or until firstRthing
                        # all R;origin
                        $got = uptil(R,Rthingu,1);
                        got[0] == Rthingu and break
                        # may not encounter either
                        r = null
                    }
                    if (r) {
                        Rs&Rthing = r;
                    }
                }
                # see hs&Rthings ^
                # < make pile of R:slan before the next %Rthing
            }
            # connect to upwardia
            if (Rs&Rthing) {
                $Rdist = 1;
                
                hs&Rthingi ||= 0;
                hs&Rthingi++;
                # < dup would be interesting
                ac(h,'Rthings',R);
                # these all R:slan
                ac(Rthingu,'Rjoins',R);
                # < then Rc&Rthing = R and calc depth?
            }
            else {
                $Rdist = N.length+1;
            }
            
            
            #c 5 size
            # near a data fog valve
            Rs&plain ||= '';
            #Rs&plain += "RD:"+Rdist
            # apply a schema,
            # to decide whether to 6
            
            # shouldn't be looking at R
            # < complain eloquently
            !Rs&ltd && Rs&sym == 'R' and Rs&ltd = '>R'
            !Rs&ltd && pps&sym == 'R' and Rs&ltd = '>R**'
            
            
            # share refs
            $rl = Rs&refR;
            if (!Rs&ltd && rl) {
                $l = rl[0];
                Rs&plain = 'dup:'+me&nampup,l,R;
                # other side was limited, try express it here
                if (!Rs&ltd) {
                    if (ls&ltd) {
                        # do here instead
                        delete Rc&nofurther;
                        # be the main instance
                        Rs&refR.reverse();
                    }
                    else {
                        Rs&ltd = '<'
                    }
                }
            }
            
            # unless very near R
            if (!Rs&ltd && Rdist > 2) {
                # don't A.I
                ps&Athing && Rs&sym == '{' && R.t == 'I' and Rs&ltd = '>I'
            }
            if (!Rs&ltd && Rs&sym == '{') {
                # dom elements
                # < any .constructor.name != 'Object'
                if (s instanceof Element) {
                    Rs&ltd = '>'+(s.constructor.name||'Element')
                    Rs&sym = '<>';
                }
            }
            if (!Rs&ltd && Rdist > 3) {
                # one layer after A or y/%Cthing
                ps&Athing and Rs&ltd = '>A'
                else
                ps&Cthing && Rc&shrinky && pc&shrinky and Rs&ltd = 'y>'
            }
            
            # or farouts
            if (!Rs&ltd && (Rdist > 4 ||
                Rdist > 3 && uptil(R,'Cthing') > 3)) {
                Rs&ltd = '>';
            }
            # if limited, describe the edge of the pile
            if (Rs&ltd) {
                if (Rs&Cthing) {
                    Rs&text = ':'+s.t;
                }
                elsif (Rs&sym == '{') {
                    $ks = haks(s);
                    $limit = 50;
                    Rs&text = ks.length > limit+5 ?
                        ks.slice(0,limit-1).join(',')+'..'+ks.length
                    : ks.join(',');
                }
                elsif (Rs&sym == '[') {
                    Rs&text = 'x'+s.length
                }
                return
            }
            
            # 6 more values
            $l = haks(s);
            each ik l {
                $v = s [k];
                if (c.igy && ps&Cthing && R.t == 'y') {
                    # wants to ignore s.y.dige in/for Elvis %balls
                    c.igy.indexOf(k) >= 0 and continue
                }
                me&Ret,R,{t:k,s:v}
            }
        });
        
        #c select moving parts
        $M = [];
        $seen = [];
        # in z order
        $gump = &R{
            Rc&N.indexOf(R) < 0 and return Rs&landscape = "NOTIN: "+R.t
            seen.indexOf(R) >= 0 and throw "gumpR seen"
            seen.push(R);
            
            $se = R.t+" "+(Rs&sym||'');
            # text == firstline + dig if \n
            Rs&text != null and se += ''+Rs&text
            Rs&plain != null and se += ' '+Rs&plain
            Rs&ltd and se += ' '+Rs&ltd
            
            $rt = Rs&Rthing;
            if (rt) {
                # anything else from the Rthing
                se += ' %R ';
                if (rty&Te_slandige) {
                    # R receives Tey&slandige
                    se += "Te_slandige:"+rty&Te_slandige
                }
            }
            
            Rs&landscape = 
            Rs&portrait = se;
            
            # < allpathy: what was/wasnt different and how
            each in Rs&z {
                gump(n);
                
                $is = (ns&landscape||"NOTHING:"+n.t);
                $at = is.split("\n")
                    .map(&s{ return "  "+s })
                    .join("\n");
                Rs&landscape += "\n"+at;
                
            }
            if (c.digeity && Rs&Rthing && Rs&Cthing) {
                # put + ignore dige of the landscape in s
                # < as a post-hook to io.i
                $s = Rc&s;
                Rs&dige = s.y [c.digeity] = dig(Rs&landscape)
            }
            
            $b = Rc&b;
            if (b && Rs&Rthing) {
                if (bs&landscape != Rs&landscape) {
                    M.unshift(R);
                }
                else {
                    Rs&sleepable = 1
                }
            }
        };
        gump(r);
        
        # for the origin (%slander?)
        rs&moving = M;
        rs&talk = rs&landscape.split("\n");
        rs&dige ||= dig(rs&landscape);
        # check dl/nl
        me&safer,r;
        the();
        return r;
    };
    
    
    
    #c DisplayTwo-RbitX
    =pod
    
    Receive the past (V) and make a now (X)
    
    # X is the space index...
    #  of X.x.$bit = X (inwards)
    #     X.z = [ R nodes
    simply inherited, moved into, children made with
    cX/V is carelessly inherited
    each R goes inside each
     toplevel R=I, r=C, makes IcX
    
      Re gives children:
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
      
    =cut
    
    me.RbitXingness = &acgt{ return [
        ['RbitX','17',&acgtRs{ me&arriveRbitX,R,R.t },'if:RcX'],
        ['RbitX','4',&acgtRs{  me&goneRbitX,R },'if:h'],
        ['RbitX','91',&acgtRs{ me&applyRbitX,R },'if:h'],
    ] };
    # the named self resolves in 17:
    me.arriveRbitX = &acgtR,bit{
        # X goes inside
        #  RcX = Rs&X = {} at Resurrect
        #   Re inherits us RcX and RcV,
        #    we simply move into the name we are
        $X = Rc&X ||= {};
        # < X.up more conducive to simple transplants
        X.top ||= {};
        X.x ||= {};
        X = Rc&X = X.x[bit] ||= {top:X.top};
        X.x ||= {};
        X.z ||= [];
        X.z.length and 'dups allowed'
        $i = X.z.push(R);
        # me&Re gives children X from this point
        Rs&X = X;
        # < the simple inheritance isn't simply implemented

        # someone gave you V that used to be X
        # but let's depend on X.z being as it was, not X.x
        #  to make history easier to forge
        $V = Rc&V && Rc&V.x && Rc&V.x[bit] || {};
        # X (new) must hold which V (old) z we're up to
        $b;
        if (V && V.z && V.z[i-1]) {
            b = V.z[i-1];
            # V is an X becoming the past
            bc&X != V and throw "bcX != V"
            # let yfuture find b->R if not commit
            # not for anything else
            V.newz ||= [];
            V.newz[i-1] = R;
        }
        # care to leave history
        # = V ? me&RbitXtend,V : {};
        Rc&V = V;
        if (b) {
            Rc&b = b;
            # no further back
            bc&b and bc&b;
        }
    };
    
    # and is supposed to be completed by 4
    # < by the time it is 4?
    # < decide moves by new/gone pairs with similar appearance
    #   the thing producing changes may be willing to help
    me.goneRbitX = &acgtR{
        R != Rc&N[0] and throw "!head"
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;

            $V = Rc&V;
            $X = Rc&X;
            if (V) {
                each kv V.x {
                    $x = X.x[k];
                    # @93, R:Display, not around yet
                    k == 'Display' and continue
                    if (!x || x.z.length < v.z.length) {
                        # < filter to goners yup==Rc&b
                        Rs&gone ||= [];
                        Rs&gone.push(... v.z.slice(x ? x.z.length : 0));
                    }
                }
            }
            Rs&gone and me&chR,R,'Goners:'+(Rs&gone.length)
            !b and me&chR,R,'new!'
        }
    };
    # commits the wiring of past to future at 91
    #  almost at the same time osc/I will
    # before Display
    me.applyRbitX = &acgtR{
        R != Rc&N[0] and throw "!head"
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            !b and continue
            # check this is still our history?
            # eg. the second slep/slan takes over X.newz
            #   after a deleteRbitX reduces X.z
            #Rc&V.newz.indexOf(R) >= 0 and continue
            by&future = R;
            # no further back
            !bc&b and continue
            b = bc&b;
            delete bc&b;
        }
    };
    #c RbitX etc
    # keeps history of unhad children
    #  and adds them to Rs&z
    # used by Display too, shouldn't need to...
    #   needs that X.x ||= {}
    me.recycleRbitXz = &acgtR{
        $b = Rc&b;
        !b and throw "recycle !hist"
        $ig = [];
        each bit,oV bc&X.x {
            # no support for dupes, which share an X
            # would take merging the new over the old or so,
            Rc&X.x && Rc&X.x[bit] and continue
            Rc&X.x ||= {};
            Rc&X.x[bit] = oV;
            ig.push(... oV.z);
        }
        # and links to their last selves
        # < io may notice the z !tv
        #   me&ioty just looks at z
        each in bs&z {
            ig.indexOf(n) >= 0 and continue
            Rs&z.push(n);
        }
    };
    # remove thing from its present history
    # causing dup identities to crosswire, an interesting area...
    #  so the early slep/scan inherits the later
    me.deleteRbitX = &acgtr{
        $R = ry&up;
        $X = Ry&up.c.X;
        each bit,oX Rc&X.x {
            oX == rc&X and delete Rc&X.x[bit]; break
            # also no support for dupes, which share an X
            #  would be a deep search for $R/**
            #   splicing out of X.z
        }
    };
    

    
    #c DisplayTwo
    # makes each R clickable
    # and R0 me&Displays:
    #   foam of the atoms (R+C) + modulat (C)
    #   gets put in html
    #   < without jquery
    #   < without the element.A leading back,
    #     just path by attr on the elements
    me.DisplayTwoness = &acgt{ return [
        ... me&RbitXingness ,
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            # GOING
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 888;
            Rc&dl ||= 35;
        }],
        ['Displayingness','27',&acgtRs{
            Rs&elvis = 'Gazel';
            if (Rs&Recipe) {
                # the tangulate this R is from
                $n = Rs&Recipe;
                # tracks latest R on the recipe
                ny&Real and ny&Real = R
            }
            !1s&Te and return;
            $Te = me&Tie,R;
            !Te and return
            # tracks latest R for this Te
            # see also ElvisingRealness
            Tey&Real = R
            # elvising's version stamped on R
            Tey&slandige and Ry&Te_slandige = Tey&slandige
            # meanings
            me&playstulate,R;
            me&boostulate,R;
            me&tangulate,R;
        },'D'],
        # data dump R%sun
        ['sun','3',&acgtRs{
            $c = {task:'Cray'};
            Rs&sun == 2 and c.refpool = 1
            Rs&dupup and c.dupup = 1
            me&Reis,R,R.t,null,c;
        },'ift'],
        
        ['Displayingness','93',&acgtRs{
            Rs&noDisplay and return
            $the = me&Timethe,'Display';
            $d = me&Display,R;
            the();
        },'if:h'],
    ] };
    #c Displayingness GOING
    me.Displayingness = &acgt{ return [
        ['RbitX','17',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:h'],
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            # GOING
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 888;
            Rc&dl ||= 35;
        }],
        ['Displayingness','3',&acgtRs{
            Rs&elvis = 'Gazel';
            !1s&Te and return;
            # ^ is somewherish. posits and deposits.
            me&playstulate,R;
            me&boostulate,R;
            Rs&Te && Rs&Te.c &&
            me&tangulate,R;
        },'D'],
        # data dump R%sun
        ['sun','3',&acgtRs{
            $c = {task:'Cray'};
            Rs&sun == 2 and c.refpool = 1
            Rs&dupup and c.dupup = 1
            me&Reis,R,R.t,s||Rs&self,c;
        },'ift'],
        
        ['Displayingness','9',&acgtRs{
            Rs&noDisplay and return
            $the = me&Timethe,'Display';
            $d = me&Display,R;
            the();
        },'if:h'],
    ] };
    # 1s&Te/Rs&Te carry centralised namewires from Elvising
    # so set value can be reintroduced
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        1s&Te and me&Tie,R,'boost';
        !Rs&boost and return
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : '↯';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
            z.t += hu;
            i++;
        }
    };
    me.playstulate = &acgtR{
        1s&Te and me&Tie,R,'play'
        !Rs&play and return
        n playing  s:▶
        # look up what to do
        $N = me.cby(R).reverse();
        each ir N {
            $p = rs&playsheet;
            !p and continue
            each kc p {
                !R.sc[k] and continue
                c(A,C,G,T,R);
                return
            }
        }
        n noplaysheetupwards  s:(buthow?) %fs:6
    };
    # GOING
    # applies Cee directly
    me.Cray = &acgtRs{ return [
        ... me&Displayingness ,
        ['Ceetop','12',&acgtRs{
            Rs&Cee ||= 1;
        },'if:h'],
        ... me&Ceeingness,
    ] };
    #c Renderingness
    # patch the channels thiswaythatway
    me.Renderingness = &acgtR{ return [
        # allow for %Cit & %Tool... to use Displays
        # link elvising to origin
        ['displayon','7',&acgtRs{
            $D = me&tsc,'displayon','D','G';
            Dy&cv = 0.11
            Ds&pa = 0.4;
            (Rs&boost||0) < 1 and return
            # < turn into a header with a cell in it
            # < controls for width/height, spillover
            Dc&s = 'displayon';
            
            s&over = 'scroll';
            Ds&dis = 2; # inline
            #Ds&ab = 1; # pos:absolute
            #Ds&over = 'hidden';
            Ds&bg = 'green';
            Ds&width = '50%';
            Rs&rowish = 1;
            s&bo = '4px dotted green';
            s&hue = 30;
            s&br = 0.4;
            
            $s = s||Rs&self;
            
            $ons = [];
            ss&on and ons.push(s)
            else {
                # for a !Display(ed yet?) R receiving others
                each in ss&down {
                    ns&on && ons.push(n)
                }
            }
            if (!ons.length) {
                # interface to ask things to Display more
                if (ss&enlum != null) {
                    if ((Rs&boost||0) < 2)
                        return me&tsc,'canbegot','?','b'
                    me&introqua,s,{enlum:1};
                    me&tsc,'canbegot','...','b'
                }
                else {
                    me&tsc,'nobits','!D','6'
                }
            }
            
            $Te = Rs&Te;
            each in ons {
                ac(R,'down',n);
                # link elvising to origin
                $r = ny&origin;
                # R:C does R:Display in itself
                !r && ss&task == 'C' and r = R
                !r and throw "R:Display !yorigin"
                $ot = me&introqua,r;
                i $Te/$ot
                # BUG io z dupe
                # if multiple $ot to the same tv:
                # TEST
                # < io.i for two different $ot repeatedly
                #   singalises by tv, makes z dupey
                #   expecting o to filter z by tv?
                #    or can it dup_z what inserts by tv?
                #   ot1.y.later = ot2(.y.earlier = ot1)
                #    supposes the ot1/2 are singly theirs to muck with,
                #    not just linked to from there
                #   sometimes the z-ing (accumulation) is
                #    more desired than the tv-ing (namespace)
                $was = Tes&z.length;
                Tes&z = uniq(Tes&z);
                was > Tes&z.length and ~WasotinTe
            }
        },'ift,D'],
    ]};
    #c Implantingness R:Cit mobility
    me.Implantingness = &acgtR{ return [
        # %Cit%play mobilises as an origin
        #  then %spondo (Das playing with it)
        #   does spondoReis %Reis:Cit%,%TeImplant
        #   and configures it, making W:City
        # W:City %Citying
        #   does CityingReis %Reis:Cit%,%TeImplant
        # biggining, middle, end
        
        # realise we're becoming elsewhere:
        ['Cit+play','29',&acgtRs{
            $p = Ry&up;
            $pp = p && py&up;
            if (ps&Citop) {
                if (Rs&play && !ps&Implant) {
                    # defer to W:Das every time
                    $b = Rc&b;
                    b && !bs&play and 1s&pausing = 1
                    # map what's around here for them
                    $hn = me.nameup(R,'testrun run step doing');
                    # < less fatal, %spondo may only look for...
                    $name = hn.t +"'s "+R.t;
                    $D = G&Cye,[name,'',{R:R,Te:Rs&Te,nameup:hn,J:A.1}];
                    4s&DasN.push(D);
                    # causes a %spondo to %Reis again elsewhere
                    delete Rs&Cit;
                    Rs&Outplanted = 'Cit';
                }
            }
        },'ift,D'],
        
        # in a %Reis:Cit%,%TeImplant
        ['Citop','52',&acgtRs{
            $p = Ry&up;
            $pp = py&up;
            # %Reis with %TeImplant
            if (ps&Reis && ps&TeImplant) {
                # makes %Citop%Implant
                Rs&Implant = 1;
                # and implants/links elvising:
                $Te = ps&TeImplant;
                if (!Rs&Te || !Rs&Te.sc.Implanted) {
                    $el = me&introqua,R,{Implanted:1};
                    i $el/$Te
                    Rs&Te = el;
                }
            }
        },'ift,D'],
        
        # then inside W:City:
        ['Citying','3',&acgtRs{
            if (Rs&gleep) {
                Rs&rowish = 1;
                me&tsc,'nopddp';
                s&bo = '3px solid blue';
                n spondto  $self:Rs&gleep,R %Reis:Cit%,refpool
                return
            }
            # the R:C for...
            $p = Ry&up;
            # Citey s=thing %ravel:Citying
            $c = pc&s;
            !cc&s and me&tsc,'nos','nos','B';
            # %ravel gives s=thing here
            cc&s != s and me&tsc,'sdiff','sdiff(R/C)','B';
            $z =
            n CityingReis  $self:cc&s,R %Reis:Cit%,refpool
            # (dont) give Rs&Te directly,
            #  TeImplant would cause it to hang around,
            #  < could be alright if Co/$main ran its own W Te
            #  < then main-main could extract updates naturally?
            #  < click in test's displayon should re%doing it
            $Te = c.y.TeImplant;
            Te and zs&TeImplant = Te;
            
            s&lv = 1;
            # clone this Rs&C/** into R:C's Cs&z
            Rs&printDisplay = 1;
            #$s:c&s,TeImplant:Te %ravel:Citying
            #n spondo  $self:s,R,TeImplant:rs&Te %Reis:Cit,set:Cit
        },'ift,D'],
        #c spondo (Das playing with it)
        ['spond','3',&acgtRs{
            Rs&rowish = 1;
            n t  $s:s.t %hs:789
            $N = sc&s;
            !N || !N.push and throw "!array"
            # squish repeatative entry by futurised R
            # later may have changes in Te/s we want
            $gotR = [];
            $outi = [];
            each in N {
                $r = me&yfuture,nc&R;
                # disconnect when yfuture but no extra push from it
                r != nc&R and nc&discon = 1
                nc&R = r;
                $ri = gotR.indexOf(r);
                if (ri < 0) {
                    gotR[i] = r;
                }
                else {
                    # has a more up to date s/%Te
                    N[ri] = n;
                    outi.push(i)
                }
            }
            outi.reverse().map(i => N.splice(i,1));
            
            !Rc&b and me&sublatePassT,A.1.t;
            #n rec  s:●
            #n stop  s:■
            #n redo  s:◀
            each in N {
                $del = &{ N.splice(i,1) };
                n $n.t  $s:n,R,remova:del %spondo
            }
        },'ift,D'],
        # as a dislocated being
        ['spondo','3',&acgtRs{
            Rs&rowish = 1;
            # the %Cit gone %Citless
            $r = sc&R;
            $h = sc&nameup;
            !h and me&domesticate,R
            else {
                n nameup  $s:h,R,aTe:rs&Te,Spondo:s %nameup
                
            }
            sc&discon and me&tsc,'disconnected','unplug?','g'
            sc&discon and Rs&remova()
            #me&Reis,R,'Cray',s,{refpool:1};
            $s = rc&s;
            n Te  $s:rs&Te,R %ball,rowish
            
            # < inherit test's refpool
            n spondoReis  $self:s,R,TeImplant:rs&Te %Reis:Cit%
        },'ift,D'],
        # display the thing from me.nameup
        ['nameup','3',&acgtRs{
            Rs&rowish = 1;
            me&tsc,'nameup',null,'G';
            $h = s;
            each in h.N {
                $k = h.twas[i];
                i > 0 and me&tsc,'upwardsof','/','y';
                me&tsc,'%'+k,n.t;
                #n $k  $self:n,R %Cit
            }
            if (h.doing && h.step) {
                # the %doing
                (Rs&boost||0) < 1 and return me&tsc,'Upplantscheme','(+%City?)','g'
                delete Rs&Te.sc.boost;
                
                $expco = &k{
                    $d = h[k];
                    $dex = ds&exp;
                    return dexs&Copy;
                };
                $s = Rs&Spondo;
                !s and throw "DasN thing !self"
                # unpause the source J
                $J = sc&J;
                !J and throw "DasN thing !J"
                me&JPause,J,0;
                # unDasinate the source R
                $Te = Rs&aTe;
                delete Tes&play;
                # boost also, later
                
                $S = expco('step');
                # insert doing to step
                i $S/City:s
                $D = ya;
                # that looks at previous doing (W.t)
                $d = expco('doing');
                Dc&points = d.t;
                # awkwardly pass in %Te as s&z to City
                # un-push to Das,
                #   and save Te without the extra %play
                #   which will cancel out with %TeImplanted on arrival
                if ('how' && Te) {
                    # gives you a little time to muck with it
                    $r = me&Copy,R,Te,16;
                    delete rs&ov;
                    # every %ball to a %push should %Lines
                    # < does doing it now matter?
                    rs&Lines = 3;
                    me&Ring,r;
                    i $D/rc&s
                }
                # now the City takes the boost/gutsprawl
                #   inner boosts are still there
                delete Tes&boost;
            }
            else {
                me&tsc,'noUpplantscheme','(?)','g';
            }
        },'ift,D'],
        
    ] };
    #c Cit
    =head2
    dive into the result after it was made,
      showing output and crawling into the details:
        wants to be pointed to not coded
    < fast pointing to the data you want,
        elvising into this Reis without its enclosing A
          resetting the 4s frame wait
    < to create new %doings to W=Cit that check those points
    see XVer for during
    =cut
    # as its own R
    me.Cit = &acgtR{ return [
        ... me&DisplayTwoness ,
        # includes Citingness:
        ... me&Toolingness ,
        ... me&Slepingness ,
    ] };
    # with you & your Tooling/Display/etc
    me.Citingness = &acgtR{ return [
        ... me&Ceeingness ,
        ['Cit','13',&acgtRs{
            # subverted refs dedup
            s = Rc&s ||= Rs&self;
            
            $p = Ry&up;
            ps&Cit || ps&Citop and 'inside %Cit gel'
            else {
                Rs&Citop = delete Rs&Cit
            }
            
            $foret = R.t;
            if (!Rs&Citop && isC(s)) {
                if (Rs&tiny) {
                    # path in != title once there
                    # < doesn't work for Teing...
                    #   many places decide what that bit is,
                    #   mainly stackTe?
                    Rs&RXbit = R.t;
                }
                # use inner title
                # < leave R.t, invent another %ot for t inside R.t
                #   may target by s.t sometimes, eg an array of C
                R.t = s.t
            }
            if (Rs&ot == '1' || !Rs&ot && foret != R.t) {
                delete Rs&ot
                foret != 'Cit' and Rs&ot = foret
            }
            
            # allow %Cit to have %play 
            # and yon %Cee to sprawl to C
            Rs&playsheet = {Cit: &acgtR{}};
        },'ift'],
        # the top Cit looks it over more
        ['Citop','6',&acgtRs{
            $b = Rc&b;
            $p = Ry&up;
            ps&ok and Rs&ok = 1
            # ok-ing overthing should calm...
            Rs&ok && b && !bs&ok and Rs&boost--
            
            # clicking in here should localise refresh
            if (0 && !Rs&oldR) {
            Rs&elvisrefresh = &acgtc{
                # c.Te = new Rs&Te, prevents looking for it
                c = ex(c||{},Rs&rec);
                c.directDisplay = 1;
                c.oldR = R;
                # < transact with history to replace this thing
                #   as opposed to piling up a whole new X
                $p = Ry&up;
                # now 1=Fourier, make it think we're near Teing:
                1s&Te = 'ha';
                # works once:
                pc&b = p;
                $r = me&Reis,Ry&up,'Cit',null,c;
                #debugger;
            };
            }
            
            if (Rs&directDisplay) {
                !Rc&b and throw "no history to Display over"
                ~Historific
            }
            
            s&bo = '2px dotted blue';
            s&hue = 30;
            s&br = 1;
            s&ma = 0.3;
            s&pa = 0.3;
            #s&float = 'right';
            !Rs&Te || !Rs&Te.c and s&fs = 6;
            
            if (typeof s != 'object') {
                me&tsc,'notobject','!object','d'
                n notC  $s:s,R %Cee,dupup
                return
            }
            
            n $R.t  $s:s,R %Cit,fromsitop
            
            !isC(s) and return
            $WR = sy&R;
            if (WR) {
                $on = WRs&on;
                if (on) {
                    n yRson  $self:WR,R %displayon,maybe
                }
            }
        },'ift,D'],
        ['TeImplantation','3',&acgtRs{
            # %ball?
        },'ift,D'],
        # continuity markers
        # < Tool continuity awareness over all
        # < slan diff also, probably already somewhere
        ['continuity markers','6',&acgtRs{
            return;
            $b = Rc&b;
            !b && !Ry&up.c.b and return
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        #c Cit
        ['Cit','3',&acgtRs{
            Rs&Cit = 3;
            $p = Ry&up;
            $Cit = &tsc{
                $n =
                n $t  $s:s,R
                ex(n.sc,ex(c||{},{Cit:1}));
                return n
            };
            # title 0
            $doot = &d{
                $tee = (Rs&ot||R.t);
                d && tee == R.t and return
                $v = me&tsc,'ot',tee,'q';
                vy&cv = 0.01;
                vs&deco = 1;
                doot = &{};
            };
            Rs&ot || Rs&tiny and doot()
            $scan = Rs&scan = me&scan,s;
            scan.is == 'C' && sy&R == s and scan.is = 'R'
            scan.is == 'C' && ss&W and scan.is = 'W'
            Rs&ma and s&ma = Rs&ma
            
            $wastiny = Rs&tiny;
            Rs&boost > 0 and delete Rs&tiny
            if (Rs&kvey) {
                each kv s {
                    $c = {ma:0.1};
                    c.tiny = 1;
                    Cit(k,v,c)
                }
                me&domesticate,R
                Rs&tiny = 1;
            }
            if (Rs&tiny) {
                Rs&dis and s&dis = 1
                return
            }
            elsif (wastiny) {
                Rs&dis = 1
            }
            if (scan.sym == '[' && Rs&boost < 2) {
                n open 4 s:[ %hs:489
                
                each in s {
                    # BUG this titling situ of z [ z,z,z,z
                    Cit('['+i, n, {tiny:1,ot:R.t});                
                }
                n close 7 s:] %hs:489
                return
            }
            if (Rs&istw) {
                each kv s {
                    $c = {};
                    Rs&tiny and c.tiny = 1
                    Cit(k,v,c)
                }
                return
            }
            
            if (!scan.C && ps&Citop && !Rs&boost) {
                n $R.t  $s:s,R %Cee,dupup
                return
            }
            
            # title 1
            me&domesticate,R
            !Rs&dis and delete s&dis;
            
            #n swhu  $self:scan,R %sun
            
            if (scan.C && (Rs&boost||0) < 1) {
                n yes  s:」
            }
            elsif (scan.C && Rs&boost < 2) {
                # several C's with some interesting stuff in
                # < look for anomalies
                #   generate maps to call things
                if (scan.is == 'R') {
                    n asR  s:¢
                    $hem = {kvey:1,ma:0.3,dis:1};
                    Cit('y',s.y,hem);
                    Cit('c',s.c,hem);
                    Cit('sc',s.sc,hem);
                }
                else {
                    sy&R and Cit('yR',sy&R,{Rit:1,dis:1});
                }
            }
            else {
                doot(1);
                # some strangeness or the thing we're interested in
                s&dis ||= 1;
                $le =
                n $R.t  $s:s,R %Cee,dupup
                # if Cit is only a Cee, put title inside:
                # < computed overall, paint out vagueness
                ps&Citop and les&wanttitle = 1
            }
        },'ift,D'],
        #c as well as Cit-ing, shade and understand A
        ['Rit','3',&acgtRs{
            !sc&N and throw "Rit !R"
            $I = sy&I;
            if (I && !Rs&isI) {
                n yI  $s:I,R %Rit,Cit,isI
            }
            if (Rs&isI) {
                # see the big picture
                $head = sc&head;
                if (head) {
                    n chead  $s:head,R %Cit
                }
            }
        },'ift,D'],
        
    ] };
    
    #c Cee the truth (with folded edge)
    # reliable expression of data as it is
    # < json-compatible copy/paste
    me.Ceeingness = &acgtRs{ return [
        ['Cee','3',&acgtRs{
            $Cee = &tsc{
                c = ex(c||{},{t:t,s:s,Cee:1});
                return me&Ret,R,c
            };
            $scan = Rs&scan = me&scan,s,R;
            
            $h = Rc&N[0];
            $P = me.cby(R,&r{ return !rs&Cee });
            $p = R.y.up;
            $it = P.shift();
            # above %plays to open all non-C
            ps&play || ps&sprawling and Rs&sprawling = 1
            scan.C and delete Rs&sprawling;
            if (Rs&sprawling) {
                delete Rs&isgk;
                Rs&rowish = 1;
                #Rs&sprawling and delete Rs&sprawling; Rs&isgk = 1;
            }
            $depth = P.length;
            $p = R.y.up;
            
            Rs&wanttitle and debugger;
            Rs&wanttitle || !Rs&dupup and me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && depth > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            #Rs&boost < 0 and delete ps&rowish;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                me&gkness,R;
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = Cee(k, s [k], {isgk:1});
                i == 0 and ns&ml = 1
            }

            each ik ks {
                Cee(k, s [k], {rowish:1});
            }
            
            Rs&boost > 0 && depth == 1 and Rs&runny = 2

            
            if (scan.C && (Rs&runny > 1
                ||
                (Rs&runny || depth == 1) && sy&tv && ss&z && !ss&J
                )) {
                each in ss&z {
                    # can zoom around Cs if ^
                    Cee(i, n, {rowish:1,runny:1});
                }
            }
        },'ift'],
    ] };
    #c Ceey
    # exit the entrance
    #  put label/C.t (not always the same)
    #  C's cell wall
    me.domesticate = &acgtR{
        # 1
        $M = me&Mw,R,'traw';
        $t =
        m t 1 $s:R.t %fs:13,hs:288
        if (Rs&fornt) {
            # coming off the grounded C, name after that C
            $proc = "|"+R.t;
            m into 118 $s:proc %fs:11,hs:267,bgh:230
            tc&s = Rs&fornt;
            ts&bob = '1px dotted white';
        }
        
        # types at s
        $scan = Rs&scan;
        !scan and return
        
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955
        
        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    };
    me.bagatagage = &acgtR{
        $scan = Rs&scan;
        $ks = scan.ks || [];
        if (scan.C) {
            ks[0] != 't' and debugger;
            ks.shift();
            $s = Rc&s;

            $M = me&Mw,R,'.t';
            scan.is == 'A' &&
                m tofA 19 s:: %ls:-0.2

            m t 2 $s:s.t %deco,fs:15

            if (scan.is == 'A') {
                $cv = s.cv+'';
                cv[0] == '0' and cv = cv.slice(2);
                cv = '@'+cv;
                m cv 21 $s:cv %ls:-0.1,hs:339
            }
        }

        if (scan.modu) {
            each in scan.modu {
                n.t == 'weirdkeys' and continue
                $M = me&Mw,R,'modu:'+n.t;
                me&Modu,[n],M;
            }
        }
    };
    # squished lump of thing
    me.gkness = &acgtR{
        $M = me&Mw,R,'traw';
        
        # make block,inline have same indento
        $p = Ry&up;
        $iN = (ps&z||[]).indexOf(R) - 1;
        $f = iN >= 0 && ps&z[iN];
        f && fs&rowish and s&ml = 1
        
        s&fs = 7;
        m sym 12 not
        $pow = 2;
        Rs&boost and pow = 4;
        $string = ki(Rc&s,pow);
        $limit = 100;
        Rs&boost > 1 and limit *= Rs&boost;
        if (string.length > limit) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    };
    # regroup Cee's children (before they're Cee'd)
    me.wktion = &acgtRs{
        $wk = s;
        s = Rc&s;
        $p = R.y.up;
        if (p && ps&scan && ps&scan.C) {
            if (R.t == 'c') {
                if (wk.indexOf('sip')>=0) {
                    wk = wk.filter(n => n != 'ip' && n != 'sip');
                    $fa = 4s&famous;
                    $slip = s.sip;
                    $M = me&Mw,R,'sip';
                    # tradeoff between things
                    if (fa) {
                        each in fa {
                            s.sip.indexOf(i) != 0 and continue
                            m famous  $s:n.t %deco,fs:7,hs:999
                            slip = '.'+s.sip.substr(i.length+1);
                        }
                    }
                    m sip  $s:slip %fs:7,hs:999
                }
            }
        }
        return wk
    };
    #c R ing , collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        # a way to depth-first, see slep
        Rc&N && Rc&N.indexOf(R) > -1 and return
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        if (s && typeof s == 'object') {
        # dedupe/limit objects already in this pool
        $ri = Rc&refs.indexOf(s);
        if (ri < 0) {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            RN.push(R);
            # in this pool
            $RhN = RN.filter(r => h && rc&N == hc&N);
            $nvm;
            if (Rs&dupup) {
                # when -known also -unknown inside itself
                RhN.indexOf(Ry&up) >= 0 and nvm = 1
            }
            if (!nvm) {
                $dupl = Rc&dupl || 0;
                if (RhN.length > dupl) {
                    limit('dup');
                    Rc&nofurther = 1;
                }
                else {

                }
                !Rc&nofurther and limit('dub')
            }
            # < to know circular links, converge
        }
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.indexOf(R) == -1 and Rc&N.push(R)
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X (inwards)
    #     X.z = [ R nodes
    #
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    # at Display 17
    me.RbitX = &acgtR{
        # too many places guess R.t
        #$bit = Rs&RXbit != null ? Rs&RXbit : R.t;
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    # at Display 4
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;

            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        if (s.length == 2) {
            # dl or nl count
            a[s] ||= 0;
            a[s]++;
        }
        else {
            # others list nodes of trouble
            $m = a[s] ||= [];
            m.push(R);
        }
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # the awkward toplevel
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        Ry&R = Ry&I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
        return r
    };
    
    # new R pool
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task ||= r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                if (h && hs&joinR) {
                    rc&N = hc&N;
                    # < avoid Ringing on the way out of Reis
                }
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    # new R, same pool
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        if (c.refpool) {
            # we become a pool of refs
            #  something about A.1-9
            #   the magnitude of a distance
            $p = delete c.refpool;
            if (p != '1') {
                !isC(p) || !p.y.R and throw "refpool !R"
                Rc&refs = pc&refs;
                Rc&refR = pc&refR;
                
            }
            else {
                Rc&refs = [];
                Rc&refR = [];
            }
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    

