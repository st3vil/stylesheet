Coffle: | # discussion
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    io.doz = 1;
    io.usu_dup = &{};
    G&waylay,'NutGravy';

    =head1 #prepare to A=A
    
    - J to take < 200ms
    - Elvising running the shower
    
    currently injecting things with plans to sleep,
      should get vast %ball/%Cit/%Cee things (and more)
        a way to map their changes fast and sleep
          change of container vs. the values within
    a&z toplevel thinker - and its localised sidecares
      rebuilding on the Co Joinup
        having it bring G (map of its dependencies)
          as an %H of a different name
            once osc piles hoisting whatever are a thing?
      Matu process with %ball
        mapping the mapped into a transform,
          redoing parts, remixing
    and then making a coderupper and way in-outer
      to the rest of the rennovation...
        starting a new page of html,
          built-in and not NutMach,io
        I-ing up Sevo, then placing more A-ily
    
      C   E
    A   D 
      C   C
    
    #sleep
    D - the Aing grouping items sprouting inside
      to transport them out of time,
        so J>7 can help J<7 (sleep)
      and provide history, so to sleep:
        1-2 remembers and sleeps most of their Ring
      Desire might want to do something,
        as a new elvis pointing into here would
         (Teing is a kind of elvising)
           and is the float:right upside down triangle of stuff
             the small network-edge pile coming down into
             the big contenty pile of isness
     so build:
      names extruding, like X but with:
        where/when they would have emerged (gonerism)
          eg. from the ground, or some picking of Rc&s
        decide as soon as new Dome == old Dome to:
          do extra/deep checks, should be hung near
            put Display into 8-mode:
              have to put hs&on somewhere
          
        what if Ry&up awakes but R sleeps:
      Display2, that goes via X instead of yup:
        traversal iterators that choose a name system to use,
          X is the given base name system
    
    
    elvising coming out or going in on the X
    and transacting the change of it
     as Domes, which have versions of Domes going into them
     an osc that keeps everything it sees would be first
      and be the wandering frontiers of change
     
     making the R an A.
      compiling ravel into throat?
    
    %push gives T(..Co..) five clicks to find J,
      then it is woken up
    
    fairly slow slow, need:
     more sleep (R to 1/2 and no further)
     ongoing bisection of A
    
    
    make this data pointer (Cit)
     add %doings that Cit the same way
       and can share refs perfectly,
       showing where internals began
         set free with an everything bisector
     to see the current RbitX system and replace it (bugs/b-loss)
     with something less tight and confusing
    
    then make go fast
    
    and then I land,
      an editor native to
     then A=A
    
    =head1 #bugs
    
      =head2 b-loss
        see about the b loss after a throw
          from not checking out Rc&X/V properly
         by elvising sensors into Elvising
 
         ^ holding up timing deunification/fast Display updates
      
      
    =head1 #voidable bugs  #c laterthisweek
    
    the editor
      keeps injecting the difference when you move a chunk marker
        remove, save, add back in to new place works
      freezes if you click+drag off the left
    
    the %kvstore %furthering into ting W/ doesnt settle
    
    io not doing a bunch more of the expression
     < do $s/%ball
     < know to Rsync after messing with?
    would take care of me&ioty and me&input
    
    =head1 #I
    
    for recompiling everything,
     G&t gets it from A*%believed
    that may be part of or leading to elvising,
      the hyper-everything trans-anyway maculata
     which lives in the same form:
     <Source> /Transform|Select\ <Output>
    any of that may need to live somewhere,
    for independent intelliglance:
     CodeChange
       To
         Experie
           $Doleux # the -e below, put for destination
       For
         Vang # W from here to grabber
           Doleux -e
             %here: Doleux # version of grabbed thing
             %etc: whathaveyou
    then Vang relives that %push
    and Experie knows its got stuff incoming
      which it might already have pulled in,
        (it must also disconnect)
      or is able to pull in with/without Vang being awake
    
    =head1 push
    
    is near simplifying
      G/W rebuild would realise calmable push boundaries
     and how hard the codon was entered
     and an overmind to wander around %tests
    
    =head2 Cnetobjet
    
    all %H within should gather atop
      garbage collection
        the wandery overmind
    rebuild this editor as a picture museum
    
     a juice - bioavailability of A prog C
     grab moment S, giving some kind of housing
     lexicals hang around,
     -the end- of computer science
     scene collapses into bubble
     try to get back to some kind of housing
     security is being stuck on the outside of some jeweled cavity
     
     once done a bunch of something, you can look at them.
     as gravity.
    
    =head5 #c A=A
    
    merge R into A.
    A is R, throat is Ring, sooner of things
      throat - where Instructions iterate over Culture
    # here we do the entire Ceeing instantly to the enclosing timeframe
    (taking pictures of state that is about to change)
    in general, knowing if the A is for a queue or for right now
     + the usual about how queues crud around
    patching time... all Cnetobj
     it will look like itself, except for where it ruptures/grows
    
    =head1 Srupto
    we want to allow pin Steps to be Instructions
      a way to grab anything at any rhythm
    
    the baseline C mode includes encoding Instructions:
     Cont
       thinger 3 s:'s&er++' %of:Lat
    becomes:
     Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
    then:
     Cont transports
     Lat is I stuff (%W with %z), posited as being Lat
     thinger is encoded (Latc&W:of)
    such that it is mostly ready for action:
    A.3+ believes in Cont%W
    A.1 somewhere wants Lat
        (or thinger, knowing things like Lat might contain it)
     by elvising G/$pathtoA1/Lat,
      finding/choosing a Lat,
      which must 6 the whole of what it bit
        (W around might be only indexing of what can be got)
    do-ing
    then that elvising attaches to A.1/G/Lat/Cont
     which A.3 hoists/attaches/encodes/stores as some of:
       A.3/G/Cont # no idea wherefor but small edge
         # does updates for change at the large-object level
       A.3/G/Cont/$pathtoA1 # know where to send attention
         # andor where in the stream of Cont the change is!
       A.3/$pathtoA1/G/Lat/Cont # Q/A format per place
         # lends itself to network change sensitively
     easily all at once
     hyperspheres of definition named simply
    and store perhaps on the first line of the W in Lines:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Stuff   %produced
    and something incorporating Cont and more looks like:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
         thingo 3 s:'C.c.o++'
       thingo 3 s:'s&er++' %of:Lat
    
     when thinger blows up, inspected:
        thinging from AyeOne%W/Lat%Wz/thinger
        and as asking around about random things:
        find AyeOne%W/Cont%W (aka Cont%W) also has Lat/thinger
        things may be asleep about here,
        but may be able to show source code, compile/mutate it
    
    looking at the G would be lots of io-ing
      things packed into it
      checking those injection/projection points
      is bitXgonerism
      relying on percolating those things
        along things that we can relive
       or shut down, rearrange, tamper with
      as osc-compatible:
       various $Gish of $Wish may be attached to $Wish
         so long as osc understands what/how to involve/mixage
       even outside itself on $Woth/$pathtoWish/$Gish
        just as $Teing is an index of landstructions to go here
        we have the chance to take with us or trust to recreation anything
        
       they are understood by the I, made meaningful where $Wish is
      and hoist/dehoist its structures into other places
        with others doing the same thing
      and also just the giant tabulation
    
    #c ph (post R re-combobulation)
    osc does new A:I over the old one
      probably rolling everything
     A:C make separations of a thing or things
      lets its content be distributed and depended on
      pattern matched and made into elvisings out to W:of,
      putting into a further self
    
    so C may need separation to preserve various objectives:
     A:n C being the most-uphill thing
     A:C = C coming in
     A:s = C for doming/playing sc forward
     A:C = C going out
     A:W = C encoding/compressing
    they all have ways to know about their previous lives
    
    
    
    another life of the underlying shape:
    A - receivability
    C - received culture
    G - culture + momentum, implantations
    T - what could not fit in,
      its mysteries/problems/developments,
      its inclusion to/from the world
        to as in for Teing into some W-position,
        from as in its life was because of such insTruction
      the T is like the G
        dealing with a big tangle of comings & goings
    the T decides/dealswith the edge of the picture,
    by hoisting/making the content misfiture,
      such that a big C can have its anomalies adjusted
    
    the layer above io, provides mode ala c&el
      io needs to readwrite A&X/A&V/A&Xo
        to provide the memory of the current play
        in parallel to the previous one,
          noticing when C views should complete (gonerism)
    diversifying how to match $thing against $Thing,
      what we are looking for,
      what level of understanding to borrow what from
    yet producing that sc-lang about how it was written:
      Some%sounds = {index of direction to points of resonance}
    there could be:
      Cs making the structure of any kind of index
      direction Cs, coming from/with merge/over/with/etc
      resonating Cs, beings in a constellation unknown to themselves
    
    A:s would be driving towards a goal
     juggling dives in, points and progress
       of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
     compiles fast checkers of 0-2 wobble once inflated
      so lowlevel changes (container re-ref) cause higher modes
    needs a playspout
     told/finding how innards roll through time (A&ip++)
     pointing to things, as if regrouping into another
      laying schemes on what to do
       producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked, wandering
    
    drawing cellular boundary
      s&z = more C,
        so might its A&z = more A
      based a bit on A signage (A.so = $so)
        $so might be via Ay&up (would know if soA&ip aboves us)
        A.pileup of things involved/leading to A
          should cleanup per J or so,
          but provide being/groupology along A
      measures of depth/appropriateness
       A&d (A.c.d)
      thickness/gravitational of cultural boundary-ness
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
    #c ph Srupto Elvising 
    =head1 Srupto 
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
          throating is meeting several inputs at once:
           A:n->C+ dome-havers (leading to/with/during s for the J)
           Teing (Instruction overloading) from 'above'
           Regurgitants
        Js can be trusted to get their TGW meaning to a point,
         so they can be reset natively
          consuming all input, producing all output,
          for what is supposed to be here.
          inside J (s life) its expression is freer
           
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
         for going into the C and its state through time, etc
          onward, redo, step, pause at trouble...
         matching between many pools
          for same objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          and similarityin many pools, overlapping, notice objects had by each other
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        Geing stuff, departing pile of meaning
        # similar but for unpackedness in general,
        Teing suff, meaning of departing
        # phases of aiming the display and adjusting things
        a pi sewing machine:
        # latter -go wants to be pointed to not coded, initially
        
        =cut
        
        
    #c push
    me.Pushingness = &acgtR{ return [
        # %push = cv awake
        ['push','3',&acgtRs{
            me&rollbs,R,'moves,delivered';
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            s&fs = 8;
            #Rs&arrow =
            n $R.t 13 s:⇒ %fs:24
            # certain/lowlevel types of %push
            Rs&auto || Rs&hard and return Rs&push = 9
            # log
            Rs&moves ||= []
        },'ift,D'],
        
        # %their
        # not currently pointed to and found:
        #   %there + %here = %their
        #     might mean disregard for %their state
        #     or ignorance, as elvis might clue
        #      with all the logistical infolation
        # ways the item 7s from afars:
        
        # %push%their = %balls reporting back
        ['ball+pushed','56',&acgtRs{
            # since ball 53 yfuture'd %pulled...
            $p = Ry&up;
            $above = ps&pushed || [];
            each il Rs&pushed {
                # %pushed here and not above
                above.indexOf(l) >= 0 and continue
                # < many?
                ls&their = R;
            }
        },'ift,D'],
        # %push%their = what %deliverer did (via %pushish)
        ['push+deliverer','56',&acgtRs{
            $d = Rs&deliverer;
            $ed = d && ds&delivered
            ed and Rs&their = ed
        },'ift,D'],
        # the %moves could lead somewhere
        ['push+moves','56',&acgtRs{
            each in Rs&moves {
                n.t == 'push' and Rs&lastpush = n
            }
            # last %move that was a push
            $lm = Rs&lastpush;
            if (lm) {
                # this %push when %move was started (had the %made)
                Rs&doing = lmc&pusher;
                # this %push when %move was done
                Rs&done = lmc&pushed;
            }
        },'ift,D'],
        
        # an error getting fixed
        # detects disconnected %their
        #  searches for likely candidate
        #   or however there/their is pointed
        ['push+losttheir','77',&acgtRs{
            delete Rs&losttheir;
            !Rs&lastpush and return
            $m = Rs&main || Rs&made || Rs&here;
            $th = Rs&there;
            !m || !th and throw "m-th"
            $t = me&ioty,th,'%ball' .filter(t => t.t == m.t) [0];
            n sun  $s:m,R %sun
            !t and return me&tsc,'notfindable','gonetheir','d'
            Rs&losttheir = t;
        },'ift,D'],
        # and puts it forth
        ['push+moves','56',&acgtRs{
            # for push+losttheir 77
            $b = Rc&b;
            $l = b && bs&losttheir;
            l and Rs&their = me&yfuture,l
        },'ift'],
        

        ['push','59',&acgtRs{
            Rs&push >= 9 and return
            # attaching checks to its parts
            me&suggesc,Rs&here,'Lines';
            me&suggesc,Rs&their,'Lines';
            # %act from what it %does to get %made
            #  engaged now so it can tamper with <6%their
            Rs&does and Rs&act = Rs&does
        },'ift,D'],
        
        #c push-7 have encoded %balls wormhole through %moves
        #   received by this %push early enough to action
        ['push','7',&acgtRs{
            Rs&push >= 9 and return
            $t = Rs&their;
            $h = Rs&here;
            
            # both sides should Lines
            me&sch_didLines,R,h;
            !t || me&sch_didLines,R,t;
            
            if (me&Mw,R,'err' .length ) {
                Rs&push = 9;
                return me&tsc,'push7_errrors','⊗','L'
            }
        },'ift,D'],
        
        ['push','73',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            $done = Rs&done;
            
            done && !t and me&tsc,'va','vanishing!'
            !t and me&tsc,'notheir','⧁','L'
            
            # here <-> their if nothing organised
            !Rs&diffya and me&diffya,R,'diff',h,t
            
            # their <-> their at the last push
            $tdiff = t && done && me&diffya,R,'theirs',t,dones&their;
            if (tdiff) {
                # < handle changes we didn't push
                # < branch here <-> dones&here, patch onto that
                if (!tdiffs&exactly) {
                    # < explore what'll happen, run in reverse
                    #m pull $from:t,to:h %pull,pending,move
                    n pending  s:pull? %hs:588
                }
            }
        },'ift,D'],
        
        # %push makes %moves
        ['push','77',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            # collects %moves
            $M = Rs&moves;
            
            # the checkout on init trick
            if (Rs&checkout && !M.length && me&sch_ballonlyt,h ) {
                m checkout $from:t,to:h %pull
            }
            
            # transmit here or what we made of it
            Rs&made and h = Rs&made
            
            if (Rs&shove || Rs&boost > 1) {
                !Rs&shove and Rs&Te.sc.boost = 1;
                Rs&shove &&
                    n shovedby  $s:Rs&shove %hs:388,deco
                
                if (!t) {
                    t = Rs&there;
                    $into = '> '+t.t
                }
                ~PUSH: R.t, h.t, into||t.t
                # the usual
                $c =
                m push $from:h,to:t,pusher:R
                into and cc&into = 1
            }
        },'ift,D'],
        
        # random look
        ['push','8',&acgtRs{
            !Rs&boost || Rs&boost < 1 and return
            
            s&fs = 11;
            s&dis = 1;
            #n thing  $s:R.sc,R %sun
        },'ift,D'],
        #c push-moves
        # 7%push sends its future self %moves to do
        #   objects (esp %from and %pusher) from that time
        # now early enough to make %ball%othering
        # a %move is just a C, has:
        #   c&from/c&to: most of all
        #   c&push: %push when it started to move
        # if you:
        #   c&pusher: whatever/%push the move was designed in
        #  you get:
        #   c&pushed: yfutured/%push when move completed
        ['push+moves','4',&acgtRs{
            $M = Rs&moves;
            each in M {
                ns&done and continue
                # with items from late last time
                $f = nc&from;
                $t = nc&to;
                t ||= nc&into;
                !t || !ts&ball and throw "move not sure of t%ball"
                !t || !fs&ball and throw "move not sure of f%ball"
                # us, last time
                $p = nc&pusher;
                nc&push = R;
                # f is likely to be the last %here, unless reversing
                # t (usu c&to=%their) may still be c&into=%there
                $tp = t && ty&up;
                if (tp && tps&pushering) {
                    tp = me&yfuture,tp;
                    # parent mediates %push for some reason
                    #  eg to %kvstore %here%string
                    # not %their directly
                    ~pushering: t.t, R.t
                    ac(tp,'pushering',R,'ball',f)
                }
                else {
                    $to = t;
                    t = me&yfuture,t;
                    ~othering: t.t, R.t
                    0 > Rc&N.indexOf(t) and ns&warn = 'to!cur'
                    t == to             and ns&warn = 'to!futu'
                    ts&ball == '6'      and ns&err = 'toolate'
                    
                    if (!ns&err) {
                        # bit more pto
                        ns&move = 1;
                        ns&from = f;
                        ns&to = t;
                        ac(t,'movingin',n);
                    }
                    # usu othering %push%here,
                    # < the %moves making subcommits:
                    #   their own reselections of %ball
                }
                
                ns&sym = n.t == 'checkout' ? '↽' :
                    ns&pull ? (ns&pending ? '◅' : '◄') :
                    ns&step ? '‣' :
                    (ns&pending ? '▻' : '►');
                ns&err and ns&sym += '!'
                ns&done = 6;
                #n thereup  $s:ty&up,R %sun
                # t%ball%othering should get us
            }
            
        },'ift,D'],
        
        # moves talked about 
        ['push+moves','7',&acgtRs{
            $M = Rs&moves;
            M.length &&
                n moves $s:M,R %hadmoves
        },'ift,D'],
        # squishy shrinking ooze, preserving interesting events
        # more info at latest
        ['hadmoves','3',&acgtRs{
            $p = Ry&up;
            $forget = [];
            each in s {
                # done this round
                if (ns&done == 6) {
                    ns&done = 9;
                    $r = nc&pusher;
                    # branch at %push%their with %move
                    r and nc&pushed = me&yfuture,r,R
                }
                # id by name then symbol
                $sym = n.t;
                ns&sym and sym = ns&sym
                n $n.t  $s:sym %fs:12,hs:594
                
                ns&err and me&tsc,'error',ns&err,'d';
                ns&warn and me&tsc,'warn',ns&warn,'d';
                
                # condenses
                if (s.length > 5) {
                    $ne = s [i+1];
                    ne && n.t == ne.t and forget.push(i)
                }
            }
            
            forget.map(i => s.splice(i,1));
        },'ift,D'],
        

    ] };
    
    #c TeCo
    # minimal pin-like thing returner (harness acts)
    me.domething = &acgttc{
        !me[t] and throw "no me."+t
        !c.acgt and throw "somethingelse"
        $r = me[t](A,C,G,T, ...c.acgt);
        c.returns && !r and throw "me."+t+" !return"
        return r
    };
    # %act='TeCo' gets this %made
    #  make instructions for Co
    me.TeCo = &acgtRhtc{
        $s = hc&s;
        # s:
        # haps
        #   step_1
        #     WaTe %H:38247253
        #       someelvising
        #   step_2
        #     haps %H:38231253
        $Co = G&Cye,['Co',''];
        i $Co/$s
        # r is %made
        $r = me&Copy,R,Co,18;
        
        # want to just:
        # o $Co/*:main/*:step/*:do
        # with %ball layer, style main + do
        
        $main = me&ioty,r,'%ball' [0];
        $m = mainc&s;
        ms&Serarar = 'was';
        
        # ensure step_1
        !mains&z and me&input,main,'step_1';
        $steps = me&ioty,main,'%ball';
        each in steps {
            # ensure doing=main.t
            !ns&z and me&input,n,main.t;
            $does = me&ioty,n,'%ball';
            each id does {
                $n = dc&s;
                # whittle to instruction part
                # hiding whatever is here that is not it:
                # - the H object it should be
                ns&H and ds&H = delete ns&H
            }
        }
        
        # < any s&H still anywhere should be loaded in
        # < why only now can this have effect?
        $main = me&ioty,r,'%ball' [0];
        $m = mainc&s;
        ms&Here = 'was';
        
        delete rs&ov;
        rs&Lines = 3;
        # onward 2%ball Rsyncs, anything under r may ~
        me&Ring,r;
        
        $mains = me&ioty,r,'%ball';
        each im mains {
            # blows everything away when othered
            ms&clobberypushingz = 1;
            # limit othering of steps (to %run%currentstep?)
            ms&pushingnoz = 1;
            ms&invent_step = m.t;
        }
        ~TeCo: main.t
        return r
    };
    #c act
    # where it must do a computation
    # the R that %push%made, relative to others
    # ie an elvising that sleeps
    me.Actingness = &acgtR{ return [
        # the R that %made
        ['push+act','72',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            # this R with %here + %made when %move was made
            $doing = Rs&doing;
            # sublates other diffs
            Rs&diffya ||= {};
            Rs&diffya.theirs = 0;
            Rs&diffya.diffs = 0;
            
            # diff the input that %made et (approx)
            doing and $indiff = me&diffya,R,'input',h,doings&here
            if (indiff) {
                # input better understood as %made
                indiffs&sublated = 1;
                if (indiffs&exactly) {
                    # sleep %made by
                    Rs&made = doings&made
                }
            }
            
            # %made ||= the act
            Rs&made ||= me&domething,Rs&act,{acgt:[R,h,t],returns:1};
            
            # diff %made to %made when move was made
            doing and me&diffya,R,"made",Rs&made,doings&made
            
            if (t && t.t != h.t && t.t == 'Co') {
                Rs&mained = me&ioty,Rs&made,'%ball' .filter(n=>n.t == h.t)[0];
                !Rs&mained and throw "No Co/%mained thing";
            }
        },'ift,D'],
        
        # < as part of a %push%made%plan to make Co/%main/%steps
        
        # %made = Co [haps[step[do[elvis]]]]
        # is othered to %their instead of %here, so:
        # %mained = %made Co/haps
        # %main = %their Co/haps
        # two halves of living situation
        ['push+act','591',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            !h and return me&waits,'..h'
            $t = Rs&their;
            if (!t) {
                me&waits,'..t'
                Rs&losttheir = 1;
            }
            !t and return
            
            if (t.t != h.t && t.t == 'Co') {
                # locate their main thing (othered from %mained)
                $main = me&ioty,t,'%ball' .filter(n => n.t == h.t)[0];
                !main and return
                Rs&main = main;
                # Linesing per do
                $N = me&ioty,main,'%ball%ball';
                each id N {
                    #me&tsc,'indo','('+d.t+')','b';
                    me&suggesc,d,'Lines';
                }
            }
        },'ift,D'],
        #c act-made
        # Co/Hap/ Hap v1...
        # a bug chaser
        # make deals across the border so
        # a layer of task built onto a push
        # some complicated thing breaking out steps
        # < take %made/%step++ to %main/%step
        ['push+act','73',&acgtRs{
            s&bow = '3px';
            n act  $s:Rs&act %deco
            $h = Rs&here;
            $t = Rs&their;
            # persist %run per %main%ball c&s
            $mains = Rs&main && Rs&main.c.s;
            #  per clobberypushingz, restarts test run (drops J)
            $r = me&rollcounty,R,'run',{per:mains};
            # between two planes
            $N = me&ioty,Rs&main,'%ball'
            $Z = me&ioty,Rs&mained,'%ball';
            
            me&tsc,'thoughtclock',r.t+"@"+rs&count,'6' .sc.fs=7;
            me&tsc,'tot','('+N.length+'/'+Z.length+')','p'
            
            # zip N-results to Z-expectations,
            #  allowing more N if all is %ok
            $i = 0;
            while (N[i] || Z[i] || i == 0) {
                $eye = i+1;
                $k = 'step_'+eye;
                n $k  $step:eye,got:N[i],exp:Z[i],R
                i++;
            }
            # 4%step and then 5%groksteps...
            n progress  R %groksteps
        },'ift,D'],
        # groksteps
        #  playhead advances when more && ok
        #  boost to add steps
        # ⧐ from the top
        # ∿ big change
        # ~ small change
        # ☯
        # 
        ['groksteps','81',&acgtRs{
            $p = Ry&up;
            $steps = me&ioty,p,'%step';
            Rs&ok = 1;
            Rs&more = 0;
            each iS steps {
                $doings = me&ioty,S,'%doing';
                each in doings {
                    ns&doing == 1 and return T.wide = 1
                    !ns&got and Rs&more = 1; break
                    # results got must be ok
                    !ns&ok and Rs&ok = 0
                }
            }
            
            Rs&ok and me&tsc,'ok'
            !Rs&ok and me&tsc,'notok','!','B'
            
            Rs&more and me&waits,'more','...'
            
            Rs&more && me&waits,'more','≻','L'
            !Rs&more && me&waits,'moreanyway','⊁','L'
            
            Rs&ok && Rs&more and Rs&wantstep = 1
            Rs&boost > 0 and Rs&wantstep = 1; Rs&Te.sc.boost = 0
            
            Rs&wantstep and ps&stepforward = 1
        },'ift,D'],
        
        # others a %main%step
        ['push+made','82',&acgtRs{
            $m = Rs&mained;
            $M = Rs&moves;
            if (Rs&stepforward) {
                # should be ready
                !m || !Rs&main || !M and return me&tsc,'noforward',"!main"
                # find step with no %got
                $N = me&ioty,R,'%step';
                $S = N.filter(S => !Ss&got)[0];
                if (!S) {
                    # go beyond expectations
                    $doing = ms&invent_step;
                    !doing and throw "no more steps"
                    typeof doing != 'string' and throw "doing"
                    doing = G&Cye,[doing,''];
                    
                    $la = N.slice(-1)[0];
                    $i = las&step + 1;
                    $S = G&Cye,['step_'+i,''];
                    S = me&Copy,R,S,18;
                    me&input,S,doing;
                    
                    delete Ss&ov;
                    Ss&Lines = 3;
                    # onward 2%ball Rsyncs, anything under S may ~
                    me&Ring,S;
                }
                else {
                    !Ss&exp and return me&tsc,'noforward',"nextstep!exp"
                    S = Ss&exp;
                }
                
                # S is now a new %mained %step's %ball (or looks like it)
                # push the new %step to %main
                m step $from:S,into:Rs&main,pusher:R %step
                S && Ss&string and me&tsc,'shipping',Ss&string,'6'
                #n stepth  $s:Rs&main,R %sun
                
                #$c =
                #m push $from:h,to:t,pusher:R
                ~wouldstep: R.t
            }
        },'ift,D'],
        #c step acceptor
        # %push's %step/%doings build up %ok
        # < hang %step on the %here %ball it's for
        ['step','2',&acgtRs{
            Rs&rowish = 1;
            $p = me&zoep,R,{up:'%push'},'step','S','';
            $m = me&rollcounty,R,'mem',{per:ps&run};
            
            # go main/mained %step -> %do
            $N = me&ioty,Rs&got,'%ball';
            $Z = me&ioty,Rs&exp,'%ball';
            
            $i = 0;
            while (N[i] || Z[i] || i == 0) {
                $eye = i+1;
                $k = 'doing_'+eye;
                n $k  $doing:eye,got:N[i],exp:Z[i],R
                i++;
            }
        },'ift,D'],
        ['doing','3',&acgtRs{
            $p = me&zoep,R,{up:'%step%push'},'doing','.','';
            $m = me&rollcounty,R,'mem',{per:ps&run};
            $M = ps&moves;
            $g = Rs&got;
            $x = Rs&exp;
            # helps %groksteps decide things are ready
            # (A below should be done by the time...)
            Rs&doing = 3;
            x && !g and return me&waits,'nogot','...'
            !x && !g and return me&waits,'noexpgot','..!'
            
            # prepare to %diff
            $dc = {};
            # was no %doing
            !x and dc.unexpected = 1
            else
            # was no %doing%H, the result
            # swaps x with nothing insides %diff
            !xs&H and dc.unexpected = 1; dc.expGhost = &{};
            else {
                # make it look Linesey
                xs&dige = xs&H;
                # decode contents if needed (for a diff_
                dc.expGhost = &{ return me&GhostOut,R,xs&H; }
                # < decompress vastnesses
                # < use trusted code to generate everything?
                #   a lobo A4 copying dispatches from a live instance
                #   clonesyncing as it transports between them
            }
            
            # got %ball = n
            $W = g && gc&s;
            # replaces instruction
            W && !Wy&C and return me&waits,'noWyC','n...'
            
            # diff
            if (g) {
                $d = me&diffya,R,R.t,g,x,dc;

                # < what happens to this?
                ds&new and me&tsc,'nothere','⧀','L'

                ds&exactly and Rs&ok = 1
            }
            
            Rs&ok and ms&ok = R
            elsif (ms&ok) {
                # results are allowed to wander off once ok
                # such info is interesting
                # < accept/test for history-warp
                d and ds&sublated = 1
                n accepted_before s:=)
                Rs&ok = 3
            }
            
            #c This
            # we have a diff, know if ok now/before
            # and all this:
            if (W) {
                if (Rs&boost < 0) {
                    # quick redo thing
                    # < when it <G
                    $p = g.y.up;
                    $ps = pc&s;
                    $pi = pss&z.indexOf(W);
                    pi < 0 and throw "nofind"
                    !Wy&C and throw "nooriginal"
                    W = pss&z[pi] = Wy&C;
                    delete Wy&C;
                    W = null;
                    Rs&Te.sc.boost = 0;
                    return
                }
                # the object
                n Cit  $self:W,R %Reis:Cit,set:Cit
            }
            Rs&ok and return me&tsc,'ok','ok','p'
            
            if (W) {
                if (Ws&err) {
                    $skull = '☠';
                    me&tsc,'error',skull,'D';
                    me&tsc,'error',Ws&err,'d';
                }
            }
            
            # we have %here, find names for %step/%doing
            $S = Ry&up;
            $stepname = Ss&exp ? Ss&exp.t : S.t;
            $doingname = x ? x.t : 
                # to save an invented step/doing (!x) as got
                g ? g.t :
                R.t;
            
            # accept change
            if (g && Rs&boost > 0) {
                !Rs&shove and Rs&Te.sc.boost = 0;
                me&tsc,'accept',"<",'L';
                
                # find us from %here
                $step = me&input,ps&here,stepname;
                $doing = me&input,step,doingname;
                # store an object
                !gs&dige || !gs&string and throw "weird"
                me&GhostIn,R,gs&dige,gs&string;
                # put pointer
                $ds = doingc&s;
                dss&H = gs&dige;
                
                $dt = ds&Te;
                # reset diff about to become '='
                dt && dts&boost and dts&boost = 0
            }
        },'ift,D'],
        # encloses one of these,
        #  lest it Display before the M of Ry&up
        # always gives a new refpool,
        #  and first rs&self from Rs&self
        ['Reis','3',&acgtRs{
            $c = {refpool:1,self:Rs&self};
            Rs&set and c[Rs&set] = 1;
            c.t = Rs&Reis;
            c.rec = ex({},c);
            Rs&ReisR = me&Reis,R,Rs&Reis,null,c;
        },'ift,D'],
        
        # tape full of our stuff on Das
        ['spond','3',&acgtRs{
            Rs&rowish = 1;
            n t  $s:s.t %hs:789
            $N = sc&s;
            !N || !N.push and throw "!array"
            # squish repeatative entry by futurised R
            # later may have changes in Te/s we want
            $gotR = [];
            $outi = [];
            each in N {
                $r = me&yfuture,nc&R;
                # disconnect when yfuture but no extra push from it
                r != nc&R and nc&discon = 1
                nc&R = r;
                $ri = gotR.indexOf(r);
                if (ri < 0) {
                    gotR[i] = r;
                }
                else {
                    # has a more up to date s/%Te
                    N[ri] = n;
                    outi.push(i)
                }
            }
            outi.reverse().map(i => N.splice(i,1));
            #n rec  s:●
            #n stop  s:■
            #n redo  s:◀
            each in N {
                $del = &{ N.splice(i,1) };
                n $n.t  $s:n,R,remova:del %spondo
            }
        },'ift,D'],
        ['spondo','3',&acgtRs{
            Rs&rowish = 1;
            me&domesticate,R;
            sc&discon and me&tsc,'disconnected','unplug?','g'
            sc&discon and Rs&remova()
            #n spondo  $self:s,R %sun
            #return
            $r = sc&R;
            $s = rc&s;
            n thingshere  $s:rs&Te,R %ball,rowish
            n spondo  $self:s,R,TeImplant:rs&Te %Reis:Cit,set:Cit
                    #n yRson  $self:WR,R %displayon,maybe
                    #me&tsc,'TeIngImplanted','+Te'
        },'ift,D'],
        
        
    ] };
    #c pushy
    # operate on Ghost/kvstore remotely
    # < s&H object pointers wander borders
    me.GhostOut = &acgtRk{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $s = localStorage[k];
        !s and throw "noH: "+k
        # a %ball with %Lines=0
        return Ghosts&arrange_decoder(k,s);
    };
    # write-once storage
    me.GhostIn = &acgtRks{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $bs = localStorage[k];
        bs && bs != s and throw "hash collision?"
        localStorage[k] = s;
    };
    # the source of your information
    # o ^^%push %here %pushed'lookup' %there
    me.sGhost = &acgtR{
        $Ha = me.cby(R,&b{ return
            bs&pushed && bs&pushed[0].t == 'lookup'
        })[0];
        if (Ha) {
            $pl = Hac&pushed[0];
            $Ghost = pls&there;
        }
        else {
            #  %pushed falls off if throw
            $Ghost = me&pushpath,R,['/','G'];
        }
        return Ghost
    };

    #c Ring mind, doming
    # empties grounda&z into M or more R
    me.endome = &acgtR{
        !T.nN || !T.nN.length and return
        $N = T.nN;
        T.nN = [];
        $M = null;
        each in N {
            if (nc&R) {
                # spawn R?
                $parent = R;
                $s = nc&R;
                if (s && Rc&N.indexOf(s) >= 0) {
                    parent = s;
                    s = null;
                }
                delete nc&R;
                nc&s and s = nc&s; delete nc&s
                ex(n.sc,n.c);
                $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
                parent != R and me&zN,r
            }
            else {
                # otherwise this mindthing grows M
                M ||= me&Mw,R,t.t;
                M.push(n)
            }
        }
    };
    
    # while the R.t == mind of this pool
    $osu = &R{
        $task = Rs&task || R.t;
        !me[task] and debugger;
        
        # bit of caching on the w.t=Coffle, closured from eval
        $mI = ws&makesI ||= {};
        mI[task] and return mI[task]
        
        # m ... BQ breaks code visibility (until proper u)
        $z = [];
        $N = me[task](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            
            # compile instructions
            if (ns&ift == '1') {
                $op = n.t.split('+');
                if (op.length > 1) {
                    # must have all these sc
                    ns&ifs = op
                }
                else {
                    ns&if = 's'+n.t
                }
            }
            elsif (ns&ift) {
                ns&if = 's'+ns&ift;
                ns&ifeq = n.t;
            }
            
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        mI[task] = z;
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => me&zN,z );
    };
    # Rs&z -> hc&N, validates as atom
    me.zN = &acgtR{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    #c Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtRq{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        $the = me&Timethe,'Ring:'+h.t;
        
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            me&zN,h;
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        # walk the 愛 tape, trying to do more
        $timing = 1s&Times;
        $direct = 0;
        $indirect = 0;
        # a concentration
        # if things don't happen in the correct order,
        # since we go wide fairly often
        #  the parent Acv > the child sometimes matters:
        #   to get Cit3/slep2 to be Cit27(getslep)/slep2
        if (q) {
            # on those q.inside=$R
            #  growing q.onlyRupto
            q.inside and q.onlyRupto = [q.inside];
            q.ov and q.ov = G&desca,q.ov
            # < R indexed by cv
            # or otherwise grouped for meaningful disruptability
            #  TimeWaves
            # < have cursors not bunged by asyncs
            #    which is doming, a general segmentation
        }
        
        $busy = 1;
        $sheer = 45000;
        $onlyt;
        while (1) {
            indirect++;
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (q && R && q.onlyRupto) {
                R == q.inside and continue
                $not = q.onlyRupto.indexOf(R) < 0;
                if (not && Rs&ci == null &&
                    q.onlyRupto.indexOf(Ry&up) >= 0) {
                    q.onlyRupto.push(R);
                    not = 0;
                }
                not and continue
            }
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                onlyt = null;
                $lowci = '';
                $ati;
                each in hc&N {
                    if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                        lowci = ns&ci;
                        ati = i;
                    }
                }
                #lowci != '' and hs&iN = ati-1
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            Ry&R ||= R;
            
            # step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            R.c.not and continue
            #onlyt && t != onlyt and continue
            
            hs&ov && hs&ov < ty&cv and continue
            q && q.ov && q.ov < ty&cv and continue
            
            #c from here is going to accept the step as done
            #  except if T.wide, late abort/comebacklater
            #   for when your dependencies haven't filled out
            #    < keeping loopage direct with TimeWaves,
            #      which try to gather at fully awake
            
            # deciding
            $T = {};
            if (Rs&sleeping) {
                # misses everything but sleeping spells
                !ts&sleeping and T.not = 'sleeping'
            }
            if (ts&ifs && !T.not) {
                each ik ts&ifs {
                    R.sc[k] == null and T.not='ifs'
                }
            }
            if (ts&if && !T.not) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='ifh'
                elsif (ts&if[0] == 's') {
                    $v = R.sc[ts&if.substr(1)];
                    !v and T.not='if'
                    ts&ifeq && v != ts&ifeq and T.not='ifeq'
                }
                else {
                    throw "if "+ts&if
                }
            }
            if (timing) {
                indirect--;
                direct++;
                $k = h.t+'/'+t.t+'@'+t.y.cv;
                timing[k] ||= 0;
                $from = G&time;
                $thestep = &{
                    timing[k] += G&time,from
                };
            }
            
            if (!T.not) {
                $packdown = [];
                if (ts&D) {
                    # doming for n
                    T.nN = [];
                    packdown.push(&{
                        # empties T.nN into M or more R
                        me&endome,R;
                        delete T.nN;
                    });
                }

                $cb = tc&s;
                #!hak(R.c,'s') and debugger;
                
                cb(A,Rs&C||C,G,T,R,Rc&s);
                
                packdown.map(pd=>pd())

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            thestep and thestep()
            if (T.Rq) {
                $TRq = delete T.Rq;
                me&Ring,R,TRq;
            }
            if (T.wide) {
                Rs&widenings ||= 0;
                Rs&widenings++ > 30 and debugger;
                delete T.wide;
                busy = 1;
                continue;
            }
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            onlyt = t;
            busy = 1;
        }
        if (timing) {
            timing.direct ||= 0;
            timing.indirect ||= 0;
            timing.direct += direct;
            timing.indirect += indirect;
        }
        the();
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #   sprouts some sc to R
    #    C.y.R = R:C
    #  determine, certify version of etc involved
    # we have a village's machinery for progress
    # teleporting in 
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            me&zN,r;
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&rovo and me&Reis,R,'rovo',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c Flim pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    # inside W:Wobulus, after W:Fourier
    me.do_main = &acgt{
        if (1) {
            #me&J,'Pass','W';
            #me&J,'Das','W';
            #me&J,'Co','W';
        }
        me&J,'edges','W';
        #me&J,'Fours','W';
    };
    
    
    #c PassDasCo
    # host attachable T with W + G around
    me.findRef = &acgtRs{
        !(R && R.y && R.y.R == R) and throw "!R"
        $i = Rc&refs.indexOf(s);
        return Rc&refR[i][0]
    }
    me.Timethe = &acgts{
        $ti = 1s&Times;
        !ti and return &{}
        $starts = G&time;
        return &{
            $delta = G&time,starts;
            ti[s] ||= 0;
            ti[s] += delta;
        };
    };
    me.DeltaDelOsc = &acgt{
        $starts = G&time;
        $d =
        n delta  s:... %dis:1,float:right
        1s&OscDoneHook = &h{
            $R = me&findRef,h,d;
            $on = Rs&on;
            $delta = G&time,starts;
            delta += 's';
            each kn 1s&Times {
                0.01 > n and continue
                delta += "\n"+k+": "+G&desca,n +"s";
            }
            $done = G&time;
            $whendone = &{
                done = G&time,done;
                delta += "\ndone: "+done+"s";
                $(on).text(delta);
            };
            G&yl,0,whendone;
        };
    };
    me.Ja.Fours = &acgt{
        me&Gomp;
        n 4sDasN  $s:4s&Jtv %rovo:ning
        n 4sDasN  $s:A.4.sc %sun
    };
    me.Ja.Pass = &acgt{
        me&Gomp;
        #me&DeltaDelOsc;
        1s&Times = {};
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Ha  $Travel:el %ravel:gee
    };
    me.Ja.Das = &acgt{
        me&Gomp;
        $N = 4s&DasN ||= [];
        
        n 4sDasN  $s:N %ravel:spond
    };
    # provide n to %main/%step/%doings
    me.Ja.Co = &acgt{
        me&Gomp;
        $t = 1s&Te;
        # too late for this J to include it
        t && ts&z and G&yl:22,&{ me&doN,ts&z };
    };
    # do only undone %main/%step/%doings
    me.doN = &acgtN{
        each im N {
            # a main
            if (!my&began) {
                # fresh run, clear memory
                delete 4s&Jtv[m.t];
            }
            my&began ||= G&time;
            each iS ms&z {
                # a step
                ms&pause || Ss&pause and continue
                each iC Ss&z {
                    # a doing
                    C.y.C and continue
                    $live = me&adoing;
                    # if another, keep it instead
                    C.y.C = live || C;
                    if (live && live != C) {
                        live.y.C = C;
                        Ss&z[i] = live;
                    }
                }
            }
        }
    };
    # n $C # returns another
    me.adoing = &acgt{
        $q = {q:'W'};
        try {
            q.part = 'Jin';
            me&J,C.t,q;
            q.part = 'Jreturned';
        }
        catch (er) {
            # < powow with Ban to surf Bstack
            C = q.C || C;
            s&err = ki(C,2)+"   !"+q.part+"! "+er;
            ~adoing_er: s&err
        }
        return q.C;
    };
    #c Tests now we will try to make software:
    me.Ja.lobbek =
    me.Ja.happenings = &acgt{
        me&Gomp;
        $bit = 1s&bithold ||= G&Cye,['Bit',''];
        $b =
        n abit  s:lau %fopia
        i $b/$bit
        bits&bobs ||= 0
        bits&bobs --;
        #bits&bobs == -2 and throw "Unfielded quark"
        
        n Plethoria  $s:<<'' %oph:s
            # glampiture
            n now  s:noow %fs:54
        
        # < get rid of ^'s /^\t\t\t/
    };
    me.Ja.seeI = &acgt{
        me&Gomp;
        each kN ws&makesI {
            $l =
            n $k 3
            ls&z = [];
            each iI N {
                G&m,ls&z,[I.t,Iy&cv];
            }
        }
    };
    me.Ja.XV = &acgt{
        me&Gomp;
        s&Ring = 'XVer';
        $eye = 1s&count + 1;
        n thing  $s:33
        n thing  $s:55
        eye < 3 &&
        n thing 32 $s:33
        eye > 2 &&
        n thing 35 $s:22
        n thy  $s:eye
    };
    # see history work
    #   want to see Rc&X/V and Rs&X
    #   across all instances of time
    #   probably just from the top...
    
    # a bit of history use
    me.XVer = &acgtR{ return [
        ... me&Displayingness ,
        ['Ring','2',&acgtRs{
            Rc&refs = [];
            Rc&refR = [];
            each in ss&z {
                n.t != 'thing' and continue
                n $n.t  $s:n,R %fr
            }
        },'if:h,D'],
        ['fr','1',&acgtRs{
            R.t = s.t+' '+(s.y.cv||'')
        },'ift'],
        ['fr','2',&acgtRs{
            me&rollbs,R,'twang';
            Rs&twang ||= 0;
            Rs&twang < 8 and Rs&twang ++
            n twa  $s:sc&s %fs:16
            n for  $s:Rs&twang %hs:466
            ss&twan = Rs&twang
        },'ift,D'],
    ] };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c cellvey think about their state,
    # become straight, become curvy
    # have things wanting to be streamed uphill
    # showing interfaces where things can come across
    
    # h's ss&rovo='atype' -> Rs&atype = 1
    me.Rscinsideness = &acgtk{
        return [
        ['Rscinside','1',&acgtRs{
            $uh = Ry&up && Ry&up.c.N[0];
            uhs&task == Rs&task and return;
            isC(s) && s.sc[k] and R.sc[s.sc[k]] = 1
            Rc&dupl = 3;
        },'if:h']
        ]
    };
    
    me.ravel = &acgtR{ return [
        ... me&DisplayTwoness ,
        ... me&Rscinsideness,'ravel' ,
        # the living - a situation
        # slow rolling wakeup
        # openness is travelled in
        # up into cell
        ['gee','3',&acgtRs{
            Rs&rowish = 1;
            # %balls get shot into T
            #  giving a pi? real/veyd layers of sc?
            #  e /T -run . %does:TeCo %boost:2
            Rs&playsheet = {
                ball: &acgtR{
                    $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
                    ls&boost = 2;
                    me&introqua,l,{boost:1};
                },
            };
            # A.4 to/run/from, shared
            # is the local stage, our gear projected on
            # land of ignoring your own mind
            1s&runs == 1 and me&introqua,[A.1.t,'Ha','ravel','T',A.1.t],{boost:-1}
            n T  $s:sc&Travel,R %ball,bgh:586
            # create and harvest arrangements of gear
            #  %Teing extrapolates runningness
            n W  $lookup:s.t,R %ballse
            #,dragelvis:projvey
            # to stable
            n G  $kvstore:localStorage,R %ballse
        },'ift,D'],
        
        # lookup %ball/*.t in G
        # assorted W you asked for, bay of incoming remotes
        #   elvising/G&t-ish interface to mysterious places
        ['lookup','2',&acgtRs{
            $g = Ry&up.sc.z.filter(g=>g.t == 'G')[0];
            !gs&ball and return T.wide = 1;
            # W holds many, to sync to G
            # with %lookup: highest/starting point
            $t = Rs&lookup;
            if (t != '1') {
                # < be othering ourselves, lending content
                #   to get instant %ball for things
                #   and so disconnections keep objects
                #     for packdown/gc
                #   specifying types of ephemerality:
                #     runspace kept tidier than piles
                $n = me&push,R,[],[t],'purpose';
                # ensure it's first in z
                $zi = ss&z.indexOf(nc&s);
                zi > 0 and ss&z.unshift(ss&z.splice(zi,1)[0])
            }
            
            # ready all s/* as R/*%balls
            me&Rsync,R;
            
            $N = me&ioty,R,'%ball';
            each in N {
                # posit they %push(ish) to G
                $l = me&push,n,['/','G'],[],'lookup','checkout';
            }
        },'ift,D'],
        ['continuity markers','28',&acgtRs{
            !(Rs&ball || Rs&push) and return
            $b = Rc&b;
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        ... me&Ballingness ,
        ... me&Copyingness ,
        ... me&Pushingness ,
        ... me&Actingness ,
        ... me&Linesingness ,
        ... me&Diffingness ,
        #c kvstore
        # accept %pushish as a name lookup first
        #  names %decode'd and pushed here
        #   they have a %delivered %ball stuck in the past
        ['kvstore','2',&acgtRs{
            # t source
            # weak %push
            # %pushin helps project lives from s
            #   as decode
            # looks at %balls pushing to it,
            #  look for them here
            #   pushing there 
            #  accept their content if full enough
            !Rs&pushish and return T.wide = 1;
            # tell %push to do
            # < search children for %othering
            # < upgrade %othering sense to
            #   any of the objects
            Rs&pushering ||= [];
            me&rollbs,R,'rememb';
            
            Rs&get_key_for = &t{
                return ts&H || t.t
            };
            Rs&arrange_decoder = &ksl{
                # arrange decoder
                $re = Rs&rememb ||= {};
                $kd = k+dig(s);
                $bc = {task:'ravel',Lines:1,intoa:'ball',noDisplay:1};
                bc.remova = &{ delete re[kd] };
                # keep the %balls with the decoding Lines stuff
                $S = re[kd] ||= me&Reis,R,k,s,bc;
                $Ss = Sc&s;
                Ssy&decoder = S;
                Ss&keepy = 'decoder';
                if (l) {
                    # %pull%here=S, see below 
                    $L = me&push,R,[],S,'decode','hard';
                    # allow %their from ^ to look like l's %thing
                    ls&deliverer = L;
                }
                return S
            };
            
            each il Rs&pushish {
                $t = ls&here;
                # a remote %push, for some id
                $k = Rs&get_key_for(t);
                $s = localStorage[k];
                !s and ls&new = 1; continue
                
                Rs&arrange_decoder(k,s,l);
            }
        },'ift,D'],
        ['kvstore','4',&acgtRs{
            !Rs&pushering and return
            $i = 0;
            while (Rs&pushering[i]) {
                l = Rs&pushering[i];
                $t = (Rs&pushering_ball||[])[i] || ls&here;
                if (ls&hard) {
                    $S = tc&s;
                    # %here%ball must be the same
                    $still = ls&delivered && t == ls&delivered;
                    if (!still) {
                        i Rc&s/-#S.t
                        n ush  s:ush
                        ts&keepy = 'decoder';
                        ac(R,'pushing_z',l,'ball',t);
                        # becomes %push%their
                        ls&delivered = t;
                    }
                }
                else {
                    # must have a Lines done
                    !ts&ball || !ts&LinesN and throw "not %here=%ball%LinesN"
                    $good = ts&string && ts&string.length > 7
                    !good and throw "string dodgy"
                    # redecode, sets/does another ls&deliverer since lookup
                    #  checks it works,
                    #  %move%pushed%their gets what was pushed
                    $k = Rs&get_key_for(t);
                    Rs&arrange_decoder(k,ts&string,l);
                    localStorage[k] = ts&string;
                    # < check it's what %push knew about when it pushed
                    # < may contain several things to which you must link
                }
                i++;
            }
        },'ift,D'],
        #c further
        ['kvstore','6',&acgtRs{
            $N = me&ioty,R,'%ball';
            # hide innards
            each in N {
                ns&nofurtherDisplay = 1;
            }
            
            n fur  $selves:N,R %tfurther
        },'ift,D'],
        ['tfurther','3',&acgtRs{
            me&tsc,'tfurther','t','G';
            (Rs&boost||0) < 1 and return
            Rs&rowish = 1;
            s&bo = '2px dotted green';
            s&hue = 30;
            s&br = 0.4;
            # create a bunch more lookups
            
            each in Rs&selves {
                n $n.t  $self:n,R %Wirror
            }
        },'ift,D'],
        # sync localStorage -> webserver
        # use 24/NutIns' new G&t (G&ting) and it's W mode
        # from the thing receiver outran the thing providor
        ['Wirror','3',&acgtRs{
            s&hue = 80;
            me&domesticate,R;
            $h = Rs&self;
            !hs&dige and h = hc&s.y.decoder
            !h and throw "nodecoder"
            $k = h.t;
            #k = 't/iooiatal';
            $C = me&rollcounty,R,'tinging',{per:k};
            
            # persist a Question
            $Q = s&Q ||= G&Cye,[k,'',{of:'W'}];
            # which may throw async
            $ting = &Q{
                $r;
                try { r =  G&ting,Q }
                catch (er) { }
                # gets stuck in pushing mode:
                delete Qc&s;
                return r
            };
            $r = ting(Q);
            # has a Pull, with the got content or not
            # almost looks ballish, a decoded C at c&s
            # < remotism, G tendrils of causality hung, shaft utils
            # < know if its state can be guaranteed by some news agent,
            #   prefer to hear of rather than go looking for news
            #   digwaypoll
            $P = Qs&P;
            
            !P and return me&tsc,'pleasewait','...','G'
            $del = G&time,Ps&now;
            del > 16 and me&tsc,'delta','>'+del+'s','b';
            me&tsc,'here','@'+hs&dige,'G'
            
            #n so  $self:C,R %sun
            !Pc&s and me&tsc,'notexist','⧁','G'
            else
            !Ps&dige and throw "eiwer"
            else
            Ps&dige == hs&dige and me&tsc,'equal','=','G';
            Pc&String == hs&string and me&tsc,'equals','==','G';
            else {
                # we have a P for the remote's branch
                # make it look like a ball so it can %diff
                Ps&ball = 1;
                Ps&Lines = 0;
                Ps&string = Pc&String;
                $d = me&diffya,R,'upstream',h,P,{hue:90};
            }
            
            (Rs&boost||0) < 1 and return delete s&qh
            Rs&rowish = 1;
            #c objects/names to copy
            $M = [];
            # write obj/$dige for versioning $h (if you know %H history)
            m h.t  $s:hs&string,dige:hs&dige
            
            # move depended objects first
            each in hs&LinesN {
                $s = nc&s;
                !ss&H and continue
                $string = localStorage[ss&H];
                !string and throw "Nolocal"
                
                $L = me.cby(n,&n{ return n == h });
                $path = L.map(n=>n.t).join('/');
                
                m $path  $s:string,aka:path,dige:ss&H
            }
            $qh = s&qh ||= {};
            $abug = 0;
            each in M {
                ns&ok = 1;
                $doq = &ts{
                    $q = qh[t] ||= G&Cye,[t,'',{of:'W'}];
                    $r = ting(q);
                    $P = qs&P;
                    $wai = &s{
                        ns&ok = 0;
                        ta(s);
                    };
                    $ta = &s{
                        $st = t[0] == 'o' ? '6' : '';
                        me&tsc,'waiting',t+s,st .sc.dis = 1;
                    };
                    # has a pull, has a result (decoded by G&ting)
                    !P and return wai('..')
                    Pc&String == s and return ta('!')
                    # BUG stop it continually doing this later:
                    #   losing P on update?
                    #  just gets by if all updates succeed once
                    abug = 0;
                    Pc&String ? wai('>') : wai('*');
                    # write: add s to the question for next time
                    qc&s = s;
                    # next time
                };
                !nc&dige and throw "nodige"
                
                # a permanent object,
                #  excepting garbage collection (uninvented)
                #doq('obj/'+nc&dige,nc&s);
                
                # a place in the tree (Ha/Tothe/ThingthathasH)
                #   for some continuity in the git there
                nc&aka and doq(nc&aka,nc&s);
                
                if (!ns&ok) {
                    Rs&in_progress = 1;
                }
            }
            if (abug) {
                # see BUG ^
                n so  $self:C,R %sun
                return
            }
            Rs&in_progress and return
            # change what links it all together
            Qc&s = hs&string;
            
            delete Rs&Te.sc.boost
        },'ift,D'],
        
        
        #c haveth
        # interesting comment rubble from drained %pull:
        
        # t individuals in any place
        #     < new/gone similar -> moved
        # %haveth=to %ball vaguely
        # %other=from %ball specifica
            # once turned up, may have an in-t and an out-t
        # concat modulat 1-2?
            # < overall, has it pushed? 
            # < state change here/there click show in %ball
            #     that %ball's %pushed_ball will be historic,
            #         have sc.z %fix and etc
                # should show up as an item to push
                #   push/display change fairly easily
                # conversely, n.t only implodes:
                #   (sch_ballonlyt) -> G&t-ish, pull almost auto
                # needs some opposite to search with
            # wants to Rc&refs s now?
            # and the usual two-step confusible C-C nametag
        # < if engaged, %ball 5 notifies us?
                # engage drawing up of planes
                # becoming matter for idea/diff/apply
        
        # give idea of where on screen such ref is from here
        # eg up/prev/in = up, up/next/in = down
        # < up = left, in = right
        ['haveth','3',&acgtRs{
            if (!Rs&haveth) {
                n nohaveth  s:!
            }
            delete Rs&elvis;
            # draw an arrow between two R
            $we = me.cby(R,&R{ return Rs&cell });
            $th = me.cby(Rs&haveth,&R{ return Rs&cell });
            $direction = "v";
            each in we {
                $t = th[i];
                t == n and continue
                # path separates
                i == 0 and throw "different cells"
                $f = th[i-1];
                each il fs&z {
                    l == n and break
                    l == t and direction = '^'
                }
                break;
            }
            $d =
            n direction  $s:direction %fs:17,lh:0.05,hs:346
            
            $p = Ry&up;
            R.t == 'other' and direction == '^' and ps&upward = 1;
            
            if (!Rs&self) {
                # no yon %ball
                #R.t == 'self' and throw "self no self"
                R.t == 'self' &&
                    n ohno  s:!
                delete ds&hs; # green
            }
            # give other bigger arrow
            dc&s = dc&s == '^' ? '▲' : '▼';
            # < n should type styles into number etc
            R.t == 'other' and ds&fs = (ds&fs*1)+7
            # ◀ ▶
        },'ift,D'],
    ] };
    #c Slep-landscape
    # R-ing that maps/checks the data underlying Ring
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        delete rc&refs;
        delete rc&inC;
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    me.leplandscape = &acgtRpc{
        c ||= {};
        $uptil = &Rkd{
            $N = me.cby(R,&s{ return s == oR || s.sc[k] });
            d and return N
            return N.length
        };
        $oR = R;
        $firstRthing = p;
        
        $r = Ron(R,p.t,pc&s,0,&Rs{
            if (Rc&d == 0) {
                Rs&Rthing = firstRthing;
                Rc&dl = 99;
                Rc&nl = 4444;
                delete Rc&dupl;
            }
            Rc&N.push(R);
            $p = Ry&up;
            # 2
            if (Rs&Rthing && 0) {
                # GONE: diving Rthings first
                #   makes landscape dependent on Rthings
                # < diving Rthings and data in parallel
                #   Resonance = streaming Ring+
                $r = s;
                me&Ret,R,{t:'cs',s:rc&s};
                each in rs&z {
                    # not slep/other
                    n == oR and continue
                    # wake children with pc&s
                    $z = me&Ret,R,{t:'z_'+n.t,s:n,Rthing:1};
                    # depth first
                    me&ing,'',z;
                }
                return
            }
            elsif (typeof s == 'object' && s != null) {
                if (s.constructor == Array) {
                    Rs&sym = '[';
                }
                elsif (isC(s)) {
                    Rs&Cthing = 1;
                    Rs&sym = 'C';
                    if (s.y == s) {
                        Rs&Athing = 1;
                        Rs&sym = 'A';
                        s.1 == s and Rs&sym = 'J';
                    }
                    else
                    s.y.R && s.y.R == s and Rs&sym = 'R';
                }
                else {
                    Rs&sym = '{';
                    if (R.t == 'y' && ps&Cthing) {
                        Rc&shrinky = 1;
                    }
                }
            }
            else {
                # 4 at a value
                Rs&text = typeof s == 'number' ? ''+s
                    : typeof s == 'string' ? '"'+s
                    : ki(s);
                $into = Rs&text.split("\n");
                into.length > 1 and Rs&text = '"'+into[0]+'..dige:'+dig(Rs&text);
                return
            }
            # 4 or a thing we can feel out way to
            $pp = py&up;
            if (c.early) {
                # no origin Rs beyond first
                # download them from history
                !Rs&Rthing and me&rollbs,R,'Rthing'
            }
            if (Rs&Rthing) {
                $Rdist = 1;
            }
            else {
                $N = uptil(R,'Rthing',1);
                $Rthing = N[0];
                # %Rthings are the origin R
                #   have c&s, we will find
                $or = Rthings&Rthing;
                !or and debugger;
                $ri = orc&refs.indexOf(s);
                if (ri >= 0) {
                    # some R had this?
                    $refR = orc&refR[ri];
                    each ir refR {
                        # inside the last one?
                        r.y.up == or || r.y.up && r.y.up.y.up == or and break
                        r = null
                    }
                    if (r) {
                        Rs&Rthing = r;
                    }
                }
                $Rdist = N.length+1;
            }
            
            
            #c 5 size
            # near a data fog valve
            Rs&plain ||= '';
            #Rs&plain += "RD:"+Rdist
            # apply a schema,
            # to decide whether to 6
            
            $rl = Rs&refR;
            if (rl) {
                $l = rl[0];
                Rs&plain = 'dup:'+me&nampup,l,R;
                # other side was limited, try express it here
                if (!Rs&ltd) {
                    if (ls&ltd) {
                        # do here instead
                        delete Rc&nofurther;
                        # be the main instance
                        Rs&refR.reverse();
                    }
                    else {
                        Rs&ltd = '<'
                    }
                }
            }
            
            #   unless very near R
            if (!Rs&ltd && Rdist > 2) {
                # A.I
                ps&Athing && Rs&sym == '{' && R.t == 'I' and Rs&ltd = '>I'
            }
            if (!Rs&ltd && Rs&sym == '{') {
                # dom elements
                # < any .constructor.name != 'Object'
                if (s instanceof Element) {
                    Rs&ltd = '>'+(s.constructor.name||'Element')
                    Rs&sym = '<>';
                }
            }
            if (!Rs&ltd && Rdist > 3) {
                # one layer after A or y/%Cthing
                ps&Athing and Rs&ltd = '>A'
                else
                ps&Cthing && Rc&shrinky && pc&shrinky and Rs&ltd = 'y>'
            }
            
            # or farouts
            if (!Rs&ltd && (Rdist > 4 ||
                Rdist > 3 && uptil(R,'Cthing') > 3)) {
                Rs&ltd = '>';
            }
            # if limited, describe the edge of the pile
            if (Rs&ltd) {
                if (Rs&Cthing) {
                    Rs&text = ':'+s.t;
                }
                elsif (Rs&sym == '{') {
                    $ks = haks(s);
                    $limit = 50;
                    Rs&text = ks.length > limit+5 ?
                        ks.slice(0,limit-1).join(',')+'..'+ks.length
                    : ks.join(',');
                }
                elsif (Rs&sym == '[') {
                    Rs&text = 'x'+s.length
                }
                return
            }
            
            # 6 more values
            $l = haks(s);
            each ik l {
                $v = s [k];
                me&Ret,R,{t:k,s:v}
            }
        });
        
        #c select moving parts
        $M = [];
        $talk = [];
        $seen = [];
        # in z order
        $gump = &R{
            #Rc&N.indexOf(R) < 0 && R.t == '1' and debugger;
            #R.t == 'edgga' and debugger;
            Rc&N.indexOf(R) < 0 and return Rs&landscape = "NOTIN: "+R.t
            seen.indexOf(R) >= 0 and throw "gumpR seen"
            seen.push(R);
            
            $se = R.t+" "+(Rs&sym||'');
            # text == firstline + dig if \n
            Rs&text != null and se += ''+Rs&text
            Rs&plain != null and se += ' '+Rs&plain
            Rs&ltd and se += ' '+Rs&ltd
            
            Rs&landscape = 
            Rs&portrait = se;
            
            each in Rs&z {
                gump(n);
                
                $is = (ns&landscape||"NOTHING:"+n.t);
                $at = is.split("\n")
                    .map(&s{ return "  "+s })
                    .join("\n");
                Rs&landscape += "\n"+at;
            }
            $ind = [];
            while (ind.length < Rc&d) { ind.push("  ") }
            talk.unshift(ind.join('')+se);
            
            $b = Rc&b;
            if (b && Rs&Rthing) {
                if (bs&landscape != Rs&landscape) {
                    M.unshift(R);
                }
                else {
                    Rs&sleepy = 1
                }
            }
        };
        gump(r);
        
        # put in top-down order
        rs&moving = rc&N.filter(n => M.indexOf(n) > -1);
        # for the origin
        rs&moving = rs&moving.map(n => ns&Rthing);
        rs&moving = M;
        rs&talk = talk;
        
        me&safer,r;
        
        return r;
    };
    
    #c replace ravel with Doming and Display2,
    #   once tests...
    me.Slepingness = &acgtR{ return [
    =pod
        # if Rs&Te.c then .yReal = R; ~Te
        ['Cany','41',&acgtRs{
            $Te = Rs&Te;
            !Te || !Te.c and return
            Te.y.Real = R;
            R.t != 'notC' and return
            me&tsc,'Te','Te','6';
        },'D'],
        ['ball','41',&acgtRs{
            sy&Real and me&tsc,'Real','R','g'
        },'ift,D'],
    =cut
        # Display 27 gets tangulate,
        # they Ring ov=3 before it continues
        # TheirSleepStrategy 28 gets this intel
        ['slep','3',&acgtRs{
            s&fs = 14;
            s&bo = '1px dotted green';
            me&tsc,'slep-ing','slep','6';
            
            $p = Ry&up;
            $b = Rc&b;
            !b and return me&tsc,'isnew','*','g'
            $re = me&leplandscape,R,p;
            Rs&sleplandR = re;

            if (res&sleepy) {
                me&tsc,'maysleep','---'+ps&ci+'/'+Rs&ci,'g';
                (Rs&boost||0) < 0 and return
                
                #ps&sleeping = R; Rs&theysleep = 1;
                
            }
            (Rs&boost||0) < 1 and return
            # here we do the entire Ceeing instantly
            #  in general, knowing if the A is for a queue or for right now
            #me&Reis,R,'Cit',0,{t:'splepl',self:p,Cit:1};
            me&Reis,R,'Cray',p;
        },'ift,D'],
        
        # things' sleepcheck has an answer
        #   may be some scenario-centric reasoning/management still,
        #   but mostly the sleepscheme and the types involved know all
        ['sleeping+Cee','28',&acgtRs{
            $l = Rs&sleeping;
            $b = Rc&b;
            # keeps history of unhad children
            $ig = [];
            each iX bc&X.x {
                each in X.z {
                    X.newz && X.newz[i] and ig.push(n); continue
                }
            }
            # and links to their last selves
            each in bs&z {
                ig.indexOf(n) >= 0 and continue
                Rs&z.push(n);
            }
            
            Rs&nofurtherDisplay = 1;
            # Display
        },'ift,D,sleeping'],
        ['sleeping+ball','28',&acgtRs{
            me&rollbs,R,'string,dige';
            # + make me.sch_didLines accept %sleeping !%Lines
            
        },'ift,D'],
        
        ['slep','7',&acgtRs{
            Rs&theysleep and return
            $oR = R;
            $p = Ry&up;
            # we may not need to get here if res&sleepy
            #   
            
            # leave one slep/$R, or early will only trust early's map
            $re = Rs&sleplandR;
            #re and me&cancelRbitX,re;
            
            $r = me&leplandscape,R,p;
            
            # scan happens early and late:
            # late first, Long/** is awake, scan boosted around Rthings
            # early thence, scan boosted from before
            
            (Rs&boost||0) < 2 and return
            n slepe  $self:r,R %Reis:Cit,set:Cit
            n pare  $self:p,R %Reis:Cit,set:Cit
            4s&sleperp = p;
            $l = rs&landscape.split("\n");
            #n lands  $self:l,R %sun
        },'ift,D'],
        ... me&Actingness ,
    ]};
    me.cancelRbitX = &acgtR{
        $X = Rc&X;
        $ri = X.z.indexOf(R);
        ri < 0 and throw "R not in Xz"
        X.z.splice(ri,1);
    };
    #c rovo
    me.rovo = &acgtR{ return [
        ... me&DisplayTwoness ,
        #... me&Displayingness ,
        ... me&Rscinsideness,'rovo' ,
        ... me&Ballingness ,
        ... me&Slepingness ,
        ['ning','3',&acgtRs{
            Rs&rowish = 1;
            $p = Ry&up;
            $D = pc&s;
            me&tsc,'arp','ning:'+D.t;
            
            n Citula  $self:sc&s,R %Reis:Cit,set:Cit
            
            if (D.t == 'seen') {
                # to deal sleep patterns
                n Tool  R %Tool
                if (4s&modeen) {
                    #4s&modeen = me&yfuture,4s&modeen;
                    n modeen  $s:4s&modeen,R %sun
                }
                # the other thing to sleeperate
                n vising  $s:4s&elvisory,R %ball
            }
            
            if (D.t == 'ajaying') {
                n vising  $self:A,R %Reis:Cit,set:Cit
                
                $p = 4s&sleperp;
                p &&
                n pare  $self:p,R %Reis:Cit,set:Cit
            }
        },'ift,D'],
        # tray of icons to do tricks
        ['Tool','3',&acgtRs{
            Rs&rowish = 1;
            me&rollbs,R,'mode';
            Rs&modeen = &acgts{
                $mode = s.t;
                4s&eloncer = &acgts{
                    # the above is already thus
                    $r = me&anRfromelC,s;
                    # Elvisorise it has R to do in its Tes&z
                    $poi = me&introqua,r,{Rz:1};
                    if (!poi) {
                        ~failtoel: r.t
                        4s&modeen = r;
                        return;
                    }
                    $n = G&Cye,[mode,6,{R:1}];
                    n.sc[mode] = 1;
                    i $poi/$n
                    # bug:
                    T.wake = 1;
                };
                ~picking: mode
            };
            n t  $s:R.t %hs:789
            n slep  s:● %fs:22,medo:modeen
            
             #n $Rs&mode  $s:Rs&sele,R %sun
            #n stop  s:■
            #n redo  s:◀
            # wander?
            n play  s:▶ %fs:22
        },'ift,D'],
        
    ] };
    me.anRfromelC = &acgts{
        !isC(s) and throw "notC";
        $r = sy&R == s ? s :
            # Display's C
            s.y.Display;
        !r and throw "no idea";
        # out of some M (which get R's each under Display)
        rs&modulat and r = ry&up;
        # out of Display
        ry&origin and r = ry&origin;
        return me&yfuture,r
    };
    me.modeen = &acgts{
        $R = me&anRfromelC,s;
        Rs&modeen and return Rs&modeen(A,C,G,T,s);
        ~NOTHING: R.t
        4s&modeen = R;
    };
    
    #c DisplayTwo-RbitX
    me.DisplayTwoness = &acgt{ return [
    =pod
    
    Receive the past (V) and make a now (X)
    
    # X is the space index...
    #  of X.x.$bit = X (inwards)
    #     X.z = [ R nodes
    
    cX/V is carelessly inherited
     toplevel R=I, r=C, makes IcX
    
      Re gives children:
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
      
    so
      
      the named self resolves in 17:
        
    =cut
        ['RbitX','17',&acgtRs{ 
            $bit = R.t;
            # X goes inside
            #  RcX = Rs&X = {} at Resurrect
            #   Re inherits us RcX and RcV,
            #    we simply move into the name we are
            $X = Rc&X ||= {};
            X.top ||= {};
            X.x ||= {};
            X = Rc&X = X.x[bit] ||= {top:X.top};
            X.x ||= {};
            X.z ||= [];
            X.z.length and 'dups allowed'
            $i = X.z.push(R);

            # someone gave you V that used to be X
            $V = Rc&V && Rc&V.x && Rc&V.x[bit] || {};
            # X (new) must hold which V (old) z we're up to
            $b;
            if (V && V.z && V.z.length) {
                b = V.z[i-1];
                bc&X != V and throw "bcX != V"
                # let yfuture find b->R if not commit
                # not for anything else
                V.newz ||= [];
                V.newz[i-1] = R;
            }
            # care to leave history
            # = V ? me&RbitXtend,V : {};
            Rc&V = V;
            if (b) {
                Rc&b = b;
                # no further back
                bc&b and bc&b;
            }
        },'if:RcX'],
    # and is supposed to be completed by 4
    # < by the time it is 4?
    # < decide moves by new/gone pairs with similar appearance
    #   the thing producing changes may be willing to help
        ['RbitX','4',&acgtRs{ 
            # atoms in locations, another lives
            $N = Rc&N;
            each iR N {
                $b = Rc&b;
                $s = Rc&s;

                $V = Rc&V;
                $X = Rc&X;
                if (V) {
                    each kv V.x {
                        $x = X.x[k];
                        if (!x || x.z.length < v.z.length) {
                            Rs&gone ||= [];
                            Rs&gone.push(... v.z.slice(x ? x.z.length : 0));
                        }
                    }
                }
                Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
                !b and me&chR,R,'new!'
            }
        },'if:h'],
    # commits the wiring of past to future,
    #  almost at the same time I will
        ['RbitX','9',&acgtRs{
            $N = Rc&N;
            each iR N {
                $b = Rc&b;
                !b and continue
                by&future = R;
                # no further back
                !bc&b and continue
                b = bc&b;
                delete bc&b;
            }
        },'if:h'],
    #c DisplayTwo-TX
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            # GOING
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 888;
            Rc&dl ||= 35;
        }],
        ['Displayingness','27',&acgtRs{
            Rs&elvis = 'Gazel';
            # somewherish
            !1s&Te and return;
            # posits for R
            me&Tie,R;
            # mean variously
            me&playstulate,R;
            me&boostulate,R;
            me&tangulate,R;
        },'D'],
        # data dump R%sun
        ['sun','3',&acgtRs{
            $c = {task:'Cray'};
            Rs&sun == 2 and c.refpool = 1
            Rs&dupup and c.dupup = 1
            me&Reis,R,R.t,null,c;
        },'ift'],
        
        ['Displayingness','9',&acgtRs{
            Rs&noDisplay and return
            $the = me&Timethe,'Display';
            $d = me&Display,R;
            the();
        },'if:h'],
    ] };
    me.tangulate = &acgtR{
        $Te = Rs&Te;
        !Te and return
        if (Tes&Rz) {
            # just before R starts creating itself
            #  some forerbrain addons create themselves first
            $RN = Tes&z.filter(r => rc&R);
            each in RN {
                n $n
            }
            T.Rq = {inside:R,ov:3};
        }
    };
    #c Displayingness
    me.Displayingness = &acgt{ return [
        ['RbitX','17',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:h'],
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            # GOING
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 888;
            Rc&dl ||= 35;
        }],
        ['Displayingness','3',&acgtRs{
            Rs&elvis = 'Gazel';
            !1s&Te and return;
            # ^ is somewherish. posits and deposits.
            me&playstulate,R;
            me&boostulate,R;
            me&tangulate,R;
        },'D'],
        # data dump R%sun
        ['sun','3',&acgtRs{
            $c = {task:'Cray'};
            Rs&sun == 2 and c.refpool = 1
            Rs&dupup and c.dupup = 1
            me&Reis,R,R.t,s||Rs&self,c;
        },'ift'],
        
        ['Displayingness','9',&acgtRs{
            Rs&noDisplay and return
            $the = me&Timethe,'Display';
            $d = me&Display,R;
            the();
        },'if:h'],
    ] };
    # 1s&Te/Rs&Te carry centralised namewires from Elvising
    # so set value can be reintroduced
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        1s&Te and me&Tie,R,'boost';
        !Rs&boost and return
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : '↯';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
            z.t += hu;
            i++;
        }
    };
    me.playstulate = &acgtR{
        1s&Te and me&Tie,R,'play'
        !Rs&play and return
        n playing  s:▶
        # look up what to do
        $N = me.cby(R).reverse();
        each ir N {
            $p = rs&playsheet;
            !p and continue
            each kc p {
                !R.sc[k] and continue
                c(A,C,G,T,R);
                return
            }
        }
        n noplaysheetupwards  s:(buthow?) %fs:6
    };
    # GOING
    # applies Cee directly
    me.Cray = &acgtRs{ return [
        ... me&Displayingness ,
        ['Ceetop','12',&acgtRs{
            Rs&Cee ||= 1;
        },'if:h'],
        ... me&Ceeingness,
    ] };
    
    #c Cit
    =head2
    dive into the result after it was made,
      showing output and crawling into the details:
        wants to be pointed to not coded
    < fast pointing to the data you want,
        elvising into this Reis without its enclosing A
          resetting the 4s frame wait
    < to create new %doings to W=Cit that check those points
    see XVer for during
    =cut
    me.Cit = &acgtR{ return [
        ... me&DisplayTwoness ,
        ... me&Ceeingness ,
        ... me&Slepingness ,
        ['Cit','13',&acgtRs{
            # subverted refs dedup
            s = Rc&s ||= Rs&self;
            !Rs&ot and Rs&ot = R.t;
            isC(s) and R.t = s.t
            Rs&ot == R.t and delete Rs&ot
            
            $p = Ry&up;
            ps&Cit || ps&Citop and return
            Rs&Citop = delete Rs&Cit;
            # allow %Cit to have %play 
            #  for yon %Cee to sprawl to C
            Rs&playsheet = {Cit: &acgtR{}};
        },'ift'],
        # the top Cit looks it over more
        ['Citop','6',&acgtRs{
            $b = Rc&b;
            $p = Ry&up;
            ps&ok and Rs&ok = 1
            # ok-ing overthing should calm...
            Rs&ok && b && !bs&ok and Rs&boost--
            
            # clicking in here should localise refresh
            if (0 && !Rs&oldR) {
            Rs&elvisrefresh = &acgtc{
                # c.Te = new Rs&Te, prevents looking for it
                c = ex(c||{},Rs&rec);
                c.directDisplay = 1;
                c.oldR = R;
                # < transact with history to replace this thing
                #   as opposed to piling up a whole new X
                $p = Ry&up;
                # now 1=Fourier, make it think we're near Teing:
                1s&Te = 'ha';
                # works once:
                pc&b = p;
                $r = me&Reis,Ry&up,'Cit',null,c;
                #debugger;
            };
            }
            
            
            if (Rs&directDisplay) {
                !Rc&b and throw "no history to Display over"
                ~Historific
            }
            
            s&bo = '2px dotted blue';
            s&hue = 30;
            s&br = 1;
            s&ma = 0.3;
            s&pa = 0.3;
            #s&float = 'right';
            !Rs&Te || !Rs&Te.c and s&fs = 6;
            
            if (0 && !isC(s)) {
                me&tsc,'notC','Cit:notC','d'
                n notC  $s:s,R %Cee,dupup
                return
            }
            
            $pp = py&up;
            if (pps&spondo) {
                if (ps&TeImplant) {
                    Rs&Implant = 1;
                    $Te = ps&TeImplant;
                    if (!Rs&Te || !Rs&Te.sc.Implanted) {
                        $el = me&introqua,R,{Implanted:1};
                        i $el/$Te
                        Rs&Te = el;
                    }
                }
            }
            n $R.t  $s:s,R %Cit,fromsitop
            
            !isC(s) and return
            $WR = sy&R;
            if (WR) {
                $on = WRs&on;
                if (on) {
                    n yRson  $self:WR,R %displayon,maybe
                }
            }
        },'ift,D'],
        ['TeImplantation','3',&acgtRs{
            # %ball?
        },'ift,D'],
        # continuity markers
        ['Cit','6',&acgtRs{
            $b = Rc&b;
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        #c Cit
        ['Cit','3',&acgtRs{
            Rs&Cit = 3;
            $Cit = &tsc{
                $n =
                n $t  $s:s,R
                ex(n.sc,ex(c||{},{Cit:1}));
                return n
            };
            # title 0
            $doot = &d{
                $tee = (Rs&ot||R.t);
                d && tee == R.t and return
                $v = me&tsc,'ot',tee,'q';
                vy&cv = 0.01;
                vs&deco = 1;
                doot = &{};
            };
            Rs&ot || Rs&tiny and doot()
            $scan = Rs&scan = me&scan,s;
            scan.is == 'C' && sy&R == s and scan.is = 'R'
            scan.is == 'C' && ss&W and scan.is = 'W'
            Rs&ma and s&ma = Rs&ma
            
            $p = Ry&up;
            $pp = p && py&up;
            if (ps&Citop) {
                if (Rs&play && !ps&Implant) {
                    # defer to W:Das
                    $nah;
                    $name = 'run step doing'.split(' ').map(&t{
                        $r = me.cby(R,&r{ return r.sc[t] })[0];
                        !r and return nah = 1
                        return r.t
                    }).join('/');
                    if (!nah) {
                        name += "'s "+R.t;
                        $D = G&Cye,[name,'',{R:R,Te:Rs&Te}];
                        4s&DasN.push(D);
                        # causes a %spondo to %Reis again elsewhere
                        return;
                    }
                }
            }
            
            $wastiny = Rs&tiny;
            Rs&boost > 0 and delete Rs&tiny
            if (Rs&kvey) {
                each kv s {
                    $c = {ma:0.1};
                    c.tiny = 1;
                    Cit(k,v,c)
                }
                me&domesticate,R
                Rs&tiny = 1;
            }
            if (Rs&tiny) {
                Rs&dis and s&dis = 1
                return
            }
            elsif (wastiny) {
                Rs&dis = 1
            }
            if (scan.sym == '[' && Rs&boost < 2) {
                n open 4 s:[ %hs:489
                
                each in s {
                    Cit('['+i, n, {tiny:1,ot:R.t});                
                }
                #n close 7 s:]
                return
            }
            if (Rs&istw) {
                each kv s {
                    $c = {};
                    Rs&tiny and c.tiny = 1
                    Cit(k,v,c)
                }
                return
            }
            
            if (!scan.C && ps&Citop && !Rs&boost) {
                n $R.t  $s:s,R %Cee,dupup
                return
            }
            
            # title 1
            me&domesticate,R
            $p = Ry&up;
            !Rs&dis and delete s&dis;
            
            #n swhu  $self:scan,R %sun
            
            if (scan.C && (Rs&boost||0) < 1) {
                #n yes  s:y
            }
            elsif (scan.C && Rs&boost < 2) {
                # several C's with some interesting stuff in
                # < look for anomalies
                #   generate maps to call things
                if (scan.is == 'R') {
                    $hem = {kvey:1,ma:0.3,dis:1};
                    Cit('y',s.y,hem);
                    Cit('c',s.c,hem);
                    Cit('sc',s.sc,hem);
                }
                else {
                    sy&R and Cit('yR',sy&R,{Rit:1,dis:1});
                }
            }
            else {
                doot(1);
                # some strangeness or the thing we're interested in
                s&dis ||= 1;
                n $R.t  $s:s,R %Cee,dupup
            }
        },'ift,D'],
        #c as well as Cit-ing, shade and understand A
        ['Rit','3',&acgtRs{
            !sc&N and throw "Rit !R"
            $I = sy&I;
            if (I && !Rs&isI) {
                n yI  $s:I,R %Rit,Cit,isI
            }
            if (Rs&isI) {
                # see the big picture
                $head = sc&head;
                if (head) {
                    n chead  $s:head,R %Cit,istw
                }
            }
        },'ift,D'],
        
        ['displayon','3',&acgtRs{
            me&tsc,'displayon','D','G';
            (Rs&boost||0) < 1 and return
            Rs&rowish = 1;
            s&bo = '4px dotted green';
            s&hue = 30;
            s&br = 0.4;
            ac(R,'down',s||Rs&self);
        },'ift,D'],
    
    ] };
    
    #c Cee the truth (with folded edge)
    # reliable expression of data as it is
    # < json-compatible copy/paste
    me.Ceeingness = &acgtRs{ return [
        ['Cee','3',&acgtRs{
            $Cee = &tsc{
                c = ex(c||{},{t:t,s:s,Cee:1});
                return me&Ret,R,c
            };
            $scan = Rs&scan = me&scan,s,R;
            
            $h = Rc&N[0];
            $P = me.cby(R,&r{ return !rs&Cee });
            $p = R.y.up;
            $it = P.shift();
            # above %plays to open all non-C
            ps&play || ps&sprawling and Rs&sprawling = 1
            scan.C and delete Rs&sprawling;
            if (Rs&sprawling) {
                delete Rs&isgk;
                Rs&rowish = 1;
                #Rs&sprawling and delete Rs&sprawling; Rs&isgk = 1;
            }
            $depth = P.length;
            $p = R.y.up;
            
            
            
            !Rs&dupup and me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && depth > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
                Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                me&gkness,R;
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = Cee(k, s [k], {isgk:1});
                i == 0 and ns&ml = 1
            }

            each ik ks {
                Cee(k, s [k], {rowish:1});
            }
            
            Rs&boost > 0 && depth == 1 and Rs&runny = 2

            
            if (scan.C && (Rs&runny > 1
                ||
                (Rs&runny || depth == 1) && sy&tv && ss&z && !ss&J
                )) {
                each in ss&z {
                    # can zoom around Cs if ^
                    Cee(i, n, {rowish:1,runny:1});
                }
            }
        },'ift'],
    ] };
    #c Ceey
    # exit the entrance
    #  put label/C.t (not always the same)
    #  C's cell wall
    me.domesticate = &acgtR{
        # 1
        $M = me&Mw,R,'traw';
        $t =
        m t 1 $s:R.t %fs:13,hs:288
        if (Rs&fornt) {
            # coming off the grounded C, name after that C
            $proc = "|"+R.t;
            m into 118 $s:proc %fs:11,hs:267,bgh:230
            tc&s = Rs&fornt;
            ts&bob = '1px dotted white';
        }
        
        # types at s
        $scan = Rs&scan;
        !scan and return
        
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955
        
        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    };
    me.bagatagage = &acgtR{
        $scan = Rs&scan;
        $ks = scan.ks || [];
        if (scan.C) {
            ks[0] != 't' and debugger;
            ks.shift();
            $s = Rc&s;

            $M = me&Mw,R,'.t';
            scan.is == 'A' &&
                m tofA 19 s:: %ls:-0.2

            m t 2 $s:s.t %deco,fs:15

            if (scan.is == 'A') {
                $cv = s.cv+'';
                cv[0] == '0' and cv = cv.slice(2);
                cv = '@'+cv;
                m cv 21 $s:cv %ls:-0.1,hs:339
            }
        }

        if (scan.modu) {
            each in scan.modu {
                n.t == 'weirdkeys' and continue
                $M = me&Mw,R,'modu:'+n.t;
                me&Modu,[n],M;
            }
        }
    };
    # squished lump of thing
    me.gkness = &acgtR{
        $M = me&Mw,R,'traw';
        
        # make block,inline have same indento
        $p = Ry&up;
        $iN = (ps&z||[]).indexOf(R) - 1;
        $f = iN >= 0 && ps&z[iN];
        f && fs&rowish and s&ml = 1
        
        s&fs = 7;
        m sym 12 not
        $pow = 2;
        Rs&boost and pow = 4;
        $string = ki(Rc&s,pow);
        $limit = 100;
        Rs&boost > 1 and limit *= Rs&boost;
        if (string.length > limit) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    };
    # regroup Cee's children (before they're Cee'd)
    me.wktion = &acgtRs{
        $wk = s;
        s = Rc&s;
        $p = R.y.up;
        if (p && ps&scan && ps&scan.C) {
            if (R.t == 'c') {
                if (wk.indexOf('sip')>=0) {
                    wk = wk.filter(n => n != 'ip' && n != 'sip');
                    $fa = 4s&famous;
                    $slip = s.sip;
                    $M = me&Mw,R,'sip';
                    # tradeoff between things
                    if (fa) {
                        each in fa {
                            s.sip.indexOf(i) != 0 and continue
                            m famous  $s:n.t %deco,fs:7,hs:999
                            slip = '.'+s.sip.substr(i.length+1);
                        }
                    }
                    m sip  $s:slip %fs:7,hs:999
                }
            }
        }
        return wk
    };
    #c R ing , collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        # a way to depth-first, see slep
        Rc&N && Rc&N.indexOf(R) > -1 and return
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        if (s && typeof s == 'object') {
        # dedupe/limit objects already in this pool
        $ri = Rc&refs.indexOf(s);
        if (ri < 0) {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            RN.push(R);
            # in this pool
            $RhN = RN.filter(r => h && rc&N == hc&N);
            $nvm;
            if (Rs&dupup) {
                # when -known also -unknown inside itself
                RhN.indexOf(Ry&up) >= 0 and nvm = 1
            }
            if (!nvm) {
                $dupl = Rc&dupl || 0;
                if (RhN.length > dupl) {
                    limit('dup');
                    Rc&nofurther = 1;
                }
                else {

                }
                !Rc&nofurther and limit('dub')
            }
            # < to know circular links, converge
        }
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.indexOf(R) == -1 and Rc&N.push(R)
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X (inwards)
    #     X.z = [ R nodes
    #
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    # at Display 17
    me.RbitX = &acgtR{
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    # at Display 4
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;

            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # the awkward toplevel
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        Ry&R = Ry&I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
        return r
    };
    
    # new R pool
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task ||= r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                if (h && hs&joinR) {
                    rc&N = hc&N;
                    # < avoid Ringing on the way out of Reis
                }
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    # new R, same pool
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        if (c.refpool) {
            # we become a pool of refs
            #  something about A.1-9
            #   the magnitude of a distance
            $p = delete c.refpool;
            if (p != '1') {
                !isC(p) || !p.y.R and throw "refpool !R"
                Rc&refs = pc&refs;
                Rc&refR = pc&refR;
                
            }
            else {
                Rc&refs = [];
                Rc&refR = [];
            }
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    

