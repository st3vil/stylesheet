Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    #c Jay
    me.J = &acgts{
        # do a J
        $C = typeof s == 'string' && [s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        $j = G&n,C,5;
        #1c&newosc && j.2 == A.1 and j.1.c.newosc = 1
        C = jc&s;
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        
        if (c&M) {
            $cv = 0.3;
            $z = j.ground.sc.z;
            each in c&M {
                n.y.cv and continue
                # suggest y.cv of 30i+
                n.y.cv = G&desca,cv,8;
                cv += 0.001;
                z && z.indexOf(n) >= 0 and continue
                # do not re-C the C, or dups that == will in M occur
                #G&n,n;
            }
        }
        
        me.osc(j,C,G,T);
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        A&o = 'ind';
        # etc
        #debugger;
        
        =pod
        n A4sc  $s:A.4.sc
        n A4on  $s:A.4.on
        n A  $s:A
        n Aup  $s:A.up
        n Aupup  $s:A.up.up
        n Aon  $s:A.on
        n AonA  $s:A.on.A
        n AonA1  $s:A.on.A.1
        n A1  $s:A.1
        =cut
        
        // tayt #!!
        #=cut
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        n tongs 5 s:lovelyyyy
        n tongs 6 s:lovelyy
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'Fourier';
        
        me&J,'edges';
    };
    me.Ja.Fourier = &acgt{
        A.3 = A.1;
    
        me&J,['Fourier','-od',{s:A.4}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # wants to leap onto new osc gear (1c&newosc)
    me.Ja.edges = &acgt{
        A.3 = A.1;
        n t  $s:C.t %fs:20,hs:594
        #A&o = 'ind';
        1c&newosc = 1;
        s&blr = 10;
        
        n things 2
        
        if (!1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicine
            Skys the autumn grey of a lonely wren

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    z = z[w] ||= {};
                }
            }
            1s&es = s;
        }
        $s = 1s&es;
        
        n vedge 3 s:vedge %fs:23,hs:594,dis
        
        me&J,['expr','-go',{s:s}];
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising}];
    };
    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    # data sift/unpack/classify/pointerise with osc
    # be yinyander
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        1c&newosc = 1;
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be =
            me&J,['lookfortheedge','-globe',{s:s}];
        # and showing output
        me&J,['lookatlooking','-od',{s:be}];
        $j = bes&J;
        $s = jc&o.lookfortheedge;
        $see = sc&R.map(s => s.t);
        #me&J,['andJco','-od',{s:sc&chR}];
        #me&J,['andJcp','-od',{s:sc&R.slice(-1)[0]}];
        
        each ic sc&chR {
            me&J,['ch:'+i,'-od',{s:c}];
        }
        each iR sc&R {
            $sc = {};
            Rc&d and sc.ml = Rc&d
            me&J,['isC'+i,'-od',{s:Rc&s},sc];
            R.t == 's ' &&
            me&J,['isR'+i,'-od',{s:R},sc];
        }
        
    };
    #c facilitate_daydream
    #  c&s should -> s&z til explains
    me.Ja.globe = &acgts{
        n t  $s:C.t %fs:20,hs:594
        1c&newosc = 1;
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        #A&o = 'Glaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        n looks  $s:ki(s)
        return;
        1s&counting ||= 1;
        
        1s&counting++;
        1s&counting > 5 and 1s&counting = 0;
        1s&counting > 3 &&
        n counts  s:counts
        s&medo = 'cra';
    };
    me.Glaze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        ~Glaze: A.1.t, ki(C)
    };
    
    # old thinger
    me.Ja.gobe = &acgts{
        n t  $s:C.t %fs:20,hs:594
        #1c&newosc = 1;
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        A&o = 'Gaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        s&medo = 'cra';
    };
    me.cra = &acgtD{
        $el = c&path_yon.slice(-1)[0];
        #debugger;
        #4s&elvising = C.c;
        ~etc: $(el).text();
    };
    
    #c Eightwo
    # osc again with separate oc-cu-lus ness,
    # s is the J, recurring C.t
    me.os = &acgts{
        # figure A-C and s
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
        }
        s ||= A;
        # the J is s
        s&J and s = s&J;
        # the s has an o.$page, A&V points to previum
        # > two indexes (o/C.t + V/R.t)
        #  for the thing on its mind...
        A&V ||= sc&o && sc&o[C.t];
        # was: $Y = 1c&on && 1c&on.A || 1c&osc;
        A&o ||= c&o || 'Carz';
        !me[A&o] and throw "No os me."+A&o
        me[A&o](A,C,G,T,s);
        
        sc&o ||= {};
        sc&o[C.t] = A;
    };
    # s collects pile of reasons for Rs&cha
    # < layered change, to phases
    me.chR = &acgtRs{
        Rs&cha = 1;
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    
    me.Carz = &acgts{
        # C is the first thing
        # A&s is C
        # A&V previum A
        
        # A&R lists Rs
        # A&X indexes Rs
        # R&V index climbing Rs
        # R&b previum R via R&V's down A&V&X...
        A&R = [];
        $c = &sR{
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
            me&RbitX,s,R;
            
            # generate furthers - notices J as yA1 different
            me&CaR,s,R;
        };
        $R = me&ing,C,c;
        
        # 5 X notices leavings
        me&RbitXgonism;
        
        # 6 details
        #  may generate more R
        me&CdaR;
        
        # 7 display part
        me&Cavon;
        # 8 unify
        me&Cupon,s;
    };
    
    #c mid C os, take to details
    me.CdaR = &acgts{
        # run the set of R into another Ring
        # for C universals
        # resolving and diving like diamonds
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        #=pod
        each iR A&R {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
        =pod
        and then further, diving into the C
        compiles vast change checkers, if daR is stretched across Cs.
          if anything changes then CaR, solve whatwhere again,
          like refs changing but actuals same
        
        AND:
        
        what they are becomes. 
        waking another R set, pouring out of the C
        R-C couple, C<R many
          for going into the C and its state through time, etc
        the many pools of R should notice objects had by each other
          eg. a bunch of C touring a cyclically linked structure
        the R is a quiet link, to be modulated/packed into Cs
        by the process, to represent, eg thinking has things to it.
        repeatable stumbles.
        
        so the protocols for drawing stuff with Cs want to use schemas
         to grab their jobs from C & R happenings..
        
        
        Anyway, the s in progress is for the 9
            which will want to Rate its s&z
            as usual - the C join the game
            etc. anything could want to generate more R anywhere
            do they G&os,C.y.A 
        giving light pools an interface to one another
        
        =cut
        
        #A&o and ~AND: A.1.t, A&o
    };
        #c 7dress html d.on
    # and whatever after the state of atoms is got (osc/3)
    # really it does 4 here - catching state of properties changing
    # 5 + 6 in Css, translating properties to another language
    # but could end up in multifaceted games, showing working, etc...
    me.Cavon = &acgt{
        each iR A&R {
            $b = Rc&b;
            $C = Rc&s;
            Rs&on ||= b && bs&on;
            Rs&on ||= $("<stylehouse>")[0];
            # each A.1 does os, plants sequencer of 
            if (Rs&J) {
                $(Rs&on).css('display','block');
                $J = Rs&J;
                # 1s&on noticed
                Rs&in = Jc&on || Js&on;
                b && Rs&in != bs&in and me&chR,R,'Jin'
                continue
            }
            # more to think mode?
            if (s&J) {
                # expand/see into Js&v, write on this atom
            }
            # C.sc etc decorate
            me&Cscon,R;
        }
    };
        # apply styles to html.. expand unto copies of this thing,
    #   allowing a compressed notation to turn into styles,
    #     giving space to dream of altering the situation
    #     as the matter forks along a path of progress
    #   (we may use d to collect & export workings)
    #     and the whole osc atomism
    #   into css styles
    $verbose = 0; # causes window.styletos to list styles
    $robust = 0; # applies all css properties every time
    me.Cscon = &acgtR{
        $isnew = !Rc&b;
        # past self
        $b = Rc&b || {c:{},sc:{}};
        # om details no longer relevant:
        s&e and throw "used to eval(s&e)"
        s&nobody and throw "used to reselect d.on"
        if (s&tag || bs&tag) { # or historically
            if (bs&tag != s&tag) {
                # recreating the d.on clears applieds
                Rs&on = $("<"+(s&tag || 'stylehouse')+">")[0];
                delete bs&attr;
                delete bs&css;
            }
            s&tag and Rs&tag = s&tag
        }
        # < hammerhead stylings wanting some cache api
        #   alike, C fork down paths repeatable
        # < title should be replaced by hover -> question elvis
        $attr = ex({title:C.t+' '+C.y.cv}, s&attr||{});
        if (attr || bs&attr) {
            $notin = ex({},bs&attr||{});
            Rs&attr = {};
            each kv attr {
                # '' makes a bareword attribute, ease coding in a peel
                v == '!' and v = ''
                Rs&attr[k] = v;
                delete notin[k];
                !robust && bs&attr && bs&attr[k] == v and continue
                $(Rs&on).attr(k,v);
            }
            each kv notin {
                $(Rs&on).removeAttr(k);
            }
            !hak(Rs&attr) and delete Rs&attr
        }
        # more simpler translatoes
        $css = {};
        # ^ merge into me&styler:
        # also s&cod/NutText
        # and Stylaplicants's dropdown
        
        $st = 4s&styler ||= me&styler;
        
        st(C,css);
        
        # css stamped on on
        if (hak(css) || bs&css) {
            $notin = ex({},bs&css||{});
            each kv css {
                delete notin[k];
                bs&css && bs&css[k] == v and continue
                $(Rs&on).css(k,v);
            }
            each kv notin {
                $(Rs&on).css(k,'')
            }
            hak(css) and Rs&css = css
        }
        
        # Cs say their c&s
        if (typeof c&s == 'string') {
            Rs&picture = c&s;
            b && Rs&picture != bs&picture and me&chR,R,'Picture'
            # ^ element's text gets set with children. later:
            c&ht and Rs&html = c&s;
            else
            Rs&text = c&s;
        }
    }
    #c 8html output: put each in another
    # the html elements are closer to the C this time,
    #  used to always output a C-patch
    # s gets s&on
    me.Cupon = &acgts{
        each iR A&R {
            $b = Rc&b;
            $s = Rc&s;
            $up = R.y.up;
            # child needs parent to attach it
            # < TES less often, if b.on still == d.on?
            Rs&cha && up and me&chR,up,'Inner:'+R.t
            
            !Rs&on and debugger;
            # how else shall we entangle R/on/C/A?
            if (s.y.A) {
                $j = s.y.A;
                jc&s != s and throw "notC"
                s.y.A.on = Rs&on;
                Rs&on.A = s.y.A;
            }
            if (s == C && s&J && s&J == A.1) {
                C != A&s and throw "notC"
                i > 0 and throw "sC>0"
                # 1s&on set to thing, big deal
                1s&on = Rs&on;
            }
            s == C && (!s.y.A || s.y.A != A) and debugger;
            !up and continue
            # ups&down here Babz A.up.sc.down
            # < make R an A, work these functions with A/C
            up.sc.down ||= [];
            up.sc.down.push(R);
        }
        
        $rev = A&R.slice().reverse();
        each iR rev {
            !Rs&cha and continue
            # what is
            $had = Rs&on.childNodes;
            # what will be
            $have = [];
            # text/html
            Rs&picture &&
                have.push('<cs>'+Rs&picture+'</cs>');
            # children
            each ir Rs&down {
                have.push(rs&on);
            }
            if (Rs&J) {
                $J = Rs&J;
                # yon 1s&on put into Rs&on
                $on = Jc&on || Js&on;
                !on and throw "noJon";
                have.push(on);
            }
            # < scan what is there, leave siblings of changes
            #   rebuilding dom annoys stately insides (cm, video)
            #     whose continuity (history + cursor + focus)
            #       could be made up somehow
            # hadnt - what we didn't know was there
            # havent - what goes
            # leaving it open to elements being rearranged by the user?
            # rearrange, carefully. or just:
            each i,on have {
                $ha = had[i];
                on == ha and continue
                typeof on == 'string' && ha && on == ha.outerHTML and continue
                # different...
            }
            $(Rs&on).empty();
            each i,on have {
                $(Rs&on).append(on);
            }
        }
        $move = A&R.filter(R => Rs&cha);
        #$(Rs&on).append('<p>~ '+
        move.length and ~moveing: move.map(R => Rc&s.t).join(', ')
        ~move: A.1.t, ki(move), '/', A&R.length
        
        if (A.2 == A.4) {
            !A.4.on and throw "No A4on"
            if (!A.4.on.contains(A.on)) {
                ~>2 Fours: A.1.t
                $(A.on).appendTo(A.4.on);
                # if it was already, take it as an unplug?
                # or find new parent, get adopted
            }
        }
    };
    
    #c CaR, daR - climb C/data generating R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtsR{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                Rc&emit({s:D})
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtsR{
        if (typeof s == 'object') {
            each kv s {
                Rc&emit({t:k,s:v})
            }
        }
    };
    
    #c Rbit history/index Rs
    me.RbitX = &acgtsR{
        $bit = R.t;
        # an X is bits of index and .z=[R that are here
        A&X ||= {};
        # check in to it
        Rc&X ||= A&X;
        $X = Rc&X = Rc&X[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);

        # history at te top
        Rc&V ||= A&V && A&V.c.X || {};
        $V = Rc&V[bit] || {};
        if (V) {
            # care to leave history
            V = ex({},V);
            V.z and V.z = V.z.slice();
        }
        # only goners remain
        $b = V && V.z && V.z.shift();
        b && !V.z.length and delete Rc&V[bit]
        # children inherit this past
        Rc&V = V || {};
        Rc&b = b;
    };
    me.RbitXgonism = &acgt{
        # atoms in locations, another lives
        each iR A&R {
            $b = Rc&b;
            $s = Rc&s;
            b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                # any other t+cv are:
                each ip V {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # 
    # R.c inherits, R.y.up up/out and Rs&z down/in
    $Re = &Rs{
        $up = R;
        R = ex({},R);
        R.y = {};
        R.c = ex({},R.c);
        delete Rc&s;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        up and R.y.up = up;
        each kv s {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s},sc:{}};
        cb and Rc&middle = cb;
        
        # dedupe/limit objects
        $s = Rc&s;
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] = R;
        }
        else {
            $od = Rc&refR[ri];
            # < to know circular links
            return;
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return
        Rc&nl && Rc&nl < Rc&refs.length and return
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        Rc&emit = &sr{
            r = Re((r||R),s);
            Rs&z ||= [];
            Rs&z.push(r);
            return r
        };
        Rc&middle(Rc&s,R);
        R.c.not and return
        
        # accepted into the list of atoms
        A&R ||= [];
        A&R.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c 7gaze
    # really think about those properties, and whatever we might dive into
    # esp. the property of having no clear boundary to experience
    # try and get a nice full screen of stuff whatever is happening
    me.Gaze = &acgt{
        # we have travelled some C, but its content is unknown
        # play out schemes on its language
        # take suggestions, resume suggestioned
        #   rules about whatwhen, this may fluctuate
        
        # suggest trying to know the unknown,
        # generate like ind but for sheer datastructure,
        $k = s&knowabout = {};
        $le = [];
        each id A&ds {
            $b = d.b;
            $s = d.s;
            # resolve which atoms are pointing to/from which others...
            # last applied stratagem of suchness diffed with current one
            # steps taken to satisfy certains, leave uncertain interactive
            $is = 'not';
            if (ss&unknown) {
                d.digin = 'SurfReals';
                is = 'the unknown';
                !me[d.digin] and throw "No me."+d.digin
                $ret = me[d.digin](A,C,G,T,d);
                le.push(ret);
            }
            else {
                #k['not '+i] = s
            }
            k[is+' '+i] = s
        }
        S fe
        
        S lace
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        A&ou = 'GazNon';
        1c&on = le;
        1c&osc = A;
        return;
        $d = {};
        # similar but for unpackedness in general,
        #   including generatedness...
        #  maps of various resolution and sprawl
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };

    me.GazNon = &acgt{
    };
    
    # A looker, taking C + d for a Gazed osc item
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    $gin = &syd{
        d ||= {};
        !d.refs and d.refs = []; d.refid = [];
        !y and throw "nocb"
        # dedupe objects
        $ri = d.refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = d.refs.push(s) - 1;
            d.refid ||= {};
            d.refid[ri] = d;
        }
        else {
            $od = d.refid[ri];
            # < to know circular links
            return;
        }
        d.dl && d.dl < d.d and return
        d.nl && d.nl < d.refs.length and return
        !d.d and d = df(d)
        # make a callback
        $l = y(s,d,df); #)
        # which gives us options to try
        $out = [l];
        each in d.z {
            d.not || n.not and continue
            $l = gin(n.s,y,n);
            out.push(l);
        }
        d.d == 1 and d.out = out.join("\n"); return d
        return out.filter(&s{ return 1 && s }).map(&s{
                return s.split("\n").map(&s{ return "  "+s }).join("\n")
            }).join("\n");
    };
    # inherit d
    $df = &d{
        $up = d.d && d;
        d = ex({},d);
        # < path as a function climbing d.up
        d.path = (d.path||[]).slice();
        d.z = [];
        up and d.up = up;
        d.d ||= 0;
        d.d++;
        return d
    };
    
    #c SurfReals
    me.SurfReals = &acgtD{
        # o origin C.c.s, because it's s&unknown
        $s = D.s;
        $rs = [];
        !(sc&s && typeof sc&s == 'object') and throw "noobject"
        $d = gin(sc&s,&s,d,df{
            rs.push(d);
            if (typeof s == 'object') {
                each kv s {
                    $D = df(d);
                    D.path.push(k);
                    D.k = k;
                    D.s = v;
                    d.z.push(D);
                }
            }
            return d.k+": "+d.path.join("-")
            #ki(s,2)
        });
        
        # ou to R, the display particles
        $rev = rs.slice().reverse();
        each id rev {
            $R = {y:{},c:{},sc:{}};
            R.t = d.k || "nothing!";
            R.y.d = d;
            Rc&s = "o "+(d.k || '');
            d.d and Rs&ml = 1;
            Rs&dis = 1;
            d.Rz and Rs&z = d.Rz;
            $p = d.up;
            if (p) {
                p.Rz ||= [];
                p.Rz.push(R);
            }
            else {
                d.everything = R;
            }
        }
        
        # put d.everything through oscering...
        $r = d.everything;
        $j = me&J,['GazeR','-n',{},{z:[r]}];
        $on = j.y.A.on;
        
        # put that on into our 1c&on
        
        # becomes 1c&on, 
        return on;
        return d.out;
    };
    me.Ja.n = &acgt{
        n t 1 $s:C.t %hs:348,dis:block
        $z = A.ground.sc.z;
        z.unshift(z.pop());
        #
    };
    {

