Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    io.doz = 1;
    io.usu_dup = &{};

    # Relosophy of C and R
    =head1 bugs
    
    see about the b loss after a throw
      from not checking out Rc&X/V properly
     by elvising sensors into Elvising
     
     ^ holding up timing deunification/fast Display updates
    
     the %kvstore %futhering into ting W/ doesnt settle
    
    io not doing a bunch more of the expression
     < do $s/%ball
     < know to Rsync after messing with?
    would take care of me&ioty and me&input
    
    =head1 I
    
    for recompiling everything,
     G&t gets it from A*%believed
    that may be part of or leading to elvising,
      the hyper-everything trans-anyway maculata
     which lives in the same form:
     <Source> /Transform|Select\ <Output>
    any of that may need to live somewhere,
    for independent intelliglance:
     CodeChange
       To
         Experie
           $Doleux # the -e below, put for destination
       For
         Vang # W from here to grabber
           Doleux -e
             %here: Doleux # version of grabbed thing
             %etc: whathaveyou
    then Vang relives that %push
    and Experie knows its got stuff incoming
      which it might already have pulled in,
        (it must also disconnect)
      or is able to pull in with/without Vang being awake
    
    =head1 push
    
    is near simplifying
      G/W rebuild would realise calmable push boundaries
     and how hard the codon was entered
     and an overmind to wander around %tests
    
    =head2 Cnetobjet
    
    all %H within should gather atop
      garbage collection
        the wandery overmind
    rebuild this editor as a picture museum
    
    
    =head5
    
    #A is R, throat is Ring, sooner of things
    #  throat - where Instructions iterate over Culture
    
    =head1 Srupto
    we want to allow pin Steps to be Instructions
      a way to grab anything at any rhythm
    
    the baseline C mode includes encoding Instructions:
     Cont
       thinger 3 s:'s&er++' %of:Lat
    becomes:
     Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
    then:
     Cont transports
     Lat is I stuff (%W with %z), posited as being Lat
     thinger is encoded (Latc&W:of)
    such that it is mostly ready for action:
    A.3+ believes in Cont%W
    A.1 somewhere wants Lat
        (or thinger, knowing things like Lat might contain it)
     by elvising G/$pathtoA1/Lat,
      finding/choosing a Lat,
      which must 6 the whole of what it bit
        (W around might be only indexing of what can be got)
    do-ing
    then that elvising attaches to A.1/G/Lat/Cont
     which A.3 hoists/attaches/encodes/stores as some of:
       A.3/G/Cont # no idea wherefor but small edge
         # does updates for change at the large-object level
       A.3/G/Cont/$pathtoA1 # know where to send attention
         # andor where in the stream of Cont the change is!
       A.3/$pathtoA1/G/Lat/Cont # Q/A format per place
         # lends itself to network change sensitively
     easily all at once
     hyperspheres of definition named simply
    and store perhaps on the first line of the W in Lines:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Stuff   %produced
    and something incorporating Cont and more looks like:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
         thingo 3 s:'C.c.o++'
       thingo 3 s:'s&er++' %of:Lat
    
     when thinger blows up, inspected:
        thinging from AyeOne%W/Lat%Wz/thinger
        and as asking around about random things:
        find AyeOne%W/Cont%W (aka Cont%W) also has Lat/thinger
        things may be asleep about here,
        but may be able to show source code, compile/mutate it
    
    looking at the G would be lots of io-ing
      things packed into it
      checking those injection/projection points
      is bitXgonerism
      relying on percolating those things
        along things that we can relive
       or shut down, rearrange, tamper with
      as osc-compatible:
       various $Gish of $Wish may be attached to $Wish
         so long as osc understands what/how to involve/mixage
       even outside itself on $Woth/$pathtoWish/$Gish
        just as $Teing is an index of landstructions to go here
        we have the chance to take with us or trust to recreation anything
        
       they are understood by the I, made meaningful where $Wish is
      and hoist/dehoist its structures into other places
        with others doing the same thing
      and also just the giant tabulation
    
    #c ph (post R re-combobulation)
    osc does new A:I over the old one
      probably rolling everything
     A:C make separations of a thing or things
      lets its content be distributed and depended on
      pattern matched and made into elvisings out to W:of,
      putting into a further self
    
    so C may need separation to preserve various objectives:
     A:n C being the most-uphill thing
     A:C = C coming in
     A:s = C for doming/playing sc forward
     A:C = C going out
     A:W = C encoding/compressing
    they all have ways to know about their previous lives
    
    
    
    another life of the underlying shape:
    A - receivability
    C - received culture
    G - culture + momentum, implantations
    T - what could not fit in,
      its mysteries/problems/developments,
      its inclusion to/from the world
        to as in for Teing into some W-position,
        from as in its life was because of such insTruction
      the T is like the G
        dealing with a big tangle of comings & goings
    the T decides/dealswith the edge of the picture,
    by hoisting/making the content misfiture,
      such that a big C can have its anomalies adjusted
    
    the layer above io, provides mode ala c&el
      io needs to readwrite A&X/A&V/A&Xo
        to provide the memory of the current play
        in parallel to the previous one,
          noticing when C views should complete (gonerism)
    diversifying how to match $thing against $Thing,
      what we are looking for,
      what level of understanding to borrow what from
    yet producing that sc-lang about how it was written:
      Some%sounds = {index of direction to points of resonance}
    there could be:
      Cs making the structure of any kind of index
      direction Cs, coming from/with merge/over/with/etc
      resonating Cs, beings in a constellation unknown to themselves
    
    A:s would be driving towards a goal
     juggling dives in, points and progress
       of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
     compiles fast checkers of 0-2 wobble once inflated
      so lowlevel changes (container re-ref) cause higher modes
    needs a playspout
     told/finding how innards roll through time (A&ip++)
     pointing to things, as if regrouping into another
      laying schemes on what to do
       producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked, wandering
    
    drawing cellular boundary
      s&z = more C,
        so might its A&z = more A
      based a bit on A signage (A.so = $so)
        $so might be via Ay&up (would know if soA&ip aboves us)
        A.pileup of things involved/leading to A
          should cleanup per J or so,
          but provide being/groupology along A
      measures of depth/appropriateness
       A&d (A.c.d)
      thickness/gravitational of cultural boundary-ness
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
    #c Srupto Elvising 
    =head1 Srupto 
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
          throating is meeting several inputs at once:
           A:n->C+ dome-havers (leading to/with/during s for the J)
           Teing (Instruction overloading) from 'above'
           Regurgitants
        Js can be trusted to get their TGW meaning to a point,
         so they can be reset natively
          consuming all input, producing all output,
          for what is supposed to be here.
          inside J (s life) its expression is freer
           
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
         for going into the C and its state through time, etc
          onward, redo, step, pause at trouble...
         matching between many pools
          for same objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          and similarityin many pools, overlapping, notice objects had by each other
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        Geing stuff, departing pile of meaning
        # similar but for unpackedness in general,
        Teing suff, meaning of departing
        # phases of aiming the display and adjusting things
        a pi sewing machine:
        # latter -go wants to be pointed to not coded, initially
        
        =cut
        
        
    #c Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    $drag;
    me.handelvis = &acgt{
        # unless dragging
        C.t.includes('mousedown') and drag = C; return 
        if (C.t.includes('mouseup')) {
            C.t = C.t.replace(/mouseup/,'click');
            if (drag) {
                $d = drag;
                $dif = [];
                # one common C, the rest different?
                each in dc&slope {
                    if (n != Cc&slope[i]) {
                        !dif.length && i > 0 and dif.push(Cc&slope[i-1])
                        dif.push(n)
                    }
                }
                dif.length and c&dragslope = dif;
            }
        }

        # go up C path until bingoed
        $lop = c&slope.slice().reverse();
        # - s&medo - instant, outside (A=4) (eg Jause)
        each in lop {
            # dont fire usual click event when dragging stuff to it
            c&dragslope and break
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            G&yl:123,&{ msg.set('what',ki(ret)) };
            return
        }
        # - s&med: 
        #   e -> 4c&elvrupto -> me.handelvis (here)
        # puts 4c&elvising as the event of the 4c&callback
        #   then inside callback J:Fourier oscs me.Elvising
        #    finding Rs&elvis = Gazer, etc
        4s&elvising = C;
        ~Insideon: ki(c&slope,2)
        G&yl,0,4c&callback;
    };
    
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';
        
        4s&elvised = [];
        G.oclon ||= G.clon;
        G.oclof ||= G.clof;
        if (1 && 'draggable') {
            G.clof();
            G.clof = &{
                window.onmousedown = null;
                window.onmouseup = null;
            };
            G.clon = &{
                window.onmousedown = &{ G&gev };
                window.onmouseup = &{ G&gev };
            };
            G.clon();
        }
        else {
            G.clof();
            G.clon = G.oclon;
            G.clof = G.oclof;
            G.clon();
        }
        
        $l = 4s&elvising;
        !l and return
        if (0) {
            me&J,['elvising','-feel',{s:l},'elvising,boost:sc,solvey'];
        s&mih = '14';
        }
        else {
            # still feeds to osc Elvising but don't display
            n elvising  $s:l %elvising
        }
        
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel
    
    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if ((e.t.includes('click')||1) && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
    #c e-slope/pointer
    
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 275;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and throw "ancient R"
            #debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.pivot = &ft{
        !f and throw "no from"
        !t and throw "no to"
        $futurup = &r{
            r = ry&up;
            r && ry&future and r = latestR(r)
            return r;
        };
        $from = me.cby(f,0,futurup);
        $to = me.cby(t,0,futurup);
        from[0] != to[0] and debugger
        $la;
        $i = 50;
        while (from[0] == to[0]) {
            i-- < 0 and debugger;
            la = from.shift(); to.shift();
        }
        $a = from.slice();
        la and a.push(la);
        a.push(...to);
        return {f:from,v:la,to:to,a:a};
    };
    me.solveR = &acgtN{
        N = N.slice().reverse();
        $M = [];
        $c = {};
        each in N {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                ns&J and vs&J = Y.1
                c.1 = Y.1;
                # find W, the level Travel is got to
                ns&J && ns&J == ns&J.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                # find the deepest each of ...
                $perc = 'elvis dragelvis'.split(' ');
                each it perc {
                    R.sc[t] && !c[t] and c[t] = v.sc[t] = R.sc[t]
                }
            }
        }
        $p = [];
        each in M {
            # down to inner %elvis
            ns&elvis and p.push(n); continue
            !p.length and continue
            p.unshift(n);
            ns&W and break
        }
        return p
    };
    #c e-cra
    # does %elvis=hook with Te
    # < make Plans to swim in there and deliver it
    me.cra = &acgtD{
        s&solvey = me&solveR,c&slope;
        !s&solvey.length and return
        if (c&dragslope) {
            s&dragsolvey = me&solveR,c&dragslope;
            each in s&solvey {
                !ns&dragelvis and continue
                # once someone up the line wants to do motion
                each id s&dragsolvey {
                    # the dragged from R%elvis
                    !ds&elvis and continue
                    c&dragfrom ||= ds&R;
                }
                each id s&solvey {
                    # and what would have handled a non-drag
                    !ds&elvis and continue
                    c&dragto ||= ds&R;
                    delete ds&elvis;
                }
                # use the travel agent
                ns&elvis = ns&dragelvis;
                break
            }
        }
        # solvey to the first %elvis
        $deep = [];
        each in s&solvey {
            deep.push(n);
            !ns&elvis and continue
            # here's state
            $el = me&stackTe,deep;
            
            T.qua = {};
            $R = ns&R;
            
            # make the adjustment
            me[ns&elvis](A,C,G,T,R);
            
            if (T.non) {
                T.non = 'drag' and delete T.non
                # invlaid approach: drag becomes click
                if (Rs&elvis && Rs&elvis != ns&elvis) {
                    ns&elvis = Rs&elvis;
                    continue
                }
            }
            # save the state
            each kv T.qua {
                el.sc[k] = v;
            }
            
            s&elvis = ns&elvis;
            s&Teing = el;
        }
    };
    #c e-do boost/say/drag
    # click up/down anywhere
    me.Gazel = &acgtR{
        C.t == 'says' and return T.qua.sayeth = c&s
        C.t.includes('S+') and return T.qua.play = Rs&play ? 0 : 1
        
        Rs&boost ||= 0;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
    };
    # ESC from textinput
    me.sayeth = &acgts{
        ~Sayeth: ki(A), c&s
        T.qua.sayeth = c&s;
    };
    # via a drag-n-drop of gear to send massages
    # < e become active que-sheets
    #   may arrange/drop themselves into Wormhole...
    #   workings for the Step: wait for such release
    # all a AndContinuance, but let's see it think in R
    me.projvey = &acgtR{
        $A = G&Aye;
        $f = c&dragfrom;
        $t = c&dragto;
        $d = A.ground = G&Cye,['dr','',{elvis:C}];
        4s&eland = d;
        ds&from = f;
        ds&to = t;
        f == t and return ds&same = 1;
        $p = me.pivot(f,t);
        $v = p.v;
        # between places simple?
        $nonballic = p.a.filter(n => !ns&ball);
        if (!nonballic.length) {
            $S = tc&s;
            $s = fc&s;
            i $S/$s
            ds&moved = 1;
            ~move: S.t, '<-', s.t
        }
        elsif (vs&Cell) {
            fs&Tool and ts&play = ts&play ? 0 : 1
            else {
                ~cellsomething
            }
        }
        else {
            # move item
            debugger;
            ds&dunno = 1;
            ~dunno
            T.non = 'drag'
        }
        dc&s = p;
    }
    # 1s&Te/Rs&Te carry centralised namewires from Elvising
    # so set value can be reintroduced
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        # ^ is somewherish. posits and deposits.
        1s&Te and me&Tie,R,'boost'
        
        !Rs&boost and return
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : '↯';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
            z.t += hu;
            i++;
        }
    };
    #c Mboostia
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tin rc&ha {
            if (rc&N.indexOf(n) >= 0) {
                # R included are from Rc&refs/refR
                # < may not be in our h/R pool, showing...
                #   same Rc&s=objects near but not in this process
                #t == 'dub' and continue
                # say where it originated
                $M = me&Mw,n,'Mlimits';
                m $t 89 s:♲ %deco,fs:13,lh:0.3
                # dub = from other R0
                if (t == 'dub' || t == 'dup') {
                    $o = ns&refR[0];
                    $nam = me&nampup,o,n;
                    m $t 892 $s:nam %deco,fs:7,hs:999
                }
                continue;
            }
            else {
                # knows upward that is
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
        }}
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $zs = t+' < '+N.map(t=>t.t).join(',');
            $te = '*'+t;
            m $te 117 $s:zs %deco,fs:13
        }}
    };
    # resume sc
    me.rollbs = &acgtRs{
        $b = Rc&b;
        !b and return
        s = s.split(',');
        each ik s {
            hak(b.sc,k) and R.sc[k] = b.sc[k]
        }
    };
    #c Te receive Te
    # drive wiring from above
    # < check every point was found
    me.JT = &acgts{
        delete 1s&Te;
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $v = p&tv $t;
        !v and return
        1s&Te = v;
    };
    # Rs receive Te
    # $k - Tes&$k given to Rs&$k
    # $d - '1' to oncer/consume that sc
    # can resume pointering across Rs that don't Tie
    # < intro much more: throat's ability to pause/step etc.
    # < checks all pointers were found,
    # < find hidden lands
    me.Tie = &acgtRkd{
        if (!Rs&Te) {
            # default unattached error-avoidance thing
            Rs&Te = {sc:{}};
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            $Tet = v&tv $t;
            if (0 && !Tet && v.t == t) {
                # pointer is thinning itself, stretch while t constant
                $vv = r.y.up;
                vv = vv && vvs&Te;
                if (vv) {
                    v = vv;
                    Tet = v&tv $t;
                    Tet and ~tstretch: r.y.up.t, t
                }
            }
            Tet and Rs&Te = Tet
        }
        $v = Rs&Te;
        !v || !v.c and return
        !k and return
        # once located, muddle with opportunity
        
        #vs&cb && vs&cb,R,t
        if (hak(v.sc,k)) {
            $V = v.sc[k];
            k == 'boost' and V *= 1
            R.sc[k] = V;
        }
        # oncer
        d == '1' and delete v.sc[k]
    };
    # make Te for N pointer/solvey path
    # < a pile of travel, io T points to look at
    me.stackTe = &acgtN{
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in N {
            if (typeof n == 'object') {
                # has a better .t
                ns&Te && ns&Te.c and n = ns&Te
            }
            # < io spacerising
            i $el/#$n
            el = ays&n[0];
        }
        return el
    };
    # set Te
    #  for setting boost that can then wander off as per
    me.introqua = &acgtRcm{
        $N;
        if (R.constructor == Array) {
            N = R
        }
        else {
            me&Tie,R;
            $h = Rs&Te;
            # if none exists
            h && h.c && !m and return
            N = me.cby(R);
            N.shift().t != 'I' and throw "I!=0"
        }
        $el = me&stackTe,N;
        each kv c {
            el.sc[k] = v
        }
    };
    #c structuR
    me.namup = &acgts{
        !s and return
        $nam = [s.t];
        while (s = s.y.up) {
            nam.push(s.t);
        }
        return nam.reverse();
    };
    # show path between two R
    me.nampup = &acgton{
        $namo = me&namup,o;
        $name = me&namup,n;
        $pup = [];
        each is namo {
            if (!pup.length) {
                s == name[i] and continue
                if (name[i] != null) {
                    # up the n
                    pup.push(name.slice(i).map(la=>'^').join(''))
                }
            }
            pup.push(s)
        }
        if (!pup.length) {
            $ups = name.length - namo.length;
            while (ups--) { pup.push('^') }
            pup = [pup.join('')];
        }
        $nam = pup.join('/');
        return nam
    };
    # pick an R by name, from ...
    #   io wants to know R, loadup qualities...
    me.bit = &acgtRtf{
        typeof t != 'object' and t = [t]
        !f and f = R
        f == 'h' and f = Rc&N[0]
        each in t {
            #$fz = fc&X && fc&X.x[n] && fc&X.x[n].z;
            $fz = fs&z && fs&z.filter(t => t.t == n);
            !fz and throw "problem"
            fz.length < 1 and throw "notfound"
            fz.length > 1 and throw "many"
            f = fz[0];
        }
        return f
    };
    # path finder
    me.cby = &sfzdo{
        !s and return !f && d
        z == 'up' and z = null
        z ||= &s{ return s.y.up };
        d ||= [];
        d.unshift(s) > 50 and throw "manycby"
        $r = f && f(s,o);
        r and return d
        return me.cby(z(s),f,z,d,s)
    };
    me.cbu = &sfz{
        $cb = f;
        typeof f == 'string' and cb = &R{ return R.sc[f] }
        typeof f == 'object' and cb = &R{ return R == f }
        $l = me.cby(s,cb,z||'up');
        return l && l[0]
    };
    me.yfuture = &acgtrRy{
        $i = 300;
        while (ry&future) {
            r = ry&future;
            i-- < 0 and throw "manyfuture"
        }
        if (R) {
            if (0 > Rc&N.indexOf(r)) {
                y and y
                else {
                    throw "yfutured "+R.t+" not in RcN"
                }
            }
        }
        return r
    }
    #c Rdata
    # input s to Rc&s, updating %balls
    # an io that makes changes to both A & C at once
    me.input = &acgtRs{
        if (!Rs&ball) {
            # we are pathing to another group of %balls
            # find R.t instead of Rc&s.t:
            typeof s != 'string' and throw "input path out of %ball !string"
            # there might be multiple of these, of %hypball
            #   for each %push to hang up its state/ambition on
            return Rs&z.filter(n => ns&ball && n.t == s)[0]
        }
        $S = Rc&s;
        # look for it
        o $S/#$s
        ya && typeof s != 'object' and s = ya
        if (ya && ya != s) {
            ~Bepicky: Ry&up.t, R.t, s.t
            $si = Ss&z.indexOf(s);
            i $S/-$ya
            ya = null
        }
        if (!ya) {
            if (typeof s != 'object') {
                i $S/#$s
                s = ya
            }
            else {
                i $S/$s
            }
            if (si != null) {
                # keep order
                $is = Ss&z.indexOf(s);
                is < 0 and throw "noin"
                if (is != si) {
                    Ss&z.splice(is,1);
                    Ss&z.splice(si,0,s);
                }
            }
        }
        me&Rsync,R;
        each in Rs&z {
            nc&s == s and return n
        }
        debugger;
        # should have found that input
    };
    # keep a %ball for each Rc&ss&z
    me.Rsync = &acgtRV{
        $S = Rc&s;
        # o $S/*
        $ba = (Ss&z||[]).slice();
        $rm = [];
        each in Rs&z {
            !ns&ball and continue
            $bi = ba.indexOf(nc&s);
            bi >= 0 and ba.splice(bi,1)
            else { rm.push(n) }
        }
        each in rm {
            Rs&z.splice(Rs&z.indexOf(n),1);
            n.c.not = 1;
            V &&
            ~Removed: R.t, n.t
        }
        each in ba {
            V &&
            ~Included: R.t, n.t
            $t = me&Ret,R,{t:n.t,s:n,ball:1};
            zN(t);
        }
    };
    # io should be able to: $t/%ball/%ball or so
    #  and Bab this while loop with var sets
    me.ioty = &acgtty{
        $leg = [];
        typeof y == 'string' and leg = y.split('%');
        leg[0] == '' and leg.shift();
        # default $t/*
        !leg.length and leg.push('');
        !t || !ts&z and return []
        $bit = leg.shift();
        $z = ts&z.filter(l => !bit || l.sc[bit] != null);
        if (leg.length) {
            leg = leg.join('%');
            $Z = [];
            each il z {
                Z.push( ... me&ioty,l,leg );
            }
            z = Z;
        }
        return z
    };
    
    #c Roll
    # roll %run per result[0] (c.lineate)
    #   and c&increment++ added to .t
    me.rollcounty = &acgtRtc{
        c = ex(c||{},{incrementt:1,count:1});
        c.per and c.lineate = delete c.per
        return me&rollbsc,R,t,c
    }
    me.rollbsc = &acgtRtc{
        me&rollbs,R,t;
        $r = R.sc[t];
        if (c.lineate) {
            if (r && rc&lineate != c.lineate) {
                # y.hist?
                delete R.sc[t]
            }
        }
        if (!R.sc[t]) {
            $n = G&Cye,[t,''];
            
            c.increment ||= c.incrementt;
            if (c.increment) {
                nc&increment = r ? rc&increment + 1 : 0;
                if (c.incrementt) {
                    n.t += '_'+nc&increment;
                    delete c.incrementt;
                }
                delete c.increment;
            }
            
            if (c.lineate) {
                nc&lineate = c.lineate;
                delete c.lineate
            }
            
            ex(n.sc,c);
            r = R.sc[t] = n
        }
        if (c.count) {
            rs&count ||= 0;
            rs&count++;
        }
        return r
    }
    # s.sc[k] ||= (v||1) unless 0 or ''
    me.suggesc = &acgtskv{
        v == null and v = 1
        s && s.sc[k] == null and s.sc[k] = 1
    };
    # be waiting for...
    me.waits = &acgttsc{
        !s and s = t; t = 'waits'
        me&tsc,t,s,c
    };
    me.tsc = &acgttsc{
        !s and s = t;
        $n =
        n $t  $s:s
        $y = &b{ ex(n.sc,G&peel,b ) };
        c == 'B' and y('hs:856,fs:17')
        c == 'b' and y('hs:856')
        c == 'D' and y('hs:675,fs:25')
        c == 'd' and y('hs:676')
        c == 'G' and y('hs:999,mar')
        c == 'g' and y('hs:634')
        c == 'p' and y('hs:395')
        c == 'L' and y('fs:15')
        c == '6' and y('fs:6')
        return n
    };
    # sanity/display helper for expanding joints
    me.zoep = &acgtRptsk{
        # find/check scheme upwards
        if (p && p.up) {
            $path = p.up.split('%').slice(1);
            $r = R;
            each il path {
                r = ry&up;
                !r and throw t+" !up"
                !r.sc[l] and throw t+" up !"+l
            }
        }
        # introduce this
        me&tsc,t,s,'g';
        k == '' and k = R.sc[t]
        me&tsc,t,k,'G';
        return r
    };
    
    #c Rcopy
    # clones s or %ball, as far as s goes
    me.Copy = &acgtRhc{
        c ||= {};
        # Rings up to a point
        typeof c == 'number' and c = {ov:c};
        while (c.ov > 1) { c.ov *= 0.1 }
        
        $s = hc&N && hs&ball ? hc&s : h;
        
        ex(c,{task:'ravel',ball:1,noDisplay:1});
        c.Copy = 1;
        h != s and c.Ropy = h
        c.t ||= h.t;
        return me&Reis,R,c.t,s,c
    };
    me.Copyingness = &acgtR{ return [
        # clones %balls for me&Copy
        ['ball+Copy','11',&acgtRs{
            Rs&Copy = s;
            Rc&s = G&Cye,s;
            # update self in above z
            $p = Ry&up;
            if (p && ps&Copy) {
                $P = pc&s;
                # replace cloned ss&z in parent
                if (Ps&z) {
                    $pi = Ps&z.indexOf(s);
                    pi < 0 and throw "pi<0"
                    Ps&z[pi] = Rc&s;
                }
                # %Ropy = %ball cloned from
                $pR = ps&Ropy;
                each in ps&z {
                    !ns&ball and continue
                    nc&s != Rs&Copy and continue
                    Rs&Ropy = n
                }
            }
            s = Rc&s;
            if (ss&z) {
                ss&z = ss&z.slice()
                me&Rsync,R;
                each ir Rs&z {
                    rs&ball and rs&Copy = 1;
                }
            }
        },'ift,D'],

    ] };
    #c push - %ball's establishment of an outgoing projection
    # < working via elvising hung near
    # < better pointering & grabbing styles
    #    remember what things looked like,
    #    be generating grammars/I off the screen
    # in a %push on this %ball, rolling through time,
    # < disconnecting once the cause (me&push call) stops
    # 
    # returns the %pull (which will Ring soonish) unless:
    #  %pull%auto:
    #    %their = me&input,%there,%herec&s
    #    returns %their = %ball holding %herec&s under %there
    # 
    me.push = &acgtRpqtc{
        # the named %push + its mode (%auto if t,!c args)
        c ||= {auto:1};
        typeof c == 'string' and c = G&peel,c
        t and ex(c,typeof t == 'string' ? {t:t} : t)
        c.push ||= 1;
        !hak(c,'t') and c.t = ki(p,2)+' = '+ki(q,2)
        $l = me&Ret,R,c;
            zN(l);
        
        # and its items, from here
        # path to receiver %ball (inflated)
        #  < elvis pointing such that name changes/bits blow away when pushed
        $t = ls&there = me&pushpath,R,p;
        # the thing itself, where it is (also inflated)
        $h = ls&here = isC(q) ? q : me&pushpath,R,q;
        !t || !h and throw "falliball"
        
        # < pipelining of here as it goes there via ...
        #   so it can wander through a network started here
        
        # begin othering:
        if (ls&hard) {
            ac(t,'pushering',l)
        }
        elsif (ls&auto) {
            $thing = hc&s;
            ls&their = me&input,ls&there,thing;
            return ls&their
        }
        else {
            # no-push link (elviser knows who's nearly elvised them)
            ac(t,'pushish',l)
        }
        # %ball pushed to %there, practically
        # < %othering to %there,
        #   saving %balls of here/there for Cdar diff
        #   the %there%balls noticing our %push vanish
        return l
    };
    # %ball input limb, extra pathy
    # < to hang push intentions on %ball
    #   or on speculative balls for slow ...
    me.pushpath = &acgtRp{
        $r = R;
        each is p {
            $nr = s == '/' ?
                me.cby(r,&r{ return rs&gee })[0]
                :
                me&input,r,s
            !nr and throw "No "+s+" after "+r.t+" along "+ki(p)
            r = nr;
        }
        return r;
    };
    #c push
    me.Pushingness = &acgtR{ return [
        # %push = cv awake
        ['push','3',&acgtRs{
            me&rollbs,R,'moves,delivered';
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            s&fs = 8;
            #Rs&arrow =
            n $R.t 13 s:⇒ %fs:24
            # certain/lowlevel types of %push
            Rs&auto || Rs&hard and return Rs&push = 9
            # log
            Rs&moves ||= []
        },'ift,D'],
        
        # %their
        # not currently pointed to and found:
        #   %there + %here = %their
        #     might mean disregard for %their state
        #     or ignorance, as elvis might clue
        #      with all the logistical infolation
        # ways the item 7s from afars:
        
        # %push%their = %balls reporting back
        ['ball+pushed','56',&acgtRs{
            # since ball 53 yfuture'd %pulled...
            $p = Ry&up;
            $above = ps&pushed || [];
            each il Rs&pushed {
                # %pushed here and not above
                above.indexOf(l) >= 0 and continue
                # < many?
                ls&their = R;
            }
        },'ift,D'],
        # %push%their = what %deliverer did (via %pushish)
        ['push+deliverer','56',&acgtRs{
            $d = Rs&deliverer;
            $ed = d && ds&delivered
            ed and Rs&their = ed
        },'ift,D'],
        # the %moves could lead somewhere
        ['push+moves','56',&acgtRs{
            each in Rs&moves {
                n.t == 'push' and Rs&lastpush = n
            }
            # last %move that was a push
            $lm = Rs&lastpush;
            if (lm) {
                # this %push when %move was started (had the %made)
                Rs&doing = lmc&pusher;
                # this %push when %move was done
                Rs&done = lmc&pushed;
            }
        },'ift,D'],
        
        # an error getting fixed
        # detects disconnected %their
        #  searches for likely candidate
        #   or however there/their is pointed
        ['push+losttheir','77',&acgtRs{
            delete Rs&losttheir;
            !Rs&lastpush and return
            $m = Rs&main || Rs&made || Rs&here;
            $th = Rs&there;
            !m || !th and throw "m-th"
            $t = me&ioty,th,'%ball' .filter(t => t.t == m.t) [0];
            n sun  $s:m,R %sun
            !t and return me&tsc,'notfindable','gonetheir','d'
            Rs&losttheir = t;
        },'ift,D'],
        # and puts it forth
        ['push+moves','56',&acgtRs{
            # for push+losttheir 77
            $b = Rc&b;
            $l = b && bs&losttheir;
            l and Rs&their = me&yfuture,l
        },'ift'],
        

        ['push','59',&acgtRs{
            Rs&push >= 9 and return
            # attaching checks to its parts
            me&suggesc,Rs&here,'Lines';
            me&suggesc,Rs&their,'Lines';
            # %act from what it %does to get %made
            #  engaged now so it can tamper with <6%their
            Rs&does and Rs&act = Rs&does
        },'ift,D'],
        
        #c push-7 have encoded %balls wormhole through %moves
        #   received by this %push early enough to action
        ['push','7',&acgtRs{
            Rs&push >= 9 and return
            $t = Rs&their;
            $h = Rs&here;
            
            # both sides should Lines
            me&sch_didLines,R,h;
            !t || me&sch_didLines,R,t;
            
            if (me&Mw,R,'err' .length ) {
                Rs&push = 9;
                return me&tsc,'push7_errrors','⊗','L'
            }
        },'ift,D'],
        
        ['push','73',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            $done = Rs&done;
            
            done && !t and me&tsc,'va','vanishing!'
            !t and me&tsc,'notheir','⧁','L'
            
            # here <-> their if nothing organised
            !Rs&diffya and me&diffya,R,'diff',h,t
            
            # their <-> their at the last push
            $tdiff = t && done && me&diffya,R,'theirs',t,dones&their;
            if (tdiff) {
                # < handle changes we didn't push
                # < branch here <-> dones&here, patch onto that
                if (!tdiffs&exactly) {
                    # < explore what'll happen, run in reverse
                    #m pull $from:t,to:h %pull,pending,move
                    n pending  s:pull? %hs:588
                }
            }
        },'ift,D'],
        
        # %push makes %moves
        ['push','77',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            # collects %moves
            $M = Rs&moves;
            
            # the checkout on init trick
            if (Rs&checkout && !M.length && me&sch_ballonlyt,h ) {
                m checkout $from:t,to:h %pull
            }
            
            # transmit here or what we made of it
            Rs&made and h = Rs&made
            
            if (Rs&shove || Rs&boost > 1) {
                !Rs&shove and Rs&Te.sc.boost = 1;
                Rs&shove &&
                    n shovedby  $s:Rs&shove %hs:388,deco
                
                if (!t) {
                    t = Rs&there;
                    $into = '> '+t.t
                }
                ~PUSH: R.t, h.t, into||t.t
                # the usual
                $c =
                m push $from:h,to:t,pusher:R
                into and cc&into = 1
            }
        },'ift,D'],
        
        # random look
        ['push','8',&acgtRs{
            !Rs&boost || Rs&boost < 1 and return
            
            s&fs = 11;
            s&dis = 1;
            #n thing  $s:R.sc,R %sun
        },'ift,D'],
        #c push-moves
        # 7%push sends its future self %moves to do
        #   objects (esp %from and %pusher) from that time
        # now early enough to make %ball%othering
        # a %move is just a C, has:
        #   c&from/c&to: most of all
        #   c&push: %push when it started to move
        # if you:
        #   c&pusher: whatever/%push the move was designed in
        #  you get:
        #   c&pushed: yfutured/%push when move completed
        ['push+moves','4',&acgtRs{
            $M = Rs&moves;
            each in M {
                ns&done and continue
                # with items from late last time
                $f = nc&from;
                $t = nc&to;
                t ||= nc&into;
                !t || !ts&ball and throw "move not sure of t%ball"
                !t || !fs&ball and throw "move not sure of f%ball"
                # us, last time
                $p = nc&pusher;
                nc&push = R;
                # f is likely to be the last %here, unless reversing
                # t (usu c&to=%their) may still be c&into=%there
                $tp = t && ty&up;
                if (tp && tps&pushering) {
                    tp = me&yfuture,tp;
                    # parent mediates %push for some reason
                    #  eg to %kvstore %here%string
                    # not %their directly
                    ~pushering: t.t, R.t
                    ac(tp,'pushering',R,'ball',f)
                }
                else {
                    $to = t;
                    t = me&yfuture,t;
                    ~othering: t.t, R.t
                    0 > Rc&N.indexOf(t) and ns&warn = 'to!cur'
                    t == to             and ns&warn = 'to!futu'
                    ts&ball == '6'      and ns&err = 'toolate'
                    
                    if (!ns&err) {
                        # bit more pto
                        ns&move = 1;
                        ns&from = f;
                        ns&to = t;
                        ac(t,'movingin',n);
                    }
                    # usu othering %push%here,
                    # < the %moves making subcommits:
                    #   their own reselections of %ball
                }
                
                ns&sym = n.t == 'checkout' ? '↽' :
                    ns&pull ? (ns&pending ? '◅' : '◄') :
                    ns&step ? '‣' :
                    (ns&pending ? '▻' : '►');
                ns&err and ns&sym += '!'
                ns&done = 6;
                #n thereup  $s:ty&up,R %sun
                # t%ball%othering should get us
            }
            
        },'ift,D'],
        
        # moves talked about 
        ['push+moves','7',&acgtRs{
            $M = Rs&moves;
            M.length &&
                n moves $s:M,R %hadmoves
        },'ift,D'],
        # squishy shrinking ooze, preserving interesting events
        # more info at latest
        ['hadmoves','3',&acgtRs{
            $p = Ry&up;
            $forget = [];
            each in s {
                # done this round
                if (ns&done == 6) {
                    ns&done = 9;
                    $r = nc&pusher;
                    # branch at %push%their with %move
                    r and nc&pushed = latestR(r)
                }
                # id by name then symbol
                $sym = n.t;
                ns&sym and sym = ns&sym
                n $n.t  $s:sym %fs:12,hs:594
                
                ns&err and me&tsc,'error',ns&err,'d';
                ns&warn and me&tsc,'warn',ns&warn,'d';
                
                # condenses
                if (s.length > 5) {
                    $ne = s [i+1];
                    ne && n.t == ne.t and forget.push(i)
                }
            }
            
            forget.map(i => s.splice(i,1));
        },'ift,D'],
        

    ] };
    
    #c TeCo
    # minimal pin-like thing returner (harness acts)
    me.domething = &acgttc{
        !me[t] and throw "no me."+t
        !c.acgt and throw "somethingelse"
        $r = me[t](A,C,G,T, ...c.acgt);
        c.returns && !r and throw "me."+t+" !return"
        return r
    };
    # %act='TeCo' gets this %made
    #  make instructions for Co
    me.TeCo = &acgtRhtc{
        $s = hc&s;
        # s:
        # haps
        #   step_1
        #     WaTe %H:38247253
        #       someelvising
        #   step_2
        #     haps %H:38231253
        $Co = G&Cye,['Co',''];
        i $Co/$s
        # r is %made
        $r = me&Copy,R,Co,18;
        
        # want to just:
        # o $Co/*:main/*:step/*:do
        # with %ball layer, style main + do
        
        $main = me&ioty,r,'%ball' [0];
        $m = mainc&s;
        ms&Serarar = 'was';
        
        # ensure step_1
        !mains&z and me&input,main,'step_1';
        $steps = me&ioty,main,'%ball';
        each in steps {
            # ensure doing=main.t
            !ns&z and me&input,n,main.t;
            $does = me&ioty,n,'%ball';
            each id does {
                $n = dc&s;
                # whittle to instruction part
                # hiding whatever is here that is not it:
                # - the H object it should be
                ns&H and ds&H = delete ns&H
            }
        }
        
        # < any s&H still anywhere should be loaded in
        # < why only now can this have effect?
        $main = me&ioty,r,'%ball' [0];
        $m = mainc&s;
        ms&Here = 'was';
        
        delete rs&ov;
        rs&Lines = 3;
        # onward 2%ball Rsyncs, anything under r may ~
        me&Ring,r;
        
        $mains = me&ioty,r,'%ball';
        each im mains {
            # blows everything away when othered
            ms&clobberypushingz = 1;
            # limit othering of steps (to %run%currentstep?)
            ms&pushingnoz = 1;
            ms&invent_step = m.t;
        }
        ~TeCo: main.t
        return r
    };
    #c act
    # where it must do a computation
    # the R that %push%made, relative to others
    # ie an elvising that sleeps
    me.Actingness = &acgtR{ return [
        # the R that %made
        ['push+act','72',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            $t = Rs&their;
            # this R with %here + %made when %move was made
            $doing = Rs&doing;
            # sublates other diffs
            Rs&diffya ||= {};
            Rs&diffya.theirs = 0;
            Rs&diffya.diffs = 0;
            
            # diff the input that %made et (approx)
            doing and $indiff = me&diffya,R,'input',h,doings&here
            if (indiff) {
                # input better understood as %made
                indiffs&sublated = 1;
                if (indiffs&exactly) {
                    # sleep %made by
                    Rs&made = doings&made
                }
            }
            
            # %made ||= the act
            Rs&made ||= me&domething,Rs&act,{acgt:[R,h,t],returns:1};
            
            # diff %made to %made when move was made
            doing and me&diffya,R,"made",Rs&made,doings&made
            
            if (t && t.t != h.t && t.t == 'Co') {
                Rs&mained = me&ioty,Rs&made,'%ball' .filter(n=>n.t == h.t)[0];
                !Rs&mained and throw "No Co/%mained thing";
            }
        },'ift,D'],
        
        # < as part of a %push%made%plan to make Co/%main/%steps
        
        # %made = Co [haps[step[do[elvis]]]]
        # is othered to %their instead of %here, so:
        # %mained = %made Co/haps
        # %main = %their Co/haps
        # two halves of living situation
        ['push+act','591',&acgtRs{
            Rs&push >= 9 and return
            $h = Rs&here;
            !h and return me&waits,'..h'
            $t = Rs&their;
            if (!t) {
                me&waits,'..t'
                Rs&losttheir = 1;
            }
            !t and return
            
            if (t.t != h.t && t.t == 'Co') {
                # locate their main thing (othered from %mained)
                $main = me&ioty,t,'%ball' .filter(n => n.t == h.t)[0];
                !main and return
                Rs&main = main;
                # Linesing per do
                $N = me&ioty,main,'%ball%ball';
                each id N {
                    #me&tsc,'indo','('+d.t+')','b';
                    me&suggesc,d,'Lines';
                }
            }
        },'ift,D'],
        #c act-made
        # Co/Hap/ Hap v1...
        # a bug chaser
        # make deals across the border so
        # a layer of task built onto a push
        # some complicated thing breaking out steps
        # < take %made/%step++ to %main/%step
        ['push+act','73',&acgtRs{
            s&bow = '3px';
            n act  $s:Rs&act %deco
            $h = Rs&here;
            $t = Rs&their;
            # persist %run per %main%ball c&s
            $mains = Rs&main && Rs&main.c.s;
            #  per clobberypushingz, restarts test run (drops J)
            $r = me&rollcounty,R,'run',{per:mains};
            # between two planes
            $N = me&ioty,Rs&main,'%ball'
            $Z = me&ioty,Rs&mained,'%ball';
            
            me&tsc,'thoughtclock',r.t+"@"+rs&count,'6' .sc.fs=7;
            me&tsc,'tot','('+N.length+'/'+Z.length+')','p'
            
            # zip N-results to Z-expectations,
            #  allowing more N if all is %ok
            $i = 0;
            while (N[i] || Z[i] || i == 0) {
                $eye = i+1;
                $k = 'step_'+eye;
                n $k  $step:eye,got:N[i],exp:Z[i],R
                i++;
            }
            # 4%step and then 5%groksteps...
            n progress  R %groksteps
        },'ift,D'],
        # groksteps
        #  playhead advances when more && ok
        #  boost to add steps
        # ⧐ from the top
        # ∿ big change
        # ~ small change
        # ☯
        # 
        ['groksteps','81',&acgtRs{
            $p = Ry&up;
            $steps = me&ioty,p,'%step';
            Rs&ok = 1;
            Rs&more = 0;
            each iS steps {
                $doings = me&ioty,S,'%doing';
                each in doings {
                    ns&doing == 1 and return T.wide = 1
                    !ns&got and Rs&more = 1; break
                    # results got must be ok
                    !ns&ok and Rs&ok = 0
                }
            }
            
            Rs&ok and me&tsc,'ok'
            !Rs&ok and me&tsc,'notok','!','B'
            
            Rs&more and me&waits,'more','...'
            
            Rs&more && me&waits,'more','≻','L'
            !Rs&more && me&waits,'moreanyway','⊁','L'
            
            Rs&ok && Rs&more and Rs&wantstep = 1
            Rs&boost > 0 and Rs&wantstep = 1; Rs&Te.sc.boost = 0
            
            Rs&wantstep and ps&stepforward = 1
        },'ift,D'],
        
        # others a %main%step
        ['push+made','82',&acgtRs{
            $m = Rs&mained;
            $M = Rs&moves;
            if (Rs&stepforward) {
                # should be ready
                !m || !Rs&main || !M and return me&tsc,'noforward',"!main"
                # find step with no %got
                $N = me&ioty,R,'%step';
                $S = N.filter(S => !Ss&got)[0];
                if (!S) {
                    # go beyond expectations
                    $doing = ms&invent_step;
                    !doing and throw "no more steps"
                    typeof doing != 'string' and throw "doing"
                    doing = G&Cye,[doing,''];
                    
                    $la = N.slice(-1)[0];
                    $i = las&step + 1;
                    $S = G&Cye,['step_'+i,''];
                    S = me&Copy,R,S,18;
                    me&input,S,doing;
                    
                    delete Ss&ov;
                    Ss&Lines = 3;
                    # onward 2%ball Rsyncs, anything under S may ~
                    me&Ring,S;
                }
                else {
                    !Ss&exp and return me&tsc,'noforward',"nextstep!exp"
                    S = Ss&exp;
                }
                
                # S is now a new %mained %step's %ball (or looks like it)
                # push the new %step to %main
                m step $from:S,into:Rs&main,pusher:R %step
                S && Ss&string and me&tsc,'shipping',Ss&string,'6'
                #n stepth  $s:Rs&main,R %sun
                
                #$c =
                #m push $from:h,to:t,pusher:R
                ~wouldstep: R.t
            }
        },'ift,D'],
        #c step acceptor
        # %push's %step/%doings build up %ok
        # < hang %step on the %here %ball it's for
        ['step','2',&acgtRs{
            Rs&rowish = 1;
            $p = me&zoep,R,{up:'%push'},'step','S','';
            $m = me&rollcounty,R,'mem',{per:ps&run};
            
            # go main/mained %step -> %do
            $N = me&ioty,Rs&got,'%ball';
            $Z = me&ioty,Rs&exp,'%ball';
            
            $i = 0;
            while (N[i] || Z[i] || i == 0) {
                $eye = i+1;
                $k = 'doing_'+eye;
                n $k  $doing:eye,got:N[i],exp:Z[i],R
                i++;
            }
        },'ift,D'],
        ['doing','3',&acgtRs{
            $p = me&zoep,R,{up:'%step%push'},'doing','.','';
            $m = me&rollcounty,R,'mem',{per:ps&run};
            $M = ps&moves;
            $g = Rs&got;
            $x = Rs&exp;
            # helps %groksteps decide things are ready
            # (A below should be done by the time...)
            Rs&doing = 3;
            x && !g and return me&waits,'nogot','...'
            !x && !g and return me&waits,'noexpgot','..!'
            
            # prepare to %diff
            $dc = {};
            # was no %doing
            !x and dc.unexpected = 1
            else
            # was no %doing%H, the result
            # swaps x with nothing insides %diff
            !xs&H and dc.unexpected = 1; dc.expGhost = &{};
            else {
                # make it look Linesey
                xs&dige = xs&H;
                # decode contents if needed (for a diff_
                dc.expGhost = &{ return me&GhostOut,R,xs&H; }
                # < decompress vastnesses
                # < use trusted code to generate everything?
                #   a lobo A4 copying dispatches from a live instance
                #   clonesyncing as it transports between them
            }
            
            # got %ball = n
            $W = g && gc&s;
            # replaces instruction
            W && !Wy&C and return me&waits,'noWyC','n...'
            
            # diff
            if (g) {
                $d = me&diffya,R,R.t,g,x,dc;

                # < what happens to this?
                ds&new and me&tsc,'nothere','⧀','L'

                ds&exactly and Rs&ok = 1
            }
            
            Rs&ok and ms&ok = R
            elsif (ms&ok) {
                # results are allowed to wander off once ok
                # such info is interesting
                # < accept/test for history-warp
                d and ds&sublated = 1
                n accepted_before s:=)
                Rs&ok = 3
            }
            
            #c This
            # we have a diff, know if ok now/before
            # and all this:
            if (W) {
                if (Rs&boost < 0) {
                    # quick redo thing
                    # < when it <G
                    $p = g.y.up;
                    $ps = pc&s;
                    $pi = pss&z.indexOf(W);
                    pi < 0 and throw "nofind"
                    !Wy&C and throw "nooriginal"
                    W = pss&z[pi] = Wy&C;
                    delete Wy&C;
                    W = null;
                    Rs&Te.sc.boost = 0;
                    return
                }
                # the object
                n Cit  $self:W,R %Reis:Cit,set:Cit
            }
            
            Rs&ok and return me&tsc,'ok','ok','p'
            
            if (W) {
                if (Ws&err) {
                    $skull = '☠';
                    me&tsc,'error',skull,'D';
                    me&tsc,'error',Ws&err,'d';
                }
            }
            
            # we have %here, find names for %step/%doing
            $S = Ry&up;
            $stepname = Ss&exp ? Ss&exp.t : S.t;
            $doingname = x ? x.t : 
                # to save an invented step/doing (!x) as got
                g ? g.t :
                R.t;
            
            # accept change
            if (g && Rs&boost > 0) {
                !Rs&shove and Rs&Te.sc.boost = 0;
                me&tsc,'accept',"<",'L';
                
                # find us from %here
                $step = me&input,ps&here,stepname;
                $doing = me&input,step,doingname;
                # store an object
                !gs&dige || !gs&string and throw "weird"
                me&GhostIn,R,gs&dige,gs&string;
                # put pointer
                $ds = doingc&s;
                dss&H = gs&dige;
                
                $dt = ds&Te;
                # reset diff about to become '='
                dt && dts&boost and dts&boost = 0
            }
        },'ift,D'],
        # encloses one of these,
        #  lest it Display before the M of Ry&up
        # always gives a new refpool,
        #  and first rs&self from Rs&self
        ['Reis','3',&acgtRs{
            $c = {refpool:1,self:Rs&self};
            Rs&set and c[Rs&set] = 1;
            Rs&ReisR = me&Reis,R,Rs&Reis,null,c;
        },'ift,D'],
    ] };
    #c pushy
    # operate on Ghost/kvstore remotely
    # < s&H object pointers wander borders
    me.GhostOut = &acgtRk{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $s = localStorage[k];
        !s and throw "noH: "+k
        # a %ball with %Lines=0
        return Ghosts&arrange_decoder(k,s);
    };
    # write-once storage
    me.GhostIn = &acgtRks{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $bs = localStorage[k];
        bs && bs != s and throw "hash collision?"
        localStorage[k] = s;
    };
    # the source of your information
    # o ^^%push %here %pushed'lookup' %there
    me.sGhost = &acgtR{
        $Ha = me.cby(R,&b{ return
            bs&pushed && bs&pushed[0].t == 'lookup'
        })[0];
        if (Ha) {
            $pl = Hac&pushed[0];
            $Ghost = pls&there;
        }
        else {
            #  %pushed falls off if throw
            $Ghost = me&pushpath,R,['/','G'];
        }
        return Ghost
    };
    #c diff balls with strings
    # setty http://xahlee.info/comp/unicode_math_operators.html
    
    # keep diffs around 7%push
    me.diffya = &acgtRkhtc{
        c ||= {};
        ex(c,{t:k,got:h,exp:t,diff:1});
        $dt = Rs&diffya ||= {};
        # may be switched off:
        dt[k] != null && !dt[k] and return
        $d = dt[k] = me&Ret,R,c;
        # can be seen to be ... already
        t && h && ts&dige == hs&dige and ds&exactly = 1
        h && !t and ds&new = 1
        return d
    };
    
    # a %diff
    me.Diffingness = &acgt{ return [
        # < map diff back out to %balls, if clicked
        # < might turn the diff into another artifact of time
        #   that needs rebasing when what you're working on changes
        # < making several commits of a bunch of change
        #   by the initial diff selecting %self%balls
        #   to go %othering into a %staging%balls
        #   %Lines that and diff etc against %other again
        
        ['diff','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            s&ma = 0.2;
            s&pa = 0.3;
            s&lh = 1;
            s&bob = '1px dotted yellow';
            Rs&hue and s&hue = Rs&hue
            # ^ applies to diffproximate but not the patch?
            
            $g = Rs&got;
            me&sch_didLines,R,g,'got';
            $x = Rs&exp;
            x && !Rs&expGhost and me&sch_didLines,R,x,'exp';
            $ob =
            n $R.t 13 s:~ %fs:29,lh:0.1
            
            if (x) {
                if (gs&dige == xs&dige) {
                    # apparently the same, avoid load/decode
                    obc&s = '=';
                    ob.t += ' equal';
                }
                elsif (Rs&expGhost) {
                    # decode contents of expectation
                    x = Rs&exp = Rs&expGhost();
                }
            }
            if (!x) {
                !Rs&unexpected and throw "Not expected to be unexpected"
                # < most after the difference from previous step
                obc&s = 'new!'
            }
            if (me&Mw,R,'err' .length) {
                n diff3_errors  s:⊗ %fs:18
                obc&s = '!'
            }
            if (obc&s.match(/[!=]$/)) {
                if (Rs&boost > 0) {
                    n entirety  $s:gs&string %max-height:7,over,dis
                }
                return
            }
            
            # switch chunk: word/line

            me&rollbs,R,'Digs,Diff,CompN,Comp';
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;

            # the job
            $c = {chunk:'word',fold:1};
            $N = Rs&Diff ||= diff(xs&string,gs&string,c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }

            me&diffproximate,R;
            
            if (Rs&boost > 0) {
                $l = Ry&up;
                ls&rowish = 1;
                $p =
                n patch   %max-height:7,over,dis
                ps&z = [...Rs&Comp];
                
                if (!ps&z.length) {
                    obc&s != '=' and throw "empty patch !="
                }
            }
        },'ift,D'],
        ['diff','87',&acgtRs{
            Rs&sublated and s&fs = 4
        },'ift,D'],
    ] };
    
    
    #c Ring mind, doming
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
        return r
    };
    # empties grounda&z into M or more R
    me.endome = &acgtR{
        !T.nN || !T.nN.length and return
        $N = T.nN;
        T.nN = [];
        $M = null;
        each in N {
            if (nc&R) {
                # spawn R?
                $parent = R;
                $s = nc&R;
                if (s && Rc&N.indexOf(s) >= 0) {
                    parent = s;
                    s = null;
                }
                delete nc&R;
                nc&s and s = nc&s; delete nc&s
                ex(n.sc,n.c);
                $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
                parent != R and zN(r)
            }
            else {
                # otherwise this mindthing grows M
                M ||= me&Mw,R,t.t;
                M.push(n)
            }
        }
    };
    
    # outdated syntacticon toward Reis
    # not looking like Instructions
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    

    
    # while the R.t == mind of this pool
    $osu = &R{
        $task = Rs&task || R.t;
        !me[task] and debugger;
        
        # bit of caching on the w.t=Coffle, closured from eval
        $mI = ws&makesI ||= {};
        mI[task] and return mI[task]
        
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','17',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        $N = me[task](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            
            # compile instructions
            if (ns&ift == '1') {
                $op = n.t.split('+');
                if (op.length > 1) {
                    # must have all these sc
                    ns&ifs = op
                }
                else {
                    ns&if = 's'+n.t
                }
            }
            elsif (ns&ift) {
                ns&if = 's'+ns&ift;
                ns&ifeq = n.t;
            }
            
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        mI[task] = z;
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    #c Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        #c walk the tape, trying to do more
        $busy = 1;
        $sheer = 45000;
        $onlyt;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                onlyt = null;
                $lowci = '';
                $ati;
                each in hc&N {
                    if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                        lowci = ns&ci;
                        ati = i;
                    }
                }
                #lowci != '' and hs&iN = ati-1
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            Ry&R ||= R;
            
            # step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            R.c.not and continue
            #onlyt && t != onlyt and continue
            
            hs&ov && hs&ov < ty&cv and continue
            
            # deciding
            $T = {};
            if (ts&ifs) {
                each ik ts&ifs {
                    R.sc[k] == null and T.not='ifs'
                }
            }
            if (ts&if && !T.not) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='ifh'
                elsif (ts&if[0] == 's') {
                    $v = R.sc[ts&if.substr(1)];
                    !v and T.not='if'
                    ts&ifeq && v != ts&ifeq and T.not='ifeq'
                }
                else {
                    throw "if "+ts&if
                }
            }
            
            if (!T.not) {
                $packdown = [];
                if (ts&D) {
                    # doming for n
                    T.nN = [];
                    packdown.push(&{
                        # empties T.nN into M or more R
                        me&endome,R;
                        delete T.nN;
                    });
                }

                $cb = tc&s;
                #!hak(R.c,'s') and debugger;
                
                cb(A,Rs&C||C,G,T,R,Rc&s);
                
                packdown.map(pd=>pd())

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            if (T.wide) {
                Rs&widenings ||= 0;
                Rs&widenings++ > 30 and debugger;
                delete T.wide;
                busy = 1;
                continue;
            }
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            onlyt = t;
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c Graze
    # waltzing stringpasses,
    # part of A:s:C, the C way to oscillate
    #   sprouts some sc to R
    #    C.y.R = R:C
    #  determine, certify version of etc involved
    # we have a village's machinery for progress
    # teleporting in 
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        $N = sc&N;
        $h = N[0];
        
        # R motif leads to P, leads to R...
        # spring forth
        # happenings by the 9 for the Cs
        $swims = {oph:0};
        $swim = &Rtc{
            # on the 9's A:of
            $V = swims[t] ||= me&Reis,h,t,null,{ov:0.18};
            # a pile of input
            $r = me&Ret,V,ex(c||{},{t:R.t});
            zN(r);
        };
        
        hc&s != C and throw "hcs !C"
        each iR N {
            $C = Rc&s;
            Cy&R = R;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            # for originals
            each tc swims {
                $of = C.sc[t];
                !of and continue
                swim(R,t,{selfer:C})
            }
            # and via Js
            if (0) {
            each tc swims {
                continue
                $J = s&J;
                !J and return
                $op = Js&top || Jc&s;
                !op and return
                each in ops&z {
                    nc&W != t and continue
                    swim(R,t,{other:Rc&s})
                }
            }
            }
            
            s&unknown and me&sunknown,R
            else
            s&Cray || s&sun and me&Reis,R,'Cray',c&s
            else
            s&ravel and me&Reis,R,'ravel',C
            else
            s&Rdeal and $r = me&Rdeal,R;
            else
            s&Ring and me&Reis,R,s&Ring,C
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
        each ir swims {
            !r and continue
            delete rs&ov;
            me&Ring,r
        }
    };
    #c Flim pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    $ve;
    me.Ja.Pass = &acgt{
        me&Gomp;
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Ha  $Travel:el %ravel:gee
        #n Jazz  $Travel:el %ravel:cell
        
        $ve = 4s&eland ||= G&Cye,['Vectroland',''];
        n eland  $s:ve %Cray
    };
    # provide n to %main/%step/%doings
    me.Ja.Co = &acgt{
        me&Gomp;
        $t = 1s&Te;
        # too late for this J to include it
        t && ts&z and G&yl:22,&{ me&doN,ts&z };
    };
    # do only undone %main/%step/%doings
    me.doN = &acgtN{
        each im N {
            # a main
            if (!my&began) {
                # fresh run, clear memory
                delete 4s&Jtv[m.t];
            }
            my&began ||= G&time;
            each iS ms&z {
                # a step
                ms&pause || Ss&pause and continue
                each iC Ss&z {
                    # a doing
                    C.y.C and continue
                    $live = me&adoing;
                    # if another, keep it instead
                    C.y.C = live || C;
                    if (live && live != C) {
                        live.y.C = C;
                        Ss&z[i] = live;
                    }
                }
            }
        }
    };
    # n $C # returns another
    me.adoing = &acgt{
        $q = {q:'W'};
        try {
            q.part = 'Jin';
            me&J,C.t,q;
            q.part = 'Jreturned';
        }
        catch (er) {
            # < powow with Ban to surf Bstack
            C = q.C || C;
            s&err = ki(C,2)+"   !"+q.part+"! "+er;
            ~adoing_er: s&err
        }
        return q.C;
    };
    #c Tests now we will try to make software:
    me.Ja.lobbek =
    me.Ja.happenings = &acgt{
        me&Gomp;
        $bit = 1s&bithold ||= G&Cye,['Bit',''];
        $b =
        n abit  s:lau %fopia
        i $b/$bit
        bits&bobs ||= 0
        bits&bobs --;
        #bits&bobs == -2 and throw "Unfielded quark"
        
        n Plethoria  $s:<<'' %oph:s
            # glampiture
            n now  s:noow %fs:54
        
        # < get rid of ^'s /^\t\t\t/
    };
    me.Ja.seeI = &acgt{
        me&Gomp;
        each kN ws&makesI {
            $l =
            n $k 3
            ls&z = [];
            each iI N {
                G&m,ls&z,[I.t,Iy&cv];
            }
        }
    };
    me.Ja.XV = &acgt{
        me&Gomp;
        s&Ring = 'XVer';
        n thing  $s:33
        n thing  $s:55
        n thing 32 $s:33
        $eye = 1s&count + 1;
        n thy  $s:eye
    };
    # see history work
    me.XVer = &acgtR{ return [
        ... me&Displayingness ,
        ['Ring','2',&acgtRs{
            Rc&refs = [];
            Rc&refR = [];
            each in ss&z {
                n.t != 'thing' and continue
                n $n.t  $s:n,R %fr
            }
        },'if:h,D'],
        ['fr','1',&acgtRs{
            R.t = s.t+' '+(s.y.cv||'')
        },'ift'],
        ['fr','2',&acgtRs{
            me&rollbs,R,'twang';
            Rs&twang ||= 0;
            Rs&twang < 8 and Rs&twang ++
            n twa  $s:sc&s %fs:16
            n for  $s:Rs&twang %hs:466
        },'ift,D'],
    ] };
    #c oph the coder
    me.oph = &acgtR{ return [
        ... me&Displayingness ,
        ['selfer','2',&acgtRs{
            $h = Rc&N[0];
            $Swim = hs&Swim ||= {};
            
            s = Rs&selfer;
            $I = Swim[ss&oph] ||= {};
            $z = I[s.t] ||= [];
            s.y.cv ||= 0.1;
            # only cv sorts
            me&sortin,z,s;
            $zi = z.indexOf(s);
            if (zi-1 >= 0) {
                $ot = z[zi-1];
                if (ot.y.cv == s.y.cv) {
                    Rs&overwrites = ot;
                    z.splice(zi-1,1);
                    me&tsc,'overwrites','<'+ot.t;
                }
            }
            Rs&selfed = 1;
            # there is also an %other for things coming via a J
            # self would always overwrite 
        },'ift,D'],
        ['Swim','3',&acgtRs{
            s&mb = 2;
            $D = G&Cye,[R.t,''];
            each fc Rs&Swim {
                $F = G&Cye,[f,{cv:0.001},{W:R.t}];
                ac(D,'z',F);
                each tz c {
                    each in z {
                        ac(F,'z',n);
                    }
                }
            }
            Rs&Swimb = me&Copy,R,D,{Lines:3} .c.s;
        },'ift,D'],
        ['Swimb','4',&acgtRs{
            $S = Rs&Swimb;
            me&rollbs,R,'indige';
            Rs&indige && Rs&indige == Ss&dige and me&rollbs,R,'Swum'
            if (!Rs&Swum) {
                Rs&indige = Ss&dige;
                
                # < send S to the server
                # it will W=oph and encode all this stuff
                $f = Ss&z[0].sc.z[0];
                fc&s += "\nstamp";
                
                Rs&Swum = S;
            }
            # attach to the 9
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            each iF Ss&z {
                $F = G&Cye,F;
                $N = delete Fs&z;
                each iD N {
                    i $s/$F/$D
                }
            }
        },'ift,D'],
        ['She','7',&acgtRs{
            Rs&rowish = 1;
            
            $p = Ry&up;
            ps&task != 'C' and throw "lst"
            $s = pc&s;
            #n so  $self:s,R %sun
        },'if:h,D'],
    ] };
    #c cellvey think about their state,
    # become straight, become curvy
    # have things wanting to be streamed uphill
    # showing interfaces where things can come across
    
    me.ravel = &acgtR{ return [
        ... me&Displayingness ,
        ['She','1',&acgtRs{
            $uh = Ry&up && Ry&up.c.N[0];
            uhs&task == Rs&task and return;
            # start by checking out thy name
            isC(s) && ss&ravel and R.sc[ss&ravel] = 1
            Rc&dupl = 3;
        },'if:h'],
        
        # the living - a situation
        # slow rolling wakeup
        # openness is travelled in
        # up into cell
        ['gee','3',&acgtRs{
            Rs&rowish = 1;
            # A.4 to/run/from, shared
            # is the local stage, our gear projected on
            # land of ignoring your own mind
            1s&runs == 1 and me&introqua,[A.1.t,'Ha','ravel','T',A.1.t],{boost:-1}
            n T  $s:sc&Travel,R %ball,bgh:586
            # create and harvest arrangements of gear
            #  %Teing extrapolates runningness
            n W  $lookup:s.t,R %ballse
            #,dragelvis:projvey
            # to stable
            n G  $kvstore:localStorage,R %ballse
        },'ift,D'],
        
        # ball-doers
        ['Tool','3',&acgtRs{
            Rs&rowish = 1;
            n t  $s:R.t %hs:789
            #n rec  s:●
            #n stop  s:■
            #n redo  s:◀
            n play  s:▶ %fs:22
        },'ift,D'],
        ['ball','29',&acgtRs{
            1s&Te and me&Tie,R,'play'
            !Rs&play and return
            n playing  s:▶
            
            # giving a pi? real/veyd layers of sc?
            # e /T -run . %does:TeCo %boost:2
            $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
            ls&boost = 2;
            me&introqua,l,{boost:1};
        },'ift,D'],
        
        # lookup %ball/*.t in G
        # assorted W you asked for, bay of incoming remotes
        #   elvising/G&t-ish interface to mysterious places
        ['lookup','2',&acgtRs{
            $g = Ry&up.sc.z.filter(g=>g.t == 'G')[0];
            !gs&ball and return T.wide = 1;
            # W holds many, to sync to G
            # with %lookup: highest/starting point
            $t = Rs&lookup;
            if (t != '1') {
                # < be othering ourselves, lending content
                #   to get instant %ball for things
                #   and so disconnections keep objects
                #     for packdown/gc
                #   specifying types of ephemerality:
                #     runspace kept tidier than piles
                $n = me&push,R,[],[t],'purpose';
                # ensure it's first in z
                $zi = ss&z.indexOf(nc&s);
                zi > 0 and ss&z.unshift(ss&z.splice(zi,1)[0])
            }
            
            # ready all s/* as R/*%balls
            me&Rsync,R;
            
            $N = me&ioty,R,'%ball';
            each in N {
                # posit they %push(ish) to G
                $l = me&push,n,['/','G'],[],'lookup','checkout';
            }
        },'ift,D'],
        ['continuity markers','28',&acgtRs{
            !(Rs&ball || Rs&push) and return
            $b = Rc&b;
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        ... me&Copyingness ,
        ... me&Pushingness ,
        ... me&Actingness ,
        ... me&Linesingness ,
        ... me&Diffingness ,
        #c kvstore
        # accept %pushish as a name lookup first
        #  names %decode'd and pushed here
        #   they have a %delivered %ball stuck in the past
        ['kvstore','2',&acgtRs{
            # t source
            # weak %push
            # %pushin helps project lives from s
            #   as decode
            # looks at %balls pushing to it,
            #  look for them here
            #   pushing there 
            #  accept their content if full enough
            !Rs&pushish and return T.wide = 1;
            # tell %push to do
            # < search children for %othering
            # < upgrade %othering sense to
            #   any of the objects
            Rs&pushering ||= [];
            me&rollbs,R,'rememb';
            
            Rs&get_key_for = &t{
                return ts&H || t.t
            };
            Rs&arrange_decoder = &ksl{
                # arrange decoder
                $re = Rs&rememb ||= {};
                $kd = k+dig(s);
                $bc = {task:'ravel',Lines:1,intoa:'ball',noDisplay:1};
                bc.remova = &{ delete re[kd] };
                # keep the %balls with the decoding Lines stuff
                $S = re[kd] ||= me&Reis,R,k,s,bc;
                $Ss = Sc&s;
                Ssy&decoder = S;
                Ss&keepy = 'decoder';
                if (l) {
                    # %pull%here=S, see below 
                    $L = me&push,R,[],S,'decode','hard';
                    # allow %their from ^ to look like l's %thing
                    ls&deliverer = L;
                }
                return S
            };
            
            each il Rs&pushish {
                $t = ls&here;
                # a remote %push, for some id
                $k = Rs&get_key_for(t);
                $s = localStorage[k];
                !s and ls&new = 1; continue
                
                Rs&arrange_decoder(k,s,l);
            }
        },'ift,D'],
        ['kvstore','4',&acgtRs{
            !Rs&pushering and return
            $i = 0;
            while (Rs&pushering[i]) {
                l = Rs&pushering[i];
                $t = (Rs&pushering_ball||[])[i] || ls&here;
                if (ls&hard) {
                    $S = tc&s;
                    # %here%ball must be the same
                    $still = ls&delivered && t == ls&delivered;
                    if (!still) {
                        i Rc&s/-#S.t
                        n ush  s:ush
                        ts&keepy = 'decoder';
                        ac(R,'pushing_z',l,'ball',t);
                        # becomes %push%their
                        ls&delivered = t;
                    }
                }
                else {
                    # must have a Lines done
                    !ts&ball || !ts&LinesN and throw "not %here=%ball%LinesN"
                    $good = ts&string && ts&string.length > 7
                    !good and throw "string dodgy"
                    # redecode, sets/does another ls&deliverer since lookup
                    #  checks it works,
                    #  %move%pushed%their gets what was pushed
                    $k = Rs&get_key_for(t);
                    Rs&arrange_decoder(k,ts&string,l);
                    localStorage[k] = ts&string;
                    # < check it's what %push knew about when it pushed
                    # < may contain several things to which you must link
                }
                i++;
            }
        },'ift,D'],
        #c further
        ['kvstore','6',&acgtRs{
            $N = me&ioty,R,'%ball';
            # hide innards
            each in N {
                ns&nofurtherDisplay = 1;
            }
            
            n fur  $selves:N,R %tfurther
        },'ift,D'],
        ['tfurther','3',&acgtRs{
            me&tsc,'tfurther','t','G';
            (Rs&boost||0) < 1 and return
            Rs&rowish = 1;
            s&bo = '2px dotted green';
            s&hue = 30;
            s&br = 0.4;
            # create a bunch more lookups
            
            each in Rs&selves {
                n $n.t  $self:n,R %Wirror
            }
        },'ift,D'],
        # sync localStorage -> webserver
        # use 24/NutIns' new G&t (G&ting) and it's W mode
        # from the thing receiver outran the thing providor
        ['Wirror','3',&acgtRs{
            s&hue = 80;
            me&domesticate,R;
            $h = Rs&self;
            !hs&dige and h = hc&s.y.decoder
            !h and throw "nodecoder"
            $k = h.t;
            #k = 't/iooiatal';
            $C = me&rollcounty,R,'tinging',{per:k};
            
            # persist a Question
            $Q = s&Q ||= G&Cye,[k,'',{of:'W'}];
            # which may throw async
            $ting = &Q{
                $r;
                try { r =  G&ting,Q }
                catch (er) { }
                # gets stuck in pushing mode:
                delete Qc&s;
                return r
            };
            $r = ting(Q);
            # has a Pull, with the got content or not
            # almost looks ballish, a decoded C at c&s
            # < remotism, G tendrils of causality hung, shaft utils
            # < know if its state can be guaranteed by some news agent,
            #   prefer to hear of rather than go looking for news
            #   digwaypoll
            $P = Qs&P;
            
            !P and return me&tsc,'pleasewait','...','G'
            $del = G&time,Ps&now;
            del > 16 and me&tsc,'delta','>'+del+'s','b';
            me&tsc,'here','@'+hs&dige,'G'
            
            n so  $self:C,R %sun
            !Pc&s and me&tsc,'notexist','⧁','G'
            else
            !Ps&dige and throw "eiwer"
            else
            Ps&dige == hs&dige and me&tsc,'equal','=','G';
            Pc&String == hs&string and me&tsc,'equals','==','G';
            else {
                # we have a P for the remote's branch
                # make it look like a ball so it can %diff
                Ps&ball = 1;
                Ps&Lines = 0;
                Ps&string = Pc&String;
                $d = me&diffya,R,'upstream',h,P,{hue:90};
            }
            
            (Rs&boost||0) < 1 and return delete s&qh
            Rs&rowish = 1;
            # objects/names to copy
            $M = [];
            # write obj/$dige for versioning $h (if you know %H history)
            m h.t  $s:hs&string,dige:hs&dige
            
            # move depended objects first
            each in hs&LinesN {
                $s = nc&s;
                !ss&H and continue
                $string = localStorage[ss&H];
                !string and throw "Nolocal"
                
                $L = me.cby(n,&n{ return n == h });
                $path = L.map(n=>n.t).join('/');
                
                m $path  $s:string,aka:path,dige:ss&H
            }
            $qh = s&qh ||= {};
            $abug = 0;
            each in M {
                ns&ok = 1;
                $doq = &ts{
                    $q = qh[t] ||= G&Cye,[t,'',{of:'W'}];
                    $r = ting(q);
                    $P = qs&P;
                    $wai = &s{
                        ns&ok = 0;
                        ta(s);
                    };
                    $ta = &s{
                        $st = t[0] == 'o' ? '6' : '';
                        me&tsc,'waiting',t+s,st .sc.dis = 1;
                    };
                    # has a pull, has a result (decoded by G&ting)
                    !P and return wai('..')
                    Pc&String == s and return ta('!')
                    # BUG stop it continually doing this later:
                    #   losing P on update?
                    #  just gets by if all updates succeed once
                    abug = 0;
                    Pc&String ? wai('>') : wai('*');
                    # write: add s to the question for next time
                    qc&s = s;
                    # next time
                };
                !nc&dige and throw "nodige"
                
                # a permanent object,
                #  excepting garbage collection (uninvented)
                #doq('obj/'+nc&dige,nc&s);
                
                # a place in the tree (Ha/Tothe/ThingthathasH)
                #   for some continuity in the git there
                nc&aka and doq(nc&aka,nc&s);
                
                if (!ns&ok) {
                    Rs&in_progress = 1;
                }
            }
            if (abug) {
                # see BUG ^
                n so  $self:C,R %sun
                return
            }
            Rs&in_progress and return
            # change what links it all together
            Qc&s = hs&string;
            
            delete Rs&Te.sc.boost
        },'ift,D'],
        
        
        #c haveth
        # interesting comment rubble from drained %pull:
        
        # t individuals in any place
        #     < new/gone similar -> moved
        # %haveth=to %ball vaguely
        # %other=from %ball specifica
            # once turned up, may have an in-t and an out-t
        # concat modulat 1-2?
            # < overall, has it pushed? 
            # < state change here/there click show in %ball
            #     that %ball's %pushed_ball will be historic,
            #         have sc.z %fix and etc
                # should show up as an item to push
                #   push/display change fairly easily
                # conversely, n.t only implodes:
                #   (sch_ballonlyt) -> G&t-ish, pull almost auto
                # needs some opposite to search with
            # wants to Rc&refs s now?
            # and the usual two-step confusible C-C nametag
        # < if engaged, %ball 5 notifies us?
                # engage drawing up of planes
                # becoming matter for idea/diff/apply
        
        # give idea of where on screen such ref is from here
        # eg up/prev/in = up, up/next/in = down
        # < up = left, in = right
        ['haveth','3',&acgtRs{
            if (!Rs&haveth) {
                n nohaveth  s:!
            }
            delete Rs&elvis;
            # draw an arrow between two R
            $we = me.cby(R,&R{ return Rs&cell });
            $th = me.cby(Rs&haveth,&R{ return Rs&cell });
            $direction = "v";
            each in we {
                $t = th[i];
                t == n and continue
                # path separates
                i == 0 and throw "different cells"
                $f = th[i-1];
                each il fs&z {
                    l == n and break
                    l == t and direction = '^'
                }
                break;
            }
            $d =
            n direction  $s:direction %fs:17,lh:0.05,hs:346
            
            $p = Ry&up;
            R.t == 'other' and direction == '^' and ps&upward = 1;
            
            if (!Rs&self) {
                # no yon %ball
                #R.t == 'self' and throw "self no self"
                R.t == 'self' &&
                    n ohno  s:!
                delete ds&hs; # green
            }
            # give other bigger arrow
            dc&s = dc&s == '^' ? '▲' : '▼';
            # < n should type styles into number etc
            R.t == 'other' and ds&fs = (ds&fs*1)+7
            # ◀ ▶
        },'ift,D'],
        
        #c ball, continuing thing around thing
        # that makes its C up
        #  now happens
        ['ballse','171',&acgtRs{
            $ba = 1s&ballse ||= {};
            Rc&s ||= Rc&b && Rc&b.c.s;
            Rc&s ||= ba[R.t];
            Rc&s ||= G&Cye,[R.t,''];
            ba[R.t] = Rc&s;
            Rs&ball = 1;
            delete Rs&ballse;
        },'ift,D'],
        
        # knows its %pushed to
        ['ball','2',&acgtRs{
            # see ball-othering
            me&rollbs,R,'pushed,pushed_ball';
        },'ift,D'],
        
        # squish long skinny trees
        ['ball','6',&acgtRs{
            Rs&boost and return
            me&ioty,Ry&up,'%ball' .length != 1 and return
            delete Rs&rowish;
        },'ift'],
        ['ball','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dupl = 0;
            s&br = '4';
            s&bo = '0.1em dotted #543';
            
            R.t != s.t &&
                n t 1 $s:R.t %fs:13,hs:288
            
            $t =
            n t 11 $s:s.t %deco,fs:8,fix:t,mr:0.3
            
            Rs&is == 'live' and s&bo = '4px dotted #782';
            
            if (Rs&boost < 0) {
                if (Rs&boost < -1) {
                    if (Rs&remova) {
                        Rs&remova();
                    }
                    else {
                        $pr = Ry&up;
                        !prs&ball and "up!ball"
                        $ups = prc&s;
                        i $ups/-$s
                        #upss&z = upss&z.filter(n => n != s);
                    }
                    n deleted  s:deleted %fs:6,hs:594
                    delete Rs&Te.sc.boost;
                }
                return
            }
            if (Rc&nofurther) {
                n nofurther 17 s:♲ %fs:8,mr:0.3
                return
            }
            
            if (sc&J || ss&H) {
                # should become or is a separate object
                #  H being dig(toLines(object))
                # and twocom'd:
                if (Rs&pushed) {
                    $p = Rs&pushed && Rs&pushed.filter(p=>ps&upward)[0];
                    $l = p && ps&pull;
                    n pup  $s:l,R %sun
                }
                Rs&boost > 0 and 'open'
                else {
                    Rs&nofurtherDisplay = 1
                }
                n J  s:J %fs:14,hs:966
            }
            
            # aim to keep a
            each kv s.c {
                n $k  $s:v,R %fix:c
            }
            each kv s.sc {
                k == 'z' and continue
                n $k  $s:v,R %fix:sc
            }
            
            
            if (Rs&boost > 0) {
                # edit C.t
                ts&e = 1;
                me&Tie,R,'sayeth',1;
                if (Rs&sayeth) {
                    tc&s = s.t = Rs&sayeth;
                    n cha  s:cha %fs:6,hs:594
                }
                # implant C -> C.t
                n typeball  R %etype:ball
            }
            me&endome,R;
            ss&z and me&Rsync,R;
        },'ift,D'],
        #c ballope
        # < sprout usual inquisitivity/saveness?
        ['etype','3',&acgtRs{
            n saying   %e,fs:8
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth) {
                $S = Rs&sayeth;
                $pr = Ry&up;
                !prs&ball and "up!ball"
                $ups = prc&s;
                if (S.substr(0,1) == '%') {
                    S = S.substr(1);
                    ups.sc[S] = ''
                    n made  s:+ %fs:6,hs:594
                }
                else {
                    i $ups/#$S
                    n made  s:+C %fs:6,hs:594
                }
            }
        },'ift,D'],
        
        # R%fix per c/sc style
        # < t/cv natively
        ['fix','3',&acgtRs{
            n k 1 $s:R.t %fs:11,hs:288
            
            !Rs&boost and return me&gkness,R;
            
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth != null) {
                $pr = Ry&up;
                $ups = prc&s;
                Rc&s = s = ups[Rs&fix][R.t] = Rs&sayeth;
            }
            if (typeof s == 'object') {
                # < just have to open it more
                n obj  s:obj %fs:12
            }
            n s 1 $s:s %e
        },'ift,D'],
        

        #c ball-othering
        # as %ball, consume %push+%ball from afar
        # < disconnect/packdown? (git around it)
        # < take the %move instead
        #   < make a cursor for the job of applying it
        #   < may be a search and replace or anything
        #   < %balls as soft+fast version control
        # some %push has put:
        #   %othering(_ball) # incoming %push
        #    (and the %ball it %move%from)
        # becomes:
        #   %pushing(_ball) # fixes fixtures
        #     and sets up:
        #       %pushed(_ball) # log of pushes
        #  and(/or):
        #   %pushing_z(_ball) to enter its children
        #    (or itself as a child)
        ['ball','52',&acgtRs{
            Rs&ball = 6; # look before you other
            
            # take a %move
            each in Rs&movingin {
                $r = nc&push;
                $putting = 'pushing';
                if (R == rs&there && !nc&into) {
                    # GOING
                    # %push%there = %move%to, %their will inside
                    me&tsc,'pushz','pushzthere';
                    putting += '_z';
                }
                nc&into and putting += '_z';
                !ns&move and throw "!move"
                !ns&from and throw "move!to"
                # < sprawl %move as it others
                ac(R,putting,r,'ball',ns&from);
            }
            
            if (Rs&othertricks) {
                n oth  s:othertricks
            }
            
            each ir Rs&othering {
                # want the %move to be around?
                if (rs&push) {
                    # a %push putting:
                    $t = (Rs&othering_ball||[])[i] || rs&here;
                    $putting = 'pushing';
                    # if %there is here, their will inside
                    R == rs&there and putting += '_z';
                    ac(R,putting,r,'ball',t);
                }
                else {
                    # a %pull putting %self at %other
                    $o = rs&other;
                    if (o) {
                        $cb = me.cby(o,&o{ return o == R });
                        !cb || cb[0] != R and throw "%other not here"
                        ac(o,'pushing',r,'ball',rs&self);
                    }
                    else {
                        rs&putting and throw "%pull !%other %putting somewhere"
                        # or just here-ish, with a put-in-z emotion
                        ac(R,'pushing_z',r,'ball',rs&self);
                        # < build there down a branch, pass tests
                    }
                }
                
                $pr = ry&up;
                $D =
                n pushed   %fs:7
                D.sc.bo = '2px solid yellow';
                Dc&s = pr.t+'/'+r.t;
            }
            # %pushed keep their %push up to date
            each ir Rs&pushed {
                Rs&pushed[i] = me&yfuture,r;
                # < de-other zombies by rc&ip...
                # < things rupturing as they delete
                #   themselves at the edge of the light cone
            }
            each ir Rs&pushing {
                # whose treeing %ball is already here
                $S = ac(R,'pushing',r,'ball');
                !Sc&s and throw "pushing !cs"
                !Ss&ball and throw "pushing !ball"
                # and replacing the last %self
                $l = ac(R,'pushed',r,'ball',S);
                $Ss = Sc&s;
                
                # the t detail (%from can rename %to)
                Ss.t != s.t and s.t = S.t
                
                # the c/sc details, per %ball%fix'd
                each in Ss&z {
                    !ns&fix and continue
                    $gk = ns&fix;
                    # GOING
                    if (Ss&othertricks && gk == 'sc') {
                        ~baresc: R.t, S.t
                        continue
                    }
                    # < clone-out function would live on n%ball%fix
                    s[gk][n.t] = nc&s;
                }
                # for streaming contents with other %pushes, eg %main/%steps
                Ss&pushingnoz and continue
                ac(R,'pushing_z',r,'ball',S);
            }
            each ir Rs&pushing_z {
                $S = ac(R,'pushing_z',r,'ball');
                $self_was_here = Rs&pushing && Rs&pushing.indexOf(r) >= 0;
                $z = self_was_here ? Ss&z : [S];
                each in z {
                    !ns&ball and continue
                    $x = nc&s;
                    if (ns&othertricks || ns&clobberypushingz) {
                        i Rc&s/-#$x
                    }
                    # n thing that should be here
                    #   Rs&z +[ t%ball -> clone(nc&s)
                    # starts with spacer, keeps t%pushing=S to it
                    $t = me&input,R,x.t;
                    ts&ball && ts&ball == '6' and debugger
                    # keep %pushing=n
                    ac(t,'pushing',r,'ball',n);
                    if (ns&keepy) {
                        # %kvstore's G/%balls othered from the decoder
                        $S = tc&s;
                        !x.y[ns&keepy] and throw "link no exi"
                        S.y[ns&keepy] = x.y[ns&keepy];
                    }
                }
            }
        },'ift,D'],
    ] };
    #c Ringing unknown
    me.Displayingness = &acgt{ return [
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 888;
            Rc&dl ||= 35;
        }],
        ['Displayingness','3',&acgtRs{
            # R can be clicked big/small
            me&boostulate,R;
        }],
        # data dump R%sun
        ['sun','3',&acgtRs{
            Rs&sun == 2 and Rc&refs = []; Rc&refR = [];
            me&Reis,R,R.t,s||Rs&self,{task:'Cray'};
        },'ift'],
        
        ['Displayingness','9',&acgtRs{
            Rs&noDisplay and return
            $d = me&Display,R;
        },'if:h'],
    ] };
    me.Cray = &acgtRs{ return [
        ... me&Displayingness ,
        ['She','3',&acgtRs{
            $h = Rc&N[0];
            $p = Ry&up;

            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                me&gkness,R;
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });
            
            Rs&boost > 0 && Rc&d == 0 and Rs&runny = 2

            
            if (scan.C && (Rs&runny > 1
                ||
                (Rs&runny || Rc&d == 0) && sy&tv && ss&z && !ss&J
                )) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        }],
    ] };
    #c Cit
    # dive into the result
    #  after it was made
    # see XVer for during
    me.Cit = &acgtR{ return [
        ... me&Displayingness ,
        ['Cit','13',&acgtRs{
            # subverted refs dedup
            s = Rc&s ||= Rs&self;
            !Rs&ot and Rs&ot = R.t;
            isC(s) and R.t = s.t
            Rs&ot == R.t and delete Rs&ot
            
            $p = Ry&up;
            ps&Cit || ps&Citop and return
            Rs&Citop = delete Rs&Cit;
        },'ift'],
        # the top Cit looks it over more
        ['Citop','6',&acgtRs{
            $b = Rc&b;
            $p = Ry&up;
            ps&ok and Rs&ok = 1
            # ok-ing overthing should calm...
            Rs&ok && b && !bs&ok and Rs&boost--
            
            s&bo = '2px dotted blue';
            s&hue = 30;
            s&br = 1;
            s&ma = 0.3;
            s&pa = 0.3;
            #s&float = 'right';
            !Rs&Te || !Rs&Te.c and s&fs = 6;
            
            if (!isC(s)) {
                me&tsc,'notC','Cit:notC','d'
                n notC  $self:s,R %sun
                return
            }
            
            n C  $s:s,R %Cit
            # ^ should have probes elvising:
            $WR = sy&R;
            if (WR) {
                $on = WRs&on;
                if (on) {
                    n yRson  $self:WR,R %displayon,maybe
                }
            }
        },'ift,D'],
        ['Cit','6',&acgtRs{
            $Cit = &tsc{
                $n =
                n $t  $s:s,R
                ex(n.sc,ex(c||{},{Cit:1}));
                return n
            };
            # title 0
            $doot = &t{
                $v = me&tsc,'ot',(t||Rs&ot||R.t),'q';
                vy&cv = 0.01;
                vs&deco = 1;
                doot = &{};
            };
            Rs&ot || Rs&tiny and doot()
            $scan = Rs&scan = me&scan,s;
            scan.is == 'C' && sy&R == s and scan.is = 'R'
            scan.is == 'C' && ss&W and scan.is = 'W'
            Rs&ma and s&ma = Rs&ma
            
            if (scan.sym == '[') {
                n open 4 s:[ %hs:489
                each in s {
                    Cit('['+i, n, {tiny:1,ot:R.t});                
                }
                #n close 7 s:]
                return
            }
            if (Rs&istw) {
                each kv s {
                    $c = {};
                    Rs&tiny and c.tiny = 1
                    Cit(k,v,c)
                }
                return
            }
            
            Rs&boost > 0 and delete Rs&tiny
            if (Rs&kvey) {
                each kv s {
                    $c = {};
                    Rs&tiny and c.tiny = 1
                    Cit(k,{},c)
                }
                s&dis = 1;
                return
            }
            Rs&tiny and return
            
            # title 1
            me&domesticate,R
            !Rs&dis and delete s&dis;
            
            #n swhu  $self:scan,R %sun
            
            if (scan.C && (Rs&boost||0) < 1) {
                #n yes  s:y
            }
            elsif (scan.C && Rs&boost < 2) {
                # several C's with some interesting stuff in
                # < look for anomalies
                #   generate maps to call things
                if (scan.is == 'W') {
                    sy&R and Cit('yR',sy&R,{Rit:1,dis:1});
                }
                if (scan.is == 'R') {
                    $hem = {kvey:1,tiny:1,ma:0.3};
                    Cit('y',s.y,hem);
                    Cit('c',s.c,hem);
                    Cit('sc',s.sc,hem);
                }
            }
            else {
                #me&tsc,'notC','here','d'
                doot()
                n $R.t  $self:s,R %sun
            }
        },'ift,D'],
        # as well as Cit-ing, shade and understand A
        ['Rit','6',&acgtRs{
            !sc&N and throw "Rit !R"
            $I = sy&I;
            if (I && !Rs&isI) {
                n yI  $s:I,R %Rit,Cit,isI
            }
            if (Rs&isI) {
                # see the big picture
                $head = sc&head;
                if (head) {
                    n chead  $s:head,R %Cit,istw
                }
            }
        },'ift,D'],
        
        ['displayon','3',&acgtRs{
            me&tsc,'displayon','D','G';
            (Rs&boost||0) < 1 and return
            Rs&rowish = 1;
            s&bo = '4px dotted green';
            s&hue = 30;
            s&br = 0.4;
            ac(R,'down',s||Rs&self);
        },'ift,D'],
    
    ] };
    
    #c Cing exit the entrance
    me.domesticate = &acgtR{
        # 1
        $M = me&Mw,R,'traw';
        $t =
        m t 1 $s:R.t %fs:13,hs:288
        if (Rs&fornt) {
            # coming off the grounded C, name after that C
            $proc = "|"+R.t;
            m into 118 $s:proc %fs:11,hs:267,bgh:230
            tc&s = Rs&fornt;
            ts&bob = '1px dotted white';
        }
        
        # types at s
        $scan = Rs&scan;
        !scan and return
        
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955
        
        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    };
    me.bagatagage = &acgtR{
        $scan = Rs&scan;
        $ks = scan.ks || [];
        if (scan.C) {
            ks[0] != 't' and debugger;
            ks.shift();
            $s = Rc&s;

            $M = me&Mw,R,'.t';
            scan.is == 'A' &&
                m tofA 19 s:: %ls:-0.2

            m t 2 $s:s.t %deco,fs:15

            if (scan.is == 'A') {
                $cv = s.cv+'';
                cv[0] == '0' and cv = cv.slice(2);
                cv = '@'+cv;
                m cv 21 $s:cv %ls:-0.1,hs:339
            }
        }

        if (scan.modu) {
            each in scan.modu {
                n.t == 'weirdkeys' and continue
                $M = me&Mw,R,'modu:'+n.t;
                me&Modu,[n],M;
            }
        }
    };
    
    me.gkness = &acgtR{
        $M = me&Mw,R,'traw';
        
        # make block,inline have same indento
        $p = Ry&up;
        $iN = (ps&z||[]).indexOf(R) - 1;
        $f = iN >= 0 && ps&z[iN];
        f && fs&rowish and s&ml = 1
        
        s&fs = 7;
        m sym 12 not
        $pow = 2;
        Rs&boost and pow = 4;
        $string = ki(Rc&s,pow);
        if (string.length > 100) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    };
    me.wktion = &acgtRs{
        $wk = s;
        s = Rc&s;
        $p = R.y.up;
        if (p && ps&scan && ps&scan.C) {
            if (R.t == 'c') {
                if (wk.indexOf('sip')>=0) {
                    wk = wk.filter(n => n != 'ip' && n != 'sip');
                    $fa = 4s&famous;
                    $slip = s.sip;
                    $M = me&Mw,R,'sip';
                    # tradeoff between things
                    if (fa) {
                        each in fa {
                            s.sip.indexOf(i) != 0 and continue
                            m famous  $s:n.t %deco,fs:7,hs:999
                            slip = '.'+s.sip.substr(i.length+1);
                        }
                    }
                    m sip  $s:slip %fs:7,hs:999
                }
            }
        }
        return wk
    };
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        if (s && typeof s == 'object') {
        # dedupe/limit objects already in this pool
        $ri = Rc&refs.indexOf(s);
        if (ri < 0) {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            RN.push(R);
            # in this pool
            $RhN = RN.filter(r => h && rc&N == hc&N);
            $dupl = Rc&dupl || 0;
            if (RhN.length > dupl) {
                limit('dup');
                Rc&nofurther = 1;
            }
            else {
                
            }
            !Rc&nofurther and limit('dub')
            # < to know circular links, converge
        }
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X, inwards
    #     X.z = [ R nodes
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    me.RbitX = &acgtR{
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # starting into Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        R.y.I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    # grow current R
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        if (c.refpool) {
            # we become a pool of refs
            #  something about A.1-9
            #   the magnitude of a distance
            delete c.refpool;
            Rc&refs = [];
            Rc&refR = [];
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    # name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task ||= r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                h && hs&joinR and rc&N = hc&N
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    

