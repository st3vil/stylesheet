Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    io.doz = 1;
    io.usu_dup = &{};

        # Relosophy of C and R
        =pod
    
    A = R, creature of something like a throat
      throat: where Instructions iterate over Culture
    
    =head1 Srupto
    we want to allow pin Steps to be Instructions
      a way to grab anything at any rhythm
    
    the baseline C mode includes encoding Instructions:
     Cont
       thinger 3 s:'s&er++' %of:Lat
    becomes:
     Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
    then:
     Cont transports
     Lat is I stuff (%W with %z), posited as being Lat
     thinger is encoded (Latc&W:of)
    such that it is mostly ready for action:
    A.3+ believes in Cont%W
    A.1 somewhere wants Lat
        (or thinger, knowing things like Lat might contain it)
     by elvising G/$pathtoA1/Lat,
      finding/choosing a Lat,
      which must 6 the whole of what it bit
        (W around might be only indexing of what can be got)
    do-ing
    then that elvising attaches to A.1/G/Lat/Cont
     which A.3 hoists/attaches/encodes/stores as some of:
       A.3/G/Cont # no idea wherefor but small edge
         # does updates for change at the large-object level
       A.3/G/Cont/$pathtoA1 # know where to send attention
         # andor where in the stream of Cont the change is!
       A.3/$pathtoA1/G/Lat/Cont # Q/A format per place
         # lends itself to network change sensitively
     easily all at once
     hyperspheres of definition named simply
    and store perhaps on the first line of the W in Lines:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Stuff   %produced
    and something incorporating Cont and more looks like:
     AyeOne   %W,G:Cont@238hfd34;Normal@49d8c9ff
       Cont   %W
       Lat  W:of %W
         thinger 3 s:'C.c.er++'
         thingo 3 s:'C.c.o++'
       thingo 3 s:'s&er++' %of:Lat
    
     when thinger blows up, inspected:
        thinging from AyeOne%W/Lat%Wz/thinger
        and as asking around about random things:
        find AyeOne%W/Cont%W (aka Cont%W) also has Lat/thinger
        things may be asleep about here,
        but may be able to show source code, compile/mutate it
    
    looking at the G would be lots of io-ing
      things packed into it
      checking those injection/projection points
      is bitXgonerism
      relying on percolating those things
        along things that we can relive
       or shut down, rearrange, tamper with
      as osc-compatible:
       various $Gish of $Wish may be attached to $Wish
         so long as osc understands what/how to involve/mixage
       even outside itself on $Woth/$pathtoWish/$Gish
        just as $Teing is an index of landstructions to go here
        we have the chance to take with us or trust to recreation anything
        
       they are understood by the I, made meaningful where $Wish is
      and hoist/dehoist its structures into other places
        with others doing the same thing
      and also just the giant tabulation
    
    #c ph (post R re-combobulation)
    osc does new A:I over the old one
      probably rolling everything
     A:C make separations of a thing or things
      lets its content be distributed and depended on
      pattern matched and made into elvisings out to W:of,
      putting into a further self
    
    so C may need separation to preserve various objectives:
     A:n C being the most-uphill thing
     A:C = C coming in
     A:s = C for doming/playing sc forward
     A:C = C going out
     A:W = C encoding/compressing
    they all have ways to know about their previous lives
    
    
    
    another life of the underlying shape:
    A - receivability
    C - received culture
    G - culture + momentum, implantations
    T - what could not fit in,
      its mysteries/problems/developments,
      its inclusion to/from the world
        to as in for Teing into some W-position,
        from as in its life was because of such insTruction
      the T is like the G
        dealing with a big tangle of comings & goings
    the T decides/dealswith the edge of the picture,
    by hoisting/making the content misfiture,
      such that a big C can have its anomalies adjusted
    
    the layer above io, provides mode ala c&el
      io needs to readwrite A&X/A&V/A&Xo
        to provide the memory of the current play
        in parallel to the previous one,
          noticing when C views should complete (gonerism)
    diversifying how to match $thing against $Thing,
      what we are looking for,
      what level of understanding to borrow what from
    yet producing that sc-lang about how it was written:
      Some%sounds = {index of direction to points of resonance}
    there could be:
      Cs making the structure of any kind of index
      direction Cs, coming from/with merge/over/with/etc
      resonating Cs, beings in a constellation unknown to themselves
    
    A:s would be driving towards a goal
     juggling dives in, points and progress
       of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
     compiles fast checkers of 0-2 wobble once inflated
      so lowlevel changes (container re-ref) cause higher modes
    needs a playspout
     told/finding how innards roll through time (A&ip++)
     pointing to things, as if regrouping into another
      laying schemes on what to do
       producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked, wandering
    
    drawing cellular boundary
      s&z = more C,
        so might its A&z = more A
      based a bit on A signage (A.so = $so)
        $so might be via Ay&up (would know if soA&ip aboves us)
        A.pileup of things involved/leading to A
          should cleanup per J or so,
          but provide being/groupology along A
      measures of depth/appropriateness
       A&d (A.c.d)
      thickness/gravitational of cultural boundary-ness
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
    #c Srupto Elvising 
    =head1 Srupto 
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
          throating is meeting several inputs at once:
           A:n->C+ dome-havers (leading to/with/during s for the J)
           Teing (Instruction overloading) from 'above'
           Regurgitants
        Js can be trusted to get their TGW meaning to a point,
         so they can be reset natively
          consuming all input, producing all output,
          for what is supposed to be here.
          inside J (s life) its expression is freer
           
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
         for going into the C and its state through time, etc
          onward, redo, step, pause at trouble...
         matching between many pools
          for same objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          and similarityin many pools, overlapping, notice objects had by each other
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        Geing stuff, departing pile of meaning
        # similar but for unpackedness in general,
        Teing suff, meaning of departing
        # phases of aiming the display and adjusting things
        a pi sewing machine:
        # latter -go wants to be pointed to not coded, initially
        
        =cut
        
        
    #c Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    $drag;
    me.handelvis = &acgt{
        # unless dragging
        C.t.includes('mousedown') and drag = C; return 
        if (C.t.includes('mouseup')) {
            C.t = C.t.replace(/mouseup/,'click');
            if (drag) {
                $d = drag;
                $dif = [];
                # one common C, the rest different?
                each in dc&slope {
                    if (n != Cc&slope[i]) {
                        !dif.length && i > 0 and dif.push(Cc&slope[i-1])
                        dif.push(n)
                    }
                }
                dif.length and c&dragslope = dif;
            }
        }

        # go up C path until bingoed
        $lop = c&slope.slice().reverse();
        # - s&medo - instant, outside (A=4) (eg Jause)
        each in lop {
            # dont fire usual click event when dragging stuff to it
            c&dragslope and break
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            G&yl:123,&{ msg.set('what',ki(ret)) };
            return
        }
        # - s&med: 
        #   e -> 4c&elvrupto -> me.handelvis (here)
        # puts 4c&elvising as the event of the 4c&callback
        #   then inside callback J:Fourier oscs me.Elvising
        #    finding Rs&elvis = Gazer, etc
        4s&elvising = C;
        ~Insideon: ki(c&slope,2)
        G&yl,0,4c&callback;
    };
    
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';
        
        4s&elvised = [];
        G.oclon ||= G.clon;
        G.oclof ||= G.clof;
        if (1 && 'draggable') {
            G.clof();
            G.clof = &{
                window.onmousedown = null;
                window.onmouseup = null;
            };
            G.clon = &{
                window.onmousedown = &{ G&gev };
                window.onmouseup = &{ G&gev };
            };
            G.clon();
        }
        else {
            G.clof();
            G.clon = G.oclon;
            G.clof = G.oclof;
            G.clon();
        }
        
        $l = 4s&elvising;
        !l and return
        me&J,['elvising','-feel',{s:l},'elvising,boost:sc,solvey'];
        
        s&mih = '14';
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel
    
    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if ((e.t.includes('click')||1) && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
    #c e-slope/pointer
    
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 275;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and throw "ancient R"
            #debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.pivot = &ft{
        !f and throw "no from"
        !t and throw "no to"
        $futurup = &r{
            r = ry&up;
            r && ry&future and r = latestR(r)
            return r;
        };
        $from = me.cby(f,0,futurup);
        $to = me.cby(t,0,futurup);
        from[0] != to[0] and debugger
        $la;
        $i = 50;
        while (from[0] == to[0]) {
            i-- < 0 and debugger;
            la = from.shift(); to.shift();
        }
        $a = from.slice();
        la and a.push(la);
        a.push(...to);
        return {f:from,v:la,to:to,a:a};
    };
    me.solveR = &acgtN{
        N = N.slice().reverse();
        $M = [];
        $c = {};
        each in N {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                ns&J and vs&J = Y.1
                c.1 = Y.1;
                # find W, the level Travel is got to
                ns&J && ns&J == ns&J.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                # find the deepest each of ...
                $perc = 'elvis dragelvis'.split(' ');
                each it perc {
                    R.sc[t] && !c[t] and c[t] = v.sc[t] = R.sc[t]
                }
            }
        }
        $p = [];
        each in M {
            # down to inner %elvis
            ns&elvis and p.push(n); continue
            !p.length and continue
            p.unshift(n);
            ns&W and break
        }
        return p
    };
    #c e-cra
    # does %elvis=hook with Te
    # < make Plans to swim in there and deliver it
    me.cra = &acgtD{
        s&solvey = me&solveR,c&slope;
        !s&solvey.length and return
        if (c&dragslope) {
            s&dragsolvey = me&solveR,c&dragslope;
            each in s&solvey {
                !ns&dragelvis and continue
                # once someone up the line wants to do motion
                each id s&dragsolvey {
                    # the dragged from R%elvis
                    !ds&elvis and continue
                    c&dragfrom ||= ds&R;
                }
                each id s&solvey {
                    # and what would have handled a non-drag
                    !ds&elvis and continue
                    c&dragto ||= ds&R;
                    delete ds&elvis;
                }
                # use the travel agent
                ns&elvis = ns&dragelvis;
                break
            }
        }
        # solvey to the first %elvis
        $deep = [];
        each in s&solvey {
            deep.push(n);
            !ns&elvis and continue
            # here's state
            $el = me&stackTe,deep;
            
            T.qua = {};
            $R = ns&R;
            
            # make the adjustment
            me[ns&elvis](A,C,G,T,R);
            
            if (T.non) {
                T.non = 'drag' and delete T.non
                # invlaid approach: drag becomes click
                if (Rs&elvis && Rs&elvis != ns&elvis) {
                    ns&elvis = Rs&elvis;
                    continue
                }
            }
            # save the state
            each kv T.qua {
                el.sc[k] = v;
            }
            
            s&elvis = ns&elvis;
            s&Teing = el;
        }
    };
    #c e-do
    # click up/down anywhere
    me.Gazel = &acgtR{
        C.t == 'says' and return T.qua.sayeth = c&s
        C.t.includes('S+') and return T.qua.play = Rs&play ? 0 : 1
        
        Rs&boost ||= 0;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
    };
    # ESC from textinput
    me.sayeth = &acgts{
        ~Sayeth: ki(A), c&s
        T.qua.sayeth = c&s;
    };
    # via a drag-n-drop of gear to send massages
    # < e become active que-sheets
    #   may arrange/drop themselves into Wormhole...
    #   workings for the Step: wait for such release
    # all a AndContinuance, but let's see it think in R
    me.projvey = &acgtR{
        $A = G&Aye;
        $f = c&dragfrom;
        $t = c&dragto;
        $d = A.ground = G&Cye,['dr','',{elvis:C}];
        4s&eland = d;
        ds&from = f;
        ds&to = t;
        f == t and return ds&same = 1;
        $p = me.pivot(f,t);
        $v = p.v;
        # between places simple?
        $nonballic = p.a.filter(n => !ns&ball);
        if (!nonballic.length) {
            $S = tc&s;
            $s = fc&s;
            i $S/$s
            ds&moved = 1;
            ~move: S.t, '<-', s.t
        }
        elsif (vs&Cell) {
            fs&Tool and ts&play = ts&play ? 0 : 1
            else {
                ~cellsomething
            }
        }
        else {
            # move item
            ds&dunno = 1;
            ~dunno
            T.non = 'drag'
        }
        dc&s = p;
    }
    # 1s&Te/Rs&Te carry centralised namewires from Elvising
    # so set value can be reintroduced
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        # ^ is somewherish. posits and deposits.
        1s&Te and me&Tie,R,'boost'
        
        !Rs&boost and return
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : '↯';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
            z.t += hu;
            i++;
        }
    };
    #c Mboostia
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tin rc&ha {
            if (rc&N.indexOf(n) >= 0) {
                # R included are from Rc&refs/refR
                # < may not be in our h/R pool, showing...
                #   same Rc&s=objects near but not in this process
                #t == 'dub' and continue
                # say where it originated
                $M = me&Mw,n,'Mlimits';
                m $t 89 s:♲ %deco,fs:13,lh:0.3
                # dub = from other R0
                if (t == 'dub' || t == 'dup') {
                    $o = ns&refR[0];
                    $nam = me&nampup,o,n;
                    m $t 892 $s:nam %deco,fs:7,hs:999
                }
                continue;
            }
            else {
                # knows upward that is
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
        }}
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $zs = t+' < '+N.map(t=>t.t).join(',');
            $te = '*'+t;
            m $te 117 $s:zs %deco,fs:13
        }}
    };
    # resume sc
    me.rollbs = &acgtRs{
        $b = Rc&b;
        !b and return
        s = s.split(',');
        each ik s {
            hak(b.sc,k) and R.sc[k] = b.sc[k]
        }
    };
    #c Te receive Te
    # drive wiring from above
    # < check every point was found
    me.JT = &acgts{
        delete 1s&Te;
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $v = p&tv $t;
        !v and return
        1s&Te = v;
    };
    # Rs receive Te
    # $k - Tes&$k given to Rs&$k
    # $d - '1' to oncer/consume that sc
    # can resume pointering across Rs that don't Tie
    # < intro much more: throat's ability to pause/step etc.
    # < checks all pointers were found,
    # < find hidden lands
    me.Tie = &acgtRkd{
        if (!Rs&Te) {
            # default unattached error-avoidance thing
            Rs&Te = {sc:{}};
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            $Tet = v&tv $t;
            if (0 && !Tet && v.t == t) {
                # pointer is thinning itself, stretch while t constant
                $vv = r.y.up;
                vv = vv && vvs&Te;
                if (vv) {
                    v = vv;
                    Tet = v&tv $t;
                    Tet and ~tstretch: r.y.up.t, t
                }
            }
            Tet and Rs&Te = Tet
        }
        $v = Rs&Te;
        !v || !v.c and return
        !k and return
        # once located, muddle with opportunity
        
        #vs&cb && vs&cb,R,t
        if (hak(v.sc,k)) {
            $V = v.sc[k];
            k == 'boost' and V *= 1
            R.sc[k] = V;
        }
        # oncer
        d == '1' and delete v.sc[k]
    };
    # make Te for N pointer/solvey path
    # < a pile of travel, io T points to look at
    me.stackTe = &acgtN{
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in N {
            if (typeof n == 'object') {
                # has a better .t
                ns&Te && ns&Te.c and n = ns&Te
            }
            # < io spacerising
            i $el/#$n
            el = ays&n[0];
        }
        return el
    };
    # set Te
    #  for setting boost that can then wander off as per
    me.introqua = &acgtRcm{
        $N;
        if (R.constructor == Array) {
            N = R
        }
        else {
            me&Tie,R;
            $h = Rs&Te;
            # if none exists
            h && h.c && !m and return
            N = me.cby(R);
            N.shift().t != 'I' and throw "I!=0"
        }
        $el = me&stackTe,N;
        each kv c {
            el.sc[k] = v
        }
    };
    #c structuR
    me.namup = &acgts{
        !s and return
        $nam = [s.t];
        while (s = s.y.up) {
            nam.push(s.t);
        }
        return nam.reverse();
    };
    # show path between two R
    me.nampup = &acgton{
        $namo = me&namup,o;
        $name = me&namup,n;
        $pup = [];
        each is namo {
            if (!pup.length) {
                s == name[i] and continue
                if (name[i] != null) {
                    # up the n
                    pup.push(name.slice(i).map(la=>'^').join(''))
                }
            }
            pup.push(s)
        }
        if (!pup.length) {
            $ups = name.length - namo.length;
            while (ups--) { pup.push('^') }
            pup = [pup.join('')];
        }
        $nam = pup.join('/');
        return nam
    };
    # pick an R by name, from ...
    #   io wants to know R, loadup qualities...
    me.bit = &acgtRtf{
        typeof t != 'object' and t = [t]
        !f and f = R
        f == 'h' and f = Rc&N[0]
        each in t {
            #$fz = fc&X && fc&X.x[n] && fc&X.x[n].z;
            $fz = fs&z && fs&z.filter(t => t.t == n);
            !fz and throw "problem"
            fz.length < 1 and throw "notfound"
            fz.length > 1 and throw "many"
            f = fz[0];
        }
        return f
    };
    # path finder
    me.cby = &sfzdo{
        !s and return !f && d
        z == 'up' and z = null
        z ||= &s{ return s.y.up };
        d ||= [];
        d.unshift(s) > 50 and throw "manycby"
        $r = f && f(s,o);
        r and return d
        return me.cby(z(s),f,z,d,s)
    };
    me.cbu = &sfz{
        $cb = f;
        typeof f == 'string' and cb = &R{ return R.sc[f] }
        typeof f == 'object' and cb = &R{ return R == f }
        $l = me.cby(s,cb,z||'up');
        return l && l[0]
    };
    me.yfuture = &acgtrRy{
        $i = 300;
        while (ry&future) {
            r = ry&future;
            i-- < 0 and throw "manyfuture"
        }
        if (R) {
            if (0 > Rc&N.indexOf(r)) {
                y and y
                else {
                    throw "yfutured "+R.t+" not in RcN"
                }
            }
        }
        return r
    }
    #c Rdata
    # input s to Rc&s, updating %balls
    # an io that makes changes to both A & C at once
    me.input = &acgtRs{
        if (!Rs&ball) {
            # we are pathing to another group of %balls
            # find R.t instead of Rc&s.t:
            typeof s != 'string' and throw "input path out of %ball !string"
            # there might be multiple of these, of %hypball
            #   for each %push to hang up its state/ambition on
            return Rs&z.filter(n => ns&ball && n.t == s)[0]
        }
        $S = Rc&s;
        # look for it
        o $S/#$s
        ya && typeof s != 'object' and s = ya
        if (ya && ya != s) {
            ~Bepicky: Ry&up.t, R.t, s.t
            $si = Ss&z.indexOf(s);
            i $S/-$ya
            ya = null
        }
        if (!ya) {
            if (typeof s != 'object') {
                i $S/#$s
                s = ya
            }
            else {
                i $S/$s
            }
            if (si != null) {
                # keep order
                $is = Ss&z.indexOf(s);
                is < 0 and throw "noin"
                if (is != si) {
                    Ss&z.splice(is,1);
                    Ss&z.splice(si,0,s);
                }
            }
        }
        me&Rsync,R;
        each in Rs&z {
            nc&s == s and return n
        }
        debugger;
        # should have found that input
    };
    # keep a %ball for each Rc&ss&z
    me.Rsync = &acgtRV{
        $S = Rc&s;
        # o $S/*
        $ba = (Ss&z||[]).slice();
        $rm = [];
        each in Rs&z {
            !ns&ball and continue
            $bi = ba.indexOf(nc&s);
            bi >= 0 and ba.splice(bi,1)
            else { rm.push(n) }
        }
        each in rm {
            Rs&z.splice(Rs&z.indexOf(n),1);
            n.c.not = 1;
            V &&
            ~Removed: R.t, n.t
        }
        each in ba {
            V &&
            ~Included: R.t, n.t
            $t = me&Ret,R,{t:n.t,s:n,ball:1};
            zN(t);
        }
    };
    #c Rcopy
    # returns a 2%ball cloned from s (not a %ball)
    me.Copy = &acgtRsc{
        $h = s;
        s = hc&s;
        
        c ||= {};
        # Rings up to a point
        typeof c == 'number' and c = {ov:c};
        while (c.ov > 1) { c.ov *= 0.1 }
        
        ex(c,{task:'ravel',ball:1,noDisplay:1});
        c.Copy = 1;
        c.Ropy = h;
        
        $k = 'Copy';
        Rs&act and k += '-> '+Rs&act
        return me&Reis,R,k,s,c
    };
    me.Copyingness = &acgtR{ return [
        # clones %balls for me&Copy
        ['ball+Copy','11',&acgtRs{
            Rs&Copy = s;
            Rc&s = G&Cye,s;
            # update self in above z
            $p = Ry&up;
            if (p && ps&Copy) {
                $P = pc&s;
                # replace cloned ss&z in parent
                if (Ps&z) {
                    $pi = Ps&z.indexOf(s);
                    pi < 0 and throw "pi<0"
                    Ps&z[pi] = Rc&s;
                }
                # %Ropy = %ball cloned from
                $pR = ps&Ropy;
                each in ps&z {
                    !ns&ball and continue
                    nc&s != Rs&Copy and continue
                    Rs&Ropy = n
                }
            }
            s = Rc&s;
            if (ss&z) {
                ss&z = ss&z.slice()
                me&Rsync,R;
                each ir Rs&z {
                    rs&ball and rs&Copy = 1;
                }
            }
        },'ift,D'],

    ] };
    #c push - %ball's establishment of an outgoing projection
    # < working via elvising hung near
    # < better pointering & grabbing styles
    #    remember what things looked like,
    #    be generating grammars/I off the screen
    # in a %push on this %ball, rolling through time,
    # < disconnecting once the cause (me&push call) stops
    # 
    # returns the %pull (which will Ring soonish) unless:
    #  %pull%auto:
    #    %their = me&input,%there,%herec&s
    #    returns %their = %ball holding %herec&s under %there
    # 
    me.push = &acgtRpqtc{
        # the named %push + its mode (%auto if t,!c args)
        c ||= {auto:1};
        typeof c == 'string' and c = G&peel,c
        t and ex(c,typeof t == 'string' ? {t:t} : t)
        c.push ||= 1;
        !hak(c,'t') and c.t = ki(p,2)+' = '+ki(q,2)
        $l = me&Ret,R,c;
            zN(l);
        
        # and its items, from here
        # path to receiver %ball (inflated)
        #  < elvis pointing such that name changes/bits blow away when pushed
        $t = ls&there = me&pushpath,R,p;
        # the thing itself, where it is (also inflated)
        $h = ls&here = isC(q) ? q : me&pushpath,R,q;
        !t || !h and throw "falliball"
        
        # < pipelining of here as it goes there via ...
        #   so it can wander through a network started here
        
        # begin othering:
        if (ls&hard) {
            ac(t,'pushering',l)
        }
        elsif (ls&auto) {
            $thing = hc&s;
            ls&their = me&input,ls&there,thing;
            return ls&their
        }
        else {
            # no-push link (elviser knows who's nearly elvised them)
            ac(t,'pushish',l)
        }
        # %ball pushed to %there, practically
        # < %othering to %there,
        #   saving %balls of here/there for Cdar diff
        #   the %there%balls noticing our %push vanish
        return l
    };
    # %ball input limb, extra pathy
    # < to hang push intentions on %ball
    #   or on speculative balls for slow ...
    me.pushpath = &acgtRp{
        $r = R;
        each is p {
            $nr = s == '/' ?
                me.cby(r,&r{ return rs&gee })[0]
                :
                me&input,r,s
            !nr and throw "No "+s+" after "+r.t+" along "+ki(p)
            r = nr;
        }
        return r;
    };
    me.Pushingness = &acgtR{ return [
        # push
        ['push','3',&acgtRs{
            me&rollbs,R,'delivered,moves';
            s&bo = '1px dotted green';
            s&hue = 70;
            s&br = 1;
            s&fs = 8;
            Rs&arrow =
            n $R.t 13 s:⇒ %fs:14
            # certain/lowlevel types of %push
            Rs&auto || Rs&hard and Rs&push = 9
        },'ift,D'],
        ['ball+pushed','55',&acgtRs{
            # since ball 53 yfuture'd %pulled...
            $p = Ry&up;
            $know = ps&pushed || [];
            each il Rs&pushed {
                know.indexOf(l) >= 0 and continue
                # < many?
                ls&their = R;
            }
        },'ift,D'],
        # get %balls encoding
        ['push','59',&acgtRs{
            Rs&push != 1 and return
            # find comparables, make plans to get %balls encoding
            # %deliverer hard pushed %delivered %ball
            $d = Rs&deliverer;
            Rs&their = d ? ds&delivered : Rs&their;
            
            Rs&act = Rs&does || 0;
            
            # always Lines h/t to sleep the act, later
            # string based representation of everything going into it
            $soc = [Rs&their, Rs&here];
            each ic soc {
                c && !hak(c.sc,'Lines') and cs&Lines = 1
            }
            
            # make subgroupings of Lines
            # < Te this in here?
            $t = Rs&their;
            if (t && t.t == 'Co') {
                me&ioty,t,'%ball%ball'
                    .map(out => outs&Lines = 1)
            }
        },'ift,D'],
        #c push-7 have encoded %balls wormhole through %moves
        #   received by this %push early enough to action
        ['push+act','7',&acgtRs{
            $M = Rs&moves ||= [];
            each in M {
                n.t == 'push' and Rs&lastpush = n
            }
            # make diff/post acceptings in M
            $t = Rs&their;
            $h = Rs&here;
            # last %move that was a push
            $lm = Rs&lastpush;
            # this %push when %move was started
            $doing = lm && lmc&pusher;
            # this %push when %move was done
            $done = lm && lmc&pushed;
            
            # both sides should Lines
            me&sch_didLines,R,h;
            !t || me&sch_didLines,R,t;
            
            if (me&Mw,R,'err' .length) {
                n errors  s:⊗ %fs:18
                return
            }
            
            if (Rs&act) {
                # with transformation in the middle
                if (doing) {
                    $indiff = me&diffya,R,'input',h,doings&here;
                    if (indiff && indiffs&exactly) {
                        Rs&made = doings&made
                    }
                }
                if (!Rs&made) {
                    !me[Rs&act] and throw "no me.%act "+Rs&act
                    Rs&made = me[Rs&act](A,C,G,T,R,h,t);
                }
                if (doing) {
                    $diff = me&diffya,R,"made",Rs&made,doings&made;
                }
            }
            else {
                $diff = me&diffya,R,'diff',h,t
            }
            
            if (t && done) {
                # offer rebase if t changes without our push
                $tdiff = me&diffya,R,'theirs',t,dones&their;
                # < branch h <-> ms&h and patch onto that
                if (!Rs&made && !tdiffs&exactly) {
                    # < explore what'll happen, run in reverse
                    #m pull $from:t,to:h %pull,pending
                    n pending  s:pull? %hs:588
                }
            }
            
            if (!t) {
                done &&
                    n va  s:vanishing!
                n notheir  s:⧁ %fs:22
            }
            
            # checkout on init (%their to %here)
            if (1s&runs == 1 && !M.length
                && Rs&mayco && me&sch_ballonlyt,h ) {
                m checkout $from:t,to:h %pull
            }
            
            # transmit here or what we made of it
            Rs&made and h = Rs&made
            
            if (Rs&shove || Rs&boost > 1) {
                !Rs&shove and Rs&Te.sc.boost = 1;
                Rs&shove &&
                    n shovedby  $s:Rs&shove %hs:388,deco
                # the usual
                $c =
                m push $from:h,to:t,pusher:R
            }
        },'ift,D'],
        #c push-made
        # some complicated thing breaking out steps
        ['push+made','8',&acgtRs{
            # m is %balls with %Copy = origin, %Ropy 
            $m = Rs&made;
            n act  $s:Rs&act %deco
            $dt = Rs&diffya;
            $td = dt && dt.theirs;
            if (!td) {
                n prog  s:...
                return
            }
            # less about input/their as made/steps
            [td,dt.input].map(d => ds&sublated = 1);
            
            # their results
            $N = me&ioty,Rs&their,'%ball%ball';
            if (!N.length) {
                n prog s:..?
                return
            }
            # roll run per result[0]
            me&rollbs,R,'run';
            $first = N[0] && N[0].c.s;
            $r = Rs&run;
            r && rs&first != first and delete Rs&run
            if (!Rs&run) {
                $runtime = (r && rs&runtime || 0) + 1;
                $k = 'run_'+runtime;
                r = Rs&run = G&Cye,[k,''];
                rs&first = first;
            }
            # 
            # Co/Hap/ Hap v1...
            # a bug chaser
            # make deals across the border so
            
            $Z = me&ioty,Rs&here,'%ball';
            
            $tot = '('+N.length+'/'+Z.length+')';
            n tot  $s:tot %hs:357
            $astep = &i{
                $k = 'step_'+i;
                n $k  $step:i,got:N[i],exp:Z[i],R
            };
            each in N {
                astep(i)
            }
            while (Z[++i]) {
                astep(i)
            }
            Rs&steps_exp = Z;
            Rs&steps_got = N;
            
            n progress  R %decideprogress
        },'ift,D'],
        # ⧐ from the top
        # ∿ big change
        # ~ small change
        # ☯
        # 
        # should be a %push%run thing, or even an A.4 (or is it A.9?)
        #  persistent/rollbs like %push%made
        #  per othering, which starts a test run (drops J)
        ['decideprogress','5',&acgtRs{
            $p = Ry&up;
            
            $steps = me&ioty,p,'%step';
            Rs&ok = 1;
            Rs&more = 0;
            each in steps {
                !ns&got and Rs&more = 1; break
                # results got must be ok
                !ns&ok and Rs&ok = 0
            }
            
            if (Rs&boost > 0) {
                Rs&Te.sc.boost = 0;
                Rs&wantstep = 1;
            }
            
            !Rs&ok &&
                n notok  s:! %fs:17,hs:856
            Rs&ok &&
                n ok  s:ok
            Rs&more &&
                n more  s:...
            
            Rs&ok && Rs&more and Rs&wantstep = 1
            Rs&more &&
                n more  s:≻ %fs:15
            !Rs&more &&
                n moreanyway  s:⊁ %fs:15
            
            Rs&wantstep and ps&stepforward = 1
        },'ift,D'],
        ['push+made','82',&acgtRs{
            #n thing  $s:R.sc,R %sun
            
            if (Rs&stepforward) {
                # makes iteration by unblocking the instruction
                $t = Rs&their;
                $N = me&ioty,t,'%ball';
                # this is W=Co's children, a shared space,
                # < look for our %made's business
                # the Winy&current points to Wins&z[-1] == Wout
                each in N {
                    $s = nc&s;
                    delete sy&current;
                }
            }
        },'ift,D'],
        #c step transfer  
        ['step','4',&acgtRs{
            Rs&rowish = 1;
            
            n t 11 s:S: %hs:634
            n i 112 $s:Rs&step %hs:999
            
            # modes of perception seeing acts
            $l = Ry&up;
            $M = ls&moves;
            !ls&push and throw "step up !push"
            !M and throw "up push !moves"
            
            # stashed steperately
            
            
            $g = Rs&got;
            $x = Rs&exp;
            $dc = {};
            if (!g) {
                # not yet
                n not  s:... %fs:18
                return
            }
            elsif (!x) {
                dc.unexpected = 1
            }
            else {
                $X = xc&s;
                if (Xs&H) {
                    # Lines/decode should do this:
                    xs&H = xs&dige = Xs&H;
                    # which may avoid decoding it
                    # until contents are needed for a diff:
                    dc.expGhost = &{
                        return me&GhostOut,R,Xs&H;
                    }
                }
            }
            
            $r = ls&run;
            # correspond %run%step
            i $r/#R.t:s
            $s = ya;
            ss&step = Rs&step;
            $ac = ss&accepted;
            
            $d = me&diffya,R,R.t,g,x,dc;
            
            ds&new &&
                n not 12 s:⧀ %fs:18
            
            if (ds&exactly) {
                Rs&ok = 1;
                ss&accepted = d
            }
            elsif (ac) {
                # results are allowed to wander off once accepted
                # such info is interesting
                # < accept/test for history-warp
                ds&sublated = 1;
                n accepted_before 15 s:=)
                Rs&ok = 3
            }
            
            if (Rs&ok) {
                n ok 14 s:ok %hs:395
                return
            }
            
            if (Rs&boost > 0) {
                !Rs&shove and Rs&Te.sc.boost = 0;
                # copy h to t
                n push  s:accept
                # %got become the $step-th %ball under %here
                # store object
                !gs&dige || !gs&string and throw "weird"
                me&GhostIn,R,gs&dige,gs&string;
                # make pointer (io spacers cv||=0.1)
                $po = G&Cye,[R.t,1,{},{H:gs&dige}];
                me&input,ls&here,po;
                
                $dt = ds&Te;
                # about to become '='
                dt && dts&boost and dts&boost = 0
                #m accept  $f:g,$t:x
            }
            elsif (Rs&boost > 0) {
                n push 12 s:accept?
            }
            
        },'ift,D'],

        # random look
        ['push','8',&acgtRs{
            !Rs&boost || Rs&boost < 1 and return
            
            s&fs = 11;
            s&dis = 1;
            #n thing  $s:R.sc,R %sun
        },'ift,D'],
        #c push-moves
        # 7%push sends its future self %moves to do
        #   objects (esp %from and %pusher) from that time
        # now early enough for %othering
        ['push+moves','4',&acgtRs{
            $M = Rs&moves;
            each in M {
                ns&done and continue
                # with items from late last time
                $f = nc&from;
                $t = nc&to;
                nc&push = R;
                # f is likely to be the last %here, unless reversing
                # t (usu %their) may not be here yet:
                #  R%othering %pull%there==R will z it
                t ||= Rs&there;
                $tp = t && ty&up;
                if (tp && tps&pushering) {
                    tp = me&yfuture,tp;
                    # parent mediates %push for some reason
                    #  eg to %kvstore %here%string
                    # not %their directly
                    ~pushering: t.t, R.t
                    ac(tp,'pushering',R,'ball',f)
                }
                else {
                    # ensures (2-arg) it be aRound
                    t = me&yfuture,t,R;
                    ~othering: t.t, R.t
                    ts&ball == '6' and throw "too late to %ball"
                    ac(t,'othering',R,'ball',f)
                    # usu othering %pull%here,
                    # < the %moves making subcommits:
                    #   their own reselections of %ball
                }
                
                ns&sym = n.t == 'checkout' ? '↽' :
                    ns&pull ? (ns&pending ? '◅' : '◄')
                    : (ns&pending ? '▻' : '►');
                ns&done = 6;
                #n thereup  $s:ty&up,R %sun
                # t%ball%othering should get us
            }
            
        },'ift,D'],
        
        # moves talked about 
        ['push+moves','7',&acgtRs{
            $M = Rs&moves;
            M.length &&
                n moves $s:M,R %hadmoves
        },'ift,D'],
        # squishy shrinking ooze, preserving interesting events
        # more info at latest
        ['hadmoves','3',&acgtRs{
            $p = Ry&up;
            $forget = [];
            each in s {
                # done this round
                if (ns&done == 6) {
                    ns&done = 9;
                    $r = nc&pusher;
                    # branch at %push%their with %move
                    r and nc&pushed = latestR(r)
                }
                # id by name then symbol
                $sym = n.t;
                ns&sym and sym = ns&sym
                n $n.t  $s:sym %fs:12,hs:594
                
                # condenses
                if (s.length > 5) {
                    $ne = s [i+1];
                    ne && n.t == ne.t and forget.push(i)
                }
            }
            
            forget.map(i => s.splice(i,1));
        },'ift,D'],
        

    ] };
    
    #c pushy
    # operate on Ghost/kvstore remotely
    # < s&H object pointers wander borders
    me.GhostOut = &acgtRk{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $s = localStorage[k];
        !s and throw "noH: "+k
        # a %ball with %Lines=0
        return Ghosts&arrange_decoder(k,s);
    };
    # write-once storage
    me.GhostIn = &acgtRks{
        $Ghost = Rs&sGhost ||= me&sGhost,R;
        $bs = localStorage[k];
        bs && bs != s and throw "hash collision?"
        localStorage[k] = s;
    };
    # the source of your information
    # o ^^%push %here %pushed'lookup' %there
    me.sGhost = &acgtR{
        $Ha = me.cby(R,&b{ return
            bs&pushed && bs&pushed[0].t == 'lookup'
        })[0];
        if (Ha) {
            $pl = Hac&pushed[0];
            $Ghost = pls&there;
        }
        else {
            #  %pushed falls off if throw
            $Ghost = me&pushpath,R,['/','G'];
        }
        return Ghost
    };
    # make instructions for Co
    me.TeCo = &acgtRhtc{
        $r = me&Copy,R,h,26;
        
        $s = rc&s;
        # remove expectations
        rs&expect = ss&z;
        delete ss&z;
        $c = rc&s = G&Cye,['Co',''];
        i $c/$s
        # pointer to s?
        
        # any s&H still there replaced with contents
        
        delete rs&ov;
        rs&Lines = 1;
        # onward 3%ball Rsyncs, anything under r may ~
        me&Ring,r;
        each in rs&z {
            !ns&ball and continue
            ns&clobberypushingz = 1
        }
        return r
    };
    # io should be able to: $t/%ball/%ball or so
    #  and Bab this while loop with var sets
    me.ioty = &acgtty{
        $leg = [];
        typeof y == 'string' and leg = y.split('%');
        leg[0] == '' and leg.shift();
        # default $t/*
        !leg.length and leg.push('');
        !ts&z and return []
        $bit = leg.shift();
        $z = ts&z.filter(l => !bit || l.sc[bit] != null);
        if (leg.length) {
            leg = leg.join('%');
            $Z = [];
            each il z {
                Z.push( ... me&ioty,l,leg );
            }
            z = Z;
        }
        return z
    };
    #c diff balls with strings
    # setty http://xahlee.info/comp/unicode_math_operators.html
    
    # returned awake enough to help 7%push
    me.diffya = &acgtRkhtc{
        c ||= {};
        ex(c,{t:k,got:h,exp:t,diff:1});
        $dt = Rs&diffya ||= {};
        $d = dt[k] = me&Ret,R,c;
        # can be seen to be ... already
        t && h && ts&dige == hs&dige and ds&exactly = 1
        h && !t and ds&new = 1
        return d
    };
    
    # a %diff
    me.Diffingness = &acgt{ return [
        # < map diff back out to %balls, if clicked
        # < might turn the diff into another artifact of time
        #   that needs rebasing when what you're working on changes
        # < making several commits of a bunch of change
        #   by the initial diff selecting %self%balls
        #   to go %othering into a %staging%balls
        #   %Lines that and diff etc against %other again
        
        ['diff','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            s&ma = 0.2;
            s&pa = 0.3;
            s&lh = 1;
            s&bo = '1px dotted yellow';
            #s&hue = '84deg';
            # ^ applies to diffproximate but not the patch?
            
            $g = Rs&got;
            me&sch_didLines,R,g;
            $x = Rs&exp;
            x && !Rs&expGhost and me&sch_didLines,R,x;
            $ob =
            n $R.t 13 s:~ %fs:29,lh:0.1
            
            if (x) {
                if (gs&dige == xs&dige) {
                    # apparently the same, avoid load/decode
                    obc&s = '=';
                    ob.t += ' equal';
                }
                elsif (Rs&expGhost) {
                    # decode contents of expectation
                    x = Rs&exp = Rs&expGhost();
                }
            }
            if (!x) {
                !Rs&unexpected and throw "Not expected to be unexpected"
                # < most after the difference from previous step
                obc&s = 'new!'
            }
            if (me&Mw,R,'err' .length) {
                n errors  s:⊗ %fs:18
                obc&s = '!'
            }
            if (obc&s.match(/[!=]$/)) {
                if (Rs&boost > 0) {
                    n entirety  $s:gs&string %max-height:7,over,dis
                }
                return
            }
            
            # switch chunk: word/line

            me&rollbs,R,'Digs,Diff,CompN,Comp';
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;

            # the job
            $c = {chunk:'word',fold:1};
            $N = Rs&Diff ||= diff(xs&string,gs&string,c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }

            me&diffproximate,R;
            
            if (Rs&boost > 0) {
                $l = Ry&up;
                ls&rowish = 1;
                $p =
                n patch   %max-height:7,over,dis
                ps&z = [...Rs&Comp];
                
                if (!ps&z.length) {
                    obc&s != '=' and throw "empty patch !="
                }
            }
        },'ift,D'],
        ['diff','87',&acgtRs{
            Rs&sublated and s&fs = 5
        },'ift,D'],
    ] };
    
    
    #c Ring mind, doming
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
        return r
    };
    # empties grounda&z into M or more R
    me.endome = &acgtR{
        $g = A.ground;
        !g and return
        !gs&z and return
        $N = gs&z;
        !N.length and return
        gs&z = [];
        $M = null;
        each in N {
            if (nc&R) {
                # spawn R?
                $parent = R;
                $s = nc&R;
                if (s && Rc&N.indexOf(s) >= 0) {
                    parent = s;
                    s = null;
                }
                delete nc&R;
                nc&s and s = nc&s; delete nc&s
                ex(n.sc,n.c);
                $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
                parent != R and zN(r)
            }
            else {
                # otherwise this mindthing grows M
                M ||= me&Mw,R,t.t;
                M.push(n)
            }
        }
    };
    
    # outdated syntacticon toward Reis
    # not looking like Instructions
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    

    
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        $task = Rs&task || R.t;
        !me[task] and debugger;
        $N = me[task](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            
            # compile instructions
            if (ns&ift == '1') {
                $op = n.t.split('+');
                if (op.length > 1) {
                    # must have all these sc
                    ns&ifs = op
                }
                else {
                    ns&if = 's'+n.t
                }
            }
            elsif (ns&ift) {
                ns&if = 's'+ns&ift;
                ns&ifeq = n.t;
            }
            
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    #c Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        #c walk the tape, trying to do more
        $busy = 1;
        $sheer = 45000;
        $onlyt;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                onlyt = null;
                $lowci = '';
                $ati;
                each in hc&N {
                    if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                        lowci = ns&ci;
                        ati = i;
                    }
                }
                #lowci != '' and hs&iN = ati-1
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            R.c.not and continue
            #onlyt && t != onlyt and continue
            
            hs&ov && hs&ov < ty&cv and continue
            
            # deciding
            $T = {};
            if (ts&ifs) {
                each ik ts&ifs {
                    R.sc[k] == null and T.not='ifs'
                }
            }
            if (ts&if && !T.not) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='ifh'
                elsif (ts&if[0] == 's') {
                    $v = R.sc[ts&if.substr(1)];
                    !v and T.not='if'
                    ts&ifeq && v != ts&ifeq and T.not='ifeq'
                }
                else {
                    throw "if "+ts&if
                }
            }
            
            if (!T.not) {
                $packdown = [];
                if (ts&D) {
                    # doming for n
                    $g = A.ground;
                    gs&nonz = gs&z;
                    gs&z = [];
                    packdown.push(&{
                        # empties grounda&z into M or more R
                        me&endome,R;
                        $g = A.ground;
                        gs&z = gs&nonz;
                        delete gs&nonz;
                    });
                }

                $cb = tc&s;
                #!hak(R.c,'s') and debugger;
                
                cb(A,Rs&C||C,G,T,R,Rc&s);
                
                packdown.map(pd=>pd())

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            if (T.wide) {
                Rs&widenings ||= 0;
                Rs&widenings++ > 30 and debugger;
                delete T.wide;
                busy = 1;
                continue;
            }
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            onlyt = t;
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c autoravel
    # waltzing stringpasses, 
    
    # pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    $ve;
    me.Ja.Pass = &acgt{
        me&Gomp;
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Ha  $Travel:el %ravel:gee
        #n Jazz  $Travel:el %ravel:cell
        
        $ve = 4s&eland ||= G&Cye,['Vectroland',''];
        n eland  $s:ve %Cray
    };
    me.Ja.Co = &acgt{
        me&Gomp;
        !1s&Te and return
        o 1s&Te/*
        $A = G&Aye,'Community';
        # too late for this J to include it
        G&yl:22,&{ me&doN,ays&s };
    };
    # do only undone
    me.doN = &acgtN{
        each is N {
            sy&current and continue
            $q = {q:'W'};
            if (!ss&z) {
                # fresh run, clear memory
                $v = 4s&Jtv;
                delete v[s.t];
            }
            try {
                q.part = 'Jin';
                me&J,s.t,q;
                q.part = 'Jreturned';
            }
            catch (er) {
                $msg = ki(q.C,2)+"   !"+q.part+"! "+er;
                ~JCo: msg
                ss&err = msg
            }
            C = q.C;
            ac(s,'z',C);
            sy&current = C;
        }
    };
    # now Ray and his armies will go do:
    me.Ja.happenings = &acgt{
        me&Gomp;
        $bit = 1s&bithold ||= G&Cye,['Bit',''];
        $b =
        n abit  s:lau %fopia
        i $b/$bit
        bits&bobs ||= 0
        bits&bobs --;
        bits&bobs == -2 and throw "Unfielded quark"
        
        n Plethoria  $s:<<'' %of:s
            # glampiture
            n now  s:noow %fs:54
        
        # < get rid of ^'s /^\t\t\t/
    };
    #c cellvey think about their state,
    # become straight, become curvy
    # have things wanting to be streamed uphill
    # showing interfaces where things can come across
    
    me.ravel = &acgtR{ return [
        ... me&Displayingness ,
        ['She','1',&acgtRs{
            $uh = Ry&up && Ry&up.c.N[0];
            uhs&task == Rs&task and return;
            # start by checking out thy name
            isC(s) && ss&ravel and R.sc[ss&ravel] = 1
            else {
                throw "lostR"
            }
            Rc&dupl = 3;
        },'if:h'],
        
        # the living - a situation
        # slow rolling wakeup
        # openness is travelled in
        # up into cell
        ['gee','3',&acgtRs{
            Rs&rowish = 1;
            # A.4 to/run/from, shared
            # is the local stage, our gear projected on
            1s&runs == 1 and me&introqua,[A.1.t,'Ha','ravel','T',A.1.t],{boost:-1}
            n T  $s:sc&Travel,R %ball
            # create and harvest arrangements of gear
            #  %Teing extrapolates runningness
            n W  $lookup:s.t,R %ballse
            # to stable
            n G  $kvstore:localStorage,R %ballse
        },'ift,D'],
        
        # persistent ish makeupforus C
        ['ballse','2',&acgtRs{
            $ba = 1s&ballse ||= {};
            Rc&s ||= Rc&b && Rc&b.c.s;
            Rc&s ||= ba[R.t];
            Rc&s ||= G&Cye,[R.t,''];
            ba[R.t] = Rc&s;
            Rs&ball = 1;
            delete Rs&ballse;
        },'ift,D'],
        # knows its %pushed to
        ['ball','2',&acgtRs{
            # see ball-othering
            me&rollbs,R,'pushed,pushed_ball';
        },'ift,D'],
        # a pattern match and squish for long skinny trees
        ['ball','6',&acgtRs{
            Rs&boost and return
            $pr = Ry&up;
            !pr and return;
            prs&z.filter(t => ts&ball).length != 1 and return
            delete Rs&rowish;
        },'ift'],
        # lookup %ball/*.t in G
        # assorted W you asked for, bay of incoming remotes
        #   elvising/G&t-ish interface to mysterious places
        ['lookup','2',&acgtRs{
            $g = Ry&up.sc.z.filter(g=>g.t == 'G')[0];
            !gs&ball and return T.wide = 1;
            # W holds many, to sync to G
            # with %lookup: highest/starting point
            $t = Rs&lookup;
            if (t != '1') {
                # < be othering ourselves, lending content
                #   to get instant %ball for things
                #   and so disconnections keep objects
                #     for packdown/gc
                #   specifying types of ephemerality:
                #     runspace kept tidier than piles
                $n = me&push,R,[],[t],'purpose';
                # ensure it's first in z
                $zi = ss&z.indexOf(nc&s);
                zi > 0 and ss&z.unshift(ss&z.splice(zi,1)[0])
            }
            
            # ready all s/* as R/*%balls
            me&Rsync,R;
            
            each in Rs&z {
                !ns&ball and continue
                # posit they %push(ish) to G
                $l = me&push,n,['/','G'],[],'lookup','mayco';
            }
        },'ift,D'],
        ['ball','28',&acgtRs{
            $b = Rc&b;
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        ['push','28',&acgtRs{
            $b = Rc&b;
            !b &&
            n newb o9 s:b %fs:7,hs:297
            if (b && bc&s != Rc&s) {
                n news o9 s:s %fs:7,hs:297
            }
        },'ift,D'],
        ... me&Copyingness ,
        ... me&Pushingness ,
        ... me&Linesingness ,
        ... me&Diffingness ,
        #c kvstore
        # accept %pushish as a name lookup first
        #  names %decode'd and pushed here
        #   they have a %delivered %ball stuck in the past
        ['kvstore','2',&acgtRs{
            # t source
            # weak %push
            # %pushin helps project lives from s
            #   as decode
            # looks at %balls pushing to it,
            #  look for them here
            #   pushing there 
            #  accept their content if full enough
            !Rs&pushish and return T.wide = 1;
            # tell %push to do
            # < search children for %othering
            # < upgrade %othering sense to
            #   any of the objects
            Rs&pushering ||= [];
            me&rollbs,R,'rememb';
            
            Rs&get_key_for = &t{
                return ts&H || t.t
            };
            Rs&arrange_decoder = &ksl{
                # arrange decoder
                $re = Rs&rememb ||= {};
                $kd = k+dig(s);
                $bc = {task:'ravel',Lines:1,intoa:'ball',noDisplay:1};
                bc.remova = &{ delete re[kd] };
                # keep the %balls with the decoding Lines stuff
                $S = re[kd] ||= me&Reis,R,k,s,bc;
                if (l) {
                    # %pull%here=S, see below 
                    $L = me&push,R,[],S,'decode','hard';
                    # allow %their from ^ to look like l's %thing
                    ls&deliverer = L;
                }
                return S
            };
            
            each il Rs&pushish {
                $t = ls&here;
                # a remote %push, for some id
                $k = Rs&get_key_for(t);
                $s = localStorage[k];
                !s and ls&new = 1; continue
                
                Rs&arrange_decoder(k,s,l);
            }
        },'ift,D'],
        ['kvstore','4',&acgtRs{
            !Rs&pushering and return
            $i = 0;
            while (Rs&pushering[i]) {
                l = Rs&pushering[i];
                $t = (Rs&pushering_ball||[])[i] || ls&here;
                if (ls&hard) {
                    $S = tc&s;
                    # %here%ball must be the same
                    $still = ls&delivered && t == ls&delivered;
                    if (!still) {
                        i Rc&s/-#S.t
                        n ush  s:ush
                        ac(R,'pushing_z',l,'ball',t);
                        # becomes %push%their
                        ls&delivered = t;
                    }
                }
                else {
                    # must have a Lines done
                    !ts&ball || !ts&LinesN and throw "not %here=%ball%LinesN"
                    $good = ts&string && ts&string.length > 7
                    !good and throw "string dodgy"
                    # redecode, sets/does another ls&deliverer since lookup
                    #  checks it works,
                    #  %move%pushed%their gets what was pushed
                    $k = Rs&get_key_for(t);
                    Rs&arrange_decoder(k,ts&string,l);
                    localStorage[k] = ts&string;
                    # < check it's what %push knew about when it pushed
                    # < may contain several things to which you must link
                }
                i++;
            }
        },'ift,D'],
        
        
        #c haveth
        # interesting comment rubble from drained %pull:
        
        # t individuals in any place
        #     < new/gone similar -> moved
        # %haveth=to %ball vaguely
        # %other=from %ball specifica
            # once turned up, may have an in-t and an out-t
        # concat modulat 1-2?
            # < overall, has it pushed? 
            # < state change here/there click show in %ball
            #     that %ball's %pushed_ball will be historic,
            #         have sc.z %fix and etc
                # should show up as an item to push
                #   push/display change fairly easily
                # conversely, n.t only implodes:
                #   (sch_ballonlyt) -> G&t-ish, pull almost auto
                # needs some opposite to search with
            # wants to Rc&refs s now?
            # and the usual two-step confusible C-C nametag
        # < if engaged, %ball 5 notifies us?
                # engage drawing up of planes
                # becoming matter for idea/diff/apply
        
        # give idea of where on screen such ref is from here
        # eg up/prev/in = up, up/next/in = down
        # < up = left, in = right
        ['haveth','3',&acgtRs{
            if (!Rs&haveth) {
                n nohaveth  s:!
            }
            delete Rs&elvis;
            # draw an arrow between two R
            $we = me.cby(R,&R{ return Rs&cell });
            $th = me.cby(Rs&haveth,&R{ return Rs&cell });
            $direction = "v";
            each in we {
                $t = th[i];
                t == n and continue
                # path separates
                i == 0 and throw "different cells"
                $f = th[i-1];
                each il fs&z {
                    l == n and break
                    l == t and direction = '^'
                }
                break;
            }
            $d =
            n direction  $s:direction %fs:17,lh:0.05,hs:346
            
            $p = Ry&up;
            R.t == 'other' and direction == '^' and ps&upward = 1;
            
            if (!Rs&self) {
                # no yon %ball
                #R.t == 'self' and throw "self no self"
                R.t == 'self' &&
                    n ohno  s:!
                delete ds&hs; # green
            }
            # give other bigger arrow
            dc&s = dc&s == '^' ? '▲' : '▼';
            # < n should type styles into number etc
            R.t == 'other' and ds&fs = (ds&fs*1)+7
            # ◀ ▶
        },'ift,D'],
        
        #c ball, continuing thing around thing
        ['ball','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dupl = 0;
            s&br = '4';
            s&bo = '0.1em dotted #543';
            
            R.t != s.t &&
                n t 1 $s:R.t %fs:13,hs:288
            
            $t =
            n t 11 $s:s.t %deco,fs:8,fix:t,mr:0.3
            
            Rs&is == 'live' and s&bo = '4px dotted #782';
            
            if (Rs&boost < 0) {
                if (Rs&boost < -1) {
                    if (Rs&remova) {
                        Rs&remova();
                    }
                    else {
                        $pr = Ry&up;
                        !prs&ball and "up!ball"
                        $ups = prc&s;
                        i $ups/-$s
                        #upss&z = upss&z.filter(n => n != s);
                    }
                    n deleted  s:deleted %fs:6,hs:594
                    delete Rs&Te.sc.boost;
                }
                return
            }
            if (Rc&nofurther) {
                n nofurther 17 s:♲ %fs:8,mr:0.3
                return
            }
            
            if (sc&J || ss&H) {
                # should become or is a separate object
                #  H being dig(toLines(object))
                # and twocom'd:
                if (Rs&pushed) {
                    $p = Rs&pushed && Rs&pushed.filter(p=>ps&upward)[0];
                    $l = p && ps&pull;
                    n pup  $s:l,R %sun
                }
                Rs&boost > 0 and 'open'
                else {
                    Rs&nofurtherDisplay = 1
                }
                n J  s:J %fs:14,hs:966
            }
            
            # aim to keep a
            each kv s.c {
                n $k  $s:v,R %fix:c
            }
            each kv s.sc {
                k == 'z' and continue
                n $k  $s:v,R %fix:sc
            }
            
            
            if (Rs&boost > 0) {
                # edit C.t
                ts&e = 1;
                me&Tie,R,'sayeth',1;
                if (Rs&sayeth) {
                    tc&s = s.t = Rs&sayeth;
                    n cha  s:cha %fs:6,hs:594
                }
                # implant C -> C.t
                n typeball  R %etype:ball
            }
            me&endome,R;
            ss&z and me&Rsync,R;
        },'ift,D'],
        #c ballope
        # < sprout usual inquisitivity/saveness?
        ['etype','3',&acgtRs{
            n saying   %e,fs:8
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth) {
                $S = Rs&sayeth;
                $pr = Ry&up;
                !prs&ball and "up!ball"
                $ups = prc&s;
                if (S.substr(0,1) == '%') {
                    S = S.substr(1);
                    ups.sc[S] = ''
                    n made  s:+ %fs:6,hs:594
                }
                else {
                    i $ups/#$S
                    n made  s:+C %fs:6,hs:594
                }
            }
        },'ift,D'],
        
        # R%fix per c/sc style
        # < t/cv natively
        ['fix','3',&acgtRs{
            n k 1 $s:R.t %fs:11,hs:288
            
            !Rs&boost and return me&gkness,R;
            
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth != null) {
                $pr = Ry&up;
                $ups = prc&s;
                Rc&s = s = ups[Rs&fix][R.t] = Rs&sayeth;
            }
            if (typeof s == 'object') {
                # < just have to open it more
                n obj  s:obj %fs:12
            }
            n s 1 $s:s %e
        },'ift,D'],
        
        #c ball-lives
        ['Tool','3',&acgtRs{
            Rs&rowish = 1;
            n t  $s:R.t %hs:789
            #n rec  s:●
            #n stop  s:■
            #n redo  s:◀
            n play  s:▶ %fs:22
            return
            $p = Ry&up;
            $W = ps&z[ps&z.indexOf(R)+1];
            W.t != 'Wormhole' and return
            $s = G&ind,Wc&s,'ki';
            n ind  $s:s %dis
        },'ift,D'],
        ['ball','29',&acgtRs{
            1s&Te and me&Tie,R,'play'
            !Rs&play and return
            n playing  s:▶
            
            $l = me&push,R,['/','T'],[],'run',{does:'TeCo'};
            ls&boost = 2;
            me&introqua,l,{boost:2};
            
            return
            # < io walking expressions: 
            # o $s/^^%vey<* # wander up, look before whence from
            # o $s/%ball^^ # highest %ball:
            $W = me.cby(Ry&up,&r{ return !rs&ball })[1];
            Rs&Wball = W;
            # Teing consists of housing the thing
            #  such that Co gets instructed with it
            $l = Ws&input(['Co',s]);
            Rs&pullable = l[0];
            $b = Rs&instructoball = l[1];
            # pushes empty, gets replaced easily
            bs&othertricks = R;
            # usually %balls would have to clone out,
            #   change/encode into another %balls,
            #   that could then be othered..
            # wrapping layers of consciousness on
        },'ift,D'],
        ['ball','31',&acgtRs{
            !Rs&play and return
            $b = Rc&b;
            !b || bs&play and return
            $Co = Rs&pullable; # Co%ball
            $dow = Co && Cos&downstream;
            !dow and return
            # %pulls that %self=R
            each ip dow {
                !ps&upward and continue
                ps&shove = Rs&Wball.t+"'s "+R.t+'%play'
            }
            # once something $other=R, from above, open pull
            $ups = Co && Cos&upstream;
            !ups and return
            each ip ups {
                ps&upward and continue
                Rs&boost ||= 1;
            }
        },'ift,D'],
        #c ball-othering
        ['ball','52',&acgtRs{
            Rs&ball = 6; # look before you other
            # %othering is an incoming %pull -> %ball -> Jazz
            # to give us/yonder %balls here:
            #   pushing: %pull when incoming
            #   pushed: %pull (toplevel, otherer id)
            #   pushed_ball: %ball
            
            if (Rs&othertricks) {
                n oth  s:othertricks
            }
            
            each ir Rs&othering {
                # want the %move to be around?
                if (rs&push) {
                    # a %push putting:
                    $t = (Rs&othering_ball||[])[i] || rs&here;
                    $putting = 'pushing';
                    # if %there is here, their will inside
                    R == rs&there and putting += '_z';
                    ac(R,putting,r,'ball',t);
                }
                else {
                    # a %pull putting %self at %other
                    $o = rs&other;
                    if (o) {
                        $cb = me.cby(o,&o{ return o == R });
                        !cb || cb[0] != R and throw "%other not here"
                        ac(o,'pushing',r,'ball',rs&self);
                    }
                    else {
                        rs&putting and throw "%pull !%other %putting somewhere"
                        # or just here-ish, with a put-in-z emotion
                        ac(R,'pushing_z',r,'ball',rs&self);
                        # < build there down a branch, pass tests
                    }
                }
                
                $pr = ry&up;
                $D =
                n pushed   %fs:7
                D.sc.bo = '2px solid yellow';
                Dc&s = pr.t+'/'+r.t;
            }
            # %ball%pushed keep %pull up to date,
            # but not %pushed_ball - to keep the applied
            each ir Rs&pushed {
                Rs&pushed[i] = me&yfuture,r;
                # < de-other zombies by rc&ip...
                # < things rupturing as they delete
                #   themselves at the edge of the light cone
            }
            # %pushing are active %pulls
            each ir Rs&pushing {
                # whose treeing %self is already here
                $S = ac(R,'pushing',r,'ball');
                !Sc&s and throw "pushing !cs"
                !Ss&ball and throw "pushing !ball"
                # and replacing the last %self
                $l = ac(R,'pushed',r,'ball',S);
                $Ss = Sc&s;
                Ss.t != s.t and s.t = S.t
                each in Ss&z {
                    !ns&fix and continue
                    Ss&othertricks && ns&fix == 'sc' and continue
                    # < clone-out function would live on n%ball
                    s[ns&fix][n.t] = nc&s;
                }
                
                ac(R,'pushing_z',r,'ball',S);
            }
            each ir Rs&pushing_z {
                $S = ac(R,'pushing_z',r,'ball');
                $self_was_here = Rs&pushing && Rs&pushing.indexOf(r) >= 0;
                $z = self_was_here ? Ss&z : [S];
                each in z {
                    !ns&ball and continue
                    # some Co/* reset C chucked to n
                    #  many ways to try more clearly
                    $x = nc&s;
                    if (ns&othertricks || ns&clobberypushingz) {
                        i Rc&s/-#$x
                    }
                    # n thing that should be here
                    #   Rs&z +[ t%ball -> clone(nc&s)
                    # clone() = make spacer to keep t%pushing=S to
                    $t = me&input,R,x.t;
                    ts&ball && ts&ball == '6' and debugger
                    # t%ball now in Rs&z, keep %pushing=S
                    ac(t,'pushing',r,'ball',n);
                }
            }
        },'ift,D'],

        ['sun','3',&acgtRs{ me&Reis,R,'Cray',s; },'ift'],
        ['sunknown','3',&acgtRs{ me&Reis,R,'Cray',s; },'ift:to'],
        
        
        
    ] };
    #c Ringing unknown
    me.Displayingness = &acgt{ return [
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 888;
            Rc&dl ||= 35;
        }],
        ['Displayingness','3',&acgtRs{
            # this R can be clicked big/small
            me&boostulate,R;
        }],
        ['Displayingness','9',&acgtRs{
            Rs&noDisplay and return
            $d = me&Display,R;
        },'if:h'],
    ] };
    me.gkness = &acgtR{
        $M = me&Mw,R,'traw';
        
        # make block,inline have same indento
        $p = Ry&up;
        $iN = (ps&z||[]).indexOf(R) - 1;
        $f = iN >= 0 && ps&z[iN];
        f && fs&rowish and s&ml = 1
        
        s&fs = 7;
        m sym 12 not
        $pow = 2;
        Rs&boost and pow = 4;
        $string = ki(Rc&s,pow);
        if (string.length > 100) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    };
    me.Cray = &acgtRs{ return [
        ... me&Displayingness ,
        ['She','3',&acgtRs{
            $h = Rc&N[0];
            $p = Ry&up;

            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                me&gkness,R;
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });
            
            Rs&boost > 0 && Rc&d == 0 and Rs&runny = 2

            
            if (scan.C && (Rs&runny > 1
                ||
                (Rs&runny || Rc&d == 0) && sy&tv && ss&z && !ss&J
                )) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        }],
    ] };
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        if (s && typeof s == 'object') {
        # dedupe/limit objects already in this pool
        $ri = Rc&refs.indexOf(s);
        if (ri < 0) {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            RN.push(R);
            # in this pool
            $RhN = RN.filter(r => h && rc&N == hc&N);
            $dupl = Rc&dupl || 0;
            if (RhN.length > dupl) {
                limit('dup');
                Rc&nofurther = 1;
            }
            else {
                
            }
            !Rc&nofurther and limit('dub')
            # < to know circular links, converge
        }
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X, inwards
    #     X.z = [ R nodes
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    me.RbitX = &acgtR{
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # starting into Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        R.y.I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    # grow current R
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    # name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task ||= r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                h && hs&joinR and rc&N = hc&N
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    

