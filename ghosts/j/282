Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;


        # Relosophy of C and R
        =pod
    
    R similar to A, but want to fall faster
     could perhaps be throated together... maybe
      thRoat wants to return data iterations to step iterations in a pin
    bassline C get I->R+ from A&o pin/gear assortment of action
      juggling dives in, points and progress
        of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
    needs a playspout
         compiles fast change checkers (0-2) once inflated (8)
          so lowlevel changes (container re-ref) cause higher modes
          told/finding how innards roll through time (A&ip++)
    laying schemes on what objects are
          producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked.
    
    drawing macro cellular boundary
      based a bit on A.1 != Y.1 along the A
       then Rc&d and Ry&up, hy&up
    already micro cells (C) are bound,
      points lead through the pointy ones
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
        =head1 Srupto
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
          for going into the C and its state through time, etc
          in many pools, overlapping, notice objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        # similar but for unpackedness in general,
        
        # phases of aiming the display and adjusting things
        # latter -go wants to be pointed to not coded
        
        =cut
        
        
    #c Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    $drag;
    me.handelvis = &acgt{
        # unless dragging
        C.t.includes('mousedown') and drag = C; return 
        if (C.t.includes('mouseup')) {
            C.t = C.t.replace(/mouseup/,'click');
            if (drag) {
                $d = drag;
                $dif = [];
                # one common C, the rest different?
                each in dc&slope {
                    if (n != Cc&slope[i]) {
                        !dif.length && i > 0 and dif.push(Cc&slope[i-1])
                        dif.push(n)
                    }
                }
                dif.length and c&dragslope = dif;
            }
        }

        # go up C path until bingoed
        $lop = c&slope.slice().reverse();
        # - s&medo - instant, outside (A=4) (eg Jause)
        each in lop {
            # dont fire usual click event when dragging stuff to it
            c&dragslope and break
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            G&yl:123,&{ msg.set('what',ki(ret)) };
            return
        }
        # - s&med: 
        #   e -> 4c&elvrupto -> me.handelvis (here)
        # puts 4c&elvising as the event of the 4c&callback
        #   then inside callback J:Fourier oscs me.Elvising
        #    finding Rs&elvis = Gazer, etc
        4s&elvising = C;
        ~Insideon: ki(c&slope,2)
        G&yl,0,4c&callback;
    };
    
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';
        
        4s&elvised = [];
        G.oclon ||= G.clon;
        G.oclof ||= G.clof;
        if (1 && 'draggable') {
            G.clof();
            G.clof = &{
                window.onmousedown = null;
                window.onmouseup = null;
            };
            G.clon = &{
                window.onmousedown = &{ G&gev };
                window.onmouseup = &{ G&gev };
            };
            G.clon();
        }
        else {
            G.clof();
            G.clon = G.oclon;
            G.clof = G.oclof;
            G.clon();
        }
        
        $l = 4s&elvising;
        !l and return
        me&J,['elvising','-feel',{s:l},'elvising,boost:sc,solvey'];
        
        s&mih = '14';
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel
    
    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if ((e.t.includes('click')||1) && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
    #c e-slope/pointer
    
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 275;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and throw "ancient R"
            #debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.solveR = &acgtN{
        N = N.slice().reverse();
        $M = [];
        $c = {};
        each in N {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                ns&J and vs&J = Y.1
                c.1 = Y.1;
                # find W, the level Travel is got to
                ns&J && ns&J == ns&J.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                # find the deepest each of ...
                $perc = 'elvis dragelvis'.split(' ');
                each it perc {
                    R.sc[t] && !c[t] and c[t] = v.sc[t] = R.sc[t]
                }
            }
        }
        $p = [];
        each in M {
            # down to inner %elvis
            ns&elvis and p.push(n); continue
            !p.length and continue
            p.unshift(n);
            ns&W and break
        }
        return p
    };
    me.cra = &acgtD{
        s&solvey = me&solveR,c&slope;
        !s&solvey.length and return
        if (c&dragslope) {
            s&dragsolvey = me&solveR,c&dragslope;
            each in s&solvey {
                !ns&dragelvis and continue
                # once someone up the line wants to do motion
                each id s&dragsolvey {
                    # the dragged from R%elvis
                    !ds&elvis and continue
                    c&dragfrom ||= ds&R;
                }
                each id s&solvey {
                    # and what would have handled a non-drag
                    !ds&elvis and continue
                    c&dragto ||= ds&R;
                    delete ds&elvis;
                }
                # use the travel agent
                ns&elvis = ns&dragelvis;
                break
            }
        }
        # < to c&pointer, to locate us in
        $M = c&pointer = [];
        # < a pile of travel, io T points to look at
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in s&solvey {
            $v =
            m $n.t  {}
            ny&cv != null and vy&cv = ny&cv
            # < io spacerised is just t
            i $el/#$n
            el = ays&n[0];
            if (ns&elvis) {
                T.qua = {};
                $R = ns&R;
                # make the adjustment
                me[ns&elvis](A,C,G,T,R);
                # save the state
                each kv T.qua {
                    el.sc[k] = v;
                }
                s&elvis = Rs&elvis;
            }
        }
    };
    
    #c e-do
    # < boostulate requires A1..3 carry s&Te wires
    #   for the rest R carry s&Te wires
    #   so set value can be reintroduced
    # < check every T point was found
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        # ^ is somewherish. posits and deposits.
        1s&Te and me&Tie,R,'boost'
        
        !Rs&boost and return
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : 'W';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
            z.t += hu;
            i++;
        }
    };
    # click up/down anywhere
    me.Gazel = &acgtR{
        C.t == 'says' and return T.qua.sayeth = c&s
        
        Rs&boost ||= 0;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
    };
    # ESC from textinput
    me.sayeth = &acgts{
        ~Sayeth: ki(A), c&s
        T.qua.sayeth = c&s;
    };
    #c Mboostia
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tin rc&ha {
            if (rc&N.indexOf(n) >= 0) {
                # R included are from Rc&refs/refR
                # < may not be in our h/R pool, showing...
                #   same Rc&s=objects near but not in this process
                #t == 'dub' and continue
                # say where it originated
                $M = me&Mw,n,'Mlimits';
                m $t 89 s:♲ %deco,fs:13,lh:0.3
                # dub = from other R0
                if (t == 'dub' || t == 'dup') {
                    $o = ns&refR[0];
                    $nam = me&nampup,o,n;
                    m $t 892 $s:nam %deco,fs:7,hs:999
                }
                continue;
            }
            else {
                # knows upward that is
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
        }}
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $zs = t+' < '+N.map(t=>t.t).join(',');
            $te = '*'+t;
            m $te 117 $s:zs %deco,fs:13
        }}
    };
    #c Js receive Te
    # drive wiring from above
    me.JT = &acgts{
        delete 1s&Te;
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $v = p&tv $t;
        !v and return
        1s&Te = v;
    };
    # Rs inhale wiring from .y.up+s&Te
    # thenceforth getting
    # can resume pointering across Rs that don't
    # < checks all pointers were found
    me.Tie = &acgtRkd{
        #R.t == 'Knowing' and debugger;
        if (!Rs&Te) {
            # attach travelvis once..
            Rs&Te = {};
            #$r = R == Rc&N[0] ? me&RupinC,R : R.y.up;
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            $Tet = v&tv $t;
            if (0 && !Tet && v.t == t) {
                # pointer is thinning itself, stretch while t constant
                $vv = r.y.up;
                vv = vv && vvs&Te;
                if (vv) {
                    v = vv;
                    Tet = v&tv $t;
                    Tet and ~tstretch: r.y.up.t, t
                }
            }
            Tet and Rs&Te = Tet
        }
        $v = Rs&Te;
        !v || !v.c and return
        !k and return
        # once located, muddle with opportunity
        
        #vs&cb && vs&cb,R,t
        hak(v.sc,k) and R.sc[k] = v.sc[k]
        # oncer
        d == '1' and delete v.sc[k]
    };
    #c Rs
    me.namup = &acgts{
        !s and return
        $nam = [s.t];
        while (s = s.y.up) {
            nam.push(s.t);
        }
        return nam.reverse();
    };
    # show path between two R
    me.nampup = &acgton{
        $namo = me&namup,o;
        $name = me&namup,n;
        $pup = [];
        each is namo {
            if (!pup.length) {
                s == name[i] and continue
                if (name[i] != null) {
                    # up the n
                    pup.push(name.slice(i).map(la=>'^').join(''))
                }
            }
            pup.push(s)
        }
        if (!pup.length) {
            $ups = name.length - namo.length;
            while (ups--) { pup.push('^') }
            pup = [pup.join('')];
        }
        $nam = pup.join('/');
        return nam
    };
    # pick an R by name, from ...
    #   io wants to know R, loadup qualities...
    me.bit = &acgtRtf{
        typeof t != 'object' and t = [t]
        !f and f = R
        f == 'h' and f = Rc&N[0]
        each in t {
            #$fz = fc&X && fc&X.x[n] && fc&X.x[n].z;
            $fz = fs&z && fs&z.filter(t => t.t == n);
            !fz and throw "problem"
            fz.length < 1 and throw "notfound"
            fz.length > 1 and throw "many"
            f = fz[0];
        }
        return f
    };
    # path finder
    me.cby = &sfzd{
        !s and return !f && d
        z == 'up' and z = null
        z ||= &s{ return s.y.up };
        d ||= [];
        d.unshift(s) > 50 and debugger
        $r = f && f(s);
        r and return d
        return me.cby(z(s),f,z,d)
    };
    me.cbu = &sfz{
        $cb = f;
        typeof f == 'string' and cb = &R{ return R.sc[f] }
        typeof f == 'object' and cb = &R{ return R == f }
        $l = me.cby(s,cb,z||'up');
        return l && l[0]
    };
    me.pivot = &ft{
        !f and throw "no from"
        !t and throw "no to"
        $from = me.cby(f);
        $to = me.cby(t);
        from[0] != to[0] and debugger
        $la;
        $i = 50;
        while (from[0] == to[0]) {
            i-- < 0 and debugger;
            la = from.shift(); to.shift();
        }
        $a = from.slice();
        a.push(la);
        a.push(...to);
        return {f:from,v:la,to:to,a:a};
    };
    #c Ring R-ing
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
        return r
    };
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    

    
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        $task = Rs&task || R.t;
        !me[task] and debugger;
        $N = me[task](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            
            # compile instructions
            ns&ift == '1' and ns&if = 's'+n.t
            else
            ns&ift and ns&if = 's'+ns&ift; ns&ifeq = n.t;
            
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    # Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        #c walk the tape, trying to do more
        $busy = 1;
        $sheer = 45000;
        $onlyt;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                onlyt = null;
                $lowci = '';
                $ati;
                each in hc&N {
                    if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                        lowci = ns&ci;
                        ati = i;
                    }
                }
                #lowci != '' and hs&iN = ati-1
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            #onlyt && t != onlyt and continue
            
            hy&ov && hy&ov < ty&cv and debugger;
            
            # deciding
            $T = {};
            if (ts&if) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='ifh'
                elsif (ts&if[0] == 's') {
                    $v = R.sc[ts&if.substr(1)];
                    !v and T.not='if'
                    ts&ifeq && v != ts&ifeq and T.not='ifeq'
                }
                else {
                    throw "if "+ts&if
                }
            }
            
            if (!T.not) {
                $packdown = [];
                if (ts&D) {
                    # doming for n
                    $g = A.ground;
                    $z = gs&z;
                    gs&z = [];
                    packdown.push(&{
                        $w = gs&z;
                        gs&z = z;
                        !w || !w.length and return
                        $M = null;
                        each in w {
                            if (nc&R) {
                                # spawn R?
                                $parent = R;
                                $s = nc&R;
                                if (s && Rc&N.indexOf(s) >= 0) {
                                    parent = s;
                                    s = null;
                                }
                                delete nc&R;
                                nc&s and s = nc&s; delete nc&s
                                ex(n.sc,n.c);
                                $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
                                parent != R and zN(r)
                            }
                            else {
                                # otherwise this mindthing grows M
                                M ||= me&Mw,R,t.t;
                                M.push(n)
                            }
                        }
                    });
                }

                $cb = tc&s;
                !hak(R.c,'s') and debugger;
                
                cb(A,Rs&C||C,G,T,R,Rc&s);
                
                packdown.map(pd=>pd())

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            if (T.wide) {
                Rs&widenings ||= 0;
                Rs&widenings++ > 30 and debugger;
                delete T.wide;
                busy = 1;
                continue;
            }
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            onlyt = t;
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c autoravel
    # waltzing stringpasses, 
    
    # pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    $ve;
    me.Ja.Pass = &acgt{
        me&Gomp;
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Jazz  $s:el %ravel
        
        $ve = 4s&eland ||= G&Cye,['Vectroland',''];
        n eland  $s:ve %Cray
        
    };
    # now Ray and his armies will go do:
    me.Ja.happenings = &acgt{
        me&Gomp;
        
        n Plethoria  {s:<<''} %of:s
            # glampiture
            n now  s:now %fs:54
        
        
    };
    # via a drag-n-drop of gear to send massages
    # < e become active que-sheets
    #   may arrange/drop themselves into Wormhole...
    #   workings for the Step: wait for such release
    # all a AndContinuance, but let's see it think in R
    me.projvey = &acgtR{
        $A = G&Aye;
        $f = c&dragfrom;
        $t = c&dragto;
        $d = A.ground = G&Cye,['dr','',{elvis:C}];
        4s&eland = d;
        ds&from = f;
        ds&to = t;
        f == t and return ds&same = 1;
        $p = me.pivot(f,t);
        $v = p.v;
        # between places simple?
        $nonballic = p.a.filter(n => !ns&ball);
        if (!nonballic.length) {
            $S = tc&s;
            $s = fc&s;
            i $S/$s
            ds&moved = 1;
            ~move: S.t, '<-', s.t
        }
        elsif (vs&Cell) {
            fs&Tool and ts&play = ts&play ? 0 : 1
            else {
                ~cellsomething
            }
        }
        else {
            # move item
            ds&dunno = 1;
            ~dunno
        }
        dc&s = p;
    }
    #c cellvey think about their state,
    # become straight, become curvy
    # have things wanting to be streamed uphill
    # showing interfaces where things can come across
    me.ravel = &acgtR{ return [
        ... me&Displayingness ,
        ['She','1',&acgtRs{
            $uh = Ry&up && Ry&up.c.N[0];
            uhs&task == Rs&task and return;
            # start by checking out thy name
            Rs&cell = 1;
            Rc&dupl = 3;
        },'if:h'],
        
        
        # the living bit
        ['cell','3',&acgtRs{
            Rs&rowish = 1;
            # settle/unsettle %vey
            n st  s:~ %statebusiness,fs:7
            n t  $s:R.t
            Rs&dragelvis = 'projvey';
            s&unsel = 1;
            
            # A.4 to/run/from, shared
            # is the local stage, our gear projected on
            n Travel  $R:Rc&s %ball
            
            # create and harvest arrangements of gear
            #  %Teing extrapolates runningness?
            n Subgumption  R:Wormhole>Travel %vey:Teing
            
            # ourself in a space
            # so others can come, composite
            # building spacetime islands
            me&rollbs,R,'Cell';
            if (!Rs&Cell) {
                $t = Ry&up.c.s.t;
                Rs&Cell = G&Cye,["Wormhole",''];
                i Rs&Cell/#$t
            }
            n T  R %Tool
            n Wormhole  $R:Rs&Cell %ball
            
            # continuity of generation
            n Substraction  R:Wormhole>String %vey:Lines
            # into other place
            n String  $R:localStorage %String,twocom
            
            # < be facty
            $b = Rc&b;
            b && bc&s != Rc&s &&
                n change  s:cscha

            # slow rolling wakeup
            # openness is travelled in
            # up into cell
            n openness  s:openness %blr:4,fs:30
        },'ift,D'],
        # a pattern match and squish for long skinny trees
        ['ball','6',&acgtRs{
            Rs&boost and return
            $pr = Ry&up;
            !pr and return;
            prs&z.filter(t => ts&ball).length != 1 and return
            delete Rs&rowish;
        },'ift'],
        # vey
        # gather names in either direction
        ['vey','31',&acgtRs{
            n t  $s:R.t %hs:789
            $any = s.split('>').map(t => me&bit,R,t,'h' );
            Rs&from = any[0];
            # %pull thing per thing in any thing (+ pointers)
            #   From: %pull/%self
            #   To: %into/%other
            # and the %vey above expects %ball to carry changes
            #   %ball jointing of self-other,
            #   %ball state moves also via Lines from self src'd for other
            $balls = &z{
                z = z && z.filter(n => ns&ball);
                return z && z.length ? z : 0
            };
            each iy any {
                each iY any {
                    y == Y and continue
                    $z = balls(ys&z) || ys&twocom && balls(Ys&z);
                    # < ys&cursor, as a way to tune into the Wormhole
                    # < sub-pulls to things aimed at
                    # < knowing the thing moved:
                    #    follow, or restart at the new cursor position
                    each in z {
                        !ns&ball and continue
                        # says which from direction
                        $t = y.t+"'s "+n.t
                        n $t  $pull:y,cot:n.t,into:Y,R
                        # to etc more easily as intended
                    }
                }
            }
        },'ift,D'],
        #c pull
        # t individuals in any place
        # %pull=from %ball vaguely
        # %self=from %ball specifica
        # %haveth=to %ball vaguely
        # %other=from %ball specifica
        ['pull','22',&acgtRs{
            s = Rs&self;
            s && !ss&ball and throw "pull:ball"
            s&bo = '3px dotted green';
            s&br = 0.3;
            s&dis = 2;
            # < may take a while to find it remotely
            # < nameclue wants the whole %pull-%ball-C structure
            #   which might have important kinks
            #   concat modulat 1-2?
            # wants to Rc&refs s now?
            # and the usual two-step confusible C-C nametag
            (!s || R.t != s.t) &&
                n t 1 $s:Rs&cot||R.t %fs:13,hs:288
            $t = s &&
            n t 11 $s:s.t %deco,fs:8,mr:0.3
            # < overall, has it pushed? 
            # < state change here/there click to show in %ball
            #     that %ball's %pushed_ball will be historic,
            #         have sc.z %fix and etc
        },'ift,D'],
        # what else to do with a pull:
        #  difference it
        #   < amongst/firstly via %ball
        #     < new/gone similar -> moved
        #  push it
        # and the %other %ball already in the place
        ['pull','3',&acgtRs{
            # if we have our this, the reflection of s
            $v = Ry&up;
            Rs&pull == vs&from and Rs&forward = 1;
            if (Rs&forward) {
                # should show up as an item to push
                #   push/display change fairly easily
                #   n.t only: G&t-ish, pull almost auto
                n forward  s:->
            }
            else {
                # just something else over there
                !Rs&boost and s&fs = 6;
                # return
            }
            $poin = &ht{
                return hs&z && hs&z
                .filter(n => ns&ball && n.t == t)[0];
            };
            $pointer = &th{
                $t = R.sc[t] || Rs&cot != null ? Rs&cot : R.t;
                typeof t != 'object' and t = [t]
                each in t {
                    h = h && poin(h,n);
                }
                return h
            };
            $coutwo = &yo{
                !ys&twocom and return
                # needs some opposite to search with
                !o and return
                return ys&twocom(o);
            };
            # havers of %balls
            Rs&self ||= pointer('picking',Rs&pull);
            Rs&other ||= pointer('putting',Rs&into);
            Rs&self ||= coutwo(Rs&pull,Rs&other);
            !Rs&other && R.t == 'Jazz' and debugger;
            Rs&other ||= coutwo(Rs&into,Rs&self);
            
            n self  $self:Rs&self,haveth:Rs&pull,R,other:Rs&other
            
            n other  $self:Rs&other,haveth:Rs&into,R,other:Rs&self
        },'ift,D'],
        
        ['haveth','3',&acgtRs{
            delete Rs&elvis;
            # draw an arrow between two R
            $we = me.cby(R,&R{ return Rs&cell });
            $th = me.cby(Rs&haveth,&R{ return Rs&cell });
            $direction = "v";
            each in we {
                $t = th[i];
                t == n and continue
                # path separates
                i == 0 and throw "different cells"
                $f = th[i-1];
                each il fs&z {
                    l == n and break
                    l == t and direction = '^'
                }
                break;
            }
            $d =
            n direction  $s:direction %fs:17,lh:0.05,hs:346
            
            if (!Rs&self) {
                # no yon %ball
                #R.t == 'self' and throw "self no self"
                R.t == 'self' &&
                    n ohno  s:!
                delete ds&hs; # green
            }
            # give other bigger arrow
            dc&s = dc&s == '^' ? '▲' : '▼';
            # < n should type styles into number etc
            R.t == 'other' and ds&fs = (ds&fs*1)+7
            # ◀ ▶
        },'ift,D'],
        
        #c pulling
        ['pull','4',&acgtRs{
            s = Rs&self;
            !s and return; #throw "pull with no self"
            
            me&rollbs,R,'plan';
            $v = Ry&up;
            $t = Rs&into;
            # < if engaged, %ball 5 notifies us?
            if (Rs&boost > 0) {
                if (Rs&other || ts&twocom) {
                    # engage drawing up of planes
                    # becoming matter for idea/diff/apply
                    Rs&diffing = 'string';
                    [Rs&self,Rs&other].map(&s{
                        !s and return
                        # make both sets %ball%Lines
                        ss&Lines == null and ss&Lines = 1
                        if (vs&vey) {
                            # < moving stuff around processors:
                            vs&vey == 'Lines' and return
                            # %balls go through process
                            # %ball%Teing takes %ball(%Lines)
                            # compiles %self%ball%Teing --> I%ball
                            # then I%ball%Lines <-> %other%ball%Lines
                            # must know forward/reverse.
                        }
                        # either may do some %ball %othering into %ball
                        # or if %into%twocom, Lines as string,
                    });
                }
                else {
                    # new item, no pre-game show to other it
                }
                # for engaging from 7 a difference:
                #   either from each in Lines, or:
                #   these %balls at 6 going into the Teing process
                # to be brought back here for application
            }
            
            $bootable = !Rc&b && Rs&other && !Rs&other.sc.z;
            if (bootable || Rs&boost > 1) {
                !bootable and Rs&Te.sc.boost = 1;
                 
                if (ts&twocom) {
                    # jam them in now and resync Rs all over?
                    # we could know from elvising that this pull is active
                    # < do it out of time, so %other%balls should be already
                    #   as %self%balls is
                    Rs&twocoma = t
                }
                else {
                    # things that apply now
                    !ts&ball and throw "notball"
                    ts&othering ||= [];
                    ts&othering.push(R);
                    n writ  s:⥿ %fs:22,ab
                }
            }
        },'ift,D'],
        
        ['pull','7',&acgtRs{
            if (Rs&twocoma) {
                $t = Rs&twocoma;
                $S = Rs&self;
                ~Twocoming: Rs&other.sc.ta, Rs&self.sc.ta
                ts&twocom(Rs&other,Rs&self);
                n writ  s:⥾ %fs:22,ab
                return
            }
            if (Rs&diffing) {
                s&hue = 80;
                # is expected, compute diff
                n diff  $self:Rs&self,diff:Rs&other,R
                # < map diff back out to %balls, if clicked
                # < might turn the diff into another artifact of time
                #   that needs rebasing when what you're working on changes
                # < making several commits of a bunch of change
                #   by the initial diff selecting %self%balls
                #   to go %othering into a %staging%balls
                #   %Lines that and diff etc against %other again
            }
        },'ift,D'],
        
        #c diff balls with strings
        ['diff','3',&acgtRs{
            s&ws = 'pre';
            s&fs = 7;
            s&wb = 'break-word';
            #s&hue = '84deg';
            # ^ applies to diffproximate but not the patch?
            
            $g = Rc&s || Rs&self;
            !gs&ball and throw "Got!ball"
            $x = Rs&diff;
            x && !xs&ball and throw "Exp!ball"
            
            if (gs&string == xs&string) {
                n equal  s:= %fs:45,ab,lh:0.1
                return
            }
            if (!gs&string || !xs&string) {
                !gs&string && 
                n empties  s:!selfstring
                !xs&string && 
                n empties  s:!othstring
                n empties  s:! %fs:45,ab,lh:0.1
                return
            }
            n notequal  s:~ %fs:45,ab

            # switch chunk: word/line

            me&rollbs,R,'Digs,Diff,CompN,Comp';
            $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
            Rs&Digs != digs and delete Rs&Diff; 
            Rs&Digs = digs;

            # the job
            $c = {chunk:'word',fold:1};
            $N = Rs&Diff ||= diff(xs&string,gs&string,c);

            # CompN - sum noise
            Rs&CompN != N and delete Rs&Comp;
            if (!Rs&Comp) {
                Rs&Comp = me&textdiffN,N,c;
                Rs&CompN = N;
            }

            me&diffproximate,R;
            
            if (Rs&boost > 0) {
                $l = Ry&up;
                ls&rowish = 1;
                $p =
                n patch   %max-height:7,over,dis
                ps&z = [...Rs&Comp];
            }
        },'ift,D'],
        #c String & the %balls on %Lines encode-decode
        # get the that
        # assorted W you asked for, bay of incoming remotes
        #   elvising/G&t-ish interface to mysterious places
        ['String','2',&acgtRs{
            Rs&rowish = 1;
            n t  $s:R.t
            s&bo = '1px dotted green';
            s&br = 0.3;
            Rs&twocom = &ne{
                # as G&t, %ball seeking itself over here
                $k = ns&H || n.t;
                if (e) {
                    !es&ball and throw 'twocom e!ball'
                    k = es&H || e.t;
                    # < may contain several things to which you must link
                    # < H - object by hash key
                    $good = es&string && es&string.length > 3
                    !good and throw "string dodgy"
                    # < check it still is that
                    localStorage[k] = es&string;
                }
                s = localStorage[k];
                
                !s and return
                
                $re = Rs&rememb ||= {};
                $kd = k+dig(s);
                $bc = {task:'ravel',Lines:1,intoa:'ball'};
                bc.remova = &{ delete re[kd] };
                
                $S = re[kd] ||= me&Reis,R,k,s,bc;
                
                
                !Ss&ball and throw "notball twocomda "+k
                if (e) {
                    # %balls check decode same?
                }
                
                return S
            };
        },'ift,D'],
        
        ['Lines','22',&acgtRs{
            !s and ns&notfound = 1; return
            $b = Rc&b;
            Rs&string = s;
            if (b && bs&string == Rs&string) {
                me&rollbs,R,'toLines,dige,decoded';
            }
            else {
                Rs&toLines = Rs&string.split("\n");
                Rs&toLines.slice(-1)[0] == '' and Rs&toLines.pop();
                Rs&dige = dig(s);
                Rs&decoded = G&readLines,s [0];
            }
            Rc&s = Rs&decoded;
            Rs&intoa and Rs&Lines = 0; R.sc[Rs&intoa] = 1
            # are now %ball continued
        },'ift,D'],
        
        ['Lines','6',&acgtRs{
            !Rs&ball and throw "Lines!ball"
            $L = Rs&Lines;
            if (L == '1') {
                L = Rs&Lines = R;
                Rs&Hi = {};
                Rs&LinesN = [];
            }
            Ls&LinesN.push(R);
            each in Rs&z {
                !ns&ball and continue
                ns&Lines = Rs&Lines
            }
            $part;
            try {
                part = 'scan';
                !isC(s) and throw "Not C"
                typeof C.y != 'object' and throw "NotC"
                sc&N and throw "mightbe R"
                # ^ Care-ing for an unconscious R in z?
                #     if Rs&C wasn't made, Rc&s = Rousce
                #   as if Rc&nofurther + s&z emit, they may show up...
                part = 'clone';
                $D = G&Cye,s;
                part = 'comp';
                # comp && comp(R,D);
                #R.c.not and return
                part = 'Compress';
                G&Compress,D;
                part = 'toLines';
                Rs&toLines = G&toLines,D;
            }
            catch (er) {
                ~enLinesR: ki(C,2)+"   !"+part+"! "+er
                me&Rec,R,'err';
                Rs&toLines = "[error} "+ki(C);
                Rs&err = "enLinesR: "+part+": "+er;
                n err  $s:Rs&err
            }
        },'ift,D'],
        
        ['Lines','67',&acgtRs{
            Rs&Lines != R and return
            $rN = Rs&LinesN.slice().reverse();
            Rs&LinesBunch = [];
            each ir rN {
                $ind = '';
                $i = 0;
                $dent = rc&d - Rc&d;
                while (i < dent) { ind += '  '; i++ }
                $l = rs&toLines.split("\n")
                    .map(l => ind+l).join("\n");
                #l += "\n";
                Rs&LinesBunch.unshift(l);
            }
            Rs&string = Rs&LinesBunch.join("\n")+"\n";
            Rs&dige = dig(Rs&string);
        },'ift,D'],
        
        #c ball, continuing thing around thing
        ['ball','3',&acgtRs{
            Rs&rowish = 1;
            Rc&dupl = 0;
            s&br = '4';
            s&bo = '0.1em dotted #543';
            
            R.t != s.t &&
                n t 1 $s:R.t %fs:13,hs:288
            
            $t =
            n t 11 $s:s.t %deco,fs:8,fix:t,mr:0.3
            
            Rs&is == 'live' and s&bo = '4px dotted #782';
            
            
            if (Rs&boost < 0) {
                if (Rs&boost < -1) {
                    if (Rs&remova) {
                        Rs&remova();
                    }
                    else {
                        $pr = Ry&up;
                        !prs&ball and "up!ball"
                        $ups = prc&s;
                        #i $ups/-$s
                        upss&z = upss&z.filter(n => n != s);
                    }
                    n deleted  s:deleted %fs:6,hs:594
                    delete Rs&Te.sc.boost;
                }
                return
            }
            if (Rc&nofurther) {
                n nofurther 17 s:♲ %fs:8,mr:0.3
                return
            }
            
            
            # aim to keep a
            each kv s.c {
                n $k  $s:v,R %fix:c
            }
            each kv s.sc {
                k == 'z' and continue
                n $k  $s:v,R %fix:sc
            }
            
            
            if (Rs&boost) {
                # edit C.t
                ts&e = 1;
                me&Tie,R,'sayeth',1;
                if (Rs&sayeth) {
                    tc&s = s.t = Rs&sayeth;
                    n cha  s:cha %fs:6,hs:594
                }
                # implant C -> C.t
                n typeball  R %etype:ball
            }
            
            if (ss&z) {
                each in ss&z {
                    n $n.t  $s:n,R %ball
                }
            }
        },'ift,D'],
        # an open ball
        # < sprout usual inquisitivity/saveness?
        ['etype','3',&acgtRs{
            n saying   %e,fs:8
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth) {
                $S = Rs&sayeth;
                $pr = Ry&up;
                !prs&ball and "up!ball"
                $ups = prc&s;
                if (S.substr(0,1) == '%') {
                    S = S.substr(1);
                    ups.sc[S] = ''
                    n made  s:+ %fs:6,hs:594
                }
                else {
                    i $ups/#$S
                    n made  s:+C %fs:6,hs:594
                }
            }
        },'ift,D'],
        
        # %fix c/sc patchables in R-state
        # t is coming too
        ['fix','3',&acgtRs{
            n k 1 $s:R.t %fs:11,hs:288
            
            !Rs&boost and return me&gkness,R;
            
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth != null) {
                Rs&fix != 'sc' and throw "weisitu"
                $pr = Ry&up;
                $ups = prc&s;
                Rc&s = s = ups[Rs&fix][R.t] = Rs&sayeth;
            }
            if (typeof s == 'object') {
                # < just have to open it more
                n obj  s:obj %fs:12
            }
            n s 1 $s:s %e
        },'ift,D'],
        
        #c ball-lives
        ['Tool','3',&acgtRs{
            Rs&rowish = 1;
            n t  $s:R.t %hs:789
            #n rec  s:●
            #n stop  s:■
            #n redo  s:◀
            n play  s:▶ %fs:22
        },'ift,D'],
        ['ball','6',&acgtRs{
            me&rollbs,R,'play';
            Rs&play &&
            n playing  s:▶
        },'ift,D'],
        
        #c ball-othering
        ['ball','52',&acgtRs{
            Rs&ball = 6; # look before you other
            # %othering is an incoming %pull -> %ball -> Jazz
            # to give us/yonder %balls here:
            #   pushing: %pull when incoming
            #   pushed: %pull (toplevel, otherer id)
            #   pushed_ball: %ball
            me&rollbs,R,'pushed,pushed_ball';
            
            # dual array Stever
            $ac = &skvKV{
                K and K = k+'_'+K;
                $l = s.sc[k] ||= [];
                $li = l.indexOf(v);
                if (li >= 0) {
                    if (K) {
                        $L = s.sc[K] ||= [];
                        $was = L[li];
                        V and L[li] = V
                        return was
                    }
                }
                else {
                    l.push(v);
                    if (K && V) {
                        $L = s.sc[K] ||= [];
                        L.push(V);
                    }
                }
            };
            
            # introgression begins at the %pull%into level
            each ir Rs&othering {
                # a %pull putting %self at %other
                $o = rs&other;
                if (o) {
                    $cb = me.cby(o,&o{ return o == R });
                    !cb || cb[0] != R and throw "%other not here"
                    ac(o,'pushing',r,'ball',rs&self);
                }
                else {
                    rs&putting and throw "%pull !%other %putting somewhere"
                    # or just here-ish, with a put-in-z emotion
                    ac(R,'pushing_z',r,'ball',rs&self);
                    # < build there down a branch, pass tests
                }
                
                $pr = ry&up;
                $D =
                n pushed   %fs:7
                D.sc.bo = '2px solid yellow';
                Dc&s = pr.t+'/'+r.t;
            }
            # %ball%pushed keep %pull up to date,
            # but not %pushed_ball - to keep the applied
            each ir Rs&pushed {
                while (ry&future) { r = ry&future }
                # < de-other zombies by rc&ip...
                # < things rupturing as they delete
                #   themselves at the edge of the light cone
                Rs&pushed[i] = r;
            }
            # %pushing are active %pulls
            each ir Rs&pushing {
                # whose treeing %self is already here
                $S = ac(R,'pushing',r,'ball');
                # and replacing the last %self
                $l = ac(R,'pushed',r,'ball',S);
                S.t != s.t and s.t = S.t
                each in Ss&z {
                    !ns&fix and continue
                    # < clone function would live on ball
                    s[ns&fix][n.t] = nc&s;
                }
                
                ac(R,'pushing_z',r,'ball',S);
            }
            each ir Rs&pushing_z {
                $S = ac(R,'pushing_z',r,'ball');
                $self_was_here = Rs&pushing && Rs&pushing.indexOf(r) >= 0;
                $z = self_was_here ? Ss&z : [S];
                each in z {
                    !ns&ball and continue
                    # look for a child under here already
                    $t = Rs&z && Rs&z.filter(t => ts&ball && t.t == n.t)[0];
                    # or make it up
                    if (!t) {
                        # < io should require unique arks
                        i Rc&s:up/#$nc&s
                        $D = ays&s[0];
                        t = me&Ret,R,{t:D.t,s:D,ball:1};
                    }
                    # pass the same %pull and a descending %self...%ball
                    ac(t,'pushing',r,'ball',n);
                }
            }
        },'ift,D'],

        ['sun','3',&acgtRs{ me&Reis,R,'Cray',s; },'ift'],
        ['sunknown','3',&acgtRs{ me&Reis,R,'Cray',s; },'ift:to'],
        
        
        
    ] };
    #c Ringing unknown
    me.Displayingness = &acgt{ return [
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 275;
            Rc&dl ||= 35;
        }],
        ['Displayingness','3',&acgtRs{
            # this R can be clicked big/small
            me&boostulate,R;
        }],
        ['Displayingness','9',&acgtRs{
            $d = me&Display,R;
        },'if:h'],
    ] };
    me.gkness = &acgtR{
        $M = me&Mw,R,'traw';
        
        # make block,inline have same indento
        $p = Ry&up;
        $iN = (ps&z||[]).indexOf(R) - 1;
        $f = iN >= 0 && ps&z[iN];
        f && fs&rowish and s&ml = 1
        
        s&fs = 7;
        m sym 12 not
        $pow = 2;
        Rs&boost and pow = 4;
        $string = ki(Rc&s,pow);
        if (string.length > 100) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    };
    me.Cray = &acgtRs{ return [
        ... me&Displayingness ,
        ['She','3',&acgtRs{
            $h = Rc&N[0];
            $p = Ry&up;

            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                me&gkness,R;
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });
            
            Rs&boost > 0 && Rc&d == 0 and Rs&runny = 2

            if (Rs&runny > 1 || (Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        }],
    ] };
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        if (s && typeof s == 'object') {
        # dedupe/limit objects already in this pool
        $ri = Rc&refs.indexOf(s);
        if (ri < 0) {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            RN.push(R);
            # in this pool
            $RhN = RN.filter(r => rc&N == hc&N);
            $dupl = Rc&dupl || 0;
            if (RhN.length > dupl) {
                limit('dup');
                Rc&nofurther = 1;
            }
            else {
                
            }
            !Rc&nofurther and limit('dub')
            # < to know circular links, converge
        }
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X, inwards
    #     X.z = [ R nodes
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    me.RbitX = &acgtR{
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # starting into Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        R.y.I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    # grow current R
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    # name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task ||= r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                h && hs&joinR and rc&N = hc&N
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    

