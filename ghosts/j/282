Coffle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;


        # Relosophy of C and R
        =pod
    
    R similar to A, but want to fall faster
     could perhaps be throated together... maybe
      thRoat wants to return data iterations to step iterations in a pin
    bassline C get I->R+ from A&o pin/gear assortment of action
      juggling dives in, points and progress
        of expanding/shrinking pools in the pool
          and filling itself in for working through time
          once inflated...
    needs a playspout
         compiles fast change checkers (0-2) once inflated (8)
          so lowlevel changes (container re-ref) cause higher modes
          told/finding how innards roll through time (A&ip++)
    laying schemes on what objects are
          producing a unified linguistic core
        what they are becomes, in layers.
        and tangles, hyperlinked.
    
    drawing macro cellular boundary
      based a bit on A.1 != Y.1 along the A
       then Rc&d and Ry&up, hy&up
    already micro cells (C) are bound,
      points lead through the pointy ones
    
    pointing to enlarge parts should shrink unpointed parts
    
        giving light pools an interface to one another
          os may be comissioned from n
            it finds its own previous thinking, checking it...
          presenting ways to understand from the moment G&n
            so os owns the things life from there
        from where it originally was scored
          eg. this showing the C subsisting sense of the C itself
           as edges
        
        =head1 Srupto
        
        for growing mind in a pin with sections
          the hook and the iterator switch places:
            iteration happens in a while that returns
        
        S Knowing 2 $r %unknown
          should Re 'Knowing' for each C s&unknown thing
          with this section generating/emitting the layer
        S Knowing 3 $r
          can take M
        S Knowing 4 $r
          similarities?
        and also I/s/unknown
          u should be generatable soon, with such a trick
        
        
        =head1 Elvising
        
        and other hanging around ness...
        
        os makes Elvising of the Res
          a better way to hold history? in Jc&o now
          e want to have pointer stuff
            the things point/naming a bunch of atoms
            maps/traces of string
        
        the time-independent interface to osc action
        
        R are essentially
          for going into the C and its state through time, etc
          in many pools, overlapping, notice objects had by each other
            eg. a bunch of C touring a cyclically linked structure
          a quiet link, to be modulated/packed into Cs
          produced and consumed by the process
          to represent, as thinking has things to it.
          for things qualities to get framed,
            process and its C-side project through it.
          for locating in the living mind (travel)
          bits dangling from it, leading to more bits
            as a Jup-place (on its Elvising)
            and the travel, anything coming out.
        repeatable stumbles.
        
        =head2 R looks at R
        
        getting into the minds of itselves,
        scribing c/sc as far as desired
         want to map out parallel bunches of C for display,
           or representing jobs going on (Elvising)
         strategies want to know if their reason changes...
         want to know the usual R properties, for shrinkage.
        
        schemas for drawing stuff with Cs
          presenting the spaces as two (ish) layers (c/sc)
         to grab their jobs from C & R:* happenings..
        
        < visually an osc
          
          expr-go shows lookfortheedge-globe's C/R/A with a bunch of -od
        < whose only changes are the ticking of the A's ip
          the classic want-to-grasp time thing...
            AND noticing/not trivial usual
          many employees passing through a role
          
        < osc animation layer... vast goings fade out
          is the one place anything can happen!
          motuvation. the < see stuff, the > assume CRAP
        
        < to have a native reset/rebase
          resolve which atoms are pointing to/from which others...
          last applied stratagem of suchness diffed with current one
          steps taken to satisfy certains, leave uncertain interactive
        < including generatedness...
        <  maps of various resolution and sprawl
        # interfaces available to those ^ (open/close, attach to..)
        # should be detailed on the 
        # similar but for unpackedness in general,
        
        # phases of aiming the display and adjusting things
        # latter -go wants to be pointed to not coded
        
        =cut
        
        
    #c Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    me.handelvis = &acgt{
        # go up C path until bingoed
        $lop = c&slope.slice().reverse();
        # - s&medo - instant, outside (A=4) (eg Jause)
        each in lop {
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            G&yl:400,&{ msg.set('what',ki(ret)) };
            return
        }
        # - s&med: 
        #   e -> 4c&elvising -> J:Fourier -> me.Elvising
        #   having gone inside (4c&callback)


        4s&elvising = C;
        ~Insideon: ki(c&slope,2)
        G&yl,0,4c&callback;
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel
    
    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if ((e.t.includes('click')||1) && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
    #c slope/pointer
    
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 275;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and throw "ancient R"
            #debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.cra = &acgtD{
        #$el = c&path_yon.slice(-1)[0];
        $M = s&solvey = [];
        $upwards = c&slope.slice().reverse();
        $c = {};
        each in upwards {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                ns&J and vs&J = Y.1
                c.1 = Y.1;
                # find W, the level Travel is got to
                ns&J && ns&J == ns&J.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                Rs&elvis && !c.elvis and c.elvis = vs&elvis = Rs&elvis
            }
        }
        !c.elvis and ~sloping
        !c.elvis and return
        $p = [];
        each in M {
            ns&elvis and p.push(n); continue
            !p.length and continue
            p.unshift(n);
            ns&W and break
        }
        s&solvey = p;
        
        # < to c&pointer, to locate us in
        $M = c&pointer = [];
        # < a pile of travel, io T points to look at
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in p {
            $v =
            m $n.t  {}
            ny&cv != null and vy&cv = ny&cv
            # < io spacerised is just t
            i $el/#$n
            el = ays&n[0];
            if (ns&elvis) {
                T.qua = {};
                $R = ns&R;
                # make the adjustment
                me[ns&elvis](A,C,G,T,R);
                # save the state
                each kv T.qua {
                    el.sc[k] = v;
                }
                s&elvis = Rs&elvis;
            }
        }
        
        # < overplace set value
        # < boostulate requires A1..3 carry T wires
        #   for the rest R carry T wires
        #   so set value can be reintroduced
        # < check every T point was found
        #4s&elvising = C.c;
        #~etc: $(el).text();
    };
    
    #c Mboostia
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tin rc&ha {
            if (rc&N.indexOf(n) >= 0) {
                # R included
                #t == 'dub' and continue
                # say where it originated
                $o = ns&refR[0];
                $namo = me&namup,o;
                $name = me&namup,n;
                $pup = [];
                each is namo {
                    if (!pup.length) {
                        s == name[i] and continue
                        if (name[i] != null) {
                            # up the n
                            pup.push(name.slice(i).map(la=>'^').join(''))
                        }
                    }
                    pup.push(s)
                }
                if (!pup.length) {
                    $ups = name.length - namo.length;
                    while (ups--) { pup.push('^') }
                    pup = [pup.join('')];
                }
                $nam = pup.join('/');
                $M = me&Mw,n,'Mlimits';
                m $t 89 s:* %deco,fs:7,lh:0.3
                m $t 892 $s:nam %deco,fs:7,hs:999
                continue;
            }
            else {
                # knows upward that is
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
        }}
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $zs = t+' < '+N.map(t=>t.t).join(',');
            $te = '*'+t;
            m $te 117 $s:zs %deco,fs:13
        }}
    };
    #c Js drive wiring from above
    me.JT = &acgts{
        delete 1s&Te;
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $v = p&tv $t;
        !v and return
        1s&Te = v;
    };
    # Rs inhale wiring from .y.up+s&Te
    # thenceforth getting
    # can resume pointering across Rs that don't
    # < checks all pointers were found
    me.Tie = &acgtRkd{
        #R.t == 'Knowing' and debugger;
        if (!Rs&Te) {
            # attach travelvis once..
            Rs&Te = {};
            #$r = R == Rc&N[0] ? me&RupinC,R : R.y.up;
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            $Tet = v&tv $t;
            if (0 && !Tet && v.t == t) {
                # pointer is thinning itself, stretch while t constant
                $vv = r.y.up;
                vv = vv && vvs&Te;
                if (vv) {
                    v = vv;
                    Tet = v&tv $t;
                    Tet and ~tstretch: r.y.up.t, t
                }
            }
            Tet and Rs&Te = Tet
        }
        $v = Rs&Te;
        !v || !v.c and return
        !k and return
        # once located, muddle with opportunity
        
        #vs&cb && vs&cb,R,t
        hak(v.sc,k) and R.sc[k] = v.sc[k]
        # oncer
        d == '1' and delete v.sc[k]
    };
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        # ^ is somewherish. posits and deposits.
        1s&Te and me&Tie,R,'boost'
        
        !Rs&boost and return
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : 'W';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,lh:0.5,hue:$hu
            z.t += hu;
            i++;
        }
    };
    me.namup = &acgts{ 
        $nam = [s.t];
        while (s = s.y.up) {
            nam.push(s.t);
        }
        return nam.reverse();
    };
    me.Gazel = &acgtR{
        C.t == 'says' and return T.qua.sayeth = c&s
        
        Rs&boost ||= 0;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
    };
    #c Ring R-ing
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
    };
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    

    
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&acgtRs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&acgtRs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        
        $N = me[R.t](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            
            # compile instructions
            ns&ift == '1' and ns&if = 's'+n.t
            else
            ns&ift and ns&if = 's'+ns&ift; ns&ifeq = n.t;
            
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    # Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        #c walk the tape, trying to do more
        $busy = 1;
        $sheer = 45000;
        $onlyt;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                onlyt = null;
                $lowci = '';
                $ati;
                each in hc&N {
                    if (lowci == '' || ns&ci == null || lowci > ns&ci) {
                        lowci = ns&ci;
                        ati = i;
                    }
                }
                #lowci != '' and hs&iN = ati-1
                busy = 0;
                continue
            }
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            #onlyt && t != onlyt and continue
            
            hy&ov && hy&ov < ty&cv and debugger;
            
            # deciding
            $T = {};
            if (ts&if) {
                ts&if == 'RcX' and !Rc&X and T.not='if'
                else
                ts&if == 'h' and R != h and T.not='ifh'
                elsif (ts&if[0] == 's') {
                    $v = R.sc[ts&if.substr(1)];
                    !v and T.not='if'
                    ts&ifeq && v != ts&ifeq and T.not='ifeq'
                }
                else {
                    throw "if "+ts&if
                }
            }
            
            if (!T.not) {
                $packdown = [];
                if (ts&D) {
                    # doming for n
                    $g = A.ground;
                    $z = gs&z;
                    gs&z = [];
                    packdown.push(&{
                        $w = gs&z;
                        gs&z = z;
                        !w || !w.length and return
                        $M = null;
                        each in w {
                            if (nc&R) {
                                # spawn R?
                                $parent = R;
                                $s = nc&R;
                                if (s && Rc&N.indexOf(s) >= 0) {
                                    parent = s;
                                    s = null;
                                }
                                delete nc&R;
                                nc&s and s = nc&s; delete nc&s
                                ex(n.sc,n.c);
                                $r = me&Ret,parent,ex({t:n.t,s:s},n.sc);
                                parent != R and zN(r)
                            }
                            else {
                                # otherwise this mindthing grows M
                                M ||= me&Mw,R,t.t;
                                M.push(n)
                            }
                        }
                    });
                }

                $cb = tc&s;
                !hak(R.c,'s') and debugger;
                
                cb(A,Rs&C||C,G,T,R,Rc&s);
                
                packdown.map(pd=>pd())

                !Rc&nofurther and cz(R,zi)
            }
            delete T.not;
            if (T.wide) {
                Rs&widenings ||= 0;
                Rs&widenings++ > 30 and debugger;
                delete T.wide;
                busy = 1;
                continue;
            }
            Rs&ci ++;
            Ry&up.c.N == Rc&N && Ry&up.sc.ci > Rs&ci and hs&iN--
            onlyt = t;
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    
    #c autoravel
    # waltzing stringpasses, 
    
    # pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    me.Ja.Pass = &acgt{
        me&Gomp;
        
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Jazz  $s:el %ravel
        
    };
    me.Ja.happenings = &acgt{
        me&Gomp;
        
        n Plethoria  {s:<<''} %of:s
            # glampiture
            n now  s:now %fs:54
        
        
    };
    # pick an R by name, from ...
    #   io wants to know R, loadup qualities...
    me.bit = &acgtRtf{
        typeof t != 'object' and t = [t]
        !f and f = R
        f == 'h' and f = Rc&N[0]
        each in t {
            #$fz = fc&X && fc&X.x[n] && fc&X.x[n].z;
            $fz = fs&z && fs&z.filter(t => t.t == n);
            !fz and throw "problem"
            fz.length < 1 and throw "notfound"
            fz.length > 1 and throw "many"
            f = fz[0];
        }
        return f
    };
    # they think about their state,
    # become straight, become curvy
    # have things wanting to be streamed uphill
    # showing interfaces where things can come across
    me.ravel = &acgtR{ return [
        ... me&Displayingness ,
        ['She','1',&acgtRs{
            # start by checking out thy name
            Rs&to = 'cell';
            Rc&dupl = 6;
        },'if:h'],
        
        # the living bit
        ['cell','3',&acgtRs{
            Rs&rowish = 1;
            
            n st  s:~ %statebusiness,fs:7
            n t  $s:R.t e
            me&Tie,R,'sayeth',1;
            
            # ourself as a commit
            me&rollbs,R,'Cell';
            $c = Rs&Cell;
            
            if (Rs&sayeth) {
                # to commit, make HEAD other
                c.t = Rs&sayeth;
                $was = c;
                c = null;
            }
            if (was || !c) {
                c = Rs&Cell = G&Cye,[R.t,''];
                # and inherit from it
                was and cs&parent = was
            }
            
            # was given by the machine
            # what is shared to/at A.4, intro
            # the environment we use to push/pull desires
            # is the local stage, our gear projected on
            n Travel  $R:s %ball,give:T
            # learn from the future
            n Subgumption  R:Travel>Wormhole %proj
            # stream ourselves in there
            n Substraction  R:Wormhole>Travel %proj
            # be ourselves
            n Wormhole  $R:c %ball
            if (cs&parent) {
                # take things forward
                n Induction  R:Fold>Wormhole %proj
                n Fold  $R:cs&parent %ball
            }
            # but then!
            n Ovulation  R:String>Wormhole %proj,itself
            #n Bring  R:String>Wormhole %proj,vey:Lines,itself
            #n Subgumption  R:Travel>Wormhole %vey:Teing
            #n Subclassity  R:Wormhole>Ghost %vey:Going
            #n Substraction  R:Wormhole>String %vey:Lines
            n String  $R:localStorage %String,twocom
            
            # < be facty
            $b = Rc&b;
            b && bc&s != Rc&s &&
                n change  s:cscha

            # slow rolling wakeup
            # openness is travelled in
            # up into cell
            n openness  s:openness %blr:4,fs:30
        },'ift:to,D'],
        ['cell','6',&acgtRs{
            each ir Rc&N {
                !rs&ball || rs&boost and continue
                $pr = r.y.up;
                prs&z.filter(t => ts&ball).length != 1 and continue
                delete rs&rowish;
            }
        },'ift:to,D'],
        #c proj
        ['proj','21',&acgtRs{
            s = s.split('>');
            n From  $R:s[0] %get
            n To  $R:s[1] %get
            Rs&vey and delete Rs&proj
        },'ift,D'],
        # resolves name, links
        ['get','21',&acgtRs{
            $p = me&bit,R,s,'h';
            Ry&up.sc[R.t] = p;
            Rc&s = pc&s;
            return;
            s&bo = '1px solid pink';
            s&fs = 7;
            n t  $s:R.t %hs:999
            n st  $s:pc&s.t
        },'ift,D'],
        
        
        ['vey','31',&acgtRs{
            Rs&rowish = 1;
            n t  $s:R.t %hs:789
            
            $f = Rs&From;
            !f and return T.wide = 1;
            $t = Rs&To;
            $fs = fc&s;
            $ts = tc&s;
            
            # %itself is for the 
        },'ift,D'],
        ['vey','31',&acgtRs{
        },'ift,D'],
        
        # the sometimes avoidable state percolation setup
        # for the (From) - (To)
        #  start suggesting travelers to ...
        ['proj','31',&acgtRs{
            Rs&rowish = 1;
            
            $f = Rs&From;
            !f and return T.wide = 1;
            $t = Rs&To;
            $fs = fc&s;
            $ts = tc&s;
            
            n t  $s:R.t %hs:789
            
            # these want to create in the FromR:
            #  - things that don't exist there yet, as in Line decodes
            #     and maintenance of all the objects included
            #  - things that do exist there being beamed out
            if (fs&String) {
                # bring your own t/pointer
                n $ts.t  $pull:f,R
            }
            else {
                # bring everything here
                # once interacted, the fc&s is above the fold
                #  and fpc&s is the raw what you could get
                #   only the top few layers of C should clone to reflect that
                if (!isC(fs)) {
                    n strange s:fsnotC %fs:6
                    return me&sunknown,R,fs
                }
                if (!fss&z || !fss&z.length) {
                    n strange  s:no.z %fs:6
                    return 
                }
                # climb Rs
                each in fs&z {
                    !ns&ball and continue
                    n $n.t  $pull:f,R,s:n
                }
            }
            # then just the worries of fitting things together or over
        },'ift,D'],
        
        ['proj','5',&acgtRs{
            $f = Rs&From;
            !f and return T.wide = 1;
            $t = Rs&To;
            $fs = fc&s;
            $ts = tc&s;
            if (Rs&boost) {
                # push the pulls
                each ir Rs&z {
                    !rs&pull and continue
                    # that are enabled
                    rs&boost < 0 and continue
                    # if pushing String to Wormhole,
                    # t = Wormhole%ball -> Jazz ... (other)
                    # R = Ovulation%proj
                    #  r= Jazz%pull -> Jazz ...
                    # f = String%String
                    # fs&pulled = [r+]
                    #  Jazz%decode,unto:r,ball -> Jazz == rc&s
                    # then the t%ball applies it
                    !ts&ball and throw "notball"
                    ts&othering ||= [];
                    ts&othering.push(r);
                }
                delete Rs&Te.sc.boost
            }
        },'ift,D'],
        #c pull-String
        ['pull','22',&acgtRs{
            s && !ss&ball and throw "pull:ball"
            if (!s) { # ask from for it
                $p = Rs&pull;
                $pul = ps&pulled ||= [];
                pul.push(R);
            }
            n t  $s:R.t
            s&bo = '3px dotted green';
            s&br = 0.3;
            # < overall, has it pushed? 
            # < state change here/there click to show in %ball
            #     that %ball's %pushed_ball will be historic,
            #         have sc.z %fix and etc
        },'ift,D'],
        
        ['String','3',&acgtRs{
            Rs&rowish = 1;
            !Rs&pulled and return T.wide = 1
            n t  $s:R.t
            s&bo = '1px dotted green';
            s&br = 0.3;
            
            each ir Rs&pulled {
                s = localStorage[r.t];
                n $r.t  $R:s,unto:r %decode,intoa:ball
            }
        },'ift,D'],
        
        ['decode','22',&acgtRs{
            !s and ns&notfound = 1; return
            $b = Rc&b;
            Rs&string = s;
            if (b && bs&string == Rs&string) {
                me&rollbs,R,'Lines,dige,decoded';
            }
            else {
                Rs&Lines = Rs&string.split("\n");
                Rs&Lines.slice(-1)[0] == '' and Rs&Lines.pop();
                Rs&dige = dig(s);
                Rs&decoded = G&readLines,s [0];
            }
            Rc&s = Rs&decoded;
            Rs&unto and Rs&unto.c.s = R
            Rs&intoa and R.sc[Rs&intoa] = 1
            # are now %ball continued
        },'ift,D'],
        
        
        #c ball, continuing thing around thing
        ['ball','3',&acgtRs{
            Rs&rowish = 1;
            s&br = '4';
            s&bo = '0.1em dotted #543';
            
            R.t != s.t &&
                n t 1 $s:R.t %fs:13,hs:288
            
            $t =
            n t 11 $s:s.t %deco,fs:8,fix:t,mr:0.3
            
            Rs&is == 'live' and s&bo = '4px dotted #782';
            
            # aim to keep a
            each kv s.sc {
                k == 'z' and continue
                n $k  $s:v,R %fix:sc
            }
            
            if (Rs&boost < 0) {
                if (Rs&boost < -1) {
                    $pr = Ry&up;
                    !prs&ball and "up!ball"
                    $ups = prc&s;
                    #i $ups/-$s
                    upss&z = upss&z.filter(n => n != s);
                    n deleted  s:deleted %fs:6,hs:594
                    delete Rs&Te.sc.boost;
                }
                return
            }
            
            if (Rs&boost) {
                ts&e = 1;
                me&Tie,R,'sayeth',1;
                if (Rs&sayeth) {
                    tc&s = s.t = Rs&sayeth;
                    n cha  s:cha %fs:6,hs:594
                }
                n typeball  R %etype:ball
            }
            
            
            if (ss&z) {
                each in ss&z {
                    n $n.t  $s:n,R %ball
                }
            }
        },'ift,D'],
        
        # an open ball
        # < sprout usual inquisitivity/saveness?
        ['etype','3',&acgtRs{
            #s&fs = 8;
            n saying   %e,fs:8
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth) {
                $pr = Ry&up;
                !prs&ball and "up!ball"
                $ups = prc&s;
                i $ups/#$Rs&sayeth
                n made  s:made %fs:6,hs:594
            }
        },'ift,D'],
        
        # %fix c/sc patchables in R-state
        # t is coming too
        ['fix','3',&acgtRs{
            n k 1 $s:R.t %fs:11,hs:288
            
            !Rs&boost and return me&gkness,R;
            
            me&Tie,R,'sayeth',1;
            if (Rs&sayeth != null) {
                Rs&fix != 'sc' and throw "weisitu"
                $pr = Ry&up;
                $ups = prc&s;
                Rc&s = s = ups[Rs&fix][R.t] = Rs&sayeth;
            }
            if (typeof s == 'object') {
                # < just have to open it more
                n obj  s:obj %fs:12
            }
            n s 1 $s:s %e
        },'ift,D'],
        
        #c othering
        ['ball','52',&acgtRs{
            # %othering is an incoming %pull -> %ball -> Jazz
            # to give us/yonder %balls here:
            #   pushing: %pull when incoming
            #   pushed: %pull (toplevel, otherer id)
            #   pushed_ball: %ball
            me&rollbs,R,'pushed,pushed_ball';
            $sync_pushed = &Rrs{
                !Rs&ball and throw "!ball sync"
                !rs&pull and throw "sync !pull"
                !ss&ball and throw "sync !ball"
                Rs&pushed ||= [];
                Rs&pushed_ball ||= [];
                $ri = Rs&pushed.indexOf(r);
                if (ri >= 0) {
                    Rs&pushed_ball[ri] = s
                }
                else {
                    Rs&pushed.push(r);
                    Rs&pushed_ball.push(s)
                }
            };
            Rs&ush = &kv{
                $l = R.sc[k] ||= [];
                l.push(v)
            };
            
            each ir Rs&othering {
                # an incoming %pull -> %ball -> Jazz
                !rs&pull and throw "%ball,othering:%pull"
                $F = rc&s;
                !Fs&ball and throw "%pull -> %ball"
                # gets %pushed(_ball)
                sync_pushed(R,r,rc&s);
                
                $pr = ry&up;
                if (prs&itself) {
                    # this C receives %fix'd values
                    Rs&ush('pushing',r);
                }
                else {
                    # merge children into here
                    Rs&ush('pushing_z',r);
                }
                
                # apply r/*%fix to s
                #   load 
                # then watch for changes
                $D =
                n pushed   %fs:7
                D.sc.bo = '2px solid yellow';
                Dc&s = pr.t+'/'+r.t;
                #n rolling  $s:ki(n,3) &hs:857
            }
            # hereload
            each ir Rs&pushing {
                ~Pulling: r.t
                $F = Rs&pushed_ball[Rs&pushed.indexOf(r)];
                !F and throw "noball"
                
                F.t != s.t and s.t = F.t
                each in Fs&z {
                    !ns&fix and continue
                    # < clone function would live on ball
                    F[ns&fix][n.t] = nc&s;
                }
                Rs&ush('pushing_z',r);
            }
            # theyload
            each ir Rs&pushing_z {
                $F = Rs&pushed_ball[Rs&pushed.indexOf(r)];
                !F and throw "noball"
                if (!Rs&pushing || Rs&pushing.indexOf(r) < 0) {
                    # not being s but inside s
                    F = {sc:{ball:1,z:[F]}};
                }
                each in Fs&z {
                    !ns&ball and continue
                    $t = Rs&z && Rs&z.filter(t => ts&ball && t.t == n.t)[0];
                    if (!t) {
                        # make C
                        $D = G&Cye,nc&s;
                        D.c = {}; D.sc = {};
                        t = me&Ret,R,{t:D.t,s:D,ball:1};
                        i $s/$D
                    }
                    sync_pushed(t,r,n);
                    ts&pushing ||= [];
                    ts&pushing.push(r);
                }
            }
        },'ift,D'],

        ['sun','3',&acgtRs{ me&Reis,R,'Cray',s; },'ift'],
        ['sunknown','3',&acgtRs{ me&Reis,R,'Cray',s; },'ift:to'],
        
        
    ] };
    [
        # sproutable new ? if low on !
        ['anet','4',&acgtRs{
            $M = me&Mw,R,'traw';
            
        },'if:sanet'],
        ['She','6',&acgtRs{
            $maybe = Rs&Mw && Rs&Mw.maybe;
            if (maybe) {
                delete Rs&Mw.maybe;
                if (!Rs&z) {
                    each in maybe {
                        $c = ex(ex({},n.c),n.sc);
                        c.t = n.t;
                        me&Ret,R,c;
                    }
                }
            }
        },'if:h'],
    ];
    me.sayeth = &acgts{
        ~Sayeth: ki(A), c&s
        T.qua.sayeth = c&s;
    };
    #c Mergibles
    
    me.Mergibles = &acgtR{ return [
        ['cell','2',&acgtRs{
        
        $got = me&enLinesR,R,s||c&s;
        $exp = me&deLinesR,R,C.t;
        $o = C;
        },'ift:to'],
            
        ['diff','3',&acgtRs{
            me&diffLines,R,got,exp;
        },'ift:to'],
        
        ['diff','2',&acgtRs{
            $M = me&Mw,R,'traw';
            m te 1 $s:R.t %fs:13,hs:288
            Rc&d == 0 &&
            m doe 1 s:Gittoo %fs:11,hs:688
            
            if (!Rs&g) {
                Rs&rowish = 1;
                Re('Here',got,'compare');
                Re('Diff','','diff');
                Re('There',exp,'compare');
            }
            elsif (Rs&g == 'sunknown') {
                Rs&rowish = 1;
                m onemore  s:sunknown
                $r = me&sunknown,R,s
            }
            elsif (Rs&g == 'compare') {
                Rs&rowish = 1;
                m dige  $s:ss&dige %hs:588
                
                ss&Lines and Re('Lines',ss&Lines,'lines');
                
                if (sc&ha) {
                    Re('Ohno',sc&ha,'sunknown');
                    m errors  s:errors? %fs:18
                    return
                }
                
                !Rs&boost and return
                Rs&Te and delete Rs&Te.sc.boost
                
                if (s == got) {
                    # push to storage
                    localStorage[expc&s] = gots&string
                }
                else {
                    # deserialise and set into live
                    $C = got.c.s.c.s;
                    $D = exps&vivify();
                    exps&vivify and ex(C,D)
                    else {
                        throw "how to read "+exp.t
                    }
                }
            }
            elsif (Rs&g == 'lines') {
                $M = me&Mw,R,'geo';
                $top = s [0];
                m top  $s:top %fs:6,hs:797
                $len = 'x'+s.length;
                m nolines  $s:len
                
                !Rs&boost and return
                Rs&rowish = 1;
                $M = me&Mw,R,'stuff';
                each in s {
                    m line  $s:n %dis,fs:6,hs:797
                }
            }
        },'ift:to'],
    ]};
    #c Ringing unknown
    me.Displayingness = &acgt{ return [
        ['Displayingness','1',&acgtRs{
            $C = Rs&C = G&Cye,[R.t,'',{}];
            if (Rc&d == 0) {
                $p = R.y.up;
                $s = p && pc&s;
                isC(s) and Rs&fornt = s.t;
            }
            Rc&inC = R;
            #Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 275;
            Rc&dl ||= 35;
        }],
        ['Displayingness','3',&acgtRs{
            # this R can be clicked big/small
            me&boostulate,R;
        }],
        ['Displayingness','7',&acgtRs{
            $d = me&Display,R;
        },'if:h'],
    ] };
    me.gkness = &acgtR{
        $M = me&Mw,R,'traw';
        
        # make block,inline have same indento
        $p = Ry&up;
        $iN = (ps&z||[]).indexOf(R) - 1;
        $f = iN >= 0 && ps&z[iN];
        f && fs&rowish and s&ml = 1
        
        s&fs = 7;
        m sym 12 not
        $pow = 2;
        Rs&boost and pow = 4;
        $string = ki(Rc&s,pow);
        if (string.length > 100) {
            string = string.substr(0,100)
              +'..'+(string.length - 100)
        }
        m ki 3 $s:string
    };
    me.Cray = &acgtRs{ return [
        ... me&Displayingness ,
        ['She','3',&acgtRs{
            $h = Rc&N[0];
            $p = Ry&up;

            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                me&gkness,R;
                return
            }
            
            #    $M = me&Mw,R,'traw';
            #m things  s:Crays %fs:20

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });

            if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        }],
    ] };
    #c R-ing, collecting rays, bouncing across matter
    # diving gear, has a middle you can steer it from
    # like ind but leaving Rs, looking at the points across it
    # A becomes the looking
    # runs once, then you compare your copies of it...
    # can only travel one property at a time, d.k
    # < path as a function climbing d.up
    # 
    me.ing = &acgtsR{
        $cb;
        typeof R == 'function' and cb = R; R = null
        R ||= {t:'ing',y:{},c:{s:s,N:[]},sc:{}};
        cb and Rc&middle = cb;
        $s = Rc&s;
        
        # limits want workarounds
        $limit = &s{ me&Rec,R,s };
        
        # dedupe/limit objects already in this pool
        !Rc&refs and Rc&refs = []; Rc&refR = [];
        $ri = Rc&refs.indexOf(s);
        if (ri < 0 || typeof s != 'object') {
            ri = Rc&refs.push(s) - 1;
            Rc&refR ||= {};
            Rc&refR[ri] ||= [];
            Rc&refR[ri].push(R);
        }
        else {
            $h = Rc&N[0];
            # see the per-ref R table
            $RN = Rc&refR[ri];
            Rs&refR = RN;
            $dupl = Rc&dupl || 0;
            each in RN {
                if (nc&N == Rc&N && !dupl--) {
                    limit('dup');
                    Rc&nofurther = 1;
                    break;
                }
            }
            # a different 
            !Rc&nofurther and limit('dub')
            # < to know circular links, converge
        }
        # sprawl limits
        Rc&dl && Rc&dl < Rc&d and return limit('dl')
        Rc&nl && Rc&N && Rc&nl < Rc&N.length and return limit('nl')
        Rc&N ||= [];
        
        # make a callback
        Rc&middle ||= A&middle;
        !Rc&middle and throw "nocb"
        # that emits more R
        
        # 6 framing
        Rc&middle(Rc&s,R);
        
        R.c.not and return
        
        # accepted into the list of atoms
        # < out of order mode
        # < place more carefully under Ryup and its z
        Rc&N.push(R);
        
        Rc&nofurther || !Rs&z and return
        
        # middle gives more options to try
        each ir Rs&z {
            r.c.not and continue
            me&ing,rc&s,r;
        }
        return R
    };
    #c Rbitology. history, ...
    # X is the space index...
    #  of X.x.$bit = X, inwards
    #     X.z = [ R nodes
    # clone for destructive history
    me.RbitXtend = &acgtV{
        V = ex({},V);
        V.z and V.z = V.z.slice()
        V.x and V.x = ex({},V.x)
        return V
    };
    me.RbitX = &acgtR{
        $bit = R.t;
        # $X = {x:{$bit:$X},z:[R+]}
        # X.x.$bit = another X, inwards a $bit
        # X.z=[R that are here
        Rc&X ||= {};
        Rc&X.x ||= {};
        $X = Rc&X = Rc&X.x[bit] ||= {};
        X.z ||= [];
        if (X.z.length) {
            # dups allowed, assumes same ordering
            if (X.z[0] == s) {
                ~duup: ki(s,3), ki(X.z[0],3)
            }
        }
        X.z.push(R);
        
        # history at te top
        Rc&V ||= {};
        Rc&V.x ||= {};
        # someone gave you V that used to be X
        $V = Rc&V.x[bit] || {};
        $b = V && V.z && V.z.shift();
        # only goners remain
        b && !V.z.length and delete Rc&V.x[bit]
        # children inherit the bit past
        # care to leave history
        Rc&V = V = V ? me&RbitXtend,V : {};
        if (b) {
            Rc&b = b;
            by&future = R;
            # no further back
            bc&b and bc&b;
        }
    };
    me.RbitXgonism = &acgtR{
        # atoms in locations, another lives
        $N = Rc&N;
        each iR N {
            $b = Rc&b;
            $s = Rc&s;
            #b && bc&s == Rc&s and throw "Crefsame may happen"
            
            $V = Rc&V;
            if (V) {
                V.z && !V.z.length and delete V.z
                each ip V.x {
                    Rs&gone ||= [];
                    Rs&gone.push(p);
                }
            }
            Rs&gone and me&chR,R,'Goners:'+ki(Rs&gone)
            !b and me&chR,R,'new!'
        }
    };
    
    #c growing R
    
    # Ret-urn what's out there, growing R
    # using Rc&emit,change to push new R into R-ing
    # s = C
    me.CaR = &acgtRs{
        # yon J, parts Aing,
        # < joins os? instead of 1s&on being the thing
        $n = s.y && s.y.A;
        if (n && n.1 != A.1) {
            Rc&nofurther = 1;
            $J = n.1;
            #!Js&on and throw "Yon J not ready: "+J.t
            Rs&J = J;
        }
        # way in
        if (ss&z) {
            each iD ss&z {
                !D and continue
                me&Ret,R,{s:D}
            }
        }
        # also y.tv, y.in, etc...
    };
    # data/anything
    me.daR = &acgtRs{
        if (typeof s == 'object') {
            each kv s {
                me&Ret,R,{t:k,s:v}
            }
        }
    };
    
    # definitions available to -od
    # < A = R about here? if Ring allows?
    # < 
    me.sc = {};
    me.sc.ha = &acgtRs{
        #S 3
        each tN s {
            # before group
            each iR N {
                # the tower
                me&Ret,R,{t:'Dupism',s:R}
            }
            # after group
        }
    };
    # of Rc&ha being R with hoistables
    
    # Rodulat pool coms
    # send message upwards
    me.Rec = &acgtRs{
        $h = Rc&N[0] || R;
        $a = hc&ha ||= {};
        $m = a[s] ||= [];
        m.push(R);
    }
    # s collects pile of reasons for Rs&cha
    # < R-centricism, layered change, to phases
    # < lossless.. for any R and any of its complains and their anyness.
    # < with an index grouper, to merge the complainso
    #   perhaps note which R have what symptoms,
    #     then the R notes which symptoms are where.
    # debuggy noise at this point...    
    me.chR = &acgtRs{
        Rs&cha = 1;
        Rs&Rch ||= [];
        Rs&Rch.push(s);
        A&chR ||= {};
        $ch = A&chR[R.t] ||= [];
        ch.push(s)
    };
    #c Realise t
    # optional previous R
    me.Resurrect = &acgttR{
        $r = R;
        R = {t:t,y:{},c:{},sc:{}};
        # doesn't ing, tapes itself
        Rc&N = [R];
        # starting into Rc&X, keeping the start in Rs&X
        Rc&X = Rs&X = {};
        # children (Re) will V = upc&bs&X || {}
        r and Rc&b = r
        # a spiral of names coming back on itself once
        r && rc&b and delete rc&b
        # children should not .y.up = I
        R.y.I = R;
        # each rc&N[0] should Ic&head[t] = [R{c&N*r}]
        return R
    };
    # grow current R
    # like G&A, but many R to an A, which (dispatch to) ... of thought
    # R.c inherits, R.y.up up/out and Rs&z down/in
    me.Ret = &acgtRc{
        $r = R;
        R = ex({},R);
        R.y = {R:R};
        R.c = ex({},R.c);
        delete Rc&s;
        delete Rc&b;
        delete Rc&ha;
        Rc&d = (Rc&d||0) + 1;
        R.sc = {};
        if (r) {
            R.y.up = r; 
            rs&z ||= [];
            rs&z.push(R);
        }
        each kv c {
            $to = k == 't' ? R : k == 's' ? R.c : R.sc;
            to[k] = v;
        }
        return R;
    };
    # name/groups new R
    # sprout node in new pool...
    # < these want to know each other,
    #   the many bits of work
    # < put waves of orders through with P
    #   such that early R can sleep, latereRs can life
    #   like the ghost is still, pure activity
    # dime flange
    me.Re = &acgtRc{
        $r = me&Ret,R,c;
        delete rc&nl;
        delete rc&dl;
        delete rc&N;
        # grasp task, eg Pond
        rs&task = r.t;
        if (Rs&z) {
            # is not a dive for the above R-ing
            Rs&z.slice(-1)[0] != r and throw "unlast"
            Rs&z.pop();
            # Reason section ...
            $I = Rc&N[0];
            I = I && I.y.I;
            if (I) {
                Ic&head ||= {};
                $hz = Ic&head[r.t] ||= [];
                # if many R:C sprout many R:Knowing in one pool
                #   if hs&joinR we ry&I but r != rc&N[0]
                $h = h && h.length == 1 && h[0];
                h && hs&joinR and rc&N = hc&N
                else { hz.push(r) }
                r.y.I = I;
            }
        }
        rc&d = 0;
        # nor its N (set)
        rc&N ||= [];
        # X - names for history
        rc&X = Rs&X ||= {};
        $b = Rc&b;
        # V - names from history
        rc&V = b && bs&X ? me&RbitXtend,bs&X : {};
        return r
    };
    
    

