Orders: | # what to
    # see Ha WebHosting
    # the Wall is the write of way
    #   shares itself
    
    =head1 todo
    
    make the bay of spot
      via 84/Glo, cluster/bay earthworks
    
      83 Lis
        see updatable
        start island (bay)
          using Co locale for ghost
            as a -pi that can mutate as ghost attaches better
     *
     * replumbing pi innards
     *
     
       use FourSleep when pi same
       
       wire up behaviours like:
        
      Matu seeing/dispatching updatables
        auto behaviour clicked on through Lis
        makes similar log of why that Lis complains about

    use for tweaking colour of something
      T elvising:
    way
    
    elvising that gives items on a contract,
        heals when remote forgets
      use for whole pile
    the 'you are understood at...' connections
    the Trips as I go understanding bits of it
    attach to the bits, become steerable...
    
    
    
    =head1 j/4          sublimits of sleepable
       
          Rw Intre as G init
              a 5s&stores = -mine+ set of gd with sc about when to use them
             giving default write locations, cachables, < fork/pushables
               a T thing.
           
          Rw FourSleep as J 45
               desire comp involving when to thaw or sleep thing
               
    
    =head1 j/5          super sense/house
    
    import/export/customs
    
      Howz, A.5
        your dialect/customs, which are options to the G

        where things get plugged in for their resource/recipe aura
        could also be the dependency collector,
          versioned holster of loaded things

        could take on every imported/exported cultural item if
          its aJenda could be split from readying ingredients
           to also placement of meals.

           5s&stores (see Rw Intre) for ingredient piles



        =head2 Motor, A.4

        Run beings/loop, behaviour actualised as J happen.

    =head1 j/51         forked being G
    
    
      51 Co
        for G/g cluster creation/personality
        
        where the G is given N, and finishes/plans
      
      51 Ge
        a J to be the G that reads the Co,
        and if master represents the set of processes,
          managing fork sources and play
          unless subnetica routes node being mess to some G-summer
      
      

    =head1 j/52          perl-process-reality abstraction
    
     shiny new telephones
          make clear how to do a:
          read:
            blocking: (Down?)
              stops anything in the process happening
            non-blocking: (Baye?)
              lets callbacks happen, Ge must return
        meta for and other ways to block a G?
        Rw GiveTime lets you run on forever
      
    
    =head1 j/53       export/save abstraction
    
    Wall, object saver/exity
    
    Elvi, to takeover from Elvis
    
    Elan should know about ips/forking
        state what W takeovers happen in the ipd so we can look up?
    
    have an elvis vent/describer...
      pointless fork culler
    
    
    
      
      
    
    =head1 j/54         J runtime state games
    
    G:Door runs G:Intrup, which implements:
    
        something over there
    
    Door then Rw decoda the -coda from Intrup,
        < adjusting sensors/lum as conjoined ghost travelling
        
    =head1 j/81        data splay
    
    < look more like a C should
    
    - froth of C makes ind or o happen
    
    < integrate to a data change test... 
        to generate and explain changes in tests,
        and show when what you were just looking at changes
    
    =head1 makin sense?
    
    sequencer?
    
    =cut
    
Beginning: | # 0 stylehouse.pl's first way
    1 && saybl "In the beginning";
    delete A.I; # only for new
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    G.c.mas = sub {
        my ($A,$C,$G,$T,$s) = @_;
        1 && saygr "Es: $s";
    } if 0;
    
    # should base all G gk here-ish
    G.c.bay = 'bay';
    G.c.tentbay = 1;
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'House';
    my $o = $A = G&A,'Motor';
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    # Motor (A) must build House without the mind House produces
    #n House
    my $n = G&A,n=>1=>A.1=>['House'];
    nc&nomind = 1;
    G&A,$n,8;
    
    # has moments
    n Motor
    
House: | # sheets of mind you want handy
    Js&loose = 1;
    Js&tby = 'byt'; # sub for further lookups, eg of=w
    
    # add u, eg WayHeave for w over/update
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        Jc&addu.>$W ++;
        T.oke = 1;
    };
    # normal is base of Normal
    # which TheU exports as of:W
    # and may have mixed 5c&plus = [W,W...] into
    # so G&t,W=>'Normal' will find:
    # before/as S, this $u with s=Steve
    # after S/as 4 etc, the Normal from TheU
    my $u = 5c&normal ||= do {
        my $laC;
        my $fiC;
        my $ii = {%{G.ii}}; # stylehouse.pl Beaches
        for my $k (sort keys %$ii) {
            my $C = $ii.>$k;
            if ($laC) {
                laC.y.next = $C;
                C.y.prev = $laC;
            }
            $fiC ||= $C;
            $laC = $C;
        }
        # < Normal pin-able so what it was becomes the base
        my $u = G&Ct,[Normal=>3=>'Steve'];
        # ylinks so it can c&base a new u
        u.y.in = $fiC;
        u.y.tw = $ii;
        u.sc.ii = $ii;
        u.sc.i.>_.t = _c&code for grep {_c&code} values %{ii.i.y.tw};
        # supposedly you would whole an s, not the top itself?
        #u.sc.top = $u;
        
        $u
    };
    
    # this is the original G.ii getting W.theu
    # while we are creating our u with it
    # u.sc.ii etc doesn't have itself
    warn "Faking Normal into an ii with W: ".ki A.ii.W if A.ii.W;
    A.ii.W.y.tw.Normal = $u;
    my $fi = A.ii;
    
    # we switched Mo to mo with PiMachine
    #   whose builder still wants to compile the u for Mo
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        G.way.>$pin = G.way.>$was;
    }
    
    # puts it as of:W, remixes it if needed
    my $c;
    # c.plus
    u TheU
    u Ang
    u $_ for sort keys %{Jc&addu||{}};
    S
    # so the G.ii no have
    delete fi.W.y.tw.Normal;
    delete fi.W if !keys %{fi.W.y.tw};
    
    1 && saygr "/House";
    
NewBeginning: | # 0 HaMachine.pl's first way
    1 && saybl "In the beginning";
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    
    # should base all G gk here-ish
    # blank/ = bay
    # Ge: = G.t=Ge
    # Ge:Lop = G.t=Lop, pin=Ge
    #   until Beginnings imply Ge all the time
    @ARGV = grep {  !(/^(\w+)\/$/ && do{Gc&bay=$1}) } @ARGV;
    G.c.bay ||= 'blank';
    #G.c.tentbay = 1;
    # G.i is A.I.i.y.tw.* directly to their .c.code
    # for calling subs inside the sub that calls subs
    G.i || die "Wants the G\.i codestash";
    A.I = delete A.ii;
    delete A.i;
    
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'Howz';
    my $o = $A = G&A,'Motor';
    
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    
    Rw CloningProcess;
    sayre "Become thingz!";
    
    die "fix: $_" for
    Rw t/o_simple;
    
    
    n Howz
    #delete G.way;
    
    # has moments
    n Motor
    
Howz: | # another House, sheets of mind you want handy
    # be a resource gateway
    Js&loose = 1;
    # h for further lookups, eg of=w
    Js&tby = 'byt';
    
    # add u, eg WayHeave for w over/update
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        5c&alsu.>$W ++;
        T.oke = 1;
    };
    
    # 5c&plus [t+] mutates Normal
    # 5c&alsu {t=>1+} puts things in 5's mind
    #  < i should mostly be on 5, speeding u comps
    
    # Normal is the implied mind everywhere
    # see Jtool/clusp
    # - waves of 'u thing' add to it for your J
    # < and everything below it?
    
    # 5c&NormalI - tw of things, A.I
    # 5c&NormalJ - s&I == 5c&NormalI
    # keeps the beginning's I
    # 5c&NormalC - s&J = 5c&NormalJ or ReNormal
    # ReNormal includes 5c&plus to NormalJ
    # to mutate everywhere
    5s&NormalI ||= A.I;
    my $j =
    5s&NormalJ ||= do {
        my $j = G&Ct,[Normal=>1];
        j.y = $j;
        j.sc.I = A.I;
        $j
    };
    if (5c&plus) {
        my $R =
        n ReNormal
        $j = Rs&J;
    }
    5s&NormalC = G&Ct,[Normal=>1=>{}=>{J=>$j}];
    
    # we switched Mo to mo with PiMachine
    #   whose builder still wants to compile the u for Mo
    # shortnames are modern
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        my $w = G&t,w=>$was;
        $w || die "Can't find 5way: $was";
        w.t = $pin;
        u $w
    }
    
    Rw Intre;
    # used by the J45 sleepwaker
    4c&way_foursleep = 'FourSleep';
    
    my $c;
    #u TheU
    u Ang
    
    # 5c&alsu: t=>1 or t=>C
    map {
        u $_
    } map { 
        ref 5c&alsu.>$_ ? 5c&alsu.>$_ : $_
    } sort keys %{5c&alsu||{}};
    S
    
    1 && saygr "/House";
    
ReNormal: |
    my $j = 5s&NormalJ || die "no5NormalJ";
    my $plus = 5c&plus || die "no5cplus";
    n Normal=>1=>{}=>{J=>$j}
    y.n = 2;
    m $_ for @$plus
TheU: | # posit our 4.ii as normal (theu), share as W
    # host
    my $u = 5c&normal;
    if (5c&plus) {
        sayre "Going reNormaling: ".ki 5c&plus;
        n Normal=>W=>{base=>$u,plus=>5c&plus};
        $u = T.op;
    }
    n Normal=>1=>{s=>$u},'%of:W'
Motor: | # be a G
    delete Gc&bay if delete G.c.tentbay;
    Gc&bay ||= 'peace';
    
    1 && sayyl "Motor: of Gc&bay: "
      .( c&e ? "e: ".ki(c&e) :
         c&to ? "to: ".ki(c&to) : "");
    
    4s&toy ||= &c,sc{
        G&elph,Motor=>W=>$c,$sc;
    };
    
    if (0) {
        # travellers adapting tape: Gc&N -> Gs&N
        ar.t = c&t if c&t;
        c&main ||= "Beer";
        Rw c&main
    }
    
    if (c&to) {
        n ref $_ eq 'ARRAY' ? @$_ : $_ for @{c&to||[]};
    }
    else {
        if (@ARGV) {
            my $t = shift @ARGV;
            my $pin = $1 || "Ge" if $t =~ s/:(\w+)?$//;
            G.t ||= $t;
            my $ext = " pin=$pin";
            argve: saybl "Read ARGV: $t$ext";
            if (my $pid = !$pin && fork()) {
                saygr "Waiting fr $pid";
                waitpid($pid,0);
                sayyl "Done! $pid on $$";
                sayre "will restart..?";
                <STDIN>;
                goto argve;
            }
            else {
                # to make your G J see bay/G/Itself
                n $pin ? ($t=>W=>{pin=>$pin,Wea=>'G'}) : $t
            }

        }
        elsif (!Gs&fishing) {
            Gs&fishing = 1;
            my $bay = Gc&bay;
            Rw BayFishing $bay WebHost;
            # over-pid never returns
            #   should be signalled to reexec stylehouse.pl
            #   have a watch loop?
            # forked workers return from work through here:

            # have Domes of stuff to osc separato
        }
    }
    
    if (4c&todo || Gc&when_done) {
        Rw MotorTime;
    }
    
    Gc&clockison ||= Gc&clockon->() || 1 if Gc&clockon;
    
    saygr "/Motor";
    # store J, no osc
    T.nose = '2';
CloningProcess: | # you keep coming out of it
    argve: # ya
    if (my $pid = fork()) {
        ar.m ||= [];
        saygr "Waiting fr $pid @{ar.m}";
        waitpid($pid,0);
        sayyl "Done! $pid on $$";
        sayre "will restart..?";
        <STDIN>;
        goto argve;
    }

