Beginning: | # 0 stylehouse.pl's first way
    1 && saybl "In the beginning";
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    G.c.mas = sub {
        my ($A,$C,$G,$T,$s) = @_;
        1 && saygr "Es: $s";
    } if 0;
    
    # should base all G gk here-ish
    G.c.bay = 'bay';
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'House';
    my $o = $A = G&A,'Motor';
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    # Motor (A) must build House without the mind House produces
    #n House
    my $n = G&A,n=>1=>A.1=>['House'];
    nc&nomind = 1;
    G&A,$n,8;
    
    # has moments
    n Motor
    
House: | # sheets of mind you want handy
    # normal is base of Normal
    # which TheU exports as of:W
    # and may have mixed 5c&plus = [W,W...] into
    # so G&t,W=>'Normal' will find:
    # before/as S, this $u with s=Steve
    # after S/as 4 etc, the Normal from TheU
    my $u = 5c&normal ||= do {
        my $laC;
        my $fiC;
        my $ii = {%{G.ii}}; # stylehouse.pl Beaches
        for my $k (sort keys %$ii) {
            my $C = $ii.>$k;
            if ($laC) {
                laC.y.next = $C;
                C.y.prev = $laC;
            }
            $fiC ||= $C;
            $laC = $C;
        }
        # < Normal pin-able so what it was becomes the base
        my $u = G&Ct,[Normal=>3=>'Steve'];
        # ylinks so it can c&base a new u
        u.y.in = $fiC;
        u.y.tw = $ii;
        u.sc.ii = $ii;
        u.sc.i.>_.t = _c&code for grep {_c&code} values %{ii.i.y.tw};
        # supposedly you would whole an s, not the top itself?
        #u.sc.top = $u;
        
        $u
    };
    
    # this is the original G.ii getting W.theu
    # while we are creating our u with it
    # u.sc.ii etc doesn't have itself
    warn "Faking Normal into an ii with W: ".ki A.ii.W if A.ii.W;
    A.ii.W.y.tw.Normal = $u;
    my $fi = A.ii;
    
    # we switched Mo to mo with PiMachine
    #   whose builder wants to compile the u for Mo
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        G.way.>$pin = G.way.>$was;
    }
    
    # puts it as of:W, remixes it if needed
    my $c;
    # c.plus
    u TheU
    u Ang
    S
    # so the G.ii no have
    delete fi.W.y.tw.Normal;
    delete fi.W if !keys %{fi.W.y.tw};
    
TheU: | # posit our 4.ii as normal (theu), share as W
    # host
    my $u = 5c&normal;
    if (5c&plus) {
        sayre "Going reNormaling: ".ki 5c&plus;
        n Normal=>W=>{base=>$u,plus=>5c&plus};
        $u = T.op;
    }
    n Normal=>1=>{s=>$u},'%of:W'
Motor: | # be a G
    sayyl "Be a G";
    
    4s&toy ||= &c,sc{
        G&elph,Motor=>W=>$c,$sc;
    };
    
    if (0) {
        # travellers adapting tape: Gc&N -> Gs&N
        ar.t = c&t if c&t;
        c&main ||= "Beer";
        Rw c&main
    }
    
    # mkoJ called by Wout, sends lines inc Ilan on Opper
    # Opper Ilan $f elvised by Ualve on Udders
    #     Ilan unifies names/routes points by elvising Win
    G.mkoJ = &Wc{
        c.holst = $W; # geoplace on desk section
        my $Y = Gc&B.sc.A;
        c.Y = $Y; # A coming from
        n NetPut=>[out=>1=>$c]
    };
    
    
    if (c&to) {
        n $_ for @{c&to||[]};
    }
    elsif (@ARGV) {
        my $t = shift @ARGV;
        argve: saybl "Read ARGV: $t";
        if (my $pid = fork()) {
            saygr "Waiting fr $pid";
            waitpid($pid,0);
            sayyl "Done! $pid on $$";
            sayre "will restart..?";
            <STDIN>;
            goto argve;
        }
        else {
            n $t
        }
        
    }
    else {
        Rw BayFishing $bay=peace;
        # over-pid never returns
        #   should be signalled to reexec stylehouse.pl
        #   have a watch loop?
        # forked workers return from work through here:
        if (G.t eq 'Opper') {
            n Opera=>V
            my $y = &Cd{ G&aC };
            my @in = G&ind:T.op,$y;
            saybl "Opera got up to: ", @in;
        }

        # have Domes of stuff to osc separato
    }
    
    Gc&clockison ||= Gc&clockon->() if Gc&clockon;
Electrica: | # not
    n PiMachine
BayFishing: | # become Op/Ud node, see 822
    my $p = $$;
    $| = 1; # autoflush output channel
    town: my $to = Rw ElvisYou;
    return sayre "< ElvisYou $p vs $$" unless $p eq $$;
    
    sleep 1;
    
    my $op;
    my $f = "$to/p/Opper";
    sayre "... $f ";
    sleep 1 until -l $f;
    $op = readlink $f;
    saygr "Waiting fr $op $f";
    waitpid($op,0);
    sayyl "Done! $op on $$";
    sayre "will restart..?";
    <STDIN>;
    goto town;
NetPut: | # see what's there, send to js
    # 
    Js&ein.t.out.sMJ = &sMJje{
        my $Y = ec&Y;
        my $z = ec&eat;
        Jc&froe = ec&froe || die "give elvis plumbing";
        my $C = @$z;
        1 && saygr "Webbing from: ".G&sn,$Y ."\n  ".ki $C;
    };
    S
Statics: | # Jig for-u, causing static u
    # 
    $M = [];
    m TheStatics
    
    n Jig=>['bay/sac'=>-Gdo=>{},{z=>$M}]
    
TheStatics: |
    n i
    n alacgts
    n a
    n alact
    n s
    n als
    n c
    n alc
    n Ang
    

