WebHost: |
    # use Mojo,
    # chew up Stylehut into bootstrappings and send
    saygr "Being a WebHost";
    use Mojolicious::Lite;
    use MIME::Base64;
    push @{app->static->paths}, '/home/s/styleshed/public';
    app->secrets(["nothing"]);
    
    #G.c.listen = readlink('listen') if -l 'listen';
    Gc&listen = '127.24.35.46:10433';
    my $s = G.c.listen || "s:10094";
    $s = "http://$s" if $s !~/^http:\/\//;
    
    

    get '/' => sub {
        my $c = shift;
        $c->reply->static("index\.html");
    };
    
    Rw Tism;
    
    websocket '/s' => sub {
        my $mojo = shift;
        sayyl "Connect!";
        die "No GWebsock yet" unless G.Websock;
        G.Websock->($mojo);
    };
    
    Gc&clockon = sub {
        saybl "Starting  G.t     listens: $s";
        app->start('daemon', '--listen' => "$s");
    };
    
    # then later within the timer...
    
    my $txm = J.txm ||= [];
    G.Websock = J.Websock ||= sub {
        my $mojo = shift;
        say "Web is socked!";
        my $s = $mojo;
        my $tx = $s->tx;
        push @$txm, $tx;
        my $addr = $tx->remote_address;
        Mojo::IOLoop->stream($tx->connection)->timeout(300000);
        $tx->max_websocket_size(512000);
        $s->on(message => sub {
            my ($M, $m) = @_;
            $m = encode_utf8($m);
            sayyl "Message from $addr ".$m;
            my $dec = eval { djson $m };
            $@ && die "Message doesnt decode: $@\n\n$m";
            
            if (my $W = dec.event.W) {
                my $db = G&db;
                $db->notify($W,decode_utf8($m));
                say "Sent ".length($m)." to $W";
            }
            else {
            
            }
        });
        $s->on(finish => sub {
            my ($M, $code, $reason) = @_;
            @$txm = grep { $_ ne $tx } @$txm;
            sayre "Gone: $addr $code $reason";
        });
        $tx->send(' clon();keon();');
        return;
        my $M = [];
        Mn(elvi=>-websock=>{s=>$mojo});
        n WebSocks => @$M
        sayyl "Socksdone";
    };
    
    G.Websen = J.Websen ||= sub {
        my $m = shift;
        $m = decode_utf8($m);
        @$txm || return sayre "No client, dropping: ".slim 50, $m;
        for my $tx (@$txm) {
            $tx->send($m)
        }
    };
    
    # how we used to message weblines to Js
    my $ya = G.onfork.Web = sub {
        my $db = G&db;
        $db->on(notification => sub {
            my ($db, $s, $pid, $m) = @_;
            $m = encode_utf8($m);
            say "$s: $m";
            J.Websen->($m);
        });
        $db->listen(G.c.in || 'Js');
    };
    #$ya->();
Tism: |
    0 && <<'';
        require Image::Magick;
        my $cand_photo = Image::Magick->new;
        #my $decoded = decode_base64($args{image_string});
        $cand_photo->read(blob=>$decoded);

        #save original
        $cand_photo->Write($f.".igk\.jpg");

        #resize
        $cand_photo->Set( Gravity => 'Center' );
        $cand_photo->Resize( geometry => '120x120' );
        $cand_photo->Extent( geometry => '120x120' );
        #save thumbnail
        $cand_photo->Write($f.".gth\.jpg");

    
    put '/tism' => sub {
        my $m = shift;
        my $c = $m->req->body;
        $c =~ s/^data:image\/jpeg;base64,//;
        my $decoded= MIME::Base64::decode_base64($c);
        
        my $h = $m->req->query_params->to_hash;
        saybl " Find: ".wdump 3, $h;
        my $run = substr($G->{id},0,4);
        my $dir = "znap";
        my $rundir = "znap/$run";
        `mkdir $rundir` unless -d $rundir;
        my $name = h.g || sprintf '%06d', $G->{tismi}++;
        my $f =  "$rundir/$name\.jpg";
        say "Go to $f four ".length $c;
        $f = "/home/s/shed/$f";
        -f $f ||
        write_file($f,{binmode=>':raw'},$decoded);
        $m->render(text => 'yup');
    };

