Orders: | # what to
    # see Ha WebHosting
    # the Wall is the write of way
    #   shares itself
    
    =head1 todo
    
    find rock and push off
    
    theory:
    name $bay, $g, $Gt as $G, so who-art specifics want to hide
        some people would call this a theoretical wrinkle
        but these meanings have to collapse on top of each other
        for the system as a G/whole to survive
    
    since $g shant matter soon, theyre patched out of lingo
    we could call $G the idea of the group of the process,
    and $g the individuals moving through time
      a pid could have more than one $g for debugging,
      all of them need to re-$g when forked
      a $g could be spread over many pids, as forks
      all of them need to wait if the spirit leaves
      they will be selected in trees of $e-ing and $g-ing
      creating a centralised, replayable log of how it went
        so every $g in the fork-path to 1.1.1.1.1.1 can be got back,
        so we can shorten the path to   1. . . .1.1
        having the first, second to last and last
        for restart, rejig and continuation
      Glan should also show when elvising completes
      and diag if G&vent
    
    j means J that is not W/A.3, so A.1 ne A.3
      it is given in Doables
    
    the dialectical jungle:
    
    81 data printer
    
    82 intelligised G urfer
      seeing namespace, finding way back to ghost
        Te goes the other way
    
    
    83 Lis
        see updatable
        < start island (bay)
          using Co locale for ghost
            as a -pi that can mutate as ghost attaches better
     
       use FourSleep when pi same
       
       wire up behaviours like:
        
      Matu seeing/dispatching updatables
        auto behaviour clicked on through Lis
        makes similar log of why that Lis complains about

    
    84 
      Text: search ghost, etc?
      Glo: cluster/bay earthworks
    
    85 AsTrow travel
      wants to 
    
    851 map/tv Juse patterns
    852 remappings, self conscious data
    
    86 Gallip, cluster livestocker
    
    87 Te
        edit $bay/T/$Gt/1, stuff to run into as you run into you ($Gt)
        makes w somewhere else,
          bending branches, pushing into action
        
        Ge/Co notices $bay/T/$Gt and subscribes to the madness
        
        builds wormholes, you inherit everything
    
    88 bits of J sleeping, the re
     which J to focus on updating
      elvis - activity
      3c&ET - bumped items/wake strategy
      W - you
      3c&TE - how it went
      
      a way to sleep depending on a W or J
        G&has about it too
        via drains -> ground, light osc incase other wants
      Matu (see above) sends something like ET as well
      they (J) want to know relations to each other
          
      
    89 cluster watch, Gallip?
    
    use for tweaking colour of something
      T elvising:
    way
    
    elvising that gives items on a contract,
        heals when remote forgets
      use for whole pile
    the 'you are understood at...' connections
    the Trips as I go understanding bits of it
    attach to the bits, become steerable...
    
    
    
    #c Stylehouse j/4          sublimits of sleepable
      4* and 8* could swap some places
       
          Rw Intre as G init
              a 5s&stores = -mine+ set of gd with sc about when to use them
             giving default write locations, cachables, < fork/pushables
               a T thing.
           
          Rw FourSleep as J 45
               desire comp involving when to thaw or sleep thing
          
    
    =head1 j/5          super sense/house
    
    import/export/customs
    
      Howz, A.5
        your dialect/customs, which are options to the G

        where things get plugged in for their resource/recipe aura
        could also be the dependency collector,
          versioned holster of loaded things

        could take on every imported/exported cultural item if
          its aJenda could be split from readying ingredients
           to also placement of meals.

           5s&stores (see Rw Intre) for ingredient piles
           5s&NormalC is where G&clusp gets you your u
             could make it search on 3s&NormalC too?
               if you "put this mind as inherited normal"

        w gets put around the place
          so we can make babblings for networks of way (pi/, fe/)
          Bab 'fe since' to 'Rw fe/since'

        =head2 Motor, A.4

        Run beings/loop, behaviour actualised as J happen.

    =head1 j/51         forked being G
    
    
      51 Co
        for G/g cluster creation/personality
        where the G is given N, and finishes/plans
          get it from 83
        
      51 Ge
        a J to be the G that reads the Co,
        and if master represents the set of processes,
          managing fork sources and play
          unless subnetica routes node being mess to some G-summer
      
      

    =head1 j/52          perl-process-reality abstraction
    
     shiny new telephones
          make clear how to do a:
          read:
            blocking: (Down?)
              stops anything in the process happening
            non-blocking: (Baye?)
              lets callbacks happen, Ge must return
        meta for and other ways to block a G?
        Rw GiveTime lets you run on forever
      
    
    =head1 j/53       export/save abstraction
    
    Wall, object saver/exity
    
    Elvi, to takeover from Elvis
    
    Elan should know about ips/forking
        state what W takeovers happen in the ipd so we can look up?
        named Glan for branching into ip knowing
        your GG wants a bit of shared memory
    
    have an elvis vent/describer...
      pointless fork culler
    
    
    
      
      
    
    =head1 j/54         J runtime state games
    
    G:Door runs G:Intrup, which implements:
    
        something over there
    
    Door then Rw decoda the -coda from Intrup,
        < adjusting sensors/lum as conjoined ghost travelling
        
    =head1 j/81        data splay
    
    < toplevel depth limiter things:
    < rotate the $M so the intlim envelope can move down the stack
    < decide to go for y, c or sc
    < hold T (applied Js&boosts) somewhere
    
    
    < look more like a C should
    
    - froth of C makes ind or o happen
    
    < integrate to a data change test... 
        to generate and explain changes in tests,
        and show when what you were just looking at changes
    
    =head1 makin sense?
    
    sequencer?
    
    =cut
    
Beginning: | # 0 stylehouse.pl's first way
    1 && saybl "In the beginning";
    delete A.I; # only for new
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    G.c.mas = sub {
        my ($A,$C,$G,$T,$s) = @_;
        1 && saygr "Es: $s";
    } if 0;
    
    # should base all G gk here-ish
    G.c.bay = 'bay';
    G.c.tentbay = 1;
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'House';
    my $o = $A = G&A,'Motor';
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    # Motor (A) must build House without the mind House produces
    #n House
    my $n = G&A,n=>1=>A.1=>['House'];
    nc&nomind = 1;
    G&A,$n,8;
    
    # has moments
    n Motor
    
House: | # sheets of mind you want handy
    Js&loose = 1;
    Js&tby = 'byt'; # sub for further lookups, eg of=w
    
    # add u, eg WayHeave for w over/update
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        Jc&addu.>$W ++;
        T.oke = 1;
    };
    # normal is base of Normal
    # which TheU exports as of:W
    # and may have mixed 5c&plus = [W,W...] into
    # so G&t,W=>'Normal' will find:
    # before/as S, this $u with s=Steve
    # after S/as 4 etc, the Normal from TheU
    my $u = 5c&normal ||= do {
        my $laC;
        my $fiC;
        my $ii = {%{G.ii}}; # stylehouse.pl Beaches
        for my $k (sort keys %$ii) {
            my $C = $ii.>$k;
            if ($laC) {
                laC.y.next = $C;
                C.y.prev = $laC;
            }
            $fiC ||= $C;
            $laC = $C;
        }
        # < Normal pin-able so what it was becomes the base
        my $u = G&Ct,[Normal=>3=>'Steve'];
        # ylinks so it can c&base a new u
        u.y.in = $fiC;
        u.y.tw = $ii;
        u.sc.ii = $ii;
        u.sc.i.>_.t = _c&code for grep {_c&code} values %{ii.i.y.tw};
        # supposedly you would whole an s, not the top itself?
        #u.sc.top = $u;
        
        $u
    };
    
    # this is the original G.ii getting W.theu
    # while we are creating our u with it
    # u.sc.ii etc doesn't have itself
    warn "Faking Normal into an ii with W: ".ki A.ii.W if A.ii.W;
    A.ii.W.y.tw.Normal = $u;
    my $fi = A.ii;
    
    # we switched Mo to mo with PiMachine
    #   whose builder still wants to compile the u for Mo
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        G.way.>$pin = G.way.>$was;
    }
    
    # puts it as of:W, remixes it if needed
    my $c;
    # c.plus
    u TheU
    u Ang
    u $_ for sort keys %{Jc&addu||{}};
    S
    # so the G.ii no have
    delete fi.W.y.tw.Normal;
    delete fi.W if !keys %{fi.W.y.tw};
    
    1 && saygr "/House";
    
NewBeginning: | # 0 HaMachine.pl's first way
    1 && saybl "In the beginning";
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    
    # should base all G gk here-ish
    # blank/ = bay
    # Ge: = G.t=Ge
    # Ge:Lop = G.t=Lop, pin=Ge
    #   until Beginnings imply Ge all the time
    @ARGV = grep {  !(/^(\w+)\/$/ && do{Gc&bay=$1}) } @ARGV;
    G.c.bay ||= 'blank';
    #G.c.tentbay = 1;
    # G.i is A.I.i.y.tw.* directly to their .c.code
    # for calling subs inside the sub that calls subs
    G.i || die "Wants the G\.i codestash";
    A.I = delete A.ii;
    delete A.i;
    
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'Howz';
    my $o = $A = G&A,'Motor';
    
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    
    Rw CloningProcess;
    sayre "Become thingz!";
    
    die "fix: $_" for
    Rw t/o_simple;
    
    
    n Howz
    #delete G.way;
    
    # has moments
    n Motor
    
Howz: | # another House, sheets of mind you want handy
    # be a resource gateway
    Js&loose = 1;
    # h for further lookups, eg of=w
    Js&tby = 'byt';
    
    # add u, eg WayHeave for w over/update
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        5c&alsu.>$W ++;
        T.oke = 1;
    };
    
    # 5c&plus [t+] mutates Normal
    # 5c&alsu {t=>1+} puts things in 5's mind
    #  < i should mostly be on 5, speeding u comps
    
    # Normal is the implied mind everywhere
    # see Jtool/clusp
    # - waves of 'u thing' add to it for your J
    # < and everything below it?
    
    # 5c&NormalI - tw of things, A.I
    # 5c&NormalJ - s&I == 5c&NormalI
    # keeps the beginning's I
    # 5c&NormalC - s&J = 5c&NormalJ or ReNormal
    # ReNormal includes 5c&plus to NormalJ
    # to mutate everywhere
    5s&NormalI ||= A.I;
    my $j =
    5s&NormalJ ||= do {
        my $j = G&Ct,[Normal=>1];
        j.y = $j;
        j.sc.I = A.I;
        $j
    };
    if (5c&plus) {
        my $R =
        n ReNormal
        $j = Rs&J;
    }
    5s&NormalC = G&Ct,[Normal=>1=>{}=>{J=>$j}];
    
    # we switched Mo to mo with PiMachine
    #   whose builder still wants to compile the u for Mo
    # shortnames are modern
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        my $w = G&t,w=>$was;
        $w || die "Can't find 5way: $was";
        w.t = $pin;
        u $w
    }
    
    Rw Intre;
    # used by the J45 sleepwaker
    4c&way_foursleep = 'FourSleep';
    
    my $c;
    #u TheU
    u Ang
    
    # 5c&alsu: t=>1 or t=>C
    map {
        u $_
    } map { 
        ref 5c&alsu.>$_ ? 5c&alsu.>$_ : $_
    } sort keys %{5c&alsu||{}};
    S
    
    1 && saygr "/House";
    
ReNormal: |
    my $j = 5s&NormalJ || die "no5NormalJ";
    my $plus = 5c&plus || die "no5cplus";
    n Normal=>1=>{}=>{J=>$j}
    y.n = 2;
    m $_ for @$plus
TheU: | # posit our 4.ii as normal (theu), share as W
    # host
    my $u = 5c&normal;
    if (5c&plus) {
        sayre "Going reNormaling: ".ki 5c&plus;
        n Normal=>W=>{base=>$u,plus=>5c&plus};
        $u = T.op;
    }
    n Normal=>1=>{s=>$u},'%of:W'
Motor: | # be a G
    delete Gc&bay if delete G.c.tentbay;
    Gc&bay ||= 'peace';
    
    Gc&ipd &&
        Rw linkrement Motoring;
    1 && sayyl "Motor: of Gc&bay: "
      .( c&e ? "e: ".ki(c&e) :
         c&to ? "to: ".ki(c&to) : "");
    
    4s&toy ||= &c,sc{
        G&elph,Motor=>W=>$c,$sc;
    };
    
    if (0) {
        # travellers adapting tape: Gc&N -> Gs&N
        ar.t = c&t if c&t;
        c&main ||= "Beer";
        Rw c&main
    }
    
    if (c&to) {
        n ref $_ eq 'ARRAY' ? @$_ : $_ for @{c&to||[]};
    }
    else {
        if (@ARGV) {
            my $t = shift @ARGV;
            my $pin = $1 || "Ge" if $t =~ s/:(\w+)?$//;
            G.t ||= $t;
            my $ext = " pin=$pin";
            argve: saybl "Read ARGV: $t$ext";
            if (my $pid = !$pin && fork()) {
                saygr "Waiting fr $pid";
                waitpid($pid,0);
                sayyl "Done! $pid on $$";
                sayre "will restart..?";
                <STDIN>;
                goto argve;
            }
            else {
                # to make your G J see bay/G/Itself
                n $pin ? ($t=>W=>{pin=>$pin,Wea=>'G'}) : $t
            }

        }
        elsif (!Gs&fishing) {
            Gs&fishing = 1;
            my $bay = Gc&bay;
            Rw BayFishing $bay WebHost;
            # over-pid never returns
            #   should be signalled to reexec stylehouse.pl
            #   have a watch loop?
            # forked workers return from work through here:

            # have Domes of stuff to osc separato
        }
    }
    
    if (4c&todo || Gc&when_done) {
        Rw MotorTime;
    }
    
    Gc&clockison ||= Gc&clockon->() || 1 if Gc&clockon;
    
    saygr "/Motor";
    # store J, no osc
    T.nose = '2';
CloningProcess: | # you keep coming out of it
    argve: # ya
    if (my $pid = fork()) {
        ar.m ||= [];
        saygr "Waiting fr $pid @{ar.m}";
        waitpid($pid,0);
        sayyl "Done! $pid on $$";
        sayre "will restart..?";
        <STDIN>;
        goto argve;
    }

