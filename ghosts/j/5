Beginning: | # 0 stylehouse.pl's first way
    1 && saybl "In the beginning";
    delete A.I; # only for new
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    G.c.mas = sub {
        my ($A,$C,$G,$T,$s) = @_;
        1 && saygr "Es: $s";
    } if 0;
    
    # should base all G gk here-ish
    G.c.bay = 'bay';
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'House';
    my $o = $A = G&A,'Motor';
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    # Motor (A) must build House without the mind House produces
    #n House
    my $n = G&A,n=>1=>A.1=>['House'];
    nc&nomind = 1;
    G&A,$n,8;
    
    # has moments
    n Motor
    

House: | # sheets of mind you want handy
    Js&loose = 1;
    Js&tby = 'byt'; # sub for further lookups, eg of=w
    
    # add u, eg WayHeave for w over/update
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        Jc&addu.>$W ++;
        T.oke = 1;
    };
    # normal is base of Normal
    # which TheU exports as of:W
    # and may have mixed 5c&plus = [W,W...] into
    # so G&t,W=>'Normal' will find:
    # before/as S, this $u with s=Steve
    # after S/as 4 etc, the Normal from TheU
    my $u = 5c&normal ||= do {
        my $laC;
        my $fiC;
        my $ii = {%{G.ii}}; # stylehouse.pl Beaches
        for my $k (sort keys %$ii) {
            my $C = $ii.>$k;
            if ($laC) {
                laC.y.next = $C;
                C.y.prev = $laC;
            }
            $fiC ||= $C;
            $laC = $C;
        }
        # < Normal pin-able so what it was becomes the base
        my $u = G&Ct,[Normal=>3=>'Steve'];
        # ylinks so it can c&base a new u
        u.y.in = $fiC;
        u.y.tw = $ii;
        u.sc.ii = $ii;
        u.sc.i.>_.t = _c&code for grep {_c&code} values %{ii.i.y.tw};
        # supposedly you would whole an s, not the top itself?
        #u.sc.top = $u;
        
        $u
    };
    
    # this is the original G.ii getting W.theu
    # while we are creating our u with it
    # u.sc.ii etc doesn't have itself
    warn "Faking Normal into an ii with W: ".ki A.ii.W if A.ii.W;
    A.ii.W.y.tw.Normal = $u;
    my $fi = A.ii;
    
    # we switched Mo to mo with PiMachine
    #   whose builder still wants to compile the u for Mo
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        G.way.>$pin = G.way.>$was;
    }
    
    # puts it as of:W, remixes it if needed
    my $c;
    # c.plus
    u TheU
    u Ang
    u $_ for sort keys %{Jc&addu||{}};
    S
    # so the G.ii no have
    delete fi.W.y.tw.Normal;
    delete fi.W if !keys %{fi.W.y.tw};
    
    1 && saygr "/House";
    
NewBeginning: | # 0 HaMachine.pl's first way
    1 && saybl "In the beginning";
    { # test I
        my $t = G&t,i=>'t';
        $t && ts&args eq 'A,C,G,T,s,t,c' || die "t t fail: ".ki$t;
    }
    # stacktrace
    Rw Bangular;
    
    # should base all G gk here-ish
    G.c.bay = 'bay';
    # G.i is A.I.i.y.tw.* directly to their .c.code
    # for calling subs inside the sub that calls subs
    G.i || die "Wants the G\.i codestash";
    A.I = delete A.ii;
    delete A.i;
    
    # these are really J, the particle, an A put somewhere
    my $i = $A = G&A,'Howz';
    my $o = $A = G&A,'Motor';
    
    # coming from each other
    i.1 = i.3 = i.5 = o.5 = o.2 = $i;
    o.1 = o.3 = o.4 = i.4 = i.2 = $o;
    my $one = 0.1;
    4s&Jtv.>_.t.>$one = $_ for $i,$o;
    
    
    
    Rw CloningProcess;
    sayre "Become thingz!";
    
    die "fix: $_" for
    Rw t/o_simple;
    
    n Howz
    #A.V = 2;
    sayyl "Ang";
    #my $C =
    #n TheFirst
    sayre "Here";
    
    
    
    # has moments
    n Motor
    
Howz: | # another House, sheets of mind you want handy, resource gateway
    Js&loose = 1;
    Js&tby = 'byt'; # h for further lookups, eg of=w
    
    # add u, eg WayHeave for w over/update
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        Jc&addu.>$W ++;
        T.oke = 1;
    };
    
    # Normal is the implied mind of the valleys
    # see Jtool
    # - waves of 'u thing' add to it for your valley
    
    # < TheU changes it everywhere, on 5
    #   puts it as of:W, seen as W=Normal
    #   having mixed 5c&plus = [W,W...] into it
    #   < remixes it if needed (versioning)
    
    #u TheU
    
    # also available as:
    # 5s&NormalI - tw of things, A.I
    # 5s&NormalC - C.c.W=Normal, sc.J.sc.I == NormalI
    #   for placing before additions in u, I swoms via J
    
    5s&NormalI = A.I;
    my $j = G&Ct,[Normal=>1];
    j.y = $j;
    j.sc.I = A.I;
    5s&NormalC = G&Ct,[Normal=>1=>{}=>{J=>$j}];
    
    # we switched Mo to mo with PiMachine
    #   whose builder still wants to compile the u for Mo
    # shortnames are modern
    my $x = {qw'c alc  s als  a alact  i alacgts'};
    each pin,was $x {
        my $w = G&t,w=>$was;
        $w || die "Can't find 5way: $was";
        w.t = $pin;
        u $w
    }
    
    my $c;
    # c.plus
    #u TheU
    u Ang
    
    u $_ for sort keys %{Jc&addu||{}};
    S
    
    1 && saygr "/House";
    
TheU: | # posit our 4.ii as normal (theu), share as W
    # host
    my $u = 5c&normal;
    if (5c&plus) {
        sayre "Going reNormaling: ".ki 5c&plus;
        n Normal=>W=>{base=>$u,plus=>5c&plus};
        $u = T.op;
    }
    n Normal=>1=>{s=>$u},'%of:W'
Motor: | # be a G
    sayyl "Motor:";
    
    4s&toy ||= &c,sc{
        G&elph,Motor=>W=>$c,$sc;
    };
    
    if (0) {
        # travellers adapting tape: Gc&N -> Gs&N
        ar.t = c&t if c&t;
        c&main ||= "Beer";
        Rw c&main
    }
    
    Gc&bay = 'peace';
    @ARGV = grep {  !(/^(\w+)\/$/ && do{Gc&bay=$1}) } @ARGV;
    
    if (c&to) {
        n $_ for @{c&to||[]};
    }
    elsif (@ARGV) {
        my $t = shift @ARGV;
        argve: saybl "Read ARGV: $t";
        if (my $pid = fork()) {
            saygr "Waiting fr $pid";
            waitpid($pid,0);
            sayyl "Done! $pid on $$";
            sayre "will restart..?";
            <STDIN>;
            goto argve;
        }
        else {
            n $t
        }
        
    }
    elsif (!Gs&fishing) {
        Gs&fishing = 1;
        Rw BayFishing $bay:Gc&bay WebHost;
        # over-pid never returns
        #   should be signalled to reexec stylehouse.pl
        #   have a watch loop?
        # forked workers return from work through here:
        if (G.t eq 'Opper') {
            n Opera=>V
            my $y = &Cd{ G&aC };
            my @in = G&ind:T.op,$y;
            saybl "Opera got up to: ", @in;
        }

        # have Domes of stuff to osc separato
    }
    else {
        sayre "Nothing to do? ".G&sn;
    }
    
    saygr "/Motor";
    Gc&clockison ||= Gc&clockon->() || 1 if Gc&clockon;
CloningProcess: | # you keep coming out of it
    argve: # ya
    if (my $pid = fork()) {
        ar.m ||= [];
        saygr "Waiting fr $pid @{ar.m}";
        waitpid($pid,0);
        sayyl "Done! $pid on $$";
        sayre "will restart..?";
        <STDIN>;
        goto argve;
    }

