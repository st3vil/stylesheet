not: | # do everything! (run as Spec)
    Jc&tape = 1;
    Jc&save = 1;
    A.6.t = A.7.t;
    
    Rw Tiot;
    # the sprawldy
    
    my $d = Rw ReadMe;
    !ds&pid || ds&pid eq $$ || sayre("Giving over to ds&pid") && exit;
    y.at.pid = $$;
    
    # to collect via T.has:
    Js&servetime = [];
    
    my $def = 
    n blank=>-Trooms
    
    Rw GiveTime;
    my $ti;
    $ti = Js&ti = &{ $ti eq Js&ti && 4s&toy ->({to=>[[C.t]]}) };
    G&timer:3.2,$ti;
    
    
    #n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
Plael: | # test el function
    y.at.ellog = 1;
    
    my $l =
    n giveth=>-od=>[[1,2,3],[3,4,(Js&bowls + 5)]]
    Js&bowls > 2 &&# sleep(2) &&
    n again=>2=>{},{J=>ls&J}
    
    Js&bowls++ if Js&bowls < 3;
    
    return;
    
    #y.at.ellog = 1;
    $M = _s&z = [] for
    n the=>3=>"Expe"
    m sev=>3=>"Fo"
    m eral=>6=>"Five"
    my @l = (('x') x Js&bowls++);
    n bo=>-bowling_5=>[neg=>@l,a=>trope=>5]
    0 &&
    n see=>'8'.Js&bowls=><<'','e'
        //console.log(A.on);
    my $t = T.op;
    $t = t.y.s;
    $t = ts&lv;
    #$t = $t->[-1];
    my $s = G&Ct:[s=>{}=>{s=>$t}];
    Js&bowls > 5 &&
        G&give,Suck=>$s;
    
Suck: | # diag, 
    y.at.ellog = 9;
    Rw Tiot;
    Rw Elationist;
    S
    n from=>o1=>"From: ".G&sn,Jc&from ,'dis,hs:874'
    n suction=>-od=>{s=>Jc&es||"blank"};
    # and turn back into line-per-time host
    G&timer:0.1,&{ 4s&toy->({to=>['Udder']}) }
Bal: | # G up in a GG
    # from Udder, assume T position
    die "Cosume: ".ki $C;
pi/bowling: |
    Jc&save = 'W';
    m teh=>''=>$_,'ma:0.2' for @$s;
pi/Trooms: |
    Jc&save = 'W';
    # C Trooms, instead of single items everywhere:
    
    n panics=>-clust=>{s=>$s,mode=>'err'}
    
    # get written on
    n gravities=>-GG_2=>{s=>$s}
    
    # put forward
    #n travels=>-T
pi/GG: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    s&is = 'directory';
    y.at.dos = 'Clustout';
    
    my $eh = hitime();
    
    n see=>-listle_1=>$s,'qz'
    m _.t=>''=>{s=>_.t,fils=>$_},'dos:looking,ma:0.2' for G&op,'pi:fils';
    # ^ others, refind selves v
    n vokate=>-lookins_02
    
    #m _.t=>-GGo=>{s=>$C}
    y.u = 4;
    Js&Fur &&
    n Fur=>-od_8=>{s=>Js&Fur}
pi/lookins: | # source of intent, remembers stuff about names
    y.res = 100; # reassign m cv
    y.at.ellog = 1;
    Jc&save = 1;
    
    # uses last save
    my $d = Rw ReadMe;
    # and applies change to it
    my $c = delete 3s&change;
    
    $c && sayyl "HAve change: ",G&ind,$c,'aC';
    
    # tree of knowing joined by tree of change
    my $pos;$pos = &Ddctp{
        # t path
        $p = [@{$p||[]}];
        push @$p, $t;
        
        # descent suggested by d or c
        my $tw = {};
        my $d = d.y.tw.>$t;
        if ($d) {
            # what it was
            G&oh,D.sc,d.sc;
            delete Ds&z; # to be refilled
            $tw.>$_++ for keys %{d.y.tw||{}};
        }
        my $c = c.y.tw.>$t;
        if ($c) {
            # how its changing
            # < delete somehow
            1 && saygr G&sn ." Posits change to @$p: ".ki $c;
            G&hoh,D.sc,c.sc;
            $tw.>$_++ for keys %{c.y.tw||{}};
        }
        for my $t (sort keys %$tw) {
            my $z = G&Ct,[$t=>''=>{}=>{}];
            $pos->($z,$d,$c,$t,$p);
            push @{Ds&z||=[]}, $z;
        }
    };
    
    # sync selves in up's $M
    if (ref $s ne 'ARRAY') {
        my $u = 2s&root;
        my $N = uc&M || die "no upM";
        my $tw = {};
        # makes selves of all others
        m _.t=>{MC=>$_} for
            grep { $tw.>_.t = 1 }
            grep { _s&dos eq 'looking' }
            @$N;
        # goners maintain selves
        m _.t=>'' for
            grep { !$tw.>_.t }
            @{ds&z};
        # bake in
        for my $C (@$M) {
            $pos->($C,$d,$c,C.t);
            if (my $m = C.y.MC) {
                if (!defined s&lum) {
                    # new
                    ms&sep = 0.8;
                    mc&s .= "!";
                }
            }
            else {
                # add vague other for goner
                my $M = $N;
                C.y.MC =
                m C.t=>''=>{s=>"C.t?"},'dos:looking,fs:7,hs:844'
            }
            if (my $m = C.y.MC) {
                # first one will dos:looking but not -looking,
                #   the self will not be in c&s
                m.y.self = $C;
                # once those dos:lookings attract light,
                # append their -looking to up's $M
                if (s&lum > 1) {
                    my $M = $N;
                    m C.t=>-looking=>{s=>$C}
                }
            }
            C.y = {};
        }
    }
    # goner spec selves to start others...
    else {
        for my $t (@$s) {
            my $D = G&Ct,[$t=>''=>{}=>{}];
            $pos->($D,$d,$c,$t);
            if (Ds&z) {
                my $ub = &C{ G&aC };
                my @le = G&ind,$D,$ub;
                1 && sayyl "HAve depth: ",@le;
            }
            m D.t, '', D.c, D.sc
        }
    }
    
    
    # resurp $d scs into ^
    
    
Fur: | # thing further and not
    return delete js&Fur if us&S;
    js&Fur = $c;
pi/GGo: | # identify your bits
    n t=>1=>C.t=>'fs:12,hs:488,dis'
    my $y = &C{ G&aC };
    my @l = G&ind:$s,$y;
    n s=>6=>wdump(\@l)
pi/gust: | # a look at a G
    # 

