not: | # do everything! (run as Spec)
    Jc&tape = 1;
    Jc&save = 1;
    A.6.t = A.7.t;
    
    Rw Tiot;
    # the sprawldy
    
    my $d = Rw ReadMe;
    !ds&pid || ds&pid eq $$ || sayre("Giving over to ds&pid") && exit;
    y.at.pid = $$;
    
    # to collect via T.has:
    Js&servetime = [];
    
    # to hang the sources of T rooms:
    my $def = 
    n hang=>-Trooms
    
    Rw GiveTime;
    my $ti;
    $ti = Js&ti = &{ $ti eq Js&ti && 4s&toy ->({to=>[[C.t]]}) };
    G&timer:3,$ti;
    
    
    #n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
Lst: | # gives your $M files from ls -1ct, sleeps using your past
    # return bigger and bigger looks at the list
    my $laC;
    my $list = &i{
        my $C = G&Ct,[C.t=>''=>{s=>$s}];
        s&iterat = $i;
        c&lim = 8 * $i;
        my $N = Rw Exer;
        $laC = $C;
        $C
    };
    
    # en-2 each file
    my $form = &C{
        (s&size,s&mtime) = (stat c&s)[7,9];
        s&link = readlink c&s if -l c&s;
        s&dir = 1 if -d c&s;
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = Rw ReadMe;
    
    # osc changing atom loads contents
    push @$M,
        Rw Modulim $s $d $list $form;
    
    $laC
ReadMe: | # the J you're in remembers itself
    # having created a place for it to land
    my $s = ''; # TODO osc channel, api here too Jeneral
    my $f = Rw Locate $read=1 $t=0 $s=0;
    $f || saybl("Nothing to read A.1.t from A.6.t / A.7.t") && return;
    1c&read_from = $f;
    #saybl "Read located: $f";
    my $head = "$f/1";
    my $d = 1s&Read.>$head ||= {};
    my $m = (stat $head)[9];
    if (ds&meta.mtime eq $m) {
        # sleep J?
    }
    else {
        -f $head || die "Read no $head";
        $d = Rw Beach $s=0 $f:head;
        ($d) = @$d;
        ds&meta.mtime = $m;
        1s&Read.>$f = $d;
    }
    return $d

Modulim: | # loadup M news from an ls or so
    # stop when old news found
    my $piit = 'fils';
    my $done;
    my $list_done;
    my $seen; # C.t
    my $seens; # c&s
    my @l;
    my $page = 1;
    my $M = [];
    # whether to read into the rest of the page
    # once something same has been found
    my $keen; 
    # if the lines go directory:\nfile\nfile\nfile
    # must see a whole directory of unchanged
    # - changes bump the directory but may then 
    #     have unchanged stuff before more changes
    # < keep going a page or so after stillness
    #   $done > 10 helps too
    my $con;
    until (($done > 10) && (!$keen || !@l)) {
        if (!@l && !($done > 10)) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            1 && saygr "Ess: ", map {G&aC,$_ } @{s&z};
            @l = grep { !$seen.>_.t } @{s&z};
            @l || last;
        }
        my $s = shift @l;
        length sc&s || die "Isnt ".ki $s;
        
        # form this one line
        my $C;
        if (ar.form) {
            $C = $s;
            ar.form->($C);
        }
        elsif (ar.forms) {
            my @C = ar.forms->(sc&s);
            $C = G&Ct,\@C;
        }
        
        $con = [] if s&container;
        
        s&pi = $piit if $piit;
        my $c = d.y.tw.>C.t;
        
        my $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            $con && push @$con, $C;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        elsif (!$con || !@$con) {
            sayyl "Done upon C.t";
            $done++;
        }
        $seen.>C.t = 1;
        push @$M, $C;
    }
    for my $C (@{ds&z}) {
        next if $piit && $piit ne C.sc.pi;
        next if $seen.>C.t;
        next if !-e c&s;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
GiveTime: | # release from reading input
    Gc&clockon = sub {
        1 && saybl "GiveTime: G.t";
        # turns Udder read loop into Baye read loop
        Gc&freetime = 1;
        n Baye
        Mojo::IOLoop->is_running || Mojo::IOLoop->start;
    };
pi/Trooms: |
    Jc&save = 'W';
    # C Trooms, instead of single items everywhere:
    n blank=>-clust=>'blank'
    
pi/clust: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    
    my $s = "$s/p{,/*}";
    my $l = Rw Lst + $s;
    n ind=>o3=>"Yon ls&dir have ls&iterat to ".@$M
    my $m = [@$M];
    #@$M = ();
    my $s = join("\n", map {G&aC,$_ }@$M);
    #saygr "Ess: $s";
    n disop=>''=>$s,'fs:7,dis'
    y.n = 3;
    
    
    
pi/gust: | # see G
    # 
Exer: | # find bits for the show
    c&s =~ s/\/$//;
    c&s =~ s/\/\//\//g;
    c&do ||= 'l'; # or find
    if (c&do eq 'l') {
        c&do = 'ls -1ct';
        c&nostderr = 1;
    }
    c&cmd = c&nostderr ? qq[bash -c "c&do c&s 2>/dev/null"]
        : "c&do c&s";
    
    # search for string
    c&cmd .= "| grep c&grep" if c&grep;
    
    # maybe, with timer to kill?
    #J.mo.J.sizeup = split"\n",''.`c&cmd` if c&sizeup;
    
    c&lim ||= 20 unless c&unl;
    # skip in
    c&cmd .= "| tail --lines=+".(c&se) if c&se ;
    # skip out
    #   further to tell if theres more,
    #    have enough after image filtering?
    c&cmd .= "| head -n ".(c&lim + 4) if c&lim;
    
    # do it
    my @img = split"\n",''.`c&cmd`;
    1 && say "EXE: c&cmd: ".@img." Last: $img[-1]";
    
    my $N = [map { {c=>{s=>$_}} } @img];
    # the directory all are within,
    #   would be the c&s up to {,} or *
    my ($know) = $1 if c&s =~ /^([^\{\*]+)(\/.*?|$|.+?)/;
    $know ||= c&s;
    my $l; # last titled directory bunch, for ls -1ct
    # upgrade all to full path c&s
    my $blanks;
    for my $C (@$N) {
        if (!length c&s) {
            C.sc.not = 1;
            $blanks++;
            undef $l;
            next;
        }
        if (c&s =~ /^($know.*)\/?:$/ && -d $1) {
            $l = $C;
            c&s = $1;
            s&container = 1;
        }
        else {
            next if c&s =~ /^\Q$know\E/; # is full path
            if ($l) {
                -e "lc&s/c&s" || die "($know) expected c&s to be in lc&s!";
                c&s = "lc&s/c&s";
            }
            else {
                -e "$know/c&s" || die "expected c&s to be in $know!";
                c&s = "$know/c&s";
            }
        }
    }
    # split $know off c&s to get C.t
    @$N = grep {
        _.t = $1 if _c&s =~ /^\Q$know\E\/?(.+)$/;
        unless (defined _.t) {
            if (_c&s eq $know && _s&container) {
                _.t = ''; # hmm
                sayyl "Gets blank from $know: ".ki $_
            }
            else {
                die "Not in $know: ".ki $_;
            }
        }
        1
    } grep {
        !_.sc.not
    } @$N;
    
    
    
    
    if (c&only eq 'images') {
        @$N = grep {
            _.t =~ /^[\/\w\[\]\{\}\(\)!@%-]+\.jpe?g$/i
        } @$N
    }
    
    # reunlimit until lim is full of satis ^
    if (c&lim && c&lim < @$N) {
        sayre "Returned c&lim < ".($blanks + @$N)." rows, keep reading...";
        #@$N = @{$N}[0..(c&lim-1)]
    }
    elsif (c&lim > @$N + $blanks) {
        sayre "Done! c&s since c&lim vs ".($blanks + @$N);
        s&done = 1
    }
    #_.y.cv ||= 9 for @$N;
    s&dir = $know;
    s&z = $N

