not: | # do everything! (run as Spec)
    Jc&tape = 1;
    Jc&save = 1;
    A.6.t = A.7.t;
    
    Rw Tiot;
    # the sprawldy
    
    my $d = Rw ReadMe;
    !ds&pid || ds&pid eq $$ || sayre("Giving over to ds&pid") && exit;
    y.at.pid = $$;
    
    # to collect via T.has:
    Js&servetime = [];
    
    if (0) {
    # to hang the sources of T rooms:
    Js&Bo ||= [
        [1,3],
        [1,6],
        [1,5],
    ];
    
    my $s = shift @{Js&Bo};
    n bowling=>-bowling=>{s=>$s||[]}
    my @l = G&op;
    
    m "see _.t"=>-od=>{s=>G&aC,_.y.A.c.diff } for @l;
    }
    my $def = 
    n hang=>-Trooms
    
    Rw GiveTime;
    my $ti;
    $ti = Js&ti = &{ $ti eq Js&ti && 4s&toy ->({to=>[[C.t]]}) };
    G&timer:6,$ti;
    
    
    #n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
pi/bowling: |
    1s&sayo = 1;
    m teh=>''=>$_ for @$s;
pi/Trooms: |
    Jc&save = 'W';
    # C Trooms, instead of single items everywhere:
    n blank=>-clust=>'blank'
    
pi/clust: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    
    n "s/p"=>-listle_1=>"$s/p{,/*}",'qz'
    my $dir = T.op.sc.dir;
    my $N = [ G&op,'pi:fils' ];
    
    my $eh = hitime();
    
    # to pi chewing list edge-blur:
    # basically receive $N or previous $M stuff
    # and chew, output $M stuff
    #   cv = 1 for sort of $M
    #   cv = '' to keep as $M is
    #   cv = cv to keep cvs
    
    #Rw pi/linkle $N;
    n linked=>-linkle_2=>{},'qz'
    
    #Rw pi/groule $N;
    n grouped=>-groule_3=>{},'qz'
    
    n piled=>-pilele_4
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;

    
    my @l = G&op,'pi:fils' ;
    my $s = $l[5];
    n fromi=>3=>"From $dir, $delta",'dis'
    
    
    #n tho=>''=>{s=>ki $s },dis
    n thing=>-od=>{s=>$s},dis
    
    ($s) = grep {_.t eq 'Spec/out'} @l;
    my $z = s.y.A;
    $z = zc&diff;
    n thingee=>-od_8=>{s=>zs&neg },dis
    
    
pi/pilele: | # pile filenames
    # FactorEase top
    # and list chewing pi that know how to be Rw
    my $N = ar.N || c&N || do {
        my $t = T.op = ref $s ? ss&J.sc.top || die "Notop" : T.oT.op;
        [ G&op,'pi:fils' ];
    };
    # assuming they're in order
    for my $C (@$N) {
        C.t = s&unit if s&unit;
        delete c&s;
        my $etc;
        if (C.y.C) { # follow back to -listle o
            my $S = $C;
            my @e;
            while (S.y.C) {
                $S = S.y.C;
                push @e, $S;
            }
            # the one in o after the first mo
            my $i = $e[-1];
            $S = $e[-2];
            $S = S.y.A;
            S.t eq 'o' || die join"\n", "Didn't find last o along: ",
              map { "--- _.t: ".G&aC,_.y.A } @e;
            
            my $d = Sc&diff || {};
            
            my @o = $S;
            while (Sc&last) {
                $S = Sc&last;
                push @o, $S;
            }
            
            if (ds&allnew) {
                $etc = '*';
            }
            elsif (my $n = ds&neg) {
                each nk,gk,v $n {
                    $etc .= "$nk $gk (".ki($v).") ";
                }}
            }
        }
        c&s = "C.t".($etc && ": $etc");
        s&ml = s&ind * 2 if s&ind;
        s&dis = 1;
    }
    
    my $M = ar.M || [];
    ar.N || do {
        @$M = @$N;
        delete _.y.cv for @$M;
    }
    
    
pi/groule: | # pile filenames
    # FactorEase top
    # and list chewing pi that know how to be Rw
    my $N = ar.N || do {
        my $t = T.op = ref $s ? ss&J.sc.top || die "Notop" : T.oT.op;
        [ G&op,'pi:fils' ];
    };
    my @p = ();
    for my $C (@$N) {
        my @b = split '/', C.t;
        my $i = 0;
        for my $et (@b) {
            my $c = $p[$i]; # last insider
            if (c.t && C.t =~ /^c.t\/(.+)$/) {
                s&inside = $c;
                s&ind = $i+1;
                s&unit = $1;
                #saygr "c.t has C.t";
            }
            else {
                pop @p while @p > $i;
                $p[$i] = $C;
            }
            $i++;
        }
    }
    
    
    
    my $M = ar.M || [];
    ar.N || do {
        @$M = @$N;
        _.y.cv = 1 for @$M;
    }
    
pi/linkle: | # dedupe linked names
    # FactorEase top
    # and list chewing pi that know how to be Rw
    my $tw;
    my $N = ar.N || do {
        my $t = T.op = ref $s ? ss&J.sc.top || die "Notop" : T.oT.op;
        $tw = t.y.tw;
        [ G&op,'pi:fils' ];
    };
    $tw ||= {map{_.t=>$_}@$N};
    
    my $linked_tw = {};
    for my $l (grep {_s&link} @$N) {
        my $to = ls&link;
        next if $to =~ /\.\./;
        my $o = $tw.>$to;
        # get everything inside either place
        my ($ls,$os) = map {my$t=$_; [ grep {_.t =~ /^\Q$t\E/} @$N] } l.t, o.t;
        @$ls == @$os || die "confusing linkage";
        my @dodge;
        # are they the same except for the name in linkage, and the s&link itself
        for (0..(@$ls-1)) {
            my $l = $ls->[$_];
            my $o = $os->[$_];
            (local oc&s = oc&s) =~ s/o.t/l.t/;
            local os&link = ls&link if ls&link;
            unless (ki(l.c) eq ki(o.c) &&
                   ki(l.sc) eq ki(o.sc)) {
                push @dodge, [$l,$o];
            }
        }
        # if the inode is the same, it grew between each way we looked at it
        for (@dodge) {
            my ($l,$o) = @$_;
            my ($li,$oi) = map{ (stat _c&s)[1] } $l,$o;
            $li eq $oi || die "Differing inodes even: ".ki($l)."\nvs: ".ki$o;
        }
        $linked_tw.>l.t = o.t;
    }
    each l,o $linked_tw {
        @$N = grep {
            _.t !~ /^$o/
        } @$N;
    }
    
    my $M = ar.M || [];
    ar.N || do {
        @$M = @$N;
        _.y.cv = 1 for @$M;
    }
pi/listle: |
    Jc&save = 'W';
    my $l = Rw Lst + $s;
    y.at.dir = ls&dir;
    n ind=>o3=>"Yon ls&dir have ls&iterat to ".@$M
    my $s = join("\n", map {G&aC,$_ }@$M);
    n disop=>''=>$s,'fs:7,dis'
    _.y.cv = 6 for @$M;
    
    
    
pi/gust: | # see G
    # 
Lst: | # gives your $M files from ls -1ct, sleeps using your past
    # return bigger and bigger looks at the list
    my $laC;
    my $list = &i{
        my $C = G&Ct,[C.t=>''=>{s=>$s}];
        s&iterat = $i;
        c&lim = 16 * $i;
        my $N = Rw Exer;
        $laC = $C;
        $C
    };
    
    # en-2 each file
    my $form = &C{
        (s&size,s&mtime) = (stat c&s)[7,9];
        s&link = readlink c&s if -l c&s;
        s&dir = 1 if -d c&s;
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = Rw ReadMe;
    
    # osc changing atom loads contents
    push @$M,
        Rw Modulim $s $d $list $form;
    
    $laC
Exer: | # find bits for the show
    c&s =~ s/\/$//;
    c&s =~ s/\/\//\//g;
    c&do ||= 'l'; # or find
    if (c&do eq 'l') {
        c&do = 'ls -1ct';
        c&nostderr = 1;
    }
    c&cmd = c&nostderr ? qq[bash -c "c&do c&s 2>/dev/null"]
        : "c&do c&s";
    
    # search for string
    c&cmd .= "| grep c&grep" if c&grep;
    
    # maybe, with timer to kill?
    #J.mo.J.sizeup = split"\n",''.`c&cmd` if c&sizeup;
    
    c&lim ||= 20 unless c&unl;
    # skip in
    c&cmd .= "| tail --lines=+".(c&se) if c&se ;
    # skip out
    #   further to tell if theres more,
    #    have enough after image filtering?
    c&cmd .= "| head -n ".(c&lim + 4) if c&lim;
    
    # do it
    my @img = split"\n",''.`c&cmd`;
    1 && say "EXE: c&cmd: ".@img." Last: $img[-1]";
    
    my $N = [map { {c=>{s=>$_}} } @img];
    # the directory all are within,
    #   would be the c&s up to {,} or *
    my ($know) = $1 if c&s =~ /^([^\{\*]+)(\/.*?|$|.+?)/;
    $know ||= c&s;
    my $l; # last titled directory bunch, for ls -1ct
    # upgrade all to full path c&s
    my $blanks;
    for my $C (@$N) {
        if (!length c&s) {
            C.sc.not = 1;
            $blanks++;
            undef $l;
            next;
        }
        if (c&s =~ /^($know.*)\/?:$/ && -d $1) {
            $l = $C;
            c&s = $1;
            s&container = 1;
        }
        else {
            next if c&s =~ /^\Q$know\E/; # is full path
            if ($l) {
                -e "lc&s/c&s" || die "($know) expected c&s to be in lc&s!";
                c&s = "lc&s/c&s";
            }
            else {
                -e "$know/c&s" || die "expected c&s to be in $know!";
                c&s = "$know/c&s";
            }
        }
    }
    # split $know off c&s to get C.t
    @$N = grep {
        _.t = $1 if _c&s =~ /^\Q$know\E\/?(.+)$/;
        unless (defined _.t) {
            if (_c&s eq $know && _s&container) {
                _.t = ''; # hmm
                sayyl "Gets blank from $know: ".ki $_
            }
            else {
                die "Not in $know: ".ki $_;
            }
        }
        1
    } grep {
        !_.sc.not
    } @$N;
    
    
    
    
    if (c&only eq 'images') {
        @$N = grep {
            _.t =~ /^[\/\w\[\]\{\}\(\)!@%-]+\.jpe?g$/i
        } @$N
    }
    
    # reunlimit until lim is full of satis ^
    if (c&lim && c&lim < @$N) {
        sayre "Returned c&lim < ".($blanks + @$N)." rows, keep reading...";
        #@$N = @{$N}[0..(c&lim-1)]
    }
    elsif (c&lim > @$N + $blanks) {
        sayre "Done! c&s since c&lim vs ".($blanks + @$N);
        s&done = 1
    }
    #_.y.cv ||= 9 for @$N;
    s&dir = $know;
    s&z = $N
Modulim: | # loadup M news from an ls or so
    # stop when old news found
    my $piit = 'fils';
    my $done;
    my $list_done;
    my $seen; # C.t
    my $seens; # c&s
    my @l;
    my $page = 1;
    my $M = [];
    # whether to read into the rest of the page
    # once something same has been found
    my $keen; 
    # if the lines go directory:\nfile\nfile\nfile
    # must see a whole directory of unchanged
    # - changes bump the directory but may then 
    #     have unchanged stuff before more changes
    # < keep going a page or so after stillness
    #   $done > 10 helps too
    my $con;
    until (($done > 10) && (!$keen || !@l)) {
        if (!@l && !($done > 10)) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep {
                if (my $c = $seen.>_.t ) {
                    # containers may dupe if {,/*}
                    #   but then goes mad when sleeping
                    if (0 && _s&container && !cs&container) {
                        sayyl "Swapping c.t For _.t";
                        @$M = grep {$_ ne $c} @$M;
                        1
                    }
                    else {
                        0
                    }
                }
                else {
                    1
                }
            } @{s&z};
            @l || last;
        }
        my $s = shift @l;
        $seen.>s.t && next; # container and not in-@l
        length sc&s || die "Isnt ".ki $s;
        
        # form this one line
        my $C;
        if (ar.form) {
            $C = $s;
            ar.form->($C);
        }
        elsif (ar.forms) {
            my @C = ar.forms->(sc&s);
            $C = G&Ct,\@C;
        }
        
        $con = [] if s&container;
        
        s&pi = $piit if $piit;
        my $c = d.y.tw.>C.t;
        
        my $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            $con && push @$con, $C;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        elsif (!$con || !@$con) {
            sayyl "Done upon C.t";
            $done++;
        }
        $seen.>C.t = $C;
        push @$M, $C;
    }
    for my $C (@{ds&z}) {
        next if $piit && $piit ne C.sc.pi;
        next if $seen.>C.t;
        next if !-e c&s;
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M

