not: | # do everything! (run as Spec)
    Jc&tape = 1;
    Jc&save = 1;
    Gc&Glan = 'Elan';
    A.6.t = A.7.t;
    
    Rw Tiot;
    # the sprawldy
    
    Rw UpSetulism;
    
    my $d = Rw ReadMe;
    !ds&pid || ds&pid eq $$ || sayre("Giving over to ds&pid") && exit;
    y.at.pid = $$;
    
    # < collect via T.has: Scuttle Js interestings
    Js&servetime = [];
    
    my $def = 
    n Gc&bay=>-Trooms
    
    Rw GiveTime;
    
    #n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
UpSetulism: | # need also GiveTime, then your 3's Lst-ings wake it up when they change
    3s&upsetters = [];
    my $ti;
    $ti = Js&ti = &{
        $ti eq Js&ti || return;
        my $u = 3s&upsetters;
        if (grep {$_->()} @$u) {
            4s&toy ->({to=>[[C.t]]})
        }
        else {
            G&timer:1.2,$ti;
        }
    };
    G&timer:1.2,$ti;
    
Plael: | # ORPH test el function
    y.at.ellog = 1;
    
    my $l =
    n giveth=>-od=>[[1,2,3],[3,4,(Js&bowls + 5)]]
    Js&bowls > 2 &&# sleep(2) &&
    n again=>2=>{},{J=>ls&J}
    
    Js&bowls++ if Js&bowls < 3;
    
    return;
    
    #y.at.ellog = 1;
    $M = _s&z = [] for
    n the=>3=>"Expe"
    m sev=>3=>"Fo"
    m eral=>6=>"Five"
    my @l = (('x') x Js&bowls++);
    n bo=>-bowling_5=>[neg=>@l,a=>trope=>5]
    0 &&
    n see=>'8'.Js&bowls=><<'','e'
        //console.log(A.on);
    my $t = T.op;
    $t = t.y.s;
    $t = ts&lv;
    #$t = $t->[-1];
    my $s = G&Ct:[s=>{}=>{s=>$t}];
    Js&bowls > 5 &&
        G&give,Suck=>$s;
    
Suck: | # diag, 
    #y.at.ellog = 9;
    Rw Tiot;
    Rw Elationist;
    S
    n from=>o1=>"From: ".G&sn,Jc&from ,'dis,hs:874'
    n suction=>-od=>{dl=>5,s=>Jc&es||"blank"};
    # and turn back into line-per-time host
    G&timer:0.1,&{ 4s&toy->({to=>['Udder']}) }
Bal: | # G up in a GG
    # from Udder, assume T position
    #die "Cosume: ".ki $C;
    what:
        what Bal?
pi/bowling: |
    Jc&save = 'W';
    m teh=>''=>$_,'ma:0.2' for @$s;
pi/Trooms: | # see many tests/Gug/goers
    Jc&save = 'W';
    # C Trooms, instead of single items everywhere:
    
    n panics=>-clust=>{s=>$s,mode=>'err',skip_pile=>1}
    
    my $eh = hitime();
    # get written on
    n gravities=>-GG_2=>{s=>$s}
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;

    n fromi=>3=>"Fro grav, $delta",'dis,fs:6,hs:474'
    
    # put forward
    #n travels=>-T
    n Taste=>-Turn_5
    n Thaste=>-Turn_51
    n Tofing=>-Turn_52
    n TookPersonel=>-Turn_53
    n Tveing=>-Turn_54
    n Tleep=>-Turn_55
    n TEsting=>-Turn_551
    
    y.n = 6;
    m line=>''=>'--------------------------','lh:0.2,hs:397,dis,poi:0'
    m Lis=>-Gug
    m Glo=>-Gug
    m Gallip=>-Gug
    m Te=>-Gug
    m TEing=>-Gug
    m TEsting=>-Gug
    
pi/Gug: |
    s&dos = 'Gugs';
    s&ma = 0.2;
    T.nose = 3;
pi/Wug: |
    s&to ||= G.t;
    s&dos = 'Gugs';
    s&ma = 0.2;
    T.nose = 3;
    
Gugs: |
    # g
    my $s = [c.t];
    my $to = cs&to; # undef forks it from Gc&Down, probably
    Rw Wudder $to $s;
    T.pos = 0;
    
pi/Turn: | # button to run thing and sort through ashes
    s&dos = 'Turns';
    s&ma = 0.1;
    T.nose = 3;
    #n t=>1=>C.t
    
Turns: | # send instance into running
    my $s = [Turning=>[W=>''=>{s=>c.t}]];
    #sayre "Giving $w: $f/$t: sc.Jo";
    Rw Wudder $s;
    T.pos = 0;
Turning: | # set up on the running instance
    # brackets whole Run inc timers, Sucks Wall
    Jc&entire = [];
    Jc&done_hook = [Turning=>[done=>'']];
    Js&ein.t.W.sMJ = &sMJjeTCA{
        # prepare node for testrun:
        push @{Gc&when_done||=[]}, Jc&done_hook;
        # mutation
        #5c&plus = ['StarTime'];
        #n Howz
        # muting
        n Wall=>W=>{mute=>1,entire=>Jc&entire}
        
        # being
        1 && saygr "Being $s from ".ki $e;
        Gc&testbeing = $s;
        Gc&asap = 1;
        n Gc&testbeing
    };
    Js&ein.t.done.sMJ = &sMJjeTCA{
        # cancel test Ting
        @{Gc&when_done} = grep{ $_ ne Jc&done_hook } @{Gc&when_done};
        1 && saygr "Testing $s done";
        
        # Tee and comp to test data
        my $W =
        n Wall=>W=>{mute=>0,entire=>0}
        my $Wallz = Ws&J.sc.top.sc.z;
        my $Wentz = Jc&entire;
        G&e,LiveResult=>[Wentz=>''=>{s=>$Wentz}];
        # notify handler of pass/fail?
        # page LiveResult per G.t/Gc&testbeing
        #  wants a G per test run, an LR-thistest per test case
        #  to be merged after accepting changes
    };
    S
    Rw GiveTime;
    
LiveResult: | # hold/check results
    # < could happen in a fork?
    #   and refork as you look around fallouts
    Rw Tiot;
    A.6.t = A.7.t = 'est';
    Jc&write_hard_links = 1;
    Js&ein.t.Wentz.sMJ = &sMJjeTCA{
        # every item sent to Wall
        for my $C (@$s) {
            if (my $reg = 5s&tig_wentz) {
                if (C.t =~ $reg) {
                    1 && saybl "ignoring tig_wentz match: C.t";
                    next;
                }
            }
            my $o = G&o,$C;
            my $t = "C.t's Wentz";
            my $i = Jc&tes.>$t if Jc&tes.>$t ++;
            $t = "$t ".$i if $i;
            1 && saygr "Test data (W) received: C.t $i";
            m $t=>-result=>{s=>oc&s}
        }
    };
    S
    #_.y.cv = 1 for @{Js&M||[]};
    
    y.n = 2;
    m $_ for @{Js&M||[]};
    # sort of could use lookins to deliver self
    # bit all-or-nothing tho...
    #n Gc&testbeing=>-lookins
    
    # TODO:
    3s&trouble = 0;
    n Gc&testbeing=>-thistest=>{s=>[@$M]}
    @$M = ();
    # which tacs via Jc&save, on -thistest and -results
    # much simpler...
    
pi/thistest: | # named
    y.at.dis = 1;
    my $t =
    n tee=>o1=>C.t=>'dos:fullercheck';
    y.n = 3;
    
    !Js&top && sayyl "Initiating -thistest: C.t";
    my $g = Rw Acceptor glance;
    
    # things from -result.sc to speed by
    Jc&glancey = [qw'zshaex'];
    # named parents
    Js&ha_tw = {};
    
    # to catch missing
    my $tw = {};
    # avoid super when the inner is updating its Jc&expected
    my $ftw = delete Jc&fulltw;
    for my $C (@$s) { # up's $M of -results
        my $s = c&s; # W in Wall
        my $f = g.y.tw.>C.t;
        # quick map of inner things
        die "Not all sha: ".ki $s if @{ss&z} != grep{_s&ha}@{ss&z};
        s&zshaex = [map {"_.t _s&ha"}@{ss&z}];
        if ($f) {
            if (!$ftw.>C.t && !Jc&full_check && sjson(fs&zshaex) eq sjson(s&zshaex)) {
                # make super -result, no J
                s&pi = delete c&pi ;
                c&s = "C.t: pass";
                s&dis = 1;
            }
        }
        else {
            s&unknown = 1;
        }
        $tw.>C.t =
        m $C
    }
    each t,C g.y.tw {
        $tw.>C.t && next;
        m C.t=>''=>"C.t: missing"=>'missing,ma:0.2,fs:8,hs:895'
    }
    
    # mo's the $M
    G&A,$_,8 for 1s&root.y.A || die "no 1srootyA";
    
    if (grep { _s&missing || _s&unknown || _s&fails } @$M) {
        ts&z = $M = [];
        m accept_all=>12=>"?"=>'dos:tacall,ma:0.2,fs:8,hs:895';
    }
    else {
        s&pass = 1;
    }
    
    
fullercheck: |
    my $j = e&hJ ->[-1];
    1 && saygr "For ".G&sn,$j;
    jc&full_check = 1;
pi/result: |
    my $d = Rw ReadMe;
    y.at.dis = 1;
    n tee=>o1=>C.t
    y.n = 3;
    
    my $c = Rw Acceptor expected;
    
    
    # $s is a W in Wall
    my $tw = {};
    for my $D (@{ss&z||[]}) {
        !ref Dc&s && length Dc&s || die "Dodge D: ".ki $D;
        
        Dc&s =~ s/(parent:)(\w+)/"$1(".2s&ha_tw.>$2 .")"/e;
        2s&ha_tw.>Ds&ha = C.t if Ds&ha; # name parent
        my $f =
        m "writes D.t"=>''=>{s=>Dc&s},'pi:testss,fs:7,hs:247,dis'
        # put further diags inside it
        my $M = fs&z = [];
        if (my $e = c.y.tw.>f.t ) {
            if (ec&s eq Dc&s) {
                fs&pass = 1;
            }
            else {
                fs&fail = 'different';
                fs&hs = '348';
                m expected=>1=>ec&s=>'hs:967,dis,dos:Diffrance'
                s&fails++;
            }
        }
        else { # the whole -result may be unknown
            fs&fail = 'unknown';
            fs&hs = '895';
            s&fails++;
        }
        $tw.>f.t = $f;
    }
    each t,C c.y.tw {
        $tw.>C.t && next;
        s&fails++;
        m C.t=>''=>"C.t - missing"=>'missing,ma:0.2,fs:8,hs:895'
    }
    
    if (s&unknown || s&fails) {
        n accept=>11=>"?",'dos:taccept,ma:0.2,hs:895';
        n btw=>12=>{s=>"f=ss&f"}
    }
Diffrance: |
    sayre "Diffrance!";
    my $l;
    c.t eq 'expected' || die "Click expectation";
    l.exp = [split "\n", cc&s];
    l.got = [split "\n", c.y.up.c.s];
    
    my @r;
    my $good;
    while (@{l.exp} || @{l.got}) {
        my $g = shift @{l.got};
        my $e = shift @{l.exp};
        
        if ($g ne $e) {
            if ($g =~ /^[^\t]+\t(\d+)\t/) {
                my $was = $1;
                (my $ee = $e) =~ s/^([^\t]+)\t(\d+)\t/$1\t$was\t/;
                if ($ee eq $g) {
                    $good++;
                    push @r, "cv diff: $1: $was -> $2";
                    next;
                }
            }
            $good && push @r, "$good then";
            $good = 0;
            push @r, "got: $g\nexp: $e";
        }
        else {
            $good++;
            $good <= 5 && push @r, "ok:  $g";
            if ($good == 5) {
                pop @r for 1..5;
            }
        }
    }
    $good && $good > 5 && push @r, "then $good ";

    
    G&give,Suck=>''=>{s=>\@r};
    T.pos = 0;
Acceptor: | # give, take and return expected C
    my $t = ar.t || ar.m->[0];
    my $d = Rw ReadMe;
    my $g = d.y.tw.>$t;
    if (J.c.>$t ) { # accepting
        $g = delete J.c.>$t;
        Jc&save = 'W';
    }
    if ($g) {
        # mutes z in lv/7, 1 gets it
        gs&qz = 1;
        # send it around again
        n $g
    }
    $g
tacall: | # accept many -results
    my ($t) = reverse e&_hJ;
    _s&pi eq 'thistest' || die "Not -thistest: ".ki$_ for tc&s;
    # drops whole glance, so goners get gone
    # < suppose -result's $t/j/$r should leave too,
    #   LiveResult keeps many -thistests that may not be there
    #   shifting house should shake out dead Js
    tc&glance = G&Ct,[glance=>''];
    #G&give,Suck=>[tacall=>''=>{s=>e.c}];
    T.op = ts&top;
    my @res = G&op,'pi:result';
    for my $r (@res) {
        if (my $J = rs&J) {
            tc&fulltw.>J.t = 1;
            push @{e.c.hJ}, $J;
            Rw taccept $J;
            pop @{e.c.hJ};
        }
        else {
            Rw taccept $t $r;
        }
    }
taccept: | # accept -result
    # -thistest J, -result C
    my ($t,$r);
    my $what = [];
    if (ar.t) {
        # when tacall-ing, some things may super -result,
        # only needing their glance collected
        $t = ar.t;
        $r = ar.r || die "ar_t also needs ar_r";
        1 && sayyl "Non-fully accepting r.t";
    }
    else {
        my ($j) = reverse e&_hJ;
        jc&imping = 1;
        $t = j.2;
        $r = jc&s;
        rs&pi eq 'result' || die "Not -result: ".ki$r;
        # the super -testss's c&s are lines of stuff
        T.op = js&top;
        my @res = G&op,'pi:testss';
        @res || die "No pi=testss found";
        # entire -result commits a new expected
        my $e = jc&expected = G&Ct,[expected=>''];
        e.y.tw.>_.t = G&Ct,[_.t=>''=>{s=>_c&s}] for @res;
        $what = [map {_.t} @res];
    }
    # also put the glance
    _s&pi eq 'thistest' || die "Not -thistest: ".ki$_ for tc&s;
    my $g = tc&glance ||= ts&tw.glance || G&Ct,[glance=>''];
    # this -result puts checksum in glance
    my $l = g.y.tw.>r.t = G&Ct,[r.t=>''];
    for my $k (@{tc&glancey}) {
        l.sc.>$k = r.sc.>$k || die "-result has no sc $k: ".ki$r;
    }
    saygr "Accepted r.t's ".ki$what;
    

pi/GG: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    s&is = 'directory';
    y.at.dos = 'Clustout';
    
    my $eh = hitime();
    
    n see=>-listle_1=>$s,'qz'
    m _.t=>''=>{s=>_.t,fils=>$_},'dos:looking,ma:0.2' for G&op,'pi:fils';
    # ^ others, refind selves v
    n vokate=>-lookins_02
    
    #m _.t=>-GGo=>{s=>$C}
    y.u = 4;
    Js&Fur &&
    n Fur=>-od_8=>{s=>Js&Fur}
Fur: | # thing further and not
    return delete js&Fur if us&S;
    js&Fur = $c;
pi/GGo: | # identify your bits
    n t=>1=>C.t=>'fs:12,hs:488,dis'
    my $y = &C{ G&aC };
    my @l = G&ind:$s,$y;
    n s=>6=>wdump(\@l)
pi/gust: | # a look at a G
    # 

