not: | # do everything! (run as Spec)
    Jc&tape = 1;
    Jc&save = 1;
    A.6.t = A.7.t;
    
    Rw Tiot;
    # the sprawldy
    
    # to collect via T.has:
    Js&servetime = [];
    
    # to hang the sources of T rooms:
    my $def = 
    n hang=>-Trooms
    
    Rw GiveTime;
    G&timer:3,&{ 4s&toy ->({to=>[[C.t]]}) };
    
    
    n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
Lst: | # gives your $M files from ls -1ct, sleeps using your past
    # return bigger and bigger potential changes
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = $s;
        c.s = "C.t/$s" if $s =~ /^\W/; # s=/thing -> t/thing
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &t{
        my $sc = {};
        my $f = "$s/$t";
        (sc.size,sc.mtime) = (stat $f)[7,9];
        sc.link = readlink $f if -l $f;
        $t=>1=>{},$sc
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = Rw ReadMe;
    
    
    # osc changing atom loads contents
    @$M = Rw Modulate $s $d $list $forms;
    
ReadMe: | # the J you're in remembers itself
    # having created a place for it to land
    my $s = ''; # TODO osc channel, api here too Jeneral
    my $f = Rw Locate $read=1 $t=0 $s=0;
    $f || saybl("Nothing to read A.1.t from A.6.t / A.7.t") && return;
    1c&read_from = $f;
    #saybl "Read located: $f";
    my $head = "$f/1";
    my $d = 1s&Read.>$head ||= {};
    my $m = (stat $head)[9];
    if (ds&meta.mtime eq $m) {
        # sleep J?
    }
    else {
        -f $head || die "Read no $head";
        $d = Rw Beach $s=0 $f:head;
        ($d) = @$d;
        ds&meta.mtime = $m;
        1s&Read.>$f = $d;
    }
    return $d
Modulate: | # loadup M news
    # stop when old news found
    my $done;
    my $list_done;
    my $seen;
    my @l;
    my $page = 1;
    my $M = [];
    my $keen; # whether to read into the rest of the page
              # once something same has been found
    until ($done && (!$keen || !@l)) {
        if (!@l && !$done) {
            last if $list_done;
            my $C = $list->($page++);
            $list_done = 1 if s&done;
            @l = grep { !$seen.>$_ } @{s&sz};
            @l || last;
        }
        my $s = shift @l;
        $seen.>$s = 1;
        
        my @C = $forms->($s);
        my $C = G&Ct,\@C;
        my $c = d.y.tw.>C.t;
        
        my $cha;
        
        # could use the thing beneath o
        my $l = G&Ct,[c.t=>''=>{s=>$c}];
        my $o = G&Ct,[C.t=>''=>{s=>$C}];
        
        # or just
        $cha = ki(c.sc) ne ki C.sc;
        
        if ($cha) {
            $done = 0;
            saybl "Cha: C.t:  ".ki(c.sc)." ne ".ki C.sc;
        }
        else {
            sayyl "Done upon C.t";
            $done = 1;
        }
        push @$M, $C;
    }
    saybl "Seen: ".ki $seen;
    for my $C (@{ds&z}) {
        next if $seen.>C.t;
        next if !-e "$s/C.t";
        saybl "Cached C.t";
        push @$M, $C;
    }
    @$M
GiveTime: | # release from reading input
    Gc&clockon = sub {
        1 && saybl "GiveTime: G.t";
        # turns Udder read loop into Baye read loop
        Gc&freetime = 1;
        n Baye
        Mojo::IOLoop->is_running || Mojo::IOLoop->start;
    };
pi/Trooms: |
    Jc&save = 'W';
    # C Trooms, instead of single items everywhere:
    n blank=>-clust=>'blank'
    
pi/clust: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    
    Rw Lst + $s=$s/p;
    n ind=>o3=>"Yo have ".join(",",map{_.t}@$M)
    my $m = [@$M];
    #@$M = ();
    m "dis _.t"=>''=>G&aC,$_ =>'dis' for @$m;
    
    #@$M = ();
    
    
pi/gust: | # see G
    # 
Exe: | # find bits for the show
    c&s =~ s/\/$//;
    c&do ||= 'l'; # or find
    c&do = 'ls -1' if c&do eq 'l';
    c&lsins = 1 if c&do =~ /^ls -1/ && c&s !~ /\*/;
    c&cmd ||= "c&do".(defined c&s && ' '.c&s);
    c&cmd .= "| grep c&grep" if c&grep;
    J.mo.J.sizeup = split"\n",''.`c&cmd` if c&sizeup;
    c&lim = 20 if !defined c&unl && !defined c&lim;
    c&cmd .= "| tail --lines=+".(c&se) if c&se ;
    c&cmd .= "| head -n ".(2*c&lim) if c&lim;
    my @img = split"\n",''.`c&cmd`;
    1 && say "EXE: c&cmd: ".@img;
    @img = grep {/^[\/\w\[\]\{\}\(\)!@%-]+\.jpe?g$/i} @img if c&only eq 'images';
    # reunlimit until lim is full of satis ^
    @img = @img[0..c&lim] if c&lim && c&lim < @img;
    my $i;
    @img = grep { !$i || $i++ >= c&skov ? do{$i=1} : 0 } @img
        if c&skov;
    c&simg = [@img] if c&lsins;
    @img = map {c&s.'/'.$_} @img if c&lsins;
    @img
    

