not: | # do everything! (run as Spec)
    Jc&tape = 1;
    
    Rw Tiot;
    # the sprawldy
    
    # to collect via T.has:
    Js&servetime = [];
    
    # to hang the sources of T rooms:
    my $def = 
    n hang=>-Trooms
    
    Rw GiveTime;
    G&timer:3,&{ 4s&toy ->({to=>[[C.t]]}) };
    
    
    n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
Lst: | # gives your $M files from ls -1ct, sleeps using your past
    my $list = &i{
        my $c;
        c.lim = 4 * $i;
        c.do = 'bash -c "ls -1ct';
        c.s = $s;
        c.s = "C.t/$s" if $s =~ /^\W/; # s=/thing -> t/thing
        c.s .= ' 2>/dev/null"';
        c.s =~ s/\/\//\//g;
        my $C = G&Ct,[C.t=>''=>$c];
        # or: $C = C C.t $lim $s:at % $universal=3
        my @im = Rw Exe;
        saybl "Im c.s: ".wdump 3, \@im;
        # make
        s&sz = \@im;
        s&done = 1 if @im < c&lim;
        $C
    };
    
    # en-2 each file
    my $forms = &t{
        my $sc = {};
        my $f = "$s/$t";
        saygr "Fed $t or $f";
        (sc.size,sc.mtime) = (stat $f)[7,9];
        sc.link = readlink $f if -l $f;
        $t=>1=>{},$sc
    };
    
    # retrieves our last save, doesn't impart/resume it
    my $d = Rw ReadMe;
    
    
    # osc changing atom loads contents
    @$M = Rw Modulate $d $list $forms;
    
ReadMe: | # the J you're in remembers itself
    # having created a place for it to land
    my $s = ''; # TODO osc channel, api here too Jeneral
    my $f = G&Locate_read
        || saybl("Nothing to read A.1.t") && return;
    1c&read_from = $f;
    #saybl "Read located: $f";
    my $head = "$f/1";
    my $d = 1s&Read.>$head ||= {};
    my $m = (stat $head)[9];
    if (ds&meta.mtime eq $m) {
        # sleep J?
    }
    else {
        -f $head || die "Read no $head";
        $d = LoadFile($head);
        ds&meta.mtime = $m;
        1s&Read.>$f = $d;
    }
    
    return $d
GiveTime: | # release from reading input
    Gc&clockon = sub {
        1 && saybl "GiveTime: G.t";
        # turns Udder read loop into Baye read loop
        Gc&freetime = 1;
        n Baye
        Mojo::IOLoop->is_running || Mojo::IOLoop->start;
    };
pi/Trooms: |
    # C Trooms, instead of single items everywhere:
    n blank=>-clust=>'blank'
    
pi/clust: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    
    Rw Lst + $s=$s/p;
    
    n seeing=>-od=>wdump 3,$M
    
    @$M = ();
    
    
pi/gust: | # see G
    # 
Exe: | # find bits for the show
    c&s =~ s/\/$//;
    c&do ||= 'l'; # or find
    c&do = 'ls -1' if c&do eq 'l';
    c&lsins = 1 if c&do =~ /^ls -1/ && c&s !~ /\*/;
    c&cmd ||= "c&do".(defined c&s && ' '.c&s);
    c&cmd .= "| grep c&grep" if c&grep;
    J.mo.J.sizeup = split"\n",''.`c&cmd` if c&sizeup;
    c&lim = 20 if !defined c&unl && !defined c&lim;
    c&cmd .= "| tail --lines=+".(c&se) if c&se ;
    c&cmd .= "| head -n ".(2*c&lim) if c&lim;
    my @img = split"\n",''.`c&cmd`;
    1 && say "EXE: c&cmd: ".@img;
    @img = grep {/^[\/\w\[\]\{\}\(\)!@%-]+\.jpe?g$/i} @img if c&only eq 'images';
    # reunlimit until lim is full of satis ^
    @img = @img[0..c&lim] if c&lim && c&lim < @img;
    my $i;
    @img = grep { !$i || $i++ >= c&skov ? do{$i=1} : 0 } @img
        if c&skov;
    c&simg = [@img] if c&lsins;
    @img = map {c&s.'/'.$_} @img if c&lsins;
    @img
    

