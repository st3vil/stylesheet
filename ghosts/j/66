not: | # do everything! (run as Spec)
    Jc&tape = 1;
    Jc&save = 1;
    A.6.t = A.7.t;
    
    Rw Tiot;
    # the sprawldy
    
    
    my $d = Rw ReadMe;
    !ds&pid || ds&pid eq $$ || sayre("Giving over to ds&pid") && exit;
    y.at.pid = $$;
    
    # to collect via T.has:
    Js&servetime = [];
    
    my $def = 
    n blank=>-Trooms
    
    Rw GiveTime;
    my $ti;
    $ti = Js&ti = &{ $ti eq Js&ti && 4s&toy ->({to=>[[C.t]]}) };
    G&timer:3.2,$ti;
    
    
    #n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
Plael: | # test el function
    y.at.ellog = 1;
    
    my $l =
    n giveth=>-od=>[[1,2,3],[3,4,(Js&bowls + 5)]]
    Js&bowls > 2 &&# sleep(2) &&
    n again=>2=>{},{J=>ls&J}
    
    Js&bowls++ if Js&bowls < 3;
    
    return;
    
    #y.at.ellog = 1;
    $M = _s&z = [] for
    n the=>3=>"Expe"
    m sev=>3=>"Fo"
    m eral=>6=>"Five"
    my @l = (('x') x Js&bowls++);
    n bo=>-bowling_5=>[neg=>@l,a=>trope=>5]
    0 &&
    n see=>'8'.Js&bowls=><<'','e'
        //console.log(A.on);
    my $t = T.op;
    $t = t.y.s;
    $t = ts&lv;
    #$t = $t->[-1];
    my $s = G&Ct:[s=>{}=>{s=>$t}];
    Js&bowls > 5 &&
        G&give,Suck=>$s;
    
Suck: | # diag, 
    #y.at.ellog = 9;
    Rw Tiot;
    Rw Elationist;
    S
    n from=>o1=>"From: ".G&sn,Jc&from ,'dis,hs:874'
    n suction=>-od=>{s=>Jc&es||"blank"};
    # and turn back into line-per-time host
    G&timer:0.1,&{ 4s&toy->({to=>['Udder']}) }
Bal: | # G up in a GG
    # from Udder, assume T position
    die "Cosume: ".ki $C;
pi/bowling: |
    Jc&save = 'W';
    m teh=>''=>$_,'ma:0.2' for @$s;
pi/Trooms: |
    Jc&save = 'W';
    # C Trooms, instead of single items everywhere:
    
    n panics=>-clust=>{s=>$s,mode=>'err'}
    
    my $eh = hitime();
    # get written on
    n gravities=>-GG_2=>{s=>$s}
    
    my $ts = hitime() - $eh;
    my $delta = Rw mass $s:ts;

    n fromi=>3=>"Fro grav, $delta",'dis,fs:6,hs:474'
    
    # put forward
    #n travels=>-T
    n Taste=>-Turn_5
pi/Turn: | # button to run thing and sort through ashes
    y.at.dos = 'Turns';
    n t=>1=>C.t
Turns: | # send instance into running
    my $s = [Turning=>[W=>''=>{s=>cc&s}]];
    #sayre "Giving $w: $f/$t: sc.Jo";
    Rw Wudder $s;
Turning: | # set up on the running instance
    # brackets whole Run inc timers, Sucks Wall
    Jc&entire = [];
    Jc&done_hook = [Turning=>[done=>'']];
    Js&ein.t.W.sMJ = &sMJjeTCA{
        # prepare node for testrun:
        push @{Gc&when_done||=[]}, Jc&done_hook;
        # mutation
        5c&plus = ['StarTime'];
        n Howz
        # muting
        n Wall=>W=>{mute=>1,entire=>Jc&entire}
        
        # being
        Gc&testbeing = 'Taste';
        n Gc&testbeing
    };
    Js&ein.t.done.sMJ = &sMJjeTCA{
        # cancel test Ting
        @{Gc&when_done} = grep{ $_ ne Jc&done_hook } @{Gc&when_done};
        # Tee and comp to test data
        my $W =
        n Wall=>W=>{mute=>0,entire=>0}
        my $Wallz = Ws&J.sc.top.sc.z;
        my $Wentz = Jc&entire;
        G&e,LiveResult=>[Wentz=>''=>{s=>$Wentz}];
        
    };
    S
    Rw GiveTime;
    
LiveResult: | # hold/check results
    # < could happen in a fork?
    #   and refork as you look around fallouts
    Rw Tiot;
    A.6.t = A.7.t = 'est';
    Jc&write_hard_links = 1;
    Js&ein.t.Wentz.sMJ = &sMJjeTCA{
        # every item sent to Wall
        for my $C (@$s) {
            my $o = G&o,$C;
            my $t = "C.t's Wentz";
            $t = "$t ".Jc&tes.>$t if Jc&tes.>$t ++;
            m $t=>-result=>{s=>oc&s}
        }
    };
    S
    #_.y.cv = 1 for @{Js&M||[]};
    
    y.n = 2;
    m $_ for @{Js&M||[]};
    # sort of could use lookins to deliver self
    # bit all-or-nothing tho...
    #n Gc&testbeing=>-lookins
    
    # TODO:
    3s&trouble = 0;
    n Gc&testbeing=>-thistest=>{s=>[@$M]}
    @$M = ();
    # which tacs via Jc&save, on -thistest and -results
    # much simpler...
    
pi/thistest: | # named
    y.at.dis = 1;
    my $t =
    n tee=>o1=>C.t
    y.n = 3;
    
    my $g = Rw Acceptor glance;
    
    # things from -result.sc to speed by
    Jc&glancey = [qw'zshaex'];
    
    my $tw = {};
    for my $C (@$s) { # up's $M of -results
        my $s = c&s; # W in Wall
        my $f = g.y.tw.>C.t;
        # quick map of inner things
        die "Not all sha: ".ki $s if @{ss&z} != grep{_s&ha}@{ss&z};
        s&zshaex = [map {"_.t _s&ha"}@{ss&z}];
        if ($f) {
            if (sjson(fs&zshaex) eq sjson(s&zshaex)) {
                # make super -result, no J
                s&pi = delete c&pi ;
                c&s = "C.t: pass";
                s&dis = 1;
            }
        }
        else {
            s&unknown = 1;
        }
        $tw.>C.t =
        m $C
    }
    each t,C g.y.tw {
        $tw.>C.t && next;
        m C.t=>''=>"C.t: missing"=>'missing,ma:0.2,fs:8,hs:895'
    }
    
    # mo's the $M
    G&A,$_,8 for 1s&root.y.A || die "no 1srootyA";
    
    if (grep { _s&missing || _s&unknown || _s&fails } @$M) {
        ts&z = $M = [];
        m accept_all=>12=>"?"=>'dos:tacall,ma:0.2,fs:8,hs:895';
    }
    else {
        s&pass = 1;
    }
    
    
Acceptor: | # give, take and return expected C
    my $t = ar.t || ar.m->[0];
    my $d = Rw ReadMe;
    my $g = d.y.tw.>$t;
    if (J.c.>$t ) { # accepting
        $g = delete J.c.>$t;
        Jc&save = 'W';
    }
    if ($g) {
        # mutes z in lv/7, 1 gets it
        gs&qz = 1;
        # send it around again
        n $g
    }
    $g
pi/result: |
    Jc&save = 'W'; # when accepting
    my $d = Rw ReadMe;
    y.at.dis = 1;
    n tee=>o1=>C.t
    y.n = 3;
    
    my $c = Rw Acceptor expected;
    
    # $s is a W in Wall
    my $tw = {};
    for my $D (@{ss&z||[]}) {
        !ref Dc&s && length Dc&s || die "Dodge D: ".ki $D;
        my $f =
        m "writes D.t"=>''=>{s=>Dc&s},'pi:testss,fs:7,hs:247,dis'
        # put further diags inside it
        my $M = fs&z = [];
        if (my $e = c.y.tw.>f.t ) {
            if (ec&s eq Dc&s) {
                fs&pass = 1;
            }
            else {
                fs&fail = 'different';
                fs&hs = '348';
                m expected=>1=>ec&s=>'hs:967,dis'
                s&fails++;
            }
        }
        else { # the whole -result may be unknown
            fs&fail = 'unknown';
            fs&hs = '895';
            s&fails++;
        }
        $tw.>f.t = $f;
    }
    each t,C c.y.tw {
        $tw.>C.t && next;
        s&fails++;
        m C.t=>''=>"C.t - missing"=>'missing,ma:0.2,fs:8,hs:895'
    }
    
    if (s&unknown || s&fails) {
        n accept=>11=>"?",'dos:taccept,ma:0.2,hs:895';
    }
tacall: | # accept many -results
    my ($t) = reverse e&_hJ;
    _s&pi eq 'thistest' || die "Not -thistest: ".ki$_ for tc&s;
    # drops whole glance, so goners get gone
    # < suppose -result's $t/j/$r should leave too,
    #   LiveResult keeps many -thistests that may not be there
    #   shifting house should shake out dead Js
    tc&glance = G&Ct,[glance=>''];
    #G&give,Suck=>[tacall=>''=>{s=>e.c}];
    T.op = ts&top;
    my @res = G&op,'pi:result';
    for my $r (@res) {
        if (my $J = rs&J) {
            push @{e.c.hJ}, $J;
            Rw taccept $J;
            pop @{e.c.hJ};
        }
        else {
            Rw taccept $t $r;
        }
    }
taccept: | # accept -result
    # -thistest J, -result C
    my ($t,$r);
    my $what = [];
    if (ar.t) {
        # when tacall-ing, some things may super -result,
        # only needing their glance collected
        $t = ar.t;
        $r = ar.r || die "ar_t also needs ar_r";
    }
    else {
        my ($j) = reverse e&_hJ;
        jc&imping = 1;
        $t = j.2;
        $r = jc&s;
        rs&pi eq 'result' || die "Not -result: ".ki$r;
        # the super -testss's c&s are lines of stuff
        T.op = js&top;
        my @res = G&op,'pi:testss';
        @res || die "No pi=testss found";
        # entire -result commits a new expected
        my $e = jc&expected = G&Ct,[expected=>''];
        e.y.tw.>_.t = G&Ct,[_.t=>''=>{s=>_c&s}] for @res;
        $what = [map {_.t} @res];
    }
    # also put the glance
    _s&pi eq 'thistest' || die "Not -thistest: ".ki$_ for tc&s;
    my $g = tc&glance ||= ts&tw.glance || G&Ct,[glance=>''];
    # this -result puts checksum in glance
    my $l = g.y.tw.>r.t = G&Ct,[r.t=>''];
    for my $k (@{tc&glancey}) {
        l.sc.>$k = r.sc.>$k || die "-result has no sc $k: ".ki$r;
    }
    saygr "Accepted r.t's ".ki$what;
    
Taste: | # waylay self
    my $i = Js&bowls++ + 1;
    Jc&tape = 'W';
    S
    $i += 0.2 if $i == 2;
    n Figuration=>1=>"Luxe Elan",{fs=>4*$i}
    
    my $cb = &{ 4s&toy->({to=>[C.t]}); };
    $i < 3 &&
    G&time,1,$cb;
StarTime: | # explicit Motor-served timers
    u i
    # todo compute desire
    time: %acgt:s cb
        1 && saygr "Eating time";
        push @{4c&todo||=[]}, [$A,$s,$cb];
MotorTime: | # serve time
    sayre "Plan future: ".ki $_ for @{4c&todo};
    my $tz;
    for my $y (@{4c&todo}) {
        my ($Y,$s,$cb) = @$y;
        saybl "Timering $s: ".G&sn,$Y;
        push @{$tz.>$s ||=[]}, [$Y,$cb];
    }
    @{4c&todo} = ();
    if (!$tz) {
        if (my $wd = Gc&when_done) {
            G&e,@$_ for @$wd;
        }
        return;
    }
    my @int;
    for my $s (sort keys %$tz) {
        push @int, $s;
        my $v = $tz.>$s;
        Mojo::IOLoop->timer($s,&{
            1 && sayyl "Here again!";
            for my $y (@$v) {
                my ($Y,$cb) = @$y;
                1 && saybl "Comeback $s: ".G&sn,$Y;
                $cb->();
            }
        });
    }
    sayyl "Have timers at ".join", ", @int;
pi/GG: |
    Jc&save = 'W';
    -d "$s/p" || die "No $s/p";
    s&is = 'directory';
    y.at.dos = 'Clustout';
    
    my $eh = hitime();
    
    n see=>-listle_1=>$s,'qz'
    m _.t=>''=>{s=>_.t,fils=>$_},'dos:looking,ma:0.2' for G&op,'pi:fils';
    # ^ others, refind selves v
    n vokate=>-lookins_02
    
    #m _.t=>-GGo=>{s=>$C}
    y.u = 4;
    Js&Fur &&
    n Fur=>-od_8=>{s=>Js&Fur}
Fur: | # thing further and not
    return delete js&Fur if us&S;
    js&Fur = $c;
pi/GGo: | # identify your bits
    n t=>1=>C.t=>'fs:12,hs:488,dis'
    my $y = &C{ G&aC };
    my @l = G&ind:$s,$y;
    n s=>6=>wdump(\@l)
pi/gust: | # a look at a G
    # 

