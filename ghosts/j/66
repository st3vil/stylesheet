not: | # do everything! (run as Spec)
    Jc&tape = 1;
    
    Rw Tiot;
    # the sprawldy
    
    # to collect via T.has:
    Js&servetime = [];
    
    # to hang the sources of T rooms:
    my $def = 
    n hang=>-Trooms
    
    Rw GiveTime;
    G&timer:3,&{ 4s&toy ->({to=>[[C.t]]}) };
    
    
    n roms=>4=>Js&bowls++=>'%dis,fs:44'
    
    # watch own saves for open/close/plot T
    #   and the latest fork... shouldn't fork?
    
    # to get up Knowing T.has
    
    # must have own clock, to watch Cluster
    #   osc knows T.has.timing
    # making T:
    #   - left, what to incorporate into Normal/SunBeatling
    #   - right, what/where to write out
     
    # sprout clusters (bay) (GG), gusts (bay/wil) (G) and wormholes (W)
    #   bind wormhole with travel, ghost
GiveTime: | # release from reading input
    Gc&clockon = sub {
        1 && saybl "GiveTime: G.t";
        # turns Udder read loop into Baye read loop
        Gc&freetime = 1;
        n Baye
        Mojo::IOLoop->is_running || Mojo::IOLoop->start;
    };
pi/Trooms: |
    # C Trooms, instead of single items everywhere:
    n blank=>-clust=>'blank'
    
pi/clust: |
    -d "$s/p" || die "No $s/p";
    
    my $l = [
        map { my $C = G&Ct,$_; [
            Rw Exe
        ]}
        [proc=>''=>"$s/p"],
        [vall=>''=>"$s"],
    ];
    
    n seeing=>-od=>wdump 3,$l
    
    
pi/gust: | # see G
    # 
Exe: | # find bits for the show
    c&s =~ s/\/$//;
    c&do ||= 'l'; # or find
    c&do = 'ls -1' if c&do eq 'l';
    c&lsins = 1 if c&do =~ /^ls -1/ && c&s !~ /\*/;
    c&cmd ||= "c&do".(defined c&s && ' '.c&s);
    c&cmd .= "| grep c&grep" if c&grep;
    J.mo.J.sizeup = split"\n",''.`c&cmd` if c&sizeup;
    c&lim = 20 if !defined c&unl && !defined c&lim;
    c&cmd .= "| tail --lines=+".(c&se) if c&se ;
    c&cmd .= "| head -n ".(2*c&lim) if c&lim;
    my @img = split"\n",''.`c&cmd`;
    1 && say "EXE: c&cmd: ".@img;
    @img = grep {/^[\/\w\[\]\{\}\(\)!@%-]+\.jpe?g$/i} @img if c&only eq 'images';
    # reunlimit until lim is full of satis ^
    @img = @img[0..c&lim] if c&lim && c&lim < @img;
    my $i;
    @img = grep { !$i || $i++ >= c&skov ? do{$i=1} : 0 } @img
        if c&skov;
    c&simg = [@img] if c&lsins;
    @img = map {c&s.'/'.$_} @img if c&lsins;
    @img
    

