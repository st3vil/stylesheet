Packle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    # bel
    
    $ffmpeg = &{
        # the general overview
        # ! lost its code snippets
        # https://medium.com/@dernis/ffmpeg-tips-tricks-and-and-lessons-learned-a6f3c1187085
        # pics -> video
        # http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
        
        # hard disk image as block device
        # cp -a /dev/sdc windos
        # and mounted:
        # sudo losetup --partscan --find --show windos
        # sudo mount /dev/loop0p3 ups
    };
    
    =pod 
    
    dyn
    @media only screen and (max-width: 600px) {
      .col { 
        display: block;
        width: 100%;
      }
    }
    
    =cut
    #c Jay
    me.J = &acgtsq{
        # do a J
        $C = typeof s == 'string' && G&Cye,[s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        q = q && typeof q == 'object' ? q : {q:q,C:C};
        q.q == 'W' and c&W = c&J;
        
        $j = G&n,C,5;
        # C changes
        C = q.C = jc&s;
        $J = s&J;
        J.3 == J and j.3 = J
        
        4s&elvisory and me.JT(j,C,G,T)
        
        $Jlim = 40;
        4s&Jays++ == Jlim and ~OutofJ: ki(J);
        4s&Jays > Jlim and return C
        
        Js&paused and return C
        
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        Js&runs ||= 0;
        Js&runs++;
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        j.1 == j.3 and J.3 = J;
        
        # puts c&M
        c&M and me&Mwix,C; s&z ||= []; s&z.push(...c&M)
        delete c&M;
        
        me.os(j,C,G,T);
        
        return C;
    };
    
    # sweep towards 4 activities
    me.Ja.wobulus = &acgt{
        A&o = 'IndofC';
        
        4c&fps = 0.2;
        
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        
        if (!4s&famous) {
            $f = 4s&famous ||= {};
            f[4c&sip] = A.4;
        }
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'Fourier','W';
        
        4s&Fourieronlynow and delete 4s&Fourieronlynow; throw "async Fourier only"
        
        me&do_main;
        
        $on = 1s&on;
        !on and return;
        $N = $(on).children().get();
        $height = 0;
        each in N {
            height += $(n).height();
        }
        height = height * 1.4 + 500;
        $cb = &{ $(on).parent().css('min-height',height+'px'); };
        1s&elbowroom > height ?
            # shrink slowly
            G&yl,300,cb
        : cb();
        1s&elbowroom = height;
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # pitch time, run time, log saming
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    me.Ja.edges = &acgt{
        me&Gomp;
        
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        
        1s&spin ||= 0;
        1s&spin++;
        1s&spin > 2 and 1s&spin = -2
        $s = me&trampel,1s&spin;
        
        
        $be =
        n seen  $s:s %rovo:ning
        
        n ajaying  $s:be %rovo:ning
    };
    
    # facilitate_daydream
    # where the Js break up the gobes becomes a size thing
    # could end up walking z by usuality
    me.Ja.feel = &acgts{
        me&heading,'';
        A&o = 'Graze';
        s&med = 'cra';
        $z =
        s &&
        n seen  $s:s %rovo:ning
    };
    
    me.trampel = &acgtd{
        #d = 0;
        if (1 || !1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicone
            Skys the autumn grey of a lonely wrench

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    w == 'of' && d > 0 and z.lof = 'yea'; z.to={eo:{}};
                    w == 'to' && d < 0 and z.edea = C
                    z = z[w] ||= {};
                    w == 'to' && d < 2 and z.edgga = A.5;
                }
            }
            1s&es = s;
        }
        return 1s&es;
    };
    
    #c Eightwo
    # osc again with separate nests of R running schemes
    # the Js&s is an R:I
    #  R:C scans C
    #  CdaR etc think, R and scan more
    #    making R:Knowing, R:Display
    #      who might produce grounds...
    #  R:C displays, bits from  R:Display tacked in
    
    
    # to draw your own conclusion
    # the hierarchy of ground reactions takes hold
    
    # !!!!!!   !!!!!!!!!! !!!!!!!!!!   !!!   !!!!!!!!!! !!!!!!!!!!    
    # the osc is about functioning...
    # building the environment fully soon would be nice?
    # bundling elvisory, runs, output checks...
    #   testing without pumping html through the screen
    
    # the total applier of what is meaningful
    # the machine up to this point is lost vectoria notation
    # here we shall draw into an over-unity, as in
    #   GROWTHS
    
    # dispatch C has experience
    # it could be complete, as a work of art,
    # or it could be ingredients for several concealations
    # and then a work of art
    
    # s might be an elvis/A going wide
    # all the osc together escape linear code
        # atoms in locations, another lives
        
        # knowing atomic-level motion here,
        # and unfolding qua in another:
        # OSC 3, drawing out of what is
        #   to run rhythms over the atoms,
        #   thinking of their subatomic meanings
        # resuming whenever the list of atoms adjusts

        # < go wide and reuse elements moving around
        #   persisting moving atoms,
        #     based pictures of subatomics
        #     a b in the d.V index leaving?
        #   TES
        
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    
    me.os = &acgts{
        # A:n C
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
            # ^ could be the way to store elvis' progress as his own,
            # bringing their own s&s = R?
            #   a piece of reason to install where the state it was
        }
        # 2 J is name-recurring since n3
        s ||= s&J || A;
        $I = me&Resurrect,'I',ss&s;
        # < feeding I's history back around for runtime instruction
        #   C and e's history for storable such
        
        # 3 C are
        $r = Ron(I,'C',C,&Rs{
            1s&Te && Rc&d == 0 and Rs&Te = 1s&Te
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # generate furthers - notices J as yA1 different
            # < make CaR,R,s
            me&CaR,R,s;
        });
        
        # 6 details
        #  may do anything
        #$o = A&o ||= 'CdaR';
        A&o and me&Rdeal,r,A&o;
        # < bring them along
        
        # 7 encode visuals
        me&Cavon,r;
        # 8 unify visuals
        me&Cupon,r;
        # ^ committing them to dom on the screen
        
        
        #   we used to concat storable C patches (el)
        # we also commit the tip of all reason:
        # < pass X society's maintainence expectations
        # top R copies sc? as an inclusive RbitXgonism,R
        ss&s = I;
        # main R ness
        A&chR and rc&chR = A&chR;
        
        1s&Te and me&Tie,r,'os'
    };
    # GOING
    # do more R for an R
    me.Rdeal = &acgtRo{
        $o = o || s&Rdeal;
        o = o.split('-');
        each id o {
            !me[d] and throw "No os me."+d
            $r = me&$d,R;
            r and R = r
        }
        return R
    };
    # display R done
    me.Rdealings = &acgtRr{
        Rs&boust = 'Lines';
        me&sunknown,R,r
    };
    #c IndofC for total sense
    me.IndofC = &acgts{
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # replaces the C, breaking Elvising because no %medo on this one:
            # switch the elemental placer until we write on but it .C = origin
            $D = G&Cye,[C.t,'',{},{ml:Rc&d,dis:1}];
            Dc&s = me&picture,C;
            $r = Ron(R,'IndofC',D );
            me&Cavon,r;
            me&Cupon,r;
            # such that r.y.up has now s&down with out rs&on
        }
        
    };
    me.picture = &acgts{
        $Y = s.y.A;
        $usu = Y && Y.t == 'n';
        if (usu && sc&J && ss&J) {
            s = hup(s);
            sc&J == s.t and delete sc&J;
            sc&W == s.t and delete sc&W;
            #ss&W == s.t and delete ss&W;
            delete ss&z;


        }
        $k = ki(s);
        usu and k = k.replace(/,A;n/,'');
        return k
    };
    #c usuals
    # 2-ish data scan
    # < for C universals
    # < standard deviatable
    # < resolving and diving like diamonds
    me.CdaR = &acgts{
        # run the set of R into another Ring
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
    };
    #c sunknown GOING
    me.sunknown = &acgtRs{
        $b = Rc&b;
        $boust = Rs&boust;
        # look at.. a scan of the thing
        $s = s || c&s;
        typeof s != 'object' and throw "unknown!ob"
        $r = Ron(R,'Knowing',s,&Rs{
            Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 175;
            Rc&dl ||= 15;
        }, &Rs{
            $p = Ry&up;
            Rc&inC = R;
            $C = Rs&C = G&Cye,[R.t,'',{}];

            # this R can be clicked big/small
            me&boostulate,R;
            boust and R.t == boust and Rs&boost = 1

            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                $M = me&Mw,R,'traw';
                # make block,inline have same indento
                $iN = (ps&z||[]).indexOf(R) - 1;
                $f = iN >= 0 && ps&z[iN];
                f && fs&rowish and s&ml = 1
                s&fs = 7;
                m sym 12 not
                $pow = 2;
                Rs&boost and pow = 4;
                $string = ki(s,pow);
                string.length > 100 and string = string.substr(0,100)+'..'+(string.length - 100)
                m ki 3 $s:string
                return
            }

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });

            if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        });
        me&Display,r;
        return r
    };
    #c Display R ender
    # bunch of Rs with Mw etc get html'd under R.y.up
    #   for the R:Thingyoudo under the R:C visualising
    me.Display = &acgtr{
        me&Mlimits,r;

        each iR rc&N {
            # unify the M
            Rs&M ||= [];
            me&Mwix,R;
        }

        # and anotheR to Cavon those M Cs,
        # and get every nl/dl comoverable.
        $t = 'Display';
        #rs&task and t += ":"+rs&task
        $d = Ron(r,t,r,0,&Rs{
            Rc&nl = 0;
            !s.sc and debugger;
            $hop = ['C','nofurtherDisplay'];
            each it hop {
                # may be modulat, ie Ds&C = display stuff of D
                s.sc[t] and R.sc[t] = s.sc[t]
            }
            if (!Rs&modulat) {
                # to an R
                Ry&origin = s;
                ss&down and Rs&down ||= []; Rs&down.push(...ss&down);
                # slep could be in there ^ want to update it?
                if (ss&sleeping) {
                    Rs&originsleeping = 1;
                    Rs&nofurtherDisplay = 1;
                    # we'll try the dont-be-here strategy,
                    #  not this single R or its M will much awake
                    return;
                }
            }
            each iD ss&M {
                me&Ret,R,{t:D.t,s:D,modulat:1}
            }
            each iD ss&z {
                Rs&nofurtherDisplay and continue
                ss&J and Rs&J = ss&J; continue
                $r = me&Ret,R,{t:D.t,s:D};
                Rs&modulat and rs&modulat = 1;
            }
            #$C = Rs&C;
        });
        
        # the %rowish -> wholewidth + indent style
        # < stretch/shrink into a bunch of grapes, like W:Das
        # > runs out of width
        each in dc&N {
            ns&modulat and continue
            $s = nc&s;
            $C = ns&C || s;
            # keeps history
            # < modulats awaking as a faster layer of change
            #   those 82-4ish pile sorters give one M
            ns&originsleeping and me&recycleRbitXz,R
            
            !ss&rowish and continue
            
            s&dis = 1;
            nc&d and s&pl = 1
        }
        me&Cavon,d;
        # Display joins to another Displaying thing,
        #   as foretold by an rc&inC = R we can Rs&down to
        #   or 
        #   so R:Display (d) appends to its cause
        #     which would be an R:C, also Displaying
        #  leaving out Knowing (r), but routing elvis to it:
        d.y.interpreted = r;
        # < Display etc collector, map the whole Rillage
        d.y.up = rc&inC && (rc&inC != r && rc&inC
            || ry&up.c.inC) || r.y.up;
        r.y.Display = d;
        me&Cupon,d;
        return d
    };

