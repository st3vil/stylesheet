Packle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    # bel
    
    $ffmpeg = &{
        # the general overview
        # ! lost its code snippets
        # https://medium.com/@dernis/ffmpeg-tips-tricks-and-and-lessons-learned-a6f3c1187085
        # pics -> video
        # http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
    };
    #c Jay
    me.J = &acgts{
        # do a J
        $C = typeof s == 'string' && [s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        $j = G&n,C,5;
        C = jc&s;
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        
        if (c&M) {
            $cv = 0.3;
            $z = j.ground.sc.z;
            each in c&M {
                n.y.cv and continue
                # suggest y.cv of 30i+
                n.y.cv = G&desca,cv,8;
                cv += 0.001;
                z && z.indexOf(n) >= 0 and continue
                # do not re-C the C, or dups that == will in M occur
                #G&n,n;
            }
        }
        
        me.os(j,C,G,T);
        delete c&M;
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        #A&o = 'ind';
        A&o = 'IndofC';
        
        4c&fps = 0.3;
        
        // tayt #!!
        #=cut
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'Fourier';
        
        me&J,'edges';
    };
    
    me.Ja.Fourier = &acgt{
        A.3 = A.1;
        A&o = 'Elvising';
    
        me&J,['Fourier','-od',{s:A.4}];
        
        4s&elvising &&
            me&J,['elvising','-od',{s:4s&elvising},'elvising'];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # wants to leap onto new osc gear
    me.Ja.edges = &acgt{
        A.3 = A.1;
        n t  $s:C.t %fs:20,hs:594
        s&blr = 6;
        
        n things 2
        
        if (1 || !1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicone
            Skys the autumn grey of a lonely wren

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    w == 'of' and z.lof = 'yea'; z.to={eo:{}};
                    w == 'to' and z.edg = C
                    z = z[w] ||= {};
                }
            }
            1s&es = s;
        }
        $s = 1s&es;
        
        n vedge 3 s:vedge %fs:23,hs:594,dis
        $tricks = "gala <pre>vi   ous";
        n vedge 4 $s:tricks %fs:23,hs:894,dis
        n vedge 5 $s:tricks,ht:1 %fs:14,hs:694,dis
        
        me&J,['expr','-go',{s:s}];
        
    };
    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    # data sift/unpack/classify/pointerise with osc
    # be yinyander
    
    # - globe with C
    # - J os direct
    # - new A&o ind = indented ki trip
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be = me&J,['lookfortheedge','-globe',{s:s}];
        
        # and showing output
        
        $sc = {};
        $it = &ts{
            return me&J,[t,'44444'+i,{s:s,pi:'od'},ex({},sc)];
        };
        $j = bes&J;
        
        $I = js&s;
        it('R:I',I);
        
        it('Ic\&head',Ic&head);
        $grou = A.ground;
        $ii = 2;
        each tN Ic&head {
            sc.ml = 0.3;
            sc.hue = ii++ * 30;
            each iR N {
                A.ground = grou;
                $t = 'head'+t+i;
                #A.ground = # < makes things vanish?
                it(t,R);
                Rc&ha and it(t+'-ha',Rc&ha)
            }
        }
        # wants to be pointed to not coded
        return;
        each ic sc&chR {
            # continue;
            me&J,['ch:'+i,'-od',{s:c}];
        }
    };
    #c facilitate_daydream
    #  c&s should -> s&z til explains
    me.Ja.globe = &acgts{
        n t  $s:C.t %fs:20,hs:594
        # to lay out the sources for:
        # oscillate the looker/climber, parenting from A.gobe
        A&o = 'Gaze';
        n s  $s:s %unknown
        # where the Js break up the gobes becomes a size thing
        # could end up walking z by usuality
        n looks  $s:ki(s,7) %hs:298
        return;
        1s&counting ||= 1;
        
        1s&counting++;
        1s&counting > 5 and 1s&counting = 0;
        1s&counting > 3 &&
        n counts  s:counts
        s&medo = 'cra';
    };
    me.cra = &acgtD{
        $el = c&path_yon.slice(-1)[0];
        #debugger;
        #4s&elvising = C.c;
        ~etc: $(el).text();
    };
    
    #c Eightwo
    # osc again with separate oc-cu-lus nests,
    # the Js&s is an R:I
    #  R:C scans C
    #  CdaR etc think, R and scan more
    #    making R:Knowing, R:Display
    #      who might produce grounds...
    #  R:C displays, bits from  R:Display tacked in
    me.os = &acgts{
        # A:n C
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
            # ^ could be the way to store elvis' progress as his own,
            # bringing their own s&s = R?
            #   a piece of reason to install where the state it was
        }
        # 2 J is name-recurring since n3
        s ||= s&J || A;
        $I = me&Resurrect,'I',ss&s;
        # < feeding I's history back around for runtime instruction
        #   C and e's history for storable such
        
        # 3 C are
        $r = Ron(I,'C',C,&Rs{
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # generate furthers - notices J as yA1 different
            # < make CaR,R,s
            me&CaR,R,s;
        });
        
        if (C.t == 'lookfortheedge') {
            $R = me&Reis,r,'Pond';
        }
        
        # 6 details
        #  may do anything
        $o = A&o ||= 'CdaR';
        o = o.split(',');
        each id o {
            !me[d] and throw "No os me."+d
            me&$d,r
        }
        # < bring them along
        
        # 7 encode visuals
        me&Cavon,r;
        # 8 unify visuals
        me&Cupon,r;
        # ^ committing them to dom on the screen
        #   we used to concat storable C patches (el)
        # we also commit the tip of all reason:
        # < pass X society's maintainence expectations
        # top R copies sc? as an inclusive RbitXgonism,R
        ss&s = I;
        ss&X = Is&X;
        ss&CR = r;
        # main R ness
        rc&chR = A&chR;
    };
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    
    #c Ring R-ing
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        # grasp task, eg Pond
        rs&task = r.t;
        me&Ring,r;
    };
    
    # insert C to z after cv ==, before cv >
    $sortin = &zC{
        $i = 0;
        while (1) {
            $s = z[i];
            !s and return z.push(C)
            C.y.cv < s.y.cv and return z.splice(i,0,C)
            i > 100 and debugger;
            i++;
        }
    };
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&Rs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&Rs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        
        me[R.t](A,C,G,T,R).map(n => sortin(z,G&Cye,n ));
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    # Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        #debugger;
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        $busy = 1;
        $sheer = 500;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                busy = 0;
                continue
            }
            #c walk the tape, trying to do more
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # get its step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            
            hy&ov && hy&ov < ty&cv and debugger;
            
            # what the step is called
            if (Ic&head[t.t]) {
                # spawn to R:C
            }
            
            if (ts&if) {
                ts&if == 'RcX' and !Rc&X and continue
                else {
                    throw "if "+ts&if
                }
            }
            
            # doming? T hook any G&n via A.ground...?
            
            $cb = tc&s;
            !hak(R.c,'s') and debugger;
            
            cb(A,C,G,T,R,Rc&s);
            
            !Rc&nofurther and cz(R,zi)
            Rs&ci ++;
            
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    # overlap understandings
    me.Pond = &acgtM{
        return [
        ['She','1',&acgtRs{
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }],
        ['','3',&acgtRs{
            # generate furthers - notices J as yA1 different
            me&CaR,R,s;
        }],
        ['','6',&acgtRs{
            #~six: R.t
        }],
        ];
    };
    #c IndofC for total sense
    me.IndofC = &acgts{
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # replaces the C, breaking Elvising because no %medo on this one:
            # switch the elemental placer until we write on but it .C = origin
            $D = G&Cye,[C.t,'',{},{ml:Rc&d,dis:1}];
            Dc&s = me&picture,C;
            $r = Ron(R,'IndofC',D );
            me&Cavon,r;
            me&Cupon,r;
            # such that r.y.up has now s&down with out rs&on
        }
        
    };
    me.picture = &acgts{
        $Y = s.y.A;
        $usu = Y && Y.t == 'n';
        if (usu && sc&J && ss&J) {
            s = hup(s);
            sc&J == s.t and delete sc&J;
            sc&W == s.t and delete sc&W;
            #ss&W == s.t and delete ss&W;
            delete ss&z;


        }
        $k = ki(s);
        usu and k = k.replace(/,A;n/,'');
        return k
    };
    # for acting out new elvisings, in -od
    # 
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if (e.t == 'click' && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        $m = ns&medo;
                        !m and continue;
                        # not in C or A
                        me&$m,e;
                        break;
                    }
                }
            }
        }
    };
    # CdaR simple
    me.CdaR = &acgts{
        # run the set of R into another Ring
        # for C universals
        # resolving and diving like diamonds
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
    };
    
    #c Gaze complicated
    me.Gaze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        
        #~Glaze: A.1.t, ki(C)
        #me&Pond,s;
        
        # R motif leads to P, leads to R...
        # spring forth
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&unknown and continue
            typeof c&s != 'object' and throw "unknown!ob"
            
            # A&R, refs and refR keep all
            # < refs dupe ignore at R bounds, overlap understandings
            $r = Ron(R,'Knowing',c&s,&Rs{
                # index by R.t set by daR
                Rc&nl = 33;
            }, &Rs{
                # data/object awareness
                $scan = me&scan,s;
                # for low lighting
                $b = Rc&b;
                b && bs&checksame;
                # < once all to here, gonism juggles
                
                # 3 - generate interesto
                # how much to draw/fall in...
                #  these M might be named in future,
                #  compositive to 3s&Me, a tv of M bits
                #    good shape for magazine ladel
                $M = Rs&M ||= [];
                m t  $s:R.t %fs:13,hs:288
                $is = scan.is || scan.sym;
                m sym  $s:is %fs:15,mt:-0.1,ml:-0.1,zi:-1,hs:4955
                # etc, drawing/falling in as ...
                # osc G&n -od?
                if (scan.is) { # object
                    #m ki  $s:ki(s) %pa:2
                    #return
                    return M.push(me&J,[R.t,'-od',{s:s}] )
                    #m R.t -od $s:s
                }

                # generate furthers, until known?
                me&daR,R,s;
            });

            # and anotheR to Cavon those M Cs,
            $d = Ron(r,'Display',r,0,&Rs{
                #Rc&nl = 0;
                each iD ss&M {
                    me&Ret,R,{t:D.t,s:D,modulat:1}
                }
                each iD ss&z {
                    ss&J and Rs&J = ss&J; continue
                    me&Ret,R,({t:D.t,s:D})
                }
            });
            
            # throw styles over the 
            each in dc&N {
                ns&modulat and continue
                #ns&dis = 1
                # styles are coming from the Display R:
                $c = nc&s;
                #nc&d <= 1 and 
                cs&dis = 1; cs&ml = 1;
                cs&pa = '7px';
                
                #n.t == 'my' and ns&dis = 1;
            }
            
            # 7 display part
            me&Cavon,d;
            # 8 unify
            # join Display (d etc) directly under its cause (R)
            #  leaving out Knowing (r)
            d.y.interpreted = r;
            d.y.up = R;
            me&Cupon,d;
            
            Rs&what = "shall we? "+rc&N.length;
            Rs&disbit = d;
        }
        
    };
    #
    

