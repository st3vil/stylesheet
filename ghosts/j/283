Packle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    # bel
    
    $ffmpeg = &{
        # the general overview
        # ! lost its code snippets
        # https://medium.com/@dernis/ffmpeg-tips-tricks-and-and-lessons-learned-a6f3c1187085
        # pics -> video
        # http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
        
        # hard disk image as block device
        # cp -a /dev/sdc windos
        # and mounted:
        # sudo losetup --partscan --find --show windos
        # sudo mount /dev/loop0p3 ups
    };
    
    =pod 
    
    dyn
    @media only screen and (max-width: 600px) {
      .col { 
        display: block;
        width: 100%;
      }
    }
    
    =cut
    #c Jay
    me.J = &acgtsq{
        # do a J
        $C = typeof s == 'string' && G&Cye,[s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        q == 'W' and c&W = c&J;
        
        $j = G&n,C,5;
        C = jc&s;
        $J = s&J;
        J.3 == J and j.3 = J
        
        4s&elvisory and me.JT(j,C,G,T)
        
        $Jlim = 40;
        4s&Jays++ == Jlim and ~OutofJ: ki(J);
        4s&Jays > Jlim and return C
        
        Js&paused and return C
        
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        j.1 == j.3 and J.3 = J;
        
        # puts c&M
        c&M and me&Mwix,C; s&z ||= []; s&z.push(...c&M)
        
        me.os(j,C,G,T);
        delete c&M;
        
        return C;
    };
    
    # sweep towards 4 activities
    me.Ja.wobulus = &acgt{
        A&o = 'IndofC';
        
        4c&fps = 0.2;
        
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        
        if (!4s&famous) {
            $f = 4s&famous ||= {};
            f[4c&sip] = A.4;
        }
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'Fourier','W';
        
        me&J,'edges','W';
    };
    
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';
        
        4s&elvised = [];
        
        $l = 4s&elvising;
        !l and return
        me&J,['elvising','-feel',{s:l},'elvising,boost:sc,solvey'];
        #ls&solvey && 
        #me&J,['solvey','-feel',{s:ls&solvey}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # wants to leap onto new osc gear
    me.Gomp = &acgt{
        me&heading;
        A&o = 'Graze';
        s&med = 'cra';
    };
    # pitch time, run time, log saming
    # < A&sip must turn into a name for determinism
    # < waver accepts advances in trave...
    #   once off the path that sequences of trave indicate
    #   begin a new branch of trave,
    #     each named phase of things moresoer
    me.Ja.edges = &acgt{
        me&Gomp;
        
        me&J,'trave';
        
        $s = me&trampel;
        me&J,['expr','-go',{s:s}];
        
        me&J,'waver';
        
    };
    
    # from Elvisory, lines of adj, push/pull pit
    me.Ja.trave = &acgt{
        me&Gomp;
        
        # the universe
        n writ  $s:A.4 %unknown
        
        each tvJ 4s&Jtv {
             continue;
            n $t  $s:Jc&s %unknown
        }}
        
        # the orders
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        i $el/edges/expr
        el = ays&s[0];
        n Travel  $s:el %Rdeal:Gittoo
        
        #i $el/edges/vinga
        #ays&s[0].c.s = 'Blangtala';
        n splat  s:ForK
    };
    
    me.tee = &acgtt{
        #typeof t == 'string' and t = [[t]]
        
        $r = A.up.ground;
        !rs&z and return
        each in rs&z {
            n.t == t and return n
        }
    };
        
    me.Ja.waver = &acgt{
        me&Gomp;
        
        $expr = me&tee,'expr';
        n Wormhole  $s:expr %Rdeal:Gittoo
        
        # the output, input, yadda
        #elvisory
        $ty = 'stco elvised rubba'.split(' ');
        each it ty {
            $s = A.4.sc[t];
            !s and continue
            n $t  $s:s %unknown,noLines
        }
    };
    
    # data sift + self
    # be yinyander
    
    # - globe with C
    # - J os direct
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be = me&J,['lookfortheedge','-feel',{s:s}];
        
        me&J,['feel','-feel',{s:be}];
        # and showing output
        # wants to be pointed to not coded
        
        #$vi = me&J,['view','-og',{s:bey&R}];
    };
    
    # facilitate_daydream
    # where the Js break up the gobes becomes a size thing
    # could end up walking z by usuality
    me.Ja.feel = &acgts{
        me&heading,'';
        A&o = 'Graze';
        s&med = 'cra';
        s &&
        n seen  $s:s %unknown
    };
    

    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    
    #c yamble
    me.counting = &acgt{
        1s&counting ||= 1;
        
        1s&counting++;
        1s&counting > 5 and 1s&counting = 0;
        1s&counting > 3 &&
        n counts  s:counts
    }
    me.trampel = &acgt{
        if (0 || !1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicone
            Skys the autumn grey of a lonely wren

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    w == 'of' and z.lof = 'yea'; z.to={eo:{}};
                    w == 'to' and z.edg = C
                    z = z[w] ||= {};
                }
            }
            1s&es = s;
        }
        return 1s&es;
    };
    me.Ja.og = &acgts{
        me&heading;
        $sc = {};
        $it = &ts{
            return me&J,[t,'44444'+i,{s:s,pi:'od'},ex({},sc)];
        };
        $R = s;
        it('R',R);
        
        $I = R.y.up;
        it('I',I);
        
        it('Ichead',Ic&head);
        return;
        
        $I = c&s;
        $grou = A.ground;
        $ii = 2;
        each tN Ic&head {
            sc.ml = 0.3;
            sc.hue = ii++ * 30;
            each iR N {
                A.ground = grou;
                $t = 'head'+t+i;
                #A.ground = # < makes things vanish?
                it(t,R);
                Rc&ha and it(t+'-ha',Rc&ha)
            }
        }
        return;
        each ic sc&chR {
            # continue;
            me&J,['ch:'+i,'-od',{s:c}];
        }
    };
    #c Eightwo
    # osc again with separate nests of R running schemes
    # the Js&s is an R:I
    #  R:C scans C
    #  CdaR etc think, R and scan more
    #    making R:Knowing, R:Display
    #      who might produce grounds...
    #  R:C displays, bits from  R:Display tacked in
    
    
    # to draw your own conclusion
    # the hierarchy of ground reactions takes hold
    
    # !!!!!!   !!!!!!!!!! !!!!!!!!!!   !!!   !!!!!!!!!! !!!!!!!!!!    
    # the osc is about functioning...
    # building the environment fully soon would be nice?
    # bundling elvisory, runs, output checks...
    #   testing without pumping html through the screen
    
    # the total applier of what is meaningful
    # the machine up to this point is lost vectoria notation
    # here we shall draw into an over-unity, as in
    #   GROWTHS
    
    # dispatch C has experience
    # it could be complete, as a work of art,
    # or it could be ingredients for several concealations
    # and then a work of art
    
    # s might be an elvis/A going wide
    # all the osc together escape linear code
        # atoms in locations, another lives
        
        # knowing atomic-level motion here,
        # and unfolding qua in another:
        # OSC 3, drawing out of what is
        #   to run rhythms over the atoms,
        #   thinking of their subatomic meanings
        # resuming whenever the list of atoms adjusts

        # < go wide and reuse elements moving around
        #   persisting moving atoms,
        #     based pictures of subatomics
        #     a b in the d.V index leaving?
        #   TES
        
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    
    me.os = &acgts{
        # A:n C
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
            # ^ could be the way to store elvis' progress as his own,
            # bringing their own s&s = R?
            #   a piece of reason to install where the state it was
        }
        # 2 J is name-recurring since n3
        s ||= s&J || A;
        $I = me&Resurrect,'I',ss&s;
        # < feeding I's history back around for runtime instruction
        #   C and e's history for storable such
        
        # 3 C are
        $r = Ron(I,'C',C,&Rs{
            1s&Te && Rc&d == 0 and Rs&Te = 1s&Te
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # generate furthers - notices J as yA1 different
            # < make CaR,R,s
            me&CaR,R,s;
        });
        
        # 6 details
        #  may do anything
        #$o = A&o ||= 'CdaR';
        A&o and me&Rdeal,r,A&o;
        # < bring them along
        
        # 7 encode visuals
        me&Cavon,r;
        # 8 unify visuals
        me&Cupon,r;
        # ^ committing them to dom on the screen
        
        
        #   we used to concat storable C patches (el)
        # we also commit the tip of all reason:
        # < pass X society's maintainence expectations
        # top R copies sc? as an inclusive RbitXgonism,R
        ss&s = I;
        # main R ness
        rc&chR = A&chR;
        
        1s&Te and me&Tie,r,'os'
    };
    #c IndofC for total sense
    me.IndofC = &acgts{
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # replaces the C, breaking Elvising because no %medo on this one:
            # switch the elemental placer until we write on but it .C = origin
            $D = G&Cye,[C.t,'',{},{ml:Rc&d,dis:1}];
            Dc&s = me&picture,C;
            $r = Ron(R,'IndofC',D );
            me&Cavon,r;
            me&Cupon,r;
            # such that r.y.up has now s&down with out rs&on
        }
        
    };
    me.picture = &acgts{
        $Y = s.y.A;
        $usu = Y && Y.t == 'n';
        if (usu && sc&J && ss&J) {
            s = hup(s);
            sc&J == s.t and delete sc&J;
            sc&W == s.t and delete sc&W;
            #ss&W == s.t and delete ss&W;
            delete ss&z;


        }
        $k = ki(s);
        usu and k = k.replace(/,A;n/,'');
        return k
    };
    #c usuals
    # 2-ish data scan
    # < for C universals
    # < standard deviatable
    # < resolving and diving like diamonds
    me.CdaR = &acgts{
        # run the set of R into another Ring
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
    };
    
    # exit the entrance
    me.domesticate = &acgtR{
        $scan = Rs&scan;
        # 1
        $M = me&Mw,R,'traw';
        m t 1 $s:R.t %fs:13,hs:288
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955
        
        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    };
    me.bagatagage = &acgtR{
        $scan = Rs&scan;
        $ks = scan.ks || [];
        if (scan.C) {
            ks[0] != 't' and debugger;
            ks.shift();
            $s = Rc&s;

            $M = me&Mw,R,'.t';
            scan.is == 'A' &&
                m tofA 19 s:: %ls:-0.2

            m t 2 $s:s.t %deco,fs:15

            if (scan.is == 'A') {
                $cv = s.cv+'';
                cv[0] == '0' and cv = cv.slice(2);
                cv = '@'+cv;
                m cv 21 $s:cv %ls:-0.1,hs:339
            }
        }

        if (scan.modu) {
            each in scan.modu {
                n.t == 'weirdkeys' and continue
                $M = me&Mw,R,'modu:'+n.t;
                me&Modu,[n],M;
            }
        }
    };
    
    me.wktion = &acgtRs{
        $wk = s;
        s = Rc&s;
        $p = R.y.up;
        if (p && ps&scan && ps&scan.C) {
            if (R.t == 'c') {
                if (wk.indexOf('sip')>=0) {
                    wk = wk.filter(n => n != 'ip' && n != 'sip');
                    $fa = 4s&famous;
                    $slip = s.sip;
                    $M = me&Mw,R,'sip';
                    # tradeoff between things
                    if (fa) {
                        each in fa {
                            s.sip.indexOf(i) != 0 and continue
                            m famous  $s:n.t %deco,fs:7,hs:999
                            slip = '.'+s.sip.substr(i.length+1);
                        }
                    }
                    m sip  $s:slip %fs:7,hs:999
                }
            }
        }
        return wk
    };
    #c Graze - s&hook up
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        
        # R motif leads to P, leads to R...
        # spring forth
        
        $N = sc&N;
        each iR N {
            $C = Rc&s;
            
            #   yonder Displayers must y&up=R also getting Displayed
            #   to hang it on the screen
            Rc&inC = R;
            
            s&unknown and me&sunknown,R
            else
            s&Rdeal and $r = me&Rdeal,R;
            
            #1s&vigua and me&sunknown,R,1s&vigua; delete 1s&vigua;
            #me&Rdealings,R,r; me&Rdealings,R,R
        }
    };
    # do more R for an R
    me.Rdeal = &acgtRo{
        $o = o || s&Rdeal;
        o = o.split('-');
        each id o {
            !me[d] and throw "No os me."+d
            $r = me&$d,R;
            r and R = r
        }
        return R
    };
    # display R done
    me.Rdealings = &acgtRr{
        Rs&boust = 'Lines';
        me&sunknown,R,r
    };
    #c sunknown
    me.sunknown = &acgtRs{
        $b = Rc&b;
        $boust = Rs&boust;
        # look at.. a scan of the thing
        $s = s || c&s;
        typeof s != 'object' and throw "unknown!ob"
        $r = Ron(R,'Knowing',s,&Rs{
            Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 175;
            Rc&dl ||= 15;
        }, &Rs{
            $p = Ry&up;
            Rs&inC = R;
            $C = Rs&C = G&Cye,[R.t,'',{}];

            # this R can be clicked big/small
            me&boostulate,R;
            boust and R.t == boust and Rs&boost = 1

            
            $scan = Rs&scan = me&scan,s,R;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                $M = me&Mw,R,'traw';
                # make block,inline have same indento
                $iN = (ps&z||[]).indexOf(R) - 1;
                $f = iN >= 0 && ps&z[iN];
                f && fs&rowish and s&ml = 1
                s&fs = 7;
                m sym 12 not
                $pow = 2;
                Rs&boost and pow = 4;
                $string = ki(s,pow);
                string.length > 100 and string = string.substr(0,100)+'..'+(string.length - 100)
                m ki 3 $s:string
                return
            }

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;
            
            Rc&nofurther and return

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            
            wk = me&wktion,R,wk;
            
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1};
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });

            if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        });
        me&Display,r;
        return r
    };
    #c Display R ender
    # bunch of Rs with Mw etc get html'd under R.y.up
    #   for the R:Thingyoudo under the R:C visualising
    me.Display = &acgtr{
        me&Mlimits,r;

        each iR rc&N {
            # unify the M
            Rs&M ||= [];
            me&Mwix,R;
        }

        # and anotheR to Cavon those M Cs,
        # and get every nl/dl comoverable.
        $t = 'Display';
        rs&task and t += ":"+rs&task
        $d = Ron(r,t,r,0,&Rs{
            Rc&nl = 0;
            !s.sc and debugger;
            each iD ss&M {
                me&Ret,R,{t:D.t,s:D,modulat:1}
            }
            each iD ss&z {
                ss&J and Rs&J = ss&J; continue
                $r = me&Ret,R,{t:D.t,s:D};
                Rs&modulat and rs&modulat = 1;
            }
            if (!Rs&modulat) {
                # original atom, s = R
                ss&down and Rs&down ||= []; Rs&down.push(...ss&down);
            }
            ss&C and Rs&C = ss&C;
            #$C = Rs&C;
        });
        # throw styles over the 
        each in dc&N {
            ns&modulat and continue
            $c = nc&s;
            !cs&rowish and continue
            $C = ns&C || c;
            s&dis = 1; s&ml = 1;
            s&pa = '7px';
        }
        me&Cavon,d;
        # Display joins to another Displaying thing,
        #   as foretold by an rc&inC = R we can Rs&down to
        #   or 
        #   so R:Display (d) appends to its cause
        #     which would be an R:C, also Displaying
        #  leaving out Knowing (r), but routing elvis to it:
        d.y.interpreted = r;
        # < Display etc collector, map the whole Rillage
        d.y.up = rc&inC && (rc&inC != r && rc&inC
            || ry&up.c.inC) || r.y.up;
        r.y.Display = d;
        me&Cupon,d;
        return d
    };
    #c Gittoo - C -> Git elvis
    
    # string+destring, place-place
    me.Gittoo = &acgtR{
        $got = me&enLinesR,R,c&s;
        $exp = me&deLinesR,R,C.t;
        $o = C;

        $r = Ron(R,'Gittoo',R,&Rs{
            Rc&d == 0 and R.t = C.t
        },&Rs{
            Rc&inC = R; # tells inner Displays to hoist to here
            $C = Rs&C = G&Cye,[R.t,'',{}];
            me&boostulate,R;
            $Re = &tsg{
                return me&Ret,R,{t:t,s:s,g:g||'sunknown'};
            };
            
            if (Rs&g == 'diff') {
                me&diffLines,R,got,exp;
                return;
            }
            
            $M = me&Mw,R,'traw';
            m te 1 $s:R.t %fs:13,hs:288
            Rc&d == 0 &&
            m doe 1 s:Gittoo %fs:11,hs:688
            
            if (!Rs&g) {
                Rs&rowish = 1;
                Re('Here',got,'compare');
                Re('Diff','','diff');
                Re('There',exp,'compare');
            }
            elsif (Rs&g == 'sunknown') {
                Rs&rowish = 1;
                m onemore  s:sunknown
                $r = me&sunknown,R,s
            }
            elsif (Rs&g == 'compare') {
                Rs&rowish = 1;
                m dige  $s:ss&dige %hs:588
                
                ss&Lines and Re('Lines',ss&Lines,'lines');
                
                if (sc&ha) {
                    Re('Ohno',sc&ha,'sunknown');
                    m errors  s:errors? %fs:18
                    return
                }
                
                !Rs&boost and return
                delete Rs&Te.sc.boost
                if (s == got) {
                    # push to storage
                    localStorage[expc&s] = gots&string
                }
                else {
                    # deserialise and set into live
                    $C = got.c.s.c.s;
                    $D = exps&vivify();
                    exps&vivify and ex(C,D)
                    else {
                        throw "how to read "+exp.t
                    }
                }
            }
            elsif (Rs&g == 'lines') {
                $M = me&Mw,R,'geo';
                $top = s [0];
                m top  $s:top %fs:6,hs:797
                $len = 'x'+s.length;
                m nolines  $s:len
                
                !Rs&boost and return
                Rs&rowish = 1;
                $M = me&Mw,R,'stuff';
                each in s {
                    m line  $s:n %dis,fs:6,hs:797
                }
            }
        });
        me&Display,r;
        return r
    };
    # a juice - bioavailability of A prog C
    # grab moment S, giving some kind of housing
    # lexicals hang around,
    # -the end- of computer science
    # scene collapses into bubble
    # try to get back to some kind of housing
    # security is being stuck on the outside of some jeweled cavity
    # 
    # once done a bunch of something, you can look at them.
    # as gravity.
    
    # reduce sunknownness
    me.KnowR = &acgtRr{
        $r = Ron(R,'KnowR',(r||R),0,&Rs{
            Rc&inC = R; # tells inner Displays to hoist to here
            $C = Rs&C = G&Cye,[R.t,'',{}];

            # this R can be clicked big/small
            me&boostulate,R;

            $M = me&Mw,R,'traw';
            m t 1 $s:s.t %fs:13,hs:288
            m sym 12 s:R %fs:15,ls:-0.1,zi:-1,hs:4955
            
            me&sunknown,R,s.sc;
            
            
            Rs&rowish = 1;
        });
        me&Display,r;
    };
    
    #c diffLines
    me.rollbs = &acgtRs{
        $b = Rc&b;
        !b and return
        s = s.split(',');
        each ik s {
            hak(b.sc,k) and R.sc[k] = b.sc[k]
        }
    };
    me.diffLines = &acgtRgx{
        $b = Rc&b;
        $M = me&Mw,R,'diff';
        s&ws = 'pre';
        s&fs = 7;
        s&wb = 'break-word';
        s&hue = '80deg';
        if (gs&string == xs&string) {
            m equal  s:= %fs:45,ab
            return
        }
        m notequal  s:~ %fs:45,ab

        # switch chunk: word/line
        
        me&rollbs,R,'Digs,Diff,CompN,Comp';
        $digs = dig(xs&string||'')+dig(gs&string||'')+dig(ki(c));
        Rs&Digs != digs and delete Rs&Diff; 
        Rs&Digs = digs;

        # the job
        $c = {chunk:'word',fold:1};
        $N = Rs&Diff ||= diff(xs&string,gs&string,c);

        # CompN - sum noise
        Rs&CompN != N and delete Rs&Comp;
        if (!Rs&Comp) {
            Rs&Comp = me&textdiffN,N,c;
            Rs&CompN = N;
        }
        
        #debugger;
        #me&sunknown,R,Rs&Comp;
        me&diffproximate,R;
        
        !Rs&boost and return
        
        $W = Rs&Comp;
        
        #me&Ret,R,{}
        #.c.middle = &Rs{
            M = me&Mw,R,'difftext';
            M.push(...W)
        #};
    };
    me.diffproximate = &acgtR{
        # how many lines +- approx
        $M = me&Mw,R,'diffproximate';
        $h = {};
        $diff = 0;
        each in Rs&Comp {
            if (nc&s.indexOf("\n") < 0) {
                # in-line boundary means something is changing, a little
                # note that once per line
                if (!diff) {
                    h.diff ||= 0;
                    h.diff++;
                    diff = 1;
                }
            }
            else {
                diff = 0;
            
                $Lines = nc&s.split("\n");
                $lines = Lines.length;
                Lines.slice(-1)[0] == '' and lines--
                h[n.t] ||= 0;
                h[n.t] += lines;
            }
        }
        $k = G&peel,'new:+,diff:~,gone:-,same:=';
        each is k {
            $n = h[i];
            !n and continue
            $s = s+n;
            $C =
            m $i  $s:s %fs:45
            C.t == 'new' and s&hue = '265deg';
            C.t == 'gone' and s&hue = '111deg';
            C.t == 'diff' and s&hue = '55deg';
        }
        # < putting yay many things approximately where they are,
        # < putting in names shaded to their thisthatty
    };
    #c textdiffN - clean up/fold
    me.textdiffN = &acgtNc{
        $M = [];
        each in N {
            $m =
            m bit  $s:nc&s %
            m.t = n.t;
            n.t == 'new' and ms&hue = '265deg';
            n.t == 'gone' and ms&hue = '111deg';

            ms&hue and continue
            !c.fold and continue
            $s = mc&s;
            s.length < 40 and continue
            if (0 && !s.match(/\n/)) {
                ms&shortfor = [s];
                mc&s = s.slice(0,20)+" ... "+s.slice(-20);
            }
            else {
                $L = s.split("\n");
                $las = L.pop();
                L = L.map(&s{ return s+"\n" });
                las != '' and L.push(las);
                $w = []; # to be
                # fold ind level
                # deep is shallow+1, when shallow bit grouper found
                $deep;
                $la;
                $finalN = i*1+1 == N.length;
                $firstN = i == 0;
                each il L {
                    # not 3 lines near a change
                    if ((firstN || i > 1) &&
                        (finalN || i < L.length - 3)) {
                        if (deep && l.match(deep)) {
                            !la and throw "no la";
                            $sh =
                            las&shortfor ||= [];
                            sh.push(l);
                            continue;
                        }
                    }
                    la = null;
                    w.push(l);
                    $shall = l.match(/^(  +)/);
                    if (shall) {
                        deep = new RegExp('^'+shall[1]+'  ');
                        la =
                        m $m.t  $s:w.join("") %
                        w = [];
                    }
                }
                mc&s = w.join("");
            }
        } 
        each in M {
            ns&hue || ns&bri and continue
            # shortened inside lines
            $text = ns&shortfor;
            !text and continue
            # falsify a heading, 't y ... +n':
            $m = nc&s.match(/^(  \S[^\t]*\t[^\t]*\t)/);
            if (m) {
                text.unshift(nc&s);
                nc&s = m[1] + " ... +"+(text.length-1);
                nc&s += "\n";
            }
            else { # never misses? 
                #
            }
            !text.join and debugger;
            ns&shortfor = text.join("");
            ns&fs = '80%';
            ns&bri = 0.6;
            ns&dow = 'do/Swaps';
        }
        return M;
    };
    
    #c writing
    # R:C, see os 3 C are
    #   CaR stops at Js, this does not
    me.Care = &acgtRs{
        $r = Ron(R,'C',s,&Rs{
            Rc&nl = 900;
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # < make CaR,R,s know J bounds
            if (ss&z) {
                each iD ss&z {
                    !D and continue
                    me&Ret,R,{s:D}
                }
            }
            elsif (sy&R && sy&R.sc.down) {
                # < os should maintain clones,
                #  whole self after C hoistins
                # hop in the C<->sunknowning boundary
                each ir sy&R.sc.down {
                    #r.t == 'Display' and debugger;
                    rs&C and rs&C.y.R = r;
                    me&Ret,R,{s:rs&C||rc&s}
                }
            }
        });
        return r
    };
    # makes copies of an R:C and its innards
    # new Rc&s = old r
    # new Rs&C = old C
    me.TakeC = &acgtRtc{
        $h = Rc&N[0];
        c ||= {};
        c.x == null and c.x = 'C'
        c.x && hs&task != c.x and throw "R:"+t+" takes R:"+c.x
        return Ron(R,t,R,0,&Rr{
            Rc&nl = 900;
            $C = Rs&C = rs&C || rc&s;
            c.cb && c.cb(R,r,C);
            R.c.not and return
            $targ = c.z ? rs&z : rs&down || rs&z;
            !targ and return
            each iD targ {
                me&Ret,R,{t:D.t,s:D};
            }
        });
    };
    #c stringify pool
    me.enLinesR = &acgtRs{
        $c = me&Care,R,s;
        $cb = &RrC{
            s&noLines and Rc&nofurther = 1
        };
        $r = me&TakeC,c,'enLinesR',{cb:cb};
        $ers = [];
        each iR rc&N {
            $b = Rc&b;
            $C = Rs&C;
            $part;
            try {
                part = 'scan';
                $scan = Rs&scan = me&scan,C;
                scan.is != 'C' and throw "Not C"
                Cc&N and throw "mightbe R"
                # ^ Care-ing for an unconscious R in z?
                #     if Rs&C wasn't made, Rc&s = Rousce
                #   as if Rc&nofurther + s&z emit, they may show up...
                
                part = 'clone';
                Rs&OC = C;
                typeof C.y != 'object' and throw "NotC";
                C = Rs&C = G&Cye,C;
                
                part = 'comp';
                # comp && comp(C,R,b);
                R.c.not and return
                
                part = 'Compress';
                G&Compress,C;
                
                part = 'toLines';
                Rs&toLines = G&toLines,C;
            }
            catch (er) {
                ~enLinesR: ki(C,2)+"   !"+part+"! "+er
                me&Rec,R,'err';
                Rs&toLines = "[error} "+ki(C);
                Rs&err = "enLinesR: "+part+": "+er;
                
            }
        }
        $rN = rc&N.slice().reverse();
        rs&Lines = [];
        each iR rN {
            $ind = '';
            $i = 0;
            while (i < Rc&d) { ind += '  '; i++ }
            $l = Rs&toLines.split("\n")
                .map(l => ind+l).join("\n");
            #l += "\n";
            rs&Lines.unshift(l);
        }
        rs&string = rs&Lines.join("\n")+"\n";
        rs&dige = dig(rs&string);
        return r
    };
    me.deLinesR = &acgtRs{
        return Ron(R,'deLinesR',s,0,&Rs{
            if (typeof s != 'object') {
                s = localStorage[s]
                !s and Rs&notfound = 1; return
                $b = Rc&b;
                Rs&string = s;
                # sleep if bs&string == Rs&string
                Rs&Lines = Rs&string.split("\n");
                Rs&Lines.slice(-1)[0] == '' and Rs&Lines.pop();
                Rs&dige = dig(s);
                
                Rs&vivify = &{
                    $N = G&readLines,s;
                    return N[0]
                };
                return; # just do ^ when pulled
                # later, boost ripples back here,
                # growing our nativising idea of this remote...
                $N = G&readLines,s;
                each iD N {
                    me&Ret,R,{t:D.t,s:D};
                }
            }
            else {
                each iD ss&z {
                    me&Ret,R,{t:D.t,s:D};
                }
            }
        });
    
    };

