Packle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    # bel
    
    $ffmpeg = &{
        # the general overview
        # ! lost its code snippets
        # https://medium.com/@dernis/ffmpeg-tips-tricks-and-and-lessons-learned-a6f3c1187085
        # pics -> video
        # http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
    };
    
    =pod 
    
    dyn
    @media only screen and (max-width: 600px) {
      .col { 
        display: block;
        width: 100%;
      }
    }
    
    =cut
    #c Jay
    me.J = &acgtsq{
        # do a J
        $C = typeof s == 'string' && G&Cye,[s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        q == 'W' and c&W = c&J;
        
        $j = G&n,C,5;
        C = jc&s;
        $J = s&J;
        J.3 == J and j.3 = J
        
        4s&elvisory and me.JT(j,C,G,T)
        
        $Jlim = 40;
        4s&Jays++ == Jlim and ~OutofJ: ki(J);
        4s&Jays > Jlim and return C
        
        Js&paused and return C
        
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        j.1 == j.3 and J.3 = J;
        
        # puts c&M
        c&M and me&Mwix,C; s&z ||= []; s&z.push(...c&M)
        
        me.os(j,C,G,T);
        delete c&M;
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        A&o = 'IndofC';
        
        4c&fps = 0.2;
        
        // tayt #!!
        #=cut
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'edges','W';
        
        me&J,'Fourier','W';
        
    };
    
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';
        
        4s&elvised = [];
        
        $l = 4s&elvising;
        !l and return
        me&J,['elvising','-feel',{s:l},'elvising,boost:sc,solvey'];
        #ls&solvey && 
        #me&J,['solvey','-feel',{s:ls&solvey}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # wants to leap onto new osc gear
    me.Gomp = &acgt{
        me&heading;
        A&o = 'Graze';
        s&med = 'cra';
    };
    me.Ja.edges = &acgt{
        me&Gomp;
        
        me&J,'trave';
        
        $s = me&trampel;
        me&J,['expr','-go',{s:s}];
        
        me&J,'waver';
        
    };
    
    # from Elvisory, lines of adj, push/pull pit
    me.Ja.trave = &acgt{
        me&Gomp;
        
        # the universe
        n writ  $s:A.4 %unknown
        
        each tvJ 4s&Jtv {
             continue;
            n $t  $s:Jc&s %unknown
        }}
        
        # the orders
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        n Travel  $s:el %Rdeal:csC-Gittoo
        
        #i $el/edges/vinga
        #ays&s[0].c.s = 'Blangtala';
        
    };
    
    me.tee = &acgtt{
        #typeof t == 'string' and t = [[t]]
        $r = A.up.ground;
        !rs&z and return
        each in rs&z {
            n.t == t and return n
        }
    };
        
    me.Ja.waver = &acgt{
        me&Gomp;
        
        $expr = me&tee,'expr';
        n Wormhole  $s:expr %Rdeal:csC-Gittoo
        
        # the output, input, yadda
        #elvisory
        $ty = 'stco elvised'.split(' ');
        each it ty {
            $s = A.4.sc[t];
            !s and continue
            n $t  $s:s %unknown,noLines
        }
    };
    
    # data sift + self
    # be yinyander
    
    # - globe with C
    # - J os direct
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be = me&J,['lookfortheedge','-feel',{s:s}];
        
        me&J,['feel','-feel',{s:be}];
        # and showing output
        # wants to be pointed to not coded
        
        #$vi = me&J,['view','-og',{s:bey&R}];
    };
    
    # facilitate_daydream
    # where the Js break up the gobes becomes a size thing
    # could end up walking z by usuality
    me.Ja.feel = &acgts{
        me&heading;
        A&o = 'Graze';
        s&med = 'cra';
        s &&
        n seen  $s:s %unknown
    };
    

    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    
    #c yamble
    me.counting = &acgt{
        1s&counting ||= 1;
        
        1s&counting++;
        1s&counting > 5 and 1s&counting = 0;
        1s&counting > 3 &&
        n counts  s:counts
    }
    me.trampel = &acgt{
        if (0 || !1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicone
            Skys the autumn grey of a lonely wren

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    w == 'of' and z.lof = 'yea'; z.to={eo:{}};
                    w == 'to' and z.edg = C
                    z = z[w] ||= {};
                }
            }
            1s&es = s;
        }
        return 1s&es;
    };
    me.Ja.og = &acgts{
        me&heading;
        $sc = {};
        $it = &ts{
            return me&J,[t,'44444'+i,{s:s,pi:'od'},ex({},sc)];
        };
        $R = s;
        it('R',R);
        
        $I = R.y.up;
        it('I',I);
        
        it('Ichead',Ic&head);
        return;
        
        $I = c&s;
        $grou = A.ground;
        $ii = 2;
        each tN Ic&head {
            sc.ml = 0.3;
            sc.hue = ii++ * 30;
            each iR N {
                A.ground = grou;
                $t = 'head'+t+i;
                #A.ground = # < makes things vanish?
                it(t,R);
                Rc&ha and it(t+'-ha',Rc&ha)
            }
        }
        return;
        each ic sc&chR {
            # continue;
            me&J,['ch:'+i,'-od',{s:c}];
        }
    };
    #c Eightwo
    # osc again with separate nests of R running schemes
    # the Js&s is an R:I
    #  R:C scans C
    #  CdaR etc think, R and scan more
    #    making R:Knowing, R:Display
    #      who might produce grounds...
    #  R:C displays, bits from  R:Display tacked in
    
    
    # to draw your own conclusion
    # the hierarchy of ground reactions takes hold
    
    # !!!!!!   !!!!!!!!!! !!!!!!!!!!   !!!   !!!!!!!!!! !!!!!!!!!!    
    # the osc is about functioning...
    # building the environment fully soon would be nice?
    # bundling elvisory, runs, output checks...
    #   testing without pumping html through the screen
    
    # the total applier of what is meaningful
    # the machine up to this point is lost vectoria notation
    # here we shall draw into an over-unity, as in
    #   GROWTHS
    
    # dispatch C has experience
    # it could be complete, as a work of art,
    # or it could be ingredients for several concealations
    # and then a work of art
    
    # s might be an elvis/A going wide
    # all the osc together escape linear code
        # atoms in locations, another lives
        
        # knowing atomic-level motion here,
        # and unfolding qua in another:
        # OSC 3, drawing out of what is
        #   to run rhythms over the atoms,
        #   thinking of their subatomic meanings
        # resuming whenever the list of atoms adjusts

        # < go wide and reuse elements moving around
        #   persisting moving atoms,
        #     based pictures of subatomics
        #     a b in the d.V index leaving?
        #   TES
        
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    
    me.os = &acgts{
        # A:n C
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
            # ^ could be the way to store elvis' progress as his own,
            # bringing their own s&s = R?
            #   a piece of reason to install where the state it was
        }
        # 2 J is name-recurring since n3
        s ||= s&J || A;
        $I = me&Resurrect,'I',ss&s;
        # < feeding I's history back around for runtime instruction
        #   C and e's history for storable such
        
        # 3 C are
        $r = Ron(I,'C',C,&Rs{
            1s&Te && Rc&d == 0 and Rs&Te = 1s&Te
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # generate furthers - notices J as yA1 different
            # < make CaR,R,s
            me&CaR,R,s;
        });
        
        # 6 details
        #  may do anything
        #$o = A&o ||= 'CdaR';
        A&o and me&Rdeal,r,A&o;
        # < bring them along
        
        # 7 encode visuals
        me&Cavon,r;
        # 8 unify visuals
        me&Cupon,r;
        # ^ committing them to dom on the screen
        
        
        #   we used to concat storable C patches (el)
        # we also commit the tip of all reason:
        # < pass X society's maintainence expectations
        # top R copies sc? as an inclusive RbitXgonism,R
        ss&s = I;
        # main R ness
        rc&chR = A&chR;
        
        1s&Te and me&Tie,r,'os'
    };
    #c IndofC for total sense
    me.IndofC = &acgts{
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # replaces the C, breaking Elvising because no %medo on this one:
            # switch the elemental placer until we write on but it .C = origin
            $D = G&Cye,[C.t,'',{},{ml:Rc&d,dis:1}];
            Dc&s = me&picture,C;
            $r = Ron(R,'IndofC',D );
            me&Cavon,r;
            me&Cupon,r;
            # such that r.y.up has now s&down with out rs&on
        }
        
    };
    me.picture = &acgts{
        $Y = s.y.A;
        $usu = Y && Y.t == 'n';
        if (usu && sc&J && ss&J) {
            s = hup(s);
            sc&J == s.t and delete sc&J;
            sc&W == s.t and delete sc&W;
            #ss&W == s.t and delete ss&W;
            delete ss&z;


        }
        $k = ki(s);
        usu and k = k.replace(/,A;n/,'');
        return k
    };
    #c usuals
    # 2-ish data scan
    # < for C universals
    # < standard deviatable
    # < resolving and diving like diamonds
    me.CdaR = &acgts{
        # run the set of R into another Ring
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
    };
    
    # exit the entrance
    me.domesticate = &acgtR{
        $scan = Rs&scan;
        # 1
        $M = me&Mw,R,'traw';
        m t 1 $s:R.t %fs:13,hs:288
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955
        
        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    };
    me.bagatagage = &acgtR{
        $scan = Rs&scan;
        $ks = scan.ks || [];
        if (scan.C) {
            ks[0] != 't' and debugger;
            ks.shift();
            $s = Rc&s;

            $M = me&Mw,R,'.t';
            scan.is == 'A' &&
                m tofA 19 s:: %ls:-0.2

            m t 2 $s:s.t %deco,fs:15

            if (scan.is == 'A') {
                $cv = s.cv+'';
                cv[0] == '0' and cv = cv.slice(2);
                cv = '@'+cv;
                m cv 21 $s:cv %ls:-0.1,hs:339
            }
        }

        if (scan.modu) {
            each in scan.modu {
                n.t == 'weirdkeys' and continue
                $M = me&Mw,R,'modu:'+n.t;
                me&Modu,[n],M;
            }
        }
    };
    #c Graze - s&hook up
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        
        # R motif leads to P, leads to R...
        # spring forth
        
        $N = sc&N;
        each iR N {
            $C = Rc&s;
            
            s&unknown and me&sunknown,R
            else
            s&Rdeal and $r = me&Rdeal,R; me&Rdealings,R,r
        }
    };
    # do more R for an R
    me.Rdeal = &acgtRo{
        $o = o || s&Rdeal;
        o = o.split('-');
        each id o {
            !me[d] and throw "No os me."+d
            $r = me&$d,R;
            r and R = r
        }
        return R
    };
    # display R done
    me.Rdealings = &acgtRr{
        Rs&boust = 'Lines';
        me&sunknown,R,r
    };
    #c sunknown
    me.sunknown = &acgtRs{
        $b = Rc&b;
        $boust = Rs&boust;
        $upw = R;
        # look at.. a scan of the thing
        $s = s || c&s;
        typeof s != 'object' and throw "unknown!ob"
        $r = Ron(R,'Knowing',s,&Rs{
            Rc&d == 0 and R.t = C.t;
            # index by R.t set by daR
            Rc&nl ||= 175;
            Rc&dl ||= 15;
        }, &Rs{
            $p = Ry&up;    
            $C = Rs&C = G&Cye,[R.t,'',{}];

            # this R can be clicked big/small
            me&boostulate,R;
            boust and R.t == boust and Rs&boost = 1

            $scan = Rs&scan = me&scan,s;

            me&domesticate,R;

            # decision of presentation
            p && ps&isnk || Rs&isgk and Rs&isgk = 1
            p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
            # boost overrides tendency to isgk weirdkeys
            Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
            R.t == 'y' and delete Rs&rowish;
            Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
            scan.sym == "'" and Rs&isgk = 1;

            if (Rs&isgk) {
                $M = me&Mw,R,'traw';
                # make block,inline have same indento
                $iN = (ps&z||[]).indexOf(R) - 1;
                $f = iN >= 0 && ps&z[iN];
                f && fs&rowish and s&ml = 1
                s&fs = 7;
                m sym 12 not
                $pow = 2;
                Rs&boost and pow = 4;
                m ki 3 $s:ki(s,pow)
                return
            }

            # bunch of keys claimed by Modus&ks=[]
            # < pluck them, bending the last representation outwards
            # < or popping it in the short term... Rs wakier
            #   wanting child boost read by the time we're here,
            #   to choose whether to Modu or RetR
            me&bagatagage,R;

            $ks = scan.ks || [];
            $wk = scan.weirdkeys || [];
            each ik wk {
                $n = me&Ret,R,{t:k,s:s[k],isgk:1}; #]
                i == 0 and ns&ml = 1
            }

            ks && ks.length && ks.map(&k{
                $v = s [k];
                me&Ret,R,{t:k,s:s[k],rowish:1}; #]
            });

            if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                each in ss&z {
                    me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                }
            }
        });
        #
        me&Mlimits,r;

        each iR rc&N {
            # unify the M
            Rs&M ||= [];
            me&Mwix,R;
        }

        # and anotheR to Cavon those M Cs,
        # and get every nl/dl comoverable.
        $d = Ron(r,'Display',r,0,&Rs{
            Rc&nl = 0;
            !s.sc and debugger;
            each iD ss&M {
                me&Ret,R,{t:D.t,s:D,modulat:1}
            }
            each iD ss&z {
                ss&J and Rs&J = ss&J; continue
                $r = me&Ret,R,{t:D.t,s:D};
                Rs&modulat and rs&modulat = 1;
            }
            ss&C and Rs&C = ss&C;
            #$C = Rs&C;
        });
        # throw styles over the 
        each in dc&N {
            ns&modulat and continue
            $c = nc&s;
            !cs&rowish and continue
            $C = ns&C || c;
            s&dis = 1; s&ml = 1;
            s&pa = '7px';
        }
        me&Cavon,d;
        # join Display (d etc) directly under its cause (R)
        #  leaving out Knowing (r)
        d.y.interpreted = r;
            d.y.up = upw;
            me&Cupon,d;
    };
    #c Gittoo - C -> Git elvis
    # minimal R:C for c&s
    me.csC = &acgtR{
        # < imply R's many if R==h
        return me&Care,R,c&s
    };
    # R:C, see os 3 C are
    #   CaR stops at Js, this does not
    me.Care = &acgtRs{
        $r = Ron(R,'C',s,&Rs{
            Rc&nl = 900;
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # < make CaR,R,s know J bounds
            if (ss&z) {
                each iD ss&z {
                    !D and continue
                    me&Ret,R,{s:D}
                }
            }
            elsif (sy&R && sy&R.sc.down) {
                # < os should maintain clones,
                #  whole self after C hoistins
                # hop in the C<->sunknowning boundary
                each ir sy&R.sc.down {
                    #r.t == 'Display' and debugger;
                    rs&C and rs&C.y.R = r;
                    me&Ret,R,{s:rs&C||rc&s}
                }
            }
        });
        return r
    };
    # makes copies of an R:C
    me.TakeC = &acgtRtc{
        $h = Rc&N[0];
        c ||= {};
        c.x == null and c.x = 'C'
        c.x && hs&task != c.x and throw "R:"+t+" takes R:"+c.x
        return Ron(R,t,R,0,&Rr{
            r.c.not || rc&N.indexOf(r) < 0 and return R.c.not = 1
            
            Rc&nl = 900;
            # new Rc&s = old r
            # new Rs&C = old C
            $C = Rs&C = rs&C || rc&s;
            c.cb && c.cb(R,r,C);
            R.c.not and return
            $targ = c.z ? rs&z : rs&down || rs&z;
            !targ and return
            each iD targ {
                me&Ret,R,{t:D.t,s:D};
            }
        });
        
    };
    me.Gittoo = &acgtR{
        $cb = &RrC{
            s&noLines and Rc&nofurther = 1
        };
        $r = me&TakeC,R,'Gittoo',{cb:cb};
        $ers = [];
        each iR rc&N {
            $b = Rc&b;
            $C = Rs&C;
            $part;
            try {
                part = 'scan';
                $scan = Rs&scan = me&scan,C;
                scan.is != 'C' and throw "Not C"
                Cc&N and throw "mightbe R"
                
                part = 'clone';
                Rs&OC = C;
                typeof C.y != 'object' and throw "NotC";
                C = Rs&C = G&Cye,C;
                
                part = 'comp';
                # comp && comp(C,R,b);
                R.c.not and return
                
                part = 'Compress';
                G&Compress,C;
                
                part = 'toLines';
                Rs&Lines = G&toLines,C;
            }
            catch (er) {
                #ers.push([part,R,s,er]);
                ~Gittoo: ki(C,2)+"   !"+part+"! "+er
                throw "Gittoo: "+ki(C,2)+"   !"+part+"! "+er
            }
        }
        $rN = rc&N.slice().reverse();
        $Lines = [];
        each iR rN {
            $ind = '';
            $i = 0;
            while (i < Rc&d) { ind += '  '; i++ }
            $l = Rs&Lines.split("\n")
                .map(l => ind+l).join("\n");
            #l += "\n";
            Lines.unshift(l);
        }
        rs&Lines = Lines;
        $string = Lines.join("\n")+"\n";
        rs&dige = dig(string);
        return r
    };

