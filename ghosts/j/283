Packle: |
    #
    $me = 4c&me;
    !me and throw "no me";
    $io = me.io;
    
    # bel
    
    $ffmpeg = &{
        # the general overview
        # ! lost its code snippets
        # https://medium.com/@dernis/ffmpeg-tips-tricks-and-and-lessons-learned-a6f3c1187085
        # pics -> video
        # http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/
    };
    #c Jay
    me.J = &acgtsq{
        # do a J
        $C = typeof s == 'string' && G&Cye,[s,1,{J:s}];
        if (!C) {
            C = G&Cye,s;
            c&pi and c&J = C.c.pi; delete c&pi
        }
        q == 'W' and c&W = c&J;
        
        $j = G&n,C,5;
        C = jc&s;
        $J = s&J;
        J.3 == J and j.3 = J
        
        4s&elvisory and me.JT(j,C,G,T)
        
        $Jlim = 40;
        4s&Jays++ == Jlim and ~OutofJ: ki(J);
        4s&Jays > Jlim and return C
        
        Js&paused and return C
        
        !me.Ja[c&J] and throw "unknown me.Ja."+c&J
        
        j.ground = C;
        
        me.Ja[c&J](j,C,G,T,c&s);
        
        jc&Jupstash();
        j.1 == j.3 and J.3 = J;
        
        c&M and me&Mwix,C
        
        me.os(j,C,G,T);
        delete c&M;
        
        return C;
    };
    
    me.Ja.wobulus = &acgt{
        A&o = 'IndofC';
        
        4c&fps = 0.2;
        
        // tayt #!!
        #=cut
        # random health dials
        $br = upupc&brake;
        br &&
        n braking  $s:br
        
        n teeth 4  %medo:pause
        
        1c&timeto ||= 0;
        if (0 && 1c&timeto > 1) {
        
            1c&timeto > 4 &&
            n toot 8 s:ffeli
            
            n tot 6 s:aly
            1c&timeto > 5 and 1c&timeto = 0
        }
        1c&timeto++
        
        me&J,'digwaypoll';
        
        me&J,'edges','W';
        
        me&J,'Fourier','W';
        
    };
    
    me.Ja.Fourier = &acgt{
        me&heading;
        A&o = 'Elvising';
        
        #me&J,['Fourier','-od',{s:A.4}];
        # using only boost
        $ty = 'elvised elvisory'.split(' ');
        each it ty {
            $s = A.4.sc[t];
            !s and continue
            me&J,[t,'-feel',{s:s}];
        }
        4s&elvised = [];
        
        $l = 4s&elvising;
        !l and return
        me&J,['elvising','-feel',{s:l},'elvising,boost:sc,solvey'];
        #ls&solvey && 
        #me&J,['solvey','-feel',{s:ls&solvey}];
    };
    me.Ja.upstream = &acgt{
        # have perl watch
        # acpi -a
    };
    #c edges
    # wants to leap onto new osc gear
    me.Ja.edges = &acgt{
        me&heading;
        
        me&J,['writ','-feel',{s:A.4}];
        
        $s = me&trampel;
        s = 4s&stco;
        me&J,['expr','-go',{s:s}];
    };
    
    # data sift + self
    # be yinyander
    
    # - globe with C
    # - J os direct
    me.Ja.go = &acgts{
        $M = c&M = [];
        n t  $s:C.t %fs:20,hs:594
        s&dis = 1;
        s&bgi = 'i/greencush.jpg';
        s&hue = 90;
        # be a significant chunk/size
        # along running s into a extenter,
        $be = me&J,['lookfortheedge','-feel',{s:s}];
        
        me&J,['feel','-feel',{s:be}];
        # and showing output
        # wants to be pointed to not coded
        
        #$j = ses&J;
        #$I = js&s;
        #$vi = me&J,['view','-og',{s:I}];
    };
    
    # facilitate_daydream
    # where the Js break up the gobes becomes a size thing
    # could end up walking z by usuality
    me.Ja.feel = &acgts{
        me&heading;
        A&o = 'Graze';
        s&med = 'cra';
        s ||= {undefine:"d"};
        n seen  $s:s %unknown
        #n looks  $s:ki(s,7) %hs:298
    };
    

    me.Ja.havethis = &acgts{
        $R = c&s;
        i A.ground/$R
    };
    
    #c yamble
    me.counting = &acgt{
        1s&counting ||= 1;
        
        1s&counting++;
        1s&counting > 5 and 1s&counting = 0;
        1s&counting > 3 &&
        n counts  s:counts
    }
    me.trampel = &acgt{
        if (0 || !1s&es) {
            $st = <<''.split("\n");
            Long way going to
            Get my medicone
            Skys the autumn grey of a lonely wren

            =pod
            Piano from a window played
            Gone tomorrow, gone yesterday
            I found it in the street
            At first I did not see
            Lying at my feet
            A trampled rose
            =cut

            st.pop();
            $s = {};
            each il st {
                l = l.split(" ");
                $z = s;
                each iw l {
                    w == 'of' and z.lof = 'yea'; z.to={eo:{}};
                    w == 'to' and z.edg = C
                    z = z[w] ||= {};
                }
            }
            1s&es = s;
        }
        return 1s&es;
    };
    me.Ja.og = &acgts{
        me&heading;
        $sc = {};
        $it = &ts{
            return me&J,[t,'44444'+i,{s:s,pi:'od'},ex({},sc)];
        };
        $I = c&s;
        it('R:I',I);
        
        it('Ic\&head',Ic&head);
        $grou = A.ground;
        $ii = 2;
        each tN Ic&head {
            sc.ml = 0.3;
            sc.hue = ii++ * 30;
            each iR N {
                A.ground = grou;
                $t = 'head'+t+i;
                #A.ground = # < makes things vanish?
                it(t,R);
                Rc&ha and it(t+'-ha',Rc&ha)
            }
        }
        return;
        each ic sc&chR {
            # continue;
            me&J,['ch:'+i,'-od',{s:c}];
        }
    };
    #c Eightwo
    # osc again with separate nests of R running schemes
    # the Js&s is an R:I
    #  R:C scans C
    #  CdaR etc think, R and scan more
    #    making R:Knowing, R:Display
    #      who might produce grounds...
    #  R:C displays, bits from  R:Display tacked in
    
    
    # to draw your own conclusion
    # the hierarchy of ground reactions takes hold
    
    # !!!!!!   !!!!!!!!!! !!!!!!!!!!   !!!   !!!!!!!!!! !!!!!!!!!!    
    # the osc is about functioning...
    # building the environment fully soon would be nice?
    # bundling elvisory, runs, output checks...
    #   testing without pumping html through the screen
    
    # the total applier of what is meaningful
    # the machine up to this point is lost vectoria notation
    # here we shall draw into an over-unity, as in
    #   GROWTHS
    
    # dispatch C has experience
    # it could be complete, as a work of art,
    # or it could be ingredients for several concealations
    # and then a work of art
    
    # s might be an elvis/A going wide
    # all the osc together escape linear code
        # atoms in locations, another lives
        
        # knowing atomic-level motion here,
        # and unfolding qua in another:
        # OSC 3, drawing out of what is
        #   to run rhythms over the atoms,
        #   thinking of their subatomic meanings
        # resuming whenever the list of atoms adjusts

        # < go wide and reuse elements moving around
        #   persisting moving atoms,
        #     based pictures of subatomics
        #     a b in the d.V index leaving?
        #   TES
    
    me.os = &acgts{
        # A:n C
        if (A&s != C) {
            throw "become s figure";
            C.y.A and A = C.y.A; # continue A:n
            else
            !s and s = C; # hist on the C itself
            # ^ could be the way to store elvis' progress as his own,
            # bringing their own s&s = R?
            #   a piece of reason to install where the state it was
        }
        # 2 J is name-recurring since n3
        s ||= s&J || A;
        $I = me&Resurrect,'I',ss&s;
        # < feeding I's history back around for runtime instruction
        #   C and e's history for storable such
        
        # 3 C are
        $r = Ron(I,'C',C,&Rs{
            1s&Te && Rc&d == 0 and Rs&Te = 1s&Te
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }, &Rs{
            # generate furthers - notices J as yA1 different
            # < make CaR,R,s
            me&CaR,R,s;
        });
        
        # 6 details
        #  may do anything
        $o = A&o ||= 'CdaR';
        o = o.split(',');
        each id o {
            !me[d] and throw "No os me."+d
            me&$d,r
        }
        # < bring them along
        
        # 7 encode visuals
        me&Cavon,r;
        # 8 unify visuals
        me&Cupon,r;
        # ^ committing them to dom on the screen
        
        #   we used to concat storable C patches (el)
        # we also commit the tip of all reason:
        # < pass X society's maintainence expectations
        # top R copies sc? as an inclusive RbitXgonism,R
        ss&s = I;
        ss&X = Is&X;
        ss&CR = r;
        # main R ness
        rc&chR = A&chR;
        
        if (C.t == 'elvisory') {
            me&Gittoo,r;
        }
    };
    #c Ring R-ing
    # get R, s and R's middles to stream work
    # new Re, ing & middle work as progress stream ala A
    # R is basically an exploration of A
    #  lets get pictures of the R joining first
    # $r = me&Reis,I,'C',C;
    me.Reis = &acgtRtsc{
        $r = me&Re,R,ex(c||{},{t:t,s:s});
        me&Ring,r;
    };
    
    # simpler Ring, until display enough to Ring it up
    # t from R, looking at s
    $Ron = &Rtsonc{
        $r = me&Re,R,{t:t,s:s};
        rc&middle = &sR{
            # 1 scan/title
            1 && o and o(R,s);
            # 2 resume history Rc&b
            me&RbitX,R;
            # 3 generate furthers
            1 && n and n(R,s);
        };
        me&ing,'',r;
        # 4 X notices leavings
        me&RbitXgonism,r;
        # 5- up to thou
        1 && c and rc&N.map(R => c(R,Rc&s))
        return r
    };
    

    
    # while the R.t == mind of this pool
    $osu = &R{
        # m ... BQ breaks code visibility (until proper u)
        $z = [
        ['RbitX','2',&Rs{ me&RbitX,R; },'if:RcX'],
        ['RbitX','4',&Rs{ me&RbitXgonism,R; },'if:RcX'],
        ].map(n => G&Cye,n );
        
        $N = me[R.t](A,C,G,T,R);
        each in N {
            n = G&Cye,n;
            me&sortin,z,n;
        }
        # < Cye should put c=code as c.s
        each in z {
            n.c = {s:n.c}
        }
        return z
    };
    # Rs&z post hook, R intro
    $cz = &Ri{
        !Rs&z || Rs&z.length == i and return
        Rs&z.slice(i)
            .filter(z => z.y.cv == null)
            .map(z => zN(z));
    };
    # Rs&z -> hc&N, validates as atom
    $zN = &R{
        Rc&middle = &sR{ R.c.not = 1 };
        me&ing,'',R;
        if (!R.c.not) {
            R.c.not = 1;
            return
        }
        delete R.c.not;
        delete Rc&middle;
        Rc&N.push(R);
        R.y.cv = 0;
    };
    
    # Ring
    # already invoked from an otheR,
    #    which becomes its source, unless Rc&s?
    # wake the pool of R,
    #  1 is me&ing, its recursion we manage
    # processes instructions from a way with S-ections
    # which handle procedures on single/multiple items,
    # creating and 
    #   S Pond 3 $R $r $s %vague
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where s.sc.vague,
    #   S Pond 3 $R $r %vague $s
    # gives R:Reason, r:Pond, rc&s=s=Rc&s where R.sc.vague,
    #   S Pond 3 $R $r
    # gives R:Reason, r:Pond, rc&s=R
    # ie, there's always a R and a r. a dialect phrow.
    me.Ring = &acgtR{
        $h = Rc&N[0] || R;
        $I = h.y.I;
        !I and throw "headR knows not what I"
        $p = h.y.up;
        $c = hs&clu ||= osu(h);
        #debugger;
        # while tasks
        if (h.y.cv == null) {
            # put the first R
            # on tape (Rc&N), as the emit queue
            zN(h);
            h.c.not and throw "h not"
            if (!hak(R.c,'s')) {
                # guess we're going at h.y.up
                Rc&s = pc&s;
            }
        }
        $busy = 1;
        $sheer = 500;
        while (1) {
            sheer-- < 0 and debugger;
            hs&iN == null and hs&iN = 0
            else { hs&iN++ }
            # select what up to
            $R = hc&N[hs&iN];
            if (!R) {
                !hc&N[hs&iN - 1] and debugger
                # end of tape
                hs&iN = null;
                !busy and break
                busy = 0;
                continue
            }
            #c walk the tape, trying to do more
            # Rs&z may be new R to emit
            $zi = Rs&z && Rs&z.length || 0;
            
            
            # get its step
            Rs&ci ||= 0;
            $t = c[Rs&ci];
            !t and continue
            
            hy&ov && hy&ov < ty&cv and debugger;
            
            # what the step is called
            if (Ic&head[t.t]) {
                # spawn to R:C
            }
            
            if (ts&if) {
                ts&if == 'RcX' and !Rc&X and continue
                else {
                    throw "if "+ts&if
                }
            }
            
            # doming? T hook any G&n via A.ground...?
            
            $cb = tc&s;
            !hak(R.c,'s') and debugger;
            
            cb(A,C,G,T,R,Rc&s);
            
            !Rc&nofurther and cz(R,zi)
            Rs&ci ++;
            
            busy = 1;
        }
    };
    
    # S for an osc pin, bump through segments of the work
    me.Srupto = &A,C,G,T,s,t,talk,params{
        ~Srupt: s, ':', t, '%', talk
        #t.includes('She 1') and debugger
        A&doings ||= {};
        $l = A&doings[t] ||= {};
        l.done and return
        l.done = 1;
        #~sttalk: ki([s,t,talk,params]);
        return 1;
    };
    # overlap understandings
    me.Pond = &acgtM{
        return [
        ['She','1',&acgtRs{
            # tv index, indexo find previum (Rc&b)
            R.t = s.t+' '+(s.y ? s.y.cv : '');
        }],
        ['','3',&acgtRs{
            # generate furthers - notices J as yA1 different
            me&CaR,R,s;
        }],
        ['','6',&acgtRs{
            #~six: R.t
        }],
        ];
    };
    #c IndofC for total sense
    me.IndofC = &acgts{
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # replaces the C, breaking Elvising because no %medo on this one:
            # switch the elemental placer until we write on but it .C = origin
            $D = G&Cye,[C.t,'',{},{ml:Rc&d,dis:1}];
            Dc&s = me&picture,C;
            $r = Ron(R,'IndofC',D );
            me&Cavon,r;
            me&Cupon,r;
            # such that r.y.up has now s&down with out rs&on
        }
        
    };
    me.picture = &acgts{
        $Y = s.y.A;
        $usu = Y && Y.t == 'n';
        if (usu && sc&J && ss&J) {
            s = hup(s);
            sc&J == s.t and delete sc&J;
            sc&W == s.t and delete sc&W;
            #ss&W == s.t and delete ss&W;
            delete ss&z;


        }
        $k = ki(s);
        usu and k = k.replace(/,A;n/,'');
        return k
    };
    #c Elvising
    # for acting out matters
    # several types of delivery...
    # c&slope are on.Cs from paths into html
    # < being a FE
    # < collectively, esp. with Js
    # < the out-C and in-C are the same
    #   but their elements are not? what is set when?
    me.handelvis = &acgt{
        # go up C path until bingoed
        $lop = c&slope.slice().reverse();
        # - s&medo - instant, outside (A=4) (eg Jause)
        each in lop {
            $medo = ns&medo;
            !medo and continue
            !me[medo] and return ~Nomedo: medo
            $msg =
            ~Elvised: medo, '>3:what ...'
            $ret = me[medo](A,C,G,T,n);
            G&yl:400,&{ msg.set('what',ki(ret)) };
            return
        }
        # - s&med: 
        #   e -> 4c&elvising -> J:Fourier -> me.Elvising
        #   having gone inside (4c&callback)


        4s&elvising = C;
        ~Insideon: ki(c&slope,2)
        G&yl,0,4c&callback;
    };
    # Elvising looks at innermost s&med on ec&slope
    # s&med=cra:
    #  then looks at c&slope's yRs
    #    may find origin of the stimuli grasped (hy&interpreted)
    #  for Rs&elvis,
    # something to keep books on the piles of C
    # and be an instantaneous adjustment of something
    #  would the boost type Travel in parallel
    
    # the introgen starts, picking other
    #  an overlay chasing particular adjustments in the field from 4
    # something needs to hook named points as it goes, ensure fullness
    me.Elvising = &acgts{
        # find the one bit...
        me&CdaR,s;
        
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&elvising and continue
            
            if (Rs&cha) {
                ~IS
                $e = c&e || c&s;
                if (e.t.includes('click') && ec&slope) {
                    $sl = ec&slope.slice().reverse();
                    each in sl {
                        # ns&medo is handled without 4c&callback
                        $m = ns&med;
                        !m and continue;
                        # not in C or A
                        $C = c&s;
                        $s = c&s;
                        me&$m,s;
                        return
                    }
                    ~NODICE
                }
            }
        }
    };
    #c slope/pointer
    
    # c&pointer snips to subnets, finds your stuff
    # for pointing into R pools, finding Rs&elvis=hook
    #  taking the c&slope from small to big
    #  looking for Rs&elvis
    #  towards hy&interpreted
    $latestR = &R{
        $il = 75;
        $futu = 0;
        while (R.y.future) {
            R = R.y.future;
            futu++;
            il-- < 0 and debugger;
        }
        futu > 5 and ~futu: R.t, futu
        return R
    };
    me.cra = &acgtD{
        #$el = c&path_yon.slice(-1)[0];
        $M = s&solvey = [];
        $upwards = c&slope.slice().reverse();
        $c = {};
        each in upwards {
            $v =
            m $n.t  $s:n
            ny&cv != null and vy&cv = ny&cv
            if (ny&A) {
                $Y = ny&A;
                # find J
                c.1 != Y.1 and vs&J = Y.1
                c.1 = Y.1;
                # find W
                Y.1 == Y.3 and vs&W = Y.1
            }
            if (ny&R) {
                $R = vs&R = latestR(ny&R);
                vs&nam = ki(me&namup,R );
                $h = Rc&N && Rc&N[0];
                if (h) {
                    # follow to what head is looking at
                    #  for Rc&s = another pool's R
                    $t = !Rs&modulat && hy&interpreted;
                    if (t) {
                        $ri = tc&N.indexOf(Rc&s);
                        ri < 0 and ~Notininterpreter: R.t
                        R = vs&R = Rc&s;
                        h = Rc&N && Rc&N[0];
                        vs&namu = ki(me&namup,R );
                    }
                    vs&h = h;
                    vs&task = hs&task;
                }
                Rs&elvis && !c.elvis and c.elvis = vs&elvis = Rs&elvis
            }
        }
        !c.elvis and ~sloping
        !c.elvis and return
        $p = [];
        each in M {
            ns&elvis and p.push(n); continue
            !p.length and continue
            p.unshift(n);
            ns&W and break
        }
        s&solvey = p;
        
        # < to c&pointer, to locate us in
        $M = c&pointer = [];
        # < a pile of travel, io T points to look at
        $el = 4s&elvisory ||= G&Cye,['Elvisory',''];
        each in p {
            $v =
            m $n.t  {}
            ny&cv != null and vy&cv = ny&cv
            # < io spacerised is just t
            i $el/#$n
            el = ays&n[0];
            if (ns&elvis) {
                T.qua = {};
                $R = ns&R;
                # make the adjustment
                me[ns&elvis](A,C,G,T,R);
                # save the state
                each kv T.qua {
                    el.sc[k] = v;
                }
                s&elvis = Rs&elvis;
            }
        }
        
        # < overplace set value
        # < boostulate requires A1..3 carry T wires
        #   for the rest R carry T wires
        #   so set value can be reintroduced
        # < check every T point was found
        #4s&elvising = C.c;
        #~etc: $(el).text();
    };
    
    #c usuals
    # 2-ish data scan
    # < for C universals
    # < standard deviatable
    # < resolving and diving like diamonds
    me.CdaR = &acgts{
        # run the set of R into another Ring
        
        # univ contrib lowlevel stillness check
        # then stilling an os lest some push
        each iR sc&N {
            $b = Rc&b;
            $C = Rc&s;
            # < me.scan for all innard
            $diff = &di,ff,dd{
                typeof di != 'object' and return di != ff
                $wh = {gone:{},diff:{},new:{},same:{}};
                each kv di {
                    null == ff[k] and wh.new[k] = {};
                    ff[k] != di[k] and wh.diff[k] = {};
                    wh.same[k] = {};
                }
                each kv ff {
                    null == di[k] and wh.gone[k] = {};
                }
                each qua,k,ha wh {
                    qua == 'same' and continue
                    dd && dd.ignore == k and continue
                    return 1
                }}
            };
            # < should be against an image of the past
            $x = b && bc&s || {};
            diff(C.c,x.c||{}) and me&chR,R,'CdaR-Diff-c'
            diff(C.sc,x.sc||{},{ignore:'z'}) and me&chR,R,'CdaR-Diff-sc'
        }
    };
    
    # exit the entrance
    me.domesticate = &acgtR{
        $scan = Rs&scan;
        # 1
        $M = me&Mw,R,'traw';
        m t 1 $s:R.t %fs:13,hs:288
        $is = scan.is || scan.sym;
        m sym 12 $s:is %fs:15,ls:-0.1,zi:-1,hs:4955
        
        # thing gets perforated edge
        if (scan.C) {
            !Rs&isgk and s&dis = 1;
            s&bgi = 'i/greencush.jpg';
            s&bgh = '1115';
            s&bo ||= '0.4em dotted #235';
            s&br = '3';
            s&zi = -2;
            s&hue = 60;
        }
    };
    me.bagatagage = &acgtR{
        $scan = Rs&scan;
        $ks = scan.ks || [];
        if (scan.C) {
            ks[0] != 't' and debugger;
            ks.shift();
            $s = Rc&s;

            $M = me&Mw,R,'.t';
            scan.is == 'A' &&
                m tofA 19 s:: %ls:-0.2

            m t 2 $s:s.t %deco,fs:15

            if (scan.is == 'A') {
                $cv = s.cv+'';
                cv[0] == '0' and cv = cv.slice(2);
                cv = '@'+cv;
                m cv 21 $s:cv %ls:-0.1,hs:339
            }
        }

        if (scan.modu) {
            each in scan.modu {
                n.t == 'weirdkeys' and continue
                $M = me&Mw,R,'modu:'+n.t;
                me&Modu,[n],M;
            }
        }
    };
    #c Mboostia
    # deprunablism - note Ry&ups&M about lost
    # would sit as a general ableness,
    #  working on h's dim awareness of what is not included 
    me.Mlimits = &acgtr{
        !rc&ha and return
        $upritN = {};
        each tin rc&ha {
            if (rc&N.indexOf(n) >= 0) {
                # R included
                $M = me&Mw,n,'Mlimits';
                m $t 89 s:* %decor,fs:13
                continue;
            }
            else {
                # knows upward that is
                $p = ny&up;
                $upri = rc&N.indexOf(p)
                upri < 0 and debugger
                upritN[upri] ||= {};
                upritN[upri][t] ||= [];
                upritN[upri][t].push(n);
            }
        }}
        each itN upritN {
            $R = rc&N[i];
            $M = Rs&M || me&Mw,R,'Mlimits';
            $zs = t+' < '+N.map(t=>t.t).join(',');
            $te = '*'+t;
            m $te 117 $s:zs %decor,fs:13
        }}
    };
    # Js drive wiring from above
    me.JT = &acgts{
        $p = A.1 == A.3 ? 4s&elvisory : 2s&Te;
        !p and return
        $t = C.t;
        $v = p&tv $t;
        !v and return
        1s&Te = v;
    };
    # Rs inhale wiring from .y.up+s&Te
    # thenceforth getting
    # can resume pointering across Rs that don't
    # < checks all pointers were found
    me.Tie = &acgtRk{
        #R.t == 'Knowing' and debugger;
        if (!Rs&Te) {
            # attach travelvis once..
            Rs&Te = {};
            $r = R.y.up;
            !r || r == R and return
            !rs&Te and me&Tie,r
            $v = rs&Te;
            !v and return
            # most R.t aren't C.t
            $t = Rc&N[0] && Rc&N[0].sc.task == 'C' ? Rc&s.t : R.t;
            $Tet = v&tv $t;
            Tet and Rs&Te = Tet
        }
        $v = Rs&Te;
        !v || !v.c and return
        !k and return
        # once located, muddle with opportunity
        #vs&cb && vs&cb,R,t
        hak(v.sc,k) and R.sc[k] = v.sc[k]
        
    };
    me.boostulate = &acgtR{
        Rs&elvis = 'Gazel';
        # ^ is somewherish. posits and deposits.
        1s&Te and me&Tie,R,'boost'
        
        if(0) {
        # returns from history
        $b = Rc&b;
        !(b && bs&boost) and return
        Rs&boost = bs&boost;
        }
        
        !Rs&boost and return
        4s&elvised.push(Rs&boost+' '+ki(me&namup,R ));
        
        # drawn
        $M = me&Mw,R,'boost';
        Rc&nl and Rc&nl += Rs&boost * 3;
        Rc&dl and Rc&dl += Rs&boost;
        $bo = Rs&boost;
        $sym = bo < 0 ? 's' : 'W';
        bo = bo < 0 ? bo*-1 : bo;
        $i = 0;
        while (i < bo) {
            $hu = 20*i+100;
            $z =
            m booste 11 $s:sym %fs:20,hs:594,hue:$hu
            z.t += hu;
            i++;
        }
    };
    me.namup = &acgts{ 
        $nam = [s.t];
        while (s = s.y.up) {
            nam.push(s.t);
        }
        return nam.reverse();
    };
    me.Gazel = &acgtR{
        Rs&boost ||= 0;
        #debugger;
        C.t.includes('C+') ? Rs&boost-- : Rs&boost ++;
        T.qua.boost = Rs&boost;
    };
    #c Gaze complicated
    me.Gaze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        
        # R motif leads to P, leads to R...
        # spring forth
        $N = sc&N;
        each iR N {
            $b = Rc&b;
            $C = Rc&s;
            
            !s&unknown and continue
            typeof c&s != 'object' and throw "unknown!ob"
            $s = c&s;
            
            # A&R, refs and refR keep all
            # < refs dupe ignore at R bounds, overlap understandings
            $r = Ron(R,'Knowing',s,&Rs{
                # index by R.t set by daR
                Rc&nl ||= 25;
                Rc&dl ||= 3;
            }, &Rs{
                # data/object awareness
                $scan = me&scan,s;
                # for low lighting
                $b = Rc&b;
                b && bs&checksame;
                # < once all to here, gonism juggles
                
                # 3 - generate interesto
                # how much to draw/fall in...
                #  these M might be named in future,
                #  compositive to 3s&Me, a tv of M bits
                #    good shape for magazine ladel
                $M = Rs&M ||= [];
                m t  $s:R.t %fs:13,hs:288
                $is = scan.is || scan.sym;
                m sym  $s:is %fs:15,mt:-0.1,ml:-0.1,zi:-1,hs:4955
                # etc, drawing/falling in as ...
                # osc G&n -od?
                
                #R.t == 'autumn' and debugger;
                me&boostulate,R;
                
                if (scan.is && Rc&d) { # object
                    #m ki  $s:ki(s) %pa:2
                    #return
                    return M.push(me&J,[R.t,'-od',{s:s}] )
                    #m R.t -od $s:s
                }

                # generate furthers, until known?
                me&daR,R,s;
            });
            
            me&Mlimits,r;

            # and anotheR to Cavon those M Cs,
            # and get every nl/dl comoverable.
            $d = Ron(r,'Display',r,0,&Rs{
                Rc&nl = 0;
                each iD ss&M {
                    me&Ret,R,{t:D.t,s:D,modulat:1}
                }
                each iD ss&z {
                    ss&J and Rs&J = ss&J; continue
                    me&Ret,R,({t:D.t,s:D})
                }
            });
            
            # throw styles over the 
            each in dc&N {
                ns&modulat and continue
                #ns&dis = 1
                # styles are coming from the Display R:
                $c = nc&s;
                #nc&d <= 1 and 
                cs&dis = 1; cs&ml = 1;
                cs&pa = '7px';
                
                #n.t == 'my' and ns&dis = 1;
            }
            
            # 7 display part
            me&Cavon,d;
            # 8 unify
            # join Display (d etc) directly under its cause (R)
            #  leaving out Knowing (r)
            d.y.interpreted = r;
            d.y.up = R;
            me&Cupon,d;
        }
        
    };
    #
    
    #c Graze
    me.Graze = &acgts{
        # cdar extendor
        # all of them Jround here S variously, lay out trees,
        # to mix the top based on the particulars
        
        # R motif leads to P, leads to R...
        # spring forth
        
        $N = sc&N;
        each iR N {
            $b = Rc&b;
            $C = Rc&s;
            $upw = R;
            
            !s&unknown and continue
            typeof c&s != 'object' and throw "unknown!ob"
            
            # look at.. a scan of the thing
            $s = c&s;
            #s = A;
            #s = me&scan,s;
            
            
            
            $r = Ron(R,'Knowing',s,&Rs{
                # index by R.t set by daR
                Rc&nl ||= 175;
                Rc&dl ||= 15;
            }, &Rs{
                $p = Ry&up;    
                $C = Rs&C = G&Cye,[R.t,'',{}];
                
                # this R can be clicked big/small
                me&boostulate,R;
                
                $scan = Rs&scan = me&scan,s;
                
                me&domesticate,R;
                
                # decision of presentation
                p && ps&isnk || Rs&isgk and Rs&isgk = 1
                p && ps&scan && ps&scan.sym == '[' && pc&d > 1 and Rs&isgk = 1;
                # boost overrides tendency to isgk weirdkeys
                Rs&isgk && Rs&boost and delete Rs&isgk; Rs&rowish = 1;
                R.t == 'y' and delete Rs&rowish;
                Rs&boost < 0 and delete Rs&rowish; Rs&isgk = 1;
                scan.sym == "'" and Rs&isgk = 1;
                
                if (Rs&isgk) {
                    $M = me&Mw,R,'traw';
                    # make block,inline have same indento
                    $iN = (ps&z||[]).indexOf(R) - 1;
                    $f = iN >= 0 && ps&z[iN];
                    f && fs&rowish and s&ml = 1
                    s&fs = 7;
                    m sym 12 not
                    m ki 3 $s:ki(s,2)
                    return
                }
                
                # always a bunch of keys
                #   sans those in Modus&ks=[]
                #   with whom we want to pluck ks out of
                #   bending the last representation outwards
                #   or popping it in the short term... Rs become Ret lims,
                #   wanting child boost read by the time we're here,
                #   to choose whether to Modu or RetR
                me&bagatagage,R;
                
                $ks = scan.ks || [];
                $wk = scan.weirdkeys || [];
                each ik wk {
                    $n = me&Ret,R,{t:k,s:s[k],isgk:1}; #]
                    i == 0 and ns&ml = 1
                }
                
                ks && ks.length && ks.map(&k{
                    $v = s [k];
                    me&Ret,R,{t:k,s:s[k],rowish:1}; #]
                });
                
                if ((Rs&runny || Rc&d == 0) && scan.C && sy&tv && ss&z && !ss&J) {
                    each in ss&z {
                        me&Ret,R,{t:i,s:n,rowish:1,runny:1}
                    }
                }
            });
            #c
            me&Mlimits,r;
            
            each iR rc&N {
                # unify the M
                Rs&M ||= [];
                me&Mwix,R;
            }

            # and anotheR to Cavon those M Cs,
            # and get every nl/dl comoverable.
            $d = Ron(r,'Display',r,0,&Rs{
                Rc&nl = 0;
                !s.sc and debugger;
                each iD ss&M {
                    me&Ret,R,{t:D.t,s:D,modulat:1}
                }
                each iD ss&z {
                    ss&J and Rs&J = ss&J; continue
                    $r = me&Ret,R,{t:D.t,s:D};
                    Rs&modulat and rs&modulat = 1;
                }
                ss&C and Rs&C = ss&C;
                #Ry&Re = Rc&s;
                #$C = Rc&s = G&Cye,[R.t,'',{s:ki(Rc&s)},{dis:1}];
                #Cy&R = R;
            });
            #ds&elvis = 'Gazel';
            
            # throw styles over the 
            each in dc&N {
                ns&modulat and continue
                #ns&dis = 1
                # styles are coming from the Display R:
                $c = nc&s;
                cs&nodule and continue
                ns&nodule and continue
                #nc&d <= 1 and 
                !cs&rowish and continue
                $C = ns&C || c;
                s&dis = 1; s&ml = 1;
                s&pa = '7px';
                
                #n.t == 'my' and ns&dis = 1;
            }
            
            # 7 display part
            #debugger;
            me&Cavon,d;
            # 8 unify
            # join Display (d etc) directly under its cause (R)
            #  leaving out Knowing (r)
            d.y.interpreted = r;
            d.y.up = upw;
            me&Cupon,d;
            each in dc&N {
                    #n.t[0] == 'I' and debugger;
            }
        }
        
    };
    #c Gittoo - C -> Git elvis
    # makes copies of an R:C
    me.TakeC = &acgtRtc{
        $h = Rc&N[0];
        c ||= {};
        c.x == null and c.x = 'C'
        c.x && hs&task != c.x and throw "R:"+t+" takes R:"+c.x
        return Ron(R,t,R,0,&Rr{
            Rc&nl = 300;
            # new Rc&s = old r
            # new Rs&C = old C
            Rs&C = rs&C || rc&s;
            c.cb && c.cb(R,r);
            R.c.not and return
            $targ = c.z ? rs&z : rs&down;
            !targ and return
            each iD targ {
                me&Ret,R,{t:D.t,s:D};
            }
        });
        
    };
    me.Gittoo = &acgtR{
        $r = me&TakeC,R,'Gittoo';
        $ers = [];
        each iR rc&N {
            $b = Rc&b;
            $C = Rs&C;
            $part;
            try {
                part = 'scan';
                $scan = Rs&scan = me&scan,C;
                scan.is != 'C' and throw "Not C"
                Cc&N and throw "mightbe R"
                
                part = 'clone';
                Rs&OC = C;
                typeof C.y != 'object' and throw "NotC";
                C = Rs&C = G&Cye,C;
                
                part = 'comp';
                # comp && comp(C,R,b);
                R.c.not and return
                
                part = 'Compress';
                G&Compress,C;
                
                part = 'toLines';
                Rs&Lines = G&toLines,C;
            }
            catch (er) {
                #ers.push([part,R,s,er]);
                ~Gittoo: ki(C,2)+"   !"+part+"! "+er
                throw "Gittoo: "+ki(C,2)+"   !"+part+"! "+er
            }
        }
        $rN = rc&N.slice().reverse();
        $Lines = [];
        each iR rN {
            $ind = '';
            $i = 0;
            while (i < Rc&d) { ind += '  '; i++ }
            $l = Rs&Lines.split("\n")
                .map(l => ind+l).join("\n");
            #l += "\n";
            Lines.unshift(l);
        }
        4s&stco = Lines;
    };

