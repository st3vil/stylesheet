Interesting: | # running a cluster
    =head1 basis
    
    someone has to make w,
    then we can all make W
    
    =head1 Gs
    
    see Zuu
    
    
    =head1 the G
    
    Gc&bay is the G,
        a branch and island of activity
        
        the $g is the in-G branch
            suggested in 5s&stores
        the $gd is "$bay/$g"
    
    G.t the thing, as it has its own process start
    
    =head Ge J    be generally, a cluster
    
      have to give c.WeaG from Motor to know to resume from g=G
      could go Ge:
    
     Ge as a J should only complete/save on G/Ge
       no Ge J if in the very first process
         which remains unclustery,
         jammed forever in GoFishing,
         to waitpid for G/Ge and refork it if p/Up/will=restart
       no Ge J if any other process...
       
       they all jam into other things forever, nobody completes Ge J
       could make overmind
    
    =head1 G/Ge, etc.
     
      aboveness - very first process
       Ge - be still, be parent, exits if in < ['Exit']
          WebHost - receive Wlan
        Up - receive Elan
        Si - watching process (see zap/)
        Down - being from
         much branching under Down
    
    =head2 other
    
      < reuse/lock by the Ge J, become Down or so under the master if extra
    
    many processes join, the G1, mastering a list of G*
        including G2 (5 templates), 3 (6 proc follower), 4 (tv set)
        
      < G8s elvising, times
    
    fork - from?
    name - at depth of takeover
    Gover                                        
    
    =head1 W routing
    
    Gc&Glan the name on Opper to receive this W
Zuu: | # a G to start all the Gs
    # old way maker system
    m Zupula=>''=>'upul'
    # to stay/kull
    m Ge=>''=>'zap'
    # to wander
    m Ge=>''=>'spot'
    
    for (@$M) {
        _c&W = 'zmd';
        _c&cmd = "./spot\.pl _.t: _c&s/";
    }
    
Zupula: | # old way-machine, dangling
    # stylehouse - codeboxes webserver, writing to g/*
    # Goh/Goat reads k:vs from g/* into database and w/$pin
    for (qw'Goh Goat stylehouse') {
        my $C =
        m $_
        c&cmd = /^[A-Z]/ ? "perl got $_ 4 b" : "cd /h; perl $_\.pl";
        c&W = 'zmd'; # do Zapula (above) under a different name
    }
    for (qw'Goh Goat') {
        `kill -KILL $_` for grep{$_}map{/^\s*(\d+)/}
            split"\n",''.`ps f | grep $_`;
    }
    
    
zmd: | # wormhole that is a command, inside a fork...
    c&cmd || die "Expect to do c_cmd";
    
    system c&cmd;
    
    die "Eror: $!" if $!;
    sayre "C.t Done!";
    exit;
linkrement: | # symlinks in Gc&ipd/r/ to count/track growth/activities
    Gc&ipd && -d "Gc&ipd" || return;
    my ($t,$v) = @{ar.m};
    my $append = $v =~ s/^_// if $v;
    `mkdir Gc&ipd/r` if !-d "Gc&ipd/r";
    my $l = "Gc&ipd/r/$t";
    my $was = my $al = readlink($l) if -l $l;
    $al = !defined $v ? ++$al : $append ? "$al;$v" : $v;
    `unlink $l` if -l $l;
    return if $v eq 'undef';
    symlink $al, $l;
    my $undo = &{ `unlink $l`; defined $was && symlink $was, $l };
Co: | # see */Co/* bay/Cluster operandis / Troom, tell G what/how
    # the G/bay usually is in one piece
    # the name being mapped out to different things
    # it may also multiply out to lots of same-ish things
    #   things - the fittings of experience
    # 
    
Ge: | # Ge Co, 1 finds itself and moves in, or plugs into the society...
    # selves
    saybl "selves! G.t on Gc&bay";
    
    saybl "Ge J already:", map{"  - ".G&aC,$_ }@{Js&top.sc.z||[]};
    if (my $t = Js&top) {
        if (my $i = t.y.tw.Gcipi) {
            Gc&ipi = ic&s;
            saybl "Adopting Gcipi = Gc&ipi";
        }
    }
    # add G person
    G.t ne 'Ge' &&
        Rw G.t;
    
    Gs&fishing++ || 
        Rw GoFishing $N:M;
    
    n Gcipi=>1=>Gc&ipi
    saybl "IDnis!";
    # pids in bay/G
GoFishing: | # become Gc&bay/G.t of G1 ideally, possibly G0
    my $p = $$;
    $| = 1; # autoflush output channel
    
    # goner?
    # mkoJ called by Wout, sends lines with Ilan on Opper
    # Opper Ilan $f elvised by Ualve on Udders
    #     Ilan unifies names/routes points by elvising Win
    G.mkoJ = &Wc{
        c.holst = $W; # geoplace on desk section
        my $Y = Gc&B.sc.A;
        c.Y = $Y; # A coming from
        G&elph,NetPut=>[out=>1=>$c]
    };
    
    # assume already 5s&stores
    Gc&bay || die "Nobay";
    
    # < cluster init/takeover/join?
    
    G.d = "Gc&bay/G/G.t";
    for ("Gc&bay/p") { # the old pid+Gt directory
        -e && !-l && die "$_ is a directory";
        -l && unlink $_;
        # making it see 
        symlink "G/G.t/G", $_;
    }
    # to contain 1-5 for this W,
    # ip/$ip - process'
    # G/$t - G names
    # W/$t - W names
    town: for my $Gdt (qw'ip G W p') {
        `rm -rf G.d/$Gdt`;
        `mkdir -p G.d/$Gdt`;
    }
    `rm -rf Gc&bay/neu`; # clustaceans like Opera
    
    # become 0 first, the terminal wait/refork with G underneath it
    # 1 then takes up Ge-minding & the c
    # 2 takes up a self consciousness & the sc
    # by splitting further
    
    # some everywheres
    Gc&Up = 'Up'; # unify results to
        # reads in free time (Baye) and incorporates
    Gc&Down = 'Down'; # send work to
        # blocking read (Down itself?), does CeLovulation per message
    
    # ^ could be more absolute?
    #   error should happen and be noticed from afar
    
    # these things should get their hangaroundness somehow
    # probably reading Gc&inch.* and sleeping (via timer if loose)
    
    # recipes!
    my $M = [@{ar.N||[]}];
    my $g;
    if (!@$M) {
        # default:
        #  - G.t: Ge sits here
        #  - Up: unify/handle everything
        #      should be comebackable one elvis tracey
        #  - Down: a path leading to wilderness
        
        # creates an ipd G.d/ip/$ip (ipdir) for each
        # < to refork Up...
        # noop: don't fork and go Motoring, just aquire ipdir
        # io: make only those channels
        #   together makes Gc&inch.in handle Gc&ipd/in and leaves stdin
        # ip: sets ip
        
        $g =
        m G.t=>{}=>{nogo=>1}
        #,io=>['in']}
        # all are W to go and do
        #   esp with e later
        m Up
        m Down
        m WebHost
    }
    
    for my $C (@$M) {
        # opens new land as C
        Rw CeLovulation $C;
        
        if (c&nogo) {
            # we go into that fork to do the rest of the forking
            s&pid || sayre("Astep C.t") && next;
            sayre("AstDoneu ep C.t") && last;
        }
        s&pid || return do { # never happens?
            saygr "Flies in as: C.t $$";
            sleep(2), sayre("Doing life") for 1..4;
            saygr "Done";
            exit;
        };
        saygr "Stands as: G.t ($$) -> C.t (s&pid)";
    }
    
    $g && !gs&pid && return sayyl(" AM g.t") && # Ge leaves
        Rw Baying $forever=1;
        
    # always us now, wait for Up or so...
    # multiple inwardses, pretending to be in cluster and ourselves as we were
    Gc&inch.std = \*STDIN;
    $g ||= $M->[0];
    
    my $op = gs&pid || die "No first pid";
    my $clean = &{
        my @l = grep {!-e "/proc/$_" } split "\n", ''.`ls -1ct Gc&bay/G/Ge/p`;
        @l && sayre "Kill @l";
        kill KILL=>$_ for @l;
    };
    saygr "Waiting fr $op (or ".ki $g;
    
    waitpid($op,0);
    goto rem if readlink("Gc&bay/p/Up/will") eq 'restart';
    sayyl "Done! Restart?";
    <>;
    rem: $clean->();
    snooze 4000;
    goto town;
CeLovulation: | # the C is causing a fork, spreading out identiG
    # or adopting the identity of:
    c&ip ||= [@{Gc&ip||[]},Gc&ipi++];
    unless (c&noop) {
        my $pa = $$;
        (s&pid = fork()) && return;
        Gc&ipi = 0;
        Gc&parent_pid = $pa;
    }
    else {
        s&pid = $$;
    }
    Gc&ip = c&ip;
    
    # process' own space by ip
    Gc&sip = join('.',@{Gc&ip});
    Gc&ipd = "G.d/ip/Gc&sip";
    `mkdir Gc&ipd`;
    
    # reopen io into ipd
    c&io ||= [qw'in out err'];
    my $te = {
        out => \*STDOUT,
        err => \*STDERR,
        in => \*STDIN,
    };
    Gc&inch = {};
    # close everything/restart t
    for my $ch (@{c&io}) {
        my $ha = $te.>$ch;
        my $f = "Gc&ipd/$ch";
        -e $f && die "Had $f!";
        `touch $f` unless $ch eq 'err';
        undef $ha if c&noop; # doesn't take over stdin
            #0;# close $ha; # < maybe dont close it?
        # emits spot/p/10813/out open noise: Inappropriate ioctl for device
        # around here
        my $mode = $ch eq 'in' ? '<' : '>';
        open($ha, $mode, $f)
             || die "$f open fail: $!";
        $! && sayre "$f open noise: $!";
        undef $!;
        Gc&inch.>$ch = $ha if $mode eq '<';
    }
    
    $0 = "Gc&ipd";
    # G names, become the latest source of W
    #   to group/stage e to
    unless (c&noGt) {
        my $t = c&Gt || C.t;
        my $Gt = "G.d/G/$t";
        unlink $Gt if -l $Gt;
        symlink "../ip/Gc&sip", $Gt;
        symlink $t, "Gc&ipd/Gt";
        $0 .= " $t";
        G.t = $t;
    }
    
    # p pids
    my $pt = "G.d/p/$$";
    unlink $pt if -l $pt;
    symlink "../ip/Gc&sip", $pt;
    symlink $$, "Gc&ipd/pid";
    Gc&oom_adjust &&
        `echo 14 > /proc/$$/oom_adj`;
    
    return if c&nogo || c&noop;
    
    saybl "CellOvulation: $0";
    sayyl "C: ".ki $C;
    
    4s&toy->({to=>[$C]});
    
    saybl "Wandering Ovv";
    
    s&pid
Up: | # organise gondolas, G Up receives Elanings for Wlanings
    Rw Tiot;
    n te=>''=>wdump(2, G.c),'dis,fs:5'
    sayre "J.t: Hihi: A.inG";
    Rw GiveTime;
    snooze 222;
    #n Fish
    n Opera
Down: | # take medicine and go gondola riding
    Rw Tiot;
    sayre "J.t: Hihi: A.inG";
    # Co brings us our T-ing
    Gc&Glan = 'Glan';
    Gc&oom_adjust = 14;
    
    # get stuck in a read loop, unless Gc&freetime
    Rw linkrement upto blockin;
    while (1) {
        snooze 10000;
        $_ = <STDIN>;
        length $_ || next;
        chomp;
        $_ =~ /\w/ || next;
        my $C = eval { djson $_ };
        if ($@) {
            sayre "NOT json C: $_";
            $@ = '';
            return;
        }
        $C = G&Ct,$C if ref $C eq 'ARRAY';
        Rw CeLovulation
        # returns nothing as the parent,
        || do {
            Rw linkrement upto blockin;
            next;
        };
        # child may have Rw GiveTime since
        saybl "Done a Down";
        if (T.Uddoff || Gc&freetime) {
            T.not = 1;
            return saybl "Uddoff";
        }
    }
Exit: |
    exit;
Lookout: |
    # tail /var/log/syslog for /Out of memory:/
    # sensors | grep 1:
    

