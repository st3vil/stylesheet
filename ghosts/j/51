Interesting: | # running a cluster
    
    =head1 the G
    
    Gc&bay is the G,
        a branch and island of activity
        
        the $g is the in-G branch
            suggested in 5s&stores
        the $gd is "$bay/$g"
    
    G.t the thing, as it has its own process start
    
    =head Ge J    be generally, a cluster
    
     Ge as a J should only complete/save on G/Ge
       no Ge J if in the very first process
         which remains unclustery,
         jammed forever in GoFishing,
         to waitpid for G/Ge and refork it if p/Up/will=restart
       no Ge J if any other process...
       
       they all jam into other things forever, nobody completes Ge J
       could make overmind
    
    =head1 G/Ge, etc.
       
       Ge - be still, be parent, exits if in < ['Exit']
          WebHost - receive Wlan
        Up - receive Elan
        Si - watching process
        Down - being from
         much branching under Down
    
    =head2 other
      < reuse/lock by the Ge J, become Down or so under the master if extra
    
    many processes join, the G1, mastering a list of G*
        including G2 (5 templates), 3 (6 proc follower), 4 (tv set)
        
      < G8s elvising, times
    
    fork - from?
    name - at depth of takeover
    Gover                                        
    
    =head1 W routing
    
    Gc&Glan the name on Opper to receive this W
Co: | # see */Co/* bay/Cluster operandis / Troom, tell G what/how
    # the G/bay usually is in one piece
    # the name being mapped out to different things
    # it may also multiply out to lots of same-ish things
    #   things - the fittings of experience
    # 
Ge: | # Ge Co, 1 finds itself and moves in, or plugs into the society...
    # selves
    saybl "selves! G.t on Gc&bay";
    
    saybl "Alreadies: ". wdump 3, Js&top.sc.z;
    if (my $t = Js&top) {
        if (my $i = t.y.tw.Gcipi) {
            Gc&ipi = ic&s;
            saybl "Adopting Gcipi = Gc&ipi";
        }
    }
    
    n "thught"=>1=>"tho"
    
    Gs&fishing++ || 
        Rw GoFishing - WebHost;
    
    n Gcipi=>1=>Gc&ipi
    saybl "IDnis!";
    # pids in bay/G
GoFishing: | # become Gc&bay/G.t of G1 ideally, possibly G0
    my $p = $$;
    $| = 1; # autoflush output channel
    
    
    # goner?
    # mkoJ called by Wout, sends lines with Ilan on Opper
    # Opper Ilan $f elvised by Ualve on Udders
    #     Ilan unifies names/routes points by elvising Win
    G.mkoJ = &Wc{
        c.holst = $W; # geoplace on desk section
        my $Y = Gc&B.sc.A;
        c.Y = $Y; # A coming from
        G&elph,NetPut=>[out=>1=>$c]
    };
    
    # assume already 5s&stores
    Gc&bay || die "Nobay";
    
    # cluster init/takeover/join?
    G.d = "Gc&bay/G/G.t";
    for ("Gc&bay/p") { # the old pid+Gt directory
        -e && !-l && die "$_ is a directory";
        -l && unlink $_;
        # making it see 
        symlink "G/G.t/G", $_;
    }
    # to contain 1-5 for this W,
    # ip/$ip - process'
    # G/$t - G names
    # W/$t - W names
    town: for my $Gdt (qw'ip G W p') {
        `rm -rf G.d/$Gdt`;
        `mkdir -p G.d/$Gdt`;
    }
    `rm -rf Gc&bay/neu`; # clustaceans like Opera
    
    # become 0 first, the terminal wait/refork with G underneath it
    # 1 then takes up Ge-minding & the c
    # 2 takes up a self consciousness & the sc
    # by splitting further
    
    # some everywheres
    Gc&Up = 'Up'; # unify results to
        # reads in free time (Baye) and incorporates
    Gc&Down = 'Down'; # send work to
        # blocking read (Down itself?), does CeLovulation per message
    
    # to fork an output handler (O) and children (U)
    my $M = [];
    # always creates an ipdir G.d/ip/$ip for us,
    #  usually putting in/out/err there and starting anew,
    # but first:
    # noop: don't fork and go Motoring, just aquire ipdir
    # io: make only those channels
    #   together makes Gc&inch.in handle Gc&ipd/in and leaves stdin
    # ip: keeps same 0 (this process) when restarting
    # ,ip=>Gc&ip
    my $g =
    m G.t=>{}=>{nogo=>1}
    #,io=>['in']}
    # all are W to go and do
    #   esp with e later
    m Up
    m Down
    m $_ for @{ar.m||[]};
    
    # these things should get their hangaroundness somehow
    # probably reading Gc&inch and sleeping (via timer if loose)
    
    for my $C (@$M) {
        # opens new land as C
        Rw CeLovulation $C;
        
        c&nogo && s&pid || sayre("Astep C.t") && next;
        c&nogo && sayre("AstDoneu ep C.t") && last;
        
        s&pid || return do {
            saygr "Flies in as: C.t $$";
            sleep(2), sayre("Doing life") for 1..4;
            saygr "Done";
            exit;
        };
        saygr "Stands as: G.t ($$) -> C.t (s&pid)";
    }
    !gs&pid && return sayyl(" AM g.t") &&
        Rw Baying $forever=1;
    # always us now, wait for Up or so...
    # multiple inwardses, pretending to be in cluster and ourselves as we were
    Gc&inch.std = \*STDIN;
    
    
    my $op = gs&pid || die "No first pid";
    my $clean = &{
        my @l = grep {!-e "/proc/$_" } split "\n", ''.`ls -1ct Gc&bay/G/Ge/p`;
        @l && sayre "Kill @l";
        kill KILL=>$_ for @l;
    };
    saygr "Waiting fr $op (or ".ki $g;
    
    waitpid($op,0);
    goto rem if readlink("Gc&bay/p/Up/will") eq 'restart';
    sayyl "Done! Restart?";
    <>;
    rem: $clean->();
    snooze 4000;
    goto town;
CeLovulation: | # the C is causing a fork
    # or adopting the identity of:
    c&ip ||= [@{Gc&ip||[]},Gc&ipi++];
    unless (c&noop) {
        my $pa = $$;
        (s&pid = fork()) && return;
        Gc&ipi = 0;
        Gc&parent_pid = $pa;
    }
    else {
        s&pid = $$;
    }
    Gc&ip = c&ip;
    
    # process' own space by ip
    Gc&sip = join('.',@{Gc&ip});
    Gc&ipd = "G.d/ip/Gc&sip";
    `mkdir Gc&ipd`;
    
    # reopen io into ipd
    c&io ||= [qw'in out err'];
    my $te = {
        out => \*STDOUT,
        err => \*STDERR,
        in => \*STDIN,
    };
    Gc&inch = {};
    # close everything/restart t
    for my $ch (@{c&io}) {
        my $ha = $te.>$ch;
        my $f = "Gc&ipd/$ch";
        -e $f && die "Had $f!";
        `touch $f`;
        undef $ha if c&noop; # doesn't take over stdin
            #0;# close $ha; # < maybe dont close it?
        # emits spot/p/10813/out open noise: Inappropriate ioctl for device
        # around here
        my $mode = $ch eq 'in' ? '<' : '>';
        open($ha, $mode, $f)
             || die "$f open fail: $!";
        $! && sayre "$f open noise: $!";
        undef $!;
        Gc&inch.>$ch = $ha if $mode eq '<';
    }
    
    $0 = "Gc&ipd";
    # G names, become the latest source of W
    #   to group/stage e to
    unless (c&noGt) {
        my $t = c&Gt || C.t;
        my $Gt = "G.d/G/$t";
        unlink $Gt if -l $Gt;
        symlink "../ip/Gc&sip", $Gt;
        symlink $t, "Gc&ipd/Gt";
        $0 .= " $t";
        G.t = $t;
    }
    
    # p pids
    my $pt = "G.d/p/$$";
    unlink $pt if -l $pt;
    symlink "../ip/Gc&sip", $pt;
    symlink $$, "Gc&ipd/pid";
    
    return if c&nogo || c&noop;
    
    saybl "CellOvulation: $0";
    
    4s&toy->({to=>[$C]});
    
    saybl "Wandering Ovv";
    
    s&pid
Up: | # organise gondolas, G Up receives Elanings for Wlanings
    Rw Tiot;
    n te=>''=>wdump(2, G.c),'dis,fs:5'
    sayre "J.t: Hihi: A.inG";
    Rw GiveTime;
    snooze 222;
    #n Fish
    n Opera
Down: | # take medicine and go gondola riding
    Rw Tiot;
    sayre "J.t: Hihi: A.inG";
    # get stuck in a read loop, unless Gc&freetime
    while (1) {
        $_ = <STDIN>;
        chomp;
        snooze 333;
        $_ =~ /\w/ || next;
        my $C = eval { djson $_ };
        if ($@) {
            sayre "NOT json C: $_";
            $@ = '';
            return;
        }
        $C = G&Ct,$C if ref $C eq 'ARRAY';
        Rw CeLovulation
        # returns nothing as the parent,
            || next;
        # child may have Rw GiveTime since
        saybl "Done a Down";
        if (T.Uddoff || Gc&freetime) {
            T.not = 1;
            return saybl "Uddoff";
        }
    }
Exit: |
    exit;

