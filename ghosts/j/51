Interesting: | # running a cluster
    
    =head1 the G
    
    Gc&bay is the G,
        a branch and island of activity
        
        the $g is the in-G branch
            suggested in 5s&stores
        the $gd is "$bay/$g"
    
    G.t the thing, as it has its own process start
     = Ge - be generally
         reuse/lock by thaw, become G0ling under the master if extra
        many processes join, the G1, mastering a list of G*
        including G2 (5 templates), 3 (6 proc follower), 4 (tv set)
        G8s elvising, times
    
    fork - from?
    name - at depth of takeover
    Gover                                        
    
    =head1 W routing
    
    Gc&Glan the name on Opper to receive this W
Co: | # see */Co/* bay/Cluster operandis / Troom, tell G what/how
    # the G/bay usually is in one piece
    # the name being mapped out to different things
    # it may also multiply out to lots of same-ish things
    #   things - the fittings of experience
    # 
Ge: | # Ge Co, 1 finds itself and moves in, or plugs into the society...
    # selves
    saybl "selves! G.t on Gc&bay";
    
    saybl "Alreadies: ". wdump 3, Js&top.sc.z;
    
    n "thught"=>1=>"tho"
    
    Gs&fishing++ || 
        Rw GoFishing - WebHost;
    saybl "IDnis!";
    # pids in bay/G
GoFishing: | # become Gc&bay/G.t of G1 ideally, possibly G0
    my $p = $$;
    $| = 1; # autoflush output channel
    
    
    # goner?
    # mkoJ called by Wout, sends lines with Ilan on Opper
    # Opper Ilan $f elvised by Ualve on Udders
    #     Ilan unifies names/routes points by elvising Win
    G.mkoJ = &Wc{
        c.holst = $W; # geoplace on desk section
        my $Y = Gc&B.sc.A;
        c.Y = $Y; # A coming from
        G&elph,NetPut=>[out=>1=>$c]
    };
    
    # assume already 5s&stores
    Gc&bay || die "Nobay";
    
    # cluster init/takeover/join?
    G.d = "Gc&bay/G/G.t";
    for ("Gc&bay/p") { # the old pid+Gt directory
        -e && !-l && die "$_ is a directory";
        -l && unlink $_;
        # making it see 
        symlink "G/G.t/G", $_;
    }
    # to contain 1-5 for this W,
    # ip/$ip - process'
    # G/$t - G names
    # W/$t - W names
    town: for my $Gdt (qw'ip G W p') {
        `rm -rf G.d/$Gdt`;
        `mkdir -p G.d/$Gdt`;
    }
    `rm -rf Gc&bay/neu`; # clustaceans like Opera
    
    # become 0 first, the terminal wait/refork with G underneath it
    # 1 then takes up Ge-minding & the c
    # 2 takes up a self consciousness & the sc
    # by splitting further
    
    # some everywheres
    Gc&Up = 'Up'; # unify results to
        # reads in free time (Baye) and incorporates
    Gc&Down = 'Down'; # send work to
        # blocking read (Down itself?), does CeLovulation per message
    
    # to fork an output handler (O) and children (U)
    my $M = [];
    # always creates an ipdir G.d/ip/$ip for us,
    #  usually putting in/out/err there and starting anew,
    # but first:
    # noop: don't fork and go Motoring, just aquire ipdir
    # io: make only those channels
    #   together makes Gc&inch.in handle Gc&ipd/in and leaves stdin
    # ip: keeps same 0 (this process) when restarting
    m G.t=>{}=>{noop=>1,io=>['in'],ip=>Gc&ip}
    # all are W to go and do
    #   esp with e later
    m Up
    m Down
    m $_ for @{ar.m||[]};
    
    # these things should get their hangaroundness somehow
    # probably reading Gc&inch and sleeping (via timer if loose)
    
    for my $C (@$M) {
        # opens new land as C
        Rw CeLovulation $C;
        
        s&pid || return do {
            saygr "Flies in as: C.t $$";
            sleep(2), sayre("Doing life") for 1..4;
            saygr "Done";
            exit;
        };
        saygr "Stands as: G.t ($$) -> C.t (s&pid)";
    }
    # always us now, wait for Up or so...
    # multiple inwardses, pretending to be in cluster and ourselves as we were
    Gc&inch.std = \*STDIN;
    
    sleep 1;
    
    my $op;
    my $f = "G.d/G/Up";
    sayre "... $f ";
    sleep 1 until -l $f;
    $op = readlink "$f/pid";
    saygr "Waiting fr $op $f";
    waitpid($op,0);
    sayyl "Done! Restart?";
    <>;
    goto town;
CeLovulation: | # the C is causing a fork
    # or adopting the identity of:
    c&ip ||= [@{Gc&ip||[]},Gc&ipi++];
    unless (c&noop) {
        my $pa = $$;
        (s&pid = fork()) && return;
        Gc&parent_pid = $pa;
    }
    else {
        s&pid = $$;
    }
    Gc&ip = c&ip;
    
    # process' own space by ip
    Gc&sip = join('.',@{Gc&ip});
    Gc&ipd = "G.d/ip/Gc&sip";
    `mkdir Gc&ipd`;
    
    # reopen io into ipd
    c&io ||= [qw'in out err'];
    my $te = {
        out => \*STDOUT,
        err => \*STDERR,
        in => \*STDIN,
    };
    Gc&inch = {};
    # close everything/restart t
    for my $ch (@{c&io}) {
        my $ha = $te.>$ch;
        my $f = "Gc&ipd/$ch";
        -e $f && die "Had $f!";
        `touch $f`;
        undef $ha if c&noop; # doesn't take over stdin
            #0;# close $ha; # < maybe dont close it?
        # emits spot/p/10813/out open noise: Inappropriate ioctl for device
        # around here
        my $mode = $ch eq 'in' ? '<' : '>';
        open($ha, $mode, $f)
             || die "$f open fail: $!";
        $! && sayre "$f open noise: $!";
        undef $!;
        Gc&inch.>$ch = $ha if $mode eq '<';
    }
    
    $0 = "Gc&ipd";
    # G names, become the latest source of W
    #   to group/stage e to
    unless (c&noGt) {
        my $t = c&Gt || C.t;
        my $Gt = "G.d/G/$t";
        unlink $Gt if -l $Gt;
        symlink "../ip/Gc&sip", $Gt;
        symlink $t, "Gc&ipd/Gt";
        $0 .= " $Gt";
        G.t = $t;
    }
    
    # p pids
    my $pt = "G.d/p/$$";
    unlink $pt if -l $pt;
    symlink "../ip/Gc&sip", $pt;
    symlink $$, "Gc&ipd/pid";
    
    return if c&noop;
    
    saybl "CellOvulation: $0";
    
    4s&toy->({to=>[$C]});
    
    saybl "Wandering Ovv";
    
    s&pid
Up: | # organise gondolas, G Up receives Elanings for Wlanings
    Rw Tiot;
    n te=>''=>wdump(2, G.c),'dis,fs:5'
    sayre "J.t: Hihi: A.inG";
    Rw GiveTime;
    snooze 222;
    #n Fish
    n Opera
Down: | # take medicine and go gondola riding
    Rw Tiot;
    sayre "J.t: Hihi: A.inG";
    # get stuck in a read loop, unless Gc&freetime
    while (1) {
        $_ = <STDIN>;
        chomp;
        snooze 333;
        $_ =~ /\w/ || next;
        my $C = eval { djson $_ };
        if ($@) {
            sayre "NOT json C: $_";
            $@ = '';
            return;
        }
        Rw CeLovulation
        # returns nothing as the parent,
            || next;
        # child may have Rw GiveTime
        saybl "Done a Down";
        if (T.Uddoff || Gc&freetime) {
            T.not = 1;
            return saybl "Uddoff";
        }
    }

