Ch: | # swim channel
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    # fact cheque ### #
        # 2d39674e5fe7 ##
    # G&t/F thing that blocks: #!
    $n =
    n Shovel V
    $j = ns&J;
    !j and return n waits 1 s:waits %
    $s = js&s;
    !s and return n waits 1 s:waits %
    
    each il ss&lv {
        $l;
        try {
        $l = G&Serialise,l;
        }
        catch (er) { l = "Error: "+er+": "+ki(l) }
        $n =
        n toL 15 $s:l %hue:1$i+9deg,ws:pre,dis:block,ma:1em
        n.y.cv += 0.015 * i;
    }
j/en/Teev: | # string t,s for N
    $M = [];
    each iC N {
        $ts = [C.t,c&s];
        # if any insides \W, throw if empty t?
        $en
        each is ts {
            !s and debugger;
            !s.match(/^[\/\w]+$/) and en = ts
        }
        en and M.push(enj(en)); continue
        M.push(ts.join("\t"));
    }
    return M.join("\t");
j/de/Teev: | # N C t,s for s 
    # slightly toLines, for t and y
    $N = [];
    # TODO way sometimes gets c&code_args = 's' but c&code = acgtar?
    !s.split and s = ar.s;
    s = s.split("\t");
    while (s.length) {
        $k = s.shift();
        $v;
        if (k.match(/^\W/)) {
            k = dej(k);
            k.length != 2 and throw "Funny: "+k, s
            k = k[0];
            v = k[1];
        }
        else {
            v = s.shift();
        }
        $d = G&Cye,[k,''];
        N.push(d);
        null == v and continue;
        if (ar.to == 'cv') {
            d.y.cv = v || 1;
            while (d.y.cv >= 1) {
                d.y.cv *= 0.1
            }
        }
        else { dc&s = v }
    }
    return N
p/en/Teev: | # string t,s for N
    return join "\t", map{
        my $ts = [_.t,_c&s]; 
        # if any insides \W, throw if empty t?
        my $whack = 
        grep{ !/^[\/\w]+$/ }@$ts;
        $whack && sayyl "Was whack: ".wdump 2, $ts;
        $whack ? sjson $ts : join "\t", @$ts
    }@$N;
p/de/Teev: | # N C t,s for s 
    # slightly toLines, for t and y
    my $N = [];
    $s = [split "\t", $s];
    while (@$s) {
        my $k = shift @$s;
        my $v;
        if ($k =~ /^\W/) {
            $k = djson($k);
            @$k != 2 && die "Funny: @$k";
            ($k,$v) = @$k;
        }
        else {
            $v = shift @$s;
        }
        push @$N, G&Ct,[$k,'',{s=>$v}]
    }
    return $N
Spade: | # serve Shovel, bulk version checkings
    # to allow stream/trust ghost happenings
    # say what is changed only
    # u allows transport as <script src=/js/$t>, usually
    #   can insist on being a J "present", T "ing", G "host"
    #  implies k:v resolutions of itselves to be t:s&v or so
    get 'Spade' => &c{
        my $r = {};
        if (my $s = $c->param('u')) {
            my $N = Rw p/de/Teev $s;
            for my $D (@$N) {
                my $C = G&Ct,[D.t,'',{head=>1}];
                my $R = Rw get/js $C;
                # see G
                Rs&ver eq Dc&s && next;
                push @{r.u ||= []}, G&Ct,[D.t,'',{s=>Rs&ver}];
            }
        }
        if (my $s = $c->param('w')) {
            my $N = Rw p/de/Teev $s;
            for my $D (@$N) {
                my $t = D.t;
                $t =~ s/\W+/-/g;
                my $w = G&t,w=>$t;
                # could give them a dig for JaBabz...
                #  Normal could have it
                ws&dige eq Dc&s && next;
                push @{r.w ||= []}, G&Ct,[D.t,'',{s=>ws&dige}];
            }
        }
        #1 && saybl "Javo: ".wdump 4, $r;
        my $s = join "\n", grep{$_} map {
            my $v = $r.>$_;
            if ($v) {
                "$_: ".
                Rw p/en/Teev $N:v;
            }
        }sort keys %$r;
        $s ||= "OK";
        $c->render(text => decode_utf8($s));
    };
    
Shovel: | # mind remote things
    # tend to possible ghost change
    # import things prior to testing...
    G&heading;
    G&u,['MelTest'];
    G&u,['NutIns'];
    G&clusp;
    ys&mah = '10em';
    # #
    # take given names
    1s&ein.ready = &acgts{
        1s&question = s;
        delete 1s&answer;
        upda({fully:1})
    };
    # map mind, give names
    1s&ein.refresh = &acgts{
        delete 1s&question;
        delete 1s&answer;
    };
    # a wave of update/infill
    #  waits for 1s&answer to exist
    #  then does A:u' or G&way noop, watches them complete
    $upda = &c{
        $cv = 7 + G&desca,Math.random();
        c = c || {};
        c.pi = 'updater';
        1s&updater = G&Cye,['update',cv,c];
    };
    # download name changes
    1s&ein.update = &acgts{
        upda()
    };
    # download all names
    1s&ein.cache = &acgts{
        upda({fully:1})
    };
    
    #

    G&S;
    #ys&over = 'scroll';
    #G&way,'t/t_wayttl',ar;
    
    # Babz &question -> 1s&question, knowingly
    # has phases of stuff
    # advertised domes, to blow away/sum/src-check as well
    
    if (!1s&question) {
        # scan inbound culture
        ar.faulty = 1;
        G&way,'S/Ghosts',ar;
    }
    
    # drawing
    if (0) {
    each tN 1s&ghost_tz {
        $i =
        e $t 1
        is&z = N;
        
        $comp = &C{
            c&s and c&s = c&s.length;
        };
        try {
            $l = G&Serialise,i,comp;
        }
        catch (er) {
            l = "Error: "+er+": "+ki(i)
        }
        #t == 'w' and continue
        m $t  $s:l %hue:150deg,ws:pre,ma:1em,fs:22%
    }
    }
    # TODO dome/section off,
    #   so it happens until completed syncronously
    #   question formulation happens once per thing...
    #   a slight o (that s might use) of the question dome's things
    #     will give way
    # come back with change
    if (!1s&answer && !A&mish) {
        G&way,'Q/Ghosts',ar;
        A&mish = 1;
    }
    
        n question -jod_05 $s:1s&question,dl:214 %fs:40%
        n answer -jod_05 $s:1s&answer,dl:214 %fs:70%
    
    n refresh 5 s:re %doe
    n update 5 s:up %doe
    n cache 5 s:ca %doe
    
    1s&updater and G&n,1s&updater
    
    M.map(&s{ ss&dis = 'block' });
    
    # TODO and as a tool for Expect, to check W
    # G&S like G&F but for serialising apart? (1-5 even)
    # G&U like G&F but for reflecting together?
    # TODO and a tool for W difference
pi/updater: | # mind updates many, async
    # similar to/uses NutMinds
    $an = 3s&answer;
    !an and throw "Need answer"
    c&fully and an = 3s&question
    1s&answer != an and delete 1s&updates;
    1s&answer = an;
    
    if (!1s&updates) {
    ~>39 Generating update:
    $z = []; # to be 8
    $al = 1s&already = {};
    each pN an {
        # build index of answer
        # an = question when inhaling names
        $sw = 3s&answer[p];
        $tw = {};
        each in sw {
            tw[n.t] = n;
        }
        # track things we had already:
        $already = al[p] = [];
        each in N {
            $t = n.t;
            if (p == 'u') {
                # A:u's may resync
                4s&mind ||= {};
                $Y = 4s&mind[t];

                if (!Y) {
                    throw "Updating nonexisting mind", t
                    $C = G&Cye,[n.t,''];
                    # being stylehut means javascript
                    !c&I and c&W = 'javascript';
                    Y = G&Aye,'u',2,{s:C};
                }
                else {
                    # had, not answered for, ver as questioned
                    if (!tw[n.t] && Ys&v == nc&s) {
                        already.push(n.t);
                        continue
                    }
                }

                # shelve
                4s&mind[t] = Y;

                # wake us when it completes
                #Ys&N ||= [];
                #Ys&N.push(A);

                # them
                z.push(Y);
            }
            else
            if (p == 'w') {
                $lies = &w{
                    # make way last ages without check
                    ws&now = G&time + 3600;
                };
                # get thing
                $w = G&t,'w',t;
                # is it already?
                if (w) {
                    # and not answered for, ver as questioned
                    if (!tw[n.t] && ws&dige == nc&s) {
                        lies(w);
                        already.push(n.t);
                        continue
                    }
                    # make sure it updates
                    ws&now = 1;
                }
                $C = G&Cye,[t,'',{W:'w'}];
                $Y = G&Aye,'wu',0,{s:C};
                Ys&ready = 0;
                z.push(Y);
                
                if (w) {
                    # so we can talk about the wrong thing
                    Yc&s = w;
                }
                
                # sub to isolate the many variables of t
                $t_w = &Y,t{
                # < G& should treat cb consistently sync
                #   only cb='noop' avoids doing the way
                #   cb!=&s{} should cb instead, assuming it G&ways
                #   cb=&s{} should s = return value of way
                $cb = &{
                    Ys&ready = 1;
                    Y.cv = 0.8;
                    $w = G&t,'w',t;
                    lies(w);
                    Yc&s = w;
                    ~>48 wdone: C.t, ki(w)
                    
                };
                G&way,t,{},cb;
                };
                t_w(Y,t);
            }
            else {
                throw "What type", p
            }
        }
    }
    1s&updates = z;
    }
    #c show update !
    # < unifying ws&now and us&now, will happen in s&in
    # < things pinned to their version able to leave
    if (1s&already)
        n already -jod $s:1s&already,dl:4 %
    
    # watch A
        $not;
        # check u' 8
        each iY 1s&updates {
            # u' 8 checks the linkage/version on some object
            # winds back to 3 if not
            Yc&T and G&thro,Y,8;
            $n = Yc&s;
            
            $verbit = Y.t == 'u' ? ',v:'+ns&v : ',dige:'+ns&dige;
            
            if (Y.t == 'u') {
            # should have a reliable way to hang hooks on an A...
            # when u' get to 8, lie about expiry date
            # much like w does above, but we catch u here, while "in"
            # (their ttl last 2x as long anyway)
                # lies3
                !Ys&sabotagi and Ys&now = G&time + 3600;
                Ys&sabotagi = 1;
            }
            
            $s = ki(Y,2)+" "+n.t+"  %ready:"+Ys&ready+verbit;
            $t = i+"thji";
            m $t  $s:s %dis:block,fs:70%
            #m $t  $s:ki(n,4) %dis:block,hue:100deg,fs:60%
            Y.cv < 0.8 and 4s&N.push(Y); not = 1;
        }
        if (not)
            m waits 1 s:waits %
        if (!not)
            m ready 1 s:redy %fs:300%
Q/Ghosts: | # check t:ver ghost versions
    1s&ein.answer = &acgts{
        ~Passad: ki(s)
        1s&answer = s;
        #G&e,[A.1.t]
    };
    # need this later, async in done() forgets to answer
    # makes an 's.split not function' error?
    # < an all-callbacks system?
    G&way,'j/de/Teev',{},'noop';
    
    $q = 1s&question;
    q = $.extend({},q);
    each ts q {
        q[t] = G&way,'j/en/Teev',{N:s};
    }
    1s&quested = q;
    
    $done = &s,c{
        ~>79 Q/Ghosts answer: A.1.t, s.length
        $r = {};
        s == 'OK' and s = '';
        s = s.split("\n");
        $lt = /^(\w+): /;
        each iz s {
            z.length == 0 and continue
            $m = z.match(lt);
            !m and throw "Invalid pasam: "+ki(s)
            $t = m[1];
            z = z.replace(lt, '');
            r[t] = G&way,'j/de/Teev',{s:z};
        }
        #1s&answer = r;
        # elvising it Js
        $e = G&Cye,['answer','',{s:r}];
        G&e,['Shovel'],e
    };
    #~>79 Q/Ghosts asking: A.1.t
    G&question,'Spade',q,done;
    
    
S/Ghosts: | # scan 4 for import/ghost versions
    # ar.drawing - for marks on the ground
    # two types of G-trace,
    # < one type with many types within
    $de = {w:[],u:[]};
    # u/mind
    each tY 4s&mind {
        $n = Yc&s;
        ns&v == 3 and continue;
        !Ys&now || ns&now and throw "C changed"
        
        de.u.push(n);
        
        #m $t+"mind"  $s:ki(n) %
        #m $t+"mindaye"  $s:ki(n.y.A) %hue:50deg,ml:1
    }
    
    # and way
    $way = A.5.I.w;
    !way and throw "w where?"
    each tC way.y.tw {
        de.w.push(C);
        
        #m $t+"way" $s:ki(C.sc,4) %hue:250deg
    }
    
    
    #n minds -h1
    #n minds -jod $s:de.u %
    
    #n way -h1
    #n way -jod_04 $s:de.w %fs:25%
    
    $q = {}; # type: N C(t,s=version)+
    each tN de {
        q[t] = N.map(&C{
            $s = t == 'w' ? s&dige : s&v;
            return G&Cye,[C.t,'',{s:s}]
        });
    }
    if (ar.faulty) {
    each tN q {
        $c = N[0];
        cc&s = (cc&s+'').replace(/\w/,'qua');
        #~The: t, v.slice(0,33)
    }
    }
    
    each tN q {
        $tw = {};
        $tl = [];
        each in N {
            tw[n.t] = n;
            tl.push(n.t);
        }
        tl = tl.sort();
        N = tl.map(&s{ return tw[s] });
        q[t] = N;
    }
    # ki could almost encode all this...
    #n wayts -jod_04 $s:q,dl:14 %
    
    # u:[] of A:u's C, asking for cjs or so
    # w:[] of way, s&dige version, c&s the code, etc
    1s&ghost_tz = de;
    # type: t v( t v)* string packed name + versioning, de/Teev
    1s&question = q;
    return q
pi/Cod: |
    ys&dis = 'block';
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];

    #
pi/h1: |
    $s = c&s || C.t;
    delete c&s;
    $n = G&n,['t',0.01,{s:s},{blr:'2px',zi:-20}];
    $size = A.1 == A.3 ? "200" : "150";
    ns&fs = size+'%';
    ns&mt = '-0.5em';
    ns&dis = 'block';
t/t_wayttl: | # G&ting used by G&quest_w
    G&heading;
    G&u,['NutIns'];
    G&clusp;
    
    1s&step ||= 0;
    1s&step++;
    
    1s&bits ||= [];
    $b = 1s&bits;
    $t = G&Cye,["try"+1s&step,2];
    
    try {
        $re = G&quest_w,'t/Serialise';
        tc&s = re;
    }
    catch(er) {
        ts&er = er.message;
        #throw er
    }
    
    m $t.t 4 $s:ki(t) %hue:1$1s&step+9deg,ws:pre,dis:block
    b.push(M.pop());
    each ip b {
        n $p
    }
    n toL 15 s:sta %hue:139deg,ws:pre
    
    
    1s&step < 8 and T.yl = 2000;
    if (T.yl) {
        $loop = 1s&loop = Math.random();
        G&yl:T.yl,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[J.t] };
    }
    else {
        
    }
    
NutIns: | # new stuff
    u j
    n \'of:eye'
    
    # make string, able to leave program memory
    #  s=C, with insides
    #   G&ind makes clone.y.D = origin, but no .y.tw etc.
    #   G&Compress tidies it up
    #   G&toLines makes one string, no y but cv
    Serialise: %acgt:s comp
        $ers = [];
        $cb = &s,d{
            $part = "Compress";
            try {
                G&Compress,s;
                part = 'comp';
                comp && comp(s,d);
                d.not and return
                part = 'toLines';
                return G&toLines,s
            }
            catch (er) {
                ers.push([part,d,s,er]);
                return ki(s,2)+"   !"+part+"! "+er
            }
        };
        $l = G&ind,s,cb,{hup:1};
        #ers.length and throw "unserial", ers
        return l
    
    # various things shouldn't be let out
    # something else (G&toLines) makes y.* disappears, wormholing only cv
    # < an embryonic composited sub, like thro, 
    # < the opposite, collected from n and something else...
    # < use the d (state from G&ind) to make links for duplicated objects
    # see j/7 K
    #   used to mute any ref not gk =~ /x$/
    Compress: %acgt:s d
        # the other things are around, also via y.{tw,tv,in} etc
        delete ss&z;
        
        # especially if pi
        ss&J and delete sc&s;
        typeof sc&s == 'object' and delete sc&s
        delete ss&J
        
        $mute = {c:['code'],sc:[]};
        # this just does: sc&code and delete sc&code; sc&mc = 'code';
        each nk,gks mute {
            $he = s[nk];
            $muted = {};
            each i,gk gks {
                null == he[gk] and continue;
                muted[gk] = 1;
                delete he[gk];
                # data should be limited somehow...
            }
            # say that it is muted, eg c&mc = 'muted Cc keys'
            #  in a thing that could pretend to be a hash for simplicity...
            if (muted.length) {
                $ou = 'm' + nk.slice(0,1);
                $was = s.c[ou];
                if (was) {
                    was = G&peel:was,{sep:' '};
                    $.extend(muted, was);
                }
                s.c[ou] = G&depeel:muted,{sep:' '};
            }
        }
    
    #c newthing
    # gets I/c&of/C.t
    # if in A.1-5.I, trust up to date
    # otherwise ask (async) some remote
    
    # G&t,'e'        -> I/e
    #    - return an entire personality
    
    # G&t,'i','peel' -> I/i/peel
    #     - returns that thing (what G&peel does) of the i personality
    
    # and things that fit here defiantly
    # given s=C it can use more smarts, async
    
    #   I/W/Expectation - gives s&top of saved W
    #     there is a list of them floating around,
    #     as:
    #         placeofplaces 9
    #           Expectation  c&W:W
    #              ...
    #           ...
    #     they each may have s&I,
    #       which G&t is usually selecting from the general availability of
    
    #   I/js/Expectisma - gives s&I from that W, with code via <script>
    
    #    I/w/Expect - returns the one w/Expect thing, not a W
    #        < it must be in some I/W/*/$w
    #      have an index (w/way/$w) to use for now
    
    
    # otherwise the latter three (of=W,js,w) can become async
    #  resourcing quests needing question time
    
    # < s = G&Cye,s if Array?
    ting: %acgt:s t
        $C = {};
        if (typeof s == 'object') {
            C = s;
            s = c&of;
            t and throw "C & t";
            t = C.t;
        }
        else {
            C.t = null == t ? '' : t;
            C.y = {};
            C.c = {of:s};
            !c&of and throw "Gt without an of";
            C.sc = {};
        }
        
        # trusted as current beacuse 4/5 are alive
        # covered by the version of Normal attached to everything
        $D = G&t,c&of,C.t;
        D and return D;
        
        # otherwise send question/pull into 5 to keep up to date
        #  C - the question
        #  P - the pull/import state 
        #  D - the item
        
        # C (question) should get Ds&v (and more?)
        #   often it shall be deciding to wake up if news
        
        # P (pull) lives in 5s&in
        #   and any ra&in where it's used,
        #    and hoists to 1-3s&in
        #     so they can be traced into the dome that G&t'd it
        
        # s&in should be of/t/pointer = P
        
        # pointer usually a W, or maybe several conjoined by \t
        #   like elvis points paths into things
        # pointer could be '' if it's something in 5,
        #   then the version of 5 (or Normal) is something's upstream
        # pointer may be something (W) visible on 4/5's bays,
        #   or deep inside somewhere
        
        # as s&in disappears down inside a W,
        #   shall its pointers stay focused A.3,
        #   or start pointing upwards:
        #     because it could use s&in to take input from itself
        #   a lark for now,
        #   getting them to pool on A.3 for A.3 would do the trick
        #   even without a remove-when-they-disappear thing, see s/swim
        
        # s&out could be pointer = s
        #  to everything it writes
        #   the path being W/page, or A.1.t/'',
        #   from the perspective of A.2
        
        # so s&in is qualified by of/t finding and pointer (a kind of url)
        #   and has P, a pull/remote/link item to track change,
        #     for Pc&s = D, the thing itself
        #   from that specific pointered remote
        #   the G&ting may end up with a different P,
        #   but would work it like a different version of the same P,
        #   the P you keep (branch becoming local?) must clone to heres&in
        
        # and s&out is qualified by pointer (a kind of url),
        #   1s&out:
        #     has a P-like push item to track change,
        #       with Pc&s = s, the brain, the prosthetic memory made
        #     or the perma-e that pulls it into storage...
        #   Ps&out:
        #     paths from 4 to any A.3 it is used 1s&in
        #     untidiable... unless updating because of it,
        #       the extra minder could see the lack of relation-creation
        #     the updator would join all 1s&in and 5s&in,
        #       know P changed and following Ps&out is cheating?
        #       spreading out to the users... is all-ahead-bendix
        # 5s&in -> 1s&in -> ss&in -> rs&in
        
        #c LUM
        # lets forget s&out until s pages and data surfs
        # and forget s&in hoisting
        # just clone 5s&in..P into 3s&in..P, let chaos clean up
        #   such an attention to detail that wants to turn into awake desire
        #     is interesting. model it.
        # we are importing these types (c&of) of thing (t)
        5s&in = 5s&in || {js:{}, W:{}, w:{}};
        !5s&in[c&of] and return
        $type = 5s&in[c&of];
        $thing = type[C.t] = type[C.t] || {};
        c&p and throw "pointers diffract where thing must be from"
        s&P and throw "quest sP: specific pull/push"
        $found;
        # P coming from the first location... unless something
        each pP thing {
            c&p && c&p != p and continue
            found and throw "many points of thing", thing
            found = P
        }
        P = found;
        # is our cache too old
        if (P) {
            $ttl = 4c&ttl || 5;
            Pc&ttl_mult and ttl *= Pc&ttl_mult;
            Ps&now && !G&time,Ps&now,ttl and P = null
        }
        #c do we know
        if (!P) {
            P = G&Cye,[C.t,C.y.cv,{of:c&of},{}];
            $get; # how to ask
            $got; # response to P/c&s
            if (c&of == 'w') {
                get = '/way/'+C.t;
                got = &P,s,c{
                    $w = G&Cye,[C.t,1];
                    wc&s = s;
                    ws&of = 'w';
                    # hash of the source, compiled in s
                    ws&dige = c.getResponseHeader('Dige');
                    Pc&s = w;
                };
            }
            if (c&of == 'js') {
                get = '/js/'+C.t;
                # T would put this c&v to wind back from bugs
                c&v and get += '-'+c&v;
                got = &P,s,c{
                    $src = c.getResponseHeader('Location');
                    $m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
                    $W = m[1];
                    $ver = m[2];
                    $W = G&Cye,[W,1];
                    $I = Ws&I = {};
                    Ps&v = Ws&v = ver;
                    Pc&s = W;
                    # js doesn't communicate much of the W 9, or anything not in I
                    
                    # move usual after-got() act to after this callback
                    $ready = c&ready;
                    delete c&ready;

                    $callback = &script,e{
                        # D & C in here refer to the of & the of/t
                        # < check for errors from that script?
                        $tocfunc = W.t+'_'+Ws&v;
                        !window[tocfunc] and throw "Notocfunc: "+tocfunc;
                        $toc = window[tocfunc]();
                        $D;
                        each il toc {
                            $ind = v[0];
                            $C = G&Cye,[v[1],v[2],v[3],v[4]];
                            if (ind == '') {
                                D = I[t] = C;
                                D.y.tw = {};
                                D.y.tv = {};
                                Ds&z ||= [];
                            }
                            else if (ind == '  ') {
                                D.t != s&js and throw "Csjs not last D", C, D;
                                c&code = window[s&name];
                                typeof c&code != 'function' and throw "Cccode not function", C, D;
                                # grow I
                                D.y.tv[C.t] ||= {};
                                D.y.tv[C.t][C.y.cv] = C;
                                D.y.tw[C.t] = C;
                                $l = Ds&z.slice(-1);
                                l[0] and l[0].y.next = C;
                                Ds&z.push(C);
                                D.y.in ||= C;
                                if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                                    G[C.t] = c&code;
                                }
                            }
                            else {
                                throw "deep C: "+W+"/"+t, v
                            }
                        }
                        
                        ready();
                    };

                    $have = $('body script[src="'+src+'"]');
                    have.length and return callback();
                    G&add_script,src,callback;
                };
            }
            if (c&of == 'W') {
                get = {url:'/W/'+C.t};
                if (c&s != null) {
                    get.type = 'post';
                    get.data = {s:c&s};
                }
                got = &P,s,c{
                    $r = dej(s);
                    if (r.ok) {
                        s = '';
                        r.ok == 'created' and s = c&s
                        else
                        r.ok == 'found' and s = r.s
                        else
                        r.ok == 'updated' and s = c&s
                        else
                        r.ok == 'deleted' and s = null
                        else {
                            throw "other kind of ok",r.ok
                        }
                        if (s) {
                            $N = G&readLines,s;
                            N.length != 1 and throw "Weird tW lines", s
                            s = N[0];
                        }
                        Pc&s = s
                    }
                    else {
                        r.er != 'not found' and throw "tW er", r.er
                        Pc&s = null
                    }
                };
            }
            
            $done = &s,c{
                # every pulling happened now
                Ps&now = G&time;
                # specific stuff moves from the response to P and Pc&s
                got(P,s,c);
                # stash the P on 5s&in
                Pc&p == null and Pc&p = '';
                thing[Pc&p] = P;
                # and on Cuestion
                s&P = P;
                # specific continuation
                c&ready and c&ready()
            };
            G&question,get,done;
            
            c&async and c&async();
            c&async and throw "async didnt async"
            # returning undef (later) means nothing found
            # could c&l = netslopes (above 5) to look up... lumit
            G&TuneTimeMachine,c&of+':'+t
        }
            
            
        
        #c stash
        if (P) {
            # hang ourselves on Ps&out?
            # copy P to your s&in
            Pc&p == null and throw "no Pcp, even if ''"
            P = G&Cye,P;
            3s&in ||= {};
            3s&in[Pc&of] ||= {};
            3s&in[Pc&of][P.t] ||= {};
            3s&in[Pc&of][P.t][Pc&p] = P;
            # give the question the link to the answer
            s&P = P;
            # return the answer
            return Pc&s;
        }
        # automatically mirror C in 5s&things.c&of.$t?
        #  tracking what things we think we know from outside
        #   the 4s&mind (A:u') has ttl and a&N back to users (A:u)
        #   the 5s&I.w.$way has ttl too, but shouldn't
        # could the 5s&thing, for each c&of/t,
        # be things to G&t again to compute ghostliness
        # and linking attention back to A.3s,
        #   maybe s&G thing like an I thing, but with minimal info
        #   that pools upward through J, s, domes, even individual C
    
    #c way/js questions as C
    # P import state
    # D the item
    quest_w: %acgt:t ar cb
        $Q = G&Cye,[t,'',{of:'w'}];
        Qc&ready = &{
            # Jin should accept this A again
            # < never set to 0, might speed it up if...
            a&ready = 1;
            # so wait for it...
            !cb and return
            if (G&arfgunc,cb == "s") {
                # way randomly happens, give return value to cb
                # without A lining up around it (it may do so itself)
                # see G&waylay for use case as delayed call
                $s = G&way,t,ar,'already_async';
                cb(s);
            }
            else {
                # containing a sync G&way call
                # or a way to get the context revisted?
                cb(t,ar,w);
            }
        };
        Qc&async = &{
            cb == 'noop' and cb = &{}
            else
            typeof cb == 'string' and throw "Cant go async: "+cb
            
            # Jin should avoid this A for a while
            a&ready = 0;
            # and throw/abort if no callback
            !cb and G&TuneTimeMachine,'w:'+t
        };
        $w = G&ting,Q;
        return w
        
    
    quest_js: %acgt:t
        $Q = G&Cye,[t,'',{of:'js'}];
        Qc&ready = &{
            A.cv = 0.4;
            # Jin should accept this A again
            # < never set to 0, might speed it up if...
            a&ready = 1;
        };
        Qc&async = &{
            a&ready = 0;
            4s&N.push(A);
            T.not = 1;
        };
        $W = G&ting,Q;
        #a&I = Ws&I;
        #a&v = Ws&v;
        return W
    
    #c rebuild tcp
    # < have A, so async in handler gets retried
    #    (or G&way noop deps just before handling)
    # < get or ws
    # retry, expire
    # c == r
    question: %acgt:get data cb
        $is_done;
        typeof data == 'function' and cb = data; data = null;
        data and get = {url:get,data:data};
        $r = $.ajax(get);
        $done = &s,how,c{
            is_done and return
            is_done = 1;
            r.status != '200' and throw "ques: "+r.status+": "+get, r
            cb(s,c)
        };
        r.done(done);
            
            $checks = 5;
            $check = &{
                is_done and return
                !r.status && checks-- > 0 and return G&yl,150,check
                done(r.responseText, 'maybe', r)
            };
            check();
    #c c&Four, c&G
    u jc
    # of html? needs to give innard an element to be in
    # could do a kind of bootup osc for one thing...
    # have G&n return with the child running & grounded
    # or make the element first, etc, give to el333 to attach
    n \'of:om'
    # starts a child process - rename to G at some point
    #   see G&Four
    # s is a runlevel
    Four 6:
        $Y = 1s&child = G&Four,C.t;
        $p = Ys&parent = A.1;
        # doesn't have a clock running yet...
        # should n {C},{c:resyncin:20ms} and push the Jinloop button via e?
        $startup = &acgt{
            G&n,['Lunch'];
        };
        s >= 6 && ps&subphone and ps&subphone(startup);
        # 
        

