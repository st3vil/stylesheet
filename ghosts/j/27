NutLands: | # reading bay/el/Figures/1,2 and etc
    u jc
    n \'of:om'
    
    # this stuff shouldn't need to be said,
    # tree reader
    
    # s&lv spawns a c&lv within itself
    0 &&
    lv 66: %nk:sc
        G&om,[C.t,'',{lv:s},C.sc]
    
    # c&lv haps before/without el creating an element 
    # G&nn manually to A.b self
    # G&oms the lv at the same A.on
    0 &&
    lv 17:
        $b = A.b;
        G&nn;
        A.b.lv ||= {};
        $lv = A.b.lv;
        s&f and lv.f = s&f;
        !lv.f and ~die~LVnof: C, lv
        lv.haN ||= {};
        A.b = b;
        !c&seeks and c&seeks = [s];
        t$
        $.each(c&seeks, &i,v{
            lv.haN[v] and return
            t ||= v
        });
        if (t) {
            $.ajax('shed/'+lv.f+'/h/'+t).done(&L{
                !L.length and ~noL: lv.f, t
                T.readinglv = lv.f+'/h/'+t;
                $l = lv.haN[t] = G&readLines,L;
                !l.length and ~nolinesin: t
                l = l[l.length-1];
                $h = ''
                ls&parent and h = 'v '+ls&parent;
                ~lvread: C.t, t, h
                ls&parent and c&seeks.push(ls&parent);
                G&yl:30,&{ G&throat,7 };
            });
            return T.not = '2';
        }
        // now from oldest to newest
        c&seeks.reverse();
        if (lv.ha) {
            $is
            $.each(c&seeks, &i,v{
                lv.ha === v and is = 1;
            });
            while (is && c&seeks.length) {
                while (c&seeks[0] === lv.ha) {
                    c&seeks.shift();
                    is = 0;
                }
                is and c&seeks.shift();
            }
        }
        $ii = 0;
        $wi = 0;
        $ha;
        $.each(c&seeks, &i,t{
            ii++;
            $N = lv.haN[t];
            $.each(N, &i,v{
                wi++;
                G&om,v;
            });
            ha = t;
        });
        
        $bumps = ii+'x'+wi;
        ~wlv: C.t, s, lv.ha, bumps
        ha and lv.ha = ha;
        return T.not = 1;
        
        
    
    #c readLines - string to Cs
    
    n \'of:eye'
    u j
    readLines:
        $L = s.split("\n");
        $oL = [];
        $tot = L.length;
        $N = [];
        $stack = [];
        $paniconce = 0;
        
        while (L.length) {
        
        $l = L.shift();
        oL.push(l);
        !l.length and continue
        $lin = l.match(/^(\s*)(.*)$/);
        $ind = lin[1];
        $d = ind.length / 2;
        l = lin[2];
        $li = l.split("\t");
        $t = li[0];
        $y = li[1];
        $c = li[2];
        $sc = li[3];
        $s = li[4];
        
        t.match(/^\W/) and t = $.parseJSON(t);
        
        y ||= 1
        y = 1*('0.'+y);
        
        if (s && s.match(/^\W/)) {
            s = $.parseJSON(s);
        }
        if (c && c.match('^"')) {
            s = $.parseJSON(c);
            c = {};
        }
        else if (c && c.match(/^\W/)) {
            c = $.parseJSON(c)
        }
        else if (c) {
            c = G&peel,c
        }
        else { c = {} }
        
        s and c.s = s;
        
        if (sc && sc.match(/^\W/)) {
            sc = $.parseJSON(sc)
        }
        else if (sc) {
            sc = G&peel,sc
        }
        else { sc = {} }
        
        $C = {t:t,y:{cv:y},c:c,sc:sc};
        
        #c readLines indented bits
        
        $k
        $v
        $indenting = &{
            !L.length and return;
            $m = L[0].match("^"+ind+"  (\\w[\\w ]+):(?: (\\||.+))?$");
            !m and return;
            k = m[1];
            v = m[2];
            return 1;
        };
        while (indenting()) {
            $string
            if (v === '|') {
                string = 1;
                v = undefined;
            }
            v && v.match(/^\W/) and v = $.parseJSON(v)
            L.shift();
            k = k.split(' ');
            $nk = k.shift();
            $gk = k.join(' ');
            if (!v) {
                $s = [];
                $one;
                $blockquoting = &{
                    !L.length and return;
                    $m = L[0].match("^"+ind+"    (.*)$");
                    !m and return;
                    one = m[1];
                    return 1;
                }
                while (blockquoting()) {
                    s.push(one);
                    L.shift();
                }
                v = s.join("\n");
                # console.log("Loaded "+nk+gk+": "+v+'  Next: '+L[0]);
                if (!string) {
                    v = jsyaml.safeLoad(v);
                }
                else {
                    !v.match(/\n$/) and v = v+"\n"
                }
            }
            C[nk][gk] = v;
        }
        
        d.toFixed() != d and ~fractionalind: d, C, T.readinglv
        d = 1 * d.toFixed();
        if (d > 0) {
            $p
            $dl = d;
            while (dl--) {
                p = stack[dl];
                p and break
            }
            if (dl < d - 1) {
                $few = oL.slice(-3);
                if (! paniconce++)
                    ~toomuchind: d, dl, T.readinglv, few
                d = dl+1;
            }
            ps&z ||= [];
            ps&z.push(C);
            # tv/tw/in/next?
            # a mass inCing, dialecting
        }
        else {
            N.push(C);
        }
        stack[d] = C;
        while (stack[d+1])
            stack.pop();
        
        }
        return N
        
    #c toLines - C to string
    # one C, possibly many lines
    # < use from o that can conjoin the many C
    # but first, oleak tests depth of data structure, true if bigger than d
    # < limit depth not number of nodes, reuse the encoding?
    oleak: %acgt:s d
        $fail = 0;
        $was = window.maxyamling;
        window.maxyamling = d * 3;
        try { jsyaml.safeDump(s) }
        catch (er) {
            window.maxyamling = was;
            er.message != "Too much to yaml" and throw er
            fail = 1;
        }
        window.maxyamling = was;
        return fail
    toLines:
        s and C = s;
        $t = C.t;
        $y = C.y.cv;
         y = (y+'').replace(/^0\./,'') || '';
        # aims for simplicity of notation for G&readLines, G&C, G&peel
        # block quotes (BQ) big strings or data after the  line
        # uses json for anything complicated
        # z insides done by the process around this one Line
        #  - they have the same indent as BQs
        #    but their t should json or not look like BQ
        # hath
        $h = {};
        h.c  = $.extend({},C.c||{});
        h.sc = $.extend({},C.sc||{});
        # needs json
        $n = {};
        # needs blockquote
        $q = {};

        # check out how sayable the values on the line are
        # for c/sc as peelable, 
        # < we can know thing:thing:thing
        #   means thing = 'thing:thing'
        $peelok = /^[\w\.\-%\/:]+$/;
        $nameok = /^\w[\w\.\-%\/]*$/;
        $simp = &s{
            s = ''+s;
            return s.match(nameok) && s.length < 24
        };
        # inject 2sphere
        $lod = &n,nk,gk,v{
            n[nk] ||= {};
            n[nk][gk] = v;
        };
        each nk,gk,v h {
            if (!simp(gk)) {
                lod(n,nk,gk,v);
                continue
            }
            if (typeof v != 'string' && typeof v != 'number') {
                if (G&oleak,v,4 ) {
                    G&oleak,v,24 and throw "Leaky "+nk+"."+gk+": "+ki(v);
                    # big enough to quote, simplifies remainder
                    lod(q,nk,gk,v);
                }
                else {
                    # ref too small to quote, json hemisphere
                    lod(n,nk,gk,v);
                }
            }
            else {
                if (v.length > 42 && v.match(/\n/)) {
                    # long enough to quote
                    lod(q,nk,gk,v);
                }
                else if ((v+'').match(peelok)) {
                    # decipherable to G&peel
                }
                else {
                    # midway to unwieldy
                    lod(n,nk,gk,v);
                }
            }
        }}

        # quote freaks, if just a few break the peelability of many
        each nk,g n { 
            $v = h[nk];
            !Object.keys(v).length and continue;
            $complex_keys;
            each ik g {
                !simp(k) and complex_keys = 1;
            }
            complex_keys and continue;
            
            if (Object.keys(g).length / Object.keys(v).length < 0.3) {
                each ik g {
                    lod(q,nk,k,h[nk][k]);
                }
            }
        }
        
        # remove quoted things and their need of json from the line
        each nk,gk,v q {
            h[nk] && delete h[nk][gk];
            n[nk] && delete n[nk][gk];
        }}
        each nk,gks n {
            # all freaks got quoted:
            !Object.keys(gks).length and delete n[nk]
        }
        #c toLines encoded bits
        $enj = &s{
            return JSON.stringify(s);
        };

        # t can be messy
        $l = simp(t) ? t : enj(t);

        # y.cv = 1 is implied
        l += "\t"+(y != '1' ? y : '');

        # throw it one way or another
        $hem = ['c','sc'];
        each i,nk hem {
            $v = h[nk];
            if (nk == 'c' && 0 == Object.keys(v).length) {
                # blank
                l += "\t";
            }
            else if (nk == 'c' && 1 == Object.keys(v).length && v.s) {
                # t y "the s" sc
                l += "\t"+enj(v.s);
            }
            else if (n[nk]) {
                # json bits: t y {W:"At"} {et:3,se:"te",ra:1}
                l += "\t"+enj(v);
            }
            else if (Object.keys(v).length) {
                # G&peel bits: t y W:At et:3,se:te,ra
                l += "\t"+G&depeel,v;
            }
        }

        $L = [];
        #c toLines indented bits
        # < quoting with Line other N/C looking vals
        each nk,gk,v q {
            $k = "  "+nk+" "+gk+":";
            if (typeof v != 'string') {
                # BQ yaml data
                $v = jsyaml.safeDump(v);
                $vs = [];
                v = v.split("\n");
                each is v {
                    vs.push("    "+s);
                }
                k += "\n"+vs.join("\n");
            }
            else if (simp(v)) {
                # simple strings
                # not confusible into 'Thing 2'
                k += " "+v;
            }
            else if (!v.match(/\n$/)) {
                # BQ implies trailing \n
                k += " "+enj(v);
            }
            else {
                # BQ string
                $vs = [];
                v = v.split("\n");
                each is v {
                    vs.push("    "+s);
                }
                k += " |\n"+vs.join("\n");
            }
            L.push(k);
        }}
        
        # extra lines (L) sorted, larger bits after smaller
        L = L.sort();
        $tidy = [];
        $large = [];
        each is L {
            s.length > 300 ? large.push(s) : tidy.push(s)
        }
        l = [l];
        tidy.length and l.push(tidy.join("\n"))
        large.length and l.push(large.join("\n"))
        l = l.join("\n");
        
        return l

