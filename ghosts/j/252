
Doming: | # in the place in the place
    # see Expect
    # doming: manage way to the future,
    #   by being other to it
    # as chunks separated by: S $number? $title?
    #   the w should know about them
    #   and be minimal and max intelligible
    
    # to be intent on:
    #   domes in order, until done
    #   not redoing earlier work, per dome
    # < computing dependencies emanating from other domes,
    #   keeping a watch function running, etc.
    # ! no support for m/$M
    
    # doming as sections of the pin
    #  - being steps of activity, isolating repeatables
    #  - being acts coded for s to invoke
    #   to be steps in the activity, or too-much-something, changed-something, etc
    
    # all feeding through to each other.
    #   Cs&in explains where things came from in a dome-dome way
    # < finished domes can do their G&s o while in J6,
    #   to wake/sleep later domes if reaction
    # an effect processing. your
    
    # J has step state
    #   thus your A joins onto doming progress, see A&doming
    #   and the history not redone but outdone, at the J level
    1s&step ||= 1;
    # A&til stops retrying
    1s&step_tries ||= 1;
    1s&osc_each_step = 1;
    
    $total = 1s&steps || '?';
    $tr =
    n testrun 1  %dis:block
    $title = &{
        $step = 1s&step > total ? total : 1s&step;
        trc&s = "("+step+"/"+total+")"
    };
    title();
    
    # < a way to set neediness of a J
    # known Jc? 
    $loop = 1s&loop = Math.random();
    G&yl:254,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[A.1.t] };
    
    # explain the jam,
    #   clumped as a todolist at the earliest complainer
    # doesn't yet bail,
    #  supposing steps should/can run all the way through, then wait
    #   tho `return G&til` in pin would leave there and wait
    #    running the show (s) and coming back via loop
    
    #   and the T rests on the crest of a wave,
    #   catching anything anomalous
    A&waitscv = 0.3001;
    A&waitings = [];
    A&til = &s,t{
        A&waitings.push(s);
        #s = "waits:\n"+A&waitings.join("\n");
        if (t) {
            # looks like -an titles about to turn up
            G&n,['waitst',A&waitscv,{s:t},'hue:80deg']
        }
        $n =
        G&n,['waits',A&waitscv,{s:t},'hue:150deg,ws:pre']
        A&waitscv += 0.0001;
        nc&s = s;
        if (1s&step_tries++ > 16) {
            nc&s = "Gave up: "+s;
            delete 1s&loop;
        }
        nc&s += "\n";
        #~>54 Til: s
    };
    A&beready = &{
        if (A&waitings.length) {
            throw "waits on step", A&waitings
        }
    }
    A&S = &s,d{
        # any? named? data joint roller? for/if something?
        typeof s != 'number' and throw "NaN",s;
        
        ~>93 Step: s, 1s&step, A&current_step
        A&beready;
        
        # satisfaction, when total is unknown || known
        if (s == 0 && !A&current_step
            || 1s&step > total) {
            if (total) {
                # check just one further?
            }
            if (!1s&nearly_finished) {
                1s&nearly_finished = 1;
            }
            else {
                delete 1s&nearly_finished;
                1s&finished = 1;
            }
        }
        
        if (s == 0) {
            # end/non-step, done each time unless throw/return
            # de-dome, only thing resurrecting domes once steps complete
            A&doming();
            title();
            return 1
        }
        # finished
        1s&finished and delete 1s&loop; return 0;
        
        s < 1s&step and return 0; # dont redo
        s > 1s&step and return 0; # dont get ahead
        if (A&current_step == s) {
            # second loop of the same while, allow next step
            A&beready();
            1s&step_tries = 1;
            1s&step++;
            return 0
        }
        # bail the first time if osc between
        if (1s&osc_each_step) {
            A&bailstep == s and return 0;
            A&bailstep = s+1;
        }
        # totals should be accurate when not coded
        1s&step > total and ~Sextra steps: 1s&step+'/'+total
        # A has attempts to do a step
        A&current_step = s;
        $t = s;
        d and t += ": "+d;
        #~>59 Expecting: t
        A&doming(t);
        return 1;
    };
    
    #c subgrounds
    # osc flattens them out
    A&doming = &t{
        # < take over grounds&z so A.ground can A out?
        #   or so A always finish what they started with?
        # resets
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A&groundling ||= g;
        #A&groundling != g and ~>grounddiff: ki(g), ki(A&groundling)
        A.ground = g;
        if (1s&domes && !gc&domed) {
            # add all the domes to the ground in this order
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        h and hs&z = [];
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        A.ground = h;
        G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
    };
    
    
    
Expect: | # pull results along, and
    #G&way,'pi/jod',{},'noop';
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    1s&empathy = 3;
    
    1s&steps = 4;
    1s&testname = 't/ExpectArt';
    
    G&way,'Doming',ar;
    A&async = 1;
    
    # sane-wait after dome/step for n A to complete, then osc
    
    # < async n can catch up
     #     as extra dp to the step, which should line up with test data
    
    # < thing that waits at each place,
    #     could see Jin carriage move
    #   gives you assertion factories

    # o Shovel prep mind
    #    to minimise async-ness...
    #    test varied for interesting results
    #    re insulating consciousness from losing trains of thought
    
    # o take steps
    #    works throat-like, M feedback becoming assertions
    #    lots of waiting just a while for some art to appear
    
    # o Shovel sums mind
    #   makes a big 5, in the 1-5 filesystem
    #   or a s&mind packed string...
    
    # 1s&inA is the child 4's .up:
    #   A:atop, where events/everything starts
    
    # the usual elvising into the play
    $a = &C,e{
        $y = A;
        !1s&Y and throw "child 4's .up A not ready";
        A = 1s&Y;
        $r = typeof C == 'function' ? C(A,C,G,T) : G&e,C,e;
        A = y;
        return r
    };
    # prototype for waiting/drawing important n
    $waits = &n,pi,pic{
        $wai = [];
        $is;
        $Y;
        if (n) {
            is = n.y == n ? n.1 == n ? 'J' : 'A' : 'C';
        }
        else {
            wai.push('n*ll')
        }
        is && !n and debugger;
        $notes = [];
        if (is == 'C') {
            typeof n != 'object' || null == n.t || !n.y || !n.c || !n.sc and throw "nonC", n
            Y = n.y.A;
            if (Y) {
                Y.t == 'e' and Y = Y.n; n = Yc&s
                if (Y.t == 'n' && Y.cv < 0.8) {
                    if (Yc&T && Yc&T.leaves) {
                        notes.push("e"+
                            !Y.e ? '?' :
                            Y.e.cv == 0.9 ? '@9' :
                            '@'+Y.e.cv+'<9'
                        );
                    }
                    else {
                        Yc&T && Yc&T.not and notes.push('not')
                        wai.push('n<8')
                    }
                }
            }
        }
        $t = '?';
        if (pi) {
            t = pi;
            pi = 'an';
            # may: '-piform test description'
            if (t.slice(0,1) == '-') {
                t = t.split(' ');
                pi = t.shift().slice(1);
                t = t.join(' ');
            }
        }
        # general resting states:
        # if A is cv==ov, if J is !1s&N.length
        # if C, yA>=8 && s&Js&s
        if (!wai.length) {
            # complete
            !pi and return
            # with pi, go further
            # make sure J & s turned up (they must have if A.cv = 8
            if (is == 'C' && (nc&W || nc&pi || nc&J || ns&J)) {
                $j = ns&J;
                !j and wai.push('sJ');
                !js&s and wai.push('s');
            }
            if (is == 'J' && ns&N && ns&N.length) {
                wai.push('JsN');
            }
            # if it looks done, make this pi about it,
            #   which can async further, usually just describe the object a bit
            #   only A&til exhausts try-system
            if (!wai.length) {
                pic ||= {};
                typeof pic == 'string' and pic = G&peel,pic;
                pic.pi ||= pi;
                pic.s ||= n;
                pic.notes = notes;
                G&n,[t,2,pic];
            }
        }
        !wai.length and return
        # test how long these things take
        Y and Y.4.sc.N.push(Y);
        A&til('Ccom ('+wai.join(',')+') '+ki(n,2), t);
    };
    
    #c startup
    while (A&S(1,"Revisit/Launch")) {
        # < stashing A:n on 1s&* should keep them awake
        $j =
        1s&Launch ||=
        e Launch
        
        waits(j,'env dealer','p:sJ');
        
        $L = js&J;
        $F = Ls&child;
        waits(F,'env');
        
        $r =
        1s&Revisit ||=
        G&e,['Revisit'],['get','',{s:1s&testname}];
        waits(r,'answers');
        
        $w = rc&s;
        waits(w,'answer');
        1s&Answer = w;
        
        A&beready();
        
        #!F and return A&til('Launch no child')
        $Y = 1s&Y = F.up;
        !Y and throw "No Fup?", F
        Y.t != 'atop' and throw "Y (Fup) not t:atop", Y
        
        if (Fc&ipi > 3) {
            # need unique Expect J and Inside J per test
            # or busy/for another test
            # and parallel, etc
            delete 4s&Jtv['Launch'];
            delete 1s&Launch;
            1s&step_tries = 1;
            A&til('child old: '+Fc&ipi);
        }
    }
    
    while (A&S(2)) {
        # < want to ready the tester and the tested
        # our test W may look like an Expect and a Thing
        #  crew end and show end
        #   like T suggests, Swim/We/of things
        #  but without excessive indent, trust the inhaler to link
        $w = 1s&Answer;
        $u = ws&u;
        if (u) {
            $r =
            1s&Ready ||=
            a(['Shovel'],['ready','',{s:u}]);
            waits(r,'mindup');
            A&beready();
            # r elvis completion, but also:
            $j = rs&J;
            j = js&s;
            j = js&top;
            $u = j.y.tw.updating;
            !u and return A&til('updating...','mindin');
            waits(u,'Shovel->updating');
            u = us&J;
            #waits(u,'updating J');
            u = us&s;
            waits(u,'updating s');
            u = us&top;
            waits(u,'updating top');
            ~here:
            A&beready();
            $ready = u.y.tw.ready;
            
            !ready and return A&til('updating...ready','mindin');
            # and that it's for the thing we sent
            $j = ready.y.A.1;
            js&answer != ws&u and delete 1s&Ready; return A&til('readied different')
        }
        else {
            n mindup -an t:non %
        }
    }
    
    while (A&S(3)) {
        #1s&step_tries = 1;
        $sh =
        1s&Sh ||=
        a(['Shovel'],['C+click','',{p:'t'}]);
        waits(sh,'shovelshrink');
        waits(sh.y.A.e,'shovel-e');
        #n shovel-e -an s:sh.e,dl:4
    }
    
    if (0) {
        $n = a(['t/LetsOsc']);
        
        n immediaW 3 $s:ki(n,3) %dis:block
        G&n:['made W','-jod_3',{s:n}];
        $Y = n.y.A;
        $ok = Y.cv >= 0.8;
        G&n:['A complete','-jod_3',{s:ok?"OK":"Not OK: "+Y.cv}];
        !ok and return A&til('n completes');
    }
    
    while (A&S(4)) {
        $n =
        1s&Bystand ||=
        a(['Bystand']);
        waits(n,'bystander');
        n see_here 3 s:gloo %fs:300%
        ~>99 ByTHeWay:
        $Y = 1s&Y;
        waits(Y,'tested Y');
        A&beready();
        $j = Y.1;
        waits(j,'tested 4');
        A&beready();
        G&n:['tested 4sN settles','-jod_632',{s:js&N,dl:2}];
        !js&N || js&N.length and A&til('settling'); debugger;
    }
    
    A&S(0);
pi/an: | # show anything, more assertive than jod
    # self
    ys&hue = '20deg';
    ys&dis = 'block';
    n t 01 $s:C.t %hue:60deg
    
    if (c&t) {
        n t 02 $s:c&t %hue:300deg
        return
    }
    
    $s = c&s;
    # pointing/climbing
    if (c&p) {
        c&p == 'sJ' and s = ss&J;
        else {
            throw "point lost", c&p
        }
        n nav 2 $s:c&p+":" %hue:240deg,fs:80%
    }
    # splatting
    $s = ki(s,c&dl||3);
    # sculpture/modula
    $stwo;
    $m = s.match(/^(\w+) (.+)$/);
    if (m)
        s = m[1];
    
    # the thing itself
    n s 3 $s:s %
    
    # its ideas
    if (m) {
        n s 31 $s:m[2] %fs:70%,sat:0.6
    }
    
    if (c&notes && c&notes.length)
        n note 4 $s:c&notes.join(',') %wc:pre,fs:70%,sat:0.6,hue:160deg
    
    
    
    #
pi/jod: | # a js J, shows a J-shaped bit of data, to aspect serialising change
    # decide lummitry
    # chase detail
    # make assertions
    # code folding J
    # start a tree of -jod
    ys&hue = '20deg';
    ys&dis = 'block';
    # has several osc flavours changable without fully J-ing
    # holds markers into whatever data/code is being asked to be opened
    
    # should partition indenty text,
    # as data structures
    # and save everything, or just a patch/lv
    
    # G&t/search for everything and add blue underline
    
    G&n,['t',0.01,{s:C.t},{hue:'60deg'}];
    
    c&v and G&n,['v',0.02,{s:c&v},{hue:'80deg'}];
    
    
    G&n,['Thing',3,{s:ki(c&s,c&dl||3)}];
Wade: | # serve /W/$t to Revisit
    # defines one place get/set name scheme
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        # read t, write if s
        # all there
        $t = "W/$t";
        # safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1
        my $f = "$t/1";
        
        # returns json:
        my $re = {ok=>1};
        # or ?
        #$c->render(text=>decode_utf8("c&s")); # ,format=>"js"
        
        # if setting
        if (defined $s) {
            if (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.ok = 0;
                re.er = 'not found'
            }
        }
        re.s = $s if length $s;
        $c->render(text=>sjson($re));
    };
Revisit: | # pull/push test data around test run
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&u,['NutText'];
    G&clusp;
    
    1s&ein.get = &acgts{
        $Q = G&Cye,[s,'',{of:'W'}];
        c&s = 
        G&ting,Q;
    };
    G&S;
    
    n maj 3 s:Mah\njor\nka %dis:block,ws:pre
    return;
    # 1s&obj is the last:
    $t = 't/ExpectArt';
    $load = 1;
    $save = 0;
    
    
    
    if (load && !1s&obj) {
        $Q = G&Cye,[t,'',{of:'W'}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    if (load && !1s&ustone) {
        # last save of t
        $w = 1s&obj;
        # its mind, encoded, Shovel adjusts
        $u = ws&u;

        $e = 1s&ust = 1s&ust ||
        G&e,['Shovel'],['ready','',{s:u}];
        # waits until Shovel's&question is what we gave it
        # kind of a deal...
        # almost e Shovel [ puts   %$question:u
        e.y.A.cv < 0.8 and G&thro,e
        e.y.A.cv < 0.8 and G&TuneTimeMachine,'ewaits:'+e.t;
        1s&ustone = 1;
    }
    
    # there's a flood of 1s&val usage,
    # Bab &val -> 1s&val ?
    # test Bab changes: compiling Normal the same
    
    # coming around to game playing with properties
    # on robust, networky objects.
    # so lets build some tools for the emerging language...
    
    # get subbing:
    #   the doming
    #   J-fetching/datadumping
    #   J-fetch-waiting, for Shovel to say ready.
    # all of which should interact,
    # 
    # perhaps even have tools 
    # be an elusive terrain for programming,
    # but one that humans spend a lot of time in:
    # inflecting in rhythms what things have or could have
    # it's an interdimensional hole we're building a door over.
    # the Shovel wait is catching up A:e for a command,
    # but the A:n is the goods... it will be Newsd
    
    # then use this history:
    #$l = G&Serialise,1s&obj;
    #n serialinout $s:l %ws:pre,hue:50deg,fs:15%
    # to help:
    #  - with extra assertions, lum tuning looks
    #  - the test way being just the story
    
    # everything happens
    
    # after happening:
    # pack some other stuff into the test W
    # 
    
    # wants to be n waited on,
    #  to make sure this is fresh Shovel
    $n =
    n Shovel V
    n = ns&J;
    !n and return
    # take this encoded representation of our mind state
    $q = ns&quested;
    
    #n mindstat -jod $s:q,dl:55 %ws:pre,hue:150deg,fs:30%
    
    #n = ns&s;
    #!n and return
    #$u = G&Serialise,ns&top;
    #n mindstat $s:u %ws:pre,hue:150deg,fs:30%
    
    
    
    $n =
    n Expect V
    n = ns&J;
    !n and return
    n = ns&s;
    !n and return
    
    # ns&top...
    #   can be given a toLines encoding by anyone wanting it
    #   stylehouse uses lv.y.toLines = G&toLines
    #   acquires y&toLines = s
    #   or y&L = A:o that did the toLines, which everyone trusts
    #   may be given s&dige by anyone encoding it,
    #   supposedly dige implies toLines
    # assumed to encode as 
    $r = ns&top;
    rs&u = q;
    
    # the r alone
    if (0) {
        $z = G&Cye,r;
        delete zs&z;
        #$did = G&oleak,zs&u,4,20;
        #debugger;
        $s = G&toLines,z;
        n and -jod $s:s %ws:pre
        #return;

    }
    
    $l = G&Serialise,r;
    n serialout $s:l %ws:pre,hue:50deg,fs:43%,e
    
    if (save) {
        $Q = G&Cye,[t,'',{of:'W',s:l}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    
    n laluce -jod $s:1s&questi,dl:4 %
    n obj -jod $s:1s&obj %
    
    # 
Bystand: |
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    1s&step ||= 1;
    1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    n lat  s:'Severa'
    G&s;
    n More  s:'twoit'
    
t/LetsOsc: |
    G&heading;
    G&n,["figuar",2,{s:"R930000"}];
    $val = G&way,'t/LetsOsc/Waytiu',{fi:234};
    G&n,["figuar",3,{s:"R664000"}];
    
    G&n,["pishrine",31,{s:"--"+val+"--"}];
    
    G&n,["figuar",4,{s:"R368738"}];
t/LetsOsc/Waytiu: |
    return ar.fi * 2
t/Serialise: |
    $Tri = A.4.sc.Jtv.Tri[0.1];
    
    
    $x = Tri.sc.s.sc.top;
    
    $toL = G&Serialise,x;
    
    n toL 15 s:toL hue:'139deg',ws:'pre'
    
    $toN = G&readLines,toL;
    n LtoN -jod_16 $s:toN %hue:169deg,ws:pre,dis:block
    
    $Lto = G&Serialise,toN[0];
    n Lto 17 s:Lto hue:'199deg',ws:'pre'
    
    
    $mes = Lto == toL ? "Same" : "Different";
    n LNLsame 18 s:mes hue:'139deg',ws:'pre',dis:'block'
    
    
    $d = {Blang:3,dop:1,LAttire:"Balgiei"};
    n LNLsame 181 pi:'jod',s:d,dl:4 hue:'139deg',ws:'pre',dis:'block'
    $de = G&depeel,d;
    n LNLsame 1811 s:de hue:'139deg',ws:'pre',dis:'block'
    
    
    $h = G&peel,'dos:SwitchupEl:4msgs:css:overflow:hidden/scroll,jela:15';
    n Thingsi 1814 s:ki(h) hue:'39deg',ws:'pre',dis:'block'
    
    $spacey = " 2  2 88  333333338 76   5 5  7 6";
    n Instead 2 s:$spacey %hue:49deg,ws:pre
    

