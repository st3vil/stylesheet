
Doming: | # in the place in the place
    # future, uses G&S to do everything,
    # and pass clues to what is on the w,
    # so we have more options...
    
    # doming as sections of the pin
    #  - being steps of activity, isolating repeatables
    #  - being acts coded for s to invoke
    #   to be steps in the activity, or too-much-something, changed-something, etc
    # all feeding through to each other.
    #   Cs&in explains where things came from in a dome-dome way
    # < finished domes can do their G&s o while in J6,
    #   to wake/sleep later domes if reaction
    # an effect processing. your
    
    # J has step state
    #   thus your A joins onto doming progress, see A&doming
    #   and the history not redone but outdone, at the J level
    1s&step ||= 1;
    # A&til stops retrying
    1s&step_tries ||= 1;
    1s&osc_each_step = 1;
    
    $total = 1s&steps || '?';
    $tr =
    n testrun 1  %dis:block
    $title = &{
        $step = 1s&step > total ? total : 1s&step;
        trc&s = "("+step+"/"+total+")"
    };
    title();
    
    # < a way to set neediness of a J
    # known Jc? 
    $loop = 1s&loop = Math.random();
    G&yl:1400,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[A.1.t] };
    
    A&S = &s,d{
        if (typeof s != 'number') {
            # any? named? data joint roller? for/if something?
            throw "NaN",s;
        }
        else { # implies sequence/steps
            if (s == 0) {
                # end/non-step, done each time unless throw/return
                # de-dome, only thing resurrecting domes once steps complete
                A&doming();
                title();
                1s&step > total and delete 1s&loop;
                return 1
            }
        }
        s < 1s&step and return 0; # dont redo
        s > 1s&step and return 0; # dont get ahead
        if (A&current_step == s) {
            # second loop of the same while, allow next step
            1s&step_tries = 1;
            1s&step++;
            return 0
        }
        # bail the first time if osc between
        if (1s&osc_each_step) {
            A&bailstep == s and return 0;
            A&bailstep = s+1;
        }
        # totals should be accurate when not coded
        1s&step > total and ~Sextra steps: 1s&step+'/'+total
        # A has attempts to do a step
        A&current_step = s;
        $t = s;
        d and t += ": "+d;
        #~>59 Expecting: t
        A&doming(t);
        return 1;
    };
    
    #c subgrounds
    # osc flattens them out
    A&doming = &t{
        # < take over grounds&z so A.ground can A out?
        #   or so A always finish what they started with?
        # resets
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A&groundling ||= g;
        A&groundling != g and ~>grounddiff: ki(g), ki(A&groundling)
        A.ground = g;
        if (1s&domes && !gc&domed) {
            # add all the domes to the ground in this order
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        h and hs&z = [];
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        A.ground = h;
        G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
    };
    
    # explain the jam,
    # when doming right, bails: return T.il = waiting condition
    #   and the T rests on the crest of a wave,
    #   catching anything anomalous
    A&til = &s{
        $n = 
        G&n:['waits','',{s:"Waiting: "+s},{hue:'150deg'}];
        G&m,M,['waits','',{s:s},{hue:'150deg'}];
        1s&step_tries++ > 3 and nc&s = "Gave up: "+s; delete 1s&loop;
        ~>54 Til: s
    };
    
    
    
Expect: | # pull results along
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    1s&steps = 3;
    G&way,'Doming',ar;
    
    # to be intent on:
    #   domes in order, until done
    #   not redoing earlier work, per dome
    #   computing dependencies emanating from other domes,
    #   they leave a sub that produces ground
    
    #$('<script type="text/javascript">function ZEAL (s) {'+temp1+'}</script>').appendTo('body')
    G&m,M,['FUN','',{s:'FUN'},{hue:'150deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'120deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'100deg'}];
    
    # steps
    # < async n can catch up
     #     as extra dp to the step, which should line up with test data
    
    # < thing that waits at each place, gives you assertion factories

    # o Shovel prep mind
    #    to minimise async-ness...
    #    test varied for interesting results
    #    re insulating consciousness from losing trains of thought
    
    # o take steps
    #    works throat-like, M feedback becoming assertions
    #    lots of waiting just a while for some art to appear
    
    # o Shovel sums mind
    #   makes a big 5, in the 1-5 filesystem
    #   or a s&mind packed string...
    
    
    while (A&S(1,"Launch")) {
        
        $j = G&n,['Launch','V'];
        $L = j && js&J;
        !L and return A&til('Jup');
        Jc&L = L;

        $F = Ls&child;
        !F and return A&til('4s\&child: '+ki(L,2));
        Jc&F = F;
        
        n haveLaunch 1 $s:ki(L,3) %
        n haveFour 1 $s:ki(F,3) %dis:block
    }
    $L = Jc&L;
    $F = Jc&F;
    $Y = F.up;
    $a = &C{
        $y = A;
        A = Y;
        $r = typeof C == 'function' ? C(A,C,G,T) : G&e,C;
        A = y;
        return r
    };
    $waits = &n{
        $Y = n.y.A;
        Y.t == 'e' and Y = Y.n; n = Yc&s;
        Y.cv >= 0.8 and return
        # test how long these things take
        Y.4.sc.N.push(Y);
        A&til('Ccom');
        throw "waits: Ccom", n
    };
    while (A&S(2)) {
        $n = a(['t/LetsOsc']);
        
        n immediaW 3 $s:ki(n,3) %dis:block
        G&n:['made W','-jod_3',{s:n}];
        $Y = n.y.A;
        $ok = Y.cv >= 0.8;
        G&n:['A complete','-jod_3',{s:ok?"OK":"Not OK: "+Y.cv}];
        !ok and return til('n completes');
    }
    
    while (A&S(3)) {
        $n = waits(a(['Bystand']));
        n see_here 3 s:gloo %fs:300%
        G&n:['3 (parent) complete','-jod_632',{s:L,dl:2}];
    }
    
    A&S(0);
Wade: | # serve /W/$t to Revisit
    # defines one place get/set name scheme
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        # read t, write if s
        # all there
        $t = "W/$t";
        # safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1
        my $f = "$t/1";
        
        # returns json:
        my $re = {ok=>1};
        # or ?
        #$c->render(text=>decode_utf8("c&s")); # ,format=>"js"
        
        # if setting
        if (defined $s) {
            if (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.ok = 0;
                re.er = 'not found'
            }
        }
        re.s = $s if length $s;
        $c->render(text=>sjson($re));
    };
Revisit: | # pull/push test data around test run
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    # 1s&obj is the last:
    $t = 't/ExpectArt';
    $load = 1;
    $save = 0;
    
    if (load && !1s&obj) {
        $Q = G&Cye,[t,'',{of:'W'}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    if (load && !1s&ustone) {
        # last save of t
        $w = 1s&obj;
        # its mind, encoded, Shovel adjusts
        $u = ws&u;

        $e = 1s&ust = 1s&ust ||
        G&e,['Shovel'],['ready','',{s:u}];
        # waits until Shovel's&question is what we gave it
        # kind of a deal...
        # almost e Shovel [ puts   %$question:u
        e.y.A.cv < 0.8 and G&thro,e
        e.y.A.cv < 0.8 and G&TuneTimeMachine,'ewaits:'+e.t;
        1s&ustone = 1;
    }
    
    # there's a flood of 1s&val usage,
    # Bab &val -> 1s&val ?
    # test Bab changes: compiling Normal the same
    
    # coming around to game playing with properties
    # on robust, networky objects.
    # so lets build some tools for the emerging language...
    
    # get subbing:
    #   the doming
    #   J-fetching/datadumping
    #   J-fetch-waiting, for Shovel to say ready.
    # all of which should interact,
    # 
    # perhaps even have tools 
    # be an elusive terrain for programming,
    # but one that humans spend a lot of time in:
    # inflecting in rhythms what things have or could have
    # it's an interdimensional hole we're building a door over.
    # the Shovel wait is catching up A:e for a command,
    # but the A:n is the goods... it will be Newsd
    
    # then use this history:
    #$l = G&Serialise,1s&obj;
    #n serialinout $s:l %ws:pre,hue:50deg,fs:15%
    # to help:
    #  - with extra assertions, lum tuning looks
    #  - the test way being just the story
    
    # everything happens
    
    # after happening:
    # pack some other stuff into the test W
    # 
    
    # wants to be n waited on,
    #  to make sure this is fresh Shovel
    $n =
    n Shovel V
    n = ns&J;
    !n and return
    # take this encoded representation of our mind state
    $q = ns&quested;
    
    #n mindstat -jod $s:q,dl:55 %ws:pre,hue:150deg,fs:30%
    
    #n = ns&s;
    #!n and return
    #$u = G&Serialise,ns&top;
    #n mindstat $s:u %ws:pre,hue:150deg,fs:30%
    
    
    
    $n =
    n Expect V
    n = ns&J;
    !n and return
    n = ns&s;
    !n and return
    
    # ns&top... may be given s&dige by anyone encoding it,
    #   supposedly dige implies toLines
    # assumed to encode as 
    $r = ns&top;
    rs&u = q;
    
    # the r alone
    if (0) {
        $z = G&Cye,r;
        delete zs&z;
        #$did = G&oleak,zs&u,4,20;
        #debugger;
        $s = G&toLines,z;
        n and -jod $s:s %ws:pre
        #return;

    }
    
    $l = G&Serialise,r;
    n serialout $s:l %ws:pre,hue:50deg,fs:15%
    
    if (save) {
        $Q = G&Cye,[t,'',{of:'W',s:l}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    
    n laluce -jod $s:1s&questi,dl:4 %
    n obj -jod $s:1s&obj %
    
    # 
Bystand: |
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    1s&step ||= 1;
    1s&step++ < 2 and throw "tant";
    
    while (M.length < 22) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg,blr:3px
    }
    n lat  s:'Severa'
    G&s;
    n More  s:'twoit'
    
t/LetsOsc: |
    G&heading;
    G&n,["figuar",2,{s:"R930000"}];
    $val = G&way,'t/LetsOsc/Waytiu',{fi:234};
    G&n,["figuar",3,{s:"R664000"}];
    
    G&n,["pishrine",31,{s:"--"+val+"--"}];
    
    G&n,["figuar",4,{s:"R368738"}];
t/LetsOsc/Waytiu: |
    return ar.fi * 2
t/Serialise: |
    $Tri = A.4.sc.Jtv.Tri[0.1];
    
    
    $x = Tri.sc.s.sc.top;
    
    $toL = G&Serialise,x;
    
    n toL 15 s:toL hue:'139deg',ws:'pre'
    
    $toN = G&readLines,toL;
    n LtoN -jod_16 $s:toN %hue:169deg,ws:pre,dis:block
    
    $Lto = G&Serialise,toN[0];
    n Lto 17 s:Lto hue:'199deg',ws:'pre'
    
    
    $mes = Lto == toL ? "Same" : "Different";
    n LNLsame 18 s:mes hue:'139deg',ws:'pre',dis:'block'
    
    
    $d = {Blang:3,dop:1,LAttire:"Balgiei"};
    n LNLsame 181 pi:'jod',s:d,dl:4 hue:'139deg',ws:'pre',dis:'block'
    $de = G&depeel,d;
    n LNLsame 1811 s:de hue:'139deg',ws:'pre',dis:'block'
    
    
    $h = G&peel,'dos:SwitchupEl:4msgs:css:overflow:hidden/scroll,jela:15';
    n Thingsi 1814 s:ki(h) hue:'39deg',ws:'pre',dis:'block'
    
    $spacey = " 2  2 88  333333338 76   5 5  7 6";
    n Instead 2 s:$spacey %hue:49deg,ws:pre
    

