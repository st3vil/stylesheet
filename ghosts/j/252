
Expect: | # pull results along
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    # to be intent on:
    #   domes in order, until done
    #   not redoing earlier work, per dome
    #   computing dependencies emanating from other domes,
    #   they leave a sub that produces ground
    
    G&m,M,['FUN','',{s:'FUN'},{hue:'150deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'120deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'100deg'}];
    # subgroups for the ground
    # < osc flattens them out
    $doming = &t{
        # < take over grounds&z so A.ground can A out?
        #   or so A always finish what they started with?
        # resets
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A&groundling ||= g;
        A&groundling != g and ~>grounddiff: ki(g), ki(A&groundling)
        A.ground = g;
        if (1s&domes && !gc&domed) {
            # add all the domes to the ground in this order
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        h and hs&z = [];
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        A.ground = h;
        G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
    };
    # lo.indexOf(4); lo.splice(3)

    # when doming right, bails: return T.il = waiting condition
    #   and the T rests on the crest of a wave
    $til = &s{
        $n = 
        G&n:['waits','',{s:"Waiting: "+s},{hue:'150deg'}];
        G&m,M,['waits','',{s:s},{hue:'150deg'}];
        1s&step_tries++ > 3 and nc&s = "Gave up: "+s; delete 1s&loop;
        ~>54 Til: s
    };
    
    # pin sections/doming idea
    1s&step ||= 1;
    1s&step_tries ||= 1;
    $osc_each_step = 1;
    $S = &s,d{
        typeof s != 'number' and throw "NaN",s;
        s < 1s&step and return 0; # dont redo
        s > 1s&step and return 0; # dont get ahead
        if (A&didstep == s) {
            # second loop of while, allow next step
            1s&step_tries = 1;
            1s&step++;
            return 0
        }
        # draw each step for stuff flying by on the screen
        # or to commit changes to test data (...)
        A&bailstep == s and return 0;
        osc_each_step and A&bailstep = s+1;
        A&didstep = s;
        $t = s;
        d and t += ": "+d;
        #~>59 Expecting: t
        doming(t);
        return 1;
    };
    
    #c steps
    # < async n can catch up
     #     as extra dp to the step, which should line up with test data
    
    # < thing that waits at each place, gives you assertion factories

    $tr =
    G&n:['testrun',1,{s:"J, with lv ("+1s&step+"/?)"},{dis:'block'}];
    $loop = 1s&loop = Math.random();
    G&yl:1430,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[J.t] };
    
    # o Shovel prep mind
    #    to minimise async-ness...
    #    test varied for interesting results
    #    re insulating consciousness from losing trains of thought
    
    # o take steps
    #    works throat-like, M feedback becoming assertions
    #    lots of waiting just a while for some art to appear
    
    # o Shovel sums mind
    #   makes a big 5, in the 1-5 filesystem
    #   or a s&mind packed string...
    
    
    while (S(1,"Launch")) {
        $j = G&n,['Launch','V'];
        $L = j && js&J;
        !L and return til('Jup');
        Jc&L = L;

        $F = Ls&child;
        !F and return til('4s\&child: '+ki(L,2));
        Jc&F = F;
        
        n haveLaunch 1 $s:ki(L,3) %
        n haveFour 1 $s:ki(F,3) %dis:block
    }
    $L = Jc&L;
    $F = Jc&F;
    $don = &n{
        $s = Ls&subphone;
        !s and throw "Nosubphone", L
        return s(&acgt{ return G&e,n }); #)
    };
    while (S(2)) {
        $n = don(['t/LetsOsc']);
        
        n immediaW 3 $s:ki(n,3) %dis:block
        G&n:['made W','-jod_3',{s:n}];
        $Y = n.y.A;
        $ok = Y.cv >= 0.8;
        G&n:['A complete','-jod_3',{s:ok?"OK":"Not OK: "+Y.cv}];
        !ok and return til('n completes');
    }
    
    while (S(3)) {
        G&n:['3 (parent) complete','-jod_632',{s:L,dl:2}];
    }
    
    doming();
    
    trc&s = "J, with lv ("+A&didstep+"/?)";
    1s&step > 3 and delete 1s&loop;
Wade: | # serve /W/$t to Revisit
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        # read t, write if s
        
        $c->render(text=>"hmm '$t'\n");
    };
Revisit: | # pull/push test data
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    
    if (1 || !1s&questi) {
        #1s&questi = 1;
        $Q = G&Cye,['t/LetsOsc','',{of:'W'}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    
    n laluce -jod $s:1s&questi %
    n obj -jod $s:1s&obj %
    # 
t/LetsOsc: |
    G&heading;
    G&n,["figuar",2,{s:"R930000"}];
    $val = G&way,'t/LetsOsc/Waytiu',{fi:234};
    G&n,["figuar",3,{s:"R664000"}];
    
    G&n,["pishrine",31,{s:"--"+val+"--"}];
    
    G&n,["figuar",4,{s:"R368738"}];
t/LetsOsc/Waytiu: |
    return ar.fi * 2
t/Serialise: |
    $Tri = A.4.sc.Jtv.Tri[0.1];
    
    
    $x = Tri.sc.s.sc.top;
    
    $toL = G&Serialise,x;
    
    n toL 15 s:toL hue:'139deg',ws:'pre'
    
    $toN = G&readLines,toL;
    n LtoN -jod_16 $s:toN %hue:169deg,ws:pre,dis:block
    
    $Lto = G&Serialise,toN[0];
    n Lto 17 s:Lto hue:'199deg',ws:'pre'
    
    
    $mes = Lto == toL ? "Same" : "Different";
    n LNLsame 18 s:mes hue:'139deg',ws:'pre',dis:'block'
    
    
    $d = {Blang:3,dop:1,LAttire:"Balgiei"};
    n LNLsame 181 pi:'jod',s:d,dl:4 hue:'139deg',ws:'pre',dis:'block'
    $de = G&depeel,d;
    n LNLsame 1811 s:de hue:'139deg',ws:'pre',dis:'block'
    
    
    $h = G&peel,'dos:SwitchupEl:4msgs:css:overflow:hidden/scroll,jela:15';
    n Thingsi 1814 s:ki(h) hue:'39deg',ws:'pre',dis:'block'
    
    $spacey = " 2  2 88  333333338 76   5 5  7 6";
    n Instead 2 s:$spacey %hue:49deg,ws:pre
    

