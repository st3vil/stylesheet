
Expect: | # pull results along
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    # to be intent on:
    #   domes in order, until done
    #   not redoing earlier work, per dome
    #   computing dependencies emanating from other domes,
    #   they leave a sub that produces ground
    
    G&m,M,['FUN','',{s:'FUN'},{hue:'150deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'120deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'100deg'}];
    # subgroups for the ground
    # < osc flattens them out
    $doming = &t{
        # < take over grounds&z so A.ground can A out?
        #   or so A always finish what they started with?
        # resets
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A&groundling ||= g;
        A&groundling != g and ~>grounddiff: ki(g), ki(A&groundling)
        A.ground = g;
        if (1s&domes && !gc&domed) {
            # add all the domes to the ground in this order
            each id 1s&domeseq {
                gs&z.push(d);
            }
            gc&domed = 1;
        }
        # coda, after domes
        !t and return;
        
        # g ground, h hovering carpets
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        # repeat or reveal
        h and hs&z = [];
        else {
            h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            gs&z.push(h);
        }
        # under the ground
        h.y.up = g;
        
        A.ground = h;
        G&n:["dome "+t,'',{s:'- '+t},{fs:'120%',hue:'200deg',dis:'block'}];
    };
    # lo.indexOf(4); lo.splice(3)

    # when doming right, bails: return T.il = waiting condition
    #   and the T rests on the crest of a wave
    $til = &s{
        $n = 
        G&n:['waits','',{s:"Waiting: "+s},{hue:'150deg'}];
        G&m,M,['waits','',{s:s},{hue:'150deg'}];
        1s&step_tries++ > 3 and nc&s = "Gave up: "+s; delete 1s&loop;
        ~>54 Til: s
    };
    
    # pin sections/doming idea
    1s&step ||= 1;
    1s&step_tries ||= 1;
    $osc_each_step = 1;
    $S = &s,d{
        typeof s != 'number' and throw "NaN",s;
        s < 1s&step and return 0; # dont redo
        s > 1s&step and return 0; # dont get ahead
        if (A&didstep == s) {
            # second loop of while, allow next step
            1s&step_tries = 1;
            1s&step++;
            return 0
        }
        # draw each step for stuff flying by on the screen
        # or to commit changes to test data (...)
        A&bailstep == s and return 0;
        osc_each_step and A&bailstep = s+1;
        A&didstep = s;
        $t = s;
        d and t += ": "+d;
        #~>59 Expecting: t
        doming(t);
        return 1;
    };
    
    #c steps
    # < async n can catch up
     #     as extra dp to the step, which should line up with test data
    
    # < thing that waits at each place, gives you assertion factories

    $tr =
    G&n:['testrun',1,{s:"J, with lv ("+1s&step+"/?)"},{dis:'block'}];
    $loop = 1s&loop = Math.random();
    G&yl:1430,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[J.t] };
    
    # o Shovel prep mind
    #    to minimise async-ness...
    #    test varied for interesting results
    #    re insulating consciousness from losing trains of thought
    
    # o take steps
    #    works throat-like, M feedback becoming assertions
    #    lots of waiting just a while for some art to appear
    
    # o Shovel sums mind
    #   makes a big 5, in the 1-5 filesystem
    #   or a s&mind packed string...
    
    
    while (S(1,"Launch")) {
        $j = G&n,['Launch','V'];
        $L = j && js&J;
        !L and return til('Jup');
        Jc&L = L;

        $F = Ls&child;
        !F and return til('4s\&child: '+ki(L,2));
        Jc&F = F;
        
        n haveLaunch 1 $s:ki(L,3) %
        n haveFour 1 $s:ki(F,3) %dis:block
    }
    $L = Jc&L;
    $F = Jc&F;
    $don = &n{
        $s = Ls&subphone;
        !s and throw "Nosubphone", L
        return s(&acgt{ return G&e,n }); #)
    };
    while (S(2)) {
        $n = don(['t/LetsOsc']);
        
        n immediaW 3 $s:ki(n,3) %dis:block
        G&n:['made W','-jod_3',{s:n}];
        $Y = n.y.A;
        $ok = Y.cv >= 0.8;
        G&n:['A complete','-jod_3',{s:ok?"OK":"Not OK: "+Y.cv}];
        !ok and return til('n completes');
    }
    
    while (S(3)) {
        G&n:['3 (parent) complete','-jod_632',{s:L,dl:2}];
    }
    
    doming();
    
    trc&s = "J, with lv ("+A&didstep+"/?)";
    1s&step > 3 and delete 1s&loop;
Wade: | # serve /W/$t to Revisit
    # defines one place get/set name scheme
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        # read t, write if s
        # all there
        $t = "W/$t";
        # safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1
        my $f = "$t/1";
        
        # returns json:
        my $re = {ok=>1};
        # or ?
        #$c->render(text=>decode_utf8("c&s")); # ,format=>"js"
        
        # if setting
        if (defined $s) {
            if (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.ok = 0;
                re.er = 'not found'
            }
        }
        re.s = $s if length $s;
        $c->render(text=>sjson($re));
    };
Revisit: | # pull/push test data around test run
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    
    $t = 't/ExpectArt';
    if (0) {
        #1s&questi = 1;
        $Q = G&Cye,[t,'',{of:'W'}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    # everything happens
    
    # after happening:
    # pack some other stuff into the test W
    # 
    
    # wants to be n waited on,
    #  to make sure this is fresh Shovel
    $n =
    n Shovel V
    n = ns&J;
    !n and return
    #n = ns&s;
    #!n and return
    # take this encoded representation of our mind state
    $q = ns&quested;
    n mindstat -jod $s:q,dl:55 %ws:pre,hue:150deg,fs:30%
    
    
    
    $n =
    n Expect V
    n = ns&J;
    !n and return
    n = ns&s;
    !n and return
    
    n serialin -jod $s:ns&top,dl:5 %
    
    # ns&top... may be given s&dige by anyone encoding it
    # assumed to encode as 
    $r = ns&top;
    rs&u = q;
    
    $z = G&Cye,r;
    delete zs&z;
    $did = G&oleak,zs&u,4,20;
    debugger;
    $s = G&toLines,z;
    n and -jod $s:s %
    return;
    
    $l = G&Serialise,r;
    n serialout $s:l %ws:pre,hue:50deg,fs:15%
    
    #$u = G&Serialise,ns&top
    #n mindstat $s:u %ws:pre,hue:150deg,fs:30%
    
    if (1) {
        $Q = G&Cye,[t,'',{of:'W',s:l}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    
    n laluce -jod $s:1s&questi,dl:2 %
    n obj -jod $s:1s&obj %
    
    # 
Bystand: |
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&clusp;
    ys&maw = '50%';
    
    while (M.length < 8) {
        $fs = M.length * 5;
        $hue = fs * 20;
        $s = 'isle of joy';
        m guil  $s:s %fs:$fs+%,hue:$hue+deg
    }
    
t/LetsOsc: |
    G&heading;
    G&n,["figuar",2,{s:"R930000"}];
    $val = G&way,'t/LetsOsc/Waytiu',{fi:234};
    G&n,["figuar",3,{s:"R664000"}];
    
    G&n,["pishrine",31,{s:"--"+val+"--"}];
    
    G&n,["figuar",4,{s:"R368738"}];
t/LetsOsc/Waytiu: |
    return ar.fi * 2
t/Serialise: |
    $Tri = A.4.sc.Jtv.Tri[0.1];
    
    
    $x = Tri.sc.s.sc.top;
    
    $toL = G&Serialise,x;
    
    n toL 15 s:toL hue:'139deg',ws:'pre'
    
    $toN = G&readLines,toL;
    n LtoN -jod_16 $s:toN %hue:169deg,ws:pre,dis:block
    
    $Lto = G&Serialise,toN[0];
    n Lto 17 s:Lto hue:'199deg',ws:'pre'
    
    
    $mes = Lto == toL ? "Same" : "Different";
    n LNLsame 18 s:mes hue:'139deg',ws:'pre',dis:'block'
    
    
    $d = {Blang:3,dop:1,LAttire:"Balgiei"};
    n LNLsame 181 pi:'jod',s:d,dl:4 hue:'139deg',ws:'pre',dis:'block'
    $de = G&depeel,d;
    n LNLsame 1811 s:de hue:'139deg',ws:'pre',dis:'block'
    
    
    $h = G&peel,'dos:SwitchupEl:4msgs:css:overflow:hidden/scroll,jela:15';
    n Thingsi 1814 s:ki(h) hue:'39deg',ws:'pre',dis:'block'
    
    $spacey = " 2  2 88  333333338 76   5 5  7 6";
    n Instead 2 s:$spacey %hue:49deg,ws:pre
    

