Expect: | # pull results along
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    
    G&m,M,['FUN','',{s:'FUN'},{hue:'150deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'120deg'}];
    G&m,M,['FUN','',{s:'FUN'},{hue:'100deg'}];
    # subgroups for the ground
    # < osc flattens them out
    $doming = &t{
        # < take over grounds&z so A.ground can A out?
        #   or so A always finish what they started with?
        # resets
        $g = A.ground;
        gc&dome and g = g.y.up;
        gc&dome and throw "many domes deep", A.ground
        A.ground = g;
        !t and return;
        
        1s&domeseq ||= [];
        1s&domes ||= {};
        $h = 1s&domes[t];
        if (h) {
            # redoing
            hs&z = [];
        }
        else {
            $h = 1s&domes[t] = G&Cye,[t,'',{dome:1},{z:[]}];
            1s&domeseq.push(h);
            h.y.up = g;
        }
        if (!gc&domedup) {
            gc&domedup = 1;
            # add all the domes to the ground in this order
            each id 1s&domeseq {
                gs&z.push(d);
            }
            ~>65 Redomed: 1s&domeseq.length
        }
        else {
            ~>65 Addome: t
            gs&z.indexOf(h) < 0 and gs&z.push(h);
        }
        A.ground = h;
        G&n,["dome:"+t,'',{s:t},{fs:'120%',hue:'200deg',dis:'block'}];
    };
    # lo.indexOf(4); lo.splice(3)

    # when doming right, bails: return T.il = waiting condition
    #   and the T rests on the crest of a wave
    $til = &s{
        $n = 
        G&n:['waits','',{s:"Waiting: "+s},{hue:'150deg'}];
        G&m,M,['waits','',{s:s},{hue:'150deg'}];
        1s&step_tries++ > 3 and nc&s = "Gave up: "+s; delete 1s&loop;
        ~>54 Til: s
    };
    
    # pin sections/doming idea
    1s&step ||= 1;
    1s&step_tries ||= 1;
    $osc_each_step = 1;
    $S = &s,d{
        typeof s != 'number' and throw "NaN",s;
        s < 1s&step and return 0; # dont redo
        s > 1s&step and return 0; # dont get ahead
        if (A&didstep == s) {
            # second loop of while, allow next step
            1s&step_tries = 1;
            1s&step++;
            return 0
        }
        # draw each step for stuff flying by on the screen
        # or to commit changes to test data (...)
        A&bailstep == s and return 0;
        osc_each_step and A&bailstep = s+1;
        A&didstep = s;
        $t = "Step "+s;
        d and t += ": "+d;
        ~>54 Expecting: t
        doming(t);
        return 1;
    };
    
    #c steps
    # < async n can catch up
     #     as extra dp to the step, which should line up with test data
    
    # < thing that waits at each place, gives you assertion factories

    $tr =
    G&n:['testrun',1,{s:"J, with lv ("+1s&step+"/?)"},{dis:'block'}];
    $loop = 1s&loop = Math.random();
    G&yl:1430,&{ A.4 == G.DNS[A.4.t] && loop == 1s&loop && G&e,[J.t] };
    
    while (S(1,"Launch")) {
        $j = G&n,['Launch','V'];
        $L = j && js&J;
        !L and return til('Jup');
        Jc&L = L;

        $F = Ls&child;
        !F and return til('4s\&child: '+ki(L,2));
        Jc&F = F;
    }
    $L = Jc&L;
    $F = Jc&F;
    $don = &n{
        $s = Ls&subphone;
        !s and throw "Nosubphone", L
        return s(&acgt{ return G&n,n }); #)
    };
    while (S(2)) {
        $n = don(['t/LetsOsc']);
        
        G&n:['made W','-jod_3',{s:n}];
        $Y = n.y.A;
        $ok = Y.cv >= 0.8;
        G&n:['A complete','-jod_3',{is:ok?"OK":"Not OK: "+Y.cv}];
        !ok and return til('n completes');
    }
    
    while (S(3)) {
        G&n:['3 (parent) complete','-jod_632',{s:L,dl:2}];
    }
    
    doming();
    
    trc&s = "J, with lv ("+A&didstep+"/?)";
    1s&step > 3 and delete 1s&loop;
t/LetsOsc: |
    G&heading;
    G&n,["figuar",2,{s:"R930000"}];
    $val = G&way,'t/LetsOsc/Waytiu',{fi:234};
    G&n,["figuar",3,{s:"R664000"}];
    
    G&n,["pishrine",31,{s:"--"+val+"--"}];
    
    G&n,["figuar",4,{s:"R368738"}];
t/LetsOsc/Waytiu: |
    return ar.fi * 2

