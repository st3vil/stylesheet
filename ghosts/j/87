Scripts: | # to
    q{
    we should be writing more code that doesn't compile
    then we will be pushing the boundary and siding with expression
    since the computer is the center of empiricle gravity
    
    max doing with minimal it understanding itself
    
    where we're going, salad is why
    
    the wayhow brings the knowhow
Todol: |
    q{
    collect pi to some place, which keeps building itself in new bays
    colonies pumped through Telon, which watches jobs
    jewelis == each
    # $s =~ s/\n/â†¯/g;
Impsev: | # restart lv when wil > 7
    if (ar.and eq 'init') {
        # normal-ish web state starting new log, eg Telon
        # knows its last 1, restarts 7ing
        unless (1s&lastmo) {
            sayre "A.1.t's init imping";
            1c&imping = 1 
        }
    }
    if (my $s = 1s&s) {
        if (ss&wil > 7) {
            sayre "A.1.t's wil=ss&wil imping";
            1c&imping = 1
        }
    }
    A.mo.sc.lastmo = 1s&lastmo;
    1s&lastmo = A.mo;
EatsPi: | # add things you like to eat
    for my $pi (@{ar.m}) {
        Js&ein.pi.>$pi ->{sMJ} = &sMJje{
            1 && saybl "Havi J.t: ".G&aC,$e;
            Rw PutThingAfterSource $e $M;
        };
    }
PutThingAfterSource: | # stitch into M for EatsPi
    # $e is a $c, clicked on pi
    my $c =
    m e.t, {C=>$e,cv=>e.y.cv}, e.c, e.sc
    c.y.up && warn "M doesnt deyer";
    
    my $s = e.y.up || die "no eyup";
    $s = ss&J || die "no J";
    my $i = 1;
    my @S = $s;
    push @S, $s = s.2 until $i++ > 20 || s.2 eq s.3 || $s eq s.3;
    $i > 20 && die "2 follow Swierdness: ".ki \@S;
    
    my @is = grep { _.t eq s.1.t } @$M;
    if (@is == 1) {
        @$M = grep { $_ ne $c } @$M;
        @$M = map { $_ eq $is[0] ? ($_,$c) : $_ } @$M;
    }
EatPi: | # hope throwing this pi ($c) into somewhere (e J.t) will do something
    sayre "Hoping J.t will like ".G&aC,$c;
    G&elph,J.t=>$c;
    T.pos = '';
Telon: | # comp sci helpyou
    Gc&Glan = 'Elan' if G.d;
    y.at.miw = '60%';
    # Lst Ts and their 5ings
    Rw Tiot;
    Rw UpSetulism;
    Rw GiveTime;
    #1s&FishBrainDump = 1;
    Rw Impsev $and=init;
    Jc&save = 1;
    y.res = 100;
    
    # c&pi generates s&pi which become c&pi when fed to A.3
    Rw EatsPi chunks way ghost;
    
    S
    Jc&bay ||= 'spot';
    Jc&G ||= 'Ge';
    my $ts = Rw fi/sembla bay G add;
    
    
    Js&boWls ||= do {
        my $o = Js&top.y.tw.boWls;
        #n fyi_ope=>-od_o83=>{s=>$o}
        oc&s =~ /Bo:(\d+)/;
        $1;
    };
    n bowls=>o81=>"Bo:".Js&bowls++ 
    n boWls=>o82=>"Bo:".Js&boWls++ 
    
    Js&M ||
    n nom=>o2=>"NO M"
    
    my $d = "Jc&bay/G/Jc&G";
    # edits the G init code into ^
    # amongst other way drawn from:
    
    Rw piFeedTape + $default=j:-clonge;
    
    my $w = G&t,w=>"Todol";
    Js&sayin = wc&s;
    #m sayin=>-Tin
    
    #n lies=>-lise_1=>"$d/ip",'%qz,fs'
    #n lizm=>-filsipdrs_2=>{s=>T.op}
    
    n M=>-od_92=>{s=>$M}
    #@$M = ();
    n GoWalking=>-Gug
    
    # stack certain shapes next to each other
    #1s&Osulation = 'FormShapes';
    for my $C (@$M) {
        s&float = 'left' if c&pi eq 'ghost' || c&pi eq 'way';
    }
    
    $ts->();
    
FormShapes: | # stack certain shapes next to each other
    # 
    my @s;
    my @M = @$M;
    my $l;
    while (@M) {
        my $r = shift @M;
        if (ls&shape && ls&shape eq rs&shape) {
            push @s, [$l] unless @s && $s[-1]->[-1] eq $l;
            push @{$s[-1]}, $r;
        }
        $l = $r;
    }
    for my $s (@s) {
        my $i = 0;
        for my $C (@$s) {
            next unless $i++; # first one takes up space
            s&ab = 1;
            s&left = 3 * $i;
        }
    }
    G&give,Budge=>[formshapes=>''=>{s=>\@s}];
    
piFeedTape: | # your J state recovery
    # Tiot shiftclick empties Js&M
    Js&Simp = 'Sweeptapes';
    Js&Cimp = 'Detapes';
    # writes s&mix=1 on everything to feedback
    if (!Js&M) {
        # init saved/feedback
        my $t = Js&top;
        my $M = Js&M = [];
        m $_ for grep{_s&mix} @{ts&z||[]};
    }
    if (!@{Js&M||[]}) {
        my $M = Js&M;
        if (my $d = ar.default) {
            m ref $d ? $d : split(":", $d)
        }
    }
    m $_ for @{Js&M||[]};
    
    delete _.y.cv for @$M;
    _c&pi = delete _s&pi for grep{_s&pi} @$M;
    # pi sc become c ^
    # unless waiting for waves of things to come up...
    my $i = 1s&Feedbowlings++;
    for (grep{!$i && _s&pi eq 'way'} @$M) {
        _s&pi = delete _c&pi ;
        delete Jc&save;
    }
    Jc&save || G&timer:0.1,&{ 4s&toy->({to=>[J.t]}) };
    
    _s&mix = 1 for @$M;
    my $tw;
    @$M = grep { !$tw.>_.t ++ } @$M;
    
    Rw DeStyleM;
    
pi/clonge: | # ambiento numbery ghostlisting
    #
    s&dis = 1;
    $s ||= C.t;
    # turns j into g/j
    # or 81 into g/j/81, etc.
    my $f = Rw Glongate $s;
    
    Rw Tiot + $t:f $nodis=1;
    1c&imping &&
        n imping=>91=>"IMPING"
    
    n lies=>-lise_1=>$f,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    # each t shows its uniqueness beyond its parent
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            my $m = Rw Min/bits + $dos=EatPi;
            ms&pi = 'ghost';
            ms&ma = 0.2;
            if ($C eq $l[0]) {
                mc&s = $1 if C.t =~ /\/([^\/]+)$/;
                ms&fs = 14;
                ms&ml = 0.4;
            }
            delete ms&ml;
            delete ms&dis;
        }
    }
pi/ghost: | # opens ghost file via -codof, has a -ways of them
    # was being a C produced in some list
    s&dis = 1;
    s&file = C.t if -e C.t;
    Rw Tiot;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    
    
    # can locate 
    n chunks=>-codolf=>{f=>C.t},qz
    my @codes = G&op,'pi:code';
    my ($c) = grep {_.t eq 'data'} @codes;
    $c = \@codes;
    #n C.t=>-lise=>{largemult=>18},'qz'
    # < hook some reverse function here, for f <- ways
    
    # < sleep these on o of the y.C we are
    
    n ways=>-ways_2=>{s=>T.op}
    
    #n ways=>-od_3=>{s=>$c}
    # shape us
    s&shape = 'tot';
pi/codolf: | # the file of code, yaml about pin=>way
    # TODO Glocation
    y.n = 3;
    y.u = 4;
    y.res = 100;
    
    my $f = c&f || 'g/'.c&s;
    n $f=>-ftimedig
    S
    my $code = read_file($f);
    my $hashc = '#'.'c';
    my $mashc = ''; #qr/|[^\n]+$hashc/;
    my @chunks = split /\n(?=\S$mashc)/sm, $code;
    
    my $i = 0;
    for my $s (@chunks) {
        $s =~ /\S/ || next;
        my ($tip) = my @l = split "\n",$s;
        my $t = $1 || $2 if $tip =~ /^([\/\w]+):|$hashc.*?(\w\w+)/;
        my ($pren,$note) = split /\b\Q$t\E\b/, $tip, 2 if $t;
        s/^: \|//, s/^\s*//, s/^\s*$hashc\s*//, s/# // for $note;
        
        $t ||= $tip;
        my $sc;
        sc.note = $note if $note;
        sc.pren = $pren if $pren;
        sc.l = \@l;
        sc.i = $i;
        sc.pi = 'code';
        m $t=>''=>{s=>$s},$sc
        $i++;
    }
    
pi/ways: | # beings in lines, gets ghost backing until it settles...
    T.op = $s;
    for my $C (G&op,'pi:code' ) {
        c&ind = 2 if s&pren; # becomes c&depth aft v
        $C = Rw Min/bits + $dos=EatPi;
        s&fs = 9 - c&depth if c&depth;
        s&pi = 'way';
    }
pi/way: |
    # resume itself...
    # way with a -ghost source, which wanders into the bay
    # if -chunks sourced, gather
    Rw Tiot;
    # can be many chunks/divisions,
    # from one origin's chunks+ into code+ bits
    
    # all remotes
    m $_ for @{1s&M||[]};
    if (!@$M) {
        # assume origin is to be figured, dest picked
        # slow push if -ghost, fast if -wayin
        m origin=>-origin
        m dest=>-origin
        m codify=>-codify
    }


    #n This=>-od_4=>{dl=>2,s=>$C}
     

    # pis exist on a C.y.C wavestring beadchaining
    #  the previum of which may have work
    #   to be reinvolved as waves continue their journey
pi/codify: | # spread out here, pack up an push changes when elvised
    # find the origin named origin,
    # get chunks from origin or last codify
    # reversing itself and pushing to origin or so...
    my ($j) = Rw te/Jpin + $p=origin $J:A.2;
    
    my $o = jc&origin || return
        n ohno=>-od=>["No Jc\&origin"=>$j]
    
    n seek=>-od_o3=>{dl=>1,s=>$o}
    
    $s ||= "Something";
    n sdo=>-Tin=>{s=>$s}
pi/origin: | # label relation on upCs&origin (or so) show up/down stream ...
    Rw Tiot;
    c&creative = 1 if C.t eq 'origin';
    
    my $D = 2c&s;
    
    if (c&creative) { # the J that upC came from
        D.sc.>C.t ||= Rw t/CreateOrigin $M $t:C.t $C:D;
    }
    else { # 
        D.sc.>C.t ||= Rw t/Awaits $M $t:C.t $C:D;
    }
    # failure to stops us here
    D.sc.>C.t || delete D.sc.>C.t;
    D.sc.>C.t || return;
    
    # follow progress
    my $o = Jc&origin = Rw t/FindOrigin $M $t:C.t $C:D;
    return if @$M; # ^ will m if problems
    
    Jc&origin_hJ = a&origin_hJ;
    
    my @Js = @{Jc&origin_hJ};
    for (@Js,$o) {
        my $c = _.y eq $_ ? _c&s : $_;
        m on=>''=>"c.t",'ml:0.3,fs:7,hs:897'
        m is=>''=>"-cs&pi",'ml:0.3,fs:7,hs:697'
        #$c eq $o && 
    }
    y.n = 4;
    y.u = 5;
    
    #n as=>7=>"as: ".G&aC,$o ,'ma,fs:7'
    
t/Awaits: | # create the destinationa
    # AwaitDest
    n t=>2=>"Awaits s\&".$t
    return;
t/CreateOrigin: | # mark to where it came from so elvistivity can fade out
    # and find where to awake on push
    my @os = Rw fe/yCtrail $group=Ao+;
    
    @os < 2 && 
        n argh=>3=>"Not enough history to find $t",'fs:7,dis,hs:566';
    @os > 2 && die "Lots of history";
    # first o'ing
    my $os = $os[0];
    # last o
    my $c = $os->[-1];
    my $Y = c.y.A;
    my $J = Y.1;
    J.3 ne A.3 && die "Origin not in J.t  "
        . G&give,Budge=>["gal"=>''=>{s=>$C}];
    
    my @J = Rw fe/upJs $J;
    A.3 eq shift(@J) || die  "Origin not in J.t";
    
    a&origin_hJ = \@J;
    A.sc.>$t = $c;
    
    # goes onto C.sc.>$t
    join";",map{_.t} @J;
    
fe/upJs: | # Js above, not-1, 2+ and 3
    my @J = $J;
    my $i = 0;
    push @J, $J while $J = $i++ < 20 && $J ne J.3 && J.2;
    $i >= 20 && die "Many upJs";
    reverse @J
t/FindOrigin: | # latter moment, look for s&origin, usu in 3
    my $j = A.3;
    js&top || die "3: j.t not ready!";
    
    my $p = [split ';', C.sc.>$t ];
    push @$p, C.t;
    my @J = Rw te/Jpin $M $J:j $p $Clast=1;
    my $c = pop @J;
    
    a&origin_hJ = \@J;
    A.sc.>$t = $c;
    
te/Jpin: | # point through Js beyond $J by t, and maybe the last C
    my @p = ref ar.p ? @{ar.p} : split ';', ar.p;
    my $j = $J;
    my $i = 1;
    my @J; # Js beyond $J
    my $c; # the last C
    my @fi; # debug
    for (@p) {
        js&top || js&Jtv || die "Lost @p    at $_ No top: ".G&aC,$j;
        my $f; # C with s&J
        my $J; # next J
        if (js&top) {
            $f = js&top.y.tw.>$_;
        }
        if ($f && !fs&J && $i < @p) {
            # more to go, look in Jtv, the f was probably thawed?
            undef $f;
        }
        if (!$f && js&Jtv) {
            my $jv = js&Jtv.>$_;
            if (keys %$jv != 1) {
                m "Lost @p at $_, maybe Jv:"=>-od=>{s=>[$j,$jv]}
                return
            }
            ($J) = values %$jv;
        }
        if (!$f && $J) {
            $f = Jc&s; # holds latest mo C
        }
        if ($f && !$J) {
            $J = fs&J;
            if (!$J) {
                if (@p > $i) {
                    m "Lost @p at $_"=>-od=>{s=>[@fi,js&top,$j]}
                    return
                }
                elsif (!ar.Clast) {
                    die "last thing in @p was only C: ".ki $f;
                }
                else {
                    # last hop can be C, no J
                }
            }
        }
        $c = $f;
        if ($J) {
            push @fi, "Found ".G&sn,$J ." on ".G&aC,$f;
            push @J, $J;
        }
        elsif (@p > $i) {
            die "Lost @p at $_ with no J on ".G&aC,$f ."   try Cytw not CsJstopytw?"
        }
        $j = $J;
        $i++;
    }
    ar.Clast ? (@J,$c) : @J;
fe/yCtrail: | # C.y.C trail
    my @l = my $S = $C;
    push @l, $S while $S = @l < 30 && S.y.C;
    @l >= 30 && die "many CyC";
    
    if (ar.group eq 'Ao+') {
        # find consecutive yA=o
        my @os; 
        my $l;
        for (reverse @l) {
            my $Y = _.y.A || next;
            if (Y.t eq 'o') {
                push @os, [] if !@os || $os[-1]->[-1] ne $l;
                push @{$os[-1]}, $_;
            }
            $l = $_;
        }
        return @os
    }
    
    return @l
    
Origist: | # origin infographics, merge with above
    my @l = my $S = $C;
    push @l, $S while $S = @l < 30 && S.y.C;
    #
    @l = map { $_, _.y.A && G&sn,_.y.A || "noyA" } @l;
    n history=>-od_4=>{dl=>1,s=>\@l}
pi/Tin: | # code boxen, re C.t to alter? check js, hold something?
    #s&ab = 1;
    #s&ri = 0;
    #s&zi = -30;
    s&miw = '100%';
        # maybe...
        #s&mh = 7;
        #overflow-y: overlay;
    s&dis = 1;
    n t=>1=>C.t,'%sha:4 9 5 698'
    
    my $h = A.3.sc;
    #$s = $h.>C.t ||= C.t;
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:Tinput';
    #sc.width = 4;
    #sc.height = 3;
    sc.dig = s&dig if s&dig;
    n "z fo" =>1 =>{s=>$s},$sc
    
    y.at.cssdel = 'transform';
Tinput: | # handly talky box
    # should be of autocomplete, lost-focus and escape
    
    my $s = us&code || die "Nocode to tinput";
    my $j = e&_hJ;
    1 && saybl "tinput: ".G&es , " (J.t's j.t) says: $s";
    J.3 eq $J || die "J not J3: ".G&sn,$J;
    
    my $was = J.sc.>j.t;
    J.sc.>j.t = $s;
    T.pos = $was ne j.t;
    #J.vid = us&code;
GoWalking: |
    Rw Tiot;
    # extrane
    my $c = 
    n Train
    my $j = cs&J;
    n od=>-od=>{s=>js&s}
Train: |
    Rw Tiot;
    
    Rw LastFewb;
    
    n boogie=>-sdi=>=>dis
pi/sdi: | # pretty text
    s&hs = Rw Numstring $s 3;
    s&hs =~ s/([1-4])$/$1+4/e;
    #s&sha = '2 2 4 439';
    # s&fs = relativity
    # G&has,word=>$s # to change relativity
    T.nose = 3;
LastFewb: | # see what matters!
    # earn names
    my $c = Gc&B;
    my $l = [$c];
    my $S = $c;
    while ($S = S.y.out) {
        unshift @$l, $S;
        last if @$l > 17;
    }
    m _.t=>-B=>{s=>$_} for @$l;
    undef $l;
    # FactorEase c&s wherebouts chains and Ts
    # and injecting after C in an M
    #   gives somewhere C,
    #   named iterators! starting with M
    for (@$M) {
        my ($s,$c) = ($l && lc&s, _c&s);
        #_s&dis = 1 if ss&A.1 ne cs&A.1;
        $l = $_;
    }
    #G&give,Budge=>[LastFewb=>''=>{s=>[$l]}];
pi/B: |
    my $hs = Rw Numstring $s:C.t 3;
    $hs =~ s/([1-4])$/$1+4/e;
    # B:
    n t=>1=>s.t=>'fs:11,hs:'.$hs
    # w/$I
    my $z = sc&s;
    
    if (!ref $z) {
        n s=>2=>$z=>'hs:677'
        return;
    }
    else {
        A&justty = 1;
    
        my $ac = G&aC,$z,'Ck5';

        my $fss = &s{
            my $over = length($s) / 14;
            my $fs = int(12 / ($over < 1 ? 1 : $over * 0.89));
            $fs = 5 if $fs < 5;
            $fs
        };
            $ac->[1] =~ s/^0\.//;
            my $fs = $fss->($ac->[0]);
            #
            n t=>2=>{s=>shift @$ac},"%hs:356,fs:$fs,mw:14"
            n ycv=>2=>{s=>shift @$ac},'%fs:12,ma:0.3'
    }
    #n btw=>5=>ki($z),'fs:6,dis'
    if (z.t eq 'J' && z.y.cv == 0.6) {
        s&dis = 1;
        if (my $Y = ss&A) {
            Ys&dec &&
            n dec=>4=>"dec: Ys&dec",'fs:7,hs:976'
            n issn=>41=>G&sn,$Y ,'fs:7,hs:977'
        }
        n sy=>575=>"J"=>"%hs:7574,ab:1,poi:0,lh:40%,fs:".int(100 / 3)
    }

