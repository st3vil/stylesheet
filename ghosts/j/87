Scripts: | # to
    q{
    we should be writing more code that doesn't compile
    then we will be pushing the boundary and siding with expression
    since the computer is the center of culture empire gravity
    
    max doing with minimal it understanding itself
    
    where we're going, salad is why
    
    the wayhow brings the knowhow
    
    bridge imagined
    
    stuffed animals
    
Todol: | # YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
    a[
        show shoves.
        to have generals here,
            eventually doing anything to anything we save,
            at any level, eg. edit thing in the brain and see the hands catch up
          specific types should go to 871 eg ghost(s), worm(s)
    ]
    q{
    
    collect pi to some place, which keeps building itself in new bays
    colonies pumped through Te, which watches jobs
    jewelis == each
    # $s =~ s/\n/â†¯/g;
    
    -ghost slowlies -way
    | a
    -way as they live
    | b
    -worm puts/gets $G/Co/$Gt
      G usually is Gt, unless things are spreading out
    
    so far $G/Co could be called s,
      and you look for your names in it
    
    pipe a is push/pull done,
     < info on the pull/push (diff with colour?)
    YY YY YY YY
    pipe b needs auto/aiming
     as a zone, which ns-indep. writes into an a -wormhole, on a -Ghost
     
    which gets read by Train
      making it:
    G&give:Budge=>['sok'=>''=>{s=>$M}];
      or something nicer
    
    and build wormholes
    should remember exactly where we are
    and click each W back one elvis or:
     forward:
      carefully
       with per-w etc stops if needing runtime disection
     back:
      one elvis
      to some mull (junk, the land the emerges during work)
    
Te: | # comp sci helpyou !!!!
    Gc&Glan = 'Elan' if G.d;
    # Lst Ts and their 5ings
    Rw Tiot;
    y.at.miw = '40%';
    y.at.mw = '60%';
    y.at.dis = 1;
    Rw UpSetulism;
    Rw GiveTime;
    #1s&FishBrainDump = 1;
    
    Rw Impsev $and=init;
    y.res = 100;
    
    # c&pi generate s&pi, elvised to A.3 become c&pi again
    # can eat ghost, way and worm
    Rw EatsPi ghost way worm;
    
    Jc&ETmode = 2;
    Rw IET;
    
    S
    
    # feedback of any s&mix, c&pi <- s&pi
    Jc&save = 1;
    Js&top ||= Rw ReadMe;
    # trouble making this tv upstream
    # as its sMJ'ing items to Js&M
    
    # < steady J args by 1c&f = c&s ...
    # ghosts from/stable
    my $f = Rw lo/ghost $s=j;
    # ghosts to/wild
    my $t = "s";
    Rw piFeedTape + $default=$f:-ghosts_$t:-worms;
    
    Jc&bay ||= 'spot';
    Jc&G ||= 'Ge';
    my $ts = Rw fi/sembla bay G add;
    
    
    Js&boWls ||= do {
        my $o = Js&top.y.tw.boWls;
        #n fyi_ope=>-od_o83=>{s=>$o}
        oc&s =~ /Bo:(\d+)/;
        $1;
    };
    n bowls=>o81=>"Bo:".Js&bowls++ 
    n boWls=>o82=>"Bo:".Js&boWls++ 
    
    Js&M ||
    n nom=>o2=>"NO M"
    
    my $d = "Jc&bay/G/Jc&G";
    # edits the G to init code into ^
    # -way drawn from abvo
    
    n GoWalking=>-Gug
    
    # stack certain shapeleyishly
    for my $C (@$M) {
        s&float = 'left' if c&pi eq 'ghost';
        s&float = 'left' if c&pi eq 'way';
    }
    push @{A&codesix||=[]}, $ts;
    
    return;
    G&timer,0.1,$_ for &{
        4s&toy->({to=>['SeeTEer']})
    };
    
pi/ghosts: | # ghost fractioney listing
    # turns j into g/j
    #   or 81 into g/j/81, etc.
    # then whatever's there into (1)1,2[1,2,3],3 (2)1,2 etc for 1, 11, 12, 121, 122, etc
    s&dis = 1;
    Rw Tiot + $nodis=1;
    
    s&open = 1;
    my $s = C.t || die "nowhere"; # our c&s disappears...
    n lies=>-lise_1=>$s,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    # each t shows its uniqueness beyond its parent
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            $C = Rw Min/bits + $dos=EatPi;
            s&pi = 'ghost';
            s&ma = 0.1;
            if (c&depth) {
                # short
            }
            else {
                c&s = $1 if C.t =~ /^\Q$s\E\/([^\/]+)$/;
                s&ml = 0.4;
            }
            s&fs = 17 - 4 * c&depth;
            s&fs = 3 if s&fs < 3;
            delete s&ml;
            delete s&dis;
        }
    }
pi/ghost: | # opens ghost file via -codolf, has a -ways of them
    # was being a C produced in some list
    s&dis = 1;
    s&file = C.t if -e C.t;
    Rw Tiot;
    s&open = 1;
    Jc&ETmode = 2;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    
    
    # can locate 
    n w=>-codolf=>{f=>C.t},qz
    
    # < sleep these on o of the y.C we are
    
    n ways=>-ways_2=>{s=>T.op}
    
    Rw EditLatter;
pi/ways: | # < move this and -codolf into -ghost
    T.op = $s;
    if (0 && A.2.t eq 's/Ru') {
        G&give,Budge=>["Saem"=>''=>{s=>$s}];
    }
    for my $C (G&op,3 ) {
        c&ind = 2 if s&pren; # becomes c&depth aft v
        $C = Rw Min/bits + $dos=EatPi $keep=dige;
        s&fs = 9 - c&depth if c&depth;
        s&pi = 'way';
    }
pi/codolf: | # read file of -code, yaml about pin=>way
    # TODO Glocation
    y.n = 3;
    y.u = 4;
    y.res = 100;
    1s&piduces = 'code';
    
    my $f = c&f || 'g/'.c&s;
    my $t =
    n $f=>-ftimedig
    if (my $l = 1c&ET) {
        my $j = ts&J;
        my $z = js&s;
        my $n = zs&notice;
        if (ns&sleep) {
            ls&sle = "fitim";
            return T.Z.8 = $A;
        }
    }
    S
    my $code = read_file($f);
    my $hashc = '#'.'c';
    my $mashc = ''; #qr/|[^\n]+$hashc/;
    my @chunks = split /\n(?=\S$mashc)/sm, $code;
    
    my $i = 0;
    for my $s (@chunks) {
        $s =~ /\S/ || next;
        my ($tip) = my @l = split "\n",$s;
        my $t = $1 || $2 if $tip =~ /^([\/\w]+):|$hashc.*?(\w\w+)/;
        my ($pren,$note) = split /\b\Q$t\E\b/, $tip, 2 if $t;
        s/^: \|//, s/^\s*//, s/^\s*$hashc\s*//, s/# // for $note;
        
        $t ||= $tip;
        my $sc;
        sc.note = $note if $note;
        sc.pren = $pren if $pren;
        sc.i = $i;
        sc.pi = 'code';
        $s .= "\n" if $s !~ /\n$/;
        sc.dige = slm(12, dig $s);
        m $t=>''=>{s=>$s},$sc
        $i++;
    }
    
pi/codolf/intake: | # write file of -code from $M
    # M has the adjustment already
    # j is -codolf
    my $f = j.t;
    -f $f || die "$f not there! am ".G&sn,$j;
    
    # New names-only want to be inflated to empty
    for (@{ar.N||[]}) {
        # make copy that will be in -codetta form,
        # convert that to -code to get yaml around it
        # < rename -code -ycode?
        my $C = G&hup,$_;
        s&pi ||= 'codetta';
        c&s ||= "#";
        s&note ||= "new";
        my $M = [$C];
        my $o = Rw pi/codetta/to/code $M;
        G&xo,$_,$o;
    }
    
    # Renamed things... we hard code the t when -codetta->-code,
    # but also serve the -map (bunch of t editor) as if it wasn't
    for (@{ar.R||[]}) {
        my $twas = delete _s&twas;
        defined $twas || die "change hard t notwas: ".ki$_;
        _c&s =~ s/^\Q$twas\E:/_.t:/
            || die "change hard t missed '$twas': "
            ." begins: ".slim 30, _c&s;
    }
    
    Rw cz/M $M $pi=code;
    
    # each -code's c&s is a chunk of indented/comment infested yaml:
    #   "pin: |( ?#[^\n]+)?\n(    way\n)+"
    my $s = join"\n",map{
        _c&s =~ /\n$/ ? _c&s : "_c&s\n"
    }@$M;
    
    write_file($f,$s);
    
    G&give:Budge=>[code_intake=>''=>{s=>[G&sn,$j ,j.c.s.sc.pi, $w,$o,$M]}];
pi/way: | # -way as suggested
    # resume itself...
    # way with a -ghost source, which wanders into the bay
    # if -chunks sourced, gather
    # remember where upto
    Rw Tiot;
    Rw Remembers;
    Jc&ETmode = 2;
    
    if (!@$M) {
        n init=>o3=>"Gitinit"
        # assume origin is to be figured from our C's yCource, dest picked
        # < slow push if to -ghost, fast if -wayin
        # 
        m origin=>-origin=>{upstream=>$C}
        m dest=>-origin
        m codify=>-codify
    }
    
    my ($t,$o) = grep{_c&pi eq 'codify'}@$M;
    $t || die "Nocodify";
    $o && die "toomany -codify";
    
    for (@$M) {
        if (_c&pi eq 'origin') {
            # if here is empty, may be just waking up, with stuff that should still dige
            my $vac = !tc&pull && !ts&dige;
            # auto pull first -origin
            if (_c&pull || $vac) {
                # plant a ref to C out, -origins mo first
                _c&pull = tc&pull = {};
                saygr "O pull _.t on A.1.t";
            }
            _c&head = $t;
        }
        _s&mix = 1;
    }
    
    # hook M to mo the C manually
    # if see osc AND C still of -origins, sleep -codify
    
    # could sleep -codify when waking up?
    
    # < delete as cutting names out of -ghost as codebox
    
    
    
pi/origin: | # git remote push/pull
    Rw Tiot;
    y.n = 4;
    y.u = 5;
    
    # c&upstream leaves its s&location
    # to repeatedly get:
    
    # Jc&head (-code, origin of that -way)
    #   and check its s&dige vs our copy s&local
    #     s&remote is here what its s&dige now is
    #     s&local is the s&dige we checked out
    # that comparing into:
    
    # c&head (-codify, sibling of the many -origins in this -way's M)
    #   unfurled, alive state
    #   and check its s&dige vs our s&head
    #    -codify with a s&dige from an encoding to some form with a dige
    c&head || die "Nohead";
    
    # < knowing not to pull/push over remote changes
    
    # < making CreateOrigin etc include W, or just . if not
    #   dots are bigger words spill out of them in stylehouse
    
    # comes in from t/Awaits
    my $newloc;
    if (1s&new_location) {
        s&location = delete 1s&new_location;
        $newloc = 1;
    }
    
    s&location ||= do {
        # -way should resume its M with our s&location
        #   if it is being resumed its C will not be tracable to -ghost
        #   should leave a note on the -way/checkout instance,
        #     in case its insides have vanished!?
        if (my $s = c&upstream) {
            # ^ may be a dead C later, when A.3 resumes open
            #   AND our -way since cloning has been deleted?
            my $l = Rw t/CreateOrigin $C:s;
            my $p = A.2.c.s;
            $p = p.y.moC; # n'd $C hups?
            # ! never makes it:
            2Cs&location = $l if $l;
            $l || 2Cs&location
        }
        else {
            # C.t name? suggests whatnow
            Rw t/Awaits
        }
    };
    s&location || return
        n location=>1=>"l:s&location",'hs:848'
    
    
    # read current origin of -way C as a path
    my $o = Jc&head = Rw t/FindOrigin;
    if (@$M) { # ^ will m if problems
        $newloc &&
            n repointfail=>''=>"pointfail,push to a&lost_point / A.2.t"
        Rw t/Awaits;
        # if path breaks before the t, it must be repointed
        # if path breaks on the t we could push to include it...
        return unless a&lost_point eq A.2.t;
    }
    
    # is over there (or not)
    s&remote = os&dige;
    
    # pull here
    s&remote &&
    n pull=>21=>'pull',{dos=>'GitsAct',fs=>6}
    if (my $p = c&pull) {
        s&remote || die "pull on disconnected remote: s&location";
        p.t = C.t;
        # also sent to -codify, attach object
        pc&s = $o;
        # local becomes as remote dige
        s&local = os&dige;
        # head becomes as the head/-way dige is
        #   not carried from o because of encoding to branch
        #     es' native dige-source types
        #     so -origin sits on boundaries of dige-integrity
        #     given a tree of source pouring out
        p.sc = C.sc;
        n pull_done=>2101=>'ing','fs:6,hs:587'
    }
    
    # should be set together as we pull/push
    my $ohno = delete s&next_should_be_still;
    if (s&remote && s&local ne s&remote) {
        n pull=>21=>'pull'=>'dos:GitsAct,fs:12,hs:746'
        if ($ohno) {
            n and=>221=>" != diges itself?",'fs:7'
            Rw Diff $o $i:ohno;
        }
    }
    
    # push there
    if (c&push) {
        # elvised, wakes up done
        # our mos unravel thing
    }
    
    # the -codify C, the working directory, is a head
    my $h = delete c&head; # keeps KCing mc? should be shaded...
    # < options to push to remote thing, pieces of running code?
    
    # this -origin's head vs -codify's head
    # - unless initing
    # - it would have got it from here
    my $p =
    n needs=>211=>'push',{dos=>'GitsAct',fs=>6}
    if (hs&dige && s&head ne hs&dige) {
        delete ps&fs;
    }
    if ($ohno) {
        n push_done=>2111=>'ing','fs:6,hs:587'
    }
    
    Jc&origin_hJ = a&origin_hJ if a&origin_hJ;
    my @Js = @{Jc&origin_hJ};
    Rw pi/pointer + $s:_ for [@Js,$o];
    
    
pi/pointer: | # describes pointer $s=[C+] with t and s&pi
    for (@$s) {
        #G&isC,$_ || die "NotC: ".ki$_;
        my $c = _.y eq $_ ? _c&s : $_;
        m on=>''=>"c.t",'ml:0.3,fs:7,hs:897'
        m is=>''=>"-cs&pi",'ml:0.3,fs:7,hs:697'
        #$c eq $o && 
    }
    
t/Awaits: | # create and/or pointer to the zone, where our way appears to G
    # AwaitDest
    my $n =
    n t=>2=>"awaits",'dos:Awaitiot'
    return unless 1s&awaiting;
    nc&s = 'click on a title...';
    ns&fs = 6;
    ns&hs = 875;
Awaitiot: | # next Reimp (title) click capturer
    3s&hijackimp = G&Ct,['Awaitioted'=>''=>{}=>{j=>$j}];
    js&awaiting = 1;
    3c&ET &&
    Rw ET 2;
Awaitioted: | # title click captured
    my $o = is&j;
    delete os&awaiting;
    my $t = js&top || die "top not?";
    # the -ghost or -worm has a more-original pi
    #   then an interpretation/display pi
    my ($r) = grep{ _s&pi } @{ts&z};
    $r || die "Cannot find first pi in ".ki$t;
    rs&J || die "first pi no sJ: ".ki$r;
    
    os&new_location = Rw t/OriJin $J:rs&J;
    
    G&give,Budge=>["Awaitioted"=>''=>{s=>[[$o,$i,$j,$r,os&new_location]]}];
GitsAct: | # do what cc&s says
    # FactorEase, with e...
    # jc&s is somewhere from $o, from hC, from tv
    my $s = '-? -origin$';
    my ($w,$o) = Rw fe/JC_hC $s;
    $o || return;
    
    my $wake = [];
    my $do = cc&s;
    if ($do eq 'pull') {
        # will go back into -way and to -origin (this $j)
        # whose difference (says ing, changes s&local) will tell -way to do the rest of itself
        oc&pull = 'clicked';
    }
    elsif ($do eq 'push') {
        push @$wake,
            Rw pushout $w $o;
    }
    else {
        G&give:Budge=>['does what?'=>''=>{s=>$c}];
    }
    # ET 2 means those things and this $j wake
    1c&ET &&
    Rw ET + $wake 2;
pushout: | # push to $w-way/$o-origin
    # -origin $o, 
    #   lacks s&remote and jc&head if it's new
    
    # wants $d-codify
    my $d = ar.d ||= Rw fe/innards $C:w $pi=codify $n=1;
    
    # -origin's J
    my $j = os&J;
    # -origin's download
    my $h = jc&head ||
        Rw pushout/nohead + $j $d;
    # -codolf 9, z having $h
    my $n = A&headconine ||
        Rw fe/fi $C:h yup;
    
    # move 9 up to mo C or the one before (yCish) it
    $l = Rw fe/fi $C:n sJ cs;
    my $cont = ls&pi || die "lang container not pi: ".G&aC,$l;
    # the pi with an intake
    # different from the lang pi that is intaken
    
    
    # is a container of heads, each of which:
    # has a language
    my $lang = A&headlang || hs&pi ;
    my $memk = "encoded_$lang";
    # to encode -way into $i
    my $i = d.y.>$memk ||= do {
        # -codify's $M of -codettas
        my $M = ar.M ||= Rw fe/innards $C:d $pi=codetta;
        Rw pi/codetta/to/$lang $M;
    };
    
    # rebuild -codolf 9's M (same as ls&z but going via J is aliver)
    my $M = Rw fe/fi $C:l sJ stop sz;
    
    1 && sayyl "Encoded $lang, to fit in to ".ki$M;
    1 && sayyl "For the 9: ".G&aC,$n;
    1 && sayyl "Or the C: ".G&aC,$l;
    
    # find the transportable termino of the stream
    # for the intake's $j
    # should be labelled from the source group (ghost)
    #   just as something s&piduces, the -ghost could:
    #    s&pisource - incoming termino/start of the stream
    #    s&pitv - when looking for pi things to be on tv
    #      (macro scaled .y.tv)
    #   there are different breakdowns of lookingfor/lookinglike
    #     to classify themselves
    my $f;
    unless ($cont eq 'codolf' || $cont eq 'wormin') {
        die join "\n", "(ls&pi eating $lang) check first C here is the source? ",
            map{ " -_s&pi ".G&aC,$_ } @$M;
    }
    # has one other thing (the file/source) $f
    #   and its set of things in M
    my ($f,$M) = Rw fe/Map $M $not=1 $pi:lang $n=1 $out=1 $V=1;
    # add/replace $i to $M, prev/next clueing with $w
    Rw fe/Mitch $nonfatal=1 $M $i $w; 
    
    1 && sayyl "ls&pi intake: ".G&aC,$l;
    # edge of multiplicity/cratering of $w and $o, give them anyway
    # now just about the remote ($f) and its set
    Rw pi/ls&pi/intake $M $j:fs&J $w $o;
    
    # update the -origin on the changed -way, encoded into $i
    os&local = os&remote = is&dige;
    os&head = is&dige; # or from whatever encosion head/-way/-codify is using
    os&next_should_be_still = $i;
    
    # wants to wake the upstream
    ls&J
pushout/nohead: | # allow
    # FindOrigin probably got some of the way:
    my $hJ = jc&origin_hJ || die "none of the way";
    my $H = $hJ->[-1];
    A&headlang = Hs&piduces 
        # or see what it has in Hs&tops&z
        || die "headcontainer not piduces: ".ki $H;
    A&headconine = Hs&top
        || die "headcontainer not osc'd: ".ki $H;
    #G&give:Budge=>['discon'=>''=>{s=>[[$j,$d,$H]]}];
    return;
codein: | # change $w-way/$d-codify/$t-codetta talky box
    # off to build a new -codify M
    #  push to easy origins
    my $s = "-? s\&dige s\&dige\$";
    my ($w,$d,$t) = Rw fe/JC_hC $s;
    
    # a -way/-origin saves
    ws&pi eq 'way' || die "noway";
    # and these are ours
    ds&pi eq 'codify' || die "nocodify";
    ts&pi eq 'codetta' || die "codetta";
    
    # new $o of $c, put together a new -codetta
    my $E = {};
    E.t = t.t;
    Ec&s = us&code || die "Nocode to tinput";
    return T.pos = 0 if Ec&s eq tc&s;
    Es&dige = slm(12, dig Ec&s);
    Es&pi = 'codetta';
    
    # feed modified -codetta to itself in -codify M
    G&xot,$t,$E;
    
    # get -codify M - unify them to get a s&dige on -codify
    my $M = Rw fe/fi $C:d sJ stop sz;
    
    # -codify itself doesn't have a join-and-digest happening...
    # so use -code, or the first one it encounters via -origin
    # to run changes through to update head, -codify's s&dige
    my $i = Rw pi/codetta/to/code $M;
    my $was = ds&dige;
    ds&dige = is&dige; # diff to -origins s&heads 
    d.y.encoded_code = $i; # memo for pushes
    
    # paused is really pretending to be another point in the tree...
    return if ds&paused; 
    
    # get -way's M's -origins
    my $r = Rw fe/innards $C:w $pi=origin;
    my $wake = [];
    for my $o (@$r) {
        next unless ws&settlement <= os&settlement;
        my $j = os&J || die "No origin J: ".ki$o;
        push @$wake, $j;
        next unless jc&head; # not tuned in, next trip around?
        push @$wake,
            Rw pushout $w $o $d $M;
    }
    
    1c&ET &&
    Rw ET + $wake 2;
pi/codify: | # spread out here, pack up an push changes when elvised
    # get chunks from origin or last codify
    # reversing itself and pushing to origin or so...
    #os&dige || die "No dige on ".ki$o;
    
    Rw Remembers;
    # these -codetta C must come back with their c.s, probably
    #   some ^ buildout may know its whole self inside
    # pi-with-Jtv's c.s usually not saved (still not taped)
    1c&savepics = 1;
    
    if (my $p = c&pull) { # a -code or so
        my $s = pc&s;
        $s || die "nopull!?";
        my $m = $M;
        my $N = [grep{_s&mix}@$M]; # working directory
        my $M = []; # stuff to check out
        
        saygr "pulling s.t from p.t";
        Rw pi/codetta/from/code + $M $s;
        
        #@$N && # could stay around as ah...
        #n the_hop=>-od_94=>[$N,$M];
        # fm channel
        #n pulled=>1=>"pulled s.t ss&dige"
        
        # codify in reverse
        my $o = Rw pi/codetta/to/code + $M;
        # could try and go all the way and:
        #os&dige eq ss&dige || die "-codify doesn't roundtrip";
        # our -origin's s&head
        s&dige = os&dige;
        ps&head = os&dige;
        
        my $tw;
        $tw.>$_ = 1 for @$N;
        @$m = grep {!$tw.>$_ } @$m;
        push @$m, @$M;
    }
    
    
    
    _s&mix = 1 for @$M;
    
    # start squishgame?
    _s&fs = 7 for @$M;
    
    #G&give:Budge=>['sok'=>''=>{s=>$M}];
    #n "M-codify"=>-od_92=>{s=>$M}
pi/codetta: | # code boxen, re C.t to alter? check js, hold something?
    # our s&dige, parts to -codify's s&dige
    # is forward-reverse
    s&miw = '100%';
        # maybe...
        #s&mh = 7;
        #overflow-y: overlay;
    s&dis = 1;
    #n t=>1=>C.t,'%sha:4 9 5 698'
    
    my $h = A.3.sc;
    #$s = $h.>C.t ||= C.t;
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:codein';
    #sc.width = 4;
    #sc.height = 3;
    sc.dig = s&dig if s&dig;
    n "z fo" =>1 =>{s=>$s},$sc
    
    y.at.cssdel = 'transform';
pi/codetta/from/code: | # -way's -codify M -codetta chunks from -code
    # regroup a -code onto $M
    my $o = $s;
    os&pi eq 'code' || die "to codify from -os&pi";
    # < option to not, edit whole yaml chunk
    # < centralise code splits with underneaths of Bablar?
    my $hashc = '#'.'c';
    my @l = split "\n",oc&s;
    my $n; # last atom
    my $indnext; # whether the next line defines:
    my $indchop; # chop indent whitespace of -code form
    
    my $i = 0;
    for my $l (@l) {
        $i++;
        # is it a heading
        my $t = $1 || $2 if $l =~ /^([\/\w]+):|$hashc.*?(\w\w+)/;
        $t && $1 && $n && die "more ways after: ".ki($n)."\n line $i: $l";
        $t && $1 && os&pi ne 'code' && die "way title from -os&pi: ".ki$o;
        
        if ($indnext) {
            $indchop = $1 if $l =~ /^(\s+)/ || die "no indent after ".ki ns&l;
            $indnext = 0;
        }
        if (defined $indchop) {
            $l =~ s/^$indchop// ||
                $l =~ /^\s+$/ && die "breaks indent line $i: $l";
        }
        
        if ($t) {
            my ($pren,$note) = split /\b\Q$t\E\b/, $l, 2;
            s/^: \|//
            # keep leading whitespace? indent the hashc or the comment after...
            ,s/^\s*//, s/^\s*$hashc\s*//,
            s/# // for $note;
            $indnext = 1 if !$n; # everything must be in that far
            $n =  
            m $t=>-codetta=>{}
            ns&note = $note if length $note; # other notes e
            ns&prenote = $pren if length $pren; # never?
            #sayyl "Sectioned by $l\n    n: ".G&aC,$n;
            # title is outside the babble, in named bubble code (yaml)
            next;
        }
        $n || die "No title line $i: $l";
        
        push @{ns&l||=[]}, $l;
    }
    
    for (@$M) {
        _s&l || die "Nothing in _.t?";
        _c&s = join "\n", @{delete _s&l};
        _c&s .= "\n" if _c&s =~ /[^\n]$/;
        _s&dige = slm(12, dig _c&s); # chunk of way, sans indent dige
    }
    
pi/codetta/to/code: | # REVERSE -way's -codify makes from -codettas into a -code
    my $hashc = '#'.'c';
    my $M = [grep{_c&pi eq 'codetta' || _s&pi eq 'codetta'} @$M];
    my ($f) = @$M;
    my $o;
    o.t = f.t;
    my @l = (
        "f.t: |".(fs&note && " # fs&note"),
        map {"    ".$_} # 4 ind
        map {
            my @l = split "\n", $_;
            pop @l while @l && $l[-1] =~ /^\s*$/;
            @l
        }
        map {
            my @l;
            if ((_s&note || _s&pren) && $_ ne $f) {
                @l = (_s&pren||"")."$hashc".(_s&note&&" # _s&note")
            }
            (@l, _c&s)
        } @$M
    );
    oc&s = join "\n", @l;
    oc&s .= "\n" if oc&s !~ /\n$/;
    # makes it probably like the -code dige standard
    # should be just a chunk of way, sans t, indent, com, etc?
    os&dige = slm(12, dig oc&s);
    os&pi = 'code';
    $o
    
pi/Tin: |
    Rw pi/codetta;
GoWalking: |
    Rw Tiot;
    Rw GiveTime;
    # extrane
    y.res = 100;
    
    my $i = ++Js&bowls;
    if ($i == 1) {
        m 3=>''=>'!'
    }
    if ($i == 2) {
        m 5=>''=>'!'
        m 3=>''=>'!'
        m 2=>''=>'!'
        m 4=>''=>'!'
    }
    if ($i == 3) {
        m 9=>''=>'!'
        m 1=>''=>'!'
        m 3=>''=>'!'
        m 2=>''=>'!'
        m 8=>''=>'!'
        m 4=>''=>'!'
        m 5=>''=>'!'
    }
    
    Js&bowls < 5 &&
    G&timer:0.1,&{ 4s&toy->({to=>[J.t]}) };
    
    return;

    my $c = 
    n Train
    my $j = cs&J;
    n od=>-od=>{s=>js&s}
    
Train: |
    Rw Tiot;
    
    Rw LastFewb;
    
    n boogie=>-sdi=>=>dis
pi/sdi: | # pretty text
    s&hs = Rw Numstring $s 3;
    s&hs =~ s/([1-4])$/$1+4/e;
    #s&sha = '2 2 4 439';
    # s&fs = relativity
    # G&has,word=>$s # to change relativity
    T.nose = 3;
LastFewb: | # see what matters!
    # earn names
    my $c = Gc&B;
    my $l = [$c];
    my $S = $c;
    while ($S = S.y.out) {
        unshift @$l, $S;
        last if @$l > 17;
    }
    m _.t=>-B=>{s=>$_} for @$l;
    undef $l;
    # FactorEase c&s wherebouts chains and Ts
    # and injecting after C in an M
    #   gives somewhere C,
    #   named iterators! starting with M
    for (@$M) {
        my ($s,$c) = ($l && lc&s, _c&s);
        #_s&dis = 1 if ss&A.1 ne cs&A.1;
        $l = $_;
    }
    #G&give,Budge=>[LastFewb=>''=>{s=>[$l]}];
pi/B: |
    my $hs = Rw Numstring $s:C.t 3;
    $hs =~ s/([1-4])$/$1+4/e;
    # B:
    n t=>1=>s.t=>'fs:11,hs:'.$hs
    # w/$I
    my $z = sc&s;
    
    if (!ref $z) {
        n s=>2=>$z=>'hs:677'
        return;
    }
    else {
        A&justty = 1;
    
        my $ac = G&aC,$z,'Ck5';

        my $fss = &s{
            my $over = length($s) / 14;
            my $fs = int(12 / ($over < 1 ? 1 : $over * 0.89));
            $fs = 5 if $fs < 5;
            $fs
        };
            $ac->[1] =~ s/^0\.//;
            my $fs = $fss->($ac->[0]);
            #
            n t=>2=>{s=>shift @$ac},"%hs:356,fs:$fs,mw:14"
            n ycv=>2=>{s=>shift @$ac},'%fs:12,ma:0.3'
    }
    #n btw=>5=>ki($z),'fs:6,dis'
    if (z.t eq 'J' && z.y.cv == 0.6) {
        s&dis = 1;
        if (my $Y = ss&A) {
            Ys&dec &&
            n dec=>4=>"dec: Ys&dec",'fs:7,hs:976'
            n issn=>41=>G&sn,$Y ,'fs:7,hs:977'
        }
        n sy=>575=>"J"=>"%hs:7574,ab:1,poi:0,lh:40%,fs:".int(100 / 3)
    }

