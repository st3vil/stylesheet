Scripts: | # to
    q{
    we should be writing more code that doesn't compile
    then we will be pushing the boundary and siding with expression
    since the computer is the center of empiricle gravity
    
    max doing with minimal it understanding itself
    
    where we're going, salad is why
    
    the wayhow brings the knowhow
Todol: |
    q{
    collect pi to some place, which keeps building itself in new bays
    colonies pumped through Telon, which watches jobs
    jewelis == each
    # $s =~ s/\n/â†¯/g;
Impsev: | # restart lv when wil > 7
    if (ar.and eq 'init') {
        # normal-ish web state starting new log, eg Telon
        # knows its last 1, restarts 7ing
        1c&imping = 1 unless 1s&lastmo
    }
    if (my $s = 1s&s) {
        1c&imping = 1 if ss&wil > 7
    }
    A.mo.sc.lastmo = 1s&lastmo;
    1s&lastmo = A.mo;
EatsPi: | # add things you like to eat
    for my $pi (@{ar.m}) {
        Js&ein.pi.>$pi ->{sMJ} = &sMJje{
            1 && saybl "Havi J.t: ".G&aC,$e;
            Rw PutThingAfterSource $e $M;
        };
    }
PutThingAfterSource: | # stitch into M for EatsPi
    # $e is a $c, clicked on pi
    my $c =
    m e.t, {C=>$e,cv=>e.y.cv}, e.c, e.sc
    c.y.up && warn "M doesnt deyer";
    
    my $s = e.y.up || die "no eyup";
    $s = ss&J || die "no J";
    $s = s.2 until s.2 eq s.3;
    my @is = grep { _.t eq s.1.t } @$M;
    if (@is == 1) {
        @$M = grep { $_ ne $c } @$M;
        @$M = map { $_ eq $is[0] ? ($_,$c) : $_ } @$M;
    }
EatPi: | # hope throwing this pi ($c) into somewhere (e J.t) will do something
    sayre "Hoping J.t will like ".G&aC,$c;
    G&elph,J.t=>$c;
    T.pos = '';
Telon: | # comp sci helpyou
    Gc&Glan = 'Elan' if G.d;
    # Lst Ts and their 5ings
    Rw Tiot;
    Rw UpSetulism;
    Rw GiveTime;
    #1s&FishBrainDump = 1;
    Rw Impsev $and=init;
    Jc&save = 1;
    
    # c&pi generates s&pi which become c&pi when fed to A.3
    Rw EatsPi chunks way ghost;
    
    S
    Jc&bay ||= 'spot';
    Jc&G ||= 'Ge';
    my $ts = Rw fi/sembla bay G add;
    
    
    Js&boWls ||= do {
        my $o = Js&top.y.tw.boWls;
        #n fyi_ope=>-od_o83=>{s=>$o}
        oc&s =~ /Bo:(\d+)/;
        $1;
    };
    n bowls=>o81=>"Bo:".Js&bowls++ 
    n boWls=>o82=>"Bo:".Js&boWls++ 
    
    Js&M ||
    n nom=>o2=>"NO M"
    
    my $d = "Jc&bay/G/Jc&G";
    # edits the G init code into ^
    # amongst other way drawn from:
    
    Rw piFeedTape + $default=j:-clonge;
    
    my $w = G&t,w=>"Todol";
    Js&sayin = wc&s;
    #m sayin=>-Tin
    
    #n lies=>-lise_1=>"$d/ip",'%qz,fs'
    #n lizm=>-filsipdrs_2=>{s=>T.op}
    
    n M=>-od_92=>{s=>$M}
    #@$M = ();
    n GoWalking=>-Gug
    
    # stack certain shapes next to each other
    #1s&Osulation = 'FormShapes';
    for my $C (@$M) {
        s&float = 'left' if c&pi eq 'ghost' || c&pi eq 'way';
    }
    
    $ts->();
    
FormShapes: | # stack certain shapes next to each other
    # 
    my @s;
    my @M = @$M;
    my $l;
    while (@M) {
        my $r = shift @M;
        if (ls&shape && ls&shape eq rs&shape) {
            push @s, [$l] unless @s && $s[-1]->[-1] eq $l;
            push @{$s[-1]}, $r;
        }
        $l = $r;
    }
    for my $s (@s) {
        my $i = 0;
        for my $C (@$s) {
            next unless $i++; # first one takes up space
            s&ab = 1;
            s&left = 3 * $i;
        }
    }
    G&give,Budge=>[formshapes=>''=>{s=>\@s}];
    
piFeedTape: | # your J state recovery
    # Tiot shiftclick empties Js&M
    Js&Simp = 'Sweeptapes';
    Js&Cimp = 'Detapes';
    # writes s&mix=1 on everything to feedback
    if (!Js&M) {
        # init saved/feedback
        my $t = Js&top;
        my $M = Js&M = [];
        m $_ for grep{_s&mix} @{ts&z||[]};
    }
    if (!@{Js&M||[]}) {
        my $M = Js&M;
        if (my $d = ar.default) {
            m ref $d ? $d : split(":", $d)
        }
    }
    m $_ for @{Js&M||[]};
    
    delete _.y.cv for @$M;
    _c&pi = delete _s&pi for grep{_s&pi} @$M;
    # pi sc become c ^
    # unless waiting for waves of things to come up...
    my $i = 1s&Feedbowlings++;
    for (grep{!$i && _s&pi eq 'way'} @$M) {
        _s&pi = delete _c&pi ;
        delete Jc&save;
    }
    Jc&save || G&timer:0.1,&{ 4s&toy->({to=>[J.t]}) };
    
    _s&mix = 1 for @$M;
    my $tw;
    @$M = grep { !$tw.>_.t ++ } @$M;
    
    Rw DeStyleM;
    
pi/clonge: | # ambiento numbery ghostlisting
    #
    s&dis = 1;
    $s ||= C.t;
    my $f = Rw Glongate $s;
    
    Rw Tiot + $t:f $nodis=1;
    
    n lies=>-lise_1=>$f,'%qz,fs'
    
    my $t = T.op;
    my $z = ts&z;
    #n $f=>1=>''.`ls -1ct $f`
    my @tops = Rw rez/thier $z;
    for my $C (@tops) {
        my @l = Rw ind/sort;
        for my $C (@l) {
            my $m = Rw Min/bits + $dos=EatPi;
            ms&pi = 'ghost';
            ms&ma = 0.2;
            if ($C eq $l[0]) {
                mc&s = $1 if C.t =~ /\/([^\/]+)$/;
                ms&fs = 14;
                ms&ml = 0.4;
            }
            delete ms&ml;
            delete ms&dis;
        }
    }
pi/ghost: | # opens ghost file via -codof, has a -ways of them
    # was being a C produced in some list
    s&dis = 1;
    s&file = C.t if -e C.t;
    Rw Tiot;
    #n yoa=>2=>ki($s),'fs:7,hs:595'
    #n self=>-od_3=>{dl=>1,s=>$C}
    
    
    # can locate 
    n chunks=>-codof=>{f=>C.t},qz
    my @codes = G&op,'pi:code';
    my ($c) = grep {_.t eq 'data'} @codes;
    $c = \@codes;
    #n C.t=>-lise=>{largemult=>18},'qz'
    # < hook some reverse function here, for f <- ways
    
    # < sleep these on o of the y.C we are
    
    n ways=>-ways_2=>{s=>T.op}
    
    #n ways=>-od_3=>{s=>$c}
    # shape us
    s&shape = 'tot';
pi/ways: | # beings in lines, gets ghost backing until it settles...
    T.op = $s;
    for my $C (G&op,'pi:code' ) {
        c&ind = 2 if s&pren; # becomes c&depth aft v
        $C = Rw Min/bits + $dos=EatPi;
        s&fs = 9 - c&depth if c&depth;
        s&pi = 'way';
    }

Originfo: | # mark it so elvistivity can fade out, and find where to awake...
    my @l = my $S = $C;
    push @l, $S while $S = @l < 30 && S.y.C;
    s&origin && return
        Rw Originfind;
    
    # find consecutive yA=o
    my @os; 
    my $l;
    for (reverse @l) {
        my $Y = _.y.A || next;
        if (Y.t eq 'o') {
            push @os, [] if !@os || $os[-1]->[-1] ne $l;
            push @{$os[-1]}, $_;
        }
        $l = $_;
    }
    @os < 2 && 
        n argh=>3=>"Not enough history to find origin",'fs:7,dis,hs:566';
    @os > 2 && die "Lots of history";
    # first o'ing?
    my $os = $os[0];
    # last o?
    my $c = $os->[-1];
    my $Y = c.y.A;
    my $j = Y.1;
    j.3 ne J.3 && die "Origin not in J.t";
    my @J = $j;
    my $i = 0;
    push @J, $j while $j = $i++ < 20 && j.2 ne j.3 && j.2;
    s&origin = join";",map{_.t}reverse @J;
    
    $c
    
Originfind: | # look for s&origin, usu in 3
    my @p = split ';', s&origin;
    my $j = A.3;
    js&top || die "3: j.t not ready!";
    my $i = 1;
    my @fi;
    
    push @p, C.t;
    
    for (@p) {
        js&top || die "Lost @p    at $_ No top: ".G&aC,$j;
        my $f = js&top.y.tw.>$_;
        if (!$f) {
            m "Lost @p at $_"=>-od=>{s=>[@fi,js&top,$j]}
            return
        }
        @p <= $i && return $f; # last hop is c
        
        if (!fs&J) {
            if ($i == 1) {
                # assuming the top is still from thaw
                # but Jtv points to the thing, earlier in A.3's M
                my $jv = js&Jtv.>$_;
                if (keys %$jv != 1) {
                    m "Lost @p at $_, maybe Jv:"=>-od=>{s=>[$j,$jv]}
                    return;
                }
                ($j) = values %$jv;
            }
            else {
                m "Lost @p at $_"=>-od=>{s=>[[$f]]}
                return
            }
        }
        else {
            undef $j;
        }
        #$f = f.y.C if f.y.C; # not on KC
        push @fi, $f;
        $j = fs&J if fs&J; # not on KC?
        push @fi, "Found ".G&sn,$j ." on ".G&aC,$f;
        $j || push @fi, "No j on: ".ki $f if @p > $i;
        $i++;
    }
    $j
    
Origist: | # origin infographics, merge with above
    my @l = my $S = $C;
    push @l, $S while $S = @l < 30 && S.y.C;
    #
    @l = map { $_, _.y.A && G&sn,_.y.A || "noyA" } @l;
    n history=>-od_4=>{dl=>1,s=>\@l}
pi/Tin: | # code boxen, re C.t to alter? check js, hold something?
    #s&ab = 1;
    #s&ri = 0;
    #s&zi = -30;
    s&miw = '100%';
        # maybe...
        #s&mh = 7;
        #overflow-y: overlay;
    s&dis = 1;
    n t=>1=>C.t,'%sha:4 9 5 698'
    
    my $h = A.3.sc;
    $s = $h.>C.t ||= C.t;
    
    my $sc = G&peel,'%cod:perl,dig:steve,dos:Tinput';
    #sc.width = 4;
    #sc.height = 3;
    sc.dig = s&dig if s&dig;
    n "z fo" =>1 =>{s=>$s},$sc
    
    y.at.cssdel = 'transform';
Tinput: | # handly talky box
    # should be of autocomplete, lost-focus and escape
    
    my $s = us&code || die "Nocode to tinput";
    my $j = e&_hJ;
    1 && saybl "tinput: ".G&es , " (J.t's j.t) says: $s";
    J.3 eq $J || die "J not J3: ".G&sn,$J;
    
    my $was = J.sc.>j.t;
    J.sc.>j.t = $s;
    T.pos = $was ne j.t;
    #J.vid = us&code;
GoWalking: |
    Rw Tiot;
    # extrane
    my $c = 
    n Train
    my $j = cs&J;
    n od=>-od=>{s=>js&s}
Train: |
    Rw Tiot;
    
    Rw LastFewb;
    
    n boogie=>-sdi=>=>dis
pi/sdi: | # pretty text
    s&hs = Rw Numstring $s 3;
    s&hs =~ s/([1-4])$/$1+4/e;
    #s&sha = '2 2 4 439';
    # s&fs = relativity
    # G&has,word=>$s # to change relativity
    T.nose = 3;
LastFewb: | # see what matters!
    # earn names
    my $c = Gc&B;
    my $l = [$c];
    my $S = $c;
    while ($S = S.y.out) {
        unshift @$l, $S;
        last if @$l > 17;
    }
    m _.t=>-B=>{s=>$_} for @$l;
    undef $l;
    # FactorEase c&s wherebouts chains and Ts
    # and injecting after C in an M
    #   gives somewhere C,
    #   named iterators! starting with M
    for (@$M) {
        my ($s,$c) = ($l && lc&s, _c&s);
        #_s&dis = 1 if ss&A.1 ne cs&A.1;
        $l = $_;
    }
    #G&give,Budge=>[LastFewb=>''=>{s=>[$l]}];
pi/B: |
    my $hs = Rw Numstring $s:C.t 3;
    $hs =~ s/([1-4])$/$1+4/e;
    # B:
    n t=>1=>s.t=>'fs:11,hs:'.$hs
    # w/$I
    my $z = sc&s;
    
    if (!ref $z) {
        n s=>2=>$z=>'hs:677'
        return;
    }
    else {
        A&justty = 1;
    
        my $ac = G&aC,$z,'Ck5';

        my $fss = &s{
            my $over = length($s) / 14;
            my $fs = int(12 / ($over < 1 ? 1 : $over * 0.89));
            $fs = 5 if $fs < 5;
            $fs
        };
            $ac->[1] =~ s/^0\.//;
            my $fs = $fss->($ac->[0]);
            #
            n t=>2=>{s=>shift @$ac},"%hs:356,fs:$fs,mw:14"
            n ycv=>2=>{s=>shift @$ac},'%fs:12,ma:0.3'
    }
    #n btw=>5=>ki($z),'fs:6,dis'
    if (z.t eq 'J' && z.y.cv == 0.6) {
        s&dis = 1;
        if (my $Y = ss&A) {
            Ys&dec &&
            n dec=>4=>"dec: Ys&dec",'fs:7,hs:976'
            n issn=>41=>G&sn,$Y ,'fs:7,hs:977'
        }
        n sy=>575=>"J"=>"%hs:7574,ab:1,poi:0,lh:40%,fs:".int(100 / 3)
    }

