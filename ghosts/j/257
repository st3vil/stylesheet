
Ventur: | # pull up beside results
    G&heading,'Hz:50';
    G&u,['MelTest'];
    G&clusp;
    
    1s&steps = '?';
    1s&testname = 't/Explude';
    
    G&way,'Doming',ar;
    A&async = 1;
    # interacts with Doming
    $a = A&a;
    $waits = A&waits;
    $w = waits;
    $b = A&beready;
    
    1s&Y = A.4.up;
    
    while (A&S(1,"Pull")) {
        # pull test data from Revisit
        $r =
        1s&Revisit ||=
        G&e,['Revisit'],['get','',{s:1s&testname}];
        waits(r,'answers');
        
        $w = rc&s;
        b(w,'answer');
        1s&Answer = w;
        1s&Quest = rc&Q;
        n Quest -jod $s:1s&Quest %
    }
    
    # becomes a matter for the Gagregator,
    # external forces (G&t set, may have to merge)
    #  carry it away, like the end of Fat Old Sun
    while (A&S(2,"Scan")) {
        $R =
        1s&MindStarted ||=
        a(['Shovel'],['refresh','']);
        b(R,'mindup');
        $j = Rs&J;
        b(j,'theJ',{dl:4});
        b(js&question,'!C question');
        b(js&answer,'!C answer');
        n questiona -jod $s:js&question,dl:6 %
        n answera -jod $s:js&answer,dl:6 %
        
        1s&Afteru = js&quested;
        n Afteru -jod $s:js&quested,dl:6 %
        
    }
        
    while (A&S(3,"Push")) {
        # get Revisit to Serialise us and apply patch via G&t:
        $c = {};
        # the $Wt
        c.s = 1s&testname;
        # G&t question that got an object we are now replacing
        c.Q = 1s&Quest;
        # this J
        c.J = A.1;
        # Shovel's idea of u (ghost deps), 
        c.u = 1s&Afteru;
        #  
        $save =
        1s&Revists ||=
        G&e,['Revisit'],['set','',c];
        
        b(1s&Answer,'thans');
        b(save,'revist');
        b(c,'!C jurevist');
        
        n QuestAgain -jod $s:1s&Quest %
    }
    A&S(0);
Revisit: | # pull/push test data around test run - outside J, all done mode
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&u,['NutText'];
    G&clusp;
    1s&M ||= [];
    # e get  s:$Wt, gives c&Q
    1s&ein.get = &acgts{
        $Q = c&Q = G&Cye,[s,'',{of:'W'}];
        c&s = 
        G&ting,Q;
    };
    # make name v via pull request Q, saving J with 9s&u=u
    # e set  s:$Wt,Q:getc&Q,J:$J,u:{u:{},w:{}}
    # < -pi matching event handlers, so we can give an object
    # takes the item (Js&top) 
    1s&ein.set = &acgts{
        $e = c&e;
        $v = G&Cye,[ec&s,'-visit'];
        vc&Q = ec&Q; # from get^
        vc&j = ec&J; # to picture
        vc&u = ec&u; # mind to attach 9s&u
        1s&M.push(v)
    };
    G&S;
    
    # ag similar Cs, once they reach -visit @4 where it'd know ss&v/ss&dige
    while (1s&M.length > 1) {
        1s&M.shift();
    }
    each in 1s&M {
        i > 0 and break; nc&dolater = 1;
        m $n
    }
    
    n maj 3 s:Mah\njor\nka %dis:block,ws:pre
    
pi/visit: | # work up diff
    G&heading;
    # visiting is about selecting from tv
    $j = c&j;
    $u = c&u;
    $Q = c&Q;
    
    if (!1s&String || 1c&String) {
        1c&String = 0;
        $s = js&s;
        $r = ss&top;
        null != u and rs&u = u;
        # +Js, make another ind to each neighbour/constituent
        $co = &C,d{
            $j = s&J;
            !j and return
            $s = js&s;
            !s and return
            $r = ss&top;
            $l = G&Serialise,r,co;
            d.out.push(l);
        };
        1s&String = G&Serialise,r,co;
    }
    
    n fi -jod $s:C.c,dl:6.12 %
    
    n Write 2 s:tac %hue:200,fs:200%,dos:do/cup
    n String 2 s:re %hue:200,fs:180%,dos:do/cup
    # if different
    if (!Q) {
          n str -jod $s:1s&String %dis:block,ws:pre,fs:40%
    }
    else {
          n was -jod $s:Q,dl:8.23 %dis:block,ws:pre,fs:40%
          $P = Qs&P;
          if (Pc&String == 1s&String)
              n same 1 s:= %fs:1999%,ab:1,blr:8px,opa:0.5,lh:40%
          
          $d = diff(Pc&String,1s&String,{chunk:'word'});
          
          n loz 1 $s:d,ht:1 %dis:block,co:#1cf,ws:pre,width:200%,fs:40%,wb:break-word
          #n str -jod $s:1s&String %dis:block,ws:pre,fs:40%
    }
    
    
    
    if (1c&Write) {
        $Q =
        1s&questi ||=
        G&Cye,[C.t,'',{of:'W',s:1s&String}];
        1s&obj ||= [ G&ting,Q ];
        n right -jod $s:Q,dl:6.12 %
    }
    
    
do/cup: |
    $k = c.t;
    $j = c.y.A.1;
    j.c[k] ||= 0;
    j.c[k]++;
Savior: | # big list of s that 1c&save somewhere - inside J, progressive scan mode
    G&heading
    1s&ein.save = {w:'W/save'};
    if (c&e) {
        $e = c&e;
        $Y = e.y.A;
        ~>6 Savie: Y.cv
        # string pickers... objects wake up
    }
    
    G&S;
    
    
    $m = G&n:['M','-jod_2',{s:[]}];
    
    each in 1s&M {
        mc&s.push(n.t)
        G&n:[n.t,3+i*0.001,{s:n,pi:'jod'},{dis:'block'}];
    }
    G&lim,1s&M,8;
    mc&s = mc&s.join(", ");
W/save: |
    ~>79 saving: A.1.t, A.cv+'@'+A.n.cv, ss&v
    
    ec&hand and return ~againe
    ec&hand = "G";
    # 4s&ki(C,2), 4s&ki(e,2), 4s&ki(s,2)
    # do e in order, incase later e get handled before waylaid e get handled
    # remains linear if nothing async
    each iY 1s&N {
        # sometimes A.n
        Y.e and Y = Y.e
        Y == A || Ac&s == Yc&s and continue
        Y.cv >= 0.5 and continue
        $D = Yc&s;
        $S = Dc&s;
        # sort = 1 if A should come before Y
        #  break, assume later 1s&N are later
        G&sortsip (Y,A) and continue
        ~>28 queN: 4s&ki(Y,2), Ss&v
        # Y wants to happen before A
        #debugger;
        G&TuneTimeMachine,'e-order';
    }
    G&m:M,[ss&title,'',{s:ss&top}];
    

