Wade: | # serve /W/$t to Revisit
    # defines one place get/set name scheme
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        # read t, write if s
        # all there
        $t = "W/$t";
        # safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1
        my $f = "$t/1";
        
        # returns json:
        my $re = {ok=>1};
        # or ?
        #$c->render(text=>decode_utf8("c&s")); # ,format=>"js"
        
        # if setting
        if (defined $s) {
            if (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.ok = 0;
                re.er = 'not found'
            }
        }
        re.s = $s if length $s;
        $c->render(text=>sjson($re));
    };

Revisit: | # pull/push test data around test run
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&u,['NutText'];
    G&clusp;
    1s&M ||= [];
    1s&ein.get = &acgts{
        $Q = G&Cye,[s,'',{of:'W'}];
        c&s = 
        G&ting,Q;
    };
    # < -pi matching event handlers, so we can give an object
    1s&ein.set = &acgts{
        $e = c&e;
        $v = G&Cye,[ec&s,'-visit'];
        vc&was = ec&was; # from get^
        vc&j = ec&J; # to picture
        vc&u = ec&u; # mind to attach 9s&u
        1s&M.push(v)
    };
    G&S;
    
    # ag similar Cs
    each in 1s&M {
        i > 0 and nc&dolater = 1;
        m $n
    }
    
    n maj 3 s:Mah\njor\nka %dis:block,ws:pre
    
    
    return;
    # 1s&obj is the last:
    $t = 't/ExpectArt';
    $load = 1;
    $save = 0;
    
    
    
    if (load && !1s&obj) {
        $Q = G&Cye,[t,'',{of:'W'}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    if (load && !1s&ustone) {
        # last save of t
        $w = 1s&obj;
        # its mind, encoded, Shovel adjusts
        $u = ws&u;

        $e = 1s&ust = 1s&ust ||
        G&e,['Shovel'],['ready','',{s:u}];
        # waits until Shovel's&question is what we gave it
        # kind of a deal...
        # almost e Shovel [ puts   %$question:u
        e.y.A.cv < 0.8 and G&thro,e
        e.y.A.cv < 0.8 and G&TuneTimeMachine,'ewaits:'+e.t;
        1s&ustone = 1;
    }
    
    #  to make sure this is fresh Shovel
    $n =
    n Shovel V
    n = ns&J;
    !n and return
    # take this encoded representation of our mind state
    $q = ns&quested;
    
    #n mindstat -jod $s:q,dl:55 %ws:pre,hue:150deg,fs:30%
    
    #n = ns&s;
    #!n and return
    #$u = G&Serialise,ns&top;
    #n mindstat $s:u %ws:pre,hue:150deg,fs:30%
    
    
    
    $n =
    n Expect V
    n = ns&J;
    !n and return
    n = ns&s;
    !n and return
    
    # ns&top...
    #   can be given a toLines encoding by anyone wanting it
    #   stylehouse uses lv.y.toLines = G&toLines
    #   acquires y&toLines = s
    #   or y&L = A:o that did the toLines, which everyone trusts
    #   may be given s&dige by anyone encoding it,
    #   supposedly dige implies toLines
    # assumed to encode as 
    $r = ns&top;
    rs&u = q;
    
    # the r alone
    if (0) {
        $z = G&Cye,r;
        delete zs&z;
        #$did = G&oleak,zs&u,4,20;
        #debugger;
        $s = G&toLines,z;
        n and -jod $s:s %ws:pre
        #return;

    }
    
    $l = G&Serialise,r;
    n serialout $s:l %ws:pre,hue:50deg,fs:43%,e
    
    if (save) {
        $Q = G&Cye,[t,'',{of:'W',s:l}];
        1s&questi = Q;
        1s&obj = 
        G&ting,Q;
    }
    
    n laluce -jod $s:1s&questi,dl:4 %
    n obj -jod $s:1s&obj %
    
    # 
pi/visit: | # work up diff
    G&heading;
    c&dolater and return G&n,['dolater',1,{s:'dolater'}];
    
    
    #debugger;
    n fi -jod $s:C.c,dl:8.24 %
    
