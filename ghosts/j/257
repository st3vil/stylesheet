Wade: | # serve /W/$t to Revisit
    # defines one place get/set name scheme
    any '/W/*W' => &c{
        my $t = $c->param('W');
        my $s = $c->param('s');
        # read t, write if s
        # all there
        $t = "W/$t";
        # safety
        $t =~ /([^\w\/-]+)/ && return
            $c->render(text=>sjson(
                {er=>"illegal t[".pos()."] char: $1 in '$t'"}
            ));
        # and you can't use the name 1
        my $f = "$t/1";
        
        # returns json:
        my $re = {ok=>1};
        # or ?
        #$c->render(text=>decode_utf8("c&s")); # ,format=>"js"
        
        # if setting
        if (defined $s) {
            if (!length $s) {
                `rm $t/1`;
                re.ok = 'deleted';
            }
            else {
                # the whole name is directory
                -d $t || `mkdir -p $t`;
                my $new = !-f $f;
                $s = "$s\n" if $s !~ /\n$/;
                # we journal! can't trust anything
                write_file("$f\.1",$s);
                `mv $f\.1 $f`;
                # < (notify nearby others, who )+
                re.ok = 'updated';
                re.ok = 'created' if $new;
                $s = '';
            }
        }
        else {
            if (-f $f) {
                $s = read_file($f);
                re.ok = 'found';
            }
            else {
                re.ok = 0;
                re.er = 'not found'
            }
        }
        re.s = $s if length $s;
        $c->render(text=>sjson($re));
    };

Revisit: | # pull/push test data around test run
    G&heading,'Hz:50';
    G&u,['NutIns'];
    G&u,['NutText'];
    G&clusp;
    1s&M ||= [];
    1s&ein.get = &acgts{
        $Q = G&Cye,[s,'',{of:'W'}];
        c&s = 
        G&ting,Q;
    };
    # < -pi matching event handlers, so we can give an object
    1s&ein.set = &acgts{
        $e = c&e;
        $v = G&Cye,[ec&s,'-visit'];
        vc&was = ec&was; # from get^
        vc&j = ec&J; # to picture
        vc&u = ec&u; # mind to attach 9s&u
        1s&M.push(v)
    };
    G&S;
    
    # ag similar Cs
    each in 1s&M {
        i > 0 and break; nc&dolater = 1;
        m $n
    }
    
    n maj 3 s:Mah\njor\nka %dis:block,ws:pre
    
pi/visit: | # work up diff
    G&heading;
    c&dolater and return G&n,['dolater',1,{s:'dolater'}];
    
    $j = c&j;
    $u = c&u;
    
    if (!1s&String) {
        $s = js&s;
        $r = ss&top;
        null != u and rs&u = u;
        
        # +Js
        1s&String = G&Serialise,r;
    }
    
    n fi -jod $s:C.c,dl:6.12 %
    n tac 2 s:tac %hue:200,fs:200%,dos:do/cWrite
    # if different
    n str -jod $s:1s&String %dis:block,ws:pre,fs:40%
    
    if (1c&Write) {
        $Q =
        1s&questi ||=
        G&Cye,[C.t,'',{of:'W',s:1s&String}];
        1s&obj ||= [ G&ting,Q ];
        n right -jod $s:Q,dl:6.12 %
    }
    
    
do/cWrite: |
    $j = c.y.A.1;
    jc&Write ||= 0;
    jc&Write++;

