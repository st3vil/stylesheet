Nonbab: |
    c&s = <<'';
        !(c&Wid && c&Mid) and ~die~noWMC: C
        $W = ww[c&Wid] = {};
        W.id = c&Wid;
        W.t = c&Mid;
        mm[W.t] = W;
        W.A = {};
        W.A.W = W;
        ~newW: W.t, W.id, W
        return W

    my $poing = qr/\w+(?:\.\w+)?/;
    my $nlp = qr/[^\n]+/;
    c&s =~ s{(^|\{|and ) *~(?:(\w+)~)?(\w+(?:$nlp?:)?)(?: ($nlp))?;?$}{
        my $ope = $1;
        my $r = $2 ? 'A,C,G,T,' : '';
        my$c=$2||'c';
        my$s=$3;
        my$e=$4;
        $s=~s/:$//;
        $ope."G\&$c:$r'$s',[$e];"
    }segm;
    
    saygr "Have: c&s";
    exit;


    n Stylewholes
    # Ang contains alacgts?
    my $y = &C{ G&aC };
    saybl "US: ", G&ind:T.op,$y;
    my ($die) = map {_.y.tw.Win}
    T.op.y.tw.i;
    saygr "And: ".wdump 3, die.c.s;
    
    
jsBab: | # < JaBabz in javascript
    # jsbabio
    $parse;
        $m;
        $p = &r{
            m = parse.match(r);
            !m and return
            m.shift();
            parse = parse.replace(r,'');
            return 1
        };
    
    #$ta = G.tiestowe = [];
    # ^ test data:
    $varguessbab = &s{
        # line = 'i '+s
        parse = s;
        $h = {vars:[],arks:[]};
        while (p(/^(\S+)\s*/)) {
            $path = m[0].split('/');
            $outer = parse;
            each in path {
                parse = n;
                $pa = {};
                p(/:(\w*)$/) and pa.ark = m[0] || 1
                p(/^#/) and pa.isvar = 1;
                p(/^\$/) and pa.isvar = 1
                pa.t = parse;
                pa.isvar and h.vars.push(pa.t);
                pa.ark and h.arks.push(pa.ark);
            }
            parse = outer
        }
        each tin h {
            n.match(/\W+/) and throw "wobbyly "+t+" varnameinterpretation: "+n, s;
        }}
        $cod = [];
        h.arks.length == 1 and cod.push('var '+h.arks[0]+' = '); h.arks = [];
        h.arks.length and cod.push('var ar = ')
        cod.push('io.i('+enj(s)+',[');
        h.vars.length and cod.push(h.vars.join(','))
        cod.push(']);');
        h.arks.length and h.arks.map(&s{ cod.push(' var '+s+' = ar.'+s+';') });
        cod = cod.join('');
        #ta.push([s,cod]);
        return cod
    };
jababio: | # for iooia
    my $ta = G.tiestowe = [];
    
    my $exp = <<'';
         - - 'w/*:w'
           - 'var w = io.i("w/*:w",[]);'
         - - 'trouble/w:r/#w:t'
           - 'var ar = io.i("trouble/w:r/#w:t",[w]); var r = ar.r; var t = ar.t;'
         - - $t
           - 'io.i("$t",[t]);'
         - - $w/*
           - 'io.o("$w/*",[w]);'
    
    # can be done here?
    #i $d/@whur/@lamb { s&fat && "laughter" }:whur { fai(C,s); s&ok = 1; s&depth * 3 } o $lambs/*
    
    
    my $brackin;
    $brackin = qr/\{[^\}\{]*$brackin?[^\}\{]*\}/;
    my $varguessbab = Rw JaBabz $ta;
    # runner
    my $ca = &t,talk,cetia{
        my $fromo = $1 if $talk =~ s/ o (.+)$//;
        
        $varguessbab->($t,$talk);
        $varguessbab->('o',$fromo) if $fromo;
    };
    $ca->('i','w/*:w');
    $ca->('i','trouble/w:r/#w:t','weeee');
    $ca->('i','$t o $w/*','tea weas');
    
    my $ex = Load($exp);
    my $i = 1;
    while (@$ta || @$ex) {
        my $t = Dump(shift @$ta);
        my $e = Dump(shift @$ex);
        if ($t eq $e) {
            saygr "ok $i";
        }
        else {
            sayre "not ok $i - Expected:";
            saybl $e;
            sayre "Got:";
            saygr $t;
        }
        $i++;
    }
    @$ta || @$ex && sayre "Extra data: ".Dump({got=>$ta,exp=>$ex});
    
JaBabz: | # make hutscript javascript
    my $poing = qr/\w+(?:\.\w+)?/;
    my $nlp = qr/[^\n]+/;
    my $nls = qr/[ \t]*(?! *\/\/)/;
    # < enj() should do this
    my $jstring = &s{
        $s = sjson([$s]);
        $s =~ s/^\[//;
        $s =~ s/\]$//;
        $s
    };
    my $hide = {};
    
    # blockquote til /^\s*$/g
    # multi line, always \n$
    # supposed to not babz anything in it...
    # < stylehouse (the editor) must know this too
    #     or it'll expand tabs to 4 spaces
    c&s =~ s{^(\s*)($nlp)<<(''|"")($nlp?)\n((?:$nlp\n)+)[ \t]*\n}{
        my $babin = $3 eq '""';
        my $ind = $1 || '';
        my $line = $1.$2."BlockQuote$4\n";
        my $was = $5;
        $was =~ s/^$ind//sgm;
        if ($babin) {
            my $C = {c=>{s=>$was}};
            Rw JaBabz $C;
            $was = c&s;
        }
        my $lines = [split /\n/, $was];
        $lines->[-1] eq '' && pop @$lines;
        # not always?
        #die "not nl last: aft $line: $lines->[-1] ".wdump 3,[$was,$lines];
        $lines = join "+\n", map {
            # HACK, tabs expanded by editor
            s/ {8,}/\t\t\t/g;
            $ind.$jstring->("$_\n")
        } @$lines;
        $lines = $ind."var BlockQuote =\n$lines;";
        my $dig = dig($lines);
        $hide->{$dig} = $lines;
        "HIDING:$dig\n$line";
    }smeg;
    
    #$o = G&readLines,<<'';

    
    # # comment to // comment
    c&s =~ s/^(\s*)#/$1\/\//gsm;
    c&s =~ s/( \{|}|;) #/$1 \/\//gsm;
    # =pod (.+) =cut comment
    c&s =~ s/^(\s*)=\w+(.+)^\s*=\w+\s*$/
        join "\n",map{"$1\/\/ $_"} split"\n",$2;
        /gesm;
    
    # capital A is the more empiricle
    c&s =~ s/\bA&(\w+)\b/A\.c\.$1/g;
    c&s =~ s/\ba&(\w+)\b/A\.sc\.$1/g;
    # and for somea&goof -> A.some.sc.goof
    c&s =~ s/\b(\w+)A&(\w+)\b/A\.$1\.c\.$2/g;
    c&s =~ s/\b(\w+)a&(\w+)\b/A\.$1\.sc\.$2/g;
    
    # @Thing -> 1s&Thing
    0 &&
    c&s =~ s/(?<!\w)\@(\w+)\b/1s\&$1/g;
    
    
    # 3s&do -> A.3.sc.do
    c&s =~ s/\b(\d)(s|c)&(\w+)\b/"A[$1].".($2 eq 's' ? 'sc' : 'c').".$3"/smeg;
    # make upA&thing -> A.up.c.thing
    c&s =~ s/\b(\w+)(a|A)&(\w+)\b/"A.$1.".($2 eq 'a' ? 'sc' : 'c').".$3"/smeg;
    # A.1 -> A[1]
    c&s =~ s/\b([a-z]+)\.(\d)\b/$1.'['.$2.']'/gie;
    
    # vs&do -> v.sc.do, etc
    # < doing the above three paragraphs in this one:
    # < upCs&pi...
    c&s =~ s[\b(\w+)(s|c)&(\w+)\b][
        my $arm = ($2 eq 's' ? 'sc' : $2).".$3";
        my $on = $1;
        my $wa = $on;
        my $s = 'A';
        if ($on =~ /^(up)+$/) { # ups&do -> A.up.sc.do
            # the other A aliases use upa&do
            $s .= '.up' while $on =~ s/^up//;
        }
        elsif ($on =~ /^\w\w+$/) { # oms&do -> om.sc.do
            # used to hang off A
            $s = $on;
        }
        else { # zs&do -> z.sc.do
            $s = $on;
        }
        $s.'.'.$arm
    ]smeg;
    
    # capital C is the more universal (prefer s&do)
    c&s =~ s/\bs&(\w+)\b/C\.sc\.$1/g;
    c&s =~ s/\bC&(\w+)\b/C\.sc\.$1/g;
    c&s =~ s/\bc&(\w+)\b/C\.c\.$1/g;
    
    # 
    #c io
    # recursive regex, but:
    #   imbalanced brackets cause an infinite loop
    # < something off the net
    #   perldoc perlre "(??{ code })" onwards?
    my $brackin;
    $brackin = qr/\{[^\}\{]*$brackin?[^\}\{]*\}/;
    my $varguessbab = &t,s,varcod,nocall{
        my $talk = $s;
        # talk is all the i is without the i
        my $cod = [];
        my $h = {path=>[],vars=>[],arks=>[]};
        my $defunc;$defunc = &{
            $s =~ s/^\s+//s;
            if ($s =~ s/^((\w+:)*)\{/\{/s) {
                my $arkfor = $1; # not in $whole, can forget
                h.bail = "not even" unless $s =~ /^$brackin/;
                $s =~ s/^($brackin)(:(\S+)|) ?//;
                my $whole = $1;
                my $withname = $2;
                my $name = $3;
                my $code = $whole;
                $code =~ s/\s+$//;
                $code =~ s/^\{|\}$//g;
                if ($code =~ /^(\w+)(?::(.+))?$/) {
                    my $prerolled_function = $1;
                    # which will peel/parse
                    my $subtalk = $2;
                    # < turn "la $inter " into "la ".$inter." "
                    # < sjson string
                    push @{h.vars}, '"'.$subtalk.'"';
                    my $now = "{$prerolled_function}";
                    $talk =~ s/\Q$whole\E/$now/;
                    # continue
                    return $defunc->();
                }
                $code = [split ";", $code];
                # return last expression
                if ($code->[-1] !~ /return/) {
                    my $expr = pop @$code;
                    $expr =~ s/^\s+//;
                    push @$code, " return $expr"
                }
                $code = join ";", @$code;
                $code = "&acgts"."{ $code }";
                push @{h.vars}, $code;
                # its var is a function, its talk is anything else about it
                my $now = "{}";
                if ($name) {
                    $now .= ":$name";
                    push @{h.arks}, $name;
                }
                $talk =~ s/\Q$whole$withname\E/$now/s
                    || push @$cod, "no replacing: $whole";
                #push @$cod, "Would $name: $code\n"
                #    ."  onward: ".slim(20,$s)."\n";
                
                # and again
                $defunc->();
            }
        };
        my $after_first_pathy_thing;
        # since that redefines columns
        # assume @things, #things, $things, anything:things are for var/ar unpack
        $defunc->();
        my $firstpath = h.path;
        while ($s =~ s/^(\S+)\s*//) {
            my $island = $1;
            $firstpath = [@{h.path}] if $island =~ /^[io]$/;
            my $path = [split '/', $island];
            for (@$path) {
                my $pa = {};
                # waving (and so we dont see :y)
                #   and this avoids latic:yon/... in paths...
                pa.arkfor = $1 if @$path == 1 && s/^((\w+:)+)y(\w|$)/y$3/;
                # returning
                pa.ark = $1 || 1 if s/:(\w*)$//;
                # greffing
                if (s/\{(\S+)\}?$//) {
                    pa.gref = $1;
                    while (pa.gref =~ /\$(\w[\w\[\]\.]*)/g) {
                        push @{pa.grefpara ||= []},$1;
                        push @{h.vars}, $1;
                    }
                    s/^/*/ if /^$/; # implies globbing
                }
                
                # parameters in
                pa.isdelete = 1 if s/^-|-$//;
                pa.issark = 1 if s/^@//;
                pa.isvar = 1 if s/^#//;
                pa.isvar = 2 if s/^\$//; 
                pa.issark && pa.isvar < 2 && delete pa.isvar;
                pa.t = $_;
                my $varnamung;
                # the notion of C always split/linking domain names etc
                if (pa.t =~ /^\w+[\[\.]\w/) {
                    # A[1].sc.cee named $cee
                    # < could be pointing to anything
                    #   into datatype (date/time/style?) aspects
                    #   to/through/with functions
                    #   at such rhythms, intro such dimension
                    $varnamung = pa.t;
                    my $name = $1 if pa.t =~ /^\w[\w\[\]\.]+?(\w+)$/;
                    !$name && die "Cant de-qualify name: pa.t    in $talk";
                    #1 && saybl "AHvo: $name ". substr($name,0,1) . " OPR " . substr($name,1,0);
                    $name = "\$$name" unless
                        substr($name,0,1) eq "\$";
                    $talk =~ s/\$?\Q$varnamung\E/$name/sg
                        || die "Cant find pa.t    in $talk";
                    pa.t = $name;
                    pa.isvar = 1;
                }
                pa.isvar && push @{h.vars}, $varnamung || pa.t;
                pa.glob = 1 if pa.t =~ /^\*/;
                pa.word = 1 unless pa.isvar || pa.issark || pa.glob;
                
                
                # not barewords or spacers :unless
                # but anything @plumbed
                pa.ark = pa.t if pa.ark eq '1';
                !$after_first_pathy_thing
                    && (pa.ark || pa.issark) &&
                        push @{h.arks}, pa.ark || pa.t;
                push @{h.path}, $pa;
            }
            $after_first_pathy_thing = 1 if @$path > 1;
            $defunc->();
        }
        #c iocall
        return "Bailed: h.bail" if h.bail;
        each tin $h {
            $n =~ /\W+/ && die "wobbyly $t varnameinterpretation: $n", $s;
        }}
        @{h.arks} = uniq @{h.arks};
        if (!@{h.arks}) { # see io.realise
            # accept pa.t as a possible name
            for my $pa (@{h.path}) {
                next if !pa.t;
                next if pa.t =~ /\W/;
                push @{h.arks}, pa.t
            }
            # possibly just s
            @{h.arks} = 's' if !@{h.arks};
        }
        my $la = $firstpath->[-1];
        # the test: i $d/@la/@dio la:{} ... puts s as the {}
            #my $vork = '$d/@la/@dio';
            #$talk =~ m{\Q$vork\E}
            #    && saybl "Found it: ".wdump 5,[$h,$la];
        # maybe we should call it r if .../made:s {}
        # probably about right.. unplumbed {}$ could mean grep that stuff?
        #   except for row generation, which is how anyway?
        # < knowing better, realise() won't spit out doofs as s
        if ((la.glob || la.word) && !la.ark && !la.issark && !grep {$_ eq 's'} @{h.arks}) {
            @{h.arks} = grep { $_ ne la.t } @{h.arks}; # remove word as nonark
            push @{h.arks}, 's';
        }
        
        # S does var setting, or each io can set ay
        #   but not each ay.sc.$arks
        my $sets = 'ay';
        
        push @$cod, "var $sets = " unless $nocall;
        nocall.sets = $sets if $nocall;
        
        # put i/o in talk
        $talk = "$t $talk" if $nocall;
        # quote talk
        (my $vus = sjson([$talk])) =~ s/^\[|\]$//g;
        # call io (or dont)
        my $call = $nocall ? "" : "io\.$t(";
        push @$cod, "$call$vus,[";
        # bind params
        push @$cod, join ',', @{h.vars} if @{h.vars};
        
        push @$cod, ']'.($nocall ? "" : ");");
        $varcod ||= $cod;
        push @$varcod, ' var '.$_.' = '.$sets.'.sc.'.$_.';' for uniq @{h.arks};
        $cod = join '', @$cod;
        ar.ta and push @{ar.ta}, [$talk,$cod];
        return $cod
    };
    return $varguessbab if ar.ta;
    c&s =~ s{(^\s*|return )(i|o) ([\w\@\{\$\#]+[^\n]*[^\n;]+)$}{
        # unless testing, i/o doesn't set variables, only as S i/o
        my $varcod = ar.testing_io_vars ? undef : [];
        "$1".$varguessbab->($2,$3,$varcod) }smeg;
     
        
    #c each
            # each etc $data {    into:
            # while (my ($e,$tv) = each %$data) {
            # while (my ($t,$c) = each %$tv) {
            #   so the value tv is for t-ing into
            # DIY closing brackets
            # avoids eaching nonref after first
            # could replace with G&chew-ish call if more spec
            # and know indents to close
            my $doi = sub {
                my ($ind,$in,$from) = @_;
                my @in = split ',', $in;
                @in = split '', $in[0] if @in == 1;
                my @open;
                while (@in) {
                    my $k = shift(@in);
                    my $v = shift(@in);
                    unshift @in, $v if @in;
                    $v = $v.'v' if @in;
                    
                    my $s = "for (var $k in $from) {";
                    $s .= "\n    var $v = $from\[$k];";
                    $s .= "\n    if(typeof $v != 'object') { continue }"
                        if @in;
                    
                    $from = $v;
                    push @open, $s;
                }
                @open = map { $ind.$_ } @open;
                join "\n", @open;
            };
            c&s =~ s/^(\s*)each (\w+(,\w+)*) (\S+) \{(\s*)$/
                $doi->($1,$2,$4);
            /smeg;

    
    #
    #c other
    # (~hifnotc)?~com message: list, of, interestings
    # < colouring or otherwise classifying by the source of the way
    #   eg everything from 4* looks kind of blue, etc
    #   more colour will jump in on top as aspects unfold, yadda
    
    my $lnlp = qr/[^\n;]+/;
    c&s =~ s{(; |^|\{|and |return ) *~(?:(\w+)~)?(\$?>?[\w]+(?:$lnlp?:)?)(?: ($lnlp)?)?(;|$)}{
        my $ope = $1;
        my$c=$2||'c';
        my$s=$3;
        my$e=$4;
        $s=~s/:$//;
        $s = "'$s'" unless $s =~ s/^\$//;
        $ope."G\&$c:$s,[$e];"
    }segm;
    
    # chuck error: throw "Something", C 
    #   throws new Error("Something"), its .tc=[C]
    #     also handles concatenated bits for "Something":
    my $varbits = qr/[\w\[\]\.]+/;
    my $concatbit = qr/\+(?:[\w\[\]\.]+|"[^\n"]+")/;
    c&s =~ s{(^\s*(?!#)$nlp?)throw ("[^\n"]+?"$concatbit*)(, ?$nlp)?;?\s*$}{
        my $ope = $1;
        my $msg = $2;
        my $tc = $3;
        $msg =~ s/: ?"$/"/;
        my $guts = "new Error($msg)";
        if ($tc =~ s/^, ?//) {
            $tc =~ s/;$//;
            $guts = "{var er = $guts; er\.tc = [$tc]; throw er}";
            # "
        }
        else {
            $guts = "throw $guts;";
        }
        $ope.$guts
    }segm;
    
    # rechuck error: throw e, "inn"
    #   pushes e.catches e.stack to e.stacks[],
    #     chrome < 2012 restacks when rethrowing
    #   
    c&s =~ s{(^\s*(?!#)$nlp?)throw ($varbits)(, ?$nlp)?;?\s*$}{
        my $ope = $1;
        my $var = $2;
        my $tc = $3;
        my $guts = "($var\.catches = $var\.catches || [])";
        $tc = $tc =~ s/^, ?// ? ",tc:[$tc]" : "";
        $guts .= ".push({stack:$var\.stack$tc}); throw $var;"; # "
        $ope.$guts
    }smeg;
    
    #c n groundula
    
    # n thing -jod_33 s:var hue:'490deg'
    #   c/sc get wrapped with {}
    # or:
    # n thing -jod_33 s:string %hue:490deg,note:$note+btw
    #   and c/sc become G&peel bits, $note+ becomes "+note+"
    #   and c $s:object,$up:ob will make json (wrapped with {})
    #   greediness of c/sc regarding % needs tuning
    #     be nice to have spaces in c, editor could easily step over all this
    # < C like this, but fits after { or =
    # < n:r yabbada to $r = G&n,['yabbada','W']
    #   viz. this Babz decides when [t] means cW:t
    #   and sets a variable to the C created
    # also u:thing so that $thing becomes that object in the mind
    my $blankycsc = '"",{},{}';
    c&s =~ s{(^\s*|return )(n|u|m|e) (\$)?("[^\n"]+"|\w+\S*)(?: (\$)?([-\w]*))?(?: ([^\n]*?))?(?: (%)?([^\n]*?))?$}{
        my $ope = $1;
        my $mode = $2;
        my $tvar = $3;
        my $t = $4;
        my $yvar = $5;
        my $y = $6;
        my $c = $7;
        my $scvar = $8;
        my $sc = $9;
        $t = '"'.$t.'"' if !$tvar;
        $y = '"'.$y.'"' if !$yvar;
        $scvar ||= 1;
        if ($scvar) {
            for ($c, $sc) {
                !$_ and s/^/{}/ && next;
                if ($_ eq $c && /^\$\w+:\w+/) {
                    s/\$(\w+):(\w+)( )?/"$1:$2".(defined $3 ? ",":"")/seg;
                    s/^/{/sg;
                    s/$/}/sg;
                    next;
                }
                s/\$([^\s\+]+)(\+|$)/"+$1+"/sg;
                s/^|$/"/sg;
                s/^(.*)$/"G\&"."peel,".$1." ";/smeg
            }
        }
        else {
            $c = "{$c}";
            $sc = "{$sc}";
        }
        my $guts = "G&".$mode.":";
        $guts .= "M," if $mode eq 'm';
        my $arg = "[$t,$y,$c";
        $arg .= ",$sc" if $sc;
        $arg .= "]";
        $arg = "$t" if
            $arg =~ s/,\Q$blankycsc\E]$/]/ && $tvar;
        $guts .= $arg;
        $ope.$guts.';'
    }smeg;
    #return
    
    c&s =~ s/^(\s*)elsif ?\(/${1}else if (/sgm;
    
    # true or assign
    # < match until closing bracket, see $brackin
    c&s =~ s/(\w\S*) \|\|\=(?: ($nlp)(;)?|\s*)$/$1 = $1 || $2$3/gm;
    
    # left-hand if
    c&s =~ s/^($nls)([^\n]+?) and ($nlp)(;)?$/$1if ($2) {
    $1    $3
    $1}/gm for 1..3;
    
    # tiny sub maker, &raw,args{
    # TODO any >1 noncomma args split
    c&s =~ s/([^G&]|^)&acgts\{/$1function(A,C,G,T,s){/gm;
    c&s =~ s/([^G&]|^)&acgt\{/$1function(A,C,G,T){/gm;
    c&s =~ s/([^G&]|^)&(\w*(,\w+)*)\{/$1function($2){/gm;
    
    # $thing -> var thing
    #  doesn't see '$get # vardescript', see # -> //
    c&s =~ s/^($nls)\$(\w+)(;|\s*=|\s*\/\/|$)/
        $1."var $2".($3||';')/smeg;
    
    # GONER thing$ -> var thing (would perl alright tho...)
    # still in Hut
    c&s =~ s/^($nls)(\w+)\$(?:;)?\s*(=|$)/
        $1."var $2".($3 eq '=' ? ' =' : ';')/smeg;
    
    
    #c S domagic
    # see 25 Domes
    my $wsnotnl = qr/[ \t]/;
    my $anS = qr/^$wsnotnl*S($wsnotnl*| \w[^\n]*)$/m;
    my $GandS = "G"."&"."S";
    if (c&s =~ $anS) {
        my @l = split /\n/, c&s;
        my $firstS = 1;
        @l = map {
            if (/$anS/) {
                my $args = $1;
                $args =~ s/^\s+|\s+$//g;
                # G&S,s/num,t/nam,talk/json(d),params
                my $num = $1 if $args =~ s/^(\d+(?:\.\d+)?)\s*//;
                my $nam; # maybe 'S 3 (title): i/o ....
                # so then: } var sets; while(sets = G&S:3,'title','i/o ...',[params]) { var one = sets.sc.one; ...
                my $sets; # name of G&S return value ^
                my $talkpara; # 'i/o ...',[params]
                my $setting = []; # the (var one = sets.sc.one;)+
                # talk,params pass through S, which iterates and sets vars inside
                $args =~ s{^(?:(.*?):? )?(i|o) ([\w\@\{\$\#]+[^\n]*[^\n;]+)$}{
                    $nam = $1 if $1;
                    my $nocall = {};
                    $talkpara = $varguessbab->($2,$3,$setting,$nocall);
                    $sets = nocall.sets;
                    ''
                }smeg;
                
                # io-light, assume one eg $N may be returned from the call
                # < projected to expand... unless io is the place that also sees
                #   up the A train to where N and M etc live.
                #   coming from or going to Osc
                if ($args) {
                    # title contains '$N' to while (N = ...)
                    # title loses '$'
                    if ($args =~ s/\$([^\s\+]+)(\+|$)/$1/sg) {
                        $1 && $sets && die "have dollarey $1 in args, also io return sets $sets";
                        $sets = $1;
                    }
                }
                $nam && $args && die "io set nam='$nam', also args: $args";
                $nam = $args if $args;
                $nam = $jstring->($nam) if $nam;
                $num ||= "''" unless $num eq '0';
                $nam ||= "''";
                $args = join',',grep{length}$num,$nam,$talkpara;
                
                my $call = join':',grep{length}$GandS,$args;
                # conjoins while blocks
                my $con = $firstS ? "" : "} ";
                $firstS = 0;
                if ($sets) {
                    $con .= "var $sets; ";
                    $call = "$sets = $call";
                }
                $con .= "while (".$call.") {";
                if (@$setting) {
                    
                    #$setting = join ';', @$setting;
                    #$setting =~ s/;;/;/sg;
                    $con .=  join '',@$setting;
                }
                $con
            }
            else {
                $_
            }
        } @l;
        push @l, '}';
        c&s = join "\n",@l;
    }
    # G&thing:args,"with space";     $e v
    c&s =~ s/($poing)\&(\$)?($poing)(?::([^\n;]+))(|\) ?\{ var.+$|\s*$|\s*$|;)/
        my ($on,$var,$p,$e,$t) = ($1,$2,$3,$4,$5);
        $t = "$1$t" if $e =~ s{(\) ?\{(?: var.+|))$}{};
        $e = ",$e" if length $e;
        ($on,my$in) = ("G\.h",'A,C,G,T,')
            if $on eq 'G';
        $p = "\"$p\"" unless $var;
        my $s = $on."($in$p$e)$t";
        $s = '$'.$s if $on !~ m{\.};
        $s
    /smge;
    
    # G&thing,args && without space
    c&s =~ s/($poing)\&(\$)?($poing)(,[^\s;]+)?(;)?/
        my $t = $2 ? "$3" : "'$3'";
        my $h = $1 eq 'G' ? ".h(A,C,G,T,$t" : "\[$t\](A,C,G,T";
        $1.$h."$4)$5"
    /smge;
    
    # unhide blockquotation
    %$hide && c&s =~ s/HIDING:([0-9a-f]+)/$hide->{$1} || die "Cant find $1"/seg;
    
jst: | # test js babbler
    c&s = <<'';
        !G&Time,'rasunify',700,s and return
        G&something
        $.each(h,&k,v{ delete h.k });
        ~leaves
        G&nothing,is,over
        c&see = c&know;
        C&tell = C&B;
        var s = &c{ that.it.is };
        ~rasunify: re.length
        ~dothis~fourly: f
            C&attr.title ||= C.t+' '+C.y.cv;
            
        S
        G&wide:"several ticks";
        G&$some:4,56-3, (28 / A.5.sc.e)
        5s&log = [];
        tys$ = &acto{
            vase and G&bump
            $nev
        };
        thy$
        knuckles$;
        ~$knuckles: fav, ours
        //etc
        S fouring
        # etc
        Ys&nope = 1;
        loa&ayer = 3;
        alos&vara = 3;
            # anyway, check form and name the wave of u
        # this and that
                !C[D.sc.nk][D.sc.gk] and continue;
        !D and s == 'js' and return G&t_js,c,t
        each tvJ 1s&Jtv||{} {
            JN[J] = N;
        }}
        ~>3 Jin: sum, '>:ms'
        throw "Figures"
        2 == 1 and throw "Miles", Y, "Or so"
        throw "Because: ", figures, are, massive
        throw "async "+per+": "+A.1.t
        throw "Give pi: ",C;
        throw bah, "Inn"
            er.message != "Too much to yaml" and throw er
        n thing -jod_33 $s:var hue:490deg
        n thing  s:string %hue:490deg,note:$note+btw
        u Matter
        $spacey = " 2  2 88  333333338 76   5 5  7 6";
        n Instead 2 s:$spacey %hue:49deg,ws:pre
        n Instead 2 $s:object,ano:'thng',$va:ery,er:li %hue:$lat+deg,ws:pre
        m = d.match(r);
        S 3 Vaticules
        n $p
        G&e:l
        $get; # gottening
        1 and return n waits
        !j and return n waits 1 s:waits %
        c&dow and c&did = 'w'; ~dow: ; return G&waylay,c&dow,har
        if (e.t.match(/^C/)) { # show/hide
        $v;
        $v
        $te = vol;
        te ||= vol;
        S 4
        $ve =
        1s&Casa ||=
        n scA -jod_3 $s:Y,dl:2
        # etc
        S
        if (k == 'rc&M') { # changes everywhere?
        S as last $N
            d.dup and d.dup(x) and return
        i latiurau/$d
        o latic:yon/$d/*:mil/#lala:gl
        =pod

        wanga

        =cut
        # #c more
        i $d/@whur/@lamb { s&fat && "laughter" }:whur y { fai(C,s); s&ok = 1; s&depth * 3 } o $lambs/*
        i $d/@whur {dehydrate:5}:whur ye,C- {notch} y o $lambs/*
        o $lambs/*
        S lambs: o $lambs/**
            C.t.match(/am/) and ss&fat = 1;
        S
        i $d/@la/@dio la:{s&i++;1} dio:y o $ohp/*:la/#loc/da/*:dio
        o { Object.keys(C.sc).length } $d/*/*
        (pa.arkfor ||= []).push(m[0])
        i $o/@class/@#doop va:{ va(C) }:class o $1s&cee/*:va/*:doop
        o va:{ lattices }:klass $cee/*:va/*:doop
        o w/*
        S limpiuty: i $s/$o
          injecto $o from midtones of $s
        S o yo $s/*:tak
          m figurative 2 $Blazm:tak
        S 0
        i $o/ling/@#$ting
        i $o/-flange
        i $o/abit{3/{>1/{c&of/*{s&of=$i
        i $1s&ooo/abit{3/{>$1s&step/{c&of:dangle/*{s&of=$i:leap
        elsif (blab) {
        $o = G&readLines,<<'';
        yruva        
          glangic            boogie:3
            tibe     s&certainty
            ttt            eel:33
        G&op;
        G&Enticing,Babils and throw
        1
        
        etc
            $o = G&readLines,<<"";
              sense s&certainty
        
        # 20th century
        o va:{ seen.push(C); vat(C) }:klass 1s&cee/*:va/*:doop
        i $o/not/stylehouse
        o $o/glangic/-$tiby
    
    # too far away:
    
    # inf/pint/lod
    #    inf 1&Jtv.$si.$fo # like T ... but for up/download
    
    #    c&$gk && do();
    # Jtv could be a t of:J, f of it is implied in z W
    #  branch broquor
    
    # n something 15 s:Shovel Ch %fs:170%,hs:345,dos:do/Launch
    #    @Launch ||=
    #    e Launch
    #c answers

    my $good = <<'';
        if (!G.h(A,C,G,T,'Time','rasunify',700,s)) {
            return
        }
        G.h(A,C,G,T,'something')
        $.each(h,function(k,v){ delete h.k });
        G.h(A,C,G,T,"c",'leaves',[]);
        G.h(A,C,G,T,'nothing',is,over)
        C.c.see = C.c.know;
        C.sc.tell = C.sc.B;
        var s = function(c){ that.it.is };
        G.h(A,C,G,T,"c",'rasunify',[re.length]);
        G.h(A,C,G,T,"dothis",'fourly',[f]);
            C.sc.attr.title = C.sc.attr.title || C.t+' '+C.y.cv;

        while (G.h(A,C,G,T,"S",'','')) {
        G.h(A,C,G,T,"wide","several ticks");
        G.h(A,C,G,T,some,4,56-3, (28 / A[5].sc.e))
        A[5].sc.log = [];
        var tys = function(acto){
            if (vase) {
                G.h(A,C,G,T,'bump')
            }
            var nev;
        };
        var thy;
        var knuckles;
        G.h(A,C,G,T,"c",knuckles,[fav, ours]);
        //etc
        } while (G.h(A,C,G,T,"S",'',"fouring")) {
        // etc
        Y.sc.nope = 1;
        A.lo.sc.ayer = 3;
        alo.sc.vara = 3;
            // anyway, check form and name the wave of u
        // this and that
                if (!C[D.sc.nk][D.sc.gk]) {
                    continue;
                }
        if (!D) {
            if (s == 'js') {
                return G.h(A,C,G,T,'t_js',c,t)
            }
        }
        for (var t in A[1].sc.Jtv||{}) {
            var vv = A[1].sc.Jtv||{}[t];
            if(typeof vv != 'object') { continue }
        for (var v in vv) {
            var J = vv[v];
            JN[J] = N;
        }}
        G.h(A,C,G,T,"c",'>3 Jin',[sum, '>:ms']);
        throw new Error("Figures");
        if (2 == 1) {
            {var er = new Error("Miles"); er.tc = [Y, "Or so"]; throw er}
        }
        {var er = new Error("Because"); er.tc = [figures, are, massive]; throw er}
        throw new Error("async "+per+": "+A[1].t);
        {var er = new Error("Give pi"); er.tc = [C]; throw er}
        (bah.catches = bah.catches || []).push({stack:bah.stack,tc:["Inn"]}); throw bah;
            if (er.message != "Too much to yaml") {
                (er.catches = er.catches || []).push({stack:er.stack}); throw er;
            }
        G.h(A,C,G,T,"n",["thing","-jod_33",{s:var},G.h(A,C,G,T,'peel',"hue:490deg") ]);
        G.h(A,C,G,T,"n",["thing","",G.h(A,C,G,T,'peel',"s:string") ,G.h(A,C,G,T,'peel',"hue:490deg,note:"+note+"btw") ]);
        G.h(A,C,G,T,"u",["Matter"]);
        var spacey = " 2  2 88  333333338 76   5 5  7 6";
        G.h(A,C,G,T,"n",["Instead","2",G.h(A,C,G,T,'peel',"s:"+spacey+"") ,G.h(A,C,G,T,'peel',"hue:49deg,ws:pre") ]);
        G.h(A,C,G,T,"n",["Instead","2",{s:object,ano:'thng',va:ery,er:li},G.h(A,C,G,T,'peel',"hue:"+lat+"deg,ws:pre") ]);
        m = d.match(r);
        } while (G.h(A,C,G,T,"S",3,"Vaticules")) {
        G.h(A,C,G,T,"n",p);
        G.h(A,C,G,T,"e",l)
        var get; // gottening
        if (1) {
            return G.h(A,C,G,T,"n",["waits"]);
        }
        if (!j) {
            return G.h(A,C,G,T,"n",["waits","1",G.h(A,C,G,T,'peel',"s:waits") ,{}]);
        }
        if (C.c.dow) {
            C.c.did = 'w'; G.h(A,C,G,T,"c",'dow',[]); return G.h(A,C,G,T,'waylay',C.c.dow,har)
        }
        if (e.t.match(/^C/)) { // show/hide
        var v;
        var v;
        var te = vol;
        te = te || vol;
        } while (G.h(A,C,G,T,"S",4,'')) {
        var ve =
        A[1].sc.Casa = A[1].sc.Casa || 
        G.h(A,C,G,T,"n",["scA","-jod_3",{s:Y,dl:2},{}]);
        // etc
        } while (G.h(A,C,G,T,"S",'','')) {
        if (k == 'r.c.M') { // changes everywhere?
        } var N; while (N = G.h(A,C,G,T,"S",'',"as last N")) {
            if (d.dup) {
                if (d.dup(x)) {
                    return
                }
            }
        var ay = io.i("latiurau/$d",[d]); var latiurau = ay.sc.latiurau; var d = ay.sc.d;
        var ay = io.o("latic:yon/$d/*:mil/#lala:gl",[d,lala]); var yon = ay.sc.yon; var mil = ay.sc.mil; var gl = ay.sc.gl;
        // 
        // 
        // wanga
        // #c more
        var ay = io.i("$d/@whur/@lamb {}:whur y {} o $lambs/*",[d,function(A,C,G,T,s){  return C.sc.fat && "laughter"  },function(A,C,G,T,s){  fai(C,s); C.sc.ok = 1; return C.sc.depth * 3  },lambs]); var whur = ay.sc.whur; var lamb = ay.sc.lamb; var s = ay.sc.s;
        var ay = io.i("$d/@whur {dehydrate}:whur ye,C- {notch} y o $lambs/*",[d,"5","",lambs]); var whur = ay.sc.whur; var s = ay.sc.s;
        var ay = io.o("$lambs/*",[lambs]); var lambs = ay.sc.lambs; var s = ay.sc.s;
        } var ay; while (ay = G.h(A,C,G,T,"S",'',"lambs","o $lambs/**",[lambs])) { var lambs = ay.sc.lambs; var s = ay.sc.s;
            if (C.t.match(/am/)) {
                s.sc.fat = 1;
            }
        } while (G.h(A,C,G,T,"S",'','')) {
        var ay = io.i("$d/@la/@dio la:{} dio:y o $ohp/*:la/#loc/da/*:dio",[d,function(A,C,G,T,s){ C.sc.i++; return 1 },ohp,loc]); var la = ay.sc.la; var dio = ay.sc.dio; var s = ay.sc.s;
        var ay = io.o("{} $d/*/*",[function(A,C,G,T,s){  return Object.keys(C.sc).length  },d]); var d = ay.sc.d; var s = ay.sc.s;
        (pa.arkfor = pa.arkfor || []).push(m[0])
        var ay = io.i("$o/@class/@#doop va:{}:class o $cee/*:va/*:doop",[o,function(A,C,G,T,s){  return va(C)  },A[1].sc.cee]); var class = ay.sc.class; var doop = ay.sc.doop;
        var ay = io.o("va:{}:klass $cee/*:va/*:doop",[function(A,C,G,T,s){  return lattices  },cee]); var klass = ay.sc.klass; var va = ay.sc.va; var doop = ay.sc.doop;
        var ay = io.o("w/*",[]); var w = ay.sc.w; var s = ay.sc.s;
        } var ay; while (ay = G.h(A,C,G,T,"S",'',"limpiuty","i $s/$o",[s,o])) { var s = ay.sc.s; var o = ay.sc.o;
          injecto $o from midtones of $s
        } var ay; while (ay = G.h(A,C,G,T,"S",'','',"o yo $s/*:tak",[s])) { var tak = ay.sc.tak;
          G.h(A,C,G,T,"m",M,["figurative","2",{Blazm:tak},{}]);
        } while (G.h(A,C,G,T,"S",0,'')) {
        var ay = io.i("$o/ling/@#$ting",[o,ting]); var ting = ay.sc.ting;
        var ay = io.i("$o/-flange",[o]); var o = ay.sc.o; var s = ay.sc.s;
        var ay = io.i("$o/abit{3/{>1/{C.c.of/*{C.sc.of=$i",[o,i]); var o = ay.sc.o; var abit = ay.sc.abit; var s = ay.sc.s;
        var ay = io.i("$ooo/abit{3/{>$A[1].sc.step/{C.c.of:dangle/*{C.sc.of=$i:leap",[A[1].sc.ooo,A[1].sc.step,i]); var dangle = ay.sc.dangle; var leap = ay.sc.leap;
        else if (blab) {
        var BlockQuote =
        "yruva\t\t\t\n"+
        "  glangic\t\t\tboogie:3\n"+
        "    tibe     s&certainty\n"+
        "    ttt\t\t\teel:33\n"+
        "G&op;\n"+
        "G&Enticing,Babils and throw\n"+
        "1\n";
        var o = G.h(A,C,G,T,'readLines',BlockQuote);
        etc
            var BlockQuote =
            "  sense C.sc.certainty\n";
            var o = G.h(A,C,G,T,'readLines',BlockQuote);
        // 20th century
        var ay = io.o("va:{}:klass $cee/*:va/*:doop",[function(A,C,G,T,s){  seen.push(C); return vat(C)  },A[1].sc.cee]); var klass = ay.sc.klass; var va = ay.sc.va; var doop = ay.sc.doop;
        var ay = io.i("$o/not/stylehouse",[o]); var o = ay.sc.o; var not = ay.sc.not; var s = ay.sc.s;
        var ay = io.o("$o/glangic/-$tiby",[o,tiby]); var o = ay.sc.o; var glangic = ay.sc.glangic; var tiby = ay.sc.tiby;
        }
        
    
    #c testily
    if (0) {
    c&s = <<'';
        la
        tomi
        S
        comback
        S 1
        throwfo
        
        S 2 ffe $W+ runs
        vatica
        S
    
    c&s = <<'';
        o va:{ seen.push(C); vat(C) }:klass 1s&cee/*:va/*:doop
    $good = "";
    }
    ar.testing_io_vars = 1;
    
    Rw JaBabz;
    
    # 
    c&s eq $good && return saygr "jst good";
    
    saygr "Result: ".length(c&s)." vs ".length($good), c&s;
    
    !length $good and return;
    
    my ($l,$r) = map {[split "\n", $_]} c&s, $good;
    my $miss; # show gaps
    for my $ls (@$l) {
        my $rs = shift @$r;
        $rs = '<undefined>' if !defined $rs;
        if ($ls eq $rs) {
            $miss = '...' if defined $miss;
            next;
        }
        sayre $miss if $miss;
        $miss = '';
        sayre "Line: $ls", "Isnt: $rs";
    }
    sayre "Line!", "Isnt: $_" for @$r;
    #saybl("Was off:\n\n'".c&s."'\n\nvs '$good'")
    #
javascript: | # compile/collect for sc.js
    # place toward A.ii.>$s, linked list of embryo
    my $of = C.t;
    my $ark = G.sc.codeark ||= {};

    # rennovating around town
    # a geodesic self-mover
    # keeps rebuilding in different locations
    
    # this way should export osc hooks and another way...
    for my $C ( e&_cz ) {
        c&s || sayre "C.t C.y.cv has no s: ".ki $C;
        if (!c&code && (s&args || s&acgt || 1)) {
            # may already be compiled
            # shades code through the wall
            # the W listened to needs one osc in G, then all can whole it
            # coded while the W goes through the wall
            my $coded = delete(s&coded) || s&dige;
            my $digs;
            my $scbab;
            unless ($coded) {
                # shade the edges, args, parsables etc.
                
                if (s&acgt && !s&args) {
                    s&args ||= join',','A,C,G,T', grep{$_ ne '1'} s&acgt;
                }
                die "wonky C.t   of ".ki $C if C.t =~ /\W/;
                s&args =~ s/ /,/g;
                delete C.sc.com;
                
                my $pasn = sub {
                    my $v = shift;
                    my ($nk,$gk,$more) = $v =~ /^([tycs])?(\S*)(?: (.+))?$/;
                    $nk = 'sc' if $nk eq 's';
                    $nk ||= 'c';
                    $nk && $gk || die"strv:$v -> $nk,$gk from ".ki $C;
                    ((s&nk||$nk),(s&gk||$gk))
                };
                (s&nk,s&gk) = $pasn->(s&v) if s&v && !s&any;

                Rw JaBabz;

                c&s = "function(".s&args.") {\n".c&s."\n};\n"
                    if s&args;
                
                s&coded = 1;
            }
            
            G&hoh,C.sc,$scbab if $scbab;
            
        }
        s&dige = slm 12, dig c&s if exists c&s && !ref c&s;
    }

    C.sc.hi = 'lo';
    T.nose = 1;
    T.pos = 0;
j: |
    u alact
    n i
    # ^ follows of encoder until:
    alarejs 4222: %of:mo
        s&js = delete s&of;
    
jc: | # see C.c.*
    n j
    n c
js: | # see C.sc.*
    n j
    n s
Stylehut: | # org, not stylehut, see also Styleslops for the html/mount
    # self tube
    n HutKitchen
    
    # dialation
    n HutLounge
    
    # other tubes
    n HutCell
    
    # fresher but dubiously designed
    #n Hand
    n HutNuts
HutCell: | # ways to communicate
    n Stylesocks
    n Stylands
Stylesocks: | # websockets & begin
    u j
    
    # give A websocket
    # s may = ws://... or existing WebSocket to resurrect
    # copying s.fail via lc through resurrections
    sockneck:
        var lc;
        typeof s === 'object' and lc = s; s = s.s;
        s ||= 'ws://'+location.host+'/s';
        a&socks ||= {};
        var socks = a&socks;
        var c = socks[s];
        c && c.readyState == 1 and return c;
        c = new WebSocket(s);
        c.s = s;
        c.fail = 0;
        lc and c.fail = lc.fail;
        s = socks[s] = c;
        s.onmessage = &ev{
            G&m,ev.data;
        };
        s.onopen = &{
            s.fail = 0;
            a&sock = s;
            G&sockalive,s;
        };
        s.onclose = &{
            G&sockdead,s;
            G&sockrecon,s;
        };
        
        return s
    
    # send something, socks want to be an I thing...
    socking:
        var c = a&sock || 5s&sock || G&sockneck;
        c.readyState !== 1 and ~sockdrop: c.s, s
        c.send(JSON.stringify(s));
    
    # shade the screen
    sockdead:
        s !== a&socks[s.s] and return ~sockdeaddupe: s.s
        ~closed: s.s
        $('body').stop().css('-webkit-filter', 'blur(1px) brightness(1.3) contrast(2)');
    
    # unshade the screen
    sockalive:
        s !== a&socks[s.s] and return ~sockalivedupe: s.s
        ~connected: s.s
        $('body').stop().css('-webkit-filter', '');
    
    # try sockneck again every .25 seconds
    # then every 2.5 seconds
    sockrecon:
        var t = 25000;
        s.fail++;
        s.fail < 100 and t = 250
        ~sockrecon: s.fail
        G&yl:t,&{ G&sockneck,s };
    
    #c begin, some unities
    # ww/mm for Stylewhole
    # keyjam for Stylicks
    # putontv for Hand
    # sockneck for Stylesocks
    
    # keon etc should have some general way to get
    #   into A contexts from the onclick="something.global()"
    begin:
        5s&ww = {};
        5s&mm = {};
        if (location.search.match('^\\\?v='))
            G&yl:6420,&{ G&putontv,location.search };
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&cl,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&ke,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        G&sockneck;
        
        G.clon(); G.keon();
    
HutKitchen: | # org systemic huttology
    n Stylephone
    n Stylicks
    n Stylesea
    n Stylating
    
    # dubiously designed
    n Stylewholes
Stylephone: | # to being there, basics
    # to begin, hang up your desires
    u j
    
    # timed callback, delay in ms?
    yl: %acgt:delay func
        setTimeout(func, delay);
    
    # eval
    e: %acgt:e
        var m = 
        eval(e);
        return m
    
    # throw error wrapped in A clues
    er: %acgt:e er
        console.log("xutbang: ", e, er);
        return;
        var ej = {er: {e: e}};
        er && er.message and ej.er.m = er.message;
        s.reply(ej); // TODO
        G&m:"!"+ (ej.er.m || e);
    
    # see M, also sand
    m: %acgt:e
        var d = e.substr(0,1);
        d == " " and return eval(e);
        d == "[" || d == "{"  and return G&om,$.parseJSON(e);
        d == "." and e = '<span style="font-size:66%">'+e+'</span>';
        G&c,e;
    
    # #msgs console message
    c: %acgt:s e
        e ||= [];
        var says = [];
        $.each(e,&i,v{
            typeof v === 'string' || typeof v === 'number' and says.push(v);
            else {
                says.push('%'+typeof v);
            }
        });
        A[5].sc.log ||= [];
        var log = A[5].sc.log;
        log.unshift([s,e]);
        G&lim,log,-9;
        says.length and s = s+': '+says.join(' ');
        $('#msgs').prepend(s+"\n");
    
    # used?
    die: %acgt:s etc
        ~dead: s, etc, A, C
        throw([s,etc,A,C]);
    
Stylicks: | # Elvis' tongue
    u j
    # A speak
    E:
        G&cl,s
    
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h
Stylesea: | # the C and data
    u j
    # parse ONE C-like scrap of something, not a Line
    inC:
        C = s;
        if (C.constructor == Array) {
            C = {t:C[0],y:C[1],c:C[2],sc:C[3]};
            typeof C.c  === 'string' and C.c =  G&peel,C.c;
            typeof C.sc === 'string' and C.sc = G&peel,C.sc;
        }
        else
        if (C.constructor == Object &&
            !C.t && !C.y && !C.c && !C.sc) {
            $.each(C, &k,v{ G&$k,v }); T.not = 1;
        }
        else
        typeof C === 'string' and C = {c: {s: C}};
        typeof C.c === 'string' and C.c = {s: C.c};
        typeof C.y === 'string' || typeof C.y === 'number' and C.y = {cv: G&sca,C.y };
        !typeof C.t === 'string' and console.log('queda',C);
        C.c ||= {};
        C.sc ||= {};
        return C;
    
    # datasm:
    
    # scale to fraction < 1
    sca:
        while (s > 1) { s = s / 10 }
        return s;
    
    # limit list, calling callback for each removal
    lim: %acgt:s lim cb
        var len = s.length;
        lim ||= 9;
        var rev;
        lim < 0 and rev = 1; lim *= -1;
        var rem = [];
        while (len > lim) {
            var v;
            rev and v = s.pop()
            else {  v = s.shift() }
            cb and cb(v);
            rem.push(v);
            len--;
        }
        rem.length and return rem
    
    # hash into ke,ys string
    ks:
        var ks = [];
        for (var k in s) {
            ks.push(k);
        }
        return ks.join(',');
    
    # ke:va,ys:lue string into hash
    # < mere,this -> mere === undefined, etc
    #   should be mere=1,this=1  see el.333/s&atr
    peel:
        var c = {};
        !s.length and return c
        $.each(s.split(','), function(i,kv) {
            kv = kv.split(':');
            var k = kv[0];
            var v = kv[1];
            v.match(/^-?\d+\.\d+$/) and v = v * 1
            c[k] = v;
        });
        return c
    
Stylating: | # A ting, h/t/om/throat
    u j
    # A.* falls, A.c/sc dont
    # A.on is the element/thing
    # A.om is a G-level A
    # A.mo is the first A under G-level
    # A.1 should mean the J the A is for... where things reside
    A:
        var V = $.extend({},A);
        V.up = A;
        var A = V;
        s and A.t = s;
        A.y = A;
        A.c = {};
        A.sc = {};
        A.om ||= A;
        A.om == A.up and A.mo = A;
        #A[1] = A;
        
        T.d ||= 1;
        return A
    
    # subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO Gc&B stacking
    # TODO G.i.* = A.I.i.y.tw.*.c.code
    h: %acgt:s so st sh sf si
        $z = s;
        typeof s === 'string' and z = G.t(A,C,G,T,'eye',s);
        typeof s === 'string' && !z and z = G.t(A,C,G,T,'i',s);
        !z and throw "No way: "+s;
        T.D = z;
        return z.c.code(A,C,G,T,so,st,sh,sf,si);
    
    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    t: %acgt:s t
        var z;
        $.each([1,2,3,4,5], &i,v{
            z and return;
            var Y = A[v];
            !Y and return;
            var I = Y.I;
            !I and return;
            z = I[s];
            z && t and z = z.y.tw[t];
        });
        return z;
    
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    
    # toplevel n-tering
    om:
        A$ = G&A,'om';
        s and C = s;
        C$ = G&inC,C;
        C = $.extend({},C);
        C.y = $.extend({},C.y);
        C.c = $.extend({},C.c);
        C.sc = $.extend({},C.sc);
        C.y.A = A;
        t$ = T;
        T$ = {};
        if (t) {
            t.d and T.d = t.d + 1;
        }
        A&T = T;
        G&throat,2,C;
        T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
        s&css ||= {};
        s&anc ||= {};
        G&throat,7;
        # with Nuts' C using Hut still... their events use the om C
        # yet pointers/others see top C, which is as OC,
        # which is origin C, until osc gets more complicated
        # and its yA is the A:n that created it,
        #  but maybe that should be an A:O,
        # if oscillators
        $O = C.y.OC;
        O and O.y.on = A.on
    
    # jog job through embryo A.t
    # up to ov
    throat: %acgt:ov sC
        T.not and return 0;
        ov and A&ov = G&sca,ov;
        sC and A&s = C;
        C = A&s;
        T = A&T;
        t$ = G&t,A.t;
        !t and G&er:"throat no "+A.t, A;
        
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            T.not and break
            var D = z;
            z = z.y.next;
            
            A.c.cv > D.y.cv and continue
            C = A&s;
            if (!D.sc.any) {
                D.sc.nk and !C[D.sc.nk] and continue;
                D.sc.gk and !C[D.sc.nk][D.sc.gk] and continue;
            }
            var es;
            D.sc.gk and es = C[D.sc.nk][D.sc.gk];
            D.sc.s and es = D.sc.s;
            G.h(A,C,G,T,D,es);
            T.not == '2' and return delete T.not;
            A.c.cv = D.y.cv;
        }
        return !T.not;
    
    
Stylewholes: | # Gs clocking on
    u j
        # on last A.b
    nn:
        A.b && A.b.A === A and return A.b
        !A.W and a.c("no aW",[A,C]);
        A.W.b ||= {};
        A.b ||= A.W.b;
        A.b[C.y.cv] ||= {};
        A.b[C.y.cv][C.t] ||= {};
        A.b.t ||= {};
        A.b.t[C.t] ||= {};
        A.b.t[C.t][C.y.cv] ||= A.b[C.y.cv][C.t];
        var b = A.b[C.y.cv][C.t];
        b.A = A;
        A.b = b;
        return b;
    
    Xi:
        !s and s = C.c.W;
        !s and s = C.c.M;
        $W = 5s&ww[s];
        W ||= 5s&mm[s];
        if (!(W && W.W && W.W.on)) {
            ~nottunedin: s
            // create it?
        }
        return W;
        
    Xin:
        $W = 5s&ww[s];
        W ||= G&Win;
        return W;
    
    Win:
        !(c&Wid && c&Mid) and ~die~noWMC: C
        $W = 5s&ww[c&Wid] = {};
        W.id = c&Wid;
        W.t = c&Mid;
        5s&mm[W.t] = W;
        W.A = {};
        W.A.W = W;
        ~newW: W.t, W.id, W
        return W
        
    Wout:
        var W = 5s&ww[A.W.id];
        W.t and 5s&mm[W.t] = W;
        delete 5s&ww[W.id];
        ~leaves W.t, W.id
    
    u jc
    n \'of:om'

    # same remote relay thing (GW)
    # comes with different Mid (G.t)
    Mid 26:
        C.t == 'GW' and C.t = s
        !c&Wid and G&die,"noWID!"
        delete c&s;
    
    # and Wid (G address) creates W
    Wid 27:
        c&id = s;
        c&Mid ||= C.t;
        $W = G&Xin,s;
        c&el == '6' and c&el = '2'; c&scub = 1;
        W.W = A;
        A.on = $('#ux');
        $.extend(A,W.A);
        c&tag ||= 'ww';
        s&ab ||= '100';
        s&poi ||= 'none';
        ~made Wid: s
    
    # either may be G.t or G address here
    M 28:
        $W = G&Xi,s;
        A.on = W.W.on;
        $.extend(A,W.A);
    
    W 28:
        $W = G&Xi,s;
        A.on = W.W.on;
        $.extend(A,W.A);
    
HutLounge: | # org enjoyable huttology
    # om c
    n Stylemoment
    # om sc
    n Stylemomentum
    # om sc/css
    n Stylebridge
    # chewers
    n Stylaplicants
Stylemoment: | # sequencing itself
    u jc
    n \'of:om'
    
    # grab another element
    nobody 31:
        s !== 'body' and s = '#'+s;
        A.on = $(s);
        !$(A.on).length and G&c:"no nobody at "+s;
    
    # eval
    e 32: %nk:sc
        A.4 and return;
        s == '1' and s = c&s;
        eval(s);
        //T.not = 1;
        c&s = 'e';
        s&fs = '30%';
    
    # inside rows, possibly fed out in time
    # < Styletime (A.5 framerates callbacks)
    #   with sub-cv A cursor
    z 6: %nk:sc
        var del = 0;
        $.each(s, &i,v{
            var c = G&inC,v;
            var ub = &{
                G&om,c;
            };
            c.sc.deal and del += 1000 * c.sc.deal; G&yl,del,ub;
            else { ub() }
        });
    
    # set attributes
    # silly - wants to be gone?
    attrib 4: %any
        var f = ['id','src','dig','class'];
        var fl = function (v,z) {
            s&attr and s&attr[v] = z;
            else {
                $(A.on).attr(v,z);
            }
        };
        $.each(f,function(i,v) {
            C.sc[v] and fl(v, C.sc[v])
            else
            C.c[v] and fl(v, C.c[v])
        });
    
    #c element into time...
    # - A.on gets (or so) a child element
    # - lv is C with C.c.el=3 for updates, etc
    #   which implies one thing after another
    #   so we dont have to sort in new C
    # - el=8 just moves the cursor along to that
    #   element stored in ups&choint, to insertAfter
    # initially el=1 amongst children means insertBefore first
    # otherwise appendTo A.on
    el 333:
        s&attr ||= {};
        C.t === 'Ilan' and G&c,'Ilanity',A;
        if (s&atr) {
            var h = G&peel,s&atr;
            $.each(h, &k,v{
                v === undefined and v = C.sc[k];
                s&attr[k] = v;
            });
        }
        
        // make a safe, meaningless tagname
        var t = C.t.replace(/\W/g,'e');
        t = 'n'+t+'n';
        
        // point inserts to after thing before removed thing
        $choint_hole = &el{
            A.W && A.W.W === A and return;
            !$(el).length and return;
            ups&choint = $(el).prev();
            !ups&choint.length and delete ups&choint
        };
        
        // el=2 means C.t is the only C.t
        $fad = 0;
        if (s == '2') {
            $e = $(A.on).find('> [t="'+C.t+'"]');
            choint_hole(e);
            if (c&slow) {
                $d = (c&slow||1)*1000;
                G&yl:d,&{ $(e).remove() };
                fad = 8;
            }
            else {
                $(e).remove();
            }
        }
        s == '2' and s = '1';
        
        var find = '> '+t;
        C.y.cv and find += "[cv='"+C.y.cv+"']";
        var el = $(A.on).find(find);
        
        if (s != '1' && !el.length) {
            tys$ = &C{
                return C.t +' '+ (''+C.y.cv).replace(/^0\./g,'');
            };
            tyleg$ = tys(upc&s)+'/'+tys(A&s);
            nam$ = 'elos'+c&el;
            ~$nam: tyleg
            console.log(nam,tyleg,A.on,C);
            return T.not = 1;
        }
        
        s == '9' && A.om == A and G&Wout;
        
        // get A.b from before
        G&nn;
        s&ellog and A.b.ellog = s&ellog
        A.b.ellog and A.ellog = A.b.ellog
        $ellog = &t,n{
            A.ellog == '9' && (C.y.cv != '0.9' && !s&pi) and return;
            $s = [];
            $.each(n, &i,v{
                typeof v === 'string' and s.push(v); return;
                if (v.constructor === Object) {
                    s.push(v.t+' '+v.y.cv+' el='+v.c.el);
                }
                else {
                       $t = $(v).attr('title');
                    !t and s.push(v); t = 'uh?';
                    s.push(t);
                }
            });
            $ind = '';
            $Y = A;
            while (Y && Y.up && A.W.W !== Y) {
                ind = ind+'  ';
                Y = Y.up;
            }
            console.log(ind+t,s);
        };
        
        if (!fad && el.length && (s == '1' || s == '9')) {
            choint_hole(el);
            $(el).remove();
            $bb = {};
            $.each(A.b, &k,v{
                bb[k] = v;
                delete A.b[k];
            });
            A.b.lastb = bb;
        }
        
        // #c to create
        if (s == '1') {
            s&attr.cv = C.y.cv;
            s&attr.t = C.t;
            c&tag and t = c&tag;
            s&attr.title ||= C.t+' '+C.y.cv;
            // extract bareword attributes
            var con = [];
            $.each(s&attr, &k,v{ 
                v == '!' and con.push(k)
            });
            con.length and con.unshift('');
            con = con.join(' ');
            var div = $("<"+t+con+">", s&attr);
            var at = ups&choint;
            var mode = 'insertAfter';
            if (!at) {
                at = A.on;
                if (0 && $(at).children().length) {
                    at = $(at).children()[0];
                    mode = 'insertBefore';
                }
                else {
                    mode = 'appendTo';
                }
            }
            A.ellog and ellog('1-'+mode,[C,'at',at,A.on]);
            $(div)[mode](at).each(&i,v{ el=v });
        }
        else {
            A.ellog and ellog('entered',[C,'on',A.on]);
        }
        
        
        s !== '9' && !(A.W && A.W.W === A) and ups&choint = el;
        
        s == '8' and return T.not = 1;
        
        delete s&attr;
        
        # sucked into not writing up c&s
        A.b.noinnerText and a&noinnerText = 1;
        a&noinnerText and A.b.noinnerText = 1;
        
        if (A.b.cod) {
            c&cod ||= '3';
        }
        if (A.b.pa) {
            s&pa ||= '3';
        }
        if (typeof c&s === 'string' && !c&cod && !s&pa && !a&noinnerText) {
            var cha = $(el).children();
            c&ht and $(el).html(c&s);
            else
            $(el).text(c&s);
            cha.length and $(el).append(cha);
        }
        A.on = el;
        A.on.A = A;
   
Stylemomentum: | # sequencing for the universal
    u js
    n \'of:om'
    
    # h call
    doo 32:
        G&$s;
        T.not = 1;
    
    cssdel 589:
        var re = s.split(',');
        $.each(re,&i,v{ delete s&css[v] });
    
    # compression of absolute/top/left/rotation/scale
    geo 5:
        s = s.split(' ');
        var aung = s[0].match('^a(\\d+)');
        if (aung) {
            s.shift();
            aung.shift();
            s&ab = aung.shift();
            //absolu
        }
        s = {x:s[0],y:s[1],rad:s[2],scale:s[3]};
        s&css.top = (s.y * 100)+'%';
        s&css.left = (s.x * 100)+'%';
        s&css['transform-origin'] = '0% 0%';
        s.tro and s&css['transform-origin'] = s.tro;
        s.rad and s&css['transform-rotate'] = s.rad+'rad';
        s.scale and s&css['transform-scale'] = s.scale;
    
    ab 51:
        if (s === '100') {
            s&css.width = '100%';
            s&css.height = '100%';
        }
        s&css.position = 'absolute';
    
    # apply attributes
    # < not losing filter: con sat when adjusting bri
    # Stylebridge compiles many sc to css
    css 59:
        if (typeof s === 'string') {
            var re = s.split(';');
            s = {};
            $.each(re, &i,v{
                var kv = v.split(':');
                s[kv[0]] = kv[1];
            });
        }
        $.each(s, &i,v{
            if (v.constructor === Object) {
                var swav = [];
                $.each(v, &ve,ss{
                    var se = ve+'('+ss+')';
                    swav.push(se);
                });
                v = swav.join(' ');
            }
            i === 'filter' and i = '-webkit-filter';
            $(A.on).css(i, v);
        });
    
    anc 59:
        $(A.on).animate(s&anc, (s&ant||900));
    
Stylebridge: | # join Ang's state of styleing
    n Ang=>W=>{}=>'%noii'
    
    # FactorEase Style{cW:of}/*, -s&of
    my ($t) = grep { _.t eq 'Style' } G&op,'cW:of';
    my $S = t.y.in;
    my $N = [$S];
    push @$N, $S while $S = S.y.next;
    delete _s&of for @$N;
    
    Rw Stylebridger $N;
    
Stylebridger: | # Style decompressions for js clients
    # given $N of=Style with s&cssk
    
    # thy expanding s&blr to s&css[filter-blur] = $v
    my $e;
    e.thy->{_s&gk} = _s&cssk for grep {_s&cssk} @$N;
    my @pooling = (
        {k=>transform=>also=>[qw'rotate scale']},
        {k=>filter=>also=>[qw'
            blur saturate brightness hue-rotate
            sepia invert grayscale
        ']},
    );
    for my $g (@pooling) {
        for my $al (@{g.also}) {
            my $lie = g.k.'-'.$al;
            e.roi->{$lie} = [g.k,$al];
        }
    }
    # roi packs s&css[filter-blur]
    #         to: s&css[filter][blur]
    # which css 59 understands as:
    #   for filter: blur(4px) saturate(...

    u js
    n css =>58,<<'',{any=>1,stylex=>$e,of=>'om'}
        s = T.D.sc.stylex;
        $.each(s.thy,&k,v{
            C.sc[k] and s&css[v] = C.sc[k];
        });
        $.each(s.roi,&k,v{
            var o = s&css[k];
            !o and return;
            var ve = v[0];
            var ss = v[1];
            s&css[ve] ||= {};
            s&css[ve][ss] = o;
            delete s&css[k];
        });
Stylaplicants: | # gears, talkyboxes
    u j
    codsav:
        var cm = s;
        var d = {};
        G&entag,d,$(A.on);
        A.b.jus = d.code = cm.getValue();
        d.dig = $(A.on).attr('dig');
        G&socking,d;
    
    cod 4: %of:om,v:ccod
        var cm = A.b.cod;
        .
        if (typeof s === 'string') {
            if (s === '3') {
                !cm and return G&c:'no cod !';
                s = {};
            }
            else {
                s = {mode:'perl'};
                cm = 0;
            }
        }
        .
        var def = {mode:'perl',theme:'midnight',lineWrapping:true};
        var set = $.extend(def, s);
        cm and $.each(set,&k,v{ cm.setOption(k,v) });
        !cm and cm = CodeMirror(A.on, set);
        A.b.cod = cm;
        
        if (c&s) {
            c&s !== A.b.jus and cm.setValue(c&s);
            else { G&c:'vv vv'+C.t; }
        }
        
        cm.refresh();
        G&yl:400,&{ cm.refresh() };
        
        var sav = &{
            G&codsav,cm;
        };
        cm.setOption('extraKeys', {Esc:sav});
        cm.on('focus',function(){G.clof();G.keof();});
        cm.on('blur',function(){G.clon();G.keon();sav();});
    
    #    $('#'+id).css('width','15em','max-height','70%','overflow','scroll');
    #   $('#'+id+' > .CodeMirror');//.css('height','auto');
    
    #c drowdowns
    # get G&point to hijack clicks
    sel 4: %of:om,v:ssel
        s&point_h = 'dropdown';
    # called by G&point with A/C found from 5s&ww/.b... 
    # from the d.p (C path)
    # selected is whichever s&sel looks like c&s
    dropdown: %acgt:d
        sel$ = $('<select/>',{name:C.t});
        hav$ = c&s.replace(/\W/g,'');
        $.each(s&sel.split('-'), &i,v{
            opt$ = $('<option/>');
            $(opt).attr('value',v);
            $(opt).text(v);
            v === hav and $(opt).attr('selected','selected');
            $(sel).append(opt);
        });
        $(A.on).empty();
        $(A.on).append(sel);
        s&point_h = 'dropdown_h';
    
    # changing ^ point handler avoids needing G&doh
    # which would have to find A/C itself etc...
    # but might be needed sometime for an onsomething event
    #   $(sel).attr('onchange','G.doh(this,"dropdown_h")');
    # - also if you:
    #   $(sel).css('pointer-events','none');
    #   it triggers click when opening the selection (?)
    doh: %acgt:el h
        console.log('h toosee: ',h,ev);
    
    # we turn up here with d.s = el.val()
    dropdown_h: %acgt:d
        console.log('in here: ',A,C,d);
        
        if (d.s === '?') {
            inp$ = $('<input>');
            $(A.on).empty();
            $(A.on).append(inp);
            inp.on('focus',&{G.clof();G.keof();});
            inp.on('blur',&{G.clon();G.keon();$(inp).click();});
            $(inp).focus();
            return;
        }
        T.letevent = 1;
        
        
        
    #
Jar: |
    # of roots

