Nonbab: |
    c&s = <<'';
        !(c&Wid && c&Mid) and ~die~noWMC: C
        $W = ww[c&Wid] = {};
        W.id = c&Wid;
        W.t = c&Mid;
        mm[W.t] = W;
        W.A = {};
        W.A.W = W;
        ~newW: W.t, W.id, W
        return W

    my $poing = qr/\w+(?:\.\w+)?/;
    my $nlp = qr/[^\n]+/;
    c&s =~ s{(^|\{|and ) *~(?:(\w+)~)?(\w+(?:$nlp?:)?)(?: ($nlp))?;?$}{
        my $ope = $1;
        my $r = $2 ? 'A,C,G,T,' : '';
        my$c=$2||'c';
        my$s=$3;
        my$e=$4;
        $s=~s/:$//;
        $ope."G\&$c:$r'$s',[$e];"
    }segm;
    
    saygr "Have: c&s";
    exit;


    n Stylewholes
    # Ang contains alacgts?
    my $y = &C{ G&aC };
    saybl "US: ", G&ind:T.op,$y;
    my ($die) = map {_.y.tw.Win}
    T.op.y.tw.i;
    saygr "And: ".wdump 3, die.c.s;
    
    
JaBabz: | # make hutscript javascript
    my $poing = qr/\w+(?:\.\w+)?/;
    my $nlp = qr/[^\n]+/;
    my $nls = qr/[ \t]*/;
    
    
    # capital A is the more empiricle
    c&s =~ s/\bA&(\w+)\b/A\.c\.$1/g;
    c&s =~ s/\ba&(\w+)\b/A\.sc\.$1/g;
    
    # 3s&do -> A.3.sc.do
    c&s =~ s/\b(\d)(s|c)&(\w+)\b/"A[$1].".($2 eq 's' ? 'sc' : 'c').".$3"/smeg;
    # make upA&thing -> A.up.c.thing
    c&s =~ s/\b(\w+)(a|A)&(\w+)\b/"A[$1].".($2 eq 'a' ? 'sc' : 'c').".$3"/smeg;
    
    # vs&do -> v.sc.do, etc
    # < upCs&pi...
    c&s =~ s[\b(\w+)(s|c)&(\w+)\b][
        my $arm = ($2 eq 's' ? 'sc' : $2).".$3";
        my $on = $1;
        my $wa = $on;
        my $s = 'A';
        if ($on =~ /^(up)+$/) { # ups&do -> A.up.sc.do
            $s .= '.up' while $on =~ s/^up//;
        }
        elsif ($on =~ /^\w\w+$/) { # oms&do -> A.om.sc.do
            $s .= '.'.$on;
        }
        else { # zs&do -> z.sc.do
            $s = $on;
        }
        $s.'.'.$arm
    ]smeg;
    
    # capital C is the more universal (prefer s&do)
    c&s =~ s/\bs&(\w+)\b/C\.sc\.$1/g;
    c&s =~ s/\bC&(\w+)\b/C\.sc\.$1/g;
    c&s =~ s/\bc&(\w+)\b/C\.c\.$1/g;
    
    # goner?
    c&s =~ s/^t\&([^\s;]+)(;)?/!G\&t,$1 and return;/gm;
    
    # (~hifnotc)?~com message: list, of, interestings
    c&s =~ s{(^|\{|and |return ) *~(?:(\w+)~)?(\$?\w+(?:$nlp?:)?)(?: ($nlp))?;?$}{
        my $ope = $1;
        my$c=$2||'c';
        my$s=$3;
        my$e=$4;
        $s=~s/:$//;
        $s = "'$s'" unless $s =~ s/^\$//;
        $ope."G\&$c:$s,[$e];"
    }segm;
    
    # G&thing:args,"with space";
    c&s =~ s/($poing)\&(\$)?($poing)(:\S+[^\n;]+)(;)?/
        my ($on,$var,$p,$e,$t) = ($1,$2,$3,$4,$5);
        $e =~ s{^:}{,};
        ($on,my$in) = ("G\.h",'A,C,G,T,')
            if $on eq 'G';
        $p = "\"$p\"" unless $var;
        my $s = $on."($in$p$e)$t";
        $s = '$'.$s if $on !~ m{\.};
        $s
    /smge;
    
    # G&thing,args && without space
    c&s =~ s/($poing)\&(\$)?($poing)(,[^\s;]+)?(;)?/
        my $t = $2 ? "$3" : "'$3'";
        my $h = $1 eq 'G' ? ".h(A,C,G,T,$t" : "\[$t\](A,C,G,T";
        $1.$h."$4)$5"
    /smge;
    
    # true or assign
    c&s =~ s/^($nls)($nlp) \|\|\= ($nlp)(;)?$/$1if (!$2) {
    $1    $2 = $3
    $1}/gm;
    # left-hand if
    c&s =~ s/^($nls)([^\n]+?) and ($nlp)(;)?$/$1if ($2) {
    $1    $3
    $1}/gm for 1..3;
    
    # tiny sub maker, &raw,args{
    c&s =~ s/([^G&])&(\w*(,\w+)*)\{/$1function($2){/gm;
    
    # TODO make it $thing or                                                                                                                                                                                                                                                                                          thing$ -> var thing; perl too
    c&s =~ s/^($nls)\$(\w+)(?:;)?\s*(=|$)/
        $1."var $2".($3 eq '=' ? ' =' : ';')/smeg;
    c&s =~ s/^($nls)(\w+)\$(?:;)?\s*(=|$)/
        $1."var $2".($3 eq '=' ? ' =' : ';')/smeg;
jst: | # test js babbler
    c&s = <<'';
        !G&Time,'rasunify',700,s and return
        G&something
        $.each(h,&k,v{ delete h.k });
        ~leaves
        G&nothing,is,over
        c&see = c&know;
        C&tell = C&B;
        var s = &c{ that.it.is };
        ~rasunify: re.length
        ~dothis~fourly: f
            C&attr.title ||= C.t+' '+C.y.cv;
            
        G&wide:"several ticks";
        G&$some:4,56-3, (28 / A.5.sc.e)
        5s&log = [];
        tys$ = &acto{
            vase and G&bump
            $nev
        };
        thy$
        knuckles$;
        ~$knuckles: fav, ours
        //etc
    #

    Rw JaBabz;
    
    my $good = <<'';
        if (!G.h(A,C,G,T,'Time','rasunify',700,s)) {
            return
        }
        G.h(A,C,G,T,'something')
        $.each(h,function(k,v){ delete h.k });
        G.h(A,C,G,T,"c",'leaves',[]);
        G.h(A,C,G,T,'nothing',is,over)
        C.c.see = C.c.know;
        C.sc.tell = C.sc.B;
        var s = function(c){ that.it.is };
        G.h(A,C,G,T,"c",'rasunify',[re.length]);
        G.h(A,C,G,T,"dothis",'fourly',[f]);
            if (!C.sc.attr.title) {
                C.sc.attr.title = C.t+' '+C.y.cv;
            }
        
        G.h(A,C,G,T,"wide","several ticks");
        G.h(A,C,G,T,some,4,56-3, (28 / A.5.sc.e))
        A[5].sc.log = [];
        var tys = function(acto){
            if (vase) {
                G.h(A,C,G,T,'bump')
            }
            var nev;
        };
        var thy;
        var knuckles;
        G.h(A,C,G,T,"c",knuckles,[fav, ours]);
        //etc
    # 
    c&s eq $good && return saygr "jst good";
    saygr "Result: ".length(c&s)." vs ".length($good), c&s;
    my ($l,$r) = map {[split "\n", $_]} c&s, $good;
    my $miss; # show gaps
    for my $ls (@$l) {
        my $rs = shift @$r;
        $rs = '<undefined>' if !defined $rs;
        if ($ls eq $rs) {
            $miss = '...' if defined $miss;
            next;
        }
        sayre $miss if $miss;
        $miss = '';
        sayre "Line: $ls", "Isnt: $rs";
    }
    sayre "Line!", "Isnt: $_" for @$r;
    #saybl("Was off:\n\n'".c&s."'\n\nvs '$good'")
    #
javascript: | # compile/collect for sc.js
    # place toward A.ii.>$s, linked list of embryo
    my $of = C.t;
    my $ark = G.sc.codeark ||= {};

    # rennovating around town
    # a geodesic self-mover
    # keeps rebuilding in different locations
    
    # this way should export osc hooks and another way...
    for my $C ( e&_cz ) {
        c&s || sayre "C.t C.y.cv has no s: ".ki $C;
        if (!c&code && (s&args || s&acgt || 1)) {
            # may already be compiled
            # shades code through the wall
            # the W listened to needs one osc in G, then all can whole it
            # coded while the W goes through the wall
            my $coded = delete(s&coded) || s&dige;
            my $digs;
            my $scbab;
            unless ($coded) {
                # shade the edges, args, parsables etc.
                
                if (s&acgt && !s&args) {
                    s&args ||= join',','A,C,G,T', grep{$_ ne '1'} s&acgt;
                }
                die "wonky C.t   of ".ki $C if C.t =~ /\W/;
                s&args =~ s/ /,/g;
                delete C.sc.com;
                
                my $pasn = sub {
                    my $v = shift;
                    my ($nk,$gk,$more) = $v =~ /^([tycs])?(\S*)(?: (.+))?$/;
                    $nk = 'sc' if $nk eq 's';
                    $nk ||= 'c';
                    $nk && $gk || die"strv:$v -> $nk,$gk from ".ki $C;
                    ((s&nk||$nk),(s&gk||$gk))
                };
                (s&nk,s&gk) = $pasn->(s&v) if s&v;

                Rw JaBabz;

                c&s = "function(".s&args.") {\n".c&s."\n};\n"
                    if s&args;
                
                s&coded = 1;
            }
            
            G&hoh,C.sc,$scbab if $scbab;
            
        }
        s&dige = slm 12, dig c&s if exists c&s && !ref c&s;
    }

    C.sc.hi = 'lo';
    T.nose = 1;
    T.pos = 0;
j: |
    u alact
    n i
    # ^ follows of encoder until:
    alarejs 4222: %of:mo
        s&js = delete s&of;
    
jc: | # see C.c.*
    n j
    n c
js: | # see C.sc.*
    n j
    n s
Stylehut: | # org, not stylehut, see also Styleslops for the html/mount
    # self tube
    n HutKitchen
    
    # dialation
    n HutLounge
    
    # other tubes
    n HutCell
    
    # fresher but dubiously designed
    #n Hand
    n HutNuts
HutCell: | # ways to communicate
    n Stylesocks
    n Stylands
Stylesocks: | # websockets & begin
    u j
    
    # give A websocket
    # s may = ws://... or existing WebSocket to resurrect
    # copying s.fail via lc through resurrections
    sockneck:
        var lc;
        typeof s === 'object' and lc = s; s = s.s;
        s ||= 'ws://'+location.host+'/s';
        a&socks ||= {};
        var socks = a&socks;
        var c = socks[s];
        c && c.readyState == 1 and return c;
        c = new WebSocket(s);
        c.s = s;
        c.fail = 0;
        lc and c.fail = lc.fail;
        s = socks[s] = c;
        s.onmessage = &ev{
            G&m,ev.data;
        };
        s.onopen = &{
            s.fail = 0;
            a&sock = s;
            G&sockalive,s;
        };
        s.onclose = &{
            G&sockdead,s;
            G&sockrecon,s;
        };
        
        return s
    
    # send something, socks want to be an I thing...
    socking:
        var c = a&sock || 5s&sock || G&sockneck;
        c.readyState !== 1 and ~sockdrop: c.s, s
        c.send(JSON.stringify(s));
    
    # shade the screen
    sockdead:
        s !== a&socks[s.s] and return ~sockdeaddupe: s.s
        ~closed: s.s
        $('body').stop().css('-webkit-filter', 'blur(1px) brightness(1.3) contrast(2)');
    
    # unshade the screen
    sockalive:
        s !== a&socks[s.s] and return ~sockalivedupe: s.s
        ~connected: s.s
        $('body').stop().css('-webkit-filter', '');
    
    # try sockneck again every .25 seconds
    # then every 2.5 seconds
    sockrecon:
        var t = 25000;
        s.fail++;
        s.fail < 100 and t = 250
        ~sockrecon: s.fail
        G&yl:t,&{ G&sockneck,s };
    
    #c begin, some unities
    # ww/mm for Stylewhole
    # keyjam for Stylicks
    # putontv for Hand
    # sockneck for Stylesocks
    
    # keon etc should have some general way to get
    #   into A contexts from the onclick="something.global()"
    begin:
        5s&ww = {};
        5s&mm = {};
        if (location.search.match('^\\\?v='))
            G&yl:6420,&{ G&putontv,location.search };
        
        // click, keys - outsiders starting with A.5
        G.clon = &{ $(window).on("click", &ev{ G&cl,ev }) };
        G.keon = &{ $(window).on("keydown", &ev{ G&ke,ev }) };
        G.clof = &{ $(window).off("click") };
        G.keof = &{ $(window).off("keydown") };
        G.doh = &ev,h{ G&doh,ev,h };
        
        G.togwid = &m,fr,to{
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        G&sockneck;
        
        G.clon(); G.keon();
    
HutKitchen: | # org systemic huttology
    n Stylephone
    n Stylicks
    n Stylesea
    n Stylating
    
    # dubiously designed
    n Stylewholes
Stylephone: | # to being there, basics
    # to begin, hang up your desires
    u j
    
    # timed callback, delay in ms?
    yl: %acgt:delay func
        setTimeout(func, delay);
    
    # eval
    e: %acgt:e
        var m = 
        eval(e);
        return m
    
    # throw error wrapped in A clues
    er: %acgt:e er
        console.log("xutbang: ", e, er);
        return;
        var ej = {er: {e: e}};
        er && er.message and ej.er.m = er.message;
        s.reply(ej); // TODO
        G&m:"!"+ (ej.er.m || e);
    
    # see M, also sand
    m: %acgt:e
        var d = e.substr(0,1);
        d == " " and return G&e,e;
        d == "[" || d == "{"  and return G&om,$.parseJSON(e);
        d == "." and e = '<span style="font-size:66%">'+e+'</span>';
        G&c,e;
    
    # #msgs console message
    c: %acgt:s e
        e ||= [];
        var says = [];
        $.each(e,&i,v{
            typeof v === 'string' || typeof v === 'number' and says.push(v);
            else {
                says.push('%'+typeof v);
            }
        });
        A[5].sc.log ||= [];
        var log = A[5].sc.log;
        log.unshift([s,e]);
        G&lim,log,-9;
        says.length and s = s+': '+says.join(' ');
        $('#msgs').prepend(s+"\n");
    
    # used?
    die: %acgt:s etc
        ~dead: s, etc, A, C
        throw([s,etc,A,C]);
    
Stylicks: | # Elvis' tongue
    u j
    # A speak
    E:
        G&cl,s
    
    # not too fast (0.01s) (used to have a bung keyboard)
    keyjam:
        5s&keyjam and return 1;
        5s&keyjam ||= 1;
        5s&keyjamfor ||= 10;
        G&yl:5s&keyjamfor,&{ 5s&keyjam = 0 };
        return 0;
    
    # click handler, fires anywhere if G.clon()
    # - G&entag .parent()s until W, makes path d.p = [[t,cv]+]
    # - G&point locates the A/C and gets distracted if ...
    # < onclick=A.sc.hands.$sip.click() finding way in
    #    see G&doh/G&begin for rudiments
    # < G&A,'e' handling it, picking up locales?
    #   we T={} to avoid tainting the 5.T with com to G&point
    cl: %acgt:ev
        G&keyjam and return;
        T$ = {};

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and 5s&lastW = d.W;
        d.p and 5s&lastp = d.p;
        
        d.W and G&point,d and return;
        
        G&socking,d;
    
    ke: %acgt:ev
        G&keyjam and return;
        T$ = {};
        
        var d = {};
        G&dscam,d,ev;
        
        d.which = ev.which;
        d.which == 16 || d.which == 17 || d.which == 18 and return
        
        d.k = String.fromCharCode(ev.keyCode);
        if (!d.W && 5s&lastW && 5s&ww[5s&lastW]) {
            $W = 5s&ww[5s&lastW].W;
            if (W.typeinto) {
                d.W ||= 5s&lastW;
                d.p ||= 5s&lastp;
            }
        }
        
        G&socking,d;
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          tag and d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
    
    # lookup C for $d event from A.5
    # can turn it local, return 1 to cancel sending
    point: %acgt:d
        W$ = 5s&ww[d.W];
        !W and ~die~noW: d.W, d
        !d.p and ~die~nodp: d
        b$ = W.b;
        got$ = [];
        
        $.each(d.p, &i,v{
            t$ = v[0];
            cv$ = v[1];
            got.push(t,cv);
            !(b.t[t] && b.t[t][cv]) and ~die~pointbroke: got.join(',')
            b = b.t[t][cv];
        });
        A$ = b.A;
        C$ = A&s;
        h$ = s&point_h;
        h and ~phand: h
        h and G&$h,d
        T.letevent and h = 0;
        return h
Stylesea: | # the C and data
    u j
    # parse ONE C-like scrap of something, not a Line
    inC:
        C = s;
        if (C.constructor == Array) {
            C = {t:C[0],y:C[1],c:C[2],sc:C[3]};
            typeof C.c  === 'string' and C.c =  G&peel,C.c;
            typeof C.sc === 'string' and C.sc = G&peel,C.sc;
        }
        else
        if (C.constructor == Object &&
            !C.t && !C.y && !C.c && !C.sc) {
            $.each(C, &k,v{ G&$k,v }); T.not = 1;
        }
        else
        typeof C === 'string' and C = {c: {s: C}};
        typeof C.c === 'string' and C.c = {s: C.c};
        typeof C.y === 'string' || typeof C.y === 'number' and C.y = {cv: G&sca,C.y };
        !typeof C.t === 'string' and console.log('queda',C);
        C.c ||= {};
        C.sc ||= {};
        return C;
    
    # datasm:
    
    # scale to fraction < 1
    sca:
        while (s > 1) { s = s / 10 }
        return s;
    
    # limit list, calling callback for each removal
    lim: %acgt:s lim cb
        var len = s.length;
        lim ||= 9;
        var rev;
        lim < 0 and rev = 1; lim *= -1;
        var rem = [];
        while (len > lim) {
            var v;
            rev and v = s.pop()
            else {  v = s.shift() }
            cb and cb(v);
            rem.push(v);
            len--;
        }
        rem.length and return rem
    
    # hash into ke,ys string
    ks:
        var ks = [];
        for (var k in s) {
            ks.push(k);
        }
        return ks.join(',');
    
    # ke:va,ys:lue string into hash
    # < mere,this -> mere === undefined, etc
    #   should be mere=1,this=1  see el.333/s&atr
    peel:
        var c = {};
        !s.length and return c
        $.each(s.split(','), function(i,kv) {
            kv = kv.split(':');
            var k = kv[0];
            var v = kv[1];
            v.match(/^-?\d+\.\d+$/) and v = v * 1
            c[k] = v;
        });
        return c
    
Stylating: | # A ting, h/t/om/throat
    u j
    # A.* falls, A.c/sc dont
    # A.on is the element/thing
    # A.om is a G-level A
    # A.mo is the first A under G-level
    # A.1 should mean the J the A is for... where things reside
    A:
        var V = $.extend({},A);
        V.up = A;
        var A = V;
        s and A.t = s;
        A.y = A;
        A.c = {};
        A.sc = {};
        A.om ||= A;
        A.om == A.up and A.mo = A;
        A[1] = A;
        
        T.d ||= 1;
        return A
    
    # subroutine call
    # TODO many args, up to acgt+5 & clued on D?
    # TODO Gc&B stacking
    # TODO G.i.* = A.I.i.y.tw.*.c.code
    h: %acgt:s so st sh sf si
        $z = s;
        typeof s === 'string' and z = G.t(A,C,G,T,'i',s);
        typeof s === 'string' && !z and z = G.t(A,C,G,T,'eye',s);
        !z and throw "No way: "+s;
        T.D = z;
        return z.c.code(A,C,G,T,so,st,sh,sf,si);
    
    # look up A slope for the I/$s (embryo) or the I/$s/$t (part)
    t: %acgt:s t
        var z;
        $.each([1,2,3,4,5], &i,v{
            z and return;
            var Y = A[v];
            !Y and return;
            var I = Y.I;
            !I and return;
            z = I[s];
            t and z = z.y.tw[t];
        });
        return z;
    
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    
    # toplevel n-tering
    om:
        A$ = G&A,'om';
        s and C = s;
        C$ = G&inC,C;
        C.y.A = A;
        t$ = T;
        T$ = {};
        if (t) {
            t.d and T.d = t.d + 1;
        }
        A&T = T;
        G&throat,2,C;
        T.alk = 'w'+T.d+' '+C.t+' '+ G&ks,C.c +'%'+G&ks,C.sc;
        s&css ||= {};
        s&anc ||= {};
        G&throat,7;
    
    # jog job through embryo A.t
    # up to ov
    throat: %acgt:ov sC
        T.not and return 0;
        ov and A&ov = G&sca,ov;
        sC and A&s = C;
        C = A&s;
        T = A&T;
        t$ = G&t,A.t;
        !t and G&er:"throat no "+A.t, A;
        
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            T.not and break
            var D = z;
            z = z.y.next;
            
            A.c.cv > D.y.cv and continue
            C = A&s;
            if (!D.sc.any) {
                D.sc.nk and !C[D.sc.nk] and continue;
                D.sc.gk and !C[D.sc.nk][D.sc.gk] and continue;
            }
            var es;
            D.sc.gk and es = C[D.sc.nk][D.sc.gk];
            D.sc.s and es = D.sc.s;
            G.h(A,C,G,T,D,es);
            T.not == '2' and return delete T.not;
            A.c.cv = D.y.cv;
        }
        return !T.not;
    
    
Stylewholes: | # Gs clocking on
    u j
        # on last A.b
    nn:
        A.b && A.b.A === A and return A.b
        !A.W and a.c("no aW",[A,C]);
        A.W.b ||= {};
        A.b ||= A.W.b;
        A.b[C.y.cv] ||= {};
        A.b[C.y.cv][C.t] ||= {};
        A.b.t ||= {};
        A.b.t[C.t] ||= {};
        A.b.t[C.t][C.y.cv] ||= A.b[C.y.cv][C.t];
        var b = A.b[C.y.cv][C.t];
        b.A = A;
        A.b = b;
        return b;
    
    Xi:
        !s and s = C.c.W;
        !s and s = C.c.M;
        $W = 5s&ww[s];
        W ||= 5s&mm[s];
        if (!(W && W.W && W.W.on)) {
            ~nottunedin: s
            // create it?
        }
        return W;
        
    Xin:
        $W = 5s&ww[s];
        W ||= G&Win;
        return W;
    
    Win:
        !(c&Wid && c&Mid) and ~die~noWMC: C
        $W = 5s&ww[c&Wid] = {};
        W.id = c&Wid;
        W.t = c&Mid;
        5s&mm[W.t] = W;
        W.A = {};
        W.A.W = W;
        ~newW: W.t, W.id, W
        return W
        
    Wout:
        var W = 5s&ww[A.W.id];
        W.t and 5s&mm[W.t] = W;
        delete 5s&ww[W.id];
        ~leaves W.t, W.id
    
    u jc
    n \'of:om'

    # same remote relay thing (GW)
    # comes with different Mid (G.t)
    Mid 26:
        C.t == 'GW' and C.t = s
        !c&Wid and G&die,"noWID!"
        delete c&s;
    
    # and Wid (G address) creates W
    Wid 27:
        c&id = s;
        c&Mid ||= C.t;
        $W = G&Xin,s;
        c&el == '6' and c&el = '2'; c&scub = 1;
        W.W = A;
        A.on = $('#ux');
        $.extend(A,W.A);
        c&tag ||= 'ww';
        s&ab ||= '100';
        s&poi ||= 'none';
        ~made Wid: s
    
    # either may be G.t or G address here
    M 28:
        $W = G&Xi,s;
        A.on = W.W.on;
        $.extend(A,W.A);
    
    W 28:
        $W = G&Xi,s;
        A.on = W.W.on;
        $.extend(A,W.A);
    
HutLounge: | # org enjoyable huttology
    # om c
    n Stylemoment
    # om sc
    n Stylemomentum
    # om sc/css
    n Stylebridge
    # chewers
    n Stylaplicants
Stylemoment: | # sequencing itself
    u jc
    n \'of:om'
    
    # grab another element
    nobody 31:
        s !== 'body' and s = '#'+s;
        A.on = $(s);
        !$(A.on).length and G&c:"no nobody at "+s;
    
    # eval
    e 32: %nk:sc
        s == '1' and s = c&s;
        eval(s);
        //T.not = 1;
        c&s = 'e';
        s&fs = '30%';
    
    # inside rows, possibly fed out in time
    # < Styletime (A.5 framerates callbacks)
    #   with sub-cv A cursor
    z 6: %nk:sc
        var del = 0;
        $.each(s, &i,v{
            var c = G&inC,v;
            var ub = &{
                G&om,c;
            };
            c.sc.deal and del += 1000 * c.sc.deal; G&yl,del,ub;
            else { ub() }
        });
    
    # set attributes
    # silly - wants to be gone?
    attrib 4: %any
        var f = ['id','src','dig'];
        var fl = function (v,z) {
            s&attr and s&attr[v] = z;
            else {
                $(A.on).attr(v,z);
            }
        };
        $.each(f,function(i,v) {
            C.sc[v] and fl(v, C.sc[v])
            else
            C.c[v] and fl(v, C.c[v])
        });
    
    #c element into time...
    # - A.on gets (or so) a child element
    # - lv is C with C.c.el=3 for updates, etc
    #   which implies one thing after another
    #   so we dont have to sort in new C
    # - el=8 just moves the cursor along to that
    #   element stored in ups&choint, to insertAfter
    # initially el=1 amongst children means insertBefore first
    # otherwise appendTo A.on
    el 333:
        s&attr ||= {};
        C.t === 'Ilan' and G&c,'Ilanity',A;
        if (s&atr) {
            var h = G&peel,s&atr;
            $.each(h, &k,v{
                v === undefined and v = C.sc[k];
                s&attr[k] = v;
            });
        }
        
        // make a safe, meaningless tagname
        var t = C.t.replace(/\W/g,'e');
        t = 'n'+t+'n';
        
        // point inserts to after thing before removed thing
        $choint_hole = &el{
            A.W && A.W.W === A and return;
            !$(el).length and return;
            ups&choint = $(el).prev();
            !ups&choint.length and delete ups&choint
        };
        
        // el=2 means C.t is the only C.t
        $fad = 0;
        if (s == '2') {
            $e = $(A.on).find('> [t="'+C.t+'"]');
            choint_hole(e);
            if (c&slow) {
                $d = (c&slow||1)*1000;
                G&yl:d,&{ $(e).remove() };
                fad = 8;
            }
            else {
                $(e).remove();
            }
        }
        s == '2' and s = '1';
        
        var find = '> '+t;
        C.y.cv and find += "[cv='"+C.y.cv+"']";
        var el = $(A.on).find(find);
        
        if (s !== '1' && !el.length) {
            tys$ = &C{
                return C.t +' '+ (''+C.y.cv).replace(/^0\./g,'');
            };
            tyleg$ = tys(upc&s)+'/'+tys(A&s);
            nam$ = 'elos'+c&el;
            ~$nam: tyleg
            console.log(nam,tyleg,A.on,C);
            return T.not = 1;
        }
        
        s == '9' && A.om == A and G&Wout;
        
        // get A.b from before
        G&nn;
        s&ellog and A.b.ellog = s&ellog
        A.b.ellog and A.ellog = A.b.ellog
        $ellog = &t,n{
            A.ellog == '9' && (C.y.cv != '0.9' && !s&pi) and return;
            $s = [];
            $.each(n, &i,v{
                typeof v === 'string' and s.push(v); return;
                if (v.constructor === Object) {
                    s.push(v.t+' '+v.y.cv+' el='+v.c.el);
                }
                else {
                       $t = $(v).attr('title');
                    !t and s.push(v); t = 'uh?';
                    s.push(t);
                }
            });
            $ind = '';
            $Y = A;
            while (Y && Y.up && A.W.W !== Y) {
                ind = ind+'  ';
                Y = Y.up;
            }
            console.log(ind+t,s);
        };
        
        if (!fad && el.length && (s == '1' || s == '9')) {
            choint_hole(el);
            $(el).remove();
            $bb = {};
            $.each(A.b, &k,v{
                bb[k] = v;
                delete A.b[k];
            });
            A.b.lastb = bb;
        }
        
        // #c to create
        if (s == '1') {
            s&attr.cv = C.y.cv;
            s&attr.t = C.t;
            c&tag and t = c&tag;
            s&attr.title ||= C.t+' '+C.y.cv;
            // extract bareword attributes
            var con = [];
            $.each(s&attr, &k,v{ 
                v == '!' and con.push(k)
            });
            con.length and con.unshift('');
            con = con.join(' ');
            var div = $("<"+t+con+">", s&attr);
            var at = ups&choint;
            var mode = 'insertAfter';
            if (!at) {
                at = A.on;
                if ($(at).children().length) {
                    at = $(at).children()[0];
                    mode = 'insertBefore';
                }
                else {
                    mode = 'appendTo';
                }
            }
            A.ellog and ellog('1-'+mode,[C,'at',at,A.on]);
            $(div)[mode](at).each(&i,v{ el=v });
        }
        else {
            A.ellog and ellog('entered',[C,'on',A.on]);
        }
        
        
        s !== '9' && !(A.W && A.W.W === A) and ups&choint = el;
        
        s == '8' and return T.not = 1;
        
        delete s&attr;
        
        if (A.b.cod) {
            c&cod ||= '3';
        }
        if (A.b.pa) {
            s&pa ||= '3';
        }
        if (typeof c&s === 'string' && !c&cod && !s&pa) {
            var cha = $(el).children();
            c&ht and $(el).html(c&s);
            else
            $(el).text(c&s);
            cha.length and $(el).append(cha);
        }
        A.on = el;
   
Stylemomentum: | # sequencing for the universal
    u js
    n \'of:om'
    
    # h call
    doo 32:
        G&$s;
        T.not = 1;
    
    cssdel 589:
        var re = s.split(',');
        $.each(re,&i,v{ delete s&css[v] });
    
    # compression of absolute/top/left/rotation/scale
    geo 5:
        s = s.split(' ');
        var aung = s[0].match('^a(\\d+)');
        if (aung) {
            s.shift();
            aung.shift();
            s&ab = aung.shift();
            //absolu
        }
        s = {x:s[0],y:s[1],rad:s[2],scale:s[3]};
        s&css.top = (s.y * 100)+'%';
        s&css.left = (s.x * 100)+'%';
        s&css['transform-origin'] = '0% 0%';
        s.tro and s&css['transform-origin'] = s.tro;
        s.rad and s&css['transform-rotate'] = s.rad+'rad';
        s.scale and s&css['transform-scale'] = s.scale;
    
    ab 51:
        if (s === '100') {
            s&css.width = '100%';
            s&css.height = '100%';
        }
        s&css.position = 'absolute';
    
    # apply attributes
    # < not losing filter: con sat when adjusting bri
    # Stylebridge compiles many sc to css
    css 59:
        if (typeof s === 'string') {
            var re = s.split(';');
            s = {};
            $.each(re, &i,v{
                var kv = v.split(':');
                s[kv[0]] = kv[1];
            });
        }
        $.each(s, &i,v{
            if (v.constructor === Object) {
                var swav = [];
                $.each(v, &ve,ss{
                    var se = ve+'('+ss+')';
                    swav.push(se);
                });
                v = swav.join(' ');
            }
            i === 'filter' and i = '-webkit-filter';
            $(A.on).css(i, v);
        });
    
    anc 59:
        $(A.on).animate(s&anc, (s&ant||900));
    
Stylebridge: | # join Ang's state of styleing
    n Ang=>W=>{}=>'%noii'
    
    # FactorEase Style{cW:of}/*, -s&of
    my ($t) = grep { _.t eq 'Style' } G&op,'cW:of';
    my $S = t.y.in;
    my $N = [$S];
    push @$N, $S while $S = S.y.next;
    delete _s&of for @$N;
    
    Rw Stylebridger $N;
    
Stylebridger: | # Style decompressions for js clients
    # given $N of=Style with s&cssk
    
    # thy expanding s&blr to s&css[filter-blur] = $v
    my $e;
    e.thy->{_s&gk} = _s&cssk for grep {_s&cssk} @$N;
    my @pooling = (
        {k=>transform=>also=>[qw'rotate scale']},
        {k=>filter=>also=>[qw'
            blur saturate brightness hue-rotate
            sepia invert grayscale
        ']},
    );
    for my $g (@pooling) {
        for my $al (@{g.also}) {
            my $lie = g.k.'-'.$al;
            e.roi->{$lie} = [g.k,$al];
        }
    }
    # roi packs s&css[filter-blur]
    #         to: s&css[filter][blur]
    # which css 59 understands as:
    #   for filter: blur(4px) saturate(...

    u js
    n css =>58,<<'',{any=>1,stylex=>$e,of=>'om'}
        s = T.D.sc.stylex;
        $.each(s.thy,&k,v{
            C.sc[k] and s&css[v] = C.sc[k];
        });
        $.each(s.roi,&k,v{
            var o = s&css[k];
            !o and return;
            var ve = v[0];
            var ss = v[1];
            s&css[ve] ||= {};
            s&css[ve][ss] = o;
            delete s&css[k];
        });
Stylaplicants: | # gears, talkyboxes
    u j
    codsav:
        var cm = s;
        var d = {};
        G&entag,d,$(A.on);
        A.b.jus = d.code = cm.getValue();
        d.dig = $(A.on).attr('dig');
        G&socking,d;
    
    cod 4: %of:om,v:ccod
        var cm = A.b.cod;
        .
        if (typeof s === 'string') {
            if (s === '3') {
                !cm and return G&c:'no cod !';
                s = {};
            }
            else {
                s = {mode:'perl'};
                cm = 0;
            }
        }
        .
        var def = {mode:'perl',theme:'midnight',lineWrapping:true};
        var set = $.extend(def, s);
        cm and $.each(set,&k,v{ cm.setOption(k,v) });
        !cm and cm = CodeMirror(A.on, set);
        A.b.cod = cm;
        
        if (c&s) {
            c&s !== A.b.jus and cm.setValue(c&s);
            else { G&c:'vv vv'+C.t; }
        }
        
        cm.refresh();
        G&yl:400,&{ cm.refresh() };
        
        var sav = &{
            G&codsav,cm;
        };
        cm.setOption('extraKeys', {Esc:sav});
        cm.on('focus',function(){G.clof();G.keof();});
        cm.on('blur',function(){G.clon();G.keon();sav();});
    
    #    $('#'+id).css('width','15em','max-height','70%','overflow','scroll');
    #   $('#'+id+' > .CodeMirror');//.css('height','auto');
    
    #c drowdowns
    # get G&point to hijack clicks
    sel 4: %of:om,v:ssel
        s&point_h = 'dropdown';
    # called by G&point with A/C found from 5s&ww/.b... 
    # from the d.p (C path)
    # selected is whichever s&sel looks like c&s
    dropdown: %acgt:d
        sel$ = $('<select/>',{name:C.t});
        hav$ = c&s.replace(/\W/g,'');
        $.each(s&sel.split('-'), &i,v{
            opt$ = $('<option/>');
            $(opt).attr('value',v);
            $(opt).text(v);
            v === hav and $(opt).attr('selected','selected');
            $(sel).append(opt);
        });
        $(A.on).empty();
        $(A.on).append(sel);
        s&point_h = 'dropdown_h';
    
    # changing ^ point handler avoids needing G&doh
    # which would have to find A/C itself etc...
    # but might be needed sometime for an onsomething event
    #   $(sel).attr('onchange','G.doh(this,"dropdown_h")');
    # - also if you:
    #   $(sel).css('pointer-events','none');
    #   it triggers click when opening the selection (?)
    doh: %acgt:el h
        console.log('h toosee: ',h,ev);
    
    # we turn up here with d.s = el.val()
    dropdown_h: %acgt:d
        console.log('in here: ',A,C,d);
        
        if (d.s === '?') {
            inp$ = $('<input>');
            $(A.on).empty();
            $(A.on).append(inp);
            inp.on('focus',&{G.clof();G.keof();});
            inp.on('blur',&{G.clon();G.keon();$(inp).click();});
            $(inp).focus();
            return;
        }
        T.letevent = 1;
        
        
        
    #
Jar: |
    # of roots

