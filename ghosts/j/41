JaBabz: |
    my $poing = qr/\w+(?:\.\w+)?/;
    my $nlp = qr/[^\n]+/;
    
    c&s =~ s/\bA&(\w+)\b/A\.c\.$1/g;
    c&s =~ s/\ba&(\w+)\b/A\.sc\.$1/g;
    c&s =~ s/\bs&(\w+)\b/C\.sc\.$1/g;
    c&s =~ s/\bC&(\w+)\b/C\.sc\.$1/g;
    c&s =~ s/\bc&(\w+)\b/C\.c\.$1/g;
    
    c&s =~ s/^t\&([^\s;]+)(;)?/!G\&t,$1 and return;/gm;
    
    # G&thing:args,"with space";
    c&s =~ s/($poing)\&(\$)?($poing)(:\S+[^\n;]+)(;)?/
        my ($on,$var,$p,$e,$t) = ($1,$2,$3,$4,$5);
        $e =~ s{^:}{,};
        ($on,my$in) = ("G\.h",'A,C,G,T,')
            if $on eq 'G';
        $p = "\"$p\"" unless $var;
        my $s = $on."($in$p$e)$t";
        $s = '$'.$s if $on !~ m{\.};
        $s
    /smge;
    
    # G&thing,args && without space
    c&s =~ s/($poing)\&(\$)?($poing)(,[^\s;]+)?(;)?/
        my $t = $2 ? "$3" : "'$3'";
        my $h = $1 eq 'G' ? ".h(A,C,G,T,$t" : "\[$t\](A,C,G,T";
        $1.$h."$4)$5"
    /smge;
    
    # true or assign
    c&s =~ s/^\s*($nlp) \|\|\= ($nlp)(;)?$/if (!$1) {
        $1 = $2
    }/gm;
    # left-hand if
    c&s =~ s/^\s*([^\n]+?) and ($nlp)(;)?$/if ($1) {
        $2
    }/gm for 1..3;
    
    # tiny sub maker, &raw,args{
    c&s =~ s/([^G&])&(\w*(,\w+)*)\{/$1function($2){/gm;
    
    # com message
    c&s =~ s{(^|\{) *~(?:(\w+)~)?(\w+(?:$nlp:)?)(?: ($nlp))?;?$}{
        my $ope = $1;
        my $r = $2 ? 'A,C,G,T,' : '';
        my$c=$2||'c';
        my$s=$3;
        my$e=$4;
        $s=~s/:$//;
        $ope."a\.$c($r'$s',[$e]);"
    }segm;
    
    c&s =~ s/^\s*\$(\w+)\b/var $1/gm;
jst: | # test js babbler
    c&s = <<'';
        !G&Time,'rasunify',700,s and return
        G&something
        $.each(h,&k,v{ delete h.k });
        ~leaves
        G&nothing,is,over
        c&see = c&know;
        C&tell = C&B;
        var s = &c{ that.it.is };
        ~rasunify: re.length
        ~dothis~fourly: f
            C&attr.title ||= C.t+' '+C.y.cv;
            
        G&wide:"several ticks";
        G&$some:4,56-3, (28 / A.5.sc.e)
    #

    Rw JaBabz;
    
    #is(c&s,<<'',"G& and ~");
    my $good = <<'';
        if (!G.h(A,C,G,T,'Time','rasunify',700,s)) {
            return
        }
        G.h(A,C,G,T,'something')
        $.each(h,function(k,v){ delete h.k });
        a.c('leaves',[]);
        G.h(A,C,G,T,'nothing',is,over)
        C.c.see = C.c.know;
        C.sc.tell = C.sc.B;
        var s = function(c){ that.it.is };
        a.c('rasunify',[re.length]);
        a.dothis(A,C,G,T,'fourly',[f]);
        if (!C.sc.attr.title) {
            C.sc.attr.title = C.t+' '+C.y.cv;
        }
        
        G.h(A,C,G,T,"wide","several ticks");
        G.h(A,C,G,T,some,4,56-3, (28 / A.5.sc.e))
    # 
    c&s eq $good && return saygr "jst good";
    my ($l,$r) = map {[split "\n", $_]} c&s, $good;
    for my $ls (@$l) {
        my $rs = shift @$r;
        $ls eq $rs && next;
        sayre "Line: $ls", "Isnt: $rs";
    }
    sayre "Line!", "Isnt: $_" for @$r;
    #saybl("Was off:\n\n'".c&s."'\n\nvs '$good'")
    #
javascript: | # compile/collect for sc.js
    # place toward A.ii.>$s, linked list of embryo
    my $of = C.t;
    my $ark = G.sc.codeark ||= {};

    # rennovating around town
    # a geodesic self-mover
    # keeps rebuilding in different locations
    
    # this way should export osc hooks and another way...
    for my $C ( e&_cz ) {
        c&s || sayre "C.t C.y.cv has no s: ".ki $C;
        if (!c&code && (s&args || s&acgt || 1)) {
            # may already be compiled
            # shades code through the wall
            # the W listened to needs one osc in G, then all can whole it
            # coded while the W goes through the wall
            my $coded = delete(s&coded) || s&args && s&acgt;
            my $digs;
            my $scbab;
            unless ($coded) {
                # shade the edges, args, parsables etc.
                
                if (s&acgt) {
                    die "acgt js: C.t already s&args" if s&args;
                    s&args ||= join',','A,C,G,T',split/\W+/,
                        grep{$_ ne '1'}s&acgt;
                }
                die "wonky C.t   of ".ki $C if C.t =~ /\W/;
                s&args =~ s/ /,/g;
                delete C.sc.com;

                Rw ym/jsbabz;

                c&s = "function(".s&args.") {\n".c&s."};\n"
                    if s&args;
                s&coded = 1;
            }
            
            G&hoh,C.sc,$scbab if $scbab;
            
        }
        s&dige = slm 12, dig c&s if exists c&s && !ref c&s;
    }

    C.sc.hi = 'lo';
    T.nose = 1;
    T.pos = 0;
j: |
    u alact
    n i
    # ^ follows of encoder until:
    alarejs 4222: %of:mo
        s&js = delete s&of;
    
jc: | # see C.c.*
    n j
    n c
js: | # see C.sc.*
    n j
    n s
Styleslops: | # minimal page that sucks in more stuff from Stylehut
    # use the js filter, store in ...
    index: %js:html
        <!DOCTYPE html>
        <html><head>
          <style type="text/css">
            ww * { pointer-events:none; }
            ww * * { pointer-events:all; }
          </style>
          <link href="light.css" rel="stylesheet"></link>

          <script src="codemirror/lib/codemirror.js"></script>
          <link href="codemirror/lib/codemirror.css" rel="stylesheet">
          <link href="codemirror/theme/night.css" rel="stylesheet">
          <link href="codemirror/theme/midnight.css" rel="stylesheet">
          <link href="codemirror/theme/base16-dark.css" rel="stylesheet">
          <link href="codemirror/addon/display/fullscreen.css" rel="stylesheet">
          <script src="codemirror/addon/display/fullscreen.js"></script>
          <script src="codemirror/mode/perl/perl.js"></script>
          
          <script src="paper.js"></script>
          <script src="paper.animate.js"></script>
          
          <script src="jquery.min.js" type="text/javascript"></script>
        </head>
        <body style="margin: 0px; background: black; color: #0d2; height:100%; width:100%;">
          <div id='msgs' style="white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:50%;height:28%; overflow:hidden;padding:0.2em;color:#abc;z-index:200" onclick="keon();clon();a.togwid('#msgs','50%','5%');" > </div>
          <div id='ux' style="position:absolute;top:0em;
          right:0em;width:100%;height:100%;"> </div>

          <canvas id="display" resize></canvas>

          <script type="text/javascript">
            var A = {c:{},sc:{}};
            a&elvis = Math.random();
            a&start = ['thestart'];
            A&start = &s{
                if (s) {
                    var m = s.split("\n");
                    $.each(m,&i,v{ eval(v); });
                }
                if (a&start.length) {
                    $.ajax(a&start.shift()).done(A&start);
                }

            };
            $(document).ready(&{
                A&start();
            });
          </script>
          </body></html>
Stylehut: | # not stylehut, see also Styleslops for the html/mount
    n Stylephone
Stylephone: | # to being there, basics
    # to begin, hang up your desires
    u j
    
    # timed callback, delay in ms?
    yl: %acgt:delay func
        setTimeout(func, delay);
    
    # eval
    e: %acgt:e
        var m = 
        eval(e);
        return m
    
    # throw error wrapped in A clues
    er: %acgt:e er
        console.log("xutbang: ", e, er);
        return;
        var ej = {er: {e: e}};
        er && er.message and ej.er.m = er.message;
        s.reply(ej); // TODO
        G&m:"!"+ (ej.er.m || e);
    
    # see M, also sand
    m: %acgt:e
        var d = e.substr(0,1);
        d == " " and return G&e,e;
        d == "[" || d == "{"  and return G&om,{},$.parseJSON(e),a,{};
        d == "." and e = '<span style="font-size:66%">'+e+'</span>';
        G&c,e;
    
    # #msgs console message
    c: %acgt:s e
        e ||= [];
        var says = [];
        $.each(e,&i,v{
            typeof v === 'string' || typeof v === 'number' and says.push(v);
            else {
                says.push('%'+typeof v);
            }
        });
        var log = A.5.sc.log ||= [];
        log.unshift([s,e]);
        a.lim(a.log,-9);
        says.length and s = s+': '+says.join(' ');
        $('#msgs').prepend(s+"\n");
    
    # datasm:
    
    # scale to fraction < 1
    sca:
        while (s > 1) { s = s / 10 }
        return s;
    
    # limit list, calling callback for each removal
    lim: %acgt:s lim cb
        var len = s.length;
        lim ||= 9;
        var rev;
        lim < 0 and rev = 1; lim *= -1;
        var rem = [];
        while (len > lim) {
            var v;
            rev and v = s.pop()
            else {  v = s.shift() }
            cb and cb(v);
            rem.push(v);
            len--;
        }
        rem.length and return rem
    
    # hash into ke,ys string
    ks:
        var ks = [];
        for (var k in s) {
            ks.push(k);
        }
        return ks.join(',');
    
    # ke:va,ys:lue string into hash
    peel:
        var c = {};
        !s.length and return c
        $.each(s.split(','), function(i,kv) {
            kv = kv.split(':');
            var k = kv[0];
            var v = kv[1];
            v.match('^-?\\\d+.\\\d+$') and v = v * 1
            c[k] = v;
        });
        return c
    
Stylicks: | # Elvis' tongue
    u j
    # A speak
    E:
        G&cl,s
    
    # click handler
    # that onclick=A.sc.hands.$sip.click()
    #   callback encloses an ACGT to do this with:
    # TODO gets keyjam
    cl: %acgt:ev ws
        keyjam and return;
        keyjam = 1;
        keyjamfor ||= 10;
        setTimeout(function () { keyjam = 0; }, keyjamfor);

        var d = {};
        G&dscam,d,ev;

        d.x = ev.clientX;
        d.y = ev.clientY;
        d.pagex = window.pageXOffset;
        d.pagey = window.pageYOffset;

        var tag = $(ev.target);
        tag.val and d.s = tag.val();

        G&entag,d,tag;
        d.W and a.lastW = d.W;
        d.p and a.lastp = d.p;
        G&ethro,d,ws; // TODO
    
    # TODO gets keyjam
    ke: %acgt:ev ws
          keyjam and return;
          setTimeout(function () { keyjam = 0; }, keyjamfor);
          keyjam = 1;

          var d = {};
          G&dscam,d,ev;
          d.which = ev.which;
          if (d.which == 16 || d.which == 17 || d.which == 18) {
              return;
          }

          d.k = String.fromCharCode(ev.keyCode);
          if (!d.W && a.lastW && ww[a.lastW]) {
                $W = ww[a.lastW].W;
              if (W.typeinto) {
                d.W ||= a.lastW;
                d.p ||= a.lastp;
              }
          }
          
          G&ethro,d,ws; // TODO
    
    # trace click up to the G
    # whose tag is ww and id the W address
    entag: %acgt:d tag
          d.name = tag.attr('name');
          var p = [];
          while (tag.length) {
              var nam = tag.prop('tagName');
              var t = tag.attr('t');
              var cv = tag.attr('cv');
              var id = tag.attr('id');
              if (nam === 'WW') {
                  d.W = id;
                  break;
              }
              if (cv || t) {
                  p.push([t,cv]);
              }
              tag = tag.parent();
          }
          d.p = p.reverse();
    
    # TODO gets ws/conz
    ethro: %acgt:d ws
          if (d.W) {
              var conin = conz[d.W];
              if (conin) {
                  ws = C[conin];
              }
          }
          if (!ws) {
              ws = w;
          }
          ws.reply({event: d});
    
    # type/click typology
    dscam: %acgt:d ev
        d.type = ev.type;
        d.S = 0+ev.shiftKey;
        d.C = 0+ev.ctrlKey;
        d.A = 0+ev.altKey;
        d.M = 0+ev.metaKey;
Stylating: | # A ting
    u j
    # A.* falls, A.c/sc dont
    # A.on is the element/thing
    # A.om is a G-level A
    # A.mo is the first A under G-level
    # A.1 should mean the J the A is for...
    A:
        var V = $.extend({},A);
        delete V.C;
        V.up = A;
        var A = V;
        s and A.t = s;
        A.c = {};
        A.sc = {};
        A.om ||= A;
        A.om == A.up and A.mo = A;
        A.1 = A;
        
        T.d ||= 1;
        return A
    
    # attaches ground
    # on last A.b
    nn:
        !A.W and a.c("no aW",[A,C]);
        A.W.b ||= {};
        A.b ||= A.W.b;
        A.b[C.y.cv] ||= {};
        A.b[C.y.cv][C.t] ||= {};
        A.b.t ||= {};
        A.b.t[C.t] ||= {};
        A.b.t[C.t][C.y.cv] ||= A.b[C.y.cv][C.t];
        var b = A.b[C.y.cv][C.t];
        b.A = A;
        return b;
    
    # TODO look in A.ii.i.$way
    # subroutine call
    # TODO many args
    h: %acgt:way s
        !G[way] and throw "No way: "+way
        return G[way](A,C,G,T,s);
    
    # look up A slope for the I/$t (embryo) or the I/$s/$t (part)
    t: %acgt:s t
        !t and t = s; s = 'I';
        var z;
        $.each([1,2,3,4,5], &i,k{
            z and return;
            var Y = A[i];
            !Y and return;
            var I = Y[I];
            !I and return;
            z = I[t];
        });
        return z;
    
    # persona perforthe webclient channels
    # so the G copies and lives from/to W
    # h reach up/down to applied layers of you
    # top level mirage is o(ww,Wid,$s) 
    # which ins ww (G.Wid for Oth), J.id (Wid)
    # and the difference is you
    
    # toplevel n-tering
    om:
        A = G&A,'om';
        C = G&inC,C;
        G&throat,2;
        T.alk = 'w'+T.d+' '+C.t+' '+a.ks(C.c)+'%'+a.ks(C.sc);
        C.sc ||= {};
        C.sc.css ||= {};
        C.sc.anc ||= {};
        G&throat,7;
    
    # jog job through embryo A.t
    # up to s
    throat: %acgt:ov sC
        T.not and return 0;
        ov and A&ov = G&sca,ov;
        sC and A&s = C;
        var t = G&t,A.t;
        !t and G&er:"throat no "+A.t,A;
        G&ex,A.I;
        return !T.not;
    
    # wants to sort in
    eine:
        var K = s[0];
        var e = s[1];
        var k = 'e_'+K;
        G[k] = e;
    
    ex:
        s.ei ||= 0;
        while (1) {
            T.not and return
            var v = A.e[s.ei];
            !v and return
            v[0] > s.cv and return
            s.ei++;
            $.each(v[1],function(i,D){
                T.not and return
                var t = D[0];
                var sc = D[1];
                sc.nk and !C[sc.nk] and return
                sc.gk and !C[sc.nk][sc.gk] and return
                var es;
                sc.gk and es = C[sc.nk][sc.gk];
                sc.s and es = sc.s;
                G&$t,es;
            });
        }
    
Jar: |
    # of roots

