
Crank: | # add trips for hC to glow more
    my $j = e&hJ ->[-1];
    my $i = 1;
    $i *= -1 if us&S;
    js&boost += $i;
    sayyl "Crank to js&boost: ".G&sn,$j;
    # make into Trips?
    # makes Matu wakeup happen
    # as a G.A would unify
pi/od: | # data splayer
    # recursion
    Rw HaveDepth;
    Rw MayC;
    # ident
    Rw Indentity;
    Rw Trunks;
    
    if (c&block) {
        n block=>2=>c&block,'%hs:855'
        c&blos &&
        n blocked=>21=>' '.c&blos,'%hs:827'
        return
    }
    
    
    # do preliminary identify
    #  with marks that cancel if others supply
    if (c&isC) {
        Rw SeeC;
    }
    elsif (c&isA) {
        Rw SeeA;
    }
    elsif (c&isJ) {
        Rw SeeA;
    }
    else {
        Rw Sees;
    }
    
    s&sy &&
        n sy=>o75=>s&sy=>"%hs:7574,ab:1,poi:0,lh:40%,fs:".int(100 / c&depth)
    delete c&s;
    
    
    #sayyl "The A&ind A.1.t)1c&path to ".ki A.1.6.c.s;
    
    
    
    return if s&return;
    
    # send forth light flames
    Rw Froth;
    
    if (@$M) {
        
        #n lit=>oo1=>"Fig ".ki($M),'fs:7,hs:894'
    }

    
HaveDepth: |
    c&depth ||= 2Cc&depth + 1;
    
    # how many M inners before 'more' (depth first)
    3Cc&intlim ||= 15;
    # max depth before like nothash
    c&dl ||= 2Cc&dl;
    c&dl = 2 if !defined c&dl;
    
    # travel boosts/cons depth
    c&dl += Js&boost * 2 if Js&boost;
    
    a&space = c&dl - c&depth;
    
    a&inself = 1 if 2Cs&pi eq s&pi ;
    
    y.n = 21;
    
    if (2Cc&pi eq 1Cc&pi) {
        # nonfirst make path
        1c&path = join ' ', grep{defined} 2c&path, A.1.t;
    }
    else {
        # first, Cc&top may clue
        A.1.6 = A.1;
    }
    
    if (my $t = 16Cc&top) {
        my $gw = t.y.gets_pw;
        if (my $e = $gw.>1c&path ) {
            n "gets_".es&gets=>o79=>"@","hs:8944,ab:1,ml:0.5,lh:80%,fs:".int(60 / c&depth)
        }
        
    }
MayC: | # c&istycsc = $1 if c&is(J|A|C)
    # C is hash with one or more of t y c sc
    return if ref $s ne 'HASH'
        || !exists s.t && !exists s.y && !exists s.c && !exists s.sc;
    
    if (s.y eq $s && exists s.t && exists s.c && exists s.sc) {
        if (s.1 eq $s) {
            c&isJ = 1;
            c&istycsc = 'J'
        }
        else {
            c&isA = 1;
            c&istycsc = 'A'
        }
    }
    elsif (defined s.t && (s.y || ref s.c eq 'HASH' || ref s.sc eq 'HASH')) {
        c&isC = 1;
        c&istycsc = 'C'
    }
Indentity: | # bit of basket "$ind<" and name of bit there (C.t)
    y.at.qs=1;
    y.at.ws=1;
    y.clos=1;
    A&ind = join'', ('  ') x (c&depth - 1);
    y.at.dis = 1;
    s&dis = 3;
    
    n ind=>o7=>A&ind
    n sli=>o8=>"<  ",'%hs:784,dos:Crank'
    
    c&quiet_t && a&space < 2 ||
    n t=>1=>"C.t ",'%dos:Crank'
    
Trunks: | # adj depth for shape/truncation of too-hyperlinkage
    # 
    c&dl += 2 if c&depth < 6 && C.t eq 's' && 22Cc&istycsc;
    c&dl -= 3 if C.t eq 'y' && 2Cc&istycsc;
    c&dl += 2 if C.t eq 'in' && A.2.C.t eq 'y' && 22Cc&istycsc;
    # crawling up a long thin trunk
    if (0 && C.t ne 'y' && (c&dl - c&depth) < 1 && 3Cc&intl < (3Cc&intlim / 3)) {
        T wtf
        c&dl += 1;
    }
    
    # above or part of a C/A/s?
    c&block = 'same' if a&inself
        && defined $s && defined 2Cc&s
        && $s eq 2Cc&s;
    
    c&block = 'b' if C.t eq 'ip' && A.2.C.t eq 'c';
    
    # mute bits of the slide that go other fast
    if (!c&block && ref $s eq 'HASH') {
        T hashi
        if (C.t eq 'G') {
            my $w = s.w;
            if (ref $w eq 'CODE' || ref \$w eq 'GLOB') {
                c&block = 'G';
            }
        }
        if (s.y eq $s) {
            c&block = 'yA' if A.2.C.t eq 'y';
            c&block = 'AA' if 2Cc&isA;
            if (c&block) {
                c&blos = G&sn,$s;
            }
        }
    }
    # see many C via z/y.in 
    if (c&isC && !a&inself) {
        # first C sees if this is a nice little place...
        if (s.y.in && G&isC,$s) {
            # < suggest we SeeC so these are...
            a&key_hash = {c=>s.c,sc=>s.sc};
            a&keys = [];
            my $cb = &Dd{
                # minimise pathiness
                my @path = @{d.path};
                shift @path; # us
                s/ 0\.(\d+)$/ $1/ for @path;
                my $key = join ' ', @path;
                a&key_hash.>$key = D.y.D;
                push @{a&keys}, $key;
                # set ind + containing its t
                my $c = a&key_oh.>$key ||= {};
                cc&depth = c&depth + @path;
                cc&quiet_t = 1;
            };
            my @n = G&ind,$s,$cb; 
            @{a&keys} = reverse @{a&keys};
            shift @{a&keys}; # us
            unshift @{a&keys}, qw'c sc';
            n zeing=>201=>'z','hs:795,fs:34,lh:0.3,blr:4'
        }
    }
    
SeeC: |
    s&sy = 'C';
    s&return ||= Rw Cpud;
    
    # see the C, calcify it...
    return;
    
    # Quant: if C is t-cs- only, it's an empty-ish layer
    if (G&q,$s,'o?.cs') {
    
    }
    if (ref $s eq 'HASH' && keys %$s < 5 && 
        G&isC,$s) {
        # try
        if (!keys %{s.y} && !keys %{s.sc}
            && keys %{s.c} == 1 && exists s.c.s) {
            n short=>12=>" t: s.t","%hs:457"
            m "c\.s"=>-pud=>{s=>sc&s,ima=>[qw'c s']}
            s&return = 2;
            c&dl += 2;
        }
        s&return ||=
            Rw Cpud;
    }
Cpud: |
    my $spc = c&block ? 1 : a&space;
    # scale t fontsize
    my $fss = &s{
        my $over = length($s) / 14;
        my $fs = int(12 / ($over < 1 ? 1 : $over * 0.89));
        $fs = 3 if $fs < 3;
        $fs
    };
    if ($spc < 1) {
        my $ac = G&aC,$s,'Ck5';
        
        $ac->[1] =~ s/^0\.//;
        my $fs = $fss->($ac->[0]);
        #
        n t=>2=>{s=>shift @$ac},"%hs:356,fs:$fs,mw:14"
        n ycv=>2=>{s=>shift @$ac},'%fs:12,ma:0.3'
        my $y = shift @$ac;
        ($y) = Rw Deyer $y;
        n y=>201=>{s=>$y},'%hs:856,fs:7'
        
        my $c = ki s.c;
        my $cac = shift @$ac;
        $c = $cac if length $c > 40;
        my $cfs = $fss->($c);
        n c=>21=>{s=>$c},"%hs:656,fs:$cfs"
        
        # < spot s&J
        my $sc = ki s.sc;
        my $scac = shift @$ac;
        $sc = $scac if length $sc > 80;
        my $scfs = $fss->($sc);
        n sc=>22=>{s=>$sc},"%hs:456,fs:$scfs"
    }
    elsif ($spc < 2) {
        my $ac = G&aC,$s,'Ck5';
        
        $ac->[1] =~ s/^0\./$2/;
        my $fs = $fss->($ac->[0]);
        $fs += 2;
        
        n t=>2=>{s=>shift @$ac},"%hs:356,fs:$fs,mw:14"
        n ycv=>2=>{s=>shift @$ac},'%hs758,fs:12,ma:0.3'
        my $y = shift @$ac;
        $y =~ s/\bcv\b//;
        ($y) = Rw Deyer $y;
        
        n y=>201=>$y,'%hs:856,fs:7'
        
        my $c = {%{s.c}};
        if (exists c.s && 0) {
            my $s = delete c.s;
            my $fs = $fss->($s);
            n s=>23=>$s,"%hs:356,fs:$fs,mw:14,ab:1,mt:2"
        }
        my $dw = {map{$_=>1}qw't y'};
        A&kg = &k{ $dw.>$k };
        return 0;
    }
    else {
        # dive into
        return 0;
    }
    1
Deyer: | # fold y familiar
    my $ig = ar.ig || {};
        my @yt = qw'D r x up|next|prev:+';
        my $m;
        for my $k (@yt) {
            ($k,my$la) = split ':', $k;
            $la ||= $k;
            $m .= "$la " if grep { $y =~ s/\b$_\b//g && ++$ig.>$_ }
                split /\|/, $k;
        }
        my $ys = join " ", grep{$_} split /\s+/, $y;
        $y = join " ", grep{$_} $m, $ys;
        ($y,$m,$ys)
SeeA: |
    if (s.1 && s.1 eq $s || s.sc && s.sc.n) {
        s&sy = "J";
        s&return ||=
            Rw Jpud;
    }
    else {
        s&sy = 'A';
        s&return ||=
            Rw Apud;
    }
    # T # seen to/from ghost, they osc pool up to direct change in
    # chasing up all the J that hit it
    # osc pool meaning a vortex of self, changes moving upward, 
    # just copying changed hashes - replace {} from changed up to root
    # and copy it in at the other J
Jpud: |
    if (a&space < 5) {
        n Jt=>15=>"s.t",'%hs:588,fs:13'
        n sn=>167=>" $_ ",'%hs:897,fs:7' for G&sn,$s;
        n co=>168=>(sc&o||"?")=>'%hs:374'
    }
    #
    n inj=>189=>" J*a&space"
    T there
    if (a&space < 5) {
        my $dw = {map{$_=>1}qw'y 1 2 3 4 5 i ii I cv t'};
        A&kg = &k{ $dw.>$k };
    }
    # return if
    a&space <= 5;
Apud: |
    my $spc = c&dl - c&depth;
    if ($spc < 1) {
        n Jt=>15=>"s.t",'%hs:588,fs:13'
        if (!s.1) {
            n sn=>167=>" <nonet> ",'%hs:897,fs:7'
        }
        else {
            n sn=>167=>" $_ ",'%hs:897,fs:7' for G&sn,$s;
        }
        n co=>168=>(sc&o||"?")=>'%hs:374'
    }
    #
    n inj=>189=>" A*a&space"
    T there
    if ($spc < 1) {
        my $dw = {map{$_=>1}qw'y 1 2 3 4 5 i ii'};
        A&kg = &k{ $dw.>$k };
    }
    # return if
    $spc <= 0;
Sees: |
    if (ref $s eq 'ARRAY') {
        n is=>11=>'[','%hs:457'
        #C.sc.type = 'array';
        c&isarray = 1;
        c&vs = [@$s];
        c&ks = [0..(@$s-1)];
        if (22Cc&istycsc) {
            if (A.2.C.t eq 'c') {
                c&dl = 1 if C.t eq 'N';
            }
        }
        if (c&depth > c&dl) {
            s&return++;
            n no=>2=>ki($s),'%fs:7,hs:458'
        }
    }
    else {
        if (ref $s ne 'HASH' || c&depth > c&dl) {
            T nonhash
            my $z = s&type eq 'A' ? G&sn,$s
                : ki $s;
            my $bg;
            if (!ref $s) {
                $z =~ s/^!%://;
                $bg = ',bg:653';
                if (!defined $s) {
                    n know=>18=>'undef','%hs:845,fs:6'
                }
                elsif (!length $s) {
                    n know=>18=>"''",'%hs:845,fs:6'
                }
                elsif (c&d < 3) {
                    $z = slim((600 / (c&d||1)),$s);
                }
            }
            elsif (200 < length $z) {
                $z = slim(200,$z);
                n short=>18=>'...','%hs:798,fs:7'
            }
            my $fs = 6;
            $fs = 8 if !ref $s;
            if (2Cc&istycsc) {
                if (C.t eq 't') {
                    $z = $s;
                    $fs = 23;
                }
                if (C.t eq 'y') {
                    T ys
                    my $ig;
                    if (s.cv) {
                        ig.cv++;
                        my $cv = s.cv;
                        $cv =~ s/^0\.//;
                        n cv=>191=>$cv,'%hs:286,fs:12'
                    }
                    $z = Rw yki $s $ig $we:A.2.C.c.s;
                }
            }
            if (22Cc&istycsc) {
                if (A.2.C.t eq 'y') {
                    $fs = 16 if C.t eq 'cv';
                }
            }
            
            # js loses it, element created?
            $z = "'$z'" if $z =~ /^\d+(\.\d+)?$/;
            n Sees=>2=>$z,"%fs:$fs,hs:398,lh:0.9,mh:5$bg,dis:2,mw:75%,wb"
            s&return++;
            return
        }
        if (s.y eq $s && c&depth > c&dl) {
            s&return++;
            n A=>2=>"A s.t s.y.cv; ".ki(s.c)."    ".ki(s.sc);
        }
    }
    
yki: | # ki() again
    my $ig = ar.ig || {};
    my @ks = sort keys %$s;
    my $ks = &v{
        join' ',sort keys %$v
    };
    my $m;
    if ($we && C.t eq 'y') {
        my $y = join ' ', @ks;
        ($y,$m) = Rw Deyer $y $ig;
    }
    my @l = map {
        my $v = $s.>$_;
        ar.ig && ar.ig.>$_ ? '' :
        "$_:".(ref $v eq 'HASH' ? (
            v.y eq $v ? "A:v.t" :
            v.t && v.y && (v.c||v.sc) ? do {
                my $title = ar.we && ar.we.t eq v.t && ar.we.y.cv ? "^"
                    : "v.t v.y.cv";
                "C:$title (".$ks->(v.c).")".$ks->(v.sc)
            } :
            "?:".ki $v
        )
        : ref $v || $v
        );
    } @ks;
    join ' ', grep {$_} $m, @l;
HashKs: | # order children, returns $hash,@ks
    # order children
    # use Walks/hord
    my $hord = sub {
        my ($s,$head,$tail) = @_;
        my ($he,$ta) = ([],[]);
        $head ||= [qw't cv y c sc'];
        $tail ||= [qw's z'];
        my $tw;
        for ([$he=>$head],[$ta=>$tail]) {
            my ($to,$k) = @$_;
            for my $t (@$k) {
                $s.>$t || next;
                $tw.>$t ++;
                push @$to, $t;
            }
        }
        my $num = qr/^\-?\d+(\.\d+)?$/;
        my @mi = sort { $a =~ $num && $b =~ $num ? $a <=> $b : $a cmp $b }
            grep { !$tw.>$_ } keys %$s;
        [ map { [ $_ => $s.>$_ ] } @$he, @mi, @$ta ];
    };
    my (@he,@ta);
    push @he, qw't cv y' if c&istycsc || C.sc.istycsc;
    push @ta, qw'c sc' if c&istycsc || C.sc.istycsc;
    push @ta, qw'ip sip ipi T' if (2Cc&istycsc || A.2.C.sc.istycsc) && C.t eq 'c';
    ar.ks = c&ks if c&ks;
    ar.vs = c&vs if c&vs;
    
    my $se = ar.ks ? {map{$_=>shift@{ar.vs}}@{ar.ks}} : $s;
    my @ks = map{$_->[0]}map{@$_} $hord->($se,\@he,\@ta) if ref $se eq 'HASH';
    ($se,@ks)
    
Froth: | # the smaller bits set out 
    my @ks;
    if (!a&keys) {
        (a&key_hash,@ks) = Rw HashKs;
        a&keys = \@ks;
    }
    @ks = @{a&keys};
    n siz=>12=>" x ".@{a&keys},'%hs:283,fs:6';
    if (my $kg = delete A&kg) {
        my @sh;
        @ks = grep {
            if ($kg->($_)) {
                push @sh, $_;
                0
            } 
            else { $_ }
        } @ks;
        if (@sh) {
            a&keys_ig = \@sh;
            n sh=>189=>"sh x".@sh=>'%hs:483,fs:6'
        }
    }
    3Cc&intl++ > 3Cc&intlim && return 
        n more=>4=>"more",'%hs:544'
    
    return #sayre "Cos C&type and so..."
        if C.t =~ /^(up|T)$/
        || ( (c&isA || 2Cc&isA) && C.t =~ /^ii?/)
        #|| ( !2Cc&isarray && C.t =~ /^\d+$/)
        #|| J.A.d > 5
        ;
    
    my $limit = 30;
    my $lim = @ks > $limit;
    my $was = @ks;
    @ks = @ks[0..($limit-1)] if $lim;
    
    my $pi = c&pi || 'od';
    m $_=>''=>{pi=>$pi,s=>a&key_hash ->{$_}},'%ma:1' for @ks;
    
    if (my $h = a&key_oh) {
        for (@$M) {
            my $d = $h.>_.t || next;
            G&oh,$_,$d;
        }
    }
    
    $lim && 
    m limited=>''=>{s=>"Limited from $was to $limit"},{hs=>"888",ws=>1}
Doorin: | # see de/-coda work
    # data
    my $t;
    t.do.eo.ep.fpl.el.f++;
    t.do.r.ep.w.el.f++;
    t.do.eo.e.w.el.f++;
    t.rdo++;
    t.rdoe.r.t++;
    t.rdoe.o = [1,2,3];
    my @x = map { G&Ct,[gluarism=>$_=>{}=>{seo=>eoul=>fi=>3}] } 3..6;
    $t = G&Ct,[glua=>3=>{}=>{z=>[@x],gla=>$t}];
    
    # gets described
    my $i =
    n pud=>-coda=>{s=>$t,tape=>1},'qz'
    my $j = is&J;
    my $f = js&output_file || die "Nofile: ".G&sn,$j;
    
    # < such that our read of it forwards spaceboost
    $s = G&Beach,$f;
    $s = $s->[0] if @$s == 1;
    
     
    my $mode;
    $mode = 'decod';
    
    $mode eq 'od' &&
    n ud => -od => {s=>$s}
    $mode eq 'lod' &&
    n ud => -od => {s=>[ G&ind,$s,'aC' ]}
    if ($mode eq 'decod') {
        my $l = Rw decoda $s;
        my $r = l.y.val;
        my $z = $r;
        #$z = wdump 3, $r;
        m ud => -od => {dl=>5,s=>$z,top=>$l}
        m metaci => -od => {s=>l.y.gets_pw}
    }
pi/coda: | # convey data
    # default hash
    1c&imping++;
    y.at.sym = '[' if ref $s eq 'ARRAY';
    Rw HaveDepth;
    Rw MayC;
    c&path = join'/',grep{defined}2Cc&path,C.t;
    3c&refs.>$s = $C if ref $s;
    c&left = c&dl - c&depth;
    
    if (!Js&boost) {
        if (c&isA && c&left < 2) {
            y.at.sym = s.1 eq $s ? 'J' : 'A';
            n sn=>''=>G&sn,$s  
            n sip=>''=>sc&sip
            return
        }
        if (c&isC && c&left < 4) {
            y.at.sym = 'C';
            n t=>''=>{s=>s.t}
            s.y.cv && s.y.cv != 0.1 &&
            n y_cv=>''=>{s=>s.y.cv}
            for my $k ('c','sc') {
                my $v = $s.>$k;
                if (!keys %$v) {
                }
                elsif (grep{ref}values%$v) {
                    m $k=>-coda=>{s=>$v}
                }
                else {
                    n $k=>4=>{s=>ki $v},{sym=>'ki'}
                }
            }
            return
        }
    }
    
    Rw Fromany;
decoda: | # recode data from -coda C
    # some
    my $top;
    # if top has a yval being like ss&top
    #   it is left to further meta
    top.y.rw = {}; # refs -> $n/-coda non-9s
    top.y.meta_pw = {}; # paths -> $n where meta 
    # top.y.gets_pw   paths -> $n where s&gets
    top.y.val =
    s.y.val = ss&sym eq '[' ? [] : {};
    my @s = ([$top,$s]);
    while (@s) {
        my ($u,$C) = map{@$_} shift @s; # C = -coda 9
        my $uv = C.y.val;
        # C implies cv=1 and two hemispheres
        (uv.y.cv, uv.c, uv.sc) = (0.1, {}, {}) if s&sym eq 'C';
        (uv.y, uv.c, uv.sc) = ($uv, {}, {}) if s&sym eq 'A' || s&sym eq 'J';
        
        # mo C become the hops, 9 C gives over some attr (Scuttle)
        u.sc.sym = s&sym if s&sym;
        for my $n (@{s&z||[]}) {
            my $p = join(' ', grep{defined} C.y.path, n.t);
            my $k = n.t;
            my $v;
            if (ns&pi eq 'coda') {
                my $s = ns&z ->[0];
                $v = s.y.val = ss&sym eq '[' ? [] : {};
                s.y.path = $p;
                push @s, [$C,$s];
            }
            elsif (ns&pi || ns&W) {
                die "Want to decoda C.t's ".ki $n;
            }
            else {
                if (ns&hs) { # coloured things must be talky
                    top.y.mw.>$p = $n;
                    ns&gets = n.t;
                    next;
                }
                
                join('-',sort keys %{n.c}) =~ /^(el)?-?s?$/
                && join('-',sort keys %{n.sc}) =~ /^(gets)?-?(sym)?$/
                || die "More to C.t's ".ki($n)."\n\n"
                  .join('-',sort keys %{n.c})
                  .' % '. join('-',sort keys %{n.sc});
                
                # something to describe yers?
                # to know whats around
                if (ns&sym eq 'ki') {
                    my $h = nc&s;
                    my $ha;
                    $ha.>$1 = $2 while $h =~ s/^ ?(\S+)=(.+?)( (\S+)=|$)/$3/;
                    ns&gets = 'vague' unless $ha && ki($ha) eq nc&s;
                    if (ns&gets eq 'vague') {
                        sayre "vague because: ".ki($ha)."\n eq nc&s";
                    }
                    $v = $ha || $h;
                }
                elsif (ns&sym) {
                    die "Newsym: ns&sym  ".ki$n;
                }
                else {
                    $v = nc&s;
                }
            }
            # index of notes on representation sureity
            top.y.gets_pw.>$p = $n if ns&gets;
            
            # yers notation?
            if (n.t eq 'y_cv' && s&sym eq 'C') {
                uv.y.cv = nc&s;
                next;
            }
            
            #1 && saybl "Putting u.t's(u.sc.sym) C.t's(s&sym) n.t's(ns&sym) ".ki $v;
            #C.t . n.t =~ /22/ && sayre "HAve uval: ".ki $uv;
            if (ref $uv eq 'ARRAY') {
                $uv->[$k] = $v;
            }
            else {
                $uv.>$k = $v;
            }
            top.y.rw.>$v = $n if ref $v;
        }
    }
    $top
   
Fromany: |
    return s&gets = 'floody' if 
        3Cc&intl++ > 3Cc&intlim;
    
    if (ref $s eq 'ARRAY') {
        c&isarray = 1;
        c&vs = [@$s];
        c&ks = [0..(@$s-1)];
    }
    
    my ($hash,@ks) = Rw HashKs;
    my $limit = 60;
    my $lim = @ks > $limit;
    my $was = @ks;
    @ks = @ks[0..($limit-1)] if $lim;
    
    my $pi = c&pi || 'od';
    for (@ks) {
        my $S = $hash.>$_;
        if (!ref $S) {
            m $_=>''=>{s=>$S}
        }
        elsif (my $O = $S eq $s && '.' || 3c&refs.>$S ) {
            m $_=>''=>{}=>{sameas=>ref $O ? Oc&path : $O}
        }
        elsif (my $block = $_ eq 'I' && 'I' || c&depth > c&dl && "deep") {
            my $c = {};
            c.s = ki $S if $block eq 'deep';
            m $_=>''=>$c=>{gets=>$block}
        }
        else {
            m $_=>''=>{pi=>$pi,s=>$S};
        }
    }
    
    $lim && 
    m limited=>''=>"limit: $limit < $was",'hs:888'

