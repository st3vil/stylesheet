
pi/od: | # pud clo
    # recursion
    Rw HaveDepth;
    Rw MayC;
    # ident
    Rw Indentity;
    Rw Trunks;
    
    if (c&block) {
        n block=>2=>c&block,'%hs:855'
        c&blos &&
        n blocked=>21=>' '.c&blos,'%hs:827'
        return
    }
    
    
    # do preliminary identify
    #  with marks that cancel if others supply
    if (c&isC) {
        Rw SeeC;
    }
    elsif (c&isA) {
        Rw SeeA;
    }
    else {
        Rw Sees;
    }
    
    

    s&sy &&
        n sy=>o75=>s&sy=>"%hs:7574,ab:1,poi:0,lh:40%,fs:".int(100 / c&depth)
    delete c&s;
    return if s&return;
    
    # send forth light flames
    Rw Froth;
    
HaveDepth: |
    c&depth = A.2.C.c.depth + 1;
    
    # how many M inners before 'more' (depth first)
    3Cc&intlim ||= 15;
    # max depth before like nothash
    c&dl ||= 2Cc&dl;
    c&dl = 2 if !defined c&dl;
    
    # travel boosts/cons depth
    c&dl += Js&boost * 2 if Js&boost;
    
    a&space = c&dl - c&depth;
    
    y.n = 21;
MayC: |
    if (ref $s eq 'HASH' && defined s.t && s.y && (ref s.c eq 'HASH' || ref s.sc eq 'HASH')) {
        c&istycsc = 1;
        if (s.y ne $s) {
            c&isC = 1;
        }
        else {
            c&isA = 1;
        }
    }
Indentity: | # bit of basket "$ind<" and name of bit there (C.t)
    y.at.qs=1;
    y.at.ws=1;
    y.clos=1;
    my $ind = join'', ('  ') x (c&depth - 1);
    y.at.dis = 1;
    s&dis = 3;
    
    n ind=>o7=>"$ind"
    n sli=>o8=>"<  ",'%hs:784,dos:Crank'
    n t=>1=>"C.t ",'%dos:Crank'
    
Trunks: | # adj depth for shape/truncation of too-hyperlinkage
    # 
    c&dl += 2 if c&depth < 6 && C.t eq 's' && 22Cc&istycsc;
    c&dl -= 3 if C.t eq 'y' && 2Cc&istycsc;
    c&dl += 2 if C.t eq 'in' && A.2.C.t eq 'y' && 22Cc&istycsc;
    # crawling up a long thin trunk
    if (0 && C.t ne 'y' && (c&dl - c&depth) < 1 && 3Cc&intl < (3Cc&intlim / 3)) {
        T wtf
        c&dl += 1;
    }
    
    # above or part of a C/A/s?
    c&block = 'same' if $s eq 2Cc&s && 2Cs&pi eq s&pi ;
    c&block = 'b' if C.t eq 'ip' && A.2.C.t eq 'c';
    # mute bits of the slide that go other fast
    if (!c&block && ref $s eq 'HASH') {
        T hashi
        if (C.t eq 'G') {
            my $w = s.w;
            if (ref $w eq 'CODE' || ref \$w eq 'GLOB') {
                c&block = 'G';
            }
        }
        if (s.y eq $s) {
            c&block = 'yA' if A.2.C.t eq 'y';
            c&block = 'AA' if 2Cc&isA;
            if (c&block) {
                c&blos = G&sn,$s;
            }
        }
    }
SeeC: |
    s&sy = 'C';
    s&return ||= Rw Cpud;
    
    # see the C, calcify it...
    return;
    
    # Quant: if C is t-cs- only, it's an empty-ish layer
    if (G&q,$s,'o?.cs') {
    
    }
    if (ref $s eq 'HASH' && keys %$s < 5 && 
        G&isC,$s) {
        # try
        if (!keys %{s.y} && !keys %{s.sc}
            && keys %{s.c} == 1 && exists s.c.s) {
            n short=>12=>" t: s.t","%hs:457"
            m "c\.s"=>-pud=>{s=>sc&s,ima=>[qw'c s']}
            s&return = 2;
            c&dl += 2;
        }
        s&return ||=
            Rw Cpud;
    }
SeeA: |
    if (s.1 && s.1 eq $s || s.sc && s.sc.n) {
        s&sy = "J";
        s&return ||=
            Rw Jpud;
    }
    else {
        s&sy = 'A';
        s&return ||=
            Rw Apud;
    }
    # T # seen to/from ghost, they osc pool up to direct change in
    # chasing up all the J that hit it
    # osc pool meaning a vortex of self, changes moving upward, 
    # just copying changed hashes - replace {} from changed up to root
    # and copy it in at the other J
Sees: |
    if (ref $s eq 'ARRAY') {
        n is=>11=>'[','%hs:457'
        #C.sc.type = 'array';
        c&isarray = 1;
        c&vs = [@$s];
        c&ks = [0..(@$s-1)];
        if (22Cc&istycsc) {
            if (A.2.C.t eq 'c') {
                c&dl = 1 if C.t eq 'N';
            }
        }
        if (c&depth > c&dl) {
            s&return++;
            n no=>2=>ki($s),'%fs:7,hs:458'
        }
    }
    else {
        if (ref $s ne 'HASH' || c&depth > c&dl) {
            T nonhash
            my $z = s&type eq 'A' ? G&sn,$s
                : ki $s;
            my $bg;
            if (!ref $s) {
                $z =~ s/^!%://;
                $bg = ',bg:653';
                if (!defined $s) {
                    n know=>18=>'undef','%hs:845,fs:6'
                }
                elsif (!length $s) {
                    n know=>18=>"''",'%hs:845,fs:6'
                }
                elsif (c&d < 3) {
                    $z = slim((600 / (c&d||1)),$s);
                }
            }
            elsif (200 < length $z) {
                $z = slim(200,$z);
                n short=>18=>'...','%hs:798,fs:7'
            }
            my $fs = 6;
            $fs = 8 if !ref $s;
            if (2Cc&istycsc) {
                if (C.t eq 't') {
                    $z = $s;
                    $fs = 23;
                }
                if (C.t eq 'y') {
                    T ys
                    my $ig;
                    if (s.cv) {
                        ig.cv++;
                        my $cv = s.cv;
                        $cv =~ s/^0\.//;
                        n cv=>191=>$cv,'%hs:286,fs:12'
                    }
                    $z = Rw yki $s $ig $we:A.2.C.c.s;
                }
            }
            if (22Cc&istycsc) {
                if (A.2.C.t eq 'y') {
                    $fs = 16 if C.t eq 'cv';
                }
            }
            
            sayyl "Zago: $z or $s" if C.t eq 'ago';
            n no=>2=>$z,"%fs:$fs,hs:398,lh:0.9,mh:5$bg,dis:2"
            s&return++;
            return
        }
        if (s.y eq $s && c&depth > c&dl) {
            s&return++;
            n A=>2=>"A s.t s.y.cv; ".ki(s.c)."    ".ki(s.sc);
        }
    }
    
Froth: | # the smaller bits set out 
    my ($hash,@ks) = Rw HashKs;
    n siz=>12=>" x ".@ks,'%hs:283,fs:6';
    if (my $kg = delete A&kg) {
        my @sh;
        @ks = grep {
            if ($kg->($_)) {
                push @sh, $_;
                0
            } 
            else { $_ }
        } @ks;
        @sh &&
        n sh=>189=>"sh x".@sh=>'%hs:483,fs:6';
    }
    3Cc&intl++ > 3Cc&intlim && return 
        n more=>4=>"more",'%hs:544'
    
    return #sayre "Cos C&type and so..."
        if C.t =~ /^(up|T)$/
        || ( (c&isA || 2Cc&isA) && C.t =~ /^ii?/)
        #|| ( !2Cc&isarray && C.t =~ /^\d+$/)
        #|| J.A.d > 5
        ;
    s&css = 'border-left:3px solid 473' if @ks > 3;
    
    my $limit = 30;
    my $lim = @ks > $limit;
    my $was = @ks;
    @ks = @ks[0..($limit-1)] if $lim;
    
    m $_=>-od=>{s=>$hash->{$_}},'%ma:1' for @ks;
    #m "looking: ".$_=>''=>{s=>ki $hash->{$_}} for @ks;
    
    $lim && 
    m limited=>''=>{s=>"Limited from $was to $limit"},{hs=>"888",ws=>1}
Quant: | # FactorEase
    u i
    # matches a C for having only t and cs (etc)
    q: %acgt:s q
        my ($mode) = $q =~ s/^(o)//;
        my ($t) = $q =~ s/^(\?)//;
        my ($y) = $q =~ s/^(\.)//;
        my ($c) = $q =~ s/^c((?:\w+\,?)+)//;
        my ($sc) = $q =~ s/^ s((?:\w+\,?)+)//;
        ($c,$sc) = map { [split ',',$_] } ($c,$sc);
        if ($mode eq 'o') {
            if ($t eq '?') {
                exists s.t || return;
                set.t = s.t;
            }
            !keys %{s.y} || return if $y eq '.';
            !keys %{s.c} || return if !@$c;
            if (@$c) {
                keys %{s.c} == @$c || return;
                exists s.c.>$_ || return for @$c;
            }
            !keys %{s.sc} || return if !@$sc;
        }
        1

