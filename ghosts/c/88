Day: |
    u i
    # see 64 got
    G:
        $G = {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'};
        G.h = G.i.h;
        $G
    # start holding an instruction
    s:
        if (ref $s eq 'HASH' && ref s.y && s.y ne $s) {
            return $s
        }
        $C = {};
        C.t = '';
        C.y = {};
        C.c.s = $s;
        $C;
    # find local things, look up trail of con centers
    t:
        $C = G&s,$s;
        c&on ||= 'ii';
        c&max ||= 5;
        for (1..c&max) {
            return $A->{$_}->{c&on}->{c&s}
                if $A->{$_}
                && $A->{$_}->{c&on} 
                && $A->{$_}->{c&on}->{c&s}
        }
    # make call
    h:
        my $y;
        my $D = T.D if T.D;
        if (ref $s eq 'CODE') {
            $y = $s;
        }
        elsif (!ref $s && A.i && A.i.>$s) {
            $y = A.i.>$s;
        }
        else {
            my $C = G&s,$s;
            c&on = 'i';
            $y = G.i.t->($A,$C,$G,$T,$C);
        };
        $y || die "no h: $s";
        saybl ($D && D.t || $s);
        my @r = eval { $y->($A,$C,$G,$T,@Me) };
        if ($@) {
            if ($@ !~ /Throh/) {
                $D ||= A.i.ii.i.y.tw->{$s};
                saybl D.c.s;
            }
            die "Throh D.y.cv D.t: ".ind('  ',$@)."\n";
        }
        wantarray ? @r : $r[0];
        # see 64 Ngwe
    
    A: %acgt:s ov
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A; # means is full of wires
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            A.up = $i;
            A.c.ip = [@{A.up.c.ip||[]}, A.up.c.ipi++];
            A.c.sip = join',',@{A.c.ip};
            A.1 = $A;
        }
        if ($ov) {
            $ov /= 10 while $ov >= 1;
            A.c.ov = $ov;
            if (@Me) {
                A.c.N = \@Me;
            }
            G&throat,A.t;
        }
        return $A
Tube: |
    u i
    # go A
    throat:
        my $of = G&s,$s;
        of.c.of ||= of.c.s;
        of.c.max = 2;
        my $z = G&t,$of || return;
        snooze 1500;
        my $uov = A.c.ov;
        $C = A.c.s ||= {};
        $T = A.c.T ||= {};
        my $ntug = 0.1;
        while ($z) {
            say "Onto z.t z.y.cv";
            next if z.c.W;
            next if z.y.cv <= A.y.cv;
            last if $uov && z.y.cv > $uov;
            if (A.c.tug && $ntug <= z.y.cv) {
                $ntug += 0.1 until $ntug > z.y.cv;
                G&tug ;
            }
            my @is = (A.c.N || $z);
            
            # z wants C
            if (z.sc.nk) {
                exists $C->{z.sc.nk} || next;
                @is = $C->{z.sc.nk};
                if (z.sc.gk) {
                    exists $C->{z.sc.nk}->{z.sc.gk} || next;
                    @is = $C->{z.sc.nk}->{z.sc.gk};
                }
            }
            if (z.sc.sk) {
                exists C.sc->{z.sc.sk} || next;
                @is = C.sc->{z.sc.sk};
            }
            if (z.sc.t) {
                my $sc = z.sc;
                ref sc.ip eq 'HASH' || die "Dsct ip not: ".ki$z;
                G&ip,\$sc,$C || next;
            }
            if (z.sc.Ifs) {
                die "A impli";
                @is = G&scIfs,z.sc.Ifs;
            }
            
            # z readies
            if (z.sc.acgt && !z.c.code) {
                my $y = eval z.c.s;
                die "Throcompile of.t z.y.cv: z.t: ".ind('  ',$@)."\n" if $@;
                z.c.code = $y;
            }
            
            # happens
            for my $s (@is) {
                z.sc.acgt eq 's' || die "nonacgts".wdump $z;
                T.D = $z;
                my $y = z.c.code;
                
                G.i.h->($A,$C,$G,$T,$y,$s);
                
                T.ut && G&Tut,$s;
                T.Z && G&Tz,$z;
                last if T.not || T.whack;
            }
            # back
            delete T.ut;
            
            A.y.cv = z.y.cv;
            last if delete T.whack || T.not;
        }
        continue {
            $z = z.y.next; # or timeout, mass comb via A.m
        }
        # leaving
        A.c.tug && G&tug;
        delete A.c.ov;
        # TODO cycle all A.c.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    
    
of: |
    # indifferent index
    # receivers always new C.c for compile ref
Tunnel: |
    # machine for finding pi
    u a
    # dialect of ...
    u 1:
        A.3 = shift @$s; # for
        A.2 = G&sJ,A.3,'u';
    u 2:
        my $u = A.c.u;
        if (u.c.o) {
            G&sesh,A.2;
            # o is the J's orderliness mark
            # also its current position relative to itself
            # make many pages of u per A.3
        }
    u 3:
        my $n = A.c.n = G&A,n=>1=>A.2,@$s;
        n.c.u.c.whole = 'theu';
        G&A,$n,3;
    n 1:
        A.2 = shift @$s;
        A.c.u = G&sJ,A.2,'u';
        A.c.n = G&sJ,A.2,'n';
    n 2:
        my $u = A.c.u;
        if (!u.c.o) {
            u.c.base = 'theu'; # the PiMachine
            # resolve our mind
            G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 2
            G&A,o=>8=>A.2,$u,$_ for 'i','ii';
        }
        A.i = A.2.i;
        A.ii = A.2.ii;
        A.c.V = [ map{ G&s,$_ } @$s ];
    n 3:
        my $n = A.c.n;
        n.sc.a->{A.2.c.ch}->{A.c.sip} = $A;
        delete A.2.c.o;
    n 4:
        # become aware of past, surface vibration
    n 5:
        # more thinks
    n 6:
        G&A,mo=>6;
        # etc
    n 7:
        #
    mo 1:
        # sprung from n/author, separate put words...
        if (my $V = A.up.c.V) {
            A.m = $A;
            saybl "For ".wdump 8, $V;
            my $mo = G&A,mo=>1;
            mo.mo = $mo;
            A.c.tug->{mo.c.sip} = $mo;
        }
    u i
    Tnot:
        # kills a particle
    Tz: %acgt:D
        # moves/spawns in time
        die "A.t 's D.y.cv~D.t TZ moved C.y.cv~C.t ".wdump 3, T.Z;
    tug:
        # just before m (over many) mo 4, do inner mo up to 4
        
        
    u O
    of: %of:O
        #n $s=>''=>{W=>'of'}
        say "OFing ! C.t C.y.cv ".ki C.sc;
        # compile language, see 9 cono
        # container process is traveling bunches of code, see 99 Traweil
        # place toward A.ii.>$s, linked list of embryo
        
        # rennovating around town
        # a geodesic self-mover
        # keeps rebuilding in different locations
        
        
Jelly: |
    u i
    sJ: %acgt:J t f
        $f ||= $t;
        J.sc.>$t ||= G&J,$f;
    J:
        my $J = G&A,'J';
        J.t = $s;
        # will be bab to G&
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; G&A,u=>6=>$J,\@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; G&A,n=>6=>$J,\@Me };
        $J
    
    sesh: %acgt:J
        # partition guts
        my $o = J.sc.S->{J.sc.ch} = G&sJ,$J,'s';
        delete J.sc.s;
        my $ch = ++J.sc.ch;
        my $s = J.sc.s = J.sc.S->{$ch} ||= G&sJ,$J,'s';
        o.sc.next = $s;
        s.sc.prev = $o;
        # makes osc thing.3 etc hang around
        s.sc.ch = $ch;
    
    rea: %acgt:J
        # reset the ground
        my $zi = ++J.c.zi;
        my $ch = '';
        my $lim = 2;
        while (J.sc.n->{$ch}) {
            J.sc.Z->{$zi}->{$ch} = delete J.sc.n->{$ch};
            if ($zi > $lim) {
                delete J.sc.Z->{$zi-$lim}
            }
            $ch++;
        }
    
    u c
    n \'of:mo'
    pi 12:
        c&pin = "pi/$pi";
    W 12:
        ref $s && die;
        c&J = $s;
        # dhcp replanty A.c.ip
    J 2:
        # see self already
        s&J ||= A.2.sc.tv && A.2.sc.tv->{C.t} && A.2.sc.tv->{C.t}->{C.y.cv};
        # or force a...
    J 3:
        s&J ||= G&J,C.t;
    pi 3:
        my $J = s&J;
        J.c.d = A.2.c.d + 1;
        J.sc.name = "J.c.d $pi*C.t";
        # distance from A.3 as ip
    u s
    n \'of:mo'
    # to rm ^ make the of rememberer D not leave between the o switchup of u others
    J 4:
        # humming - superline timetug - osc exports that door us here
        # outside the fully self/u mind
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        # T wants ha or v wants T (by now, etc)
        # travel comes down ch-switches even if pin skips
    J 5:
        A.c.pin = c&pin || c&J || sc&J ->{t};
    J 6:
        J.sc.n && G&rea,$J;
        J.sc.u && G&rea,J.sc.u;
        J.sc.root = G&A,n=>1=>[J.t=>0.9];
        Rw A.c.pin - $A $C $G $T $J $y;
        
    J 7:
        G&A,s=>8=>$J;
    J 8:
        # through J's microJ of personality
    
Triangle: |
    u a
    # sevenatim
    # time passes independently of your being in the room (once you know about the room)
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # C is self for s
        # C is 's many for o
        A.c.s = G&sJ,A.2,'s';
    s 2:
        my $s = A.c.s;
        if (my $W = s.c.whole) {
            my $s = G&t,$W || die "no $W";
            # o it to here, as wh spacing desires
            # i subs copy same 4
            # ii linked D list per 2
            return T.Z.8 = $A;
        }
        if (my $W = s.c.base) {
            my $s = G&t,$W || die "no $W";
            # o it to here, with us overlaid
            # mix into indexes under anything from us
        }
        my $n = A.c.n;
        c&a = n.sc.a; # ch/sip = A (n/author)
        my $ch = defined s&ch ? s&ch : A.2.sc.ch || '';
        my $flux = c&a ->{$ch};
        saybl "Incoming flux: ".wdump 4, $flux;
        
        # names -> A fall replace to check inside
        # A -> J t/y images
    s 3:
        # J t/y awakens
    s 4:
        # pieces sorted
    s 5:
        # go made
    s 6:
        # going
    s 7:
        # back with goods
    s 8:
        A.2.sc.tv = s&tv;
        # send out
    # listen, insward, moral law, has to give us power
    o 1:
        A.3 = shift @$s; # us
        A.c.z = G&sJ,A.3,'s';
        A.2 = shift @$s; # from
        A.c.s = G&sJ,A.2,'s';
        A.c.V = [ map { _.t ||= _.c.s } map{ G&s,$_ } @{A.c.N} ];
    o 2:
        #G&A,$_=>
        say "Hi";
    
Rise: |
    u i
    top:
        my $J = G.c.o ||= G&J,'o';
        
    
    
    
    
    
    
    
    
    
    
    #
Round: |
    u urw
    # stash something in the wormhole
    my $N =
    [Boodle=>9=>{}=>{z=>[
        [u=>1=>{W=>'of'},{z=>[
            [sayhi=>3=><<'','%of:u,act:1']
                say "Hi";
    
        ]
    ]}];
    
    insertmind:
        my $u = J.sc.u ||= G&A,L=>1;
        u.4 = u.3 = $u;
        
    
    
    n do=>5=>'toott'
    
    
    
    
    
    
    
    
    n someh=>3=>"Dwo ".rand(4)
    
    
    
    
    Rw waito $J $d=3
    
    #
PiMachine: |
    n Day
    n Tube
    
    n Tunnel
    n Jelly
    n Triangle
Zupe: |
    u urw
    my $ii = {};
    my $dig = sub {
        my $tW = shift;
        $tW = {%{$tW}};
        $tW->{$_} = readlink "w/digway/$_" for keys %$tW;
        $tW;
    };
    my $ol = LoadFile('w/glacwal');
    if (ki($ol) ne ki($dig->($ol))) {
    sayre "Zupe unstuck: \n".ki($ol)."\n ne\n".ki($dig->($ol));
    my $it = 'Day';
    $it = 'PiMachine';
    n $it
    my $jt = G.oin.inJ;
    my $Day = $jt->{$it};
    my $tW = {};
    my $su;$su = sub {
        my $J = shift;
        my $v = J.El.Pre.tv || die "J.name no tv";
        map { _.sc.J ? ($_,$su->(_.sc.J)) : $_ }
        grep { _.y.cv < 0.9 || do{$tW->{_.t} = $_; 0} } values %$v;
    };
    my $N = [$su->($Day)];
    my $v = {}; # of/cv/t acum
    my $M = [map {
        Rw ym/conoi $noAI=1 $C:_ $v;
    } @$N];
    DumpFile('w/glacwal',$dig->($tW));
    DumpFile('w/glacval',$v);
    }
    
    my $v = LoadFile('w/glacval');
    for my $of (keys %$v) {
        my $o = $ii->{$of} = {t=>'of',y=>{cv=>0.1},c=>{W=>'of'}};
        my $c = $v->{$of};
        my $la = $o;
        for my $cv (sort keys %$c) {
            my $ts = $c->{$cv};
            for my $t (sort keys %$ts) {
                my $z = $ts->{$t};
                sayre "Compile $of $cv $t !";
                z.c.s = G&parse_babbl,z.c.s;
                z.c.s =~ s/\bs\&(\w+)/C\&$1/g;
                my $y = eval z.c.s;
                die "Throcompile of.t z.y.cv: z.t: "
                    .ind('  ',$@)."\n" if $@;
                z.c.code = $y;
                   la.y.next = $z;
                z.y.prev = $la;
                $la = $z;
            }
        }
    }
    
    my $i = {};
    my $n = ii.i;
    while ($n) {
        if (n.c.code) {
            $i->{n.t} = n.c.code;
            ii.i.y.tw->{n.t} = $n;
        }
        $n = n.y.next;
    }
    
    my $so = do {
        my $A = {};
        A.i = $i;
        A.ii = $ii;
        my $G = A.i.G->($A,$C,$G,$T);
        sayre "Yep";
        $A = G&A,'so';
        my $J = G&J,'os';
        A.4 = A.3 = A.2 = $A;
        $DB::single = 1;
        n ows
    };
    
    #n Bud
    #n Round
    #!##
    n wk=>-pre=>wdump(6, $so),'%hs:375'
    #n wk=>-pud=>{s=>$so},'%hs:375,ws,wi:30%'
    J.VV.N = 1;
    
    
pi/pud: |
    y.at.qs=1;
    y.at.ws=1;
    #y.at.ml=J.A.d;
    y.in = 0.2;
    my $ind = join'', ('  ') x (J.A.d - 1);
    n la=>''=>"\n$ind< C.t";
    if ($s eq J.Jiter.C.c.s) {
        n same=>2=>'same','%hs:855'
        return
    }
    if (ref $s ne 'HASH' || J.A.d > 5) {
        my $z = wdump(2, $s);
        $z = $s if C.t eq 't';
        n no=>2=>$z,'%fs:5,hs:394,lh:0.8em,ab,mt:1'
        return;
    }
    my @ks = sort keys %$s;
    n siz=>12=>" x ".@ks,'%hs:283,fs:6';
    if (J.mo.J.C.c.intl++ > 40) {
        return
        n 'more'=>''=>"more",'%hs:544';
    }
    return if C.t =~ /^(\d+|ii?)$/;
    m $_=>-pud=>{s=>$s->{$_}}, for @ks;
    
Zuup: |
    n Zupe
Zop: |
    J.VV.N = 1;
    u Traweil
    
    n Zoop=>W=>'%isle:go'
    
Zoop: |
    n PiMachine
a: | # act
    u allact
    n allact
    n 'allareact=1'=>42,<<''
        C.sc.act = 1 if !exists C.sc.act;
        C.sc.code = C.t if !exists C.sc.code;
i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
c: | # of something c.? acts
    n allc
s: | # of something sc.? acts
    n alls
    
Doy: |
    u urw
    u unicrow
    u curv=>-curv=><<''
        zoom 0 1.2
        y    0  0
        x    0  0.02
        curve 0 -0.2
        zoom 0.01 1.6
        curve 0.2 -0.1
        zoom 0.3 0.8
        spin 0.3 2
        zoom 0.38 1.4
        curve 0.4 1.3
        zoom 35 2
    
    J.VV.N = 1;
    my $at = 8000 + int rand(4203);
    n good=>[-dot=>0.02]=>$at
    n bad =>[-dot=>0.04]=>$at
    
    
    y.in = 1;
    y.out = 8;
    for (1..22) {
        m $_,'',{loug=>$at,hsb=>376}
    }
    
good: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=good $s:do.c.s;
    
bad: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=bad $s:do.c.s;
    
AddToMy: |
    my $l = "w/T/C.t/$l";
    G&wraf,$l,$s
    
Dool: |
    u urw
    
    my @la = shuffle `cat w/T/Doy/good`;
    chomp for @la;
    
    m lang=>-langi=>$_ for @la[0..1];
pi/langi: |
    u Phi
    u unicrow
    y.at.width = '50%';
    y.at.height = '50%';
    
    y.clos = 1;
    y.in = 0.1;
    y.out = 0.9;
    n bit=>'1-9x30'=>{loug=>$s+4},'%phi,cola:654'
    
    n '.'=>'2-5x10'=>'@','%phi,fs:30,cola:3'
    
    
    
    
    
Not: |
    u urw
    u Phi
    u curv=>-curv=><<''
        zoom 0 1
        curve 4 -0.1
    
    n m=>1=>'moere'
    
    y.in = 2;
    y.out = 8;
    my $which = 3 > rand 5 ? 'not' : 'g/N/Z';
    my $not = J.note||=[ shuffle split /\n\s*\n/, ''.`cat $which` ];
    my @in;
    push @in,
        grep{!/\/\w+\/|https?:/}
        shift @$not
        until sum(map{length}@in) > 80;
    @in = map{split/\s+/} @in;
    
    m s=>''=>$_=>{fs=>40, cola=>1} for @in;
    
NotPhi: |
    my $phi = sub {
        my $s = shift;
        $s = {n=>1,cv=>$s} if !ref $s;
        my $n = s.n || 9;
        s.w ||= 100;
        s.h ||= 100;
        my $cx = s.x || (s.w / 2);
        my $cy = s.y || (s.h / 2);
        my $lg_diam = s.w * 0.85;
        my $lg_rad = $lg_diam / 2;
        my $outer_rad = s.w * 0.45;
        my $angle_incr = s.ai || 9 / $n;
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              $ratio = s.cv if s.cv;
              my $spiral_rad = ($ratio *1.43) * $outer_rad;
              my $angi = $angle_incr + 1.15;
              my $angle = 0.3 + $i *$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  rad => sprintf('%.4f', atan2($x - $cx, $y - $cy)),
                # angle => sprintf('%.3f', $angle),
                  x => sprintf('%.4f', $x/100),
                  y => sprintf('%.4f', $y/100),
              };
          }
          wantarray ? @$xy : $xy->[0]
    };
    
    my $x;
    x.n = @in;
    my @phi = $phi->($x);
    
    m s=>''=>$_=>{geo=>G&here2geo,shift@phi ,fs=>40, cola=>1} for @in;
Phi: |
    u allsvse
    #n Spirals
    n \'of:Mo'
    
    cola 5:
        my $start = $cola || 1;
        $start *= 10;
        
        my @ay = ($1, split'',$1) if C.y.pcv =~ /\.(\d+)/;
        C.sc.hs = join' ', map {
            my $o = shift @ay;
            $o += 2;
            $o *= $start;
            $o /= 100 until $o < 100;
            int $o;
        } 1..3;
        C.sc.sha = '3 4 8 248';
    
unicrow: |
    u allc
    n \'of:Mo'
    J.VV.N = 1;
    
    loug 44:
        my ($tin) = C.y.pcv =~ /(\d\d)$/;
        c&s = encode_entities unico $loug + $tin;
        C&ht = 1;
    
    hsb 45:
        my ($t,$in) = C.y.pcv =~ /(\d)(\d)$/;
        my @hs = split '', $hsb;
        $hs[0] += $in * 3;
        $hs[1] += $t * 3;
        for my $y (0,1) {
            $hs[$y] -= 9 while $hs[$y] > 9;
            $hs[$y] += 9 while $hs[$y] < 1;
        }
        C&fs = 8 * $in + 3;
        #C&ml = 1 * $in;
        C&zi = $in;
        C&hs = join '', @hs;

