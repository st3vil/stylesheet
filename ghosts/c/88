Day: |
    u i
    # see 64 got
    G:
        {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'}
    # start holding an instruction
    s:
        if (ref $s eq 'HASH' && s.t && ref s.y && s.y ne $s) {
            return $s
        }
        $C = {};
        C.t = '';
        C.y = {};
        C.c.s = $s;
        $C;
    # find local things, look up trail of con centers
    t:
        $C = G&s,$s;
        c&on ||= 'ii';
        c&max ||= 5;
        for (1..c&max) {
            return $A->{$_}->{c&on}->{c&s}
                if $A->{$_}
                && $A->{$_}->{c&on} 
                && $A->{$_}->{c&on}->{c&s}
        }
    # make call
    h:
        my $y;
        my $D = T.D if T.D;
        if (ref $s eq 'CODE') {
            $y = $s;
        }
        elsif (!ref $s && A.i && A.i.>$s) {
            $y = A.i.>$s;
        }
        else {
            my $C = G&s,$s;
            c&on = 'i';
            $y = G.i.t->($A,$C,$G,$T,$C);
        };
        $y || die "no h: $s";
        eval { my @r = $y->($A,$C,$G,$T,@Me) };
        die "Throh D.y.cv D.t: ".ind('  ',$@)."\n" if $@;
        @r
        # see 64 Ngwe
    
    
    Rw MoreHands;
    
    A: %acgt:s ov
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A; # means is full of wires
            A.c = {};
            A.sc = {};
            A.up = $i;
            A.1 = $A;
        }
        if ($ov) {
            $ov /= 10 while $ov >= 1;
            A.c.ov = $ov;
            if (@Me) {
                A.c.N = \@Me;
            }
            G&throat,A.t;
        }
Tube: |
    u i
    # go A
    throat:
        my $of = G&s,$s;
        of.c.of ||= of.c.s;
        of.c.max = 2;
        my $z = G&t,$of || return;
        
        my $uov = A.c.ov;
        $C = A.c.s ||= {};
        $T = A.c.T ||= {};
        
        while (1) {
            last if $uov && z.y.cv > $uov;
            my @is = (A.c.N || $z);
            
            # z wants C
            if (z.sc.nk) {
                exists $C->{z.sc.nk} || next;
                @is = $C->{z.sc.nk};
                if (z.sc.gk) {
                    exists $C->{z.sc.nk}->{z.sc.gk} || next;
                    @is = $C->{z.sc.nk}->{z.sc.gk};
                }
            }
            if (z.sc.sk) {
                exists C.sc->{z.sc.sk} || next;
                @is = C.sc->{z.sc.sk};
            }
            if (z.sc.t) {
                my $sc = z.sc;
                ref sc.ip eq 'HASH' || die "Dsct ip not: ".ki$z;
                G&ip,\$sc,$C || next;
            }
            if (z.sc.Ifs) {
                die "A impli";
                @is = G&scIfs,z.sc.Ifs;
            }
            
            # z readies
            if (z.sc.acgt && !z.c.code) {
                my $y = eval z.y.s;
                die "Throcompile of.t z.y.cv: z.t: ".ind('  ',$@)."\n" if $@;
                z.c.code = $y;
            }
            
            # happens
            for my $s (@is) {
                z.sc.acgt eq 's' || die "nonacgts".wdump $z;
                T.D = $z;
                my $y = z.sc.code;
                
                G.i.h->($A,$C,$G,$T,$y,$s);
                
                if (T.ut) {
                    G&Tut,$s;
                }
                if (T.Z) {
                    die "A.t 's z.y.cv~z.t TZ moved C.y.cv~C.t ".wdump 3, T.Z;
                }
                last if T.not || T.whack;
            }
            # back
            delete T.ut;
            
            A.cv = z.y.cv;
            last if delete T.whack || T.not;
            $z = z.y.next || last; # or timeout, mass comb via A.m
            
        }
        # TODO cycle all A.c.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    
    
of: |
    # indifferent index
    # receivers always new C.c for compile ref
Tunnel: |
    # machine for finding pi
    u i
    sJ: %acgt:J t f
        $f ||= $t;
        J.sc.>$t ||= G&J,$f;
    sesh:
        # partition guts, makes osc thing.3 etc hang around
        # base remains
    u a
    J 2:
        my $J = G&A,J=>1;
        J.t = $s;
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; G&A,u=>6=>$J,@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; G&A,n=>6=>$J,@Me };
        $J
    # dialect of ...
    n 1:
        A.2 = shift @$s;
        A.c.u = G&sJ,A.2,'u';
        A.c.n = G&sJ,A.2,'n';
    u 1:
        A.3 = shift @$s;
        A.2 = G&sJ,A.3,'u';
    n 2:
        my $u = A.c.u; # bab Acu$
        u.c.o || G&A,s=>7=>$u;
        G&A,o=>8,A.2,$u,'i','ii';
        A.c.V = [ map{ G&s,$_ } @{A.c.N} ];
    n 3:
        my $n = A.c.n;
        n.sc.a.This = $A;
    u 2:
        my $u = A.c.u;
        u.c.o && G&sesh,$u;
        A.c.V = [ map{ G&s,$_ } @{A.c.N} ];
    # sevenatim
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # come into self again by A.2.sc.s
        A.c.s = G&sJ,A.2,'s';
    s 2:
        my $n = A.c.n;
        c&a = n.sc.a;
        # names -> A fall replace to check inside
        # A -> J t/y images
    s 3:
        # J t/y awakens
    s 4:
        # pieces sorted
    s 5:
        # go made
    s 6:
        # going
    s 7:
        # back with goods
    s 8:
        # send out
    # insward, moral law, has to give us power
    o 1:
        A.3 = shift @$s;
        A.2 = shift @$s;
    o 2:
        G&mo,$_=>
    
    markactive 13:
        A.c.o = 1;
        # spawn A of In, enter C into the vector
        # see 1 Shelf/Cone
    u:
        # soft-figure mind
    un:
        # called when n after u
        # collapse J's microJ of personality
        # see 2 uCon
    u O
    of:
        n $s=>''=>{W=>'of'}
        # compile language, see 9 cono
        # container process is traveling bunches of code, see 99 Traweil
        # place toward A.ii.>$s, linked list of embryo
        
        
Rise: |
    u i
    top:
        my $J = G.c.o ||= G&J,'o';
        
    
    
    
    
    
    
    
    
    
    
    #
Round: |
    u urw
    # stash something in the wormhole
    my $N =
    [Boodle=>9=>{}=>{z=>[
        [u=>1=>{W=>'of'},{z=>[
            [sayhi=>3=><<'','%of:u,act:1']
                say "Hi";
    
        ]
    ]}];
    
    insertmind:
        my $u = J.sc.u ||= G&A,L=>1;
        u.4 = u.3 = $u;
        
    
    
    n do=>5=>'toott'
    
    
    
    
    
    
    
    
    n someh=>3=>"Dwo ".rand(4)
    
    
    
    
    Rw waito $J $d=3
    
    #
Zupe: |
    u urw
    n Bud
    n Round
    #!##
    my $jt = G.oin.inJ;
    #my $Day = jt.Day;
    m wk=>-pre=>wdump(3, [J.A.I, J.A.II]),'%hs:375'
    
Zop: |
    J.VV.N = 1;
    u Traweil
    
    n Zoop=>W=>'%isle:go'
    
Zoop: |
    n Day

i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
Doy: |
    u urw
    u unicrow
    u curv=>-curv=><<''
        zoom 0 1.2
        y    0  0
        x    0  0.02
        curve 0 -0.2
        zoom 0.01 1.6
        curve 0.2 -0.1
        zoom 0.3 0.8
        spin 0.3 2
        zoom 0.38 1.4
        curve 0.4 1.3
        zoom 35 2
    
    J.VV.N = 1;
    my $at = 8000 + int rand(4203);
    n good=>[-dot=>0.02]=>$at
    n bad =>[-dot=>0.04]=>$at
    
    
    y.in = 1;
    y.out = 8;
    for (1..22) {
        m $_,'',{loug=>$at,hsb=>376}
    }
    
good: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=good $s:do.c.s;
    
bad: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=bad $s:do.c.s;
    
AddToMy: |
    my $l = "w/T/C.t/$l";
    G&wraf,$l,$s
    
Dool: |
    u urw
    
    my @la = shuffle `cat w/T/Doy/good`;
    chomp for @la;
    
    m lang=>-langi=>$_ for @la[0..1];
pi/langi: |
    u Phi
    u unicrow
    y.at.width = '50%';
    y.at.height = '50%';
    
    y.clos = 1;
    y.in = 0.1;
    y.out = 0.9;
    n bit=>'1-9x30'=>{loug=>$s+4},'%phi,cola:654'
    
    n '.'=>'2-5x10'=>'@','%phi,fs:30,cola:3'
    
    
    
    
    
Not: |
    u urw
    u Phi
    u curv=>-curv=><<''
        zoom 0 1
        curve 4 -0.1
    
    n m=>1=>'moere'
    
    y.in = 2;
    y.out = 8;
    my $which = 3 > rand 5 ? 'not' : 'g/N/Z';
    my $not = J.note||=[ shuffle split /\n\s*\n/, ''.`cat $which` ];
    my @in;
    push @in,
        grep{!/\/\w+\/|https?:/}
        shift @$not
        until sum(map{length}@in) > 80;
    @in = map{split/\s+/} @in;
    
    m s=>''=>$_=>{fs=>40, cola=>1} for @in;
    
NotPhi: |
    my $phi = sub {
        my $s = shift;
        $s = {n=>1,cv=>$s} if !ref $s;
        my $n = s.n || 9;
        s.w ||= 100;
        s.h ||= 100;
        my $cx = s.x || (s.w / 2);
        my $cy = s.y || (s.h / 2);
        my $lg_diam = s.w * 0.85;
        my $lg_rad = $lg_diam / 2;
        my $outer_rad = s.w * 0.45;
        my $angle_incr = s.ai || 9 / $n;
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              $ratio = s.cv if s.cv;
              my $spiral_rad = ($ratio *1.43) * $outer_rad;
              my $angi = $angle_incr + 1.15;
              my $angle = 0.3 + $i *$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  rad => sprintf('%.4f', atan2($x - $cx, $y - $cy)),
                # angle => sprintf('%.3f', $angle),
                  x => sprintf('%.4f', $x/100),
                  y => sprintf('%.4f', $y/100),
              };
          }
          wantarray ? @$xy : $xy->[0]
    };
    
    my $x;
    x.n = @in;
    my @phi = $phi->($x);
    
    m s=>''=>$_=>{geo=>G&here2geo,shift@phi ,fs=>40, cola=>1} for @in;
Phi: |
    u allsvse
    #n Spirals
    n \'of:Mo'
    
    cola 5:
        my $start = $cola || 1;
        $start *= 10;
        
        my @ay = ($1, split'',$1) if C.y.pcv =~ /\.(\d+)/;
        C.sc.hs = join' ', map {
            my $o = shift @ay;
            $o += 2;
            $o *= $start;
            $o /= 100 until $o < 100;
            int $o;
        } 1..3;
        C.sc.sha = '3 4 8 248';
    
unicrow: |
    u allc
    n \'of:Mo'
    J.VV.N = 1;
    
    loug 44:
        my ($tin) = C.y.pcv =~ /(\d\d)$/;
        c&s = encode_entities unico $loug + $tin;
        C&ht = 1;
    
    hsb 45:
        my ($t,$in) = C.y.pcv =~ /(\d)(\d)$/;
        my @hs = split '', $hsb;
        $hs[0] += $in * 3;
        $hs[1] += $t * 3;
        for my $y (0,1) {
            $hs[$y] -= 9 while $hs[$y] > 9;
            $hs[$y] += 9 while $hs[$y] < 1;
        }
        C&fs = 8 * $in + 3;
        #C&ml = 1 * $in;
        C&zi = $in;
        C&hs = join '', @hs;

