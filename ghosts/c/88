Day: |
    u s
    # see 64 got
    G:
        {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'}
    # start holding an instruction
    s:
        if (ref $s eq 'HASH' && s.t && ref s.y && s.y ne $s) {
            return $s
        }
        $C = {};
        C.t = '';
        C.y = {};
        C.c.s = $s;
        $C;
    # find local things, look up trail of con centers
    t:
        $C = G&s,$s;
        c&on ||= 'ii';
        c&max ||= 5;
        my $wh;
        for (1..c&max) {
            $C = $A->{$_}
              && $A->{$_}->{c&on} 
              && $A->{$_}->{c&on}->{c&s} || next;
            $wh = $_;
            last;
        }
        $wh || return;
        c&wh ||= $wh;
        $C
    h:
        my $y = !ref $s && A.i && A.i.>$s || do {
            $C = G&s,$s;
            c&on = 'i';
            $C = G.i.t->($A,$C,$G,$T,$C);
            c&s
        };
        $y || die "no h: $s";
        $y->($A,$C,$G,$T,@Me);
        # see 64 Ngwe
    
    
    Rw MoreHands;
    
    # go A
    throat:
        my $of = G&s,$s;
        of.c.of ||= of.c.s;
        of.c.max = 2;
        my $z = G&t,$of || return;
        my $uov = A.c.ov;
        while (1) {
            if ($z wants $C) {
                my $yt = z.sc.yt;
                G&$yt,C.sc.interesting;
            }
            $z = z.y.next || last; # or timeout
        }
        # TODO cycle all A.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    J:
        my $J = G&A,J=>1;
        J.t = $s;
        J.sc.u = sub { G&u,@_ };
        J.sc.n = sub { G&n,@_ };
        
    A: %acgt:s ov
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A; # means is full of wires
            A.c = {};
            A.sc = {};
            A.up = $i;
        }
        if ($ov) {
            $ov = 0 + '0'.G&sca,$ov if $ov >= 1;
            A.c.ov = 0 + $ov;
        }
        
    n:
        my $n = G&A,n=>1;
        my $u = A.sc.u; # pronounce ayousk, youok
        if ($u && !u.c.o) {
            G&A,osc=>9;
        }
        
        # spawn A of In, enter C into the vector
        # see 1 Shelf/Cone
    u:
        # soft-figure mind
    un:
        # called when n after u
        # collapse J's microJ of personality
        # see 2 uCon
    u O
    of:
        # compile language, see 9 cono
        # container process is traveling bunches of code, see 99 Traweil
        # place toward A.ii.>$s, linked list of embryo
        
        
n: |
    u s
    n:
        $A = G&A,n=>1;
        A.N = \@Me;
    u a
    in 1:
        ref _.t eq '
Rise: |
    u i
    top:
        my $J = G.c.o ||= G&J,'o';
        
    
    
    
    
    
    
    
    
    
    
    #
Round: |
    u urw
    # stash something in the wormhole
    my $N =
    [Boodle=>9=>{}=>{z=>[
        [u=>1=>{W=>'of'},{z=>[
            [sayhi=>3=><<'','%of:u,act:1']
                say "Hi";
    
        ]
    ]}];
    
    insertmind:
        my $u = J.sc.u ||= G&A,L=>1;
        u.4 = u.3 = $u;
        
    
    
    n do=>5=>'toott'
    
    
    
    
    
    
    
    
    n someh=>3=>"Dwo ".rand(4)
    
    
    
    
    Rw waito $J $d=3
    
    #
Zupe: |
    u urw
    n Bud
    n Round
    #!##
    my $jt = G.oin.inJ;
    #my $Day = jt.Day;
    m wk=>-pre=>wdump(3, [J.A.I, J.A.II]),'%hs:375'
    
Zop: |
    J.VV.N = 1;
    u Traweil
    
    n Zoop=>W=>'%isle:go'
    
Zoop: |
    n Day
MoreHands: |
    # complicates h and 
    h: %arounds:-1
        push @{A.sc.hs||=[]}, "h $s: ".join' ', (caller($b))[0,3,2];
        my @r = eval { 
        # &
        };
        pop @{A.sc.hs};
        $@ && $s ne 'bang' && G&bang;
        @r
    bang:
        # zig zag report stitched onto happenings' branches
s: | # ACGTs sub for h
    n allacgts
    u O
    arounds 4:
        # look for C.t in already entered stuff
        
i: | # 
O: | # s&OSCillators
    n allsvse
Doy: |
    u urw
    u unicrow
    u curv=>-curv=><<''
        zoom 0 1.2
        y    0  0
        x    0  0.02
        curve 0 -0.2
        zoom 0.01 1.6
        curve 0.2 -0.1
        zoom 0.3 0.8
        spin 0.3 2
        zoom 0.38 1.4
        curve 0.4 1.3
        zoom 35 2
    
    J.VV.N = 1;
    my $at = 8000 + int rand(4203);
    n good=>[-dot=>0.02]=>$at
    n bad =>[-dot=>0.04]=>$at
    
    
    y.in = 1;
    y.out = 8;
    for (1..22) {
        m $_,'',{loug=>$at,hsb=>376}
    }
    
good: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=good $s:do.c.s;
    
bad: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=bad $s:do.c.s;
    
AddToMy: |
    my $l = "w/T/C.t/$l";
    G&wraf,$l,$s
    
Dool: |
    u urw
    
    my @la = shuffle `cat w/T/Doy/good`;
    chomp for @la;
    
    m lang=>-langi=>$_ for @la[0..1];
pi/langi: |
    u Phi
    u unicrow
    y.at.width = '50%';
    y.at.height = '50%';
    
    y.clos = 1;
    y.in = 0.1;
    y.out = 0.9;
    n bit=>'1-9x30'=>{loug=>$s+4},'%phi,cola:654'
    
    n '.'=>'2-5x10'=>'@','%phi,fs:30,cola:3'
    
    
    
    
    
Not: |
    u urw
    u Phi
    u curv=>-curv=><<''
        zoom 0 1
        curve 4 -0.1
    
    n m=>1=>'moere'
    
    y.in = 2;
    y.out = 8;
    my $which = 3 > rand 5 ? 'not' : 'g/N/Z';
    my $not = J.note||=[ shuffle split /\n\s*\n/, ''.`cat $which` ];
    my @in;
    push @in,
        grep{!/\/\w+\/|https?:/}
        shift @$not
        until sum(map{length}@in) > 80;
    @in = map{split/\s+/} @in;
    
    m s=>''=>$_=>{fs=>40, cola=>1} for @in;
    
NotPhi: |
    my $phi = sub {
        my $s = shift;
        $s = {n=>1,cv=>$s} if !ref $s;
        my $n = s.n || 9;
        s.w ||= 100;
        s.h ||= 100;
        my $cx = s.x || (s.w / 2);
        my $cy = s.y || (s.h / 2);
        my $lg_diam = s.w * 0.85;
        my $lg_rad = $lg_diam / 2;
        my $outer_rad = s.w * 0.45;
        my $angle_incr = s.ai || 9 / $n;
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              $ratio = s.cv if s.cv;
              my $spiral_rad = ($ratio *1.43) * $outer_rad;
              my $angi = $angle_incr + 1.15;
              my $angle = 0.3 + $i *$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  rad => sprintf('%.4f', atan2($x - $cx, $y - $cy)),
                # angle => sprintf('%.3f', $angle),
                  x => sprintf('%.4f', $x/100),
                  y => sprintf('%.4f', $y/100),
              };
          }
          wantarray ? @$xy : $xy->[0]
    };
    
    my $x;
    x.n = @in;
    my @phi = $phi->($x);
    
    m s=>''=>$_=>{geo=>G&here2geo,shift@phi ,fs=>40, cola=>1} for @in;
Phi: |
    u allsvse
    #n Spirals
    n \'of:Mo'
    
    cola 5:
        my $start = $cola || 1;
        $start *= 10;
        
        my @ay = ($1, split'',$1) if C.y.pcv =~ /\.(\d+)/;
        C.sc.hs = join' ', map {
            my $o = shift @ay;
            $o += 2;
            $o *= $start;
            $o /= 100 until $o < 100;
            int $o;
        } 1..3;
        C.sc.sha = '3 4 8 248';
    
unicrow: |
    u allc
    n \'of:Mo'
    J.VV.N = 1;
    
    loug 44:
        my ($tin) = C.y.pcv =~ /(\d\d)$/;
        c&s = encode_entities unico $loug + $tin;
        C&ht = 1;
    
    hsb 45:
        my ($t,$in) = C.y.pcv =~ /(\d)(\d)$/;
        my @hs = split '', $hsb;
        $hs[0] += $in * 3;
        $hs[1] += $t * 3;
        for my $y (0,1) {
            $hs[$y] -= 9 while $hs[$y] > 9;
            $hs[$y] += 9 while $hs[$y] < 1;
        }
        C&fs = 8 * $in + 3;
        #C&ml = 1 * $in;
        C&zi = $in;
        C&hs = join '', @hs;

