Day: |
    u i
    # see 64 got
    G:
        {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'}
    # start holding an instruction
    s:
        if (ref $s eq 'HASH' && s.t && ref s.y && s.y ne $s) {
            return $s
        }
        $C = {};
        C.t = '';
        C.y = {};
        C.c.s = $s;
        $C;
    # find local things, look up trail of con centers
    t:
        $C = G&s,$s;
        c&on ||= 'ii';
        c&max ||= 5;
        for (1..c&max) {
            return $A->{$_}->{c&on}->{c&s}
                if $A->{$_}
                && $A->{$_}->{c&on} 
                && $A->{$_}->{c&on}->{c&s}
        }
    # make call
    h:
        my $y;
        my $D = T.D if T.D;
        if (ref $s eq 'CODE') {
            $y = $s;
        }
        elsif (!ref $s && A.i && A.i.>$s) {
            $y = A.i.>$s;
        }
        else {
            my $C = G&s,$s;
            c&on = 'i';
            $y = G.i.t->($A,$C,$G,$T,$C);
        };
        $y || die "no h: $s";
        eval { my @r = $y->($A,$C,$G,$T,@Me) };
        die "Throh D.y.cv D.t: ".ind('  ',$@)."\n" if $@;
        @r
        # see 64 Ngwe
    
    A: %acgt:s ov
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A; # means is full of wires
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            A.up = $i;
            A.c.ip = [@{A.up.c.ip||[]}, A.up.c.ipi++];
            A.c.sip = join',',@{A.c.ip};
            A.1 = $A;
        }
        if ($ov) {
            $ov /= 10 while $ov >= 1;
            A.c.ov = $ov;
            if (@Me) {
                A.c.N = \@Me;
            }
            G&throat,A.t;
        }
        A.9 || $A
Tube: |
    u i
    # go A
    throat:
        my $of = G&s,$s;
        of.c.of ||= of.c.s;
        of.c.max = 2;
        my $z = G&t,$of || return;
        
        my $uov = A.c.ov;
        $C = A.c.s ||= {};
        $T = A.c.T ||= {};
        my $ntug = 0.1;
        while (1) {
            next if z.y.cv <= A.y.cv;
            last if $uov && z.y.cv > $uov;
            A.c.tug && $ntug <= z.y.cv && G&tug;
            my @is = (A.c.N || $z);
            
            # z wants C
            if (z.sc.nk) {
                exists $C->{z.sc.nk} || next;
                @is = $C->{z.sc.nk};
                if (z.sc.gk) {
                    exists $C->{z.sc.nk}->{z.sc.gk} || next;
                    @is = $C->{z.sc.nk}->{z.sc.gk};
                }
            }
            if (z.sc.sk) {
                exists C.sc->{z.sc.sk} || next;
                @is = C.sc->{z.sc.sk};
            }
            if (z.sc.t) {
                my $sc = z.sc;
                ref sc.ip eq 'HASH' || die "Dsct ip not: ".ki$z;
                G&ip,\$sc,$C || next;
            }
            if (z.sc.Ifs) {
                die "A impli";
                @is = G&scIfs,z.sc.Ifs;
            }
            
            # z readies
            if (z.sc.acgt && !z.c.code) {
                my $y = eval z.y.s;
                die "Throcompile of.t z.y.cv: z.t: ".ind('  ',$@)."\n" if $@;
                z.c.code = $y;
            }
            
            # happens
            for my $s (@is) {
                z.sc.acgt eq 's' || die "nonacgts".wdump $z;
                T.D = $z;
                my $y = z.sc.code;
                
                G.i.h->($A,$C,$G,$T,$y,$s);
                
                T.ut && G&Tut,$s;
                T.Z && G&Tz,$s;
                last if T.not || T.whack;
            }
            # back
            delete T.ut;
            
            A.y.cv = z.y.cv;
            last if delete T.whack || T.not;
            $z = z.y.next || last; # or timeout, mass comb via A.m
        }
        # leaving
        delete A.c.ov;
        # TODO cycle all A.c.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    
    
of: |
    # indifferent index
    # receivers always new C.c for compile ref
Tunnel: |
    # machine for finding pi
    u a
    # dialect of ...
    n 1:
        A.2 = shift @$s;
        A.c.u = G&sJ,A.2,'u';
        A.c.n = G&sJ,A.2,'n';
    u 1:
        A.3 = shift @$s; # for
        A.2 = G&sJ,A.3,'u';
    n 2:
        my $u = A.c.u;
        if (!u.c.o) {
            u.c.base = 'theu';
            # resolve our (A.2 J) mind (its u J)
            G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 2
            G&A,o=>8,A.2,$u for 'i','ii';
        }
        A.c.V = [ map{ G&s,$_ } @{A.c.N} ];
    u 2:
        my $u = A.c.u;
        if (u.c.o) {
            G&sesh,A.2;
            # o is the J's orderliness mark
            # also its current position relative to itself
            # make many pages of u per A.3
        }
    n 3:
        my $n = A.c.n;
        n.sc.a->{A.2.c.ch}->{A.c.sip} = $A;
        delete A.2.c.o;
    u 3:
        my $n = A.c.n = G&A,n=>1=>A.2,@$s;
        n.c.u.c.whole = 'theu';
        G&A,$n,3;
    n 4:
        # become aware of past, surface vibration
    n 5:
        # more thinks
    n 6:
        G&A,'mo'=>6;
    n 7:
        
    mo 1:
        # sprung from n/author, separate put words...
        if (my $V = A.up.c.V) {
            A.c.V = $V;
            A.m = $A;
            my $mo = G&A,mo=>1;
            mo.mo = $mo;
            A.c.tug->{mo.c.sip} = $mo;
        }
    u i
    Tnot:
        # kills a particle
    Tz:
        # moves/spawns in time
        die "A.t 's z.y.cv~z.t TZ moved C.y.cv~C.t ".wdump 3, T.Z;
    u O
    of:
        n $s=>''=>{W=>'of'}
        # compile language, see 9 cono
        # container process is traveling bunches of code, see 99 Traweil
        # place toward A.ii.>$s, linked list of embryo
        
        # rennovating around town
        # a geodesic self-mover
        # keeps rebuilding in different locations
        
        
Jelly: |
    u i
    sJ: %acgt:J t f
        $f ||= $t;
        J.sc.>$t ||= G&J,$f;
    J:
        my $J = G&A,'J';
        J.t = $s;
        # will be bab to G&
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; G&A,u=>6=>$J,\@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; G&A,n=>6=>$J,\@Me };
        $J
    
    sesh: %acgt:J
        # partition guts
        my $o = J.sc.S->{J.sc.ch} = G&sJ,$s,'s';
        delete J.sc.s;
        my $ch = ++J.sc.ch;
        my $s = J.sc.s = J.sc.S->{$ch} ||= G&sJ,$J,'s';
        s.sc.prev = $o;
        o.sc.next = $s;
        # makes osc thing.3 etc hang around
        J.sc.s.sc.ch = $ch;
    
    rea: %acgt:J
        # reset the ground
        my $zi = ++J.c.zi;
        my $ch = '';
        my $lim = 2;
        while (J.sc.S->{$ch}) {
            J.sc.Z->{$zi}->{$ch} = delete J.sc.S->{$ch};
            if ($zi > $lim) {
                delete J.sc.Z->{$zi-$lim}
            }
            $ch++;
        }
    
    u c
    n \'of:mo'
    pi 12:
        c&pin = "pi/$pi";
    W 12:
        ref $s && die;
        c&J = $s;
        # dhcp replanty A.c.ip
    J 2:
        # see self already
        s&J = A.2.sc.tv && A.2.sc.tv->{C.t} && A.2.sc.tv->{C.t}->{C.y.cv};
        # or force a...
    J 3:
        s&J ||= G&J,C.t;
    pi 3:
        my $J = s&J;
        J.c.d = A.2.c.d + 1;
        J.sc.name = "J.c.d $pi*C.t";
        # distance from A.3 as ip
    u s
    n \'of:mo'
    # to rm ^ make the of rememberer D not leave between the o switchup of u others
    J 4:
        # humming - superline timetug - osc exports that door us here
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        # T wants ha or v wants T (by now, etc)
        # travel comes down ch-switches even if pin skips
    J 5:
        A.c.pin = c&pin || c&J || sc&J ->{t};
    J 6:    
        G&rea,$J
    J 7:
        G&A,s=>8=>$J;
    J 8:
        # through J's microJ of personality
    
Triangle: |
    # sevenatim
    # time passes independently of your being in the room (once you know about the room)
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # come into self again by A.2.sc.s
        A.c.s = G&sJ,A.2,'s';
    s 2:
        if (my $W = s.c.whole) {
            my $s = G&t,$W || die "no $W";
            # o it to here, as wh spacing desires: i subs copy same G
            return T.Z.8 = $A;
        }
        my $n = A.c.n;
        c&a = n.sc.a; # ch/sip = A (n/author)
        c&ch = s&ch || A.2.sc.ch || 
        
        # names -> A fall replace to check inside
        # A -> J t/y images
    s 3:
        # J t/y awakens
    s 4:
        # pieces sorted
    s 5:
        # go made
    s 6:
        # going
    s 7:
        # back with goods
    s 8:
        A.2.sc.tv = s&tv;
        # send out
    # listen, insward, moral law, has to give us power
    o 1:
        A.3 = shift @$s;
        A.c.z = G&sJ,A.3,'s';
        A.2 = shift @$s; # from
        A.c.s = G&sJ,A.2,'s';
        A.c.V = [ map { _.t ||= _.c.s } map{ G&s,$_ } @{A.c.N} ];
    o 2:
        G&mo,$_=>
    
Rise: |
    u i
    top:
        my $J = G.c.o ||= G&J,'o';
        
    
    
    
    
    
    
    
    
    
    
    #
Round: |
    u urw
    # stash something in the wormhole
    my $N =
    [Boodle=>9=>{}=>{z=>[
        [u=>1=>{W=>'of'},{z=>[
            [sayhi=>3=><<'','%of:u,act:1']
                say "Hi";
    
        ]
    ]}];
    
    insertmind:
        my $u = J.sc.u ||= G&A,L=>1;
        u.4 = u.3 = $u;
        
    
    
    n do=>5=>'toott'
    
    
    
    
    
    
    
    
    n someh=>3=>"Dwo ".rand(4)
    
    
    
    
    Rw waito $J $d=3
    
    #
Zupe: |
    u urw
    n Bud
    n Round
    #!##
    my $jt = G.oin.inJ;
    #my $Day = jt.Day;
    m wk=>-pre=>wdump(3, [J.A.I, J.A.II]),'%hs:375'
    
Zop: |
    J.VV.N = 1;
    u Traweil
    
    n Zoop=>W=>'%isle:go'
    
Zoop: |
    n Day
i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
Doy: |
    u urw
    u unicrow
    u curv=>-curv=><<''
        zoom 0 1.2
        y    0  0
        x    0  0.02
        curve 0 -0.2
        zoom 0.01 1.6
        curve 0.2 -0.1
        zoom 0.3 0.8
        spin 0.3 2
        zoom 0.38 1.4
        curve 0.4 1.3
        zoom 35 2
    
    J.VV.N = 1;
    my $at = 8000 + int rand(4203);
    n good=>[-dot=>0.02]=>$at
    n bad =>[-dot=>0.04]=>$at
    
    
    y.in = 1;
    y.out = 8;
    for (1..22) {
        m $_,'',{loug=>$at,hsb=>376}
    }
    
good: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=good $s:do.c.s;
    
bad: |
    my $do = e&hC ->[1];
    Rw AddToMy $l=bad $s:do.c.s;
    
AddToMy: |
    my $l = "w/T/C.t/$l";
    G&wraf,$l,$s
    
Dool: |
    u urw
    
    my @la = shuffle `cat w/T/Doy/good`;
    chomp for @la;
    
    m lang=>-langi=>$_ for @la[0..1];
pi/langi: |
    u Phi
    u unicrow
    y.at.width = '50%';
    y.at.height = '50%';
    
    y.clos = 1;
    y.in = 0.1;
    y.out = 0.9;
    n bit=>'1-9x30'=>{loug=>$s+4},'%phi,cola:654'
    
    n '.'=>'2-5x10'=>'@','%phi,fs:30,cola:3'
    
    
    
    
    
Not: |
    u urw
    u Phi
    u curv=>-curv=><<''
        zoom 0 1
        curve 4 -0.1
    
    n m=>1=>'moere'
    
    y.in = 2;
    y.out = 8;
    my $which = 3 > rand 5 ? 'not' : 'g/N/Z';
    my $not = J.note||=[ shuffle split /\n\s*\n/, ''.`cat $which` ];
    my @in;
    push @in,
        grep{!/\/\w+\/|https?:/}
        shift @$not
        until sum(map{length}@in) > 80;
    @in = map{split/\s+/} @in;
    
    m s=>''=>$_=>{fs=>40, cola=>1} for @in;
    
NotPhi: |
    my $phi = sub {
        my $s = shift;
        $s = {n=>1,cv=>$s} if !ref $s;
        my $n = s.n || 9;
        s.w ||= 100;
        s.h ||= 100;
        my $cx = s.x || (s.w / 2);
        my $cy = s.y || (s.h / 2);
        my $lg_diam = s.w * 0.85;
        my $lg_rad = $lg_diam / 2;
        my $outer_rad = s.w * 0.45;
        my $angle_incr = s.ai || 9 / $n;
          my $xy = [];
          for my $i (1..$n) {
              my $ratio = $i/$n;
              $ratio = s.cv if s.cv;
              my $spiral_rad = ($ratio *1.43) * $outer_rad;
              my $angi = $angle_incr + 1.15;
              my $angle = 0.3 + $i *$angi;
              my $x = $cx + cos($angle) * $spiral_rad;
              my $y = $cy + sin($angle) * $spiral_rad;
              push @$xy, {
                  rad => sprintf('%.4f', atan2($x - $cx, $y - $cy)),
                # angle => sprintf('%.3f', $angle),
                  x => sprintf('%.4f', $x/100),
                  y => sprintf('%.4f', $y/100),
              };
          }
          wantarray ? @$xy : $xy->[0]
    };
    
    my $x;
    x.n = @in;
    my @phi = $phi->($x);
    
    m s=>''=>$_=>{geo=>G&here2geo,shift@phi ,fs=>40, cola=>1} for @in;
Phi: |
    u allsvse
    #n Spirals
    n \'of:Mo'
    
    cola 5:
        my $start = $cola || 1;
        $start *= 10;
        
        my @ay = ($1, split'',$1) if C.y.pcv =~ /\.(\d+)/;
        C.sc.hs = join' ', map {
            my $o = shift @ay;
            $o += 2;
            $o *= $start;
            $o /= 100 until $o < 100;
            int $o;
        } 1..3;
        C.sc.sha = '3 4 8 248';
    
unicrow: |
    u allc
    n \'of:Mo'
    J.VV.N = 1;
    
    loug 44:
        my ($tin) = C.y.pcv =~ /(\d\d)$/;
        c&s = encode_entities unico $loug + $tin;
        C&ht = 1;
    
    hsb 45:
        my ($t,$in) = C.y.pcv =~ /(\d)(\d)$/;
        my @hs = split '', $hsb;
        $hs[0] += $in * 3;
        $hs[1] += $t * 3;
        for my $y (0,1) {
            $hs[$y] -= 9 while $hs[$y] > 9;
            $hs[$y] += 9 while $hs[$y] < 1;
        }
        C&fs = 8 * $in + 3;
        #C&ml = 1 * $in;
        C&zi = $in;
        C&hs = join '', @hs;

