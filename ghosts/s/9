


ElvisWhole: | # o replicates C tv,i,ii
    my $t = Rw Telvis;
    # feed J.sc.ii onto s.sc.ii without osc
    # see ii as a vortex including tv
    # even lv
    # whose objects we copy, since y.in
    
    if ($n == 0) {
        c&te =
        n ElvisWhob
        t.cs->('sc lastK c s','source');
        
        my $W = t.ntos->(c&te,'J');
        my $ii = W.sc.ii;
        t.cs->({s=>t.anii->($ii)},'source ii');
        
        ii.men.y.oun = ii.seg;
        ii.men.y.tw.singing.y.monic = ii.seg.y.tw.eye;
        ii.whatever = ii.seg.y.tw.ran;
        
        # is A, see for C too
        c&te = $W;
        c&ot = 'whole';
        c&ocv = 7;
        
        t.es->("See somewhat");
        
        my $uu = J.sc.ii;
        t.cs->({s=>t.anii->($uu)},'destination ii');
        
        is uu.men.y.oun, uu.seg, "men youn = seg";
        is uu.men.y.tw.singing.y.monic,
            uu.seg.y.tw.eye,
            "men singing ymonic = seg eye";
        isnt uu.seg, ii.seg, 'seg not seg';
        isnt uu.men.y.tw.singing, ii.men.y.tw.singing,
            'men singing not men singing';
        
        is uu.whatever, uu.seg.y.tw.ran, "whatever can be seg ran";
        isnt uu.whatever, ii.whatever, "whatever not whatever";
    }
    elsif ($n == 1) {
        # is C, we arg m=A to get understandings
        c&te = A.ii.theu;
        c&ot = 'whole';
        c&ocv = 7;
        t.toc.m = 'A';
        my $i = c&oi = G&Ct,[receiver=>5=>{s=>'whatisnow'},{efopia=>'n'}];
        ok !i.sc.ii, "i no ii yet";
        t.es->("A whole thing"=>''=>{grepl=>sub {
            s/ z\+\d+ /?z?/;
            $_[0] =~ /W\+of|  xot/;
        }});
        my $ii = i.sc.ii;
        ok $ii, "i has ii";
        isnt ii.D, A.ii.D, "D not D";
        isnt ii.i.y.tw.xot, A.ii.i.y.tw.xot, "xot not xot";
    }
    elsif ($n == 2) {
        c&te =
        n ElvisNothing
        
        t.cs->('sc lastK c s','ElvisNothing with it');
        my $mo = t.ntos->(c&te,'mo');
        my $W = t.ntos->(c&te,'J');
        is mo.ii, W.ii, "mo\.ii is J\.ii";
        is mo.ii.mo, W.ii.mo, "mo\.ii\.mo is J\.ii\.mo";
        isnt mo.ii, A.ii, "mo\.ii ! A\.ii";
        isnt mo.ii.mo, A.ii.mo, "mo\.ii\.mo ! A\.ii\.mo";
        isnt mo.ii.mo.y.in, A.ii.mo.y.in, "moiimoyin not Aiimoyin";
        my $traces = qr/^\S.+has:| xot| FindMeWhenYoure/;
        
        my $lmo = t.anii->(mo.ii);
        @$lmo = grep /$traces/, @$lmo;
        t.cs->({s=>$lmo},'source ii');
    }
    elsif ($n == 3) {
        c&te =
        n ElvisThinker
        
        t.cs->('sc lastK c s','ElvisThinker with it');
        my $mo = t.ntos->(c&te,'mo');
        my $W = t.ntos->(c&te,'J');
        is mo.ii, W.ii, "mo\.ii is J\.ii";
        is mo.ii.mo, W.ii.mo, "mo\.ii\.mo is J\.ii\.mo";
        isnt mo.ii, A.ii, "mo\.ii ! A\.ii";
        isnt mo.ii.mo, A.ii.mo, "mo\.ii\.mo ! A\.ii\.mo";
        isnt mo.ii.mo.y.in, A.ii.mo.y.in, "moiimoyin not Aiimoyin";
        my $traces = qr/^\S.+has:| xot| FindMeWhenYoure/;
        
        my $lmo = t.anii->(mo.ii);
        @$lmo = grep /$traces/, @$lmo;
        t.cs->({s=>$lmo},'source ii');
    }
ElvisNothing: |
    n nothi=>3=>'e'
ElvisWhob: |
    n do=>1
    my $mod = sub {
        my $of = shift;
        n /(.+)-()(.+)/,'%of:'.$of for @_
    };
    $mod->(qw{seg ran-dome eye-stuff taking-sat to-places});
    $mod->(qw{men singing-bride of-south east-cs});
    # random ii
    u alact
    n \'of:mo'
    duire 3:
        # pieces
    n \'of:u'
    moreso 2:
        # moreso
ElvisEltus: | # J u n u n, again and again
    my $t = Rw Telvis;
    
    my $joint = sub {
        my @l;
        ok(J.uosc,"have J(4)uosc");
        for (0..5) {
            my $s = J.uosc.>$_;
            J.firsj.>$n ||= $s;
            my $zo = s.c.zip.c.s.c.s;
            push @l, "$_: $s (ch:s.sc.ch)  ";
            next if !ref $zo eq 'HASH';
            for my $gi (sort keys %$zo) {
                my $o = $zo.>$gi;
                my $c = o.c.s;
                my $gl = c.c.m eq 'zip' ? t.grimd->( c.c.s )
                    : [ki c.c.s];
                push @l, "  $_ - $gi:  ", @$gl;
                
            }
        }
        \@l
    };
    if ($n == 0) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        isnt W.ii, J.ii, 'dif ii';
        
        my $lmo = t.anii->(J.firstuoscii = W.sc.u.sc.s.sc.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source u osc ii');
        J.joints.1 = $joint->();
        t.cs->({s=>J.joints.1},'pages of u s');
        push @{J.upageS||=[]}, {%{ W.sc.u.sc.S }};
    }
    if ($n == 1) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        isnt W.ii, J.ii, 'dif ii';
        
        my $lmo = t.anii->(W.sc.u.sc.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source u ii');
        
        is (J.firstuoscii, W.sc.u.sc.s.sc.ii, "Still u osc ii");
        my $lmo = t.anii->(W.sc.u.sc.s.sc.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source u osc ii');
        J.joints.2 = $joint->();
        t.cs->({s=>J.joints.2},'pages of u s');
        
        # TODO ids dont sync?
        # first first page of u's s is lost, next times it works
        t.cs->({rsl=>[map{@$_}map{J.joints.>$_ }1,2]},'two runs of pages of u s?');
        push @{J.upageS||=[]}, {%{ W.sc.u.sc.S }};
        
        is scalar(uniq(map{values %$_}@{J.upageS})), 5, 'five waves of u';
    }
    if ($n == 2) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        push @{J.upageS||=[]}, {%{ W.sc.u.sc.S }};
        
        is scalar(uniq(map{values %$_}@{J.upageS})), 5, 'five waves of u';
    }
    if ($n == 3) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
    }
ElvisEltussock: |
    J.4.uosc.0 = J.sc.u.sc.s;
    1 && sayyl "Time ".J.bowls++." is J.sc.ch";
    n alof
    J.4.uosc.1 = J.sc.u.sc.s;
    u alact
    tracks:
        # towards
    J.4.uosc.2 = J.sc.u.sc.s;
    five 5:
        5
    u alacgts
    zo:
        # hop
    J.4.uosc.3 = J.sc.u.sc.s;
    u alact
    zow:
        # hop
    J.4.uosc.4 = J.sc.u.sc.s;
    u alacgts
    zorw:
        # hop
    J.4.uosc.5 = J.sc.u.sc.s;
ElvisDialects: | # J u Dialect, deeply rooted # TODO TODO TODO
    my $t = Rw Telvis;
    #A.V = 1;
    #A.nowholeyet = 1;
    # if n (alof) before u (alact) then las
    
    # localised implica expanded into universal (still localised)
    # eg make everything acgt:s
    
    # how to isolate pure data entry from Jing
    # encode not sJ or anywhere in the mo that sJ:
    # so our J/their our-minded parts (eg n root) dont get the encoding
    
    #  # may want to use a clear head at mo J 5, ie
    # takes our readings of impulse in 4 to the control dome
    # J inter language space of 5, the permissions, net gear
    # so could A.ii = A.5.ii and T.seek=1 re G&t the throat
    # and eg the root n in J 6 will be a normal op
    
    #  # decompression wants to live in of=D and be for nonJ
    # and be the thing knowing/isolating a ghost
    # making A.D = receipt for the pin/scheme/O cause/elvis handling
    # or the convo/dialect state applied within
    # falling A bounds like .mo:
    
    # U al4noJ 3 spawns our encoding on the J6ing.mo:
    #     A.D = {self,J=A.D}
    #         marking D above ours (unless already) as the norm for doing J
    # then mo dome 2:
    #    A.D = A.D.J if c&J && A.D && A.D.J;
    #       peels off encodings/holes to A.mo.up.mo's intention
    #         for this A.mo, so it can speak nonJ n normally
    #   runs D
    #        with A.D for direction/self
    # and U al4noJ 7:
    #    finishes our encoding
    
    # D may make good interface to pages to reset (when J 6)
    # or unrestart (when S sleeps)
    # or partition (with names) and despatch to whatever process
    
    # so encodings should all of=D
    # a W reverses line protocols from remote stream
    # via m into golden box acum space
    # fills <5 at lum top, 8-9 lum/3, 7-8 lum/7, etc towards 555555555555
    # into streams of atoms for your A.3 to officially reposition
    # there's a ghost bridge
    
    # of=U = runs when mind made up/down
    # of=M = for the $M produced by 6, incs depth of atoms
    # of=S = check for escaping gas (sleeps minor changes)
    
    # A.2 to change to A.1 whenever
    
    # but for now:
    # the encodings are all in 42-43, which s& or cv=9 skips over
    # could be more pronounced how its not for J or its descendants
    #  by hanging encodings on/in an A.D, which replants at 6
    #  until that J brings its own mind onto the A
    # simple stuff should work
    
    my $Jay;
    G.tuberay = sub {
        my ($A,$C,$G,$T) = @_;
        $Jay || return;
        Jay.sc.ch ne '' && die "Jayscch changed: Jay.sc.ch";
    } if 0;
    
    if ($n == 0) {
        my $ec;
        ec.popi = t.popi;
        ec.popl.0 = "before any";
        # theu leaves ii, mo alof in ground, u s but not zip
        ec.popl.1 = "first n, normal mind"; 
        ec.popl.2 = "first u, mind still normal";
        # al* appears in mind
        ec.popl.3 = "n aft u";
        # new bit of u ground + blank u s for next page
        ec.popl.4 = "second u";
        ec.popl.5 = "finality";
        c&te =
        n ElvisDialecto=>W=>$ec
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $traces = qr/^\S.+has:| al\w+ 0/;
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /$traces/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        ok !W.ii.42, "Stuff in W not as W's mind";
    }
    elsif ($n == 1) {
        my $ec;
        ec.popi = t.popi;
        # has J.ii with alacgts from last round
        # we would be using A.ii from above
        # and u osc would be the whole=theu which skips zip
        ec.popl.0 = "reset ground, last u osc";
        ec.popl.1 = "first n, normal mind";
        ec.popl.2 = "first u, mind still normal";
        # al* appears in mind
        ec.popl.3 = "n aft u";
        # new bit of u ground + blank u s for next page
        ec.popl.4 = "second u";
        
        ec.popl.5 = "finality";
        c&te =
        n ElvisDialecto=>W=>$ec
        t.cs->('sc lastK c s','dialected change stuff');
        # see the W.sc.ii produced by W
        t.cs->({s=>t.lookii->()},'have ii');
        # see the W.ii used by W
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep {/^\S.+has:| al\w+ 0/} @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        ok !W.ii.42, "Stuff in W not as W's mind";
    }
    elsif ($n == 2) {
        c&te =
        n ElvisDialecto
        t.cs->('sc lastK c s','dialect changes');
    }
    elsif ($n == 3) {
        c&te =
        n ElvisDialectos
        t.cs->('sc lastK c s','u Cee with i things once collasped in pin');
        t.cs->('sc lastA 2 sc u sc ii i y tw rand,nonext','see i rand');
        # T # the kind that keeps a fork waiting,
        # does the new ghost's remainder of this way, lexicals -> $ar
        # and maybe knows how to serve data/analysis forms to pud,
        # which keeps running in the end of the first run
    }
ElvisDialectos: |
    u Cee
    n $_=>2=>$_ for "Doowop";
    n $_ eq 4 && 3 || $_=>'3'.$_ => G&rand,7  for 1..7;
ElvisDialecto: | # TODO n alof before u alact drops stuff
    my $for = sub {
        my $i = shift;        
        c&popi && c&popl.>$i && c&popi ->($J,$i,$C);
    };
    
    $for->(0);
    n alof
    $for->(1);
    if (J.bowls++ < 2) {
        u alact
    }
    else {
        u alacgts
    }
    $for->(2);
    my $hum = ',cr:ab' if J.bowls > 1;
    jasm: %fo:late$hum
        # rubbing
    $for->(3);
    joints: %fo:river,of:42
        "southward $s"
    n \'of:not'
    semio:
        # tic tic;sdigjshgisdf
    u alacgts
    $for->(4);
    # no mind after first run...
    sedio:
        # tic tic
    $for->(5);
    

ElvisWay: | # J new Rw pin getter, 
    my $t = Rw Telvis;
    A.uyes = 1;
    #A.V = 1;
    if ($n == 0) {
        c&te =
        n ElvisWays
        t.cs->('sc lastK c s y l y tw w,nonext','ways of=w');
        t.cs->({s=>t.lookii->()},'have ii');
    }
    if ($n == 1) {
        my $h;
    
        c&te = 
        n ElvisWhay
        t.cs->('sc lastK c s','way holder, nothing with no cs');
        t.cs->('sc lastA 2 ii w,nonext','is holding shu');
        my $W = t.ntos->(c&te,'J');
        is W.t, 'ElvisWhay', 'Have holder J';
        is W.ii.w && W.ii.w.y.in.t, 'shu', 'Have shu in J';
        h.5 = $W;
        
        c&te = 
        n ElvisNotWhay
        t.cs->('sc lastA 2 ii w,nonext','Another holder');
        my $W = t.ntos->(c&te,'J');
        is W.t, 'ElvisNotWhay', 'Another holder 2 J';
        h.4 = $W;
        
        #W.ii = W.sc.ii;
        # ^ doesn't break W, is J, bystander/particle to A
        # those serving t must be holding it as .ii
        # T.o.J.t.ElvisWayer = G&Ct,'In5'=>3=>{inet=>5,s=>$J
        
        c&te = 
        n ElvisWaying=>W=>{house=>$h}
        t.cs->('sc lastK c s','looks of Elvis Waying');
        t.cs->({s=>t.lookii->()},'have no ii of waying');
        # 
    }
ElvisWaying: |
    n some=>1=>here
    my $Gw = G.w;
    G.w = A.i.w;
    G&xot,$A,$_ for c&house || die "Give house";
    A.5.ii && A.5.ii.w || die "House no w: ".wdump 1, A.5.ii;
    
    Rw shu + $C $nos:A.2 $job=0 etc;
    # ^ babs to:
    # $G->{w}->($A,$C,$G,$T,"lingophase",$ar,C=>$C,nos=>$A->{2},job=>"0",m=>["etc"]);
    Rw shu + $C $nos:A.2 $job=3;
    # the + mixes in ar at the front, becomes m[] if elsewhere
    Rw lingophase $C $nos:A.2 $noj=C.y.cv;
    
    Rw thinelse $C $nos:A.2 $noj=C.y.cv;
    
    G.w = $Gw;
    my $i = 2;
    n looks=>$i++=>{s=>"$_: ".C.sc.>$_ } for grep {!ref C.sc.>$_ } sort keys %{C.sc};
    
ElvisNotWhay: |
    u ElvisNotWays
    n othing=>1
ElvisNotWays: |
    #u alway
    # passed through of uncoded
    lingophase: %of:w
        C.sc.lingo = 'first phase';
    thinelse: %of:w
        C.sc.nothin = 'elsey';
ElvisWhay: |
    u ElvisWays
    n othing=>1
ElvisWays: |
    #u alway
    # passed through of uncoded
    shu: %of:w
        s&op = 3;
        s&mind = 'with arm' if ar.m;
        s&mindo = 'without arm' if !ar.m;
        s&job = join ' ',grep{defined} s&job, ar.job if defined ar.job;
    lingophase 3: %of:w
        s&lingo = 'second phase';
    
ElvisThinks: | # J uses u (mind), does stuff with it
    my $t = Rw Telvis;
    A.uyes = 1;
    if ($n == 0) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker made with mind');
        t.cs->('sc lastA 2 sc u sc s sc ii eloquence,nonext','J u s ii eloquence');
        t.cs->({ntos=>'sc lastA 2 sc u sc s sc ii mo',
            nonext=>1,grepl=>sub{ $_[0] =~ /^\s+(fis|fscolour) / }
        },'J u s ii mo seems to be');
        
        my $mo = t.ntos->(c&te,'mo');
        
        is mo.t, 'mo', 'mot is mo';
        is mo.2.t, 'ElvisThinker', 'mo2t is ElvisThinker';
        is mo.2.sc.u.t, 'u', 'ut is u';
        my $usii = mo.2.sc.u.sc.ii;
        is ref $usii, 'HASH', 'ii is hash';
        for my $t (qw'eloquence mo') {
            my $is = $usii.>$t;
            is ref $is, 'HASH', "usii $t";
            for (qw'tv tw in') {
                is ref is.y.>$_, 'HASH', "usii $t has y$_";
            }
        }
        my $minds = [map{t.gout->($mo,$_)}qw'
            up 1 1-sc
            2 2-sc
            2-sc-u
            2-sc-u-sc
            2-sc-u-sc-s
            2-sc-u-sc-s-sc
            2-sc-s
            2-sc-s-sc
        '];
        t.cs->({s=>$minds},"ii in/around mo ElvisThinker");
        
    }
    elsif ($n == 1) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker again uses mind');
    }
    elsif ($n == 2) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker changes mind');
    }
ElvisThinker: |
    u ElvisThinking
    
    J.bowls++ < 2 &&
    u ElvisThought
    some: %fs:8
        tan goal
    further: %fis:5
        thought matters
    n random=>7=>\'mon:A,s:moon'
    #G.ouJ = $J;
ElvisThinking: |
    # for mo 
    FindMeWhenYoure: %acgt:s,of:i
        # anywhere
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.03 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    fscolour 4: %act,acgt:s,v:sfs,of:mo
        my $h = $fs + 7;
        my $l = int($h / 3) + 6;
        $h -= 9 until $h < 9;
        $l -= 9 until $l < 9;
        C.sc.hs ||= $h.'7'.$l;
    
ElvisThought: |
    # for mo, or Hoop & bend towards some over time...
    dosoooooooooooooooooooo: %of:eloquence
        3 + 4 / 33 + $s
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.06 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    monta 4: %act,acgt:s,v:cmon,of:mo
        c&s = "$mon c&s $mon" if exists c&s;
EpiWaveletting: | # J makes pi, join lv
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit');
        t.cs->('c zip sc top','Waveofit zip top');
        t.cs->('c zop sc top','Waveofit zop top');
    }
    elsif ($n == 1) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 2) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change/goner');
    }
    elsif ($n == 3) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 4) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 5) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
Waveofit: |
    my $ou = J.sc.ou ||= [3,6,44,2,42,3,7,12];
    J.bowls++ && J.bowls < 4 && shift @$ou;
    n ylinogj=>-waveofits=>{s=>$ou}
    J.bowls < 3 &&
    n dough=>3=>{pi=>'waveofit',s=>"Says so"}
    n etc=>6=>J.bowls
pi/waveofits: |
    pre 1: %hs:378,fs:19
        ~@@@~
    my $div = 6 / @$s;
    my $i;
    for (@$s) {
        n doing=>( G&rou,2+$div*$i++ )=>{s=>$_},'%hs:394,bo:3px solid 4873'.($_ > 20 && ',fs:'.($_))
    }
    
    (J.dimin ||= 12)--;
    reg 89: %fs:J.dimin
        hadu
    pos 9: %hs:376,fs:17
        ~@@@~
pi/waveofit: |
    pre 1: %hs:878,fs:19
        ~~~~~~
    n doing=>2=>{s=>$s},'%hs:394,bo:3px solid 4873'
    pos 3: %hs:876,fs:17
        ~~~~~~
ElvisWorlds: | # J makes J, gather We in self
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys');#
        t.cs->({s=>C&ofts},"ofts made");
        # TODO? zopul copies dupey z, relinked in/next is deduped
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 1) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys without Whysl');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 2) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys + Whysl again');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 3) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys not');
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 4) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 5) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 6) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
Whys: |
    J.herefirst = "Was htis";
    J.bowls++ != 1 &&
    n Whysl
    
    J.bowls > 3 &&
    not: %velo:iffry,oft:i
        negate
    mix: %acgt:s,v:chume,oft:i
        G&yellow,$C,'tool'
    elect: %acgt:s,v:chume,oft:i
        G&blues
        # e
    my $ms = J.bowls > 2 ? '# the sandy' : '# sandy';
    n music=>1=>{s=>$ms}=>'%acgt:s,v:sJ,oft:dowse'
    bull: %oft:tools
        motorise time machine
    trail 16: %acgt:s,v:cmoresel,oft:tools,Wv:2
        1c&dol++;
    
Whysl: |
    J.bowls++ < 2 ||
    n skinny=>4=>{}
    J.herefirst && die "Was not J.t";
    my $hum = ',hum:'.(J.bowls+2) if J.bowls == 2 || J.bowls == 3;
    
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
    mix: %acgt:s,v:chume,oft:i$hum
        G&yam,$A,'tool';
    dowse: %acgt:s,v:sJ,oft:dowse
        G&yam,$A,'tool';
    trail 22: %acgt:s,v:ctar,oft:tools
        # and
        1c&dali++;
    J.bowls < 5 &&
    trail 16: %acgt:s,v:ctar,oft:tools,Wv:2
        # or
        1c&dali++;
        
    
        
        
ElvisWads: | # J in J (both W) simplicity
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad');
        ok !exists C&ofts, 'no ofts';
        t.cs->('c zop sc top','ElWad zop top');
        #$tos->('s1omp/sc lastK c s','two wormholes unite');
    }
    elsif ($n == 1) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 2) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed');
    }
    elsif ($n == 3) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed back');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 4) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still changed back komp');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 5) {
        c&te =
        n ElWadill=>W=>{rando=>'M'}
        t.cs->('sc lastK c s','ElWadill randomly');
        t.cs->('c zop sc top','ElWadill zop top');
    }
ElWad: |
    n ElWadill
    my $hum = ',hs:394' if J.bowls++ == 2;
    n noise=>3=>"Samp"=>'%hs:445'
    n nose=>4=>"Samp"=>'%hs:445'
    dji 314159: %fs:40$hum
        blos
ElWadill: |
    More:
        Noise!
    c&rando ||
    Than:
        before
    since:
        sync
    c&rando &&
    n c&rando=>87=>"With sides"
    
ElvisWorld: | # J makes, puts elvised We in self
    my $e = A.ii.theu;
    my $ot = "this";
    my $o;
    
    my $tos = sub {
        my ($c,$t) = @_;
        $c = {ntos=>$c} if $c && !ref $c;
        $ot = $1 if c.ntos =~ s/^(\w+)\///;
        map { G&xot,$c,$_ } G&peel,$1 if c.ntos =~ s/,(.+)$//;
        $tes->($t,1,$c)
    };
    my $ntos = sub { # get the oscillator A (s) given e is n of J
        my $j = shift;
        ($j) = values %{j.c.tug};
        $j = j.c.s || die "No C on ".ki$j;
        # the last Hows mo C
        $j = j.sc.J || die "No J on ".ki$j;
        $j = j.sc.s || die "No s on ".ki$j;
        $j = G&pint,$j,@_ if @_;
        $j
    };
    my $toc = {};
    c&mks = sub {
        my ($C,$T) = @_;
        T.oke = 1;
        my $se = $e;
        if (my $p = c&ntos) {
            my $sp = sub {[split / |,/, shift ]};
            my $output = $sp->($1) if $p =~ s/^(.*)\?( .+)?$/$1$2/;
            $p = $sp->($p);
            $se = $ntos->($se);
            
            if ($output || C.c.see) {
                $output ||= $sp->(C.c.see) if C.c.see && C.c.see ne '1';
                oJ.output = $output ? G&pint,$se,@$output : $se;
                C.c.return ||= oJ.output;
                return [] if C.c.see;
            }
            
            $se = G&pint,$se,@$p
        }
        C.c.return ||= $se;
        my $AV;# = delete A.V;
        my $oc = {};
        oc.noz = 1 if c&noz;
        oc.nonext = 1 if c&nonext;
        $oc.>$_ = $toc.>$_ for keys %$toc;
        $o = G&A,o=>6=>$J=>$se,[$ot,'',$oc];
        A.V = $AV if $AV;
        
        #A.V = 1 if $n == 10;
        # c&tac=1;
        
        my $l = o.c.rsl || die "no rsl";
        
        (A.V || A.Ve || C.c.question) &&
        1 && saybl "the $ot: ".$_ for @$l;
        $l
    };
    if ($n == 0) { #c
        #A.V = 1;
        $e =
        n Hows
        $tos->('zuptop/c zip sc top','Hows zip top');
        $tos->('zoptop/c zop sc top','Hows zop top');
        $tos->('zupp/c zip sc aroz,noz','Hows zip aroz');
        $tos->('zup1zop/c zip sc zop,noz','Hows zip zop');
        $tos->('zop1allz/c zop sc aroz,noz','Hows zop aroz');
    }
    elsif ($n ==1) {
        $e =
        n Hows
        my $zip =
        $tos->('zlp/c zip? sc top','Hows zip top again');
        delete oJ.output;
        my $cha = zip.c.cha.C;
        is 0+keys%$cha, 3, "3 changed";
        my $gone = cha.gone;
        ok $gone, "was gone";
        is join(', ',sort keys %$gone), 'skinny', "gone has keys == skinny";
        my $sk = G&pint,$gone,skinny=>0.4;
        is sk.t, 'skinny', "skinny is";
        ok !G&pint,$gone,Hows=>0.9 , "Hows tv not gone";
        ok !G&pint,$gone,'Hows' , "Hows t not gone";
        
        my $u =
        $tos->('zop2top/c zop? sc top','Hows zop top');
        delete oJ.output;
        $tos->({s=>u.c.rsl},'zop rsl shows goner');
        toc.noz = 1;
        $tos->('zup2zop/c zip sc zop','zip zop shows gone skinny');
        $tos->('zop2zop/c zop sc zop','zop zop shows gone skinny');
        $tos->('zop2inz/c zop sc inz','zop inz shows gone skinny');
        $tos->('zop2outz/c zop sc outz','zop outz shows gone skinny');
        delete oJ.output;
        delete toc.noz;
        $tos->('scomp/sc lastK c s','compression of gone skinny');
    }
    elsif ($n == 2) {
        $e =
        n Hows
        
        $tos->('zlo3p/c zip sc top','Hows zip top shows new trail');
        $tos->('zol3p/c zop sc top','Hows zop top shows new trail');
        # cant look at zop/inz because unhandled duplicate ty of trail
        $tos->('s3omp/sc lastK c s','compression of etc + trail');
    }
    elsif ($n == 3) {
        $e =
        n Hows
        
        $tos->('zlo4p/c zip sc top','Hows zip top shows changed trail');
        $tos->('zol4p/c zop sc top','Hows zop top shows changed trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        $tos->('s4omp/sc lastK c s','compression of etc + changed trail');
        
        my $ii = 
        $tos->('s4ii/sc ii? tools,nonext','made ii tools');
        delete oJ.output;
        $tos->({s=>[ki$ii,1]},"ii looks good");
        my $s = $ntos->($e);
        is s.sc.ii, $ii, "ii same a tos'd return";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.2;
        is H.sc.ii, $ii, "ii same on A2sii";
        ok !exists H.sc.i, "no i on A2si";
    }
    elsif ($n == 4) {
        #A.V = 1;
        #return;
        # explodes: unpositing into zopul makes empty We thing
        $e =
        n Hows
        
        $tos->('zlo5p/c zip sc top','Hows zip top shows gone trail');
        $tos->('zol5p/c zop sc top','Hows zop top shows gone trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        my $s = $ntos->($e);
        ok !exists s.sc.ii, "no ii on s";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.2;
        ok !exists H.sc.ii, "no ii on A2sii";
        ok !exists H.sc.i, "no i on A2si";
        #G.ouJ = j.sc.lastK.c.s;
        $tos->('s5omp/sc lastK c s','compression of gone trail');
    }
    
Hows: |
    J.sc.u.c.o = 'oscd';
    my $so = 's o,towe:l';
    $so = 's,tele:vise' if J.bowls;
    rakes: %acgt:$so
        robino
    
    leaves: %some:other,ma:ni,fo:la,t:e
        traces
    
    J.bowls &&
    surf:
        to rise
    
    J.bowls++ ||
    n skinny=>4=>{}
    my $hum = ',hum:4' if J.bowls == 4;
    J.bowls >= 3 && J.bowls <= 4 &&
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
        
        
        
        
        # and
        1c&dali++;
oft: | # test of
    1 && saybl "We things C.c.W named C.t C.y.cv:   ".ki C.c.e;
    # should hup & acum C.sc.z
    push @{ A.4.c.testC.sc.ofts ||= [] },
        "We things C.c.W named C.t C.y.cv:   ".ki C.c.e
        if A.4.c.testC;
    
    for my $e ( e&_z ) {
        ec&s =~ s/\n\s*\n+/\n\n/sgm;
        es&seen = 2;
        ec&code = sub { "does e.t e.y.cv from C.t" };
    }
    C.sc.hi = 'lo';
    T.nose = 1;
    
ElvisLeaves: | # data vs o, watch change
    #A.V = 1;
    #exit if $n > 3;
    my $tf = 't/Zupe/ElvisLeaves/theu';
    DumpFile($tf, A.ii.theu) unless -f $tf;
    my $e = J.theu ||= LoadFile($tf);
    my $o;
    my $ot = 'zimb';
    
    my $lshot = sub {
        my ($C,$l) = @_;
        my $m = c&lshot;
        return unless @$l > $m;
        @$l = (@{$l}[0..$m]);# "... snip x".(@$l-$m));
    };
    c&mks = sub {
        my $C = shift;
        $o = G&A,o=>6=>$J=>$e,$ot;
        
        #A.V = 1 if $n == 10;
        
        my $l = o.c.rsl;
        #  c&tac = 1;
        
        c&lshot && $lshot ->($C,$l);
        (A.V || A.Ve) &&
        saybl "the Dujis: ".$_ for @$l;
        $l
    };
    
    if ($n==0) { #c
        $tes->('whole u','',{lshot=>32});
    }
    elsif ($n==1) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Here';
        $m = e.sc.z->[3];
        $m = m.y.in;
        $m = m.y.next || $m for 1..3;
        m.sc.epl = "Dop";
        m.c.s = "ACGT {} !";
        e.sc.eo = 'popup';

        $m = e.sc.z->[5];
        $m = m.y.in;
        $m = m.y.next || $m for 1..2;
        
        my $pr = m.y.prev;
        G&apart,next=>$pr;
        pr.sc.herre = 'OOOO';

        pop @{e.sc.z};
        
        $tes->('u messed with');
    }
    elsif ($n==2) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Hur';
        $m = e.sc.z->[1];
        $m = m.y.in;
        G&apart,next=>$m for 1..3;
        G&toget,next=>m.y.next.y.next,$_ for G&Ct,[available=>6=>'makeether','%eo:fil'];
        $tes->('couple more');
    }
    elsif ($n >= 3 && $n <= 4) {
        $ot = 'dwell';
        my $la = G&Ct,[row=>6=>is=>'%hs:588'];
        my $te = G&Ct,[seen=>8=>is=>'%hs:588'];
        $e = [
            G&Ct,[row=>1=>is=>'%hs:588'] ,
            G&Ct,[reow=>1=>is=>'%hs:588'] ,
            G&Ct,[rodw=>5=>is=>'%hs:588'] ,
            $la, $te
        ];
        $e = G&Ct,[wo=>2=>{}=>{z=>$e}];
        
        if ($n == 3) {
            $tes->('el=1 when dup t');
        }
        else {
            la.t = 'som';
            te.sc.hs = 359;
            te.sc.know = 'ing';
            $tes->('mount');
        }
    }
    elsif ($n >= 5 && $n <= 8) {
        my $mo = e.sc.z->[1];
        my $om = G&Ct,[J=>4=>'codedpassage'=>'%acgt:3'];
        my $z = [
            $om,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        my $lom = G&Ct,[mo=>0.001=>{W=>'of'},{z=>$z}];
        my @io = (
            G&A,o=>2=>$J=>$mo,'Themo' ,
            $n < 7 && G&A,o=>2=>$J=>$lom,'Extra'
        );
        $e = {map{_.c.sip => $_ }grep{$_}@io};
        $ot = 'zip';
        
        if ($n == 5) {
            # c&mks ->();
            $tes->('W over without innards');
        }
        elsif ($n == 6) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over change some');
        }
        elsif ($n == 7) {
            mo.y.in.sc.casa = "case $n";
            $tes->('W over, chang, Extra gone');
        }
        elsif ($n == 8) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over, more change');
        }
    }
    elsif ($n == 9) { #c
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[snapsof=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see two');
    }
    elsif ($n == 10) {
        $ot = 'thanks';
        my $z = [
            G&Ct,[movie=>3=>'mae'=>{acgt=>3}] ,
        ];
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>{acgt=>3,z=>$z}] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see one go, one come');
    }
    elsif ($n == 11) {
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see z disappear');
    }
    my $so = $o;
    my $one = 0.001;
    #$so = so.c.oo.C.theu.>$one;
    $so = J.sc.jo.zip.sc.oo.C.mo.>$one; # from oJ, the zip's mo 0.001
    return {p=>33};
    $so = so.sc.jo->{"z mo $one"};
    $so = so.c.Co; # the C currently othering under the recursionship of j
    $so = so.c.j.sc.oo.C.W; # through to the j again, all C it can see named W

