
ElvisWay: | # J new Rw pin getter, 
    my $t = Rw Telvis;
    A.uyes = 1;
    #A.V = 1;
    if ($n == 0) {
        c&te =
        n ElvisWays
        t.cs->('sc lastK c s y l y tw w,nonext','ways of=w');
        t.cs->({s=>t.lookii->()},'have ii');
    }
    if ($n == 1) {
        my $h;
    
        c&te = 
        n ElvisWhay
        t.cs->('sc lastK c s','way holder, nothing with no cs');
        t.cs->('sc lastA 2 ii w,nonext','is holding shu');
        my $W = t.ntos->(c&te,'J');
        is W.t, 'ElvisWhay', 'Have holder J';
        is W.ii.w && W.ii.w.y.in.t, 'shu', 'Have shu in J';
        h.5 = $W;
        
        c&te = 
        n ElvisNotWhay
        t.cs->('sc lastA 2 ii w,nonext','Another holder');
        my $W = t.ntos->(c&te,'J');
        is W.t, 'ElvisNotWhay', 'Another holder 2 J';
        h.4 = $W;
        
        #W.ii = W.sc.ii;
        # ^ doesn't break W, is J, bystander/particle to A
        # those serving t must be holding it as .ii
        # T.o.J.t.ElvisWayer = G&Ct,'In5'=>3=>{inet=>5,s=>$J
        
        c&te = 
        n ElvisWaying=>W=>{house=>$h}
        t.cs->('sc lastK c s','looks of Elvis Waying');
        t.cs->({s=>t.lookii->()},'have no ii of waying');
        # 
    }
ElvisWaying: |
    n some=>1=>here
    my $Gw = G.w;
    G.w = A.i.w;
    G&xot,$A,$_ for c&house || die "Give house";
    A.5.ii && A.5.ii.w || die "House no w: ".wdump 1, A.5.ii;
    
    Rw shu + $C $nos:A.2 $job=0 etc;
    # ^ babs to:
    # $G->{w}->($A,$C,$G,$T,"lingophase",$ar,C=>$C,nos=>$A->{2},job=>"0",m=>["etc"]);
    Rw shu + $C $nos:A.2 $job=3;
    # the + mixes in ar at the front, becomes m[] if elsewhere
    Rw lingophase $C $nos:A.2 $noj=C.y.cv;
    
    Rw thinelse $C $nos:A.2 $noj=C.y.cv;
    
    G.w = $Gw;
    my $i = 2;
    n looks=>$i++=>{s=>"$_: ".C.sc.>$_ } for grep {!ref C.sc.>$_ } sort keys %{C.sc};
    
ElvisNotWhay: |
    u ElvisNotWays
    n othing=>1
ElvisNotWays: |
    #u alway
    # passed through of uncoded
    lingophase: %of:w
        C.sc.lingo = 'first phase';
    thinelse: %of:w
        C.sc.nothin = 'elsey';
ElvisWhay: |
    u ElvisWays
    n othing=>1
ElvisWays: |
    #u alway
    # passed through of uncoded
    shu: %of:w
        s&op = 3;
        s&mind = 'with arm' if ar.m;
        s&mindo = 'without arm' if !ar.m;
        s&job = join ' ',grep{defined} s&job, ar.job if defined ar.job;
    lingophase 3: %of:w
        s&lingo = 'second phase';
    
ElvisThinks: | # J uses u (mind), does stuff with it
    my $t = Rw Telvis;
    A.uyes = 1;
    if ($n == 0) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker made with mind');
        t.cs->('sc lastA 2 sc u sc s sc ii eloquence,nonext','J u s ii eloquence');
        t.cs->({ntos=>'sc lastA 2 sc u sc s sc ii mo',
            nonext=>1,grepl=>sub{ $_[0] =~ /^\s+(fis|fscolour) / }
        },'J u s ii mo seems to be');
        
        my $mo = t.ntos->(c&te,'mo');
        
        is mo.t, 'mo', 'mot is mo';
        is mo.2.t, 'ElvisThinker', 'mo2t is ElvisThinker';
        is mo.2.sc.u.t, 'u', 'ut is u';
        my $usii = mo.2.sc.u.sc.ii;
        is ref $usii, 'HASH', 'ii is hash';
        for my $t (qw'eloquence mo') {
            my $is = $usii.>$t;
            is ref $is, 'HASH', "usii $t";
            for (qw'tv tw in') {
                is ref is.y.>$_, 'HASH', "usii $t has y$_";
            }
        }
        my $minds = [map{t.gout->($mo,$_)}qw'
            up 1 1-sc
            2 2-sc
            2-sc-u
            2-sc-u-sc
            2-sc-u-sc-s
            2-sc-u-sc-s-sc
            2-sc-s
            2-sc-s-sc
        '];
        t.cs->({s=>$minds},"ii in/around mo ElvisThinker");
        
    }
    elsif ($n == 1) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker again uses mind');
    }
    elsif ($n == 2) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker changes mind');
    }
ElvisThinker: |
    u ElvisThinking
    
    J.bowls++ < 2 &&
    u ElvisThought
    some: %fs:8
        tan goal
    further: %fis:5
        thought matters
    n random=>7=>\'mon:A,s:moon'
    #G.ouJ = $J;
ElvisThinking: |
    # for mo 
    FindMeWhenYoure: %acgt:s,of:i
        # anywhere
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.03 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    fscolour 4: %act,acgt:s,v:sfs,of:mo
        my $h = $fs + 7;
        my $l = int($h / 3) + 6;
        $h -= 9 until $h < 9;
        $l -= 9 until $l < 9;
        C.sc.hs ||= $h.'7'.$l;
    
ElvisThought: |
    # for mo, or Hoop & bend towards some over time...
    dosoooooooooooooooooooo: %of:eloquence
        3 + 4 / 33 + $s
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.06 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    monta 4: %act,acgt:s,v:cmon,of:mo
        c&s = "$mon c&s $mon" if exists c&s;
EpiWaveletting: | # J makes pi, join lv
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit');
        t.cs->('c zip sc top','Waveofit zip top');
        t.cs->('c zop sc top','Waveofit zop top');
    }
    elsif ($n == 1) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 2) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change/goner');
    }
    elsif ($n == 3) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 4) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 5) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
Waveofit: |
    my $ou = J.sc.ou ||= [3,6,44,2,42,3,7,12];
    J.bowls++ && J.bowls < 4 && shift @$ou;
    n ylinogj=>-waveofits=>{s=>$ou}
    J.bowls < 3 &&
    n dough=>3=>{pi=>'waveofit',s=>"Says so"}
    n etc=>6=>J.bowls
pi/waveofits: |
    pre 1: %hs:378,fs:19
        ~@@@~
    my $div = 6 / @$s;
    my $i;
    for (@$s) {
        n doing=>( G&rou,2+$div*$i++ )=>{s=>$_},'%hs:394,bo:3px solid 4873'.($_ > 20 && ',fs:'.($_))
    }
    
    (J.dimin ||= 12)--;
    reg 89: %fs:J.dimin
        hadu
    pos 9: %hs:376,fs:17
        ~@@@~
pi/waveofit: |
    pre 1: %hs:878,fs:19
        ~~~~~~
    n doing=>2=>{s=>$s},'%hs:394,bo:3px solid 4873'
    pos 3: %hs:876,fs:17
        ~~~~~~
ElvisWorlds: | # J makes J, gather We in self
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys');#
        t.cs->({s=>C&ofts},"ofts made");
        # TODO? zopul copies dupey z, relinked in/next is deduped
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 1) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys without Whysl');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 2) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys + Whysl again');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 3) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys not');
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 4) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 5) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 6) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
Whys: |
    J.herefirst = "Was htis";
    J.bowls++ != 1 &&
    n Whysl
    
    J.bowls > 3 &&
    not: %velo:iffry,oft:i
        negate
    mix: %acgt:s,v:chume,oft:i
        G&yellow,$C,'tool'
    elect: %acgt:s,v:chume,oft:i
        G&blues
        # e
    my $ms = J.bowls > 2 ? '# the sandy' : '# sandy';
    n music=>1=>{s=>$ms}=>'%acgt:s,v:sJ,oft:dowse'
    bull: %oft:tools
        motorise time machine
    trail 16: %acgt:s,v:cmoresel,oft:tools,Wv:2
        1c&dol++;
    
Whysl: |
    J.bowls++ < 2 ||
    n skinny=>4=>{}
    J.herefirst && die "Was not J.t";
    my $hum = ',hum:'.(J.bowls+2) if J.bowls == 2 || J.bowls == 3;
    
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
    mix: %acgt:s,v:chume,oft:i$hum
        G&yam,$A,'tool';
    dowse: %acgt:s,v:sJ,oft:dowse
        G&yam,$A,'tool';
    trail 22: %acgt:s,v:ctar,oft:tools
        # and
        1c&dali++;
    J.bowls < 5 &&
    trail 16: %acgt:s,v:ctar,oft:tools,Wv:2
        # or
        1c&dali++;
        
    
        
        
ElvisWads: | # J in J (both W) simplicity
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad');
        ok !exists C&ofts, 'no ofts';
        t.cs->('c zop sc top','ElWad zop top');
        #$tos->('s1omp/sc lastK c s','two wormholes unite');
    }
    elsif ($n == 1) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 2) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed');
    }
    elsif ($n == 3) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed back');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 4) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still changed back komp');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 5) {
        c&te =
        n ElWadill=>W=>{rando=>'M'}
        t.cs->('sc lastK c s','ElWadill randomly');
        t.cs->('c zop sc top','ElWadill zop top');
    }
ElWad: |
    n ElWadill
    my $hum = ',hs:394' if J.bowls++ == 2;
    n noise=>3=>"Samp"=>'%hs:445'
    n nose=>4=>"Samp"=>'%hs:445'
    dji 314159: %fs:40$hum
        blos
ElWadill: |
    More:
        Noise!
    c&rando ||
    Than:
        before
    since:
        sync
    c&rando &&
    n c&rando=>87=>"With sides"
    
ElvisWorld: | # J makes, puts elvised We in self
    my $e = A.ii.theu;
    my $ot = "this";
    my $o;
    
    my $tos = sub {
        my ($c,$t) = @_;
        $c = {ntos=>$c} if $c && !ref $c;
        $ot = $1 if c.ntos =~ s/^(\w+)\///;
        map { G&xot,$c,$_ } G&peel,$1 if c.ntos =~ s/,(.+)$//;
        $tes->($t,1,$c)
    };
    my $ntos = sub { # get the oscillator A (s) given e is n of J
        my $j = shift;
        ($j) = values %{j.c.tug};
        $j = j.c.s || die "No C on ".ki$j;
        # the last Hows mo C
        $j = j.sc.J || die "No J on ".ki$j;
        $j = j.sc.s || die "No s on ".ki$j;
        $j = G&pint,$j,@_ if @_;
        $j
    };
    my $toc = {};
    c&mks = sub {
        my ($C,$T) = @_;
        T.oke = 1;
        my $se = $e;
        if (my $p = c&ntos) {
            my $sp = sub {[split / |,/, shift ]};
            my $output = $sp->($1) if $p =~ s/^(.*)\?( .+)?$/$1$2/;
            $p = $sp->($p);
            $se = $ntos->($se);
            
            if ($output || C.c.see) {
                $output ||= $sp->(C.c.see) if C.c.see && C.c.see ne '1';
                oJ.output = $output ? G&pint,$se,@$output : $se;
                C.c.return ||= oJ.output;
                return [] if C.c.see;
            }
            
            $se = G&pint,$se,@$p
        }
        C.c.return ||= $se;
        my $AV = delete A.V;
        my $oc = {};
        oc.noz = 1 if c&noz;
        oc.nonext = 1 if c&nonext;
        $oc.>$_ = $toc.>$_ for keys %$toc;
        $o = G&A,o=>6=>$J=>$se,[$ot,'',$oc];
        A.V = $AV if $AV;
        
        #A.V = 1 if $n == 10;
        # c&tac=1;
        
        my $l = o.c.rsl || die "no rsl";
        
        (A.V || A.Ve || C.c.question) &&
        1 && saybl "the $ot: ".$_ for @$l;
        $l
    };
    if ($n == 0) { #c
        $e =
        n Hows
        $tos->('ziptop/c zip sc top','Hows zip top');
        $tos->('zoptop/c zop sc top','Hows zop top');
        $tos->('zipp/c zip sc aroz,noz','Hows zip aroz');
        $tos->('zip1zop/c zip sc zop,noz','Hows zip zop');
        $tos->('zop1allz/c zop sc aroz,noz','Hows zop aroz');
    }
    elsif ($n ==1) {
        $e =
        n Hows
        my $zip =
        $tos->('zlp/c zip? sc top','Hows zip top again');
        delete oJ.output;
        my $cha = zip.c.cha.C;
        is 0+keys%$cha, 3, "3 changed";
        my $gone = cha.gone;
        ok $gone, "was gone";
        is join(', ',sort keys %$gone), 'skinny', "gone has keys == skinny";
        my $sk = G&pint,$gone,skinny=>0.4;
        is sk.t, 'skinny', "skinny is";
        ok !G&pint,$gone,Hows=>0.9 , "Hows tv not gone";
        ok !G&pint,$gone,'Hows' , "Hows t not gone";
        
        my $u =
        $tos->('zop2top/c zop? sc top','Hows zop top');
        delete oJ.output;
        $tos->({s=>u.c.rsl},'zop rsl shows goner');
        toc.noz = 1;
        $tos->('zip2zop/c zip sc zop','zip zop shows gone skinny');
        $tos->('zop2zop/c zop sc zop','zop zop shows gone skinny');
        $tos->('zop2inz/c zop sc inz','zop inz shows gone skinny');
        $tos->('zop2outz/c zop sc outz','zop outz shows gone skinny');
        delete oJ.output;
        delete toc.noz;
        $tos->('scomp/sc lastK c s','compression of gone skinny');
    }
    elsif ($n == 2) {
        $e =
        n Hows
        
        $tos->('zlo3p/c zip sc top','Hows zip top shows new trail');
        $tos->('zol3p/c zop sc top','Hows zop top shows new trail');
        # cant look at zop/inz because unhandled duplicate ty of trail
        $tos->('s3omp/sc lastK c s','compression of etc + trail');
    }
    elsif ($n == 3) {
        $e =
        n Hows
        
        $tos->('zlo4p/c zip sc top','Hows zip top shows changed trail');
        $tos->('zol4p/c zop sc top','Hows zop top shows changed trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        $tos->('s4omp/sc lastK c s','compression of etc + changed trail');
        
        my $ii = 
        $tos->('s4ii/sc ii? tools,nonext','made ii tools');
        delete oJ.output;
        $tos->({s=>[ki$ii,1]},"ii looks good");
        my $s = $ntos->($e);
        is s.sc.ii, $ii, "ii same a tos'd return";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.2;
        is H.sc.ii, $ii, "ii same on A2sii";
        ok !exists H.sc.i, "no i on A2si";
    }
    elsif ($n == 4) {
        #A.V = 1;
        #return;
        # explodes: unpositing into zopul makes empty We thing
        $e =
        n Hows
        
        $tos->('zlo5p/c zip sc top','Hows zip top shows gone trail');
        $tos->('zol5p/c zop sc top','Hows zop top shows gone trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        my $s = $ntos->($e);
        ok !exists s.sc.ii, "no ii on s";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.2;
        ok !exists H.sc.ii, "no ii on A2sii";
        ok !exists H.sc.i, "no i on A2si";
        #G.ouJ = j.sc.lastK.c.s;
        $tos->('s5omp/sc lastK c s','compression of gone trail');
    }
    
Hows: |
    J.sc.u.c.o = 'oscd';
    my $so = 's o,towe:l';
    $so = 's,tele:vise' if J.bowls;
    rakes: %acgt:$so
        robino
    
    leaves: %some:other,ma:ni,fo:la,t:e
        traces
    
    J.bowls &&
    surf:
        to rise
    
    J.bowls++ ||
    n skinny=>4=>{}
    my $hum = ',hum:4' if J.bowls == 4;
    J.bowls >= 3 && J.bowls <= 4 &&
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
        
        
        
        
        # and
        1c&dali++;
oft: | # test of
    1 && saybl "We things C.c.W named C.t C.y.cv:   ".ki C.c.e;
    # should hup & acum C.sc.z
    push @{ A.4.c.testC.sc.ofts ||= [] },
        "We things C.c.W named C.t C.y.cv:   ".ki C.c.e
        if A.4.c.testC;
    
    for my $e ( e&_z ) {
        ec&s =~ s/\n\s*\n+/\n\n/sgm;
        es&seen = 2;
        ec&code = sub { "does e.t e.y.cv from C.t" };
    }
    C.sc.hi = 'lo';
    T.nose = 1;
    
ElvisLeaves: | # data vs o, watch change
    #A.V = 1;
    #exit if $n > 3;
    my $tf = 't/Zupe/ElvisLeaves/theu';
    DumpFile($tf, A.ii.theu) unless -f $tf;
    my $e = J.theu ||= LoadFile($tf);
    my $o;
    my $ot = 'zimb';
    
    my $lshot = sub {
        my ($C,$l) = @_;
        my $m = c&lshot;
        return unless @$l > $m;
        @$l = (@{$l}[0..$m]);# "... snip x".(@$l-$m));
    };
    c&mks = sub {
        my $C = shift;
        $o = G&A,o=>6=>$J=>$e,$ot;
        
        #A.V = 1 if $n == 10;
        
        my $l = o.c.rsl;
        #  c&tac = 1;
        
        c&lshot && $lshot ->($C,$l);
        (A.V || A.Ve) &&
        saybl "the Dujis: ".$_ for @$l;
        $l
    };
    
    if ($n==0) { #c
        $tes->('whole u','',{lshot=>32});
    }
    elsif ($n==1) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Here';
        $m = e.sc.z->[3];
        $m = m.y.in;
        $m = m.y.next || $m for 1..3;
        m.sc.epl = "Dop";
        m.c.s = "ACGT {} !";
        e.sc.eo = 'popup';

        $m = e.sc.z->[5];
        $m = m.y.in;
        $m = m.y.next || $m for 1..2;
        
        my $pr = m.y.prev;
        G&apart,next=>$pr;
        pr.sc.herre = 'OOOO';

        pop @{e.sc.z};
        
        $tes->('u messed with');
    }
    elsif ($n==2) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Hur';
        $m = e.sc.z->[1];
        $m = m.y.in;
        G&apart,next=>$m for 1..3;
        G&toget,next=>m.y.next.y.next,$_ for G&Ct,[available=>6=>'makeether','%eo:fil'];
        $tes->('couple more');
    }
    elsif ($n >= 3 && $n <= 4) {
        $ot = 'dwell';
        my $la = G&Ct,[row=>6=>is=>'%hs:588'];
        my $te = G&Ct,[seen=>8=>is=>'%hs:588'];
        $e = [
            G&Ct,[row=>1=>is=>'%hs:588'] ,
            G&Ct,[reow=>1=>is=>'%hs:588'] ,
            G&Ct,[rodw=>5=>is=>'%hs:588'] ,
            $la, $te
        ];
        $e = G&Ct,[wo=>2=>{}=>{z=>$e}];
        
        if ($n == 3) {
            $tes->('el=1 when dup t');
        }
        else {
            la.t = 'som';
            te.sc.hs = 359;
            te.sc.know = 'ing';
            $tes->('mount');
        }
    }
    elsif ($n >= 5 && $n <= 8) {
        my $mo = e.sc.z->[1];
        my $om = G&Ct,[J=>4=>'codedpassage'=>'%acgt:3'];
        my $z = [
            $om,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        my $lom = G&Ct,[mo=>0.001=>{W=>'of'},{z=>$z}];
        my @io = (
            G&A,o=>2=>$J=>$mo,'Themo' ,
            $n < 7 && G&A,o=>2=>$J=>$lom,'Extra'
        );
        $e = {map{_.c.sip => $_ }grep{$_}@io};
        $ot = 'zip';
        
        if ($n == 5) {
            # c&mks ->();
            $tes->('W over without innards');
        }
        elsif ($n == 6) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over change some');
        }
        elsif ($n == 7) {
            mo.y.in.sc.casa = "case $n";
            $tes->('W over, chang, Extra gone');
        }
        elsif ($n == 8) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over, more change');
        }
    }
    elsif ($n == 9) { #c
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[snapsof=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see two');
    }
    elsif ($n == 10) {
        $ot = 'thanks';
        my $z = [
            G&Ct,[movie=>3=>'mae'=>{acgt=>3}] ,
        ];
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>{acgt=>3,z=>$z}] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see one go, one come');
    }
    elsif ($n == 11) {
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see z disappear');
    }
    my $so = $o;
    my $one = 0.001;
    #$so = so.c.oo.C.theu.>$one;
    $so = J.sc.jo.zip.sc.oo.C.mo.>$one; # from oJ, the zip's mo 0.001
    return {p=>33};
    $so = so.sc.jo->{"z mo $one"};
    $so = so.c.Co; # the C currently othering under the recursionship of j
    $so = so.c.j.sc.oo.C.W; # through to the j again, all C it can see named W

