ElvisHandles: | # J e J e J e J e J
    my $t = Rw Telvis;
    t.toc.slim = 44;
    G.ohno = [];
    A.4.c.mutelos = 1;
    my $lp = sub {
        my $et = shift;
        t.el->(ElvisEmpty=>($et||'implant')=>
            [qw'ElvisViarator ElvisViaratorr ElvisFivery Elvista'=>@_]);
    };
    if ($n == 0) {
        c&te =
        n ElvisFivery
        t.en->('Tarfindsimagi, give one to vist');
        c&te =
        n Elvista
        t.en->('vist 2');
        c&te =
        n Elvista
        t.en->('vist 3');
        
        c&te =
        n ElvisFivery
        t.en->('Give another to vist');
        
        for (4..12) {
            c&te =
            n Elvista
            t.en->('vist '.$_);
        }
        c&te =
        n ElvisFivery
        my $s = t.ntos->(c&te);
        saybl "so ".wdump 4, [s.c.zop.c.rsl, s.sc.lastK.c.s];
        #exit;
        t.cs->('sc lastK c s', 'Give third...');
        #t.en->('Give third to vist');
        
        for (13..16) {
            c&te =
            n Elvista
            t.en->('vist '.$_);
        }
    }
    if ($n == 1) {
        my $p = [qw'ElvisViarator ElvisEmpty ElvisFivery Elvista img'];
        t.el->(ElvisEmpty=>'implant'=>$p);
        c&te =
        n Elvista
        t.en->('message sent');
        t.cs->({rsl=>G.ohno},'lost on virate');
    }
    if ($n == 2) {
        my $tr =
        n ElvisViarator
        n ElvisViaratorr
        t.cs->({rsl=>G.ohno},'emptiness');
        
        $lp->(implant=>'img');
        c&te =
        n Elvista
        t.en->('sc top', 'selection appears');
        t.cs->({rsl=>G.ohno},'nolos');
        for (4..7) {
            c&te =
            n Elvista
            t.en->('sc top', 'vist '.$_);
        }
        $lp->(eardrum=>'img-0.6');
        c&te =
        n Elvista
        t.en->('sc top', 'another selection appears');
        
        c&te = $tr;
        t.en->('sc top', 'the Viarated transcript');
        
        t.cs->({rsl=>G.ohno},'nolos');
    }
    if ($n == 3) {
        $lp->(stereo=>'img');
        
        t.cs->({rsl=>G.ohno},'nAmbiguous-way-inolos');
    }
    if ($n == 4) {
        c&te =
        n ElvosRandomthings
        t.cs->('sc top', 'scene');
        my $lp = sub {
            t.el->(ElvisEmpty=>plant=>[ElvosRandomthings=>@_]);
        };
        $lp->(split '/', $_) for qw'hands  reeds   reed-0.4/Mix  reed-0.4/Lake';
        t.cs->({rsl=>G.ohno},'hands amb, los, no dos, los');
        
        
    }
ElvosRandomthings: |
    1s&ein.pi.relim = 'reeltooled';
    Js&ein.bo = 'Doable';
    couch:
        swump
    filo 3:
        [ ]
    hands 5:
        5
    hands 7:
        5
    n reed=>-reed=>[qw'Sow Mix Lake']
    n sav=>-reed=>[qw'Three Mix Four ']
    n reed=>4=>{s=>[qw'Sow Mix Gee'],pi=>'reed'}
pi/reed: |
    my $i = 1;
    n $_=>'1'.$i++=>$_ for @$s;
ElvisEmpty: |
    # nothi
ElvisViarator: |
    1s&ein.tractor = 1;
    1s&ein.li = 'writedown';
    n thing => 3 => $_ for grep {$_} J.remember;
ElvisViaratorr: |
    # etc
writedown: |
    1 && saybl "WRiteing on C.t: ".ki$e;
    J.remember .= "\n e.t: ".ki us&p;
    T.com = 6;
ElvisFivery: |
    T.ishere = C.t;
    n ElTarfigure
    
    my $i = J.bowls++;
    my $t = T.op.y.in;
    while ($i) {
        if (!t.y.next) {
            J.bowls--;
            last;
        }
        $i--;
        $t = t.y.next;
    }
    n Elvista=>W=>{e=>$t}
Point: |
    # etc
ElTarfigure: |
    c&only = 'images';
    c&grep = 't';
    c&s = '../Tarf/Photo_serieses/';
    my @imgs = Rw Exe;
    my $i = 3;
    n (/.+\/(.+?)$/)[0]=>'3'.$i++=>$_=>{pi=>'relim'} for @imgs;
Elvista: |
    1s&ein.pi.relim = 'reeltooled';
    Js&ein.bo = 'Doable';
    Js&bunch ||= [];
    Js&chose ||= [];
    S
    my $l = Js&bunch ->[ J.bowls ] || return;
    J.bowls = 0 if !exists Js&bunch ->[++J.bowls];
    
    n img => 6 => $l=>{dos=>'visache'}
    
    my $i;
    for (@{Js&chose}) {
        n img => '3'.$i++ => $_=>{dos=>'visache'}
    }
    
visache: |
    1 && saybl "Jere at C.t c.c.t".ki e&chC;
    sayyl "Or ".ki$c;
    push @{Js&chose}, cc&s;
    T.pos = 1;
ElvisLinkage: | # J succession of link
    my $t = Rw Telvis;
    my $pn = sub {
        my $s = shift;
        my $ty = sub{my $s = shift; $s && "s.t s.y.cv $s"};
        $ty->($s)."  ^ ".$ty->(s.y.prev)."  v ".$ty->(s.y.next)
    };
    my $tvlinkage = sub {
        my $tv = shift;
        $tv ||= c&so.sc.tv;
        my $yt = G&yttv,$tv;
        my @l;
        G&chew,$yt,\'cv,t',$_ for sub { push @l, $pn->(shift); };
        \@l
    };
    if ($n == 0) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
    if ($n == 1) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
    if ($n == 2) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
    if ($n == 3) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
ElvisLinkoy: |
    # 123, 234, 345
    $s = 'seewooooorld';
    Rw pi/seawire + $s;
ElvisElvises: | # J e J,
    my $t = Rw Telvis;
    #A.V = 1;
    # your mo .e 
    # the J minded of=E awaken/resolve options
    # calls handlers or the pin to find handlers or handle as pin
    # handlers register into E (may want to J.ii only u wave '' or so)
    # handling e vars (via e&st -> G&e,'st', etc) tickles clues to pin
    G.ohno = [];
    delete A.4.sc.Jtv.Elvisrec->{0.1};
    
    if ($n == 0) {
        c&te =
        n Elviseso
        t.cs->('sc lastK c s','source');
        is 0+uniq(map{_.sc.J}values %{c&so.sc.tv.Elvisrec}), 1,
            "Same Elvisrec positioned twice";
        c&te =
        n Elvisrec
        t.cs->('sc lv,olv','lvour');
        
        t.cs->({rsl=>G.ohno},'none lost');
        
    }
    if ($n == 1) {
        c&te =
        n Walless=>W=>\'pin:Elviseso,droppy'
        t.cs->('sc lastK c s','source');
        c&te =
        n Elvisrec
        t.cs->('sc lv,olv','lvour');
        
        t.cs->({rsl=>G.ohno},'nonfirst lost');
    }
    if ($n == 2) {
        my $el =
        n ElvisBystand
        c&te =
        n Walley=>W=>\'pin:Elviseso,reeltool'
        t.cs->('sc lastK c s','source');
        c&te =
        n ElvisBystand
        t.cs->('sc lastK c s','routed to');
        t.cs->('sc lv,olv','routed to lv');
        
        c&te =
        n Elvisrec
        #t.cs->('sc lv,olv','lvour');
        
        t.cs->({rsl=>G.ohno},'only outerspacer');
    }

Elviseso: |
    #n ElBridge
    #return;
    1c&droppy = 1 if c&droppy;
    1c&reeltool = 1 if c&reeltool;
    my $e;
    $e = G&s,once=>"Dwiver";
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,twice=>"Sandpaper";
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,reeltool=>{s=>"Drier",us=>{p=>[['ElvisBystand']]}};
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,twice=>"Dwivel";
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,reeltool=>{s=>"Digly",us=>{p=>[['OthierElves']]}};
    n Elvisrec=>W=>{e=>$e}
    
    n Elvisrec=>3=>{W=>''}
Elvisrec: |
    if (2c&reeltool) {
        Js&ein.t.reeltool = 'reeltooled';
    }
    S
    if (my $e = (!2c&droppy || !(J.bowls++> 1) ) && e&C) {
        if (e.t eq 'twice') {
            Js&theword = e.c.s;
            J.seawire += 2;
        }
        1 && saybl "A minor ".ki $e;
    }
    
    J.seawire && J.seawire-- &&
        n seewooooorld=>-seawire=>
    
    n oa=>1=>33
    n ha =>2=> Js&theword||"unknown"
    Js&bunch && 
    n have =>3=>join(", ", @{Js&bunch||[]})
    #Js&ein.t.tools = 'fixolid';
ElvisBystand: |
    1s&ein.t.reeltool = 'reeltooled';
    S
    n maunk=>3=>3
    Js&bunch && 
    n have =>3=>(join", ", @{Js&bunch||[]})
reeltooled: |
    my $bu = Js&bunch ||= [];
    push @$bu, e.c.s;
    sayyl "J.t Handled e.c.s: ".ki $e;
    T.pos = 1;
pi/seawire: |
    n snuff=>3=>"Wuff";
    my $i = ++J.bowls;
    for (split '', $s||C.t) {
        n $_=>'0.'.sprintf('%04d',$i++)=>$_
    }

ElvisFalls: | # the A.1 = this J, A.2 above, A.3 W in A.4, A.5 serve
    my $t = Rw Telvis;
    if ($n == 0) {
        c&te =
        n Elvisvisoh
        t.cs->('sc lastK c s','source');
    }
Elvisvisoh: |
    n Elvisoh=>-Elvisvisoh=>3
pi/Elvisvisoh: |
    for (1..5) {
        my $n = 6 - $_;
        my $J = $A.>$n;
        n "A $n"=>$_=>"J.t"
    }
    $s || return;
    my $t = C.t;
    $t =~ s/...$//;
    $t .= J.c.d < 2 ? 'ooool' : 'ake';
    
    n $t=>7=>{pi=>Elvisvisoh=>s=>$s-1}
ElvisWhole: | # o replicates C tv,i,ii
    my $t = Rw Telvis;
    # feed J.sc.ii onto s.sc.ii without osc
    # see ii as a vortex including tv
    # even lv
    # whose objects we copy, since y.in
    
    if ($n == 0) {
        c&te =
        n ElvisWhob
        t.cs->('sc lastK c s','source');
        
        my $W = t.ntos->(c&te,'J');
        my $ii = W.sc.ii;
        t.cs->({s=>t.anii->($ii)},'source ii');
        
        ii.men.y.oun = ii.seg;
        ii.men.y.tw.singing.y.monic = ii.seg.y.tw.eye;
        ii.whatever = ii.seg.y.tw.ran;
        
        # is A, see for C too
        c&te = $W;
        c&ot = 'whole';
        c&ocv = 7;
        
        t.es->("See somewhat");
        
        my $uu = J.sc.ii;
        t.cs->({s=>t.anii->($uu)},'destination ii');
        
        is uu.men.y.oun, uu.seg, "men youn = seg";
        is uu.men.y.tw.singing.y.monic,
            uu.seg.y.tw.eye,
            "men singing ymonic = seg eye";
        isnt uu.seg, ii.seg, 'seg not seg';
        isnt uu.men.y.tw.singing, ii.men.y.tw.singing,
            'men singing not men singing';
        
        is uu.whatever, uu.seg.y.tw.ran, "whatever can be seg ran";
        isnt uu.whatever, ii.whatever, "whatever not whatever";
    }
    elsif ($n == 1) {
        # is C, we arg m=A to get understandings
        c&te = A.ii.theu;
        c&ot = 'whole';
        c&ocv = 7;
        t.toc.m = 'A';
        my $i = c&oi = G&Ct,[receiver=>5=>{s=>'whatisnow'},{efopia=>'n'}];
        ok !i.sc.ii, "i no ii yet";
        t.es->("A whole thing"=>''=>{grepl=>sub {
            s/ z\+\d+ /?z?/;
            $_[0] =~ /W\+of|  xot/;
        }});
        my $ii = i.sc.ii;
        ok $ii, "i has ii";
        isnt ii.D, A.ii.D, "D not D";
        isnt ii.i.y.tw.xot, A.ii.i.y.tw.xot, "xot not xot";
    }
    elsif ($n == 2) {
        c&te =
        n ElvisNothing
        
        t.cs->('sc lastK c s','ElvisNothing with it');
        my $mo = t.ntos->(c&te,'mo');
        my $W = t.ntos->(c&te,'J');
        is mo.ii, W.ii, "mo\.ii is J\.ii";
        is mo.ii.mo, W.ii.mo, "mo\.ii\.mo is J\.ii\.mo";
        isnt mo.ii, A.ii, "mo\.ii ! A\.ii";
        isnt mo.ii.mo, A.ii.mo, "mo\.ii\.mo ! A\.ii\.mo";
        isnt mo.ii.mo.y.in, A.ii.mo.y.in, "moiimoyin not Aiimoyin";
        my $traces = qr/^\S.+has:| xot| FindMeWhenYoure/;
        
        my $lmo = t.anii->(mo.ii);
        @$lmo = grep /$traces/, @$lmo;
        t.cs->({s=>$lmo},'source ii');
    }
    elsif ($n == 3) {
        c&te =
        n ElvisThinker
        
        t.cs->('sc lastK c s','ElvisThinker with it');
        my $mo = t.ntos->(c&te,'mo');
        my $W = t.ntos->(c&te,'J');
        is mo.ii, W.ii, "mo\.ii is J\.ii";
        is mo.ii.mo, W.ii.mo, "mo\.ii\.mo is J\.ii\.mo";
        isnt mo.ii, A.ii, "mo\.ii ! A\.ii";
        isnt mo.ii.mo, A.ii.mo, "mo\.ii\.mo ! A\.ii\.mo";
        isnt mo.ii.mo.y.in, A.ii.mo.y.in, "moiimoyin not Aiimoyin";
        my $traces = qr/^\S.+has:| xot| FindMeWhenYoure/;
        
        my $lmo = t.anii->(mo.ii);
        @$lmo = grep /$traces/, @$lmo;
        t.cs->({s=>$lmo},'source ii');
    }
ElvisNothing: |
    n nothi=>3=>'e'
ElvisWhob: |
    n do=>1
    my $mod = sub {
        my $of = shift;
        n /(.+)-()(.+)/,'%of:'.$of for @_
    };
    $mod->(qw{seg ran-dome eye-stuff taking-sat to-places});
    $mod->(qw{men singing-bride of-south east-cs});
    # random ii
    u alact
    n \'of:mo'
    duire 3:
        # pieces
    n \'of:u'
    moreso 2:
        # moreso
ElvisEltus: | # J u n u n, again and again
    my $t = Rw Telvis;
    
    my $joint = sub {
        my @l;
        ok(J.uosc,"have J(4)uosc");
        for (0..5) {
            my $s = J.uosc.>$_;
            J.firsj.>$n ||= $s;
            my $zo = s.c.zip.c.s.c.s;
            push @l, "$_: $s (ch:s.sc.ch)  ";
            next if !ref $zo eq 'HASH';
            for my $gi (sort keys %$zo) {
                my $o = $zo.>$gi;
                my $c = o.c.s;
                my $gl = c.c.m eq 'zip' ? t.grimd->( c.c.s )
                    : [ki c.c.s];
                push @l, "  $_ - $gi:  ", @$gl;
                
            }
        }
        \@l
    };
    if ($n == 0) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        isnt W.ii, J.ii, 'dif ii';
        
        my $lmo = t.anii->(J.firstuoscii = W.sc.u.sc.s.sc.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source u osc ii');
        J.joints.1 = $joint->();
        t.cs->({s=>J.joints.1},'pages of u s');
        push @{J.upageS||=[]}, {%{ W.sc.u.sc.S }};
    }
    if ($n == 1) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        isnt W.ii, J.ii, 'dif ii';
        
        my $lmo = t.anii->(W.sc.u.sc.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source u ii');
        
        is (J.firstuoscii, W.sc.u.sc.s.sc.ii, "Still u osc ii");
        my $lmo = t.anii->(W.sc.u.sc.s.sc.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source u osc ii');
        J.joints.2 = $joint->();
        t.cs->({s=>J.joints.2},'pages of u s');
        
        # TODO ids dont sync?
        # first first page of u's s is lost, next times it works
        # put questionmark at end of test name to see:
        t.cs->({rsl=>[map{@$_}map{J.joints.>$_ }1,2]},'two runs of pages of u s');
        push @{J.upageS||=[]}, {%{ W.sc.u.sc.S }};
        
        is scalar(uniq(map{values %$_}@{J.upageS})), 5, 'five waves of u';
    }
    if ($n == 2) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        push @{J.upageS||=[]}, {%{ W.sc.u.sc.S }};
        
        is scalar(uniq(map{values %$_}@{J.upageS})), 5, 'five waves of u';
    }
    if ($n == 3) {
        c&te =
        n ElvisEltussock
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /^\S.+has:| al\w+ 0/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
    }
ElvisEltussock: |
    J.4.uosc.0 = J.sc.u.sc.s;
    1 && sayyl "Time ".J.bowls++." is J.sc.ch";
    n alof
    J.4.uosc.1 = J.sc.u.sc.s;
    u alact
    tracks:
        # towards
    J.4.uosc.2 = J.sc.u.sc.s;
    five 5:
        5
    u alacgts
    zo:
        # hop
    J.4.uosc.3 = J.sc.u.sc.s;
    u alact
    zow:
        # hop
    J.4.uosc.4 = J.sc.u.sc.s;
    u alacgts
    zorw:
        # hop
    J.4.uosc.5 = J.sc.u.sc.s;
ElvisDialects: | # J u Dialect, deeply rooted # TODO TODO TODO
    my $t = Rw Telvis;
    #A.V = 1;
    #A.nowholeyet = 1;
    # if n (alof) before u (alact) then las
    
    # localised implica expanded into universal (still localised)
    # eg make everything acgt:s
    
    # how to isolate pure data entry from Jing
    # encode not sJ or anywhere in the mo that sJ:
    # so our J/their our-minded parts (eg n root) dont get the encoding
    
    #  # may want to use a clear head at mo J 5, ie
    # takes our readings of impulse in 4 to the control dome
    # J inter language space of 5, the permissions, net gear
    # so could A.ii = A.5.ii and T.seek=1 re G&t the throat
    # and eg the root n in J 6 will be a normal op
    
    #  # decompression wants to live in of=D and be for nonJ
    # and be the thing knowing/isolating a ghost
    # making A.D = receipt for the pin/scheme/O cause/elvis handling
    # or the convo/dialect state applied within
    # falling A bounds like .mo:
    
    # U al4noJ 3 spawns our encoding on the J6ing.mo:
    #     A.D = {self,J=A.D}
    #         marking D above ours (unless already) as the norm for doing J
    # then mo dome 2:
    #    A.D = A.D.J if c&J && A.D && A.D.J;
    #       peels off encodings/holes to A.mo.up.mo's intention
    #         for this A.mo, so it can speak nonJ n normally
    #   runs D
    #        with A.D for direction/self
    # and U al4noJ 7:
    #    finishes our encoding
    
    # D may make good interface to pages to reset (when J 6)
    # or unrestart (when S sleeps)
    # or partition (with names) and despatch to whatever process
    
    # so encodings should all of=D
    # a W reverses line protocols from remote stream
    # via m into golden box acum space
    # fills <5 at lum top, 8-9 lum/3, 7-8 lum/7, etc towards 555555555555
    # into streams of atoms for your A.3 to officially reposition
    # there's a ghost bridge
    
    # of=U = runs when mind made up/down
    # of=M = for the $M produced by 6, incs depth of atoms
    # of=S = check for escaping gas (sleeps minor changes)
    
    # A.2 to change to A.1 whenever
    
    # but for now:
    # the encodings are all in 42-43, which s& or cv=9 skips over
    # could be more pronounced how its not for J or its descendants
    #  by hanging encodings on/in an A.D, which replants at 6
    #  until that J brings its own mind onto the A
    # simple stuff should work
    
    my $Jay;
    G.tuberay = sub {
        my ($A,$C,$G,$T) = @_;
        $Jay || return;
        Jay.sc.ch ne '' && die "Jayscch changed: Jay.sc.ch";
    } if 0;
    
    if ($n == 0) {
        my $ec;
        ec.popi = t.popi;
        ec.popl.0 = "before any";
        # theu leaves ii, mo alof in ground, u s but not zip
        ec.popl.1 = "first n, normal mind"; 
        ec.popl.2 = "first u, mind still normal";
        # al* appears in mind
        ec.popl.3 = "n aft u";
        # new bit of u ground + blank u s for next page
        ec.popl.4 = "second u";
        ec.popl.5 = "finality";
        c&te =
        n ElvisDialecto=>W=>$ec
        
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
        
        my $W = t.ntos->(c&te,'J');
        my $traces = qr/^\S.+has:| al\w+ 0/;
        my $lmo = t.anii->(W.ii);
        @$lmo = grep /$traces/, @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        ok !W.ii.42, "Stuff in W not as W's mind";
    }
    elsif ($n == 1) {
        my $ec;
        ec.popi = t.popi;
        # has J.ii with alacgts from last round
        # we would be using A.ii from above
        # and u osc would be the whole=theu which skips zip
        ec.popl.0 = "reset ground, last u osc";
        ec.popl.1 = "first n, normal mind";
        ec.popl.2 = "first u, mind still normal";
        # al* appears in mind
        ec.popl.3 = "n aft u";
        # new bit of u ground + blank u s for next page
        ec.popl.4 = "second u";
        
        ec.popl.5 = "finality";
        c&te =
        n ElvisDialecto=>W=>$ec
        t.cs->('sc lastK c s','dialected change stuff');
        # see the W.sc.ii produced by W
        t.cs->({s=>t.lookii->()},'have ii');
        # see the W.ii used by W
        
        my $W = t.ntos->(c&te,'J');
        my $lmo = t.anii->(W.ii);
        @$lmo = grep {/^\S.+has:| al\w+ 0/} @$lmo;
        t.cs->({s=>$lmo},'dialect source ii');
        ok !W.ii.42, "Stuff in W not as W's mind";
    }
    elsif ($n == 2) {
        c&te =
        n ElvisDialecto
        t.cs->('sc lastK c s','dialect changes');
    }
    elsif ($n == 3) {
        c&te =
        n ElvisDialectos
        t.cs->('sc lastK c s','u Cee with i things once collasped in pin');
        t.cs->('sc lastA 1 sc u sc ii i y tw rand,nonext','see i rand');
        # T # the kind that keeps a fork waiting,
        # does the new ghost's remainder of this way, lexicals -> $ar
        # and maybe knows how to serve data/analysis forms to pud,
        # which keeps running in the end of the first run
    }
ElvisDialectos: |
    u Cee
    n $_=>2=>$_ for "Doowop";
    n $_ eq 4 && 3 || $_=>'3'.$_ => G&rand,7  for 1..7;
Cee: | # ways at C, see 2/Sea for C chewing/itself
    u alacgts
    n Tee
    rand:
        3
    peels: %subpeel
        qr/^[\{\%]\w+/;
    
    peel:
        return $s if ref $s;
        $s =~ s/^%//;
        my $c = {};
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c
    
    c: %acgt:D
        G&inDin,$C,@M;
    
    e: %acgt:D
        my $e = G&sces,C.c.e||return();
        G&inDin,$e,@M;
    
    us: %acgt:D
        my $e = G&sces,C.c.e||return();
        my $us = e.c.us||return();
        push @M, 'NOGK' if @M == 1;
        G&inDin,$us,@M;
    
    sces:
        my $i = 0;
        while (s.c.e) {
            $s = s.c.e;
            $i++ > 9 && die "HUGE $i recursing C.t CceCceCceCce... by ".ki $s;
        }
        return $s;
    
    inDin: %acgt:s D
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = G&interpD,@M if !ref $D;
        #
        my $v = G&Cngk,$s,$D;
        saybl "Got cnkgk: ".wdump 3,[\@M,$D,$v,$s] if A.VV.D;
        die "Unhandles any: $v: ".ki $D if $v eq '1';
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        @$v == 1 || die "Many somehowed ".wdump 3,[ki($D),$v];
        ($v) = @$v;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;
            return @$v;
        }
        return $v;
    
    interpD: %acgt:nk gk
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if ($nk =~ s/^(y|c|s)(?=\w+)//) {
            D.c.nk = $1 eq 's' ? 'sc' : $1;
            D.c.gk = $nk;
        }
        elsif (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    Cngk: %acgt:s D
        ref $A || die "nmonref A!";
        A.bangdesk.bang->{Cngek} = sub {
            sayre "was Cngk; ".ki($s)."\nWith: ".ki($D)
        } if 0;
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
Tee: | # determine & introgress
    u alacgts
    # intel s, c properties
    # \$whereclause
    ip: %acgt:s c
        my $z;
        $s = G&peel,$$s if ref $s eq 'SCALAR';
        my $n;
        if (ref $s eq 'REF') {
            # do s.do
            $s = $$s;
            $n = $s;
            s.ip || die "sip no ref";
            $s = {map{$_=> \s.ip.>$_ }keys %{s.ip}};
        }
        # n.all keeps going after a pass--
        my $pass = 1;
        EE: for my $k (keys %$s) {
            $pass == 1 || n.all || return 0;
            my $y = $s.>$k;
            my $x = $c.>$k;
            if (ref $y eq 'REF') {
                $y = $$y;
                if (exists y.nk) {
                    $x = $c;
                    for my $k (grep{defined}y.nk,y.gk,y.tk) {
                        $pass--, next EE unless
                            ref $x eq 'HASH' && exists $x.>$k;
                        $x = $x.>$k;
                    }
                }
                my $wa = $pass;
                !defined $x || $pass-- if y.ndef;
                defined $x || $pass-- if y.def;
                y.is eq $x || $pass-- if exists y.is;
                y.not ne $x || $pass-- if exists y.not;
                y.in->{$x} || $pass-- if y.in;
                !y.nin->{$x} || $pass-- if y.nin;
                $x > y.gt || $pass-- if exists y.gt;
                $x < y.lt || $pass-- if exists y.lt;
                $x >= y.gteq || $pass-- if exists y.gteq;
                $x <= y.lteq || $pass-- if exists y.lteq;
                $x =~ y.re || $pass-- if exists y.re;
                $pass = $pass < $wa ? $wa : $pass-1
                    if y.neg;
            }
            elsif ($y ne $c.>$k) {
                $pass--;
            }
        }
        $pass == 1
    
    xoy: %acgt:s c
        $c = G&xot,{},$c;
        G&xot,$c,$s;
        return $s;
    
    xot: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : $v;
        }
        return $s
    
    xo: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = $v;
        }
        return $s
    
    hup:
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for
            grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    
ElvisDialecto: | # TODO n alof before u alact drops stuff
    my $for = sub {
        my $i = shift;        
        c&popi && c&popl.>$i && c&popi ->($J,$i,$C);
    };
    
    $for->(0);
    n alof
    $for->(1);
    if (J.bowls++ < 2) {
        u alact
    }
    else {
        u alacgts
    }
    $for->(2);
    my $hum = ',cr:ab' if J.bowls > 1;
    jasm: %fo:late$hum
        # rubbing
    $for->(3);
    joints: %fo:river,of:42
        "southward $s"
    n \'of:not'
    semio:
        # tic tic;sdigjshgisdf
    u alacgts
    $for->(4);
    # no mind after first run...
    sedio:
        # tic tic
    $for->(5);
    

ElvisWay: | # J new Rw pin getter, 
    my $t = Rw Telvis;
    A.uyes = 1;
    #A.V = 1;
    if ($n == 0) {
        c&te =
        n ElvisWays
        t.cs->('sc lastK c s y l y tw w,nonext','ways of=w');
        t.cs->({s=>t.lookii->()},'have ii');
    }
    if ($n == 1) {
        my $h;
    
        c&te = 
        n ElvisWhay
        t.cs->('sc lastK c s','way holder, nothing with no cs');
        t.cs->('sc lastA 1 ii w,nonext','is holding shu');
        my $W = t.ntos->(c&te,'J');
        is W.t, 'ElvisWhay', 'Have holder J';
        is W.ii.w && W.ii.w.y.in.t, 'shu', 'Have shu in J';
        h.5 = $W;
        
        c&te = 
        n ElvisNotWhay
        t.cs->('sc lastA 1 ii w,nonext','Another holder');
        my $W = t.ntos->(c&te,'J');
        is W.t, 'ElvisNotWhay', 'Another holder 1 J';
        h.4 = $W;
        
        #W.ii = W.sc.ii;
        # ^ doesn't break W, is J, bystander/particle to A
        # those serving t must be holding it as .ii
        # T.o.J.t.ElvisWayer = G&Ct,'In5'=>3=>{inet=>5,s=>$J
        
        c&te = 
        n ElvisWaying=>W=>{house=>$h}
        t.cs->('sc lastK c s','looks of Elvis Waying');
        t.cs->({s=>t.lookii->()},'have no ii of waying');
        # 
    }
ElvisWaying: |
    n some=>1=>here
    my $Gw = G.w;
    G.w = A.i.w;
    G&xot,$A,$_ for c&house || die "Give house";
    A.5.ii && A.5.ii.w || die "House no w: ".wdump 1, A.5.ii;
    
    Rw shu + $C $nos:A.2 $job=0 etc;
    # ^ babs to:
    # $G->{w}->($A,$C,$G,$T,"lingophase",$ar,C=>$C,nos=>$A->{2},job=>"0",m=>["etc"]);
    Rw shu + $C $nos:A.2 $job=3;
    # the + mixes in ar at the front, becomes m[] if elsewhere
    Rw lingophase $C $nos:A.2 $noj=C.y.cv;
    
    Rw thinelse $C $nos:A.2 $noj=C.y.cv;
    
    G.w = $Gw;
    my $i = 2;
    n looks=>$i++=>{s=>"$_: ".C.sc.>$_ } for grep {!ref C.sc.>$_ } sort keys %{C.sc};
    
ElvisNotWhay: |
    u ElvisNotWays
    n othing=>1
ElvisNotWays: |
    #u alway
    # passed through of uncoded
    lingophase: %of:w
        C.sc.lingo = 'first phase';
    thinelse: %of:w
        C.sc.nothin = 'elsey';
ElvisWhay: |
    u ElvisWays
    n othing=>1
ElvisWays: |
    #u alway
    # passed through of uncoded
    shu: %of:w
        s&op = 3;
        s&mind = 'with arm' if ar.m;
        s&mindo = 'without arm' if !ar.m;
        s&job = join ' ',grep{defined} s&job, ar.job if defined ar.job;
    lingophase 3: %of:w
        s&lingo = 'second phase';
    
ElvisThinks: | # J uses u (mind), does stuff with it
    my $t = Rw Telvis;
    A.uyes = 1;
    if ($n == 0) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker made with mind');
        t.cs->('sc lastA 1 sc u sc s sc ii eloquence,nonext',
            'J u s ii eloquence');
        t.cs->({ntos=>'sc lastA 1 sc u sc s sc ii mo',
        nonext=>1,grepl=>sub{ $_[0] =~ /^\s+(fis|fscolour) / }
        },'J u s ii mo seems to be');
        
        my $mo = t.ntos->(c&te,'mo');
        
        is mo.t, 'mo', 'mot is mo';
        is mo.1.t, 'ElvisThinker', 'mo1t is ElvisThinker';
        is mo.1.sc.u.t, 'u', 'ut is u';
        my $usii = mo.1.sc.u.sc.ii;
        is ref $usii, 'HASH', 'ii is hash';
        for my $t (qw'eloquence mo') {
            my $is = $usii.>$t;
            is ref $is, 'HASH', "usii $t";
            for (qw'tv tw in') {
                is ref is.y.>$_, 'HASH', "usii $t has y$_";
            }
        }
        my $minds = [map{t.gout->($mo,$_)}qw'
            up y y-sc
            1 1-sc
            1-sc-u
            1-sc-u-sc
            1-sc-u-sc-s
            1-sc-u-sc-s-sc
            1-sc-s
            1-sc-s-sc
        '];
        t.cs->({s=>$minds},"ii in/around mo ElvisThinker");
        
    }
    elsif ($n == 1) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker again uses mind');
    }
    elsif ($n == 2) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker changes mind');
    }
ElvisThinker: |
    u ElvisThinking
    
    J.bowls++ < 2 &&
    u ElvisThought
    some: %fs:8
        tan goal
    further: %fis:5
        thought matters
    n random=>7=>\'mon:A,s:moon'
    #G.ouJ = $J;
ElvisThinking: |
    # for mo 
    FindMeWhenYoure: %acgt:s,of:i
        # anywhere
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.03 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    fscolour 4: %act,acgt:s,v:sfs,of:mo
        my $h = $fs + 7;
        my $l = int($h / 3) + 6;
        $h -= 9 until $h < 9;
        $l -= 9 until $l < 9;
        C.sc.hs ||= $h.'7'.$l;
    
ElvisThought: |
    # for mo, or Hoop & bend towards some over time...
    dosoooooooooooooooooooo: %of:eloquence
        3 + 4 / 33 + $s
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.06 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    monta 4: %act,acgt:s,v:cmon,of:mo
        c&s = "$mon c&s $mon" if exists c&s;
EpiWaveletting: | # J makes pi, join lv
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit');
        t.cs->('c zip sc top','Waveofit zip top');
        t.cs->('c zop sc top','Waveofit zop top');
    }
    elsif ($n == 1) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 2) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change/goner');
    }
    elsif ($n == 3) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 4) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 5) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
Waveofit: |
    my $ou = J.sc.ou ||= [3,6,44,2,42,3,7,12];
    J.bowls++ && J.bowls < 4 && shift @$ou;
    n ylinogj=>-waveofits=>{s=>$ou}
    J.bowls < 3 &&
    n dough=>3=>{pi=>'waveofit',s=>"Says so"}
    n etc=>6=>J.bowls
pi/waveofits: |
    pre 1: %hs:378,fs:19
        ~@@@~
    my $div = 6 / @$s;
    my $i;
    for (@$s) {
        n doing=>( G&rou,2+$div*$i++ )=>{s=>$_},'%hs:394,bo:3px solid 4873'.($_ > 20 && ',fs:'.($_))
    }
    
    (J.dimin ||= 12)--;
    reg 89: %fs:J.dimin
        hadu
    pos 9: %hs:376,fs:17
        ~@@@~
pi/waveofit: |
    pre 1: %hs:878,fs:19
        ~~~~~~
    n doing=>2=>{s=>$s},'%hs:394,bo:3px solid 4873'
    pos 3: %hs:876,fs:17
        ~~~~~~
ElvisWorlds: | # J makes J, gather We in self
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys');#
        t.cs->({s=>C&ofts},"ofts made");
        # TODO? zopul copies dupey z, relinked in/next is deduped
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 1) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys without Whysl');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 2) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys + Whysl again');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 3) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys not');
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 4) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 5) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 6) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
Whys: |
    J.herefirst = "Was htis";
    J.bowls++ != 1 &&
    n Whysl
    
    J.bowls > 3 &&
    not: %velo:iffry,oft:i
        negate
    mix: %acgt:s,v:chume,oft:i
        G&yellow,$C,'tool'
    elect: %acgt:s,v:chume,oft:i
        G&blues
        # e
    my $ms = J.bowls > 2 ? '# the sandy' : '# sandy';
    n music=>1=>{s=>$ms}=>'%acgt:s,v:sJ,oft:dowse'
    bull: %oft:tools
        motorise time machine
    trail 16: %acgt:s,v:cmoresel,oft:tools,Wv:2
        1c&dol++;
    
Whysl: |
    J.bowls++ < 2 ||
    n skinny=>4=>{}
    J.herefirst && die "Was not J.t";
    my $hum = ',hum:'.(J.bowls+2) if J.bowls == 2 || J.bowls == 3;
    
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
    mix: %acgt:s,v:chume,oft:i$hum
        G&yam,$A,'tool';
    dowse: %acgt:s,v:sJ,oft:dowse
        G&yam,$A,'tool';
    trail 22: %acgt:s,v:ctar,oft:tools
        # and
        1c&dali++;
    J.bowls < 5 &&
    trail 16: %acgt:s,v:ctar,oft:tools,Wv:2
        # or
        1c&dali++;
        
    
        
        
ElvisWads: | # J in J (both W) simplicity
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad');
        ok !exists C&ofts, 'no ofts';
        t.cs->('c zop sc top','ElWad zop top');
        #$tos->('s1omp/sc lastK c s','two wormholes unite');
    }
    elsif ($n == 1) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 2) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed');
    }
    elsif ($n == 3) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed back');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 4) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still changed back komp');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 5) {
        c&te =
        n ElWadill=>W=>{rando=>'M'}
        t.cs->('sc lastK c s','ElWadill randomly');
        t.cs->('c zop sc top','ElWadill zop top');
    }
ElWad: |
    n ElWadill
    my $hum = ',hs:394' if J.bowls++ == 2;
    n noise=>3=>"Samp"=>'%hs:445'
    n nose=>4=>"Samp"=>'%hs:445'
    dji 314159: %fs:40$hum
        blos
ElWadill: |
    More:
        Noise!
    c&rando ||
    Than:
        before
    since:
        sync
    c&rando &&
    n c&rando=>87=>"With sides"
    
ElvisWorld: | # J makes, puts elvised We in self
    my $e = A.ii.theu;
    my $ot = "this";
    my $o;
    
    my $tos = sub {
        my ($c,$t) = @_;
        $c = {ntos=>$c} if $c && !ref $c;
        $ot = $1 if c.ntos =~ s/^(\w+)\///;
        map { G&xot,$c,$_ } G&peel,$1 if c.ntos =~ s/,(.+)$//;
        $tes->($t,1,$c)
    };
    my $ntos = sub { # get the oscillator A (s) given e is n of J
        my $j = shift;
        ($j) = values %{j.c.tug};
        $j = j.c.s || die "No C on ".ki$j;
        # the last Hows mo C
        $j = j.sc.J || die "No J on ".ki$j;
        $j = j.sc.s || die "No s on ".ki$j;
        $j = G&pint,$j,@_ if @_;
        $j
    };
    my $toc = {};
    c&mks = sub {
        my ($C,$T) = @_;
        T.oke = 1;
        my $se = $e;
        if (my $p = c&ntos) {
            my $sp = sub {[split / |,/, shift ]};
            my $output = $sp->($1) if $p =~ s/^(.*)\?( .+)?$/$1$2/;
            $p = $sp->($p);
            $se = $ntos->($se);
            
            if ($output || C.c.see) {
                $output ||= $sp->(C.c.see) if C.c.see && C.c.see ne '1';
                oJ.output = $output ? G&pint,$se,@$output : $se;
                C.c.return ||= oJ.output;
                return [] if C.c.see;
            }
            
            $se = G&pint,$se,@$p
        }
        C.c.return ||= $se;
        my $AV;# = delete A.V;
        my $oc = {};
        oc.noz = 1 if c&noz;
        oc.nonext = 1 if c&nonext;
        $oc.>$_ = $toc.>$_ for keys %$toc;
        $o = G&A,o=>6=>$J=>$se,[$ot,'',$oc];
        A.V = $AV if $AV;
        
        #A.V = 1 if $n == 10;
        # c&tac=1;
        
        my $l = o.c.rsl || die "no rsl";
        
        (A.V || A.Ve || C.c.question) &&
        1 && saybl "the $ot: ".$_ for @$l;
        $l
    };
    if ($n == 0) { #c
        #A.V = 1;
        $e =
        n Hows
        $tos->('zuptop/c zip sc top','Hows zip top');
        $tos->('zoptop/c zop sc top','Hows zop top');
        $tos->('zupp/c zip sc aroz,noz','Hows zip aroz');
        $tos->('zup1zop/c zip sc zop,noz','Hows zip zop');
        $tos->('zop1allz/c zop sc aroz,noz','Hows zop aroz');
    }
    elsif ($n ==1) {
        $e =
        n Hows
        my $zip =
        $tos->('zlp/c zip? sc top','Hows zip top again');
        delete oJ.output;
        my $cha = zip.c.cha.C;
        is 0+keys%$cha, 3, "3 changed";
        my $gone = cha.gone;
        ok $gone, "was gone";
        is join(', ',sort keys %$gone), 'skinny', "gone has keys == skinny";
        my $sk = G&pint,$gone,skinny=>0.4;
        is sk.t, 'skinny', "skinny is";
        ok !G&pint,$gone,Hows=>0.9 , "Hows tv not gone";
        ok !G&pint,$gone,'Hows' , "Hows t not gone";
        
        my $u =
        $tos->('zop2top/c zop? sc top','Hows zop top');
        delete oJ.output;
        $tos->({s=>u.c.rsl},'zop rsl shows goner');
        toc.noz = 1;
        $tos->('zup2zop/c zip sc zop','zip zop shows gone skinny');
        $tos->('zop2zop/c zop sc zop','zop zop shows gone skinny');
        $tos->('zop2inz/c zop sc inz','zop inz shows gone skinny');
        $tos->('zop2outz/c zop sc outz','zop outz shows gone skinny');
        delete oJ.output;
        delete toc.noz;
        $tos->('scomp/sc lastK c s','compression of gone skinny');
    }
    elsif ($n == 2) {
        $e =
        n Hows
        
        $tos->('zlo3p/c zip sc top','Hows zip top shows new trail');
        $tos->('zol3p/c zop sc top','Hows zop top shows new trail');
        # cant look at zop/inz because unhandled duplicate ty of trail
        $tos->('s3omp/sc lastK c s','compression of etc + trail');
    }
    elsif ($n == 3) {
        $e =
        n Hows
        
        $tos->('zlo4p/c zip sc top','Hows zip top shows changed trail');
        $tos->('zol4p/c zop sc top','Hows zop top shows changed trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        $tos->('s4omp/sc lastK c s','compression of etc + changed trail');
        
        my $ii = 
        $tos->('s4ii/sc ii? tools,nonext','made ii tools');
        delete oJ.output;
        $tos->({s=>[ki$ii,1]},"ii looks good");
        my $s = $ntos->($e);
        is s.sc.ii, $ii, "ii same a tos'd return";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.1;
        is H.t, 'Hows', "lastA for-particle";
        is H.sc.ii, $ii, "ii same on A2sii";
        ok !exists H.sc.i, "no i on A2si";
    }
    elsif ($n == 4) {
        #A.V = 1;
        #return;
        # explodes: unpositing into zopul makes empty We thing
        $e =
        n Hows
        
        $tos->('zlo5p/c zip sc top','Hows zip top shows gone trail');
        $tos->('zol5p/c zop sc top','Hows zop top shows gone trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        my $s = $ntos->($e);
        ok !exists s.sc.ii, "no ii on s";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.1;
        is H.t, 'Hows', "lastA for-particle";
        ok !exists H.sc.ii, "no ii on A2sii";
        ok !exists H.sc.i, "no i on A2si";
        #G.ouJ = j.sc.lastK.c.s;
        $tos->('s5omp/sc lastK c s','compression of gone trail');
    }
    
Hows: |
    J.sc.u.c.o = 'oscd';
    my $so = 's o,towe:l';
    $so = 's,tele:vise' if J.bowls;
    rakes: %acgt:$so
        robino
    
    leaves: %some:other,ma:ni,fo:la,t:e
        traces
    
    J.bowls &&
    surf:
        to rise
    
    J.bowls++ ||
    n skinny=>4=>{}
    my $hum = ',hum:4' if J.bowls == 4;
    J.bowls >= 3 && J.bowls <= 4 &&
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
        
        
        
        
        # and
        1c&dali++;
oft: | # test of
    1 && saybl "We things C.c.W named C.t C.y.cv:   ".ki C.c.e;
    # should hup & acum C.sc.z
    push @{ A.4.c.testC.sc.ofts ||= [] },
        "We things C.c.W named C.t C.y.cv:   ".ki C.c.e
        if A.4.c.testC;
    for my $e ( e&_cz ) {
        ec&s =~ s/\n\s*\n+/\n\n/sgm;
        es&seen = 2;
        ec&code = sub { "does e.t e.y.cv from C.t" };
    }
    C.sc.hi = 'lo';
    T.nose = 1;
    
ElvisLeaves: | # data vs o, watch change
    #A.V = 1;
    #exit if $n > 3;
    my $tf = 't/Zupe/ElvisLeaves/theu';
    DumpFile($tf, A.ii.theu) unless -f $tf;
    my $e = J.theu ||= LoadFile($tf);
    my $o;
    my $ot = 'zimb';
    
    my $lshot = sub {
        my ($C,$l) = @_;
        my $m = c&lshot;
        return unless @$l > $m;
        @$l = (@{$l}[0..$m]);# "... snip x".(@$l-$m));
    };
    c&mks = sub {
        my $C = shift;
        $o = G&A,o=>6=>$J=>$e,$ot;
        
        #A.V = 1 if $n == 10;
        
        my $l = o.c.rsl;
        #  c&tac = 1;
        
        c&lshot && $lshot ->($C,$l);
        (A.V || A.Ve) &&
        saybl "the Dujis: ".$_ for @$l;
        $l
    };
    
    if ($n==0) { #c
        $tes->('whole u','',{lshot=>32});
    }
    elsif ($n==1) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Here';
        $m = e.sc.z->[3];
        $m = m.y.in;
        $m = m.y.next || $m for 1..3;
        m.sc.epl = "Dop";
        m.c.s = "ACGT {} !";
        e.sc.eo = 'popup';

        $m = e.sc.z->[5];
        $m = m.y.in;
        $m = m.y.next || $m for 1..2;
        
        my $pr = m.y.prev;
        G&apart,next=>$pr;
        pr.sc.herre = 'OOOO';

        pop @{e.sc.z};
        
        $tes->('u messed with');
    }
    elsif ($n==2) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Hur';
        $m = e.sc.z->[1];
        $m = m.y.in;
        G&apart,next=>$m for 1..3;
        G&toget,next=>m.y.next.y.next,$_ for G&Ct,[available=>6=>'makeether','%eo:fil'];
        $tes->('couple more');
    }
    elsif ($n >= 3 && $n <= 4) {
        $ot = 'dwell';
        my $la = G&Ct,[row=>6=>is=>'%hs:588'];
        my $te = G&Ct,[seen=>8=>is=>'%hs:588'];
        $e = [
            G&Ct,[row=>1=>is=>'%hs:588'] ,
            G&Ct,[reow=>1=>is=>'%hs:588'] ,
            G&Ct,[rodw=>5=>is=>'%hs:588'] ,
            $la, $te
        ];
        $e = G&Ct,[wo=>2=>{}=>{z=>$e}];
        
        if ($n == 3) {
            $tes->('el=1 when dup t');
        }
        else {
            la.t = 'som';
            te.sc.hs = 359;
            te.sc.know = 'ing';
            $tes->('mount');
        }
    }
    elsif ($n >= 5 && $n <= 8) {
        my $mo = e.sc.z->[1];
        my $om = G&Ct,[J=>4=>'codedpassage'=>'%acgt:3'];
        my $z = [
            $om,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        my $lom = G&Ct,[mo=>0.001=>{W=>'of'},{z=>$z}];
        my @io = (
            G&A,o=>2=>$J=>$mo,'Themo' ,
            $n < 7 && G&A,o=>2=>$J=>$lom,'Extra'
        );
        $e = {map{_.c.sip => $_ }grep{$_}@io};
        $ot = 'zip';
        
        if ($n == 5) {
            # c&mks ->();
            $tes->('W over without innards');
        }
        elsif ($n == 6) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over change some');
        }
        elsif ($n == 7) {
            mo.y.in.sc.casa = "case $n";
            $tes->('W over, chang, Extra gone');
        }
        elsif ($n == 8) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over, more change');
        }
    }
    elsif ($n == 9) { #c
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[snapsof=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see two');
    }
    elsif ($n == 10) {
        $ot = 'thanks';
        my $z = [
            G&Ct,[movie=>3=>'mae'=>{acgt=>3}] ,
        ];
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>{acgt=>3,z=>$z}] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see one go, one come');
    }
    elsif ($n == 11) {
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see z disappear');
    }
    my $so = $o;
    my $one = 0.001;
    #$so = so.c.oo.C.theu.>$one;
    $so = J.sc.jo.zip.sc.oo.C.mo.>$one; # from oJ, the zip's mo 0.001
    return {p=>33};
    $so = so.sc.jo->{"z mo $one"};
    $so = so.c.Co; # the C currently othering under the recursionship of j
    $so = so.c.j.sc.oo.C.W; # through to the j again, all C it can see named W

