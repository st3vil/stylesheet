Sea: | # folds of the day
    u i
    # start C by t,c/s
    s: %acgt:t c
        return $t if ref $t eq 'HASH' && ref t.y && t.y ne $t;
        $C = {};
        C.t = $t;
        C.y = {};
        C.c = ref $c eq 'HASH' ? $c : {s=>$c};
        $C
    # start C
    Ct:
        my $C = {};
        G&Cs,$s;
        $C;
    # parse [This=>3=>{etc}] into your C
    Cs:
        my ($t,@e) = @$s;
        my $cs;
        if (ref $t eq 'SCALAR') {
            C.c = G&peel,$$t;
            $cs++;
        }
        elsif (ref $t eq 'ARRAY') {
            die "Aray: ".wdump 3, $s;
        }
        elsif (ref $t eq 'HASH') {
            G&xot,$C,$t;
            return;
        }
        elsif (ref $t) {
            die "reft: ".wdump 3, $s;
        }
        else {
            C.t = $t;
        }
        if (!@e && !$cs) {
            C.c.W = C.t;
        }
        else {
            my ($y,$c,$sc,@ex) = @e;
            C.c.s = $c if !ref $c && @e > 1;
            C.c = $c if ref $c eq 'HASH';
            C.c = G&peel,$$c if ref $c eq 'SCALAR';
            $sc = G&peel,$$sc if $sc eq 'SCALAR';
            $sc = {} if $sc eq '';
            $sc = G&peel,$sc if !ref $sc;
            C.sc = $sc if $sc;
            if (ref $y eq 'HASH') {
                if (y.y) {
                    C.c.e = $y;
                    C.c.W ||= C.t;
                }
                else {
                    C.y = $y;
                }
            }
            if (!ref $y) {
                C.c.pi = $1 if $y =~ s/^-(\w+)//;
                C.c.W = C.t if $y =~ s/^W$//;
                $y = 1 if $y eq '';
                C.y.cv = $y;
            }
            C.y.cv /= 10 until C.y.cv < 1;
            die "Extra: ".wdump 3,$s if @ex;
        }

    # osc blinds previous empirica
    Chade:
        my $C = {};
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = s.c.s if exists s.c.s;
        C.sc = {%{s.sc}};
        return $C;
    # make an other holding it (s) at same ty
    # s usu. copy already, hs is origin
    Chs: %acgt:s hs
        my $C = {};
        C.y.A = $A;
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = $s;
        C.c.hs = $hs if $hs;
        return $C;

    # round number
    rou:
        0.0001 * int(10000*$s)
    # 33 -> 0.33
    sca:
        $s /= 10 while $s > 1 || $s < -1;
        $s
    
    # check for rounded datastructure, non sprawl into A
    oleak: %acgt:s n
        length(wdump $n,$s) < length(wdump $n+1,$s);
    
    #c ways at C, see 2/Sea for C chewing/itself
    peels: %subpeel
        qr/^[\{\%]\w+/;
    
    peel:
        return $s if ref $s;
        $s =~ s/^%//;
        my $c = {};
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c
    
    pang: %acgt:s def
        my ($nk,$gk) = $s =~ /^([tycs])?(.+)$/;
        $nk = 'sc' if $nk eq 's';
        $nk = $def || 'sc' if !$nk;
        $nk && $gk || die"strv:$s";
        ($nk,$gk);
    
    # determine/intel s, c properties
    # \$whereclause
    ip: %acgt:s c
        my $z;
        $s = G&peel,$$s if ref $s eq 'SCALAR';
        my $n;
        if (ref $s eq 'REF') {
            # do s.do
            $s = $$s;
            $n = $s;
            s.ip || die "sip no ref";
            $s = {map{$_=> \s.ip.>$_ }keys %{s.ip}};
        }
        # n.all keeps going after a pass--
        my $pass = 1;
        EE: for my $k (keys %$s) {
            $pass == 1 || n.all || return 0;
            my $y = $s.>$k;
            my $x = $c.>$k;
            if (ref $y eq 'REF') {
                $y = $$y;
                my $exi;
                if (exists y.nk) {
                    $x = $c;
                    for my $k (grep{defined}y.nk,y.gk,y.tk) {
                        $pass--, next EE unless
                            ref $x eq 'HASH' && exists $x.>$k;
                        $exi = exists $x.>$k;
                        $x = $x.>$k;
                    }
                }
                my $wa = $pass;
                !defined $x || $pass-- if y.ndef;
                defined $x || $pass-- if y.def;
                !$exi || $pass-- if y.nexi;
                $exi || $pass-- if y.exi;
                y.is eq $x || $pass-- if exists y.is;
                y.not ne $x || $pass-- if exists y.not;
                y.in->{$x} || $pass-- if y.in;
                !y.nin->{$x} || $pass-- if y.nin;
                $x > y.gt || $pass-- if exists y.gt;
                $x < y.lt || $pass-- if exists y.lt;
                $x >= y.gteq || $pass-- if exists y.gteq;
                $x <= y.lteq || $pass-- if exists y.lteq;
                $x =~ y.re || $pass-- if exists y.re;
                $pass = $pass < $wa ? $wa : $pass-1
                    if y.neg;
            }
            elsif ($y ne $c.>$k) {
                $pass--;
            }
        }
        $pass == 1
    
    xoy: %acgt:s c
        $c = G&xot,{},$c;
        G&xot,$c,$s;
        return $s;
    
    xot: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : $v;
        }
        return $s
    
    xo: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = $v;
        }
        return $s
    
    hup:
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for
            grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    
With: | # J's stuff, its Js, osc page, etc.
    u i
    
    # make/return J as named universal
    sJ: %acgt:J t
        J.sc.>$t ||= G&J,$J,$t;
    
    # make J, they inherit non c/sc
    J: %acgt:from t
        ($from,$t) = (A.1,$from) if !defined $t;
        my $J = do {
            my $A = $from;
            G&A,'J';
        };
        J.t = $t;
        J.y.G = $G;
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,u=>8=>$J,\@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,n=>8=>$J,\@Me };
        delete(J.u), delete J.n if $t ne 'os';
        $J
    
    # join the A (with .c.s = C) to the J
    # and gives A.c.n
    ground:
        A.c.n ||= G&sJ,A.1,'n';
        my $ch = A.1.sc.ch || '';
        my $sip = s.c.sip || die "no ip: ".ki$s;
        A.c.n.sc.a->{$ch}->{$sip} = $s;
    
    # get ground zip off J, or osc/ch s
    grind: %acgt:J s
        my $ch;
        if (ref $s) {
            $ch = s.sc.ch;
        }
        elsif ($s) {
            sayre "Getting ground J.t/$s";
            $ch = $s;
        }
        $ch = J.sc.ch if !defined $ch;
        $ch = '' if !defined $ch;
        T.givech = $ch if exists T.givech;
        my $n = G&sJ,$J,'n';
        my $zip = n.sc.a->{$ch};
        defined $zip && keys %$zip && $zip
        
    # partition ground - increment ch and swap out the s
    # all osc s live on Js&S by channel they're for
    # channel is the time dive/page
    # main street (Js&ch aimed) being '', 1, 2...
    sesh: %acgt:J
        my $n = G&sJ,$J,'n';
        J.sc.ch = '' if !defined J.sc.ch;
        n.sc.a->{J.sc.ch} ||= {}; # so rea goes through blank pages
        my $o = J.sc.S->{J.sc.ch} = G&sJ,$J,'s';
        delete J.sc.s;
        my $ch = ++J.sc.ch;
        my $s = J.sc.s = J.sc.S->{$ch} ||= G&sJ,$J,'s';
        o.sc.next = $s;
        s.sc.prev = $o;
        # makes osc thing.3 etc hang around
        # TODO s adds to .root? files under ch
        # which could mean layer or page
        s.sc.ch = $ch;
    
    # reset ground '', 1, 2...
    rea: %acgt:J s
        my $n = J.sc.n || return;
        Js&S.>Js&ch = G&sJ,$J,'s';
        my $zi = ++J.c.zi;
        my $ch = '';
        my $lim = 2;
        my $rm = {};
        while (n.sc.a->{$ch}) {
            J.sc.Z->{$zi}->{$ch} = $rm->{$ch} = delete n.sc.a->{$ch};
            if ($zi > $lim) {
                delete J.sc.Z->{$zi-$lim}
            }
            $ch++;
        }
        J.sc.ch = '';
        delete J.c.o;
        delete J.sc.s;
        J.sc.s = Js&S.>Js&ch ||= G&sJ,$J,'s';
    
    # adapt to J interior as perhaps exterior
    # here A.1 is the doer
    n: %acgt
        pop @Me;
        G&A,n=>8=>A.1,\@Me;
    u: %acgt
        pop @Me;
        G&A,u=>8=>A.1,\@Me;
    # many slide by slightly and then get nailed down
    m: %acgt
        pop @Me;
        sayre "In out ".wdump 3, \@Me;
    
Tunnel: | # mind & world
    # machine for finding pi
    # reality is a cave system
    u a
    # dialect of ...
    u 1:
        A.2 = shift @$s; # for
        A.1 = G&sJ,A.3,'u';
    u 2:
        if (A.1.c.o) { # uJ's orderliness mark
            # also its current position relative to itself
            # make many pages of u per A.2 (A.1 doing u)
            G&sesh,A.1;
        }
    # hardwire u's u
    u 3:
        my $n = A.c.n = G&A,n=>1=>A.1,@$s;
        n.c.u.c.whole = 'theu';
        G&A,$n,8;
        # pull on if not cached mindset (various W merged)
    n 1:
        ref $s ne 'ARRAY' && die "No :".wdump 4, [A.c.N, $s];    
        A.1 = shift @$s;
        A.4 || sayre "NO A4: A.t";
        A.c.u = G&sJ,A.1,'u';
    # ground assembles mind
    n 2:
        my $u = A.c.u;
        return if A.1.t eq 'os';#|| !A.uyes;
        if (!u.c.o) {
            u.c.base = 'theu'; # the PiMachine
            # base if grind (ground, needs root), whole if just theu
            my $rev = ".u.sc.ch" if u.sc.ch;
            my $V = A.1.t =~ /^[A-Z]/;
            my $gr = G&grind,$u;
            if ($gr) {
                G&A,n=>8=>$u=>[uuu=>9=>{root=>1}];
                # slowly opening & closing a J of the u better than ^
                # but also want to hold u n at 3 til cachable known
                # the relevant page of s (man sesh) then ^ getting whole=?
                # those u s pages get cached somewhere in 4stw.ucache
                #   if simple enough
            }
            $V && saybl "resolves mind$rev: A.1.t".($gr && " (u)");
            # resolve our mind
            my $so = G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 1
            if (u.sc.ii) {
                # A.mo = the 6er this n is mindupping
                # A = this A, already fell off A.mo
                # A.1 = an fyi for the J, may want only the most something mind
                for (A.mo, $A, A.1) {
                    _.ii = u.sc.ii;
                    _.i = u.sc.i || die "No i on A.1.t u";
                }
                # the mo of A.2 minds from above til here
                # a J's mind has how to get into a J and do its mind
                # see Elvising for inside-outside cooperation
            }
            else {
                sayre "No ii on A.1.t u (o Whole TODO?)";
                for (A.mo, $A, A.1) {
                    _.ii = A.4.ii;
                    _.i = A.4.i || die "No i on A.1.t u ish A.4.t not-whole";
                }
            }
        }
    # foldout tape - ground creates moment
    n 3:
        @$s = ([@$s]) if ref $s->[0] ne 'ARRAY';
        A.m = $A;
        for my $l (@$s) {
            my $mo = G&tugA,mo=>1,@$l;
            G&ground,$mo unless mo.c.s.c.nogro;
            A&mo = $mo;
        }
        delete 1c&o; # orderliness
    n 4:
        # become aware of past, surface vibration
    n 5:
        # more thinks
    n 6:
        # etc
    n 7:
        # compress
    n 8:
        # intertime
    mo 1:
        A.mo = $A;
        # sprung from n/author, separate put words...
        G&Cs,$s;
    mo 17:
        C.y.cv = 0.1 if C.y.cv eq '';
    # A.ii gets inner's mind, should T.seek
    mo 5:
        # 
    mo 8:
        A.up.la = $A; # never happens?
Jelly: | # mo Town making
    u c
    n \'of:mo'
    # a wake of dynamics to the same particle
    pi 12:
        $pi || die "Give pi: ".ki$C;
        c&J = "pi/$pi";
    # W by name
    W 12:
        ref $s && die;
        $W = c&W ||= C.t if !$W;
        c&J = $W;
        A&Jup = A.4;
        A&Jcv = 0.1;
        s&W = $W;
        # dhcp replanty A.c.ip
    # see self already
    J 2:
        my $J = s&J && return;
        A&Jup ||= A.1;
        $J = G&pint,A&Jup,sc=>Jtv=>C.t,A&Jcv||C.y.cv;
        s&J = $J;
        # 1 wants J indexing through rest of now ^
        #     could be for types of the J present,
        #     for doing m organisation
        # via the osc to it could replant the Jtv
        # preserving the tubing if same J, like Hypno
        G&pint,A&Jup,sc=>tv=>C.t,C.y.cv;
    J 3:
        if (!s&J) {
            s&J = G&J,A&Jup,C.t;
            length(C.t) > 2 && sayyl "J ! C.t";
        }
        A.3 = s&J if c&W;
        A.2 = A.1;
        A.1 = s&J;
        # J inherits from A before ^
        s&J.1 = s&J;
        s&J.2 = A.2 if s&J.2 eq A.4;
        s&J.3 = s&J if c&W;
    pi 3:
        my $J = s&J;
        Jc&d = A.2.c.d + 1;
        Js&name = "J.c.d $pi*C.t";
        s&pi = $pi;
        # distance from A.3 as ip
    
    # J.C/T wants to be? drop in A spawn?
    # the 1Cs&la babs to A.1.c.s.sc.la
    
    u s
    # humming - superline timetug - osc exports that door us here
    # outside the fully self/u mind
    # can see network protocols of elvias
    # A&E would know if it wants to go in
    J 4:
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        
        Rw Js&amb $J if !c&e && Js&amb;
        
        # T wants ha or v wants T (by now, etc)
    
    # impulse -> in pulse
    J 5:
        A&pin = c&pin || c&J || s&J ->{t};
    
    # do the pin
    # could do M-odulate 
    J 6:
        T.nose && return sayyl "C.t 6 knows";
        Js&n && G&rea,$J;
        Js&u && G&rea,Js&u,$J;
        #A.1 = $J;
        my $ise = c&e && " (e:".c&e ->{t}.")";
        saybl "St J.t / A.1.t  (A&pin)$ise";
        my $c = {root=>1};
        my $y = {cv=>0.9};
        my $sc = y.at = {};
        my $r = J.sc.root = G&A,n=>1=>$J=>[J.t,$y,$c,$sc];
        my $M = [];
        my $ar = c&ar || {};
        my $s = c&s;
        local A.V = 2;
        Rw A.c.pin + $J $y $M $s;
        T.nose && return;
        c.M = $M if @$M;
        G&A,$r,8;
    
    # do the oscillator
    J 7:
        T.nose && return
            sayyl "C.t knows";
        # temp - of wants to load elvis understanding like route handlers
        A&Jup ->{sc}->{Jtv}->{C.t}->{C.y.cv} = s&J;
        
        sayyl "Oscillate J.t";
        G&A,s=>8=>$J;
        sayyl "Oscillate J.t done!@!";
    
    # coms to overT
    J 8:
        my $oT = A.mo.up.mo.c.T;
        oT.op = 1s&s.sc.top;
    
Compliers: | # othered
    u i
    # join/etc linked lists
    toget:
        G&together,$s,@Me
        
    together: %acgt:k c d
        my $o = c.y.>$k;
        c.y.>$k = $d;
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            d.y.>$ok = $c;
            if ($o) {
                d.y.>$k = $o;
                o.y.>$ok = $d;
            }
        }
    
    apart: %acgt:k c d
        $d ||= c.y.>$k;
        my $o = d.y.>$k;
        delete c.y.>$k;
        if ($o) {
            if ($c eq $o) { # mutual
                delete d.y.>$k;
            }
            else {
                c.y.>$k = $o;
            }
        }
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            delete d.y.>$k;
            if ($o) {
                delete d.y.>$ok;
                o.y.>$ok = $c;
            }
        }
    
Walks: | # othering, many C
    u i
    # k into hash path    also T/ip
    pint:
        for (@Me) {
            return unless ref $s eq 'HASH' && exists $s.>$_;
            $s = $s.>$_;
        }
        $s
    # hash ordering
    hord: %acgt:s head tail
        my ($he,$ta) = ([],[]);
        $head ||= [qw't cv y c sc'];
        $tail ||= [qw's z'];
        my $tw;
        for ([$he=>$head],[$ta=>$tail]) {
            my ($to,$k) = @$_;
            for my $t (@$k) {
                $s.>$t || next;
                $tw.>$t ++;
                push @$to, $t;
            }
        }
        my @mi = sort grep { !$tw.>$_ } keys %$s;
        [ map { [ $_ => $s.>$_ ] } @$he, @mi, @$ta ];
    # make yt (cv/t) from tv (t/cv)
    yttv: %acgt
        my $yt = {};
        for my $on (@Me) {
            G&chew,$on,'t,cv',$_ for sub {
                my ($o,$t,$cv) = @_;
                $yt->{$cv}->{$t} = $o;
            };
        }
        $yt
    # iterator/map for index
    chew:
        G&Chew,$s,@Me
    Chew:
        my $sort;
        my $it = pop @Me if ref $Me[-1] eq 'CODE';
        if (@Me == 1) {
            my $i = shift @Me;
            if (ref $i eq 'SCALAR') {
                $sort = 1;
                $i = $$i;
            }
            @Me = split ',', $i;
        }
        my $in;$in = sub {
            my ($p,$s,$i) = @_;
            if (!@$i || @$i==1 &&
                ref $s ne 'HASH' && $i->[0] =~ /\?$/) {
                return [$s,@$p];
            }
            defined $s || return;
            die "NO ".wdump 3,[$p,$s] if ref $s ne 'HASH';
            shift @$i;
            my @r = keys %$s;
            @r = sort @r if $sort;
            map {
                my $v = $s.>$_;
                $in->([@$p,$_],$v,[@$i]);
            } @r;
            
        };
        my @are = grep{defined} $in->([],$s,[@Me]);
        if ($it) {
            $it->(@$_) for @are 
        }
        else {
            sub { shift @are }
        }
        
    
    # hash then & now, makes histories
    # prop up non val o.c.$cha.$nk.$gk = {}
    # which unify cha ne same into o.c.cha.$cha.$nk.$gk 
    # {} may extend meaning, eg z tys into
    Chang: %acgt:l o
        my $E = l.c.s if $l;
        my $e = o.c.s;
        my @p = (['t'],[y=>'cv'],[c=>{}],[sc=>{}]);
        while (@p) {
            my $p = shift @p;
            my ($nk,$gk) = @$p;
            my $u = $E.>$nk; # Eustobe
            my $v = $e.>$nk; # revelation
            if (ref $gk) {
                keys %$gk == 0 || die "Given a ref: ".ki $gk;
                $gk.>$_++ for keys(%$u), keys (%$v);
                unshift @p, [$nk,$_] for keys %$gk;
                next;
            }
            my $i = {};
            if ($gk) {
                if (!exists $u.>$gk) {
                    o.c.new.>$nk.>$gk = $i;
                }
                elsif (!exists $v.>$gk) {
                    o.c.gone.>$nk.>$gk = $i;
                }
                elsif ($u.>$gk ne $v.>$gk) {
                    o.c.diff.>$nk.>$gk = $i;
                }
                else {
                    o.c.same.>$nk.>$gk = $i;
                }
                
            }
            else {
                if (!exists $E.>$nk) {
                    o.c.new.>$nk = $i;
                }
                elsif (!exists $e.>$nk) {
                    o.c.gone.>$nk = $i;
                }
                elsif ($u ne $v) {
                    o.c.diff.>$nk = $i;
                }
                else {
                    o.c.same.>$nk = $i;
                }
            }
        }
        for (grep { o.c.>$_ } qw'new gone diff') {
            o.c.cha->{$_} = o.c.>$_;
        }
    # sort by many y.As
    sortysip:
        my $so;$so = sub {
            my ($i,@try) = @_;
            my ($yk) = @try;
            my ($c,$d) = (a.y->{$yk},b.y->{$yk});
            $c && $d || return;
            ($c,$d) = (c.c.ip,d.c.ip);
            $c && $d || die "sort noy$yk ip";
            unless (exists $c->[$i] || exists $d->[$i]) {
                shift @try;
                return $so->(0,@try) if @try;
                die "ip sort ran out:\n  ".ki($a)."\n  ".ki($b);
            }
            $c->[$i] <=> $d->[$i]
            || $so->($i+1,@try);
        };
        sort {$so->(0,@Me)} @$s;
Stashi: | # recursors/ways to track A stuff
    u i
    # c&$j = above.sc.$jo.path
    # above is our c&$jC or root c&$r
    # @Me is C nkgks for path
    #
    # out of throat order, first/deepest coops others
    # j is usually j
    offis: %acgt:r j
        my $ik = $j.'C';
        my $ok = $j.'o';
        my $tw;
        my $oi;$oi = sub {
            my ($C) = @_;
            die "loop C.t" if $tw->{$C}++;
            my $jon;
            if (my $D = C.c.>$ik) {
                # tune in parents first
                $jon = D.c.>$j ||= $oi->($D);
            }
            else {
                # origin
                $jon = C.c.>$r;
            }
            my $i = jon.sc.>$ok ||= {t=>C.t};
            for my $nk (@Me) {
                ($nk,my $gk) = ($1,$nk) if $nk =~ s/^(y|c|sc)//;
                my $v = $C->{$nk};
                $v = $v->{$gk} if $gk;
                $i = $i->{$v} ||= {};
            }
            C.c.>$j = $i;
        };
        $oi->($C);
    

