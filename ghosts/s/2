Sea: | # folds of the day
    u i
    # start holding an instruction
    s:
        if (ref $s eq 'HASH' && ref s.y && s.y ne $s) {
            return $s
        }
        $C = {};
        C.t = '';
        C.y = {};
        C.c.s = $s;
        $C;
    # give you your C
    Ct:
        my $C = {};
        G&Cs,$s;
        $C;
    # parse [This=>3=>{etc}] into $C
    Cs:
        my ($t,@e) = @$s;
        if (ref $t eq 'SCALAR') {
            C.c = G&peel,$$t;
        }
        elsif (ref $t eq 'ARRAY') {
            die "Aray: ".wdump 3, $s;
        }
        elsif (ref $t eq 'HASH') {
            G&xot,$C,$t;
            return;
        }
        elsif (ref $t) {
            die "reft: ".wdump 3, $s;
        }
        else {
            C.t = $t;
        }
        if (!@e) {
            C.c.W = C.t;
        }
        else {
            my ($y,$c,$sc,@e) = @e;
            C.c.s = $c if !ref $c;
            C.c = $c if ref $c eq 'HASH';
            C.c = G&peel,$$c if ref $c eq 'SCALAR';
            $sc = G&peel,$$sc if $sc eq 'SCALAR';
            $sc = {} if $sc eq '';
            $sc = G&peel,$sc if !ref $sc;
            C.sc = $sc if $sc;
            if (ref $y eq 'HASH') {
                if (y.y) {
                    C.c.e = $y;
                    C.c.W ||= C.t;
                }
                else {
                    C.y = $y;
                }
            }
            if (!ref $y) {
                C.c.pi = $1 if $y =~ s/^-(\w+)//;
                C.c.W = C.t if $y =~ s/^W$//;
                $y = 1 if $y eq '';
                C.y.cv = $y;
            }
            C.y.cv /= 10 until C.y.cv < 1;
            die "Extra: ".wdump 3,$s if @e;
        }

    # osc blinds previous empirica
    Chade:
        my $C = {};
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = s.c.s if exists s.c.s;
        C.sc = {%{s.sc}};
        return $C;
    # make an other holding it (s) at same ty
    # s usu. copy already, hs is origin
    Chs: %acgt:s hs
        my $C = {};
        C.y.A = $A;
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = $s;
        C.c.hs = $hs if $hs;
        return $C;
With: | # J's stuff, its Js, osc page, etc.
    u i
    # adapt to J interior as perhaps exterior
    # used to be J.u sub created to know J
    # use s&J or kaboom
    # here A.2 is the doer
    # see With/J
    n: %acgt
        pop @Me;
        G&A,n=>8=>A.2,\@Me;
    u: %acgt
        pop @Me;
        G&A,u=>8=>A.2,\@Me;
    # many slide by slightly and then get nailed down
    m: %acgt
        pop @Me;
        sayre "In out ".wdump 3, \@Me;
    
    # make/return J as named universal
    sJ: %acgt:J t
        J.sc.>$t ||= G&J,$J,$t;
    
    # make J, they inherit non c/sc
    J: %acgt:from t
        ($from,$t) = (A.2,$from) if !defined $t;
        my $J = do {
            my $A = $from;
            G&A,'J';
        };
        J.t = $t;
        J.y.G = $G;
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,u=>8=>$J,\@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,n=>8=>$J,\@Me };
        delete J.u, delete J.n if $t ne 'os';
        $J
    
    # give an A (with .c.s = C) to the J
    ground:
        my $sip = s.c.sip || die "no ip: ".ki$s;
        my $ch = A.2.c.ch || '';
        A.c.n.sc.a->{$ch}->{$sip} = $s;

    # partition ground - increment ch and swap out the s
    # all osc s live on Js&S by channel they're for
    # channel is the time dive/page
    # main street (Js&ch aimed) being '', 1, 2...
    sesh: %acgt:J
        my $o = J.sc.S->{J.sc.ch} = G&sJ,$J,'s';
        delete J.sc.s;
        my $ch = ++J.sc.ch;
        my $s = J.sc.s = J.sc.S->{$ch} ||= G&sJ,$J,'s';
        o.sc.next = $s;
        s.sc.prev = $o;
        # makes osc thing.3 etc hang around
        s.sc.ch = $ch;
    
    # reset ground '', 1, 2...
    rea: %acgt:J
        my $n = J.sc.n || return sayre "no n on J.t";
        my $zi = ++J.c.zi;
        my $ch = '';
        my $lim = 2;
        while (n.sc.a->{$ch}) {
            J.sc.Z->{$zi}->{$ch} = delete n.sc.a->{$ch};
            if ($zi > $lim) {
                delete J.sc.Z->{$zi-$lim}
            }
            $ch++;
        }
        delete J.c.o;
    
Tunnel: | # mind & world
    # machine for finding pi
    # reality is a cave system
    u a
    # dialect of ...
    u 1:
        A.3 = shift @$s; # for
        A.2 = G&sJ,A.3,'u';
    u 2:
        if (A.2.c.o) { # uJ's orderliness mark
            # also its current position relative to itself
            # make many pages of u per A.3
            G&sesh,A.2;
        }
    # hardwire u's u
    u 3:
        my $n = A.c.n = G&A,n=>1=>A.2,@$s;
        n.c.u.c.whole = 'theu';
        G&A,$n,3; # pull on if not cached mindset (various W merged)
    n 1:
        A.2 = shift @$s;
        A.4 || sayre "NO A4: A.t";
        A.c.u = G&sJ,A.2,'u';
        A.c.n = G&sJ,A.2,'n';
    # any ground needs a mind first
    n 2:
        my $u = A.c.u;
        return if "not using mind";
        if (!u.c.o) {
            u.c.base = 'theu'; # the PiMachine
            # resolve our mind
            saybl "resolve our mind";
            G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 2
            G&A,o=>8=>A.2,$u,$_ for 'i','ii';
        }
        #A.i = A.2.sc.i;
        #A.ii = A.2.sc.ii;
    # foldout tape - ground creates moment
    n 3:
        @$s = ([@$s]) if ref $s->[0] ne 'ARRAY';
        A.m = $A;
        for my $l (@$s) {
            my $mo = G&tugA,mo=>1,@$l;
            G&ground,$mo unless mo.c.s.c.nogro;
        }
        delete A.2.c.o; # orderliness
    n 4:
        # become aware of past, surface vibration
    n 5:
        # more thinks
    n 6:
        # etc
    n 7:
        # compress
    n 8:
        # intertime
    mo 1:
        # sprung from n/author, separate put words...
        G&Cs,$s;
        C.y.cv = 0.1 if C.y.cv eq '';
    mo 5:
        # 
    mo 8:
        A.up.la = $A;
Jelly: | # Town making happening
    u c
    n \'of:mo'
    # a wake of dynamics to the same particle
    pi 12:
        c&pin = "pi/$pi";
    W 12:
        ref $s && die;
        c&J = $s;
        A&Jup = A.4;
        # dhcp replanty A.c.ip
    J 2:
        # see self already
        my $J = s&J && return;
        A&Jup ||= A.2;
        $J = G&pint,A&Jup,sc=>Jtv=>C.t,C.y.cv;
        s&J = $J;
        
        my $v = G&pint,A&Jup,sc=>tv=>C.t,C.y.cv;
        $v && saybl "J A.2.t -> v.t"; # C with sJ
        # or force a...
    J 3:
        if (!s&J) {
            s&J = G&J,A&Jup,C.t;
            1 && sayyl "J ! C.t";
        }
        A.2 = s&J;
        A.3 = s&J if A.c.Jpool;
    pi 3:
        my $J = s&J;
        J.c.d = A.2.c.d + 1;
        J.sc.name = "J.c.d $pi*C.t";
        # distance from A.3 as ip
    u s
    n \'of:mo'
    # to rm ^ make the of rememberer D not leave between the o switchup of u others
    J 4:
        # humming - superline timetug - osc exports that door us here
        # outside the fully self/u mind
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        # T wants ha or v wants T (by now, etc)
        # travel comes down ch-switches even if pin skips
    J 5:
        A.c.pin = c&pin || c&J || sc&J ->{t};
    J 6:
        J.sc.n && G&rea,$J;
        J.sc.u && G&rea,J.sc.u;
        #A.1 = $J;
        saybl "St J.t / A.2.t";
        my $y = {cv=>0.9};
        my $M = [];
        my $c = {root=>1};
        my $r = J.sc.root = G&A,n=>1=>$J=>[J.t,$y,$c];
        Rw A.c.pin - $A $C $G $T $J $y $M;
        c.M = $M if @$M;
        G&A,$r,6;
        sayyl "J.t done!!!";
    J 7:
        T.nose && return
            sayyl "C.t knows";
        # temp - of wants to load elvis understanding like route handlers
        A&Jup ->{sc}->{Jtv}->{C.t}->{C.y.cv} = s&J;
        
        sayyl "Oscillate J.t";
        G&A,s=>8=>$J;
        sayyl "Oscillate J.t done!@!";
    J 8:
        # through J's microJ of personality/ghost
    
Compliers: | # othered
    u i
    # join/etc linked lists
    toget:
        G&together,$s,@Me
        
    together: %acgt:k c d
        my $o = c.y.>$k;
        c.y.>$k = $d;
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            d.y.>$ok = $c;
            if ($o) {
                d.y.>$k = $o;
                o.y.>$ok = $d;
            }
        }
    
    apart: %acgt:k c d
        $d ||= c.y.>$k;
        my $o = d.y.>$k;
        delete c.y.>$k;
        if ($o) {
            if ($c eq $o) { # mutual
                delete d.y.>$k;
            }
            else {
                c.y.>$k = $o;
            }
        }
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            delete d.y.>$k;
            if ($o) {
                delete d.y.>$ok;
                o.y.>$ok = $c;
            }
        }
    
Walks: | # othering, many C
    u i
    # k into hash path    also T/ip
    pint:
        for (@Me) {
            return unless ref $s eq 'HASH' && exists $s.>$_;
            $s = $s.>$_;
        }
        $s
    # hash ordering
    hord: %acgt:s head tail
        my ($he,$ta) = ([],[]);
        $head ||= [qw't cv y c sc'];
        $tail ||= [qw's z'];
        my $tw;
        for ([$he=>$head],[$ta=>$tail]) {
            my ($to,$k) = @$_;
            for my $t (@$k) {
                $s.>$t || next;
                $tw.>$t ++;
                push @$to, $t;
            }
        }
        my @mi = sort grep { !$tw.>$_ } keys %$s;
        [ map { [ $_ => $s.>$_ ] } @$he, @mi, @$ta ];
    # make yt (cv/t) from tv (t/cv)
    yttv: %acgt
        my $yt = {};
        for my $on (@Me) {
            G&chew,$on,'t,cv',$_ for sub {
                my ($o,$t,$cv) = @_;
                $yt->{$cv}->{$t} = $o;
            };
        }
        $yt
    # iterator/map for index
    chew:
        G&Chew,$s,@Me
    Chew:
        my $sort;
        my $it = pop @Me if ref $Me[-1] eq 'CODE';
        if (@Me == 1) {
            my $i = shift @Me;
            if (ref $i eq 'SCALAR') {
                $sort = 1;
                $i = $$i;
            }
            @Me = split ',', $i;
        }
        my $in;$in = sub {
            my ($p,$s,$i) = @_;
            if (!@$i || @$i==1 &&
                ref $s ne 'HASH' && $i->[0] =~ /\?$/) {
                return [$s,@$p];
            }
            defined $s || return;
            die "NO ".wdump 3,[$p,$s] if ref $s ne 'HASH';
            shift @$i;
            my @r = keys %$s;
            @r = sort @r if $sort;
            map {
                my $v = $s.>$_;
                $in->([@$p,$_],$v,[@$i]);
            } @r;
            
        };
        my @are = grep{defined} $in->([],$s,[@Me]);
        if ($it) {
            $it->(@$_) for @are 
        }
        else {
            sub { shift @are }
        }
        
    
    # hash then & now, makes histories
    # prop up non val o.c.$cha.$nk.$gk = {}
    # which unify cha ne same into o.c.cha.$cha.$nk.$gk 
    # {} may extend meaning, eg z tys into
    Chang: %acgt:l o
        my $E = l.c.s if $l;
        my $e = o.c.s;
        my @p = (['t'],[y=>'cv'],[c=>{}],[sc=>{}]);
        while (@p) {
            my $p = shift @p;
            my ($nk,$gk) = @$p;
            my $u = $E.>$nk; # Eustobe
            my $v = $e.>$nk; # revelation
            if (ref $gk) {
                keys %$gk == 0 || die "Given a ref: ".ki $gk;
                $gk.>$_++ for keys(%$u), keys (%$v);
                unshift @p, [$nk,$_] for keys %$gk;
                next;
            }
            my $i = {};
            if ($gk) {
                if (!exists $u.>$gk) {
                    o.c.new.>$nk.>$gk = $i;
                }
                elsif (!exists $v.>$gk) {
                    o.c.gone.>$nk.>$gk = $i;
                }
                elsif ($u.>$gk ne $v.>$gk) {
                    o.c.diff.>$nk.>$gk = $i;
                }
                else {
                    o.c.same.>$nk.>$gk = $i;
                }
                
            }
            else {
                if (!exists $E.>$nk) {
                    o.c.new.>$nk = $i;
                }
                elsif (!exists $e.>$nk) {
                    o.c.gone.>$nk = $i;
                }
                elsif ($u ne $v) {
                    o.c.diff.>$nk = $i;
                }
                else {
                    o.c.same.>$nk = $i;
                }
            }
        }
        for (grep { o.c.>$_ } qw'new gone diff') {
            o.c.cha->{$_} = o.c.>$_;
        }
    # sort by many y.As
    sortysip:
        my $so;$so = sub {
            my ($i,@try) = @_;
            my ($yk) = @try;
            my ($c,$d) = (a.y->{$yk},b.y->{$yk});
            $c && $d || return;
            ($c,$d) = (c.c.ip,d.c.ip);
            $c && $d || die "sort noy$yk ip";
            unless (exists $c->[$i] || exists $d->[$i]) {
                shift @try;
                return $so->(0,@try) if @try;
                die "ip sort ran out:\n  ".ki($a)."\n  ".ki($b);
            }
            $c->[$i] <=> $d->[$i]
            || $so->($i+1,@try);
        };
        sort {$so->(0,@Me)} @$s;
Stashi: | # recursors/ways to track A stuff
    u i
    # c&$j = above.sc.$jo.path
    # above is our c&$jC or root c&$r
    # @Me is C nkgks for path
    #
    # out of throat order, first/deepest coops others
    # j is usually j
    offis: %acgt:r j
        my $ik = $j.'C';
        my $ok = $j.'o';
        my $tw;
        my $oi;$oi = sub {
            my ($C) = @_;
            die "loop C.t" if $tw->{$C}++;
            my $jon;
            if (my $D = C.c.>$ik) {
                # tune in parents first
                $jon = D.c.>$j ||= $oi->($D);
            }
            else {
                # origin
                $jon = C.c.>$r;
            }
            my $i = jon.sc.>$ok ||= {};
            for my $nk (@Me) {
                ($nk,my $gk) = ($1,$nk) if $nk =~ s/^(y|c|sc)//;
                my $v = $C->{$nk};
                $v = $v->{$gk} if $gk;
                $i = $i->{$v} ||= {};
            }
            C.c.>$j = $i;
        };
        $oi->($C);
    

