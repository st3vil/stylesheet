Tunnel: | # mind & world
    # machine for finding pi
    u a
    # dialect of ...
    u 1:
        A.3 = shift @$s; # for
        A.2 = G&sJ,A.3,'u';
    u 2:
        if (A.2.c.o) {
            G&sesh,A.2;
            # o is the J's orderliness mark
            # also its current position relative to itself
            # make many pages of u per A.3
        }
    u 3:
        my $n = A.c.n = G&A,n=>1=>A.2,@$s;
        n.c.u.c.whole = 'theu';
        G&A,$n,3;
    n 1:
        A.2 = shift @$s;
        A.c.u = G&sJ,A.2,'u';
        A.c.n = G&sJ,A.2,'n';
    n 2:
        my $u = A.c.u;
        if (!u.c.o) {
            u.c.base = 'theu'; # the PiMachine
            # resolve our mind
            saybl "resolve our mind";
            G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 2
            G&A,o=>8=>A.2,$u,$_ for 'i','ii';
        }
        #A.i = A.2.sc.i;
        #A.ii = A.2.sc.ii;
    n 3:
        # foldout tape
        @$s = ([@$s]) if ref $s->[0] ne 'ARRAY';
        A.m = $A;
        for my $l (@$s) {
            my $mo = G&tugA,mo=>1,@$l;
            A.c.n.sc.a->{A.2.c.ch||''}->{mo.c.sip} = $mo;
        }
        delete A.2.c.o; # orderliness
    n 4:
        sayre "YEP ".ki $C;
        # become aware of past, surface vibration
    n 5:
        # more thinks
    n 6:
        # etc
        G&tug,0.7;
    n 7:
        # compress
    n 8:
        # intertime
    mo 1:
        # sprung from n/author, separate put words...
        G&Cs,$s;
    mo 5:
        say 'mive'
Jelly: | # Town making
    u c
    n \'of:mo'
    pi 12:
        c&pin = "pi/$pi";
    W 12:
        ref $s && die;
        c&J = $s;
        # dhcp replanty A.c.ip
    J 2:
        # see self already
        s&J ||= A.2.sc.tv && A.2.sc.tv->{C.t} && A.2.sc.tv->{C.t}->{C.y.cv};
        # or force a...
    J 3:
        s&J ||= G&J,C.t;
    pi 3:
        my $J = s&J;
        J.c.d = A.2.c.d + 1;
        J.sc.name = "J.c.d $pi*C.t";
        # distance from A.3 as ip
    u s
    n \'of:mo'
    # to rm ^ make the of rememberer D not leave between the o switchup of u others
    J 4:
        # humming - superline timetug - osc exports that door us here
        # outside the fully self/u mind
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        # T wants ha or v wants T (by now, etc)
        # travel comes down ch-switches even if pin skips
    J 5:
        A.c.pin = c&pin || c&J || sc&J ->{t};
    J 6:
        sayre "Re J.t";
        J.sc.n && G&rea,$J;
        J.sc.u && G&rea,J.sc.u;
        saybl "St J.t";
        my $y = {cv=>0.9};
        my $M = [];
        my $c = {};
        my $r = J.sc.root = G&A,n=>1=>$J=>[J.t,$y,$c];
        saybl "Ive J.t";
        Rw A.c.pin - $A $C $G $T $J $y $M;
        c.M = $M if @$M;
        G&A,$r,6;
    J 7:
        G&A,s=>8=>$J;
    J 8:
        # through J's microJ of personality
    
With: | # J's stuff, its Js, osc page, etc.
    u i
    
    sJ: %acgt:J t f
        $f ||= $t;
        J.sc.>$t ||= G&J,$f;
    J:
        my $J = G&A,'J';
        J.t = $s;
        J.y.G = $G;
        # will be bab to G&
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,u=>6=>$J,\@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,n=>6=>$J,\@Me };
        $J
    
    # partition ground
    sesh: %acgt:J
        my $o = J.sc.S->{J.sc.ch} = G&sJ,$J,'s';
        delete J.sc.s;
        my $ch = ++J.sc.ch;
        my $s = J.sc.s = J.sc.S->{$ch} ||= G&sJ,$J,'s';
        o.sc.next = $s;
        s.sc.prev = $o;
        # makes osc thing.3 etc hang around
        s.sc.ch = $ch;
    
    # reset ground
    rea: %acgt:J
        my $n = J.sc.n || die 'no n';
        my $zi = ++J.c.zi;
        my $ch = '';
        my $lim = 2;
        while (n.sc.a->{$ch}) {
            J.sc.Z->{$zi}->{$ch} = delete n.sc.a->{$ch};
            if ($zi > $lim) {
                delete J.sc.Z->{$zi-$lim}
            }
            $ch++;
        }
        delete J.c.o;
    
Compliers: | # othered
    u i
    # join/etc linked lists
    toget:
        G&together,$s,@Me
        
    together: %acgt:k c d
        my $o = c.y.>$k;
        c.y.>$k = $d;
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            d.y.>$ok = $c;
            if ($o) {
                d.y.>$k = $o;
                o.y.>$ok = $d;
            }
        }
    
    apart: %acgt:k c d
        $d ||= c.y.>$k;
        my $o = d.y.>$k;
        delete c.y.>$k;
        if ($o) {
            if ($c eq $o) { # mutual
                delete d.y.>$k;
            }
            else {
                c.y.>$k = $o;
            }
        }
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            delete d.y.>$k;
            if ($o) {
                delete d.y.>$ok;
                o.y.>$ok = $c;
            }
        }
    
    # osc blinds previous empirica
    Chade:
        my $C = {};
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = s.c.s if exists s.c.s;
        C.sc = {%{s.sc}};
        return $C;
    # make an other holding it (s) at same ty
    # s usu. copy already, hs is origin
    Chs: %acgt:s hs
        my $C = {};
        C.y.A = $A;
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = $s;
        C.c.hs = $hs if $hs;
        return $C;
Walks: | # othering, many C
    u i
    # iterator/map for index
    Chew:
        my $sort;
        my $it = pop @Me if ref $Me[-1] eq 'CODE';
        if (@Me == 1) {
            my $i = shift @Me;
            if (ref $i eq 'SCALAR') {
                $sort = 1;
                $i = $$i;
            }
            @Me = split ',', $i;
        }
        my $in;$in = sub {
            my ($p,$s,$i) = @_;
            if (!@$i || @$i==1 &&
                ref $s ne 'HASH' && $i->[0] =~ /\?$/) {
                return [$s,@$p];
            }
            defined $s || return;
            die "NO ".wdump 3,[$p,$s] if ref $s ne 'HASH';
            shift @$i;
            my @r = keys %$s;
            @r = sort @r if $sort;
            map {
                my $v = $s.>$_;
                $in->([@$p,$_],$v,[@$i]);
            } @r;
            
        };
        my @are = grep{defined} $in->([],$s,[@Me]);
        if ($it) {
            $it->(@$_) for @are 
        }
        else {
            sub { shift @are }
        }
        
    
    # hash then & now, makes histories
    # prop up non val o.c.$cha.$nk.$gk = {}
    # which unify cha ne same into o.c.cha.$cha.$nk.$gk 
    # {} may extend meaning, eg z tys into
    Chang: %acgt:l o
        my $E = l.c.s if $l;
        my $e = o.c.s;
        my @p = (['t'],[y=>'cv'],[c=>{}],[sc=>{}]);
        while (@p) {
            my $p = shift @p;
            my ($nk,$gk) = @$p;
            my $u = $E.>$nk; # Eustobe
            my $v = $e.>$nk; # revelation
            if (ref $gk) {
                keys %$gk == 0 || die "Given a ref: ".ki $gk;
                $gk.>$_++ for keys(%$u), keys (%$v);
                unshift @p, [$nk,$_] for keys %$gk;
                next;
            }
            my $i = {};
            if ($gk) {
                if (!exists $u.>$gk) {
                    o.c.new.>$nk.>$gk = $i;
                }
                elsif (!exists $v.>$gk) {
                    o.c.gone.>$nk.>$gk = $i;
                }
                elsif ($u.>$gk ne $v.>$gk) {
                    o.c.diff.>$nk.>$gk = $i;
                }
                else {
                    o.c.same.>$nk.>$gk = $i;
                }
                
            }
            else {
                if (!exists $E.>$nk) {
                    o.c.new.>$nk = $i;
                }
                elsif (!exists $e.>$nk) {
                    o.c.gone.>$nk = $i;
                }
                elsif ($u ne $v) {
                    o.c.diff.>$nk = $i;
                }
                else {
                    o.c.same.>$nk = $i;
                }
            }
        }
        for (grep { o.c.>$_ } qw'new gone diff') {
            o.c.cha->{$_} = o.c.>$_;
        }
    # sort by many y.As
    sortysip:
        my $so;$so = sub {
            my ($i,@try) = @_;
            my ($yk) = @try;
            my ($c,$d) = (a.y->{$yk},b.y->{$yk});
            $c && $d || die "sort no y$yk".wdump 4,[$a,$b];
            ($c,$d) = (c.c.ip,d.c.ip);
            $c && $d || die "sort noy$yk ip";
            unless (exists $c->[$i] || exists $d->[$i]) {
                shift @try;
                return $so->(0,@try) if @try;
                die "ip sort ran out:\n  ".ki($a)."\n  ".ki($b);
            }
            $c->[$i] <=> $d->[$i]
            || $so->($i+1,@try);
        };
        sort {$so->(0,@Me)} @$s;
Stashi: | # recursors/ways to track A stuff
    u i
    # c&$j = above.sc.$jo.path
    # above is our c&$jC or root c&$r
    # @Me is C nkgks for path
    #
    # out of throat order, first/deepest coops others
    # j is usually j
    offis: %acgt:r j
        my $ik = $j.'C';
        my $ok = $j.'o';
        my $tw;
        my $oi;$oi = sub {
            my ($C) = @_;
            die "loop C.t" if $tw->{$C}++;
            my $jon;
            if (my $D = C.c.>$ik) {
                # tune in parents first
                $jon = D.c.>$j ||= $oi->($D);
            }
            else {
                # origin
                $jon = C.c.>$r;
            }
            my $i = jon.sc.>$ok ||= {};
            for my $nk (@Me) {
                ($nk,my $gk) = ($1,$nk) if $nk =~ s/^(y|c|sc)//;
                my $v = $C->{$nk};
                $v = $v->{$gk} if $gk;
                $i = $i->{$v} ||= {};
            }
            C.c.>$j = $i;
        };
        $oi->($C);
    

