Tunnel: | # mind & world
    # machine for finding pi
    u a
    # dialect of ...
    u 1:
        A.3 = shift @$s; # for
        A.2 = G&sJ,A.3,'u';
    u 2:
        if (A.2.c.o) {
            G&sesh,A.2;
            # o is the J's orderliness mark
            # also its current position relative to itself
            # make many pages of u per A.3
        }
    u 3:
        my $n = A.c.n = G&A,n=>1=>A.2,@$s;
        n.c.u.c.whole = 'theu';
        G&A,$n,3;
    n 1:
        A.2 = shift @$s;
        A.c.u = G&sJ,A.2,'u';
        A.c.n = G&sJ,A.2,'n';
    n 2:
        my $u = A.c.u;
        if (!u.c.o) {
            u.c.base = 'theu'; # the PiMachine
            # resolve our mind
            saybl "resolve our mind";
            G&A,s=>8=>$u;
            # merge its i/ii thing ideas into our 2
            G&A,o=>8=>A.2,$u,$_ for 'i','ii';
        }
        A.i = A.2.sc.i;
        A.ii = A.2.sc.ii;
    n 3:
        # foldout tape
        @$s = ([@$s]) if ref $s->[0] ne 'ARRAY';
        A.m = $A;
        for my $l (@$s) {
            my $mo = G&tugA,mo=>1,@$l;
            A.c.n.sc.a->{A.2.c.ch||''}->{mo.c.sip} = $mo;
        }
        delete A.2.c.o; # orderliness
    n 4:
        # become aware of past, surface vibration
    n 5:
        # more thinks
    n 6:
        # etc
        G&tug,0.7;
    n 7:
        # compress
    n 8:
        # intertime
    mo 1:
        # sprung from n/author, separate put words...
        G&Cs,$s;
    mo 5:
        say 'mive'
Jelly: | # Town making
    u c
    n \'of:mo'
    pi 12:
        c&pin = "pi/$pi";
    W 12:
        ref $s && die;
        c&J = $s;
        # dhcp replanty A.c.ip
    J 2:
        # see self already
        s&J ||= A.2.sc.tv && A.2.sc.tv->{C.t} && A.2.sc.tv->{C.t}->{C.y.cv};
        # or force a...
    J 3:
        s&J ||= G&J,C.t;
    pi 3:
        my $J = s&J;
        J.c.d = A.2.c.d + 1;
        J.sc.name = "J.c.d $pi*C.t";
        # distance from A.3 as ip
    u s
    n \'of:mo'
    # to rm ^ make the of rememberer D not leave between the o switchup of u others
    J 4:
        # humming - superline timetug - osc exports that door us here
        # outside the fully self/u mind
        my $v = J.sc.Tv; # inner surf attracto
        my $ha = J.sc.tv; # things
        # T wants ha or v wants T (by now, etc)
        # travel comes down ch-switches even if pin skips
    J 5:
        A.c.pin = c&pin || c&J || sc&J ->{t};
    J 6:
        sayre "Re J.t";
        J.sc.n && G&rea,$J;
        J.sc.u && G&rea,J.sc.u;
        saybl "St J.t";
        my $y = {cv=>0.9};
        my $M = [];
        my $c = {};
        my $r = J.sc.root = G&A,n=>1=>$J=>[J.t,$y,$c];
        saybl "Ive J.t";
        Rw A.c.pin - $A $C $G $T $J $y $M;
        c.M = $M if @$M;
        G&A,$r,6;
    J 7:
        G&A,s=>8=>$J;
    J 8:
        # through J's microJ of personality
    
Stashi: | # recursors/ways to track A stuff
    u i
    # c&$j = above.sc.$jo.path
    # above is our c&$jC or root c&$r
    # @Me is C nkgks for path
    #
    # out of throat order, first/deepest coops others
    # j is usually j
    offis: %acgt:r j
        my $ik = $j.'C';
        my $ok = $j.'o';
        my $tw;
        my $oi;$oi = sub {
            my ($C) = @_;
            die "loop C.t" if $tw->{$C}++;
            my $jon;
            if (my $D = C.c.>$ik) {
                # tune in parents first
                $jon = D.c.>$j ||= $oi->($D);
            }
            else {
                # origin
                $jon = C.c.>$r;
            }
            my $i = jon.sc.>$ok ||= {};
            for my $nk (@Me) {
                ($nk,my $gk) = ($1,$nk) if $nk =~ s/^(y|c|sc)//;
                my $v = $C->{$nk};
                $v = $v->{$gk} if $gk;
                $i = $i->{$v} ||= {};
            }
            C.c.>$j = $i;
        };
        $oi->($C);
    
    sJ: %acgt:J t f
        $f ||= $t;
        J.sc.>$t ||= G&J,$f;
    J:
        my $J = G&A,'J';
        J.t = $s;
        J.y.G = $G;
        # will be bab to G&
        J.u = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,u=>6=>$J,\@Me };
        J.n = sub { ($A,$C,$G,$T,@Me) = @_; pop @Me; G&A,n=>6=>$J,\@Me };
        $J
    
    # partition ground
    sesh: %acgt:J
        my $o = J.sc.S->{J.sc.ch} = G&sJ,$J,'s';
        delete J.sc.s;
        my $ch = ++J.sc.ch;
        my $s = J.sc.s = J.sc.S->{$ch} ||= G&sJ,$J,'s';
        o.sc.next = $s;
        s.sc.prev = $o;
        # makes osc thing.3 etc hang around
        s.sc.ch = $ch;
    
    # reset ground
    rea: %acgt:J
        my $n = J.sc.n || die 'no n';
        my $zi = ++J.c.zi;
        my $ch = '';
        my $lim = 2;
        while (n.sc.a->{$ch}) {
            J.sc.Z->{$zi}->{$ch} = delete n.sc.a->{$ch};
            if ($zi > $lim) {
                delete J.sc.Z->{$zi-$lim}
            }
            $ch++;
        }
        delete J.c.o;
    

