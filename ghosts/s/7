Storage: | # maps down to strings
    n Hosthing
    n Impart
Tropics: | # store hashed C
    # meshed islands that will want to careen away over time
    # keep stitched via time dilation under ongoing you
    
    # so the 3ing is o of the osc zopjects
    #   unifying digests from extremities
    #   yaml maker that remembers all refs, merges up o
    #     so things many times repoint as T
    #       applies to any level of Wreading
    #   the z refers to more cid
    # finding the same stored C if possible
    # travel is beside each, another A
    
    # there's a G named G with all top level W (eg Zop) in it
    # 
    
    # Stro wants to eat schemed things
    # to map into pg tables
    
    # readying code into perl modules is vaguely related...
    # wants do a width first look for loops, which come out as T
    # so Too is z
    # so T can link to more T, which may have many 
    # C table is cid, t, cv, c, s, sc
    # T table is cid, tid, t, cv, c, s, sc
    # a C with s&z turns into a C without z and:
    #  T cid=^ tid=? t=z 
    #  
    # 
    
    
    
    
Hosthing: | # store/thaw s's outside
    u a
    # try wormhole/avoidance, wants Tractor/Ghoster to override regularly
    # force T.H
    #    1 nothing
    #    2 stores only
    #    3 both, give parts to osc to live (ofs of: evals code(d))
    #       for needing osc to wake it
    #    4 both, with in-bunch wires, evals code(d)
    #        osc meta resumes 76-
    #    5 ^ stores only
    #    6 impart and resume right away, continuing Jco (TODO)
    #    8+ thaws only
    # 
    thawJ 34: %of:mo,t:y:A:mo:up:mo:c:T:H || y:A:mo:c:T:H
        c&e && return;
        
        keys %{C.c} == 2 && c&W eq c&J && c&W eq C.t || return;
        
        # 
        a&thawable = 1 unless $s < 3 || $s == 5;
        a&storable = 1 unless $s < 2 || $s > 7;
        
        a&storable && A.up.c.store++;
        a&stowexp = 1 if $s >= 4 && $s < 6;
         
        a&thawable || return;
        my $V = A.1.t =~ /^[A-Z]/ && A.2.t ne 'u';
        my $d = G&thaws,$V || return;
        
        #$V && saygr " for ".G&sn;
        
        # is upCc&parts from s
        # which may skip s to 76-
        # or at least not do the pin
        c&parts = $d;
        T.Z.7 = $A;
        delete a&storable;
        
    stawJ 78: %of:n,t:y:A:c:store
        for my $m (@{A&mos||[]}) {
            ms&storable || next;
            my $c = mc&s;
            my $J = cs&J;
            my $s = Js&s;
            $A = $m;
            $C = $s;
            # hmm ^
            a&stowexp ? G&stowexp
            :
            G&stores;
            #G.ouJ = $s;
        }
        
    u i
    thaws:
        local C.c.V = 1;
        G&elph,Stro=>[get=>$C];
        delete s&top
    
    # for C = s, make flat list of C that should c&parts to what it was
    stores:
        my $t = C.y eq $C ? s&top || die "Store A no top: ".ki $C : $C;
        my @all = G&ind,$t; # hups
        my ($n) = @all;
        for (@all) {
            delete _c&ind;
            delete _c&inds;
            _s&coded = 1 if delete _c&code;
            _.y = {cv=>_.y.cv};
            my $in = delete(_c&inside) || [];
            my $z = delete _s&z;
            delete _s&J;
            G&oleak,$_,5 && die "Leaks: @$in: ".ki $_;
            _s&z = $z;
        }
        # put in meta, know not imparted unless m.unreal
        ns&xo = s&xo if s&xo;
        $s ? G&h,$s,$n :
            G&elph,Stro=>[put=>$n];
        $n
Impart: | # gittty Hosting/not interchange
    u i
    
    #c s stores itself, imparts/unreal
    stowexp:
        local A.V = 2;

        if (my $pid = fork()) {
            waitpid($pid,0);
            die "child failed with $?" if $?;
            return;
        }
        my ($ok,$dr);
        ok.y.>$_ = 1 for qw'up in prev next';
        # 2 means ref doesn't have to be one of the many
        ok.y.>$_ = 2 for qw'tv tw';
        dr.y.>$_ = 1 for qw'D x r s';
        dr.sc.>$_ = 1 for qw'J';
        dr.c.code = 3; # say s&coded=1
        ok.sc.ip = 2;

        my $ha; # have seen
        my $pa; # paths to seen
        my $se; # see from
        my @or;
        my $ub = &Cd{
            $ha.>$C = $C;
            my $p = join "/", @{d.path};
            $pa.>$p = $C;
            push @or, 
            G&chew,$C,'nk,gk',$_ for &v,nk,gk{
                ref $v || return;
                $se.>$nk.>$gk.>$v.>$C = $C;
            };
            return; # means no c.ind/inside labegy
        };
        my @all = G&ind,s&top,$ub,{nohup=>1};

        my $pass = 1;
        G&chew,$se,'nk,gk,v',$_ for &vv,nk,gk,v{
            return if $nk eq 'sc' && $gk =~ /ex$/;
            my $M = [values %$vv];
            if (my $k = $ok.>$nk.>$gk ) {
                my $c = $ha.>$v;
                $v = "C c.t c.y.cv" if $c;
                unless ($c || $k == 2) {
                    sayre "Unhad $nk $gk $v from ".ki $M;
                    $pass--;
                }
            }
            elsif (my $k = $dr.>$nk.>$gk ) {
                #saybl "Droppy $nk $gk $v from ".ki $M;
                delete $_.>$nk.>$gk for @$M;
                if ($k == 3) {
                    my $gkd = $gk.'d';
                    _.sc.>$gkd = 1 for @$M;
                }
            }
            else {
                my $c = $ha.>$v;
                my $had = " (had: c.t c.y.cv)" if $c;
                sayre "Unknown $nk $gk $v$had from ".ki $M;
                delete $_.>$nk.>$gk for @$M;
                $pass--;
            }
        };

        G&chew,s&iiyt,'cv,t',$_ for &l,cv,t{
            $ha.>$l && return;
            $pass--;
            sayre "Missing iiyt $cv $t: ".ki$l;
            saygr "Was it ".ki $_ for 
                grep { _.t eq l.t && _.y.cv eq _.y.cv } values %$ha;
        };
        die "Shave missed spots" if $pass != 1;

        my $t = s&top;
        ts&meta && die "Already had topscmeta: ".ki($t)."\n  ".ki(ts&meta);
        my $m = ts&meta = {}; # takes over as impart, sets tv,top,etc in self
        m.sc.iiyt = s&iiyt;
        m.unreal.sc.iiyt++; # iiyt maintained xarefully, drop before J for real
        m.sc.top = $t;
        m.c.>$_ = C.c.>$_ for qw'imp wil mat';
        m.A.xo = s&xo if s&xo;
        m.paths = $pa;

        # do in parallel, child kills parent
        my $dl = 160;
        if (G&oleak,$t,$dl ) {
            write_file('eak', wdump $dl, $t);
            die "t.t t.y.cv still leaks at depth=$dl, wrote file 'eak'";
        }

        G&elph,Stro=>[put=>$t];
        exit;
    
    #c s thaws out self
    imparts:
        my $d = c&parts || die "imparts no parts";
        local A.V = 2;
        my $m = delete ds&meta;
        
        if (m.mtime) {
            return c&sameparts = 1 if s&partsmtime eq m.mtime;
            s&partsmtime = m.mtime;
        }

        m.A.xo = delete ds&xo if ds&xo;
        for ('c','sc') {
            my ($s,$c) = ($C.>$_ , $m.>$_ || next );
            G&hoh,$s,$c;
        }
        # xo must be processed up onto ...
        while (my ($k,$v) = each %{m.A}) {
            A.c.>$k = $v;
        }

        return# saygr "Parts lightly A.1.t"
        unless m.unreal;
        # 
        my $i;
        my $ub = &Cd{
            $i++;
            return unless delete s&coded;
            G&Code,"imparts";
            return; # means no c.ind/inside labegy
        };
        my @all = G&ind,$d,$ub,{nohup=>1};

        # make a parts top that o2parts can make look like a ground
        my $z = [];
        my $S = d.y.in;
        while ($S) {
            push @$z, $S;
            $S = S.y.next;
        }
        ds&z = $z;

        # makes s Z to 76- un
        c&imparted = $m unless c&imparting;
        #saybl "Imparts 76- A.1.t";
    #c s continues after thawing self
    # since only s's outsides are stored
    # involves intermediate partsing to make lv etc state
    # so the next lv applies on the remote
    imparted:
        local A.V = 2;
        my $J = A.1;
        sayre "Enhere J.t: ".G&sn;
        
        my $m = delete c&imparted;

        my $t = m.sc.top || die "No metatop";
        ts&meta = $m;
        # our c&imparted already deleted
        c&parts = $t;

        # ^ wants to be a T thing wired into v instead of bounced off the J
        local c&imparting = 1; # block loop
        local 1c&imping = 1; # top that el=2
        Jc&gripo = 1; # hold version
        G&A,s=>8=>$J;

        while (my ($nk,$v) = each %{m.unreal||die"m not unreal"}) {
            delete $C.>$nk.>$_ for keys %$v
        }

        sayyl "Was parted: ", @{C.c.rsl};
        sayyl "Now has lv: ".ki s&lv;

        delete c&parts;
        # and now returns into o2 with the ground
Stro: | # storage aJent for Hosthing, just needs a G
    Js&loose = 1;
    T.nose = 2; # no osc but keep J (4s&Jtv)
    T.pos = 0; # always thinks its right
    my $f = 'w/St';
    my $c = e&s; # sets C.c.e.c.s.sc.top = got
    my @p = map { s/\W//g;$_ } A.4.t, c.t;
    my $p = join '/', $f, @p;
    my $f = "$p/head";
    if (e&t eq 'put') {
        `mkdir -p $p`;
        DumpFile($f,$c);
        C.c.V && sayyl "Store $f";
    }
    elsif (e&t eq 'get') {
        -f $f && -s $f || return;
        my $d = LoadFile($f);
        $d || return;
        ds&meta.mtime = (stat $f)[9];
        cs&top = $d;
        C.c.V && sayyl "Get $f";
    }
    else { G&vent,"NHogo" }
ElvisTribute: | # J streams from J via lv, o 5- with each wave, updates objects
    my $t = Rw Towering
        || return;
    c&Se == 1 || return;
    
    T.H = 3;
    t.e = 
    n Zpace
    t.toc.slimvague = 1;
    t.cs->('sc top', "Seeu");
    t.cs->('sc ii mo', "mo");
    
    t.cs->('sc lv,olv', "lv not there yet");
    my $s = t.ntos->(t.e);
    is s.c.o, "Steved 1 1", "origin's id";
    
    T.H = 1;
    
    t.e = 
    n Zpace=>W=>{banana=>1}
    t.cs->('sc lv,olv', "lv with and without banana");
    t.cs->('sc top', "top with banana");
    is s.c.o, "Steved 1 2", "next id";
    
    t.e = 
    n Zpace=>W=>{banana=>1,mango=>2}
    t.cs->('sc lv,olv', "lv with and without mango");
    t.cs->('sc top', "top with mango");
    is s.c.o, "Steved 1 3", "next id";
    
pg: | # postgresql connection
    u i
    db:
        use Mojo::Pg;
        my $pg = 4s&pg ||= Mojo::Pg->new('postgresql://s@/s');
        delete 1s&db unless 1s&db.stylepid eq $$;
        1s&db ||= do {
            my $db = $pg->db;
            db.stylepid = $$;
            G&has,pg=>1;
            $db
        };
    
    qp:
        G&db ->query($s,
        map{!ref && defined $_ ? decode_utf8($_) : $_ }
        @Me);
    
    tyable:
        $s ||= 'names';
        my @col = map{split','} @Me;
        push @col, 't','y real','c json','sc json';
        my $colum = join', ',map{s/:/ /g;/ /?$_:"$_ text"} @col;
        my $q = "create table if not exists $s ($colum)";
        say "Create: $q from".wdump 2, [$s,@Me] ;
        G&qp,$q
    
    qh:
        my @o;
        G&qp,$s,@Me ->hashes->map(sub{push @o,$_});
        for my $o (@o) {
            for my $k (keys %$o) {
                my $v = $o.>$k;
                $o.>$k = encode_utf8($v) if defined $v && !ref $v;
            }    
        }
        sayre "".(@o-1)." rows dropped from: @Me\n$s" if !wantarray && @o > 1;
        wantarray ? @o : $o[0]
    
    Jr:
        G&qh,<<'',$s
            select * from names where t = ?
    
    # select and then insert somewhat, osc updates it
    # with o {k=>v}, scalar ref v is sql hack #
    decj:
        $s = G&hup,$s unless @Me;
        my $auto = @Me == 1 && $Me[0] eq '';
        for (c=>sc=>@Me) {
            $_ || next;
            $s.>$_ ||= {} if $auto;
            $s.>$_ && !ref $s.>$_ || next;
            $s.>$_ = djson $s.>$_;
        }
        $s
    encj:
        $s = G&hup,$s;
        $s.>$_ = sjson $s.>$_ for 'c', 'sc';
        $s
    
    pet: %acgt:s o
        my @ks = sort keys %$o;
        my @sel;
        my $sel = "select * from $s where ".join" and ",map{
            my $z = $o.>$_;
            ref $z eq 'SCALAR' ? "$_ $$z" : do {
                push @sel, $z;
                "$_ = ?"
            };
        }@ks;
        my $n = G&qh,$sel,@sel;
        $n ||= do {
            my @ac = grep { ref $o.>$_ ne 'SCALAR' } @ks;
            my @in = map { $o.>$_ } @ac;
            my $in = "insert into $s (".join(',',@ac)
                .") values (".join(",",('?') x @ac)
                .") returning *";
            G&qh,$in,@in;
        };
        $n
    
    # add listenance via GW
    liz: %acgt:s J
        $s ||= C.c.W;
        $J ||= C.c.W;
        G.W.noti.>$s = $J;
        G.W.lizdb->listen($s) if G.W.lizdb;
        1
    
    # send message (goner)
    zen:
        my $m = @Me > 1 || ref $Me[0] ? sjson(\@Me) : $Me[0];
        if (length $m > 5000) {
            #G&tyable,mez=><<'' if !G.tabup++;
            #    f,s,ts:timestamptz:default:now(),mid:serial:primary:key
            my $h = G&qh,<<'',G.t,$s,$m;
                insert into mez (f,t,s) values (?,?,?) returning mid
            sayyl "Length of zen/notify $s: ".length $m;
            $m = "CCC h.mid";
        }
        else {
            $m = decode_utf8($m);
        }
        G&db ->notify($s,$m);

    dmez:
        my $h = G&qh,<<'',$s;
            select f,t,s,mid from mez where mid = ?
        length(h.s) || die "mized mez: $1";
        Rw timer $d=2 $cb:_ for sub { G&qp,<<'',h.mid };
            delete from mez where mid = ?
        $s = h.s;
        sayre "CCCC: h.t -> ".ki$s;
        $s

