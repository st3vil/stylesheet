PiMachine: | # all that is
    n Sequencing
    n ForJ
    n Jingle
    n Stuff
    n ThatWillBe
Sequencing: |
    n To
    n Day
    n Tube
    n Ce
ForJ: |
    n Sea
    n With
    n Tunnel
    n Elvising
    n Jelly
Jingle: |
    n Compliers
    n Walks
    n Stashi
Stuff: |
    n Triangle
    n Hoop
    n Circle
ThatWillBe: |
    n Tan
    n Tal
    n Komp
MakePi: | # make code,
    my $ii = {};
    
    my $dig = sub {
        my $tW = shift || return;
        $tW = {%{$tW}};
        $tW->{$_} = readlink "w/digway/$_" for keys %$tW;
        $tW;
    };
    
    my $main = 'PiMachine';
    my $see = G.way.>$main;
    my (@bit) = $see =~ /^n (\w+)$/sgm;
    
    my $s = {};
    for my $bit (@bit) {
         my $fd = "w/pimash/$main/$bit";
        my $ol = LoadFile($fd.'.g') if -f $fd.'.g';
        
        my $v = {};
        if (!$ol || ki($ol) ne ki($dig->($ol))) {
            sayre "$main $bit unstuck: \n".ki($ol)."\n ne\n".ki($dig->($ol)) if $ol;
            n $bit
            my $jt = G.oin.inJ;
            my $Day = $jt->{$bit};
            my $tW = {};
            my $su;$su = sub {
                my $J = shift;
                my $v = J.El.Pre.tv || die "J.name no tv";
                map { _.sc.J ? ($_,$su->(_.sc.J)) : $_ }
                grep { _.y.cv < 0.9 || do{$tW->{_.t} = $_; 0} } values %$v;
            };
            my $N = [$su->($Day)];
            for my $C (@$N) {
                Rw ym/conoi $noAI=1 $C $v;
            }
            DumpFile($fd.'.g',$dig->($tW));
            DumpFile($fd.'.v',$v);
        }
        else {
            $v = LoadFile($fd.'.v');
        }
        while (my ($k,$tv) = each %$v) {
            while (my ($t,$cvs) = each %$tv) {
                while (my ($cv,$C) = each %$cvs) {
                    $s.>$k.>$t.>$cv = $C;
                }
            }
        }
    }
    
    my $v = $s;
    for my $of (keys %$v) {
        my $o = $ii->{$of} = {t=>$of,y=>{cv=>0.001},c=>{W=>'of'}};
        my $c = $v->{$of};
        my $la = $o;
        for my $cv (sort keys %$c) {
            my $ts = $c->{$cv};
            for my $t (sort keys %$ts) {
                my $z = $ts->{$t};
                
                Rw CoBabbler $C:z;
                my $y = eval z.c.s;
                die "Throcompile $of z.y.cv: z.t:"
                    .ind('  ',$@)."\n\n z.c.s\n" if $@;
                die "Not code: z.t z.y.cv: $@\n".ki $z if ref $y ne 'CODE' && !z.sc.subpeel;
                z.c.code = $y;
                
                if ($la eq $o) {
                    la.y.in = $z;
                }
                else {
                    la.y.next = $z;
                    z.y.prev = $la;
                }
                o.y.tw.>$t = $z;
                o.y.tv.>$t.>$cv = $z;
                $la = $z;
            }
        }
    }
    
    my $i = {};
    my $n = ii.i;
    while ($n) {
        if (n.c.code) {
            $i->{n.t} = n.c.code;
            ii.i.y.tw->{n.t} = $n;
        }
        $n = n.y.in || n.y.next;
    }
    
    ($i,$ii)
CoBabbler: | # bake code
    my $sw = {};
    $sw.>$_ = 'say' for qw'saygr saybl sayyl sayre say';
    %$sw = () if C.sc.nobasay;
    for (keys %$sw) {
        my $if = $_ ne 'sayre' ? "A\.V && " : "";
        C.c.s =~ s/^(\s*)$_ ([^\n]+?)((?: (?:for|if) .+)?;?)$/${1}${if}G\.h->(\$A,\$C,\$G,\$T,'$sw->{$_}','$_',$2)$3/sgm;
    }
    
    C.c.s =~ s/\bs\&(\w+)/C\&$1/sgm;
    C.c.s =~ s/\bA\&(\w+)/A\.c\.$1/sgm;
    C.c.s =~ s/\ba\&(\w+)/A\.sc\.$1/sgm;
    C.c.s =~ s/\b((?!u)\w)s\&(\w+)/$1\.sc\.$2/sgm;
    C.c.s =~ s/\b(\w)c\&(\w+)/$1\.c\.$2/sgm;
    
    C.c.s = G&parse_babbl,C.c.s;
    
    # change J.n 
    C.c.s =~ s{\$J->\{([unm])\}->\((\$A,\$C,\$G,\$T?)(, ?\$M)?}
        {\$G->\{h\}->($2,"$1"$3}sgm;
    
    C.c.s
of: |
    # of
    #1 && sayyl "of C.t C.y.cv: _.t _.y.cv  _.c.code" for e&_z;
    for my $z ( e&_z ) {
        if (!zc&s) {
            sayre "z.t z.y.cv has no s: ".ki $z;
        }
        if (!z.c.code) {
            # shade the edge, args etc.
            Rw CoArgulate $C:z;
            # translate into perl
            Rw CoBabbler $C:z;
            # track etc
            s&dige = slm 12, dig zc&s;
            
            my $y = eval z.c.s;
            die "Nocompile of=C.t z.y.cv: z.t:"
                .ind('  ',$@)."\n\n z.c.s\n" if $@;
            die "Not code: z.t z.y.cv: $@\n".wdump 2, $z if ref $y ne 'CODE' && !z.sc.subpeel;
            z.c.code = $y;
        }
    }

    C.sc.hi = 'lo';
    T.nose = 1;
    
CoArgulate: |
    s&of || die "No of on ".ki$C;
    
    s&args ||= join',','A,C,G,T',grep{$_ ne '1'}s&acgt if s&acgt;
    s&args =~ s/[\+ ]/,/sgm;
    
    s&code && sayre "CoArgu C.t C.y.cv has scode: s&code:\n  ".ki$C;
    
    my $ara = [];
            
    exists s&t &&
        Rw conot $C;
    
    # the nk/gk it wants to wake up
    if (my $v = s&v) {
        my ($nk,$gk,$more) = $v =~ /^([tycs])(\S*)(?: (.+))?$/;
        $nk = 'sc' if $nk eq 's';
        $nk || die"strv:$v";
        s&nk = $nk;
        s&gk = $gk;
        die "More v: $more: ".ki$C if $more;
    }
    
    if (my $nk = s&nk) {
        push @$ara, "my \$".$nk." = C\.".$nk.";";
        if (my $gk = s&gk) {
            # dont remy v=cs in acgts
            my $my = "my " unless s&args =~ /\b$gk\b/;
            warn "Redefined the $gk ($nk\.$gk): ".ki$C if $gk =~ /^[ACGT]$/;
            push @$ara, "$my\$".$gk." = C\.".$nk."\.".$gk.";";
        }
    }
    
    C.sc.>$_ && die "Given $_: ".ki $C for qw'rg cg';
    
    s&args ||= 1;
    if (my $args = s&args) {
        die "wonky C.t   of ".ki $C if C.t =~ /\W/;
        my $gl = "";
        my $und = "_";
        # it becomes something
        my ($sf,$sa) = ('(',')->($A,$C,$G,$T)') if s&subpeel;
        my $sub = "sub {\n";
        if ($args ne '1') {
            my @args;
            my $und = '_';
            if ($args =~ s/^(A,C,G,T,)(?!s$)//) {
                push @args, 'my ($A,$C,$G,$T,@M)=@_;';
                $und = 'M';
            }
            push @args, "my (".join(',',map{'$'.$_}
                split',',$args).',@Me) = @'.$und.";";
            unshift @$ara, @args;
        }
        c&s = $sf
            ."sub {\n"
            .join("",map{"$_\n"} @$ara)
            .c&s
            ."}"
            .$sa
            .";";
    }
conot: | # expand sc.t->ip, compiled throat clause
    my $ip = C.sc.ip = {};
    for my $k (split ' ', C.sc.t) {
        my $is;
        # $is is our C.t
        $k =~ s/^(\w+):\^$/"$1:".C.t/e;
        # $is is $op?.$v
        $is = $2 if $k =~ s/^(\w+):(.+)$/$1/;
        # complication
        $is = C.sc.>C$k if exists C.sc.>C$k;
        my $p;
        my ($n,$g,$m) = $k =~ /^(t|y|c|sc?)?(.+?)?(\d+)?$/;
        $n ||= 'sc';
        $n = 'sc' if $n eq 's';
        # C.$nk.$gk.$tk
        p.nk = $n;
        p.tk = $2 if $n eq 'y' && $g =~ s/^([A-Z])(\w+)$/$1/;
        p.gk = $g if defined $g;
        die "merge in? ".ki$is if ref $is;
        # peels inside peels of sc.t
        if ($is =~ /^(\w+):(.+)$/) {
            $is =~ s/(?<!\\)\+/,/g;
            my $i = G&peel,$is;
            for (qw'in nin') {
                my $s = $i.>$_ || next;
                $s =~ s/\;/,/g;
                $i.>$_ = G&peel,$s;
            }
            G&xo,$p,$i;
        }
        elsif (defined $is) {
            my $i;
            my $neg = $is =~ s/^\!//;
            $i = 'gt' if $is =~ s/^>//;
            $i = 'lt' if $is =~ s/^<//;
            $i.= 'eq' if $is =~ s/^=//;
            $i = 're' if $is =~ s/^~//;
            $i ||= 'is';
            if ($neg && $i eq 'is') {
                undef $neg;
                $i = 'not';
            }
            p.neg = 1 if $neg;
            $p.>$i = $is;
        }
        delete p.gk if !p.gk;
        delete p.tk if !p.tk;
        $ip.>$k = $p;
    }
Zome: | # return a new J
    my ($i,$ii) = Rw MakePi;
    
    my $B = $A;
    my $A = {};
    A.sc.i = A.i = $i;
    A.sc.ii = A.ii = $ii;
    my $G = A.i.G->($A,$C,$G,$T);
    A.i.>$_ = B.I.>$_ for qw'parse_babbl';
    
    $A = G&A,'so';
    my $J = G&J,$A,'os';
    $J.>$_ = $A.>$_ = $J for 2,3,4;
    
    
    # A.* will inherit, A.sc.* is ours (usually)
    A.sc.ii = A.ii;
    A.sc.i = A.i;
    
    my $z = [sort {a.y.cv <=> b.y.cv || a.t cmp b.t}values%{A.ii}];
    my $u = G&Ct,[theu=>1=>'steve',{z=>$z}];
    A.ii.>u.t = $u;
    u.y.tw->{_.t} = $_ for @$z;
    
    $J
P: |
    u urw
    u UpPg
    n Zupe=>-run
pi/run: |
    symb: %hs:394,fs:12
        R
    n jeio=>2=>C.t=>'%dos:runs'
runs: |
    my $i = e&hC ->[-1];
    saybl ki $_ for @{ e&hC };
    G&zen,Com=>[dollarsworth=>''=>"Blagna",{pi=>'dae'}];
Com: |
    u urw
    u UpPg
    y.at.anch = "Noteal";
    ($A)=
    stuff:
        is
    say "Yer $$";
    G&liz,Com=>$_ for sub {
        my ($k,$s) = @_;
        saygr "Yer $$";
        #Rw waitme re;
        fork() ||
        Rw comput $s;
    };
comput: |
    say "Yer $$";
    sayyl "Yup: ".wdump 3, $s;
    exec 'perl got Zupe 4 b';
    die "BVack:";
    exit;
    
Zop: |
    u urw
    y.clos = 1;
    my $beg = hitime();
    
    J.thou++ || do {
        n ElvisDialects=>-test
        #n ElvisThinks=>-test=>{man=>'Zupe'}
    };
    
    sayyl "Took ".G&ron,hitime()-$beg;
    J.output || exit;
    
    sayyl "Making pud...";
    m wk=>-pud=>{s=>J.output},'%hs:375,ws,wi:30%'
    
    
Zupe: | # run Zome, output pud
    u urw
    y.clos = 1;
    my $beg = hitime();
    
    J.thou++ || do {
        n ElvisLeaves=>-test
        n ElvisWorld=>-test
        n ElvisWads=>-test
        n ElvisWorlds=>-test
        n EpiWaveletting=>-test
        n ElvisThinks=>-test
    };
    
    sayyl "Total ".G&ron,hitime()-$beg;
    J.output || exit;
    
    sayyl "Making pud...";
    m wk=>-pud=>{s=>J.output},'%hs:375,ws,wi:30%'
    
pi/test: |
    my $c;
    c.pin = 'ATest';
    c.tell = J.mo.J;
    c.man = c&man if c&man;
    n C.t =>W=> $c
ATest: |
    my $m = [ C.t ];
    my $out = Rw Tesh + $m;
    if ($out) {
        my $el = c&tell;
        el.output.>C.t = $out;
    }
    
Tesh: | # wrap test way
    # give prototype J/A to the t, the test J as oJ
    my ($t,$sel) = @$m;
    my $tes = sub {
        my $C = G&tC,\@_;
        c&test ||= do {
            C&l = C.t;
            C.t = $t;
            J.testRun;
        };
        C.c.tac = 1 if C&l =~ s/!$//;
        C.c.question = 1 if C&l =~ s/\?$//;
        c&tac = 1 if J.tacall;
        my ($aye) = map {_.M->[0]}
        n $C
        aye.c.return
    };
    
    #die "Just $sel" if $sel;
    
    J.R ||= Rw Zome;
    
    my $beg = hitime();
    while (!J.begins || J.testsRun > J.lasttestsrun) {
        J.lasttestsrun = J.testsRun;
        J.testUntil = J.testRun + 1;
        my $n = defined $sel ? $sel :
            Rw Dwive + $notime=1;
        J.begins ||= do {
            ok(1, "J.name begins");
            $beg;
        };
        $beg = hitime();
        
        my $oJ = J.R; # v inside oJ is J
        my $oG = oJ.y.G;
        Rw $t + $tes $n $oJ:J $J:oJ $A:oJ.1 $G:oG;
        
        J.output = oG.ouJ if oG.ouJ;
        delete J.tacall;
        $sel || J.testsRun > J.lasttestsrun &&
        ok(1, "Took ".G&ron,hitime()-$beg );
        return J.output if J.output && defined $sel;
    }
    $sel ||
    ok(1, "Total ".G&ron,hitime()-J.begins );
    
    J.output
Telvis: |
    c&te = A.ii.theu;
    c&ot = "";
    my $Q = $C;
    A.4.c.testC = $C;
    # same C each time as Tesh notime
    delete C&ofts;
    my $t;
    
    t.cs = sub {
        my ($c,$t) = @_;
        $c = {ntos=>$c} if $c && !ref $c;
        C.c.ot = $1 if c.ntos =~ s/^(\w+)\///;
        map { G&xot,$c,$_ } G&peel,$1 if c.ntos =~ s/,(.+)$//;
        $tes->($t,1,$c)
    };
    t.ntos = sub { # get the oscillator A (s) given e is n of J
        my ($j,$want) = @_;
        ($j) = values %{j.c.tug};
        return $j if $want eq 'mo';
        $j = j.c.s || die "No C on ".ki$j;
        # the last Hows mo C
        $j = j.sc.J || die "No J on ".ki$j;
        $j = j.sc.s || die "No s on ".ki$j;
        $j
    };
    my $toc = {};
    c&mks = sub {
        my ($C,$T) = @_;
        T.oke = 1;
        my $se = Q.c.te;
        my $bang = 0; # path?! means avoid o
        if (my $p = c&ntos) {
            my $sp = sub {[split / |,/, shift ]};
            my $output = $sp->($1) if $p =~ s/^(.*)\?(\S+)?(!)( .+)?$/$1$4/;
            my $nav = $2;
            $bang = 1 if $3;
            $p = $sp->($p);
            $se = t.ntos->($se);
            
            if ($output || C.c.see) {
                $output ||= $sp->(C.c.see) if C.c.see && C.c.see ne '1';
                $output = $output ? G&pint,$se,@$output : $se;
                $output = G&pint,$output,split'-',$nav if $nav;
                oJ.output = $output;
                C.c.return ||= oJ.output;
                return [] if C.c.see;
            }
            
            $se = G&pint,$se,@$p
        }
        C.c.return ||= $se;
        if ($bang) {
            return ['Outputting something'];
        }
        
        my $oc = {};
        oc.noz = 1 if c&noz;
        oc.nonext = 1 if c&nonext;
        $oc.>$_ = $toc.>$_ for keys %$toc;
        my $ot = c&ot = c&ot || Q.c.ot || c&test.'-'.C&l;
        
        
        my $AV = delete A.V;
        my $o = G&A,o=>6=>$J=>$se,[$ot,'',$oc];
        A.V = $AV if $AV;
        
        # c&tac=1;
        my $l = o.c.rsl || die "no rsl";
        $l = [grep { c&grepl ->($_) } @$l] if c&grepl;
        $l
    };
    c&posts = sub {
        my ($C,$T) = @_;
        return unless A.V || A.Ve || C.c.question;
        1 && saybl "No items for: C.sc.l" if !@{c&s};
        1 && saybl "the ".slim(10,c&ot).": ".$_ for @{c&s};
    };
    #c more stuff
    t.siim = sub {
        my ($Y,$sc,$h) = @_;
        my $ii = Y.ii;
        $ii = Y.sc.ii if $sc;
        $h = sprintf"%-12s",$h if $h;
        $h .= " Y.c.sip Y.t 2=Y.2.t: ";
        $h .= 'sc' if $sc;
        return "$h undef" if !$ii;
        "$h   ii ".join" - ",
        map { 
        my $de;
        if ($_ eq 'mo') {
            my $mo = $ii.>$_ || die "No mo";
            my $tw = mo.y.tw || die "No tv: ".ki$mo;
            $de = "*" if tw.fis;
        }
        $_.$de
        } sort keys %$ii
    };
    t.gout = sub {
        my ($Y,$p) = @_;
        $p = [split '-', $p] if !ref $p;
        my $h = join(' ',@$p);
        my $sc = pop @$p if $p->[-1] eq 'sc';
        $Y = G&pint,$Y,@$p if @$p;
        t.siim->($Y,$sc,$h);
    };
    c&iiuse = 'next';
    t.lookii = sub {
        my ($p) = @_;
        my $s = t.ntos->(c&te);
        my $ii;
        if ($p) {
            $p = [split '-', $p] if !ref $p;
            $ii = G&pint,$s,@$p;
        }
        else {
            $ii = s.sc.ii;
        }
        my @m;
        my $anii;$anii = sub {
            my ($c) = @_; #
            my @m;
            push @m, "c.t c.y.cv has:";
            if (c&iiuse eq 'z') {
                for my $e (@{c.sc.z}) {
                    push @m, " - e.t e.y.cv    ".ki(e.c)."      ".ki(e.sc);
                    $m[-1] =~ s/\n/\\n/g;
                }
            }
            else { # use next
                my $e = c.y.in;
                while ($e) {
                    push @m, " - e.t e.y.cv    ".ki(e.c)."      ".ki(e.sc);
                    $m[-1] =~ s/\n/\\n/g;
                    $e = e.y.next;
                }
            }
            if (my $ov = c.y.over) {
                push @m, " y over:",
                    map { "  $_" } $anii->($ov);
            }
            @m;
        };
        for my $t (sort keys %$ii) {
            my $c = $ii.>$t;
            push @m, $anii->($c);
        }
        \@m;
    };
    return $t
ElvisMachines: | # J u Dialect, deeply rooted # TODO TODO TODO
    my $t = Rw Telvis;
    A.uyes = 1;
    #A.V = 1;
    
ElvisDialects: | # J u Dialect, deeply rooted # TODO TODO TODO
    my $t = Rw Telvis;
    A.uyes = 1;
    #A.V = 1;
    
    # localised implica expanded into universal (still localised)
    # eg make everything acgt:s
    
    # how to isolate pure data entry from Jing
    # encode not sJ or anywhere in the mo that sJ:
    # so our J/their our-minded parts (eg n root) dont get the encoding
    
    #  # may want to use a clear head at mo J 5, ie
    # takes our readings of impulse in 4 to the control dome
    # J inter language space of 5, the permissions, net gear
    # so for now A.2.ii = A.5.ii and T.seek=1 re G&t us
    # and eg the root n in J 6 will be a normal op
    
    #  # decompression wants to live in of=D and be for nonJ
    # and be the thing knowing/isolating a ghost
    # making A.D = receipt for the pin/scheme/O cause/elvis handling
    # or the convo/dialect state applied within
    # falling A bounds like .mo:
    
    # U al4noJ 3 spawns our encoding on the J6ing.mo:
    #     A.D = {self,J=A.D}
    #         marking D above ours (unless already) as the norm for doing J
    # then mo dome 2:
    #    A.D = A.D.J if c&J && A.D && A.D.J;
    #       peels off encodings/holes to A.mo.up.mo's intention
    #         for this A.mo, so it can speak nonJ n normally
    #   runs D
    #        with A.D for direction/self
    # and U al4noJ 7:
    #    finishes our encoding
    
    # D may make good interface to pages to reset (when J 6)
    # or unrestart (when S sleeps)
    # or partition (with names) and despatch to whatever process
    
    # so encodings should all of=D
    # a W reverses line protocols from remote stream
    # via m into golden box acum space
    # fills <5 at lum top, 8-9 lum/3, 7-8 lum/7, etc towards 555555555555
    # into streams of atoms for your A.3 to officially reposition
    
    # of=U = runs when mind made up/down
    # of=M = for the $M produced by 6, incs depth of atoms
    # of=S = check for escaping gas (sleeps minor changes)
    
    # A.2 to change to A.1 whenever
    
    # but for now:
    # the encodings are all in 42-43, which s& or cv=9 skips over
    # could be more pronounced how its not for J or its descendants
    #  by hanging encodings on/in an A.D, which replants at 6
    #  until that J brings its own mind onto the A
    # simple stuff should work
    
    if ($n == 0) {
        c&te =
        n ElvisDialecto
        t.cs->('sc lastK c s','dialect decompressed');
        t.cs->({s=>t.lookii->()},'have ii');
    }
    elsif ($n == 1) {
        c&te =
        n ElvisDialecto
        t.cs->('sc lastK c s','dialected change stuff');
    }
    elsif ($n == 2) {
        c&te =
        n ElvisDialecto
        t.cs->('sc lastK c s','dialect changes');
    }
ElvisDialecto: |
    if (J.bowls++ < 2) {
        u alact
    }
    else {
        u alacgts
    }
    n alact
    my $hum = ',cr:ab' if J.bowls > 1;
    jasm: %fo:late$hum
        # rubbing
    joints: %fo:river,of:42
        # southward
    n \'of:not'
    semio:
        # tic tic;sdigjshgisdf
    sedio:
        # tic tic
alact: | # aka a
    # make acts
    n alacgts
    alact 423: %acgt:s,act,of:mo
        s&act = 1 if !exists s&act;
        s&of ||= C.t;
alacgts: | # aka i
    n alof
    alacgts 421: %acgt:s,act,of:mo
        s&acgt = 1 if !exists s&acgt;
alof: | # auto of, i or whatever was .c.of'd
    n al4noJ
    alof 422: %acgt:s,act,of:mo
        return if s&J;
        my $Y = A.mo.up.mo;
        if (c&of) {
            C.t && die "of had t: ".ki$C;
            Y.sc.vse.of = c&of;
            return T.not = 1;
        }
        my $def = 'i';
        $def = Y.sc.vse.of if Y.sc.vse && Y.sc.vse.of;
        s&of ||= $def;
        1 && saybl "alof: A.2.t 422: C.t C.y.cv";
al4noJ: | # skip codings for J
    al4noJ 42: %acgt:s,act,v:sJ,of:mo
        T.Z.43 = $A;
    # the mo J 6 may use mind for created's root, etc.
    al4nonine 42: %acgt:s,act,t:ycv:0.9,of:mo
        T.Z.43 = $A;
        
ElvisThinks: | # J uses u (mind), does stuff with it
    my $t = Rw Telvis;
    A.uyes = 1;
    if ($n == 0) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker made with mind');
        t.cs->('sc lastA 2 sc u sc s sc ii eloquence,nonext','J u s ii eloquence');
        t.cs->({ntos=>'sc lastA 2 sc u sc s sc ii mo',
            nonext=>1,grepl=>sub{ $_[0] =~ /^\s+(fis|fscolour) / }
        },'J u s ii mo seems to be');
        
        my $mo = t.ntos->(c&te,'mo');
        
        is mo.t, 'mo', 'mot is mo';
        is mo.2.t, 'ElvisThinker', 'mo2t is ElvisThinker';
        is mo.2.sc.u.t, 'u', 'ut is u';
        my $usii = mo.2.sc.u.sc.ii;
        is ref $usii, 'HASH', 'ii is hash';
        for my $t (qw'eloquence mo') {
            my $is = $usii.>$t;
            is ref $is, 'HASH', "usii $t";
            for (qw'tv tw in') {
                is ref is.y.>$_, 'HASH', "usii $t has y$_";
            }
        }
        my $minds = [map{t.gout->($mo,$_)}qw'
            up 1 1-sc
            2 2-sc
            2-sc-u
            2-sc-u-sc
            2-sc-u-sc-s
            2-sc-u-sc-s-sc
            2-sc-s
            2-sc-s-sc
        '];
        t.cs->({s=>$minds},"ii in/around mo ElvisThinker");
        
    }
    elsif ($n == 1) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker again uses mind');
    }
    elsif ($n == 2) {
        c&te =
        n ElvisThinker
        t.cs->('sc lastK c s','ElvisThinker changes mind');
    }
ElvisThinker: |
    u ElvisThinking
    
    J.bowls++ < 2 &&
    u ElvisThought
    some: %fs:8
        tan goal
    further: %fis:5
        thought matters
    n random=>7=>\'mon:A,s:moon'
    #G.ouJ = $J;
ElvisThinking: |
    # for mo 
    FindMeWhenYoure: %acgt:s,of:i
        # anywhere
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.03 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    fscolour 4: %act,acgt:s,v:sfs,of:mo
        my $h = $fs + 7;
        my $l = int($h / 3) + 6;
        $h -= 9 until $h < 9;
        $l -= 9 until $l < 9;
        C.sc.hs ||= $h.'7'.$l;
    
ElvisThought: |
    # for mo, or Hoop & bend towards some over time...
    dosoooooooooooooooooooo: %of:eloquence
        3 + 4 / 33 + $s
    fis 16: %act,acgt:s,v:sfis,of:mo
        C.y.cv = 0.24 + 0.06 * 
            (length(c&s) / length(join'',split/\S+/,c&s));
    monta 4: %act,acgt:s,v:cmon,of:mo
        c&s = "$mon c&s $mon" if exists c&s;
EpiWaveletting: | # J makes pi, join lv
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit');
        t.cs->('c zip sc top','Waveofit zip top');
        t.cs->('c zop sc top','Waveofit zop top');
    }
    elsif ($n == 1) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 2) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change/goner');
    }
    elsif ($n == 3) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 4) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
    elsif ($n == 5) {
        c&te =
        n Waveofit
        t.cs->('sc lastK c s','Waveofit pi change');
    }
Waveofit: |
    my $ou = J.sc.ou ||= [3,6,44,2,42,3,7,12];
    J.bowls++ && J.bowls < 4 && shift @$ou;
    n ylinogj=>-waveofits=>{s=>$ou}
    J.bowls < 3 &&
    n dough=>3=>{pi=>'waveofit',s=>"Says so"}
    n etc=>6=>J.bowls
pi/waveofits: |
    pre 1: %hs:378,fs:19
        ~@@@~
    my $div = 6 / @$s;
    my $i;
    for (@$s) {
        n doing=>( G&rou,2+$div*$i++ )=>{s=>$_},'%hs:394,bo:3px solid 4873'.($_ > 20 && ',fs:'.($_))
    }
    
    (J.dimin ||= 12)--;
    reg 89: %fs:J.dimin
        hadu
    pos 9: %hs:376,fs:17
        ~@@@~
pi/waveofit: |
    pre 1: %hs:878,fs:19
        ~~~~~~
    n doing=>2=>{s=>$s},'%hs:394,bo:3px solid 4873'
    pos 3: %hs:876,fs:17
        ~~~~~~
ElvisWorlds: | # J makes J, gather We in self
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys');#
        t.cs->({s=>C&ofts},"ofts made");
        # TODO? zopul copies dupey z, relinked in/next is deduped
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 1) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys without Whysl');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 2) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys + Whysl again');
        t.cs->({s=>C&ofts},"ofts made for changed We");
        t.cs->({s=>t.lookii->()},"ii changed");
    }
    elsif ($n == 3) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','Whys not');
        t.cs->({s=>t.lookii->()},"ii via next deduped");
        c&iiuse = 'z';
        t.cs->({s=>t.lookii->()},"ii via z contains dupes");
    }
    elsif ($n == 4) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 5) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
    elsif ($n == 6) {
        c&te =
        n Whys
        t.cs->('sc lastK c s','two wormholes unite');
        t.cs->({s=>t.lookii->()},"ii");
    }
Whys: |
    J.herefirst = "Was htis";
    J.bowls++ != 1 &&
    n Whysl
    
    J.bowls > 3 &&
    not: %velo:iffry,oft:i
        negate
    mix: %acgt:s,v:chume,oft:i
        G&yellow,$C,'tool'
    elect: %acgt:s,v:chume,oft:i
        G&blues
        # e
    my $ms = J.bowls > 2 ? '# the sandy' : '# sandy';
    n music=>1=>{s=>$ms}=>'%acgt:s,v:sJ,oft:dowse'
    bull: %oft:tools
        motorise time machine
    trail 16: %acgt:s,v:cmoresel,oft:tools,Wv:2
        1c&dol++;
    
Whysl: |
    J.bowls++ < 2 ||
    n skinny=>4=>{}
    J.herefirst && die "Was not J.t";
    my $hum = ',hum:'.(J.bowls+2) if J.bowls == 2 || J.bowls == 3;
    
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
    mix: %acgt:s,v:chume,oft:i$hum
        G&yam,$A,'tool';
    dowse: %acgt:s,v:sJ,oft:dowse
        G&yam,$A,'tool';
    trail 22: %acgt:s,v:ctar,oft:tools
        # and
        1c&dali++;
    J.bowls < 5 &&
    trail 16: %acgt:s,v:ctar,oft:tools,Wv:2
        # or
        1c&dali++;
        
    
        
        
ElvisWads: | # J in J (both W) simplicity
    my $t = Rw Telvis;
    
    if ($n == 0) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad');
        ok !exists C&ofts, 'no ofts';
        t.cs->('c zop sc top','ElWad zop top');
        #$tos->('s1omp/sc lastK c s','two wormholes unite');
    }
    elsif ($n == 1) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 2) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed');
    }
    elsif ($n == 3) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad changed back');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 4) {
        c&te =
        n ElWad
        t.cs->('sc lastK c s','ElWad still changed back komp');
        t.cs->('c zop sc top','ElWad zop top');
    }
    elsif ($n == 5) {
        c&te =
        n ElWadill=>W=>{rando=>'M'}
        t.cs->('sc lastK c s','ElWadill randomly');
        t.cs->('c zop sc top','ElWadill zop top');
    }
ElWad: |
    n ElWadill
    my $hum = ',hs:394' if J.bowls++ == 2;
    n noise=>3=>"Samp"=>'%hs:445'
    n nose=>4=>"Samp"=>'%hs:445'
    dji 314159: %fs:40$hum
        blos
ElWadill: |
    More:
        Noise!
    c&rando ||
    Than:
        before
    since:
        sync
    c&rando &&
    n c&rando=>87=>"With sides"
    
ElvisWorld: | # J makes, puts elvised We in self
    my $e = A.ii.theu;
    my $ot = "this";
    my $o;
    
    my $tos = sub {
        my ($c,$t) = @_;
        $c = {ntos=>$c} if $c && !ref $c;
        $ot = $1 if c.ntos =~ s/^(\w+)\///;
        map { G&xot,$c,$_ } G&peel,$1 if c.ntos =~ s/,(.+)$//;
        $tes->($t,1,$c)
    };
    my $ntos = sub { # get the oscillator A (s) given e is n of J
        my $j = shift;
        ($j) = values %{j.c.tug};
        $j = j.c.s || die "No C on ".ki$j;
        # the last Hows mo C
        $j = j.sc.J || die "No J on ".ki$j;
        $j = j.sc.s || die "No s on ".ki$j;
        $j = G&pint,$j,@_ if @_;
        $j
    };
    my $toc = {};
    c&mks = sub {
        my ($C,$T) = @_;
        T.oke = 1;
        my $se = $e;
        if (my $p = c&ntos) {
            my $sp = sub {[split / |,/, shift ]};
            my $output = $sp->($1) if $p =~ s/^(.*)\?( .+)?$/$1$2/;
            $p = $sp->($p);
            $se = $ntos->($se);
            
            if ($output || C.c.see) {
                $output ||= $sp->(C.c.see) if C.c.see && C.c.see ne '1';
                oJ.output = $output ? G&pint,$se,@$output : $se;
                C.c.return ||= oJ.output;
                return [] if C.c.see;
            }
            
            $se = G&pint,$se,@$p
        }
        C.c.return ||= $se;
        my $AV = delete A.V;
        my $oc = {};
        oc.noz = 1 if c&noz;
        oc.nonext = 1 if c&nonext;
        $oc.>$_ = $toc.>$_ for keys %$toc;
        $o = G&A,o=>6=>$J=>$se,[$ot,'',$oc];
        A.V = $AV if $AV;
        
        #A.V = 1 if $n == 10;
        # c&tac=1;
        
        my $l = o.c.rsl || die "no rsl";
        
        (A.V || A.Ve || C.c.question) &&
        1 && saybl "the $ot: ".$_ for @$l;
        $l
    };
    if ($n == 0) { #c
        $e =
        n Hows
        $tos->('ziptop/c zip sc top','Hows zip top');
        $tos->('zoptop/c zop sc top','Hows zop top');
        $tos->('zipp/c zip sc aroz,noz','Hows zip aroz');
        $tos->('zip1zop/c zip sc zop,noz','Hows zip zop');
        $tos->('zop1allz/c zop sc aroz,noz','Hows zop aroz');
    }
    elsif ($n ==1) {
        $e =
        n Hows
        my $zip =
        $tos->('zlp/c zip? sc top','Hows zip top again');
        delete oJ.output;
        my $cha = zip.c.cha.C;
        is 0+keys%$cha, 3, "3 changed";
        my $gone = cha.gone;
        ok $gone, "was gone";
        is join(', ',sort keys %$gone), 'skinny', "gone has keys == skinny";
        my $sk = G&pint,$gone,skinny=>0.4;
        is sk.t, 'skinny', "skinny is";
        ok !G&pint,$gone,Hows=>0.9 , "Hows tv not gone";
        ok !G&pint,$gone,'Hows' , "Hows t not gone";
        
        my $u =
        $tos->('zop2top/c zop? sc top','Hows zop top');
        delete oJ.output;
        $tos->({s=>u.c.rsl},'zop rsl shows goner');
        toc.noz = 1;
        $tos->('zip2zop/c zip sc zop','zip zop shows gone skinny');
        $tos->('zop2zop/c zop sc zop','zop zop shows gone skinny');
        $tos->('zop2inz/c zop sc inz','zop inz shows gone skinny');
        $tos->('zop2outz/c zop sc outz','zop outz shows gone skinny');
        delete oJ.output;
        delete toc.noz;
        $tos->('scomp/sc lastK c s','compression of gone skinny');
    }
    elsif ($n == 2) {
        $e =
        n Hows
        
        $tos->('zlo3p/c zip sc top','Hows zip top shows new trail');
        $tos->('zol3p/c zop sc top','Hows zop top shows new trail');
        # cant look at zop/inz because unhandled duplicate ty of trail
        $tos->('s3omp/sc lastK c s','compression of etc + trail');
    }
    elsif ($n == 3) {
        $e =
        n Hows
        
        $tos->('zlo4p/c zip sc top','Hows zip top shows changed trail');
        $tos->('zol4p/c zop sc top','Hows zop top shows changed trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        $tos->('s4omp/sc lastK c s','compression of etc + changed trail');
        
        my $ii = 
        $tos->('s4ii/sc ii? tools,nonext','made ii tools');
        delete oJ.output;
        $tos->({s=>[ki$ii,1]},"ii looks good");
        my $s = $ntos->($e);
        is s.sc.ii, $ii, "ii same a tos'd return";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.2;
        is H.sc.ii, $ii, "ii same on A2sii";
        ok !exists H.sc.i, "no i on A2si";
    }
    elsif ($n == 4) {
        #A.V = 1;
        #return;
        # explodes: unpositing into zopul makes empty We thing
        $e =
        n Hows
        
        $tos->('zlo5p/c zip sc top','Hows zip top shows gone trail');
        $tos->('zol5p/c zop sc top','Hows zop top shows gone trail');
        $tos->('zlo3p/c zip sc top','Hows zip top o diff');
        $tos->('zol3p/c zop sc top','Hows zop top o diff');
        my $s = $ntos->($e);
        ok !exists s.sc.ii, "no ii on s";
        ok !exists s.sc.i, "no i on s";
        my $Y = s.sc.lastA;
        my $H = Y.2;
        ok !exists H.sc.ii, "no ii on A2sii";
        ok !exists H.sc.i, "no i on A2si";
        #G.ouJ = j.sc.lastK.c.s;
        $tos->('s5omp/sc lastK c s','compression of gone trail');
    }
    
Hows: |
    J.sc.u.c.o = 'oscd';
    my $so = 's o,towe:l';
    $so = 's,tele:vise' if J.bowls;
    rakes: %acgt:$so
        robino
    
    leaves: %some:other,ma:ni,fo:la,t:e
        traces
    
    J.bowls &&
    surf:
        to rise
    
    J.bowls++ ||
    n skinny=>4=>{}
    my $hum = ',hum:4' if J.bowls == 4;
    J.bowls >= 3 && J.bowls <= 4 &&
    trail: %acgt:s,v:ctar,oft:tools$hum
        G&yam,$A,'tool';
        
        
        
        
        # and
        1c&dali++;
oft: | # test of
    1 && saybl "We things C.c.W named C.t C.y.cv:   ".ki C.c.e;
    # should hup & acum C.sc.z
    push @{ A.4.c.testC.sc.ofts ||= [] },
        "We things C.c.W named C.t C.y.cv:   ".ki C.c.e
        if A.4.c.testC;
    
    for my $e ( e&_z ) {
        ec&s =~ s/\n\s*\n+/\n\n/sgm;
        es&seen = 2;
        ec&code = sub { "does e.t e.y.cv from C.t" };
    }
    C.sc.hi = 'lo';
    T.nose = 1;
    
ElvisLeaves: | # data vs o, watch change
    #A.V = 1;
    #exit if $n > 3;
    my $tf = 't/Zupe/ElvisLeaves/theu';
    DumpFile($tf, A.ii.theu) unless -f $tf;
    my $e = J.theu ||= LoadFile($tf);
    my $o;
    my $ot = 'zimb';
    
    my $lshot = sub {
        my ($C,$l) = @_;
        my $m = c&lshot;
        return unless @$l > $m;
        @$l = (@{$l}[0..$m]);# "... snip x".(@$l-$m));
    };
    c&mks = sub {
        my $C = shift;
        $o = G&A,o=>6=>$J=>$e,$ot;
        
        #A.V = 1 if $n == 10;
        
        my $l = o.c.rsl;
        #  c&tac = 1;
        
        c&lshot && $lshot ->($C,$l);
        (A.V || A.Ve) &&
        saybl "the Dujis: ".$_ for @$l;
        $l
    };
    
    if ($n==0) { #c
        $tes->('whole u','',{lshot=>32});
    }
    elsif ($n==1) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Here';
        $m = e.sc.z->[3];
        $m = m.y.in;
        $m = m.y.next || $m for 1..3;
        m.sc.epl = "Dop";
        m.c.s = "ACGT {} !";
        e.sc.eo = 'popup';

        $m = e.sc.z->[5];
        $m = m.y.in;
        $m = m.y.next || $m for 1..2;
        
        my $pr = m.y.prev;
        G&apart,next=>$pr;
        pr.sc.herre = 'OOOO';

        pop @{e.sc.z};
        
        $tes->('u messed with');
    }
    elsif ($n==2) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Hur';
        $m = e.sc.z->[1];
        $m = m.y.in;
        G&apart,next=>$m for 1..3;
        G&toget,next=>m.y.next.y.next,$_ for G&Ct,[available=>6=>'makeether','%eo:fil'];
        $tes->('couple more');
    }
    elsif ($n >= 3 && $n <= 4) {
        $ot = 'dwell';
        my $la = G&Ct,[row=>6=>is=>'%hs:588'];
        my $te = G&Ct,[seen=>8=>is=>'%hs:588'];
        $e = [
            G&Ct,[row=>1=>is=>'%hs:588'] ,
            G&Ct,[reow=>1=>is=>'%hs:588'] ,
            G&Ct,[rodw=>5=>is=>'%hs:588'] ,
            $la, $te
        ];
        $e = G&Ct,[wo=>2=>{}=>{z=>$e}];
        
        if ($n == 3) {
            $tes->('el=1 when dup t');
        }
        else {
            la.t = 'som';
            te.sc.hs = 359;
            te.sc.know = 'ing';
            $tes->('mount');
        }
    }
    elsif ($n >= 5 && $n <= 8) {
        my $mo = e.sc.z->[1];
        my $om = G&Ct,[J=>4=>'codedpassage'=>'%acgt:3'];
        my $z = [
            $om,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        my $lom = G&Ct,[mo=>0.001=>{W=>'of'},{z=>$z}];
        my @io = (
            G&A,o=>2=>$J=>$mo,'Themo' ,
            $n < 7 && G&A,o=>2=>$J=>$lom,'Extra'
        );
        $e = {map{_.c.sip => $_ }grep{$_}@io};
        $ot = 'zip';
        
        if ($n == 5) {
            # c&mks ->();
            $tes->('W over without innards');
        }
        elsif ($n == 6) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over change some');
        }
        elsif ($n == 7) {
            mo.y.in.sc.casa = "case $n";
            $tes->('W over, chang, Extra gone');
        }
        elsif ($n == 8) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over, more change');
        }
    }
    elsif ($n == 9) { #c
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[snapsof=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see two');
    }
    elsif ($n == 10) {
        $ot = 'thanks';
        my $z = [
            G&Ct,[movie=>3=>'mae'=>{acgt=>3}] ,
        ];
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>{acgt=>3,z=>$z}] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see one go, one come');
    }
    elsif ($n == 11) {
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see z disappear');
    }
    my $so = $o;
    my $one = 0.001;
    #$so = so.c.oo.C.theu.>$one;
    $so = J.sc.jo.zip.sc.oo.C.mo.>$one; # from oJ, the zip's mo 0.001
    return {p=>33};
    $so = so.sc.jo->{"z mo $one"};
    $so = so.c.Co; # the C currently othering under the recursionship of j
    $so = so.c.j.sc.oo.C.W; # through to the j again, all C it can see named W
a: | # act
    u allact
    n allact
    n 'allareact=1'=>42,<<''
        C.sc.act = 1 if !exists C.sc.act;
        C.sc.code = C.t if !exists C.sc.code;
i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
c: | # of something c.? acts
    n allc
s: | # of something sc.? acts
    n alls
    

