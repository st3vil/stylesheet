PiMachine: |
    n C
    n Day
    n Tube
    #
    n Tunnel
    n Jelly
    
    n Triangle
    n Circle
    n Walks
Zupe: | # make code, run Zome, output pud
    u urw
    my $ii = {};
    my $dig = sub {
        my $tW = shift;
        $tW = {%{$tW}};
        $tW->{$_} = readlink "w/digway/$_" for keys %$tW;
        $tW;
    };
    my $ol = LoadFile('w/glacwal');
    if (ki($ol) ne ki($dig->($ol))) {
    sayre "Zupe unstuck: \n".ki($ol)."\n ne\n".ki($dig->($ol));
    my $it = 'Day';
    $it = 'PiMachine';
    n $it
    my $jt = G.oin.inJ;
    my $Day = $jt->{$it};
    my $tW = {};
    my $su;$su = sub {
        my $J = shift;
        my $v = J.El.Pre.tv || die "J.name no tv";
        map { _.sc.J ? ($_,$su->(_.sc.J)) : $_ }
        grep { _.y.cv < 0.9 || do{$tW->{_.t} = $_; 0} } values %$v;
    };
    my $N = [$su->($Day)];
    my $v = {}; # of/cv/t acum
    my $M = [map {
        Rw ym/conoi $noAI=1 $C:_ $v;
    } @$N];
    DumpFile('w/glacwal',$dig->($tW));
    DumpFile('w/glacval',$v);
    }
    
    my $v = LoadFile('w/glacval');
    for my $of (keys %$v) {
        my $o = $ii->{$of} = {t=>$of,y=>{cv=>0.1},c=>{W=>'of'}};
        my $c = $v->{$of};
        my $la = $o;
        for my $cv (sort keys %$c) {
            my $ts = $c->{$cv};
            for my $t (sort keys %$ts) {
                my $z = $ts->{$t};
                sayre "Compile $of $cv $t !";
                Rw TheBabbler $C:z;
                saybl "zo: ". z.c.s if z.t eq 'Chew';
                my $y = eval z.c.s;
                die "Throcompile $of z.y.cv: z.t:"
                    .ind('  ',$@)."\n\n z.c.s\n" if $@;
                die "Not code: z.t z.y.cv: $@\n".ki $z if ref $y ne 'CODE' && !z.sc.subpeel;
                z.c.code = $y;
                if ($la eq $o) {
                    la.y.in = $z;
                }
                else {
                    la.y.next = $z;
                }
                z.y.prev = $la;
                $la = $z;
            }
        }
    }
    
    my $i = {};
    my $n = ii.i;
    while ($n) {
        if (n.c.code) {
            $i->{n.t} = n.c.code;
            ii.i.y.tw->{n.t} = $n;
        }
        $n = n.y.in || n.y.next;
    }
    
    
    y.clos = 1;
    my $so = Rw Zome $i $ii;
    #n wk=>-pre=>wdump(6, $so),'%hs:375'
    m wk=>-pud=>{s=>$so},'%hs:375,ws,wi:30%'
    
    
CoBabbler: |
    C.c.s =~ s/\bs\&(\w+)/C\&$1/sgm;
    C.c.s = G&parse_babbl,C.c.s;
Hows: |
    take:
        robino
    leave:
        traces
Zome: |
    my $B = $A;
    my $A = {};
    A.sc.i = A.i = $i;
    A.sc.ii = A.ii = $ii;
    my $G = A.i.G->($A,$C,$G,$T);
    A.i.parse_babbl = B.I.parse_babbl;
    $A = G&A,'so';
    my $J = G&J,'os';
    A.4 = A.3 = A.2 = $A;
    my $z = [sort {a.y.cv <=> b.y.cv || a.t cmp b.t}values%{A.ii}];
    A.ii.>$_ = G&Ct,[$_,1,'steve',{z=>$z}] for 'theu';
    A.sc.ii = A.ii;
    A.sc.i = A.i;
    my $Y = G&A,'Y';
    Y.ii = {u=>A.ii.u};
    Y.i = {};
    Y.i.>$_ = A.i.>$_ for grep /^C/, keys %{A.i};
    Y.sc.ii = Y.ii;
    Y.sc.i = Y.i;
    my $e = G&Ct,[zomb=>1=>'steve'=>'%hs:355,el:vs'];
    $e = A.ii.theu;
    
    my $ot = 'zimb';
    my $beg = hitime();
    
    my $o = G&A,o=>4=>$J=>$e,$ot;
    #Y.i.Chsgu = Y.i.Chs;
    Rw Duj $i:o;
    #e.sc.el = 'vios';
    #e.c.s = 'Steve';
    #e.y.cv = 0.2;
    my $m = e.sc.z->[4];
    m.sc.was = 'Here';
    $m = e.sc.z->[3];
    $m = m.y.in;
    $m = m.y.next || $m for 1..3;
    m.sc.epl = "Dop";
    m.c.s = "ACGT {} !";
    e.sc.eo = 'popup';
    
    $m = e.sc.z->[5];
    $m = m.y.in;
    $m = m.y.next || $m for 1..2;
    saybl ki $m;
    my $pr = m.y.prev;
    my $ne = m.y.next;
    pr.y.next = $ne;
    ne.y.prev = $pr;
    #m.y.prev = m.y.prev.y.prev;
    #m.y.prev.y.next = $m;
    pr.sc.herre = 'OOOO';
    
    pop @{e.sc.z};
    
    my $i = G&A,o=>4=>$J=>$e,$ot;
    
    my $int = hitime() - $beg;
    say "Took $int";
    
    my $beg = hitime();
    my $z = Rw Duj $i;
    saygr " ++++++++++++++";
    my $x =
        Rw Dis $z;
    Rw Disp $x;
    my $int = hitime() - $beg;
    say "Took $int";
    
    my $so = $i;
    my $one = 0.1;
    #$so = so.c.oo.C.theu.>$one;
    $so = J.sc.jo.zimb.sc.jo;
    ($so) = values %$so;
    $so = so.sc.jo->{"z mo $one"};
    $so = so.c.Co;
    $so = so.c.j.sc.oo.C.W;
    return $so;
    n Hows
Disp: |
    my $ind = ar.ind = ar.ind.'  ';
    for my $d (@$x) {
        my $x = [];
        #saybl wdump 3, $d;
        sayyl $ind . join ' ', grep { !ref$_ || do{push@$x,$_;0} } @$d;
        Rw Disp + $x:_ for @$x;
    }
Dis: |
    my $ja;$ja = sub {
        my ($d,$e) = @_;
        $e = $e.>d.t;
        my $etc;
        if (exists d.c.s) {
            my $m = '=';
            $m = "+" if d.c.m eq 'new';
            $m = "-" if d.c.m eq 'gone';
            (my $s = d.c.s) =~ s/\n/\\n/sg;
            $etc = $m . slim(13,$s);
        }
        my @l = "d.t$etc";
        if (my $z = d.sc.z) {
            push @l,'{';
            #my $tw = {map{$_=>1}keys %$e};
            my @lo = map {
                #delete $tw.>_.t;
                $ja->($_, $e)
            } @$z;
            #push @l, join',', sort keys %$tw;
            push @l, @lo;
            push @l, '}';
        }
        @l;
    };
    my @r;
    for my $r (@$z) {
        my @l;
        push @l, r.t, r.y.cv;
        my $ul = {map{!ref r.c.>$_ ? ($_ => r.c.>$_ ) : ()}keys %{r.c}};
        push @l, ki $ul if keys %$ul;
        
        if (my $o = r.c.o) {
            my $e = o.c.s || die "no ocs".ki$r;
            for my $d (@{r.c.dis}) {
                push @l, $ja->($d,$e);
            }
            if (my $z = r.c.z) {
                push @l, 
                    Rw Dis $z;
            }
        }
        !@l && sayre "Havenodis: ".ki $r;
        push @r, \@l;
    }
    \@r;
Duj: |
    my $oo = i.c.oo;
    my $cha = i.c.cha;
    my $ind = ar.ind = ar.ind.'  ';
    die 'ooC: '.ki $oo if 1 != keys %$oo;
    my $ty = oo.C;
    my $oty = $cha && cha.C && cha.C.gone;
    my $i;
    my $yt = {};
    for my $on (grep {defined} $ty, $oty) {
        G&Chew,$on,'t,cv',$_ for sub {
            my ($o,$t,$cv) = @_;
            $yt->{$cv}->{$t} = $o;
            $i++;
        };
    }
    my $la;
    my @z;
    G&Chew,$yt,\'cv,t',$_ for sub {
        my ($o,$cv,$t) = @_;
        my $l = o.y.l;
        my $E = l.c.s;
        my $e = o.c.s;
        my $cha = o.c.cha;
        my $r;
        r.t = $t;
        r.y.cv = $cv;
        r.c.o = $o;
        saybl wdump 3, $cha if r.t eq 'u';
        if ($cha) {
            if (cha.new && cha.new.t) {
                r.c.el = keys %{ $ty.>r.t } == 1 ? 2 : 1;
                sayyl "$ind    $t $cv";
            }
            elsif (cha.gone && cha.gone.t) {
                r.c.el = 9; # not here
                sayre "$ind -- $t $cv";
            }
            else {
                saygr "$ind != $t $cv:";
                r.c.el = 3; # or 4 if only z more
                # z holding notices things coming and going
                # z ealand elabourates on past from here
            }
        }
        else {
            saygr "$ind == $t $cv";
            r.c.el = 8;
            $la = $r;
            return
        }
        my $chi;
        my $co = r.sc.co ||= {};
        G&Chew,$cha,'m,nk,gk?',$_ for sub {
            my ($wa,$m,$nk,$gk) = @_;
            $chi++;
            my $xe = $cha.>$m.>$nk;
            my $oe = $E.>$nk;
            my $ne = $e.>$nk;
            $xe = $xe.>$gk if @_ == 4;
            $oe = $oe.>$gk if @_ == 4;
            $ne = $ne.>$gk if @_ == 4;
            say "$ind $m $nk $gk    ".slim($ne)."   <<-=    ".slim($oe);
            my $co = r.sc.co.co.>$nk ||= {};
            $co = co.co.>$gk ||= {} if @_ == 4;
            co.o = $oe;
            co.v = $ne;
            co.p = [$nk];
            co.m = $m;
            push @{co.p}, $gk if @_ == 4;
            if ($nk eq 'sc' && $gk eq 'z') {
                G&Chew,$xe,\'t,cv',$_ for sub {
                    my ($zb,$t,$cv) = @_;
                    if ($m eq 'gone') {
                        co.goneyt.>$cv.>$t = $zb;
                    }
                    else {
                        co.ytm.>$cv.>$t.>$m = $zb;
                        co.Ams.>_.c.sip = $_ for zb.y.A;
                    }
                }
            }
        };
        my $or;$or = sub {
            my $co = shift; # outside/index
            my ($he,$ta) = ([],[]);
            my $tw;
            # nk/gk ordering
            for ([$he=>qw't y c sc'],
                [$ta=>qw's z']) {
                my ($l,@l) = @$_;
                for my $t (@l) {
                    $co.>$t || next;
                    $tw.>$t ++;
                    push @$l, $t;
                }
            }
            my @mi = sort grep { !$tw.>$_ } keys %$co;
            my $z = [];
            for my $t (@$he,@mi,@$ta) {
                my $co = $co->{$t}; # inside/state
                my $j;
                j.t = $t;
                if (co.co && keys %{co.co}) {
                    die "More to mid co: ".wdump 3, $co if keys %$co > 1;
                    j.sc.z = $or->(co.co);
                }
                if (co.ytm) {
                    my @mu = values %{co.Ams};
                    @mu > 1 && die "Many A below r.t r.y.cv: ".ki co.Ams;
                    for my $i (@mu) {
                        r.c.z = Rw Duj + $i;
                    }
                }
                if (my $gt = co.goneyt) {
                    my @rm;
                    G&Chew,$gt,'cv,t',$_ for sub {
                        my ($d,$cv,$t) = @_;
                        my $r;
                        r.t = $t;
                        r.y.cv = $cv;
                        r.c.el = 9;
                        push @rm, $r
                    };
                    # breaks el=8/previous thing ness
                    unshift @{r.c.z||=[]}, @rm;
                }
                saybl " LEEVLVLEI ".wdump 3, r.c.z if co.goneyt;
                map { j.c.>$_ = $co.>$_ if exists $co.>$_ } qw'o m p';
                j.c.s = co.v if exists co.v;
                push @$z, $j;
            }
            $z;
        };
        # co.co.t.v = r.t;
        # co.co.y.co.cv.v = r.y.cv;
        r.c.dis = $or->(co.co);
        
        push @z, $la if $la ne $z[-1];
        push @z, $r;
        $la = $r;
        
        # eo
    };
    saybl "No changes" if !$i;
    
    \@z
pi/pud: |
    y.at.qs=1;
    y.at.ws=1;
    y.clos=1;
    #y.at.ml=J.A.d;
    c&dl = J.Jiter.C.c.dl || 5;
    c&dl += 9 if J.A.d < 20 && C.t eq 'sc';
    y.in = 0.2;
    my $ind = join'', ('  ') x (J.A.d - 1);
    n la=>''=>"\n$ind< C.t";
    if ($s eq J.Jiter.C.c.s) {
        n same=>2=>'same','%hs:855'
        return
    }
    if (ref $s ne 'HASH' || J.A.d > c&dl) {
        my $z = ki $s;
        $z = $s if C.t eq 't';
        n no=>2=>$z,'%fs:5,hs:394,lh:0.5,mt:1,mh:5,ab'
        return;
    }
    if (s.y eq $s && J.A.d > c&dl) {
        return
        n A=>2=>"A s.t s.y.cv; ".ki(s.c)."    ".ki(s.sc);
    }
    my @ks = sort keys %$s;
    n siz=>12=>" x ".@ks,'%hs:283,fs:6';
    if (J.mo.J.C.c.intl++ > 40) {
        return
        n 'more'=>''=>"more",'%hs:544';
    }
    return if C.t =~ /^(\d+|ii?|up|T)$/ || J.A.d > 5;
    m $_=>-pud=>{s=>$s->{$_}} for @ks;
    
a: | # act
    u allact
    n allact
    n 'allareact=1'=>42,<<''
        C.sc.act = 1 if !exists C.sc.act;
        C.sc.code = C.t if !exists C.sc.code;
i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
c: | # of something c.? acts
    n allc
s: | # of something sc.? acts
    n alls
    

