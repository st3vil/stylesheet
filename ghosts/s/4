PiMachine: | # all that is
    n Sequencing
    n ForJ
    n Jingle
    n Stuff
    n ThatWillBe
Sequencing: |
    n C
    n To
    n Day
    n Tube
ForJ: |
    n Tunnel
    n Jelly
    n With
Jingle: |
    n Compliers
    n Walks
    n Stashi
Stuff: |
    n Triangle
    n Circle
ThatWillBe: |
    n Tan
    n Tal
MakePi: | # make code,
    my $ii = {};
    
    my $dig = sub {
        my $tW = shift || return;
        $tW = {%{$tW}};
        $tW->{$_} = readlink "w/digway/$_" for keys %$tW;
        $tW;
    };
    
    my $main = 'PiMachine';
    my $see = G.way.>$main;
    my (@bit) = $see =~ /^n (\w+)$/sgm;
    
    my $s = {};
    for my $bit (@bit) {
         my $fd = "w/pimash/$main/$bit";
        my $ol = LoadFile($fd.'.g') if -f $fd.'.g';
        
        my $v = {};
        if (!$ol || ki($ol) ne ki($dig->($ol))) {
            sayre "$main $bit unstuck: \n".ki($ol)."\n ne\n".ki($dig->($ol)) if $ol;
            n $bit
            my $jt = G.oin.inJ;
            my $Day = $jt->{$bit};
            my $tW = {};
            my $su;$su = sub {
                my $J = shift;
                my $v = J.El.Pre.tv || die "J.name no tv";
                map { _.sc.J ? ($_,$su->(_.sc.J)) : $_ }
                grep { _.y.cv < 0.9 || do{$tW->{_.t} = $_; 0} } values %$v;
            };
            my $N = [$su->($Day)];
            for my $C (@$N) {
                Rw ym/conoi $noAI=1 $C $v;
            }
            DumpFile($fd.'.g',$dig->($tW));
            DumpFile($fd.'.v',$v);
        }
        else {
            $v = LoadFile($fd.'.v');
        }
        while (my ($k,$tv) = each %$v) {
            while (my ($t,$cvs) = each %$tv) {
                while (my ($cv,$C) = each %$cvs) {
                    $s.>$k.>$t.>$cv = $C;
                }
            }
        }
    }
    
    my $v = $s;
    for my $of (keys %$v) {
        my $o = $ii->{$of} = {t=>$of,y=>{cv=>0.001},c=>{W=>'of'}};
        my $c = $v->{$of};
        my $la = $o;
        for my $cv (sort keys %$c) {
            my $ts = $c->{$cv};
            for my $t (sort keys %$ts) {
                my $z = $ts->{$t};
                Rw CoBabbler $C:z;
                my $y = eval z.c.s;
                die "Throcompile $of z.y.cv: z.t:"
                    .ind('  ',$@)."\n\n z.c.s\n" if $@;
                die "Not code: z.t z.y.cv: $@\n".ki $z if ref $y ne 'CODE' && !z.sc.subpeel;
                z.c.code = $y;
                if ($la eq $o) {
                    la.y.in = $z;
                }
                else {
                    la.y.next = $z;
                    z.y.prev = $la;
                }
                $la = $z;
            }
        }
    }
    
    my $i = {};
    my $n = ii.i;
    while ($n) {
        if (n.c.code) {
            $i->{n.t} = n.c.code;
            ii.i.y.tw->{n.t} = $n;
        }
        $n = n.y.in || n.y.next;
    }
    
    ($i,$ii)
CoBabbler: | # bake code
    my $sw = {};
    $sw.>$_ = 'say' for qw'saygr saybl sayyl sayre say';
    %$sw = () if C.sc.nobasay;
    for (keys %$sw) {
        my $if = $_ ne 'sayre' ? "A\.V && " : "";
        C.c.s =~ s/^(\s*)$_ ([^\n]+?)((?: (?:for|if) .+)?;?)$/${1}${if}G\.h->(\$A,\$C,\$G,\$T,'$sw->{$_}','$_',$2)$3/sgm;
    }
    
    C.c.s =~ s/\bs\&(\w+)/C\&$1/sgm;
    C.c.s =~ s/\bA\&(\w+)/A\.c\.$1/sgm;
    C.c.s =~ s/\ba\&(\w+)/A\.sc\.$1/sgm;
    
    C.c.s = G&parse_babbl,C.c.s;
    
    # change J.n 
    C.c.s =~ s{\$J->\{([unm])\}->\((\$A,\$C,\$G,\$T?)(, ?\$M)?}
        {\$G->\{h\}->($2,"$1"$3}sgm;
Zome: | # return a new J
    my ($i,$ii) = Rw MakePi;
    
    my $B = $A;
    my $A = {};
    A.sc.i = A.i = $i;
    A.sc.ii = A.ii = $ii;
    my $G = A.i.G->($A,$C,$G,$T);
    A.i.>$_ = B.I.>$_ for qw'parse_babbl';
    
    $A = G&A,'so';
    my $J = G&J,$A,'os';
    $A.>$_ = $A for 2,3,4;
    
    # A.* will inherit, A.sc.* is ours (usually)
    A.sc.ii = A.ii;
    A.sc.i = A.i;
    
    my $z = [sort {a.y.cv <=> b.y.cv || a.t cmp b.t}values%{A.ii}];
    my $u = G&Ct,[theu=>1=>'steve',{z=>$z}];
    A.ii.>u.t = $u;
    u.y.tw->{_.t} = $_ for @$z;
    
    $J
P: |
    u urw
    u UpPg
    n Zupe=>-run
pi/run: |
    symb: %hs:394,fs:12
        R
    n jeio=>2=>C.t=>'%dos:runs'
runs: |
    my $i = e&hC ->[-1];
    saybl ki $_ for @{ e&hC };
    G&zen,Com=>[dollarsworth=>''=>"Blagna",{pi=>'dae'}];
Com: |
    u urw
    u UpPg
    y.at.anch = "Noteal";
    ($A)=
    stuff:
        is
    say "Yer $$";
    G&liz,Com=>$_ for sub {
        my ($k,$s) = @_;
        saygr "Yer $$";
        #Rw waitme re;
        fork() ||
        Rw comput $s;
    };
comput: |
    say "Yer $$";
    sayyl "Yup: ".wdump 3, $s;
    exec 'perl got Zupe 4 b';
    die "BVack:";
    exit;
    
Zupe: | # run Zome, output pud
    u urw
    y.clos = 1;
    
    my $so = Rw Tesh ElvisLeaves;
    
    m wk=>-pud=>{s=>$so},'%hs:375,ws,wi:30%'
    
Zop: |
    u urw
    y.clos = 1;
    n sno=>0.04=>'snows'
    my $so = J.output ||= Rw Tesh ElvisWorld ee;
    
    m wk=>-pud=>{s=>$so},'%hs:375,ws,wi:30%'
    
    
Hows: |
    J.sc.u.c.o = 'oscd';
    # STEVEWAS
    take: %acgt:s o
        robino
    leave: %some:other,ma:ni,fo:la,t:e
        traces
    n skinny=>4=>{}
Tesh: | # wrap test way
    my ($t,$sel) = @$m;
    my $tes = sub {
        my $C = G&tC,\@_;
        c&test ||= do {
            C&l = C.t;
            C.t = $t;
            J.testRun;
        };
        c&tac = 1 if J.tacall;
        n $C
    };
    
    #die "Just $sel" if $sel;
    
    J.R ||= Rw Zome;
    
    my $beg = hitime();
    my $e;
    if (!J.begins || J.testsRun > J.lasttestsrun) {
        J.begins ||= $beg;
        J.lasttestsrun = J.testsRun;
        J.testUntil = J.testRun + 1;
        my $n = $sel ? 0 :
            Rw Dwive;
        my $oJ = J.R;
        $e =
        Rw $t + $tes $n $oJ:J $J:oJ $A:oJ.1 $G:oJ.y.G;
        delete J.tacall;
        $sel ||
        ok(1, "Took J.testRun ".G&ron,hitime()-$beg );
    }
    else {
        $sel ||
        ok(1, "Total ".G&ron,hitime()-J.begins );
    }
    $e
ElvisWorld: | # J makes, puts W
    return if $n;
    #A.V = 1;
    J.sc.u.c.o = 'oscd';
    
    my $e = A.ii.theu;
    my $ot = "this";
    my $o;
    
    c&mks = sub {
        my $C = shift;
        $o = G&A,o=>6=>$J=>$e,$ot;
        
        #A.V = 1 if $n == 10;
        
        my $l = o.c.rsl || die "no rsl";
        
        (A.V || A.Ve) &&
        saybl "the Dujis: ".$_ for @$l;
        $l
    };
    
    my $j =
    n Hows
    ($j) = values %{j.c.tug};
    $j = j.c.s;
    $j = j.sc.J;
    $j = j.sc.s;
    $j = j.c.zip;
    $j = j.c.rs;
    #$j = $j->[1]; # leave
    #$j = j.c.dis->[0];
    #$j = j.sc.z->[0]; # of c
    #$j = j.sc.jo.zipover;
    #$j = j.sc.oo;
    sayyl "Done!";
    #say wdump 4, $oJ;
    #exit;
    #$tes->("Selecto");
    #sayyl wdump 2,$j;
    return $j;
    return $e;
    #J.sc.
    
ElvisLeaves: |
    #A.V = 1;
    #exit if $n > 3;
    my $tf = 't/Zupe/ElvisLeaves/theu';
    DumpFile($tf, A.ii.theu) unless -f $tf;
    my $e = LoadFile($tf);
    my $e = A.ii.theu;
    my $o;
    my $ot = 'zimb';
    
    my $lshot = sub {
        my ($C,$l) = @_;
        my $m = c&lshot;
        return unless @$l > $m;
        @$l = (@{$l}[0..$m]);# "... snip x".(@$l-$m));
    };
    c&mks = sub {
        my $C = shift;
        $o = G&A,o=>6=>$J=>$e,$ot;
        
        #A.V = 1 if $n == 10;
        
        my $l = o.c.rsl;
        #  c&tac = 1;
        
        c&lshot && $lshot ->($C,$l);
        (A.V || A.Ve) &&
        saybl "the Dujis: ".$_ for @$l;
        $l
    };
    
    if ($n==0) { #c
        $tes->('whole u','',{lshot=>32});
    }
    elsif ($n==1) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Here';
        $m = e.sc.z->[3];
        $m = m.y.in;
        $m = m.y.next || $m for 1..3;
        m.sc.epl = "Dop";
        m.c.s = "ACGT {} !";
        e.sc.eo = 'popup';

        $m = e.sc.z->[5];
        $m = m.y.in;
        $m = m.y.next || $m for 1..2;
        
        my $pr = m.y.prev;
        G&apart,next=>$pr;
        pr.sc.herre = 'OOOO';

        pop @{e.sc.z};
        
        $tes->('u messed with');
    }
    elsif ($n==2) {
        my $m = e.sc.z->[4];
        m.sc.was = 'Hur';
        $m = e.sc.z->[1];
        $m = m.y.in;
        G&apart,next=>$m for 1..3;
        G&toget,next=>m.y.next.y.next,$_ for G&Ct,[available=>6=>'makeether','%eo:fil'];
        $tes->('couple more');
    }
    elsif ($n >= 3 && $n <= 4) {
        $ot = 'dwell';
        my $la = G&Ct,[row=>6=>is=>'%hs:588'];
        my $te = G&Ct,[seen=>8=>is=>'%hs:588'];
        $e = [
            G&Ct,[row=>1=>is=>'%hs:588'] ,
            G&Ct,[reow=>1=>is=>'%hs:588'] ,
            G&Ct,[rodw=>5=>is=>'%hs:588'] ,
            $la, $te
        ];
        $e = G&Ct,[wo=>2=>{}=>{z=>$e}];
        
        if ($n == 3) {
            $tes->('el=1 when dup t');
        }
        else {
            la.t = 'som';
            te.sc.hs = 359;
            te.sc.know = 'ing';
            $tes->('mount');
        }
    }
    elsif ($n >= 5 && $n <= 8) {
        my $mo = e.sc.z->[1];
        my $om = G&Ct,[J=>4=>'codedpassage'=>'%acgt:3'];
        my $z = [
            $om,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        my $lom = G&Ct,[mo=>0.001=>{W=>'of'},{z=>$z}];
        my @io = (
            G&A,o=>2=>$J=>$mo,'Themo' ,
            $n < 7 && G&A,o=>2=>$J=>$lom,'Extra'
        );
        $e = {map{_.c.sip => $_ }grep{$_}@io};
        $ot = 'zip';
        
        if ($n == 5) {
            # c&mks ->();
            $tes->('W over without innards');
        }
        elsif ($n == 6) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over change some');
        }
        elsif ($n == 7) {
            mo.y.in.sc.casa = "case $n";
            $tes->('W over, chang, Extra gone');
        }
        elsif ($n == 8) {
            om.sc.oh = "yeah $n";
            mo.y.in.sc.no = "case $n";
            $tes->('W over, more change');
        }
    }
    elsif ($n == 9) { #c
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[snapsof=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[squara=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see two');
    }
    elsif ($n == 10) {
        $ot = 'thanks';
        my $z = [
            G&Ct,[movie=>3=>'mae'=>{acgt=>3}] ,
        ];
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>{acgt=>3,z=>$z}] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see one go, one come');
    }
    elsif ($n == 11) {
        $ot = 'thanks';
        $e = [
            G&Ct,[innert=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[moving=>6=>'codedpassage'=>'%acgt:3'] ,
            G&Ct,[gonk=>7=>'codedpassage'=>'%acgt:3'] ,
        ];
        $tes->('see z disappear');
    }
    my $so = $o;
    my $one = 0.001;
    #$so = so.c.oo.C.theu.>$one;
    $so = J.sc.jo.zip.sc.oo.C.mo.>$one; # from oJ, the zip's mo 0.001
    return {p=>33};
    $so = so.sc.jo->{"z mo $one"};
    $so = so.c.Co; # the C currently othering under the recursionship of j
    $so = so.c.j.sc.oo.C.W; # through to the j again, all C it can see named W






pi/pud: |
    y.at.qs=1;
    y.at.ws=1;
    y.clos=1;
    A.3 = J.mo.J; # the W planted in A.4
    A.2 = J.Jiter; # the last J
    #y.at.ml=J.A.d;
    c&depth = J.A.d;
    # how many M inners before 'more' (depth first)
    A.3.C.c.intlim ||= 19;
    # max depth before like nothash
    c&dl = A.2.C.c.dl || 3;
    # travel boosts/cons depth
    c&dl += 3 if c&depth < 20 && C.t eq 'sc';
    y.in = 0.21;
    my $ind = join'', ('  ') x (J.A.d - 1);
    
    n ind=>0.07=>"\n$ind"
    n sli=>0.08=>"<  ",'%hs:784'
    n title=>1=>"C.t"
    
    c&block = 'same' if $s eq A.2.C.c.s;
    c&block = 'G' if C.t eq 'G' && ref s.w;
    if (ref $s eq 'HASH') {
        if (s.y eq $s && A.2.C.t eq 'y') {
            c&block= 'yA';
            c&blos = "s.t @ s.cv";
            c&blos .= " (s.c.s.t)" if ref s.c.s eq 'HASH';
        }
    }
    
    if (c&block) {
        n block=>2=>c&block,'%hs:855'
        c&blos &&
        n blocked=>21=>c&blos,'%hs:827'
        return
    }
    
    my ($ks,$vs);
    if (ref $s eq 'ARRAY') {
        n is=>11=>'[','%hs:457'
        C.sc.type = 'array';
        $vs = [@$s];
        $ks = [0..(@$s-1)];
    }
    else {
        if (ref $s ne 'HASH' || J.A.d > c&dl) {
            my $z = ki $s;
            my $bg;
            if (!ref $s) {
                $z =~ s/^!%://;
                $bg = ',bg:653';
                if (!defined $s) {
                    n know=>18=>'undef','%hs:845,fs:6'
                }
                elsif (!length $s) {
                    n know=>18=>"''",'%hs:845,fs:6'
                }
            }
            $z = $s if C.t eq 't';
            my $fs = 6;
            $fs = 8 if !ref $s;
            $fs = 13 if C.t eq 't';
            
            n no=>2=>$z,"%fs:$fs,hs:398,lh:0.5,mt:1,mh:5$bg"
            return
        }
        if (s.y eq $s && J.A.d > c&dl) {
            return
            n A=>2=>"A s.t s.y.cv; ".ki(s.c)."    ".ki(s.sc);
        }
        if (defined s.t && s.y && (s.c || s.sc)) {
            C.sc.istycsc = 1;
        }
    }
    # order children
    # use Walks/hord
    my ($he,$ta);
    if (C.sc.istycsc) {
        $he->{$_} = 1 for qw't y';
        $ta->{$_} = 1 for qw'c sc';
    }
    my (@he,@ta);
    my @ks = grep { !($he->{$_} && push(@he,$_) || $ta->{$_} && push(@ta,$_)) }
        $ks ? @$ks : sort keys %$s;
    @ks = (@he,@ks) if @he;
    @ks = (@ks,@ta) if @ta;
    
    n siz=>12=>" x ".@ks,'%hs:283,fs:6';
    if (A.3.C.c.intl++ > A.3.C.c.intlim) {
        if (ref $s eq 'HASH') {
            if (defined s.t) {
                n peak=>3=>"s.t",'%hs:398,fs:11'
            }
        }
        return
        n more=>4=>"more",'%hs:544'
    }
    return if C.t =~ /^(ii?|up|T)$/
        || ( A.2.C.sc.type ne 'array' && C.t =~ /^\d+$/)
        #|| J.A.d > 5
        ;
    C.sc.css = 'border-left:3px solid 473' if @ks > 3;
    m $_=>-pud=>{s=>$vs ? shift @$vs : $s->{$_}},'%ma:1' for @ks;
    
a: | # act
    u allact
    n allact
    n 'allareact=1'=>42,<<''
        C.sc.act = 1 if !exists C.sc.act;
        C.sc.code = C.t if !exists C.sc.code;
i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
c: | # of something c.? acts
    n allc
s: | # of something sc.? acts
    n alls
    

