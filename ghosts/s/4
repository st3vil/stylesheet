PiMachine: |
    n Day
    n Tube
    
    n Tunnel
    n Jelly
    
    n Triangle
    n Walks
Zupe: |
    u urw
    my $ii = {};
    my $dig = sub {
        my $tW = shift;
        $tW = {%{$tW}};
        $tW->{$_} = readlink "w/digway/$_" for keys %$tW;
        $tW;
    };
    my $ol = LoadFile('w/glacwal');
    if (ki($ol) ne ki($dig->($ol))) {
    sayre "Zupe unstuck: \n".ki($ol)."\n ne\n".ki($dig->($ol));
    my $it = 'Day';
    $it = 'PiMachine';
    n $it
    my $jt = G.oin.inJ;
    my $Day = $jt->{$it};
    my $tW = {};
    my $su;$su = sub {
        my $J = shift;
        my $v = J.El.Pre.tv || die "J.name no tv";
        map { _.sc.J ? ($_,$su->(_.sc.J)) : $_ }
        grep { _.y.cv < 0.9 || do{$tW->{_.t} = $_; 0} } values %$v;
    };
    my $N = [$su->($Day)];
    my $v = {}; # of/cv/t acum
    my $M = [map {
        Rw ym/conoi $noAI=1 $C:_ $v;
    } @$N];
    DumpFile('w/glacwal',$dig->($tW));
    DumpFile('w/glacval',$v);
    }
    
    my $v = LoadFile('w/glacval');
    for my $of (keys %$v) {
        my $o = $ii->{$of} = {t=>'of',y=>{cv=>0.1},c=>{W=>'of'}};
        my $c = $v->{$of};
        my $la = $o;
        for my $cv (sort keys %$c) {
            my $ts = $c->{$cv};
            for my $t (sort keys %$ts) {
                my $z = $ts->{$t};
                sayre "Compile $of $cv $t !";
                Rw TheBabbler $C:z;
                my $y = eval z.c.s;
                die "Throcompile of.t z.y.cv: z.t: "
                    .ind('  ',$@)."\n" if $@;
                z.c.code = $y;
                   la.y.next = $z;
                z.y.prev = $la;
                $la = $z;
            }
        }
    }
    
    my $i = {};
    my $n = ii.i;
    while ($n) {
        if (n.c.code) {
            $i->{n.t} = n.c.code;
            ii.i.y.tw->{n.t} = $n;
        }
        $n = n.y.next;
    }
    
    
    my $so = Rw Zome $i $ii;
    
    #n wk=>-pre=>wdump(6, $so),'%hs:375'
    n wk=>-pud=>{s=>$so},'%hs:375,ws,wi:30%'
    
    
CoBabbler: |
    C.c.s =~ s/\bs\&(\w+)/C\&$1/sgm;
    C.c.s = G&parse_babbl,C.c.s;
Hows: |
    take:
        robino
    leave:
        traces
Zome: |
    my $B = $A;
    my $A = {};
    A.i = $i;
    A.ii = $ii;
    my $G = A.i.G->($A,$C,$G,$T);
    A.i.parse_babbl = B.I.parse_babbl;
    $A = G&A,'so';
    my $J = G&J,'os';
    A.4 = A.3 = A.2 = $A;
    n Hows
pi/pud: |
    y.at.qs=1;
    y.at.ws=1;
    #y.at.ml=J.A.d;
    y.in = 0.2;
    my $ind = join'', ('  ') x (J.A.d - 1);
    n la=>''=>"\n$ind< C.t";
    if ($s eq J.Jiter.C.c.s) {
        n same=>2=>'same','%hs:855'
        return
    }
    if (ref $s ne 'HASH' || J.A.d > 5) {
        my $z = wdump(2, $s);
        $z = $s if C.t eq 't';
        n no=>2=>$z,'%fs:5,hs:394,lh:0.8,mt:1'
        return;
    }
    if (s.y eq $s && J.A.d > 3) {
        return
        n A=>2=>"A s.t s.y.cv; ".ki(s.c)."    ".ki(s.sc);
    }
    my @ks = sort keys %$s;
    n siz=>12=>" x ".@ks,'%hs:283,fs:6';
    if (J.mo.J.C.c.intl++ > 40) {
        return
        n 'more'=>''=>"more",'%hs:544';
    }
    return if C.t =~ /^(\d+|ii?|up)$/ || J.A.d > 5;
    m $_=>-pud=>{s=>$s->{$_}} for @ks;
    
a: | # act
    u allact
    n allact
    n 'allareact=1'=>42,<<''
        C.sc.act = 1 if !exists C.sc.act;
        C.sc.code = C.t if !exists C.sc.code;
i: | # ACGTs sub for h/A.i
    n allacgts
O: | # s&OSCillators
    n allsvse
c: | # of something c.? acts
    n allc
s: | # of something sc.? acts
    n alls
    

