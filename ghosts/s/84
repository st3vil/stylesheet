ElvisMutato: | # change normal/theu (every u's base)
    my $t = Rw Towering Ang _ EyvisMutante
        || return;
    Rw HasWay;
    return unless c&Se == 1;
    #G.mkoJ->(); # frees us from test exit
    
    # use this to:
    # see sc.ii or .y.s.sc.ii in o whole/base maneuvre
    # particularly whole will not work without it
    # and fall back to copying A.4.ii in n 2
    # when u.sc.ii in turn doesn't appear
    
    t.e = 
    n ElvisEmpty
    my $el = t.lookii->();
    t.cs->({rsl=>$el}, "ElvisEmpty has no ii");
    my $j = t.ntos->('J');
    my $yl = t.anii->(j.ii);
    t.toc.slimvague = 200;
    t.cs->({rsl=>$yl,grepl=>'/lying whee/'},
                            "Empty ii not with Mutante");
    t.cs->({rsl=>$yl,grepl=>'/ xo /'},
                             "Empty ii matches some xo");
    ok 0+@$yl > 140 && 0+@$yl < 200, "Empty ii yay many";
    
    
    t.e =
    n ElvisMutante
    my $top = T.op;
    is top.t, 'ElvisMutante',
                          "Mutante top.t = ElvisMutante";
    is top.sc.ii, undef, "No topscii";
    is ref top.y.s, 'HASH', "topys";
    is top.y.s.t, 's', "topys is s";
    is top.y.s.sc.top, $top, "topyssctop is top again";
    
    
    t.toc.slim = 100;
    t.cs->('sc top y tw O,nonext,grepl:/lying whee/',
        "Mutante top ytw O match");
    my $el = t.lookii->();
    t.cs->({rsl=>$el,grepl=>'/lying whee/'},
                                   "Mutante ii O match");
    is 0+@$el, 2+@$yl, "Mutante ii two more";
    
    t.e =
    n ElvisMuClos=>W=>{whole=>T.op}
    my $sl = t.lookii->();
    t.cs->({rsl=>$el,grepl=>'/lying whee/'},
                                    "MuClos ii O match");
    is 0+@$sl, 0+@$el, "MuClos ii count same as Mutante";
    
    t.e =
    n ExvisMutante
    t.cs->('sc top', "ExvisMutante");
    
    t.e =
    n Normal=>V
    t.cs->('sc lv,olv,grepl:/Oiviate/', "Normal");

    t.e =
    n ElvisMutated
    t.cs->('sc lv,olv', "ElvisMutated"); 
    t.xo->("Mutated with T dogon");
    
    # should have T tracked somewhere ^
    
ElvisMuClos: |
    Jc&whole = c&whole || die "Givewhole";
    
ElvisMutante: |
    Jc&base = 'normal';
    n ExvisMutante
ExvisMutante: |
    u alact
    Oxviuta 6: %of:O
        0 && sayyl "Flying wheels: C.t";
        push @{3s&anyO||=[]}, $C;
    u alacgts
    videola:
        $s .= "Lapl";
        $s .= 3 + 5;
    
EyvisMutante: |
    u alact
    Oivilate 6: %of:O
        push @{3s&Orious||=[]}, $C if C.t =~ /^[A-Z]/;
ElvisMutated: |
    so:
        soME
    u ExvisMutante
    T dogon
    n too=>2=> G&videola,'s'  
ElvisDaury: |
    u Zpace

    m $_=>-daury for 1..6;
pi/daury: |
    s&fs = 31; # y
    if ($s % 2) {
        T odd
        s&fs = 41
    }
    s&time = join' ',('~@~') x ++ Jc&bowls;
    
ElvisDesi: | # decide what to do after Waytch
    # may be about starting plans for the other to 
    my $t = Rw Towering Ang _ Sleepin
        || return;
    Rw HasWay;
    return unless c&Se == 1;
    G.mkoJ->(); # frees us from test exit
    
    my $dow;
    $dow.>$_ = _.c.s for map { G&wup,$_ } qw'ElvisDaury pi/daury';
    
    my $had;
    my $ha = &{
        my @r;
        while (my ($pin,$s) = each %$dow) {
            push @r, [$pin=>'',
                {s=>$s},
                {file=>'g/s/84',pi=>'Gup',dig=>slm 9,dig $s}
            ]
                if $had.>$pin ne $s;
            $had.>$pin = $s;
        }
        @r
    };
    $ha->();
    # put our way updates through this instead of the filesystem
    # WayHeave must come after hosted way (to Towering before _)
    my $hadow = &{
        G&elph,Waytch=>$_ for $ha->()
    };
    
    t.e =
    n Waytch=>W=>{filter=>qr{/s/84$}}
    t.cs->('sc lv,olv', "Waytch holding on to Mez");
    
    t.e =
    n ElvisDaury
    t.cs->('sc top', "complete with ElvisDaury");
    
     5s&desi = "Ghoster";
    
    # for 5 to resolve its intentions
     
    # see that T becomes known in the way by line/name
    # way change in the indent that T is on especially for those who hit that T
    
    
    $dow =~ s/fs = 41/fs = 34/;
    $hadow->();
    # sends way notify ^ which re-ElMatrons and Ghosters before returning
    #exit;
    return;
    
    t.cs->('sc top', "only odd numbers update");
    
    $dow =~ s/time = /inflation = '(3..'/;
    $hadow->();
    
    t.cs->('sc top', "everything updates");
    
Sleep: | # desire and not
    u i
    
    # sleep/engage mind
    # want to substrata bits of the ground,
    # or headers from bodies of work, making sleep if same
    # $s:
    #    names sleep/wake features to have
    #    names/numbers groups of time/etc in the pin
    #      eg test frames
    S:
        if ($s eq 'no') { # backwards for once
            if (1c&want.once) { # got in somehow
                G&unrea,A.1;
                T.nose = 7; # still, osc
                return 0 # || returns from pin
            }
            else {
                1c&want.once = -7;
            }
        }
        G&A,n=>2,A.1,[];
        $A = A.mo;
        local A.V = 0;
        G&tug,0.6; # eg E can pos=1 awake
         
        1 unless "can" eq "sleep";
        
    # marks a point for ghost chopchoping, see ElvisDesi
    # also # 38 makes a numerical
    # know line in the way it came from
    # to disambiguate unnamed T points, which just say 'here'
    T:
        G&S; # no s, just engage mind
        (my $label = 'T_'.$s) =~ s/\W+/_/sgm;
        my $line = G&find_caller_line_labelled,$label;
        my $w = T.w || die "T no w: ".ki $T;
        if (my $te = A.mo && A.mo.c.T) {
            # care for finding for way name > T name
            te.has.Tin.>w.t.>$s.>$line ++;
        }
        else {
            warn "T $s outerspace: ".G&sn
        }
        1;
    
    # could also look back for most h/w/throat/J6 call... somehow
    # c/64 Bun uses confess to find printed list of args
    # which we can lookup refs for A,
    # which could overload to print its t/ip
    find_caller_line_labelled:
        my @h;
        my $line; # to disambiguate unnamed T points
        for (0..7) {
            my $l;
            my @q = qw'package filename line subroutine hasargs
            wantarray evaltext is_require hints bitmask hinthash';
            my @ca = caller($_);
            $l.>$_ = shift @ca for @q;
            @q = qw'hinthash line subroutine';
            $l = {map{$_=>$l.>$_ }@q};
            push @h, $l;
            if (my $hh = l.hinthash) {
                if ($hh->{':'} eq $s) {
                    $line = l.line;
                    last;
                }
            }
        }
        $line || sayre "Cannot find $s above: ".ddump \@h;
        $line
        
    
    u c
    n \'of:mo'
    # are we in or out
    J 45:
        my $de;
        de.mo = A&want if A&want;
        de.C = c&want if c&want;
        de.J = 1c&want if 1c&want;
        $de || return;
        local A.V = 2;
        my $des = "C.t C.y.cv ".G&sn,5 ." -> ".ki $de;
        
        # mo.pins.$pin = $d must also mo.pin = $d
        my $eq = sum grep {!ref} map{ values %$_ } values %$de;
        # want to add counterpoints
        # everything eventually sleeps way/u/W stuff
        
        if ($eq < 0) {
            saybl "Sleep $eq   $des";
            my $to = $eq < -6 ? '8' : '7';
            T.Z.>$to = $A;
        }
        else {
            saygr "Waker $eq   $des";
        }
        
        
Sleepin: | # ways in to knowing which dream is where
    u alc
    # classify wave, particle knowing in ElvisMatu
    Sleap 31: %of:mo,v:cW
        my $t = 1s&typed ||= {};
        my $k = c&e ? 'e' : 'W';
        $t.>$k.>A.2 = A.2;
        #$t = ki $t;
        #1 && saybl sprintf "        The: %-20s %-30s", G&sn,3 , $t
Ghoster: |
    # remotely four about all Jtv, u/ning sorting update paths, doing
    sayyl "Got here! ".ki $C;
    
    Rw ElvisMatu;
ElvisMatu: | # T room on Os
    saygr "Upon: ".G&sn;
    # puddle display
    my $fo = A.4;
    my $ts;
    my $tt;
    # for all that is
    my $Jtv = fo.sc.Jtv;
    my $nine = 0.9;
    $Jtv.>fo.t.>$nine = $fo;
    
    G&chew,fo.sc.Jtv,'t,cv',$_ for sub {
        my ($J,$t,$cv) = @_;
        $tt.>$t && die "Already had $t: ".ki($J)."\nunt: ".ki($tt.>$t);
        $ts.>$J = $tt.>$t = G&Ct,[$t,$cv,{},{J=>$J}];
    };
    
    # make A.2 hierarchy
    # should all be A.4
    for my $k (sort keys %$tt) {
        my $C = $tt.>$k;
        my $upJ = s&J.2;
        C.c.>$_ = s&J.>$_ ->{t} for 1..5;
        if (my $upC = $ts.>$upJ) {
            next if $upC eq $C;
            delete $tt.>C.t;
            push @{upC.sc.z||=[]}, $C;
        }
    }
    
    my @t = values %$tt;
    @t > 1 && sayre "Many tops: ".ki \@t;
    
    
    
    
    
    #c that makes T into tests with extremities
    # things recognised out from ...
    my @al = map {
        my $ub = &C{
            my $J = s&J;
            c&s = "C.t".(!J.c.o &&"   ,");
            if (my $xo = Js&xo) {
                my $un;
                while (my ($k,$v) = each %$xo) {
                    if ($k eq 'way') {
                        s&way = {%{s&way||{}}, %$v};
                    }
                    else {
                        $un.>$k = $v;
                    }
                }
                s&xo = $un if $un;
            }
            if (my $t = Js&typed) {
                my $un;
                while (my ($k,$v) = each %$t) {
                    my $to;
                    $to = 'jointed' if $k eq 'W';
                    $to = 'elvised' if $k eq 'e';
                    if (!$to) {
                        $un.>$k = $v;
                        next;
                    }
                    while (my ($ref,$R) = each %$v) {
                        # is means its doing that for its 2
                        my $is = Rc&is || '';
                        my $oJ = R.2 if $is;
                        my $t = $oJ && oJ.t || R.t;
                        
                        my $c = s&mix.>$to.>$is.>$t ||= {};
                        
                        c.J && c.J ne $R && die "Ne R.t:".ki(c.J)
                            ."\n   ".ki($R);
                        c.oJ = $oJ if $oJ;
                        c.i++;
                    }
                }
                s&typed = $un if $un;
            }
            # string
            if (my $w = s&way) {
                s&way = join ',',sort keys %$w;
            }
            if (my $mix = s&mix) {
                my @l;
                G&chew,$mix,\'to,is,t',$_ for &c,to,is,t{
                    
                };
            }
            $C
        };
        G&ind,$_,$ub;
    } @t;
    my $s = join "\n", map { 
        sprintf "%-20s %-30s", _c&inds . _c&s , _s&xo
    } @al;
    
    if (A.1.t ne "ElvisMatu") {
        1 && saybl "Soup of fo.t:\n$s";
        return;
    }
    
    n so=>1=>G&sn 
    n woov=>2=>"\nZouper: fo.t\n$s";
Towering: | # os->Os for test frames
    if (A.4.t ne 'os') {
        # are in the ElvisLower n c&est in Os
        T.ray = 2 if c&TC && c&TC.c.ray;
        return ar.t || die "4 no art";
    }
    my $t = Rw Telvis;
    # ElMatron hosts w since we began
    # and our idea of normal (theu)
    my $incs = {};
    my $inct = 'five';
    if (ar.m && !(ar.ar && ar.ar.m eq ar.m)) {
        # u things mixing into theu (normal) TODO
        /^_$/ ? $inct = 'normal'
            : push @{ $incs.>$inct ||=[] }, $_
        for @{ar.m}
    }
    my $oJtv;
    A.c.fivey ||= do {
        local 4s&Jtv = $oJtv = {};
        my $c = {};
        c.inc = $incs if keys %$incs;
        my $ma =
        n ElMatron=>W=>$c
        J.5 = A.5 = t.ntos->($ma,'J');
    };
    defined ar.n || die "4 making no arn";
    my $c = {t=>$t, main=>'ElvisLower', estC=>c&estC, est=>C.t, estn=>1+ar.n};
    c.oJtv = $oJtv if $oJtv;
    c.inc = incs.fo if incs.fo;
    n Os=>W=>$c
    return
ElvisLower: | # Os's main as tests like to dispatch
    sayyl "forez room: ".G&sn;
    
    my $c;
    c&est || die "Give test name ".G&sn;
    c.Se = c&estn if c&estn;
    c.ar.t = $t;
    c.TC = c&estC if c&estC;
    
    n c&est=>W=>$c
    
    return unless c.mat;

    t.e =
    n ElvisMatu
    my $W = t.ntos->(t.e,'J');

    t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s});
ElMatron: | # our 5, has normal + net decising
    Js&theu = A.4.ii.theu;
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        Jc&inc.add.>$W ++;
    };
    T.H = 8; # thawable
    local A.4.t = 'Os'; # want namespace
    
    Jc&inc = c&inc if c&inc; # reset
    my $i = Jc&inc;
    u ReU=>W=>{plus=>i.normal}
    
    Jc&bowls ++ &&
    sayyl "ElM the: ".ki $i;
    
    u $_ for sort keys %{i.add||{}};
    
    T.H = 3; # thaw/store
    u ElvisWayliases
    u $_ for @{i.five||[]};
    u Ang
    
    S
    # plan to continue process
    Js&desi && 
        Rw Js&desi;
ElvisWayliases: | # dialect patchbay
    # translate g/c stylehouse dialectics to g/s (a/allact (Mo) -> alact (mo))
    # to build PiMachine on Os
    n c=>''=>G.way.alc,'%of:w';
    n s=>''=>G.way.als,'%of:w';
    n a=>''=>G.way.alact,'%of:w';
    n i=>''=>G.way.alacgts,'%of:w';
ElvisSoftu: | # T Ghost maint for common u things, dialects جستجو
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    
    # add many S pages
    if (c&Se == 1) {
        u Softu=>''=><<'','%of:w'
            T.H = 2; # stores
            n aly
            n alc
            n als
            n alact
            n alacgts
        t.e =
        n Softu
        t.en->('sc lastK c s', 'caches u');
    }
ReU: | # posit our 4.ii as normal (theu), share as W
    # host
    my $u = Js&normal ||= Js&theu ||= A.4.ii.theu;
    if (c&plus) {
        n Normal=>W=>{base=>$u,plus=>c&plus};
        $u = T.op;
    }
    n theu=>1=>{s=>$u},'%of:W'
    n normal=>1=>{s=>$u},'%of:W'
Normal: | # u receives adjustments to anything
    # as lv shipped off the top of the ghost mountain it is
    # would be imparted with 4/5 to start process
    # and then just continue itself as downstream from its true self
    # which is joining ghost change to it by travelling update paths
    # and sending it lv diffs
    
    # until base and its growth is not implanted by g/c and WayHeave:
    Jc&base = c&base if c&base;
    n $_ for @{c&plus};
    
Os: | # our 4
    G&mk4,$A;
    A.5.2 = A.5.4 = A.1;
    A.5.5 = A.5;
    # 4 includes Js created in ElMatron before 4
    if (my $Jtv = c&oJtv) {
        my @oJ = map{values %$_} values %$Jtv;
        sayyl "Boot C.t: ".join', ',sort map {_.t} @oJ;
        1s&Jtv.>_.t.>A&Jcv ||= $_ for @oJ;
        _.2 = _.4 = A.1 for @oJ;
    }
    
    # travellers
    ar.t = c&t if c&t;
    c&main ||= "Beer";
    Rw c&main;
Beer: | # our 3
    n Tube
    saygr "Upon: ".G&sn;

