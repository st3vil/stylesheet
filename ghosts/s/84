
ElvisSaves: | # savepoints, noncontinual continuation
    # wants to fork before the pin
    # stream parent WayHeave from child
    # to pin again, wander off, receive self to up to parent, etc.
    # and check forking pg relistens (xo:forked)
    my $t = Rw Towering Ang
        || return;
    # 1c&forks = 1;
    # 1c&forks so that the result can be merged/objected to the parent,
    # which knows already what to expect and what to allow
    # 
    Rw ElvisMalta;
    sayre "Dune";
ElvisObs: | # criteria for travel, observables
    my $t = Rw Towering Ang
        || return;
     5s&desi = "Ghoster";
    n ShoGoings
    n ElMatron
    n Matu
    
    
ShoGoings: |
    n flow=>$_=>"Flow" for 1..(6 + Jc&bowls++);
ElvisMalta: |
    S
    sleep 4;
    1 && saybl "Dune";
    t.dd->(1, "One thing");
    S
    sayre "Five finged";
Forks: | # we decide to fork
    my $t = G&sn,3 .(ar.s && " ar.s");
    saygr "We decide to fork $t";
Four: | # savepoint/fork and wait
    my $parent = $$;
    if (my $pid = fork()) {
        1 && saygr "
            oooo
               o o
              o   o";
        
        $SIG{INT} = sub {
            sayre "Killing $pid...";
            kill 'KILL', $pid;
            delete $SIG{INT}
        };
        my $and;
        $SIG{HUP} = sub {
            $and = 1;
        };
        
        waitpid($pid,0);
        
        if ($and) {
            saybl "child wants restart!";
            return
            Rw waitme
        }
        
        saybl "Refork $t ? <";
        
        my $IN = \*STDIN;
        while (my $k = <$IN>) {
            chomp $k;
            return if G.c.loopst;
            #!G.reing && !$k && return 2;
            J.me = $k;
            say "__ $k";
            return 2;
        }
    }
    else {
        G.forked = $parent;
    }
Sleep: | # desire and not
    u i
    
    # mark/point
    # sleep/engage mind
    # want to substrata bits of the ground,
    # or headers from bodies of work, making sleep if same
    # $e:
    #    name/Caboutname of how we are being
    #    all being is writing on some ground
    # $s:
    #    names sleep/wake features to have
    #    names/numbers groups of time/etc in the pin
    #      eg test frames
    S: %acgt:e s
        $e ||= 'doming';
        die "Featured e=".ki$e if $e ne 'doming';
        # index s and valve into A sleepmoding thing
        # Sleep has modes to deal
        
        if ($s eq 'no') { # backwards for once
            if (1c&want.once) { # got in somehow
                G&unrea,A.1;
                T.nose = 7; # still, osc
                return 0 # || returns from pin
            }
            else {
                1c&want.once = -7;
            }
        }
        
        if (c&Se && $s =~ /^\d+$/) { # goto section
            my $w = T.w;
            my $max = w.sc.num;
            $max || die "No numbers in w.t";
            if (c&Se == $s) {
                # is it
                #1c&forks &&
                #    Rw Forks $s;
            }
            elsif (c&Se < $s) {
                T.more = 1;
                return 0; # next
                # Tesh keeps throwing them,
                # may want to tell something to do more
                # in yay timeframe
                # there go the sections of code that do stuff
            }
            else {
                if (c&Se <= $max) {
                    goto "S_".c&Se;
                }
                else {
                    return 0 # last
                }
            }
        }
        
        G&A,n=>2,A.1,[];
        $A = A.mo;
        local A.V = 0;
        G&tug,0.6; # eg E can pos=1 awake
         
        1 unless "can" eq "sleep";
        
    # marks a point for ghost chopchoping, see ElvisDesi
    # also # 38 makes a numerical
    # know line in the way it came from
    # to disambiguate unnamed T points, which just say 'here'
    # we can wake J with T coverage (Tin)
    T: %acgt:e s
        if ($e ne 'doming') {
            # e type of moment of being
            # unknown should grab our attention
            # and/or make savepoint
            # they are runtime ice picks
            # like Escher joins in the space bends of the buildings
            # also similar to sending duplicate placements in lv
            # as if space was real
            die "Given e=$e s=$s";
        }
        G&S; # no s, just engage mind
        
        my $w = T.w || die "T no w: ".ki $T;
        (my $label = 'T_'.$s) =~ s/\W+/_/sgm;
        my $line = G&find_caller_line_labelled,$label;
        if (my $te = A.mo && A.mo.c.T) {
            G&has,\'mo'=>way=>w.t=>w.sc.dige=>1 if A.mo;
        
            # care for finding for way name > T name
            te.has.Tin.>w.t.>$s.>$line ++;
        }
        else {
            warn "T $s outerspace: ".G&sn
        }
        1;
    
    # could also look back for most h/w/throat/J6 call... somehow
    # c/64 Bun uses confess to find printed list of args
    # which we can lookup refs for A,
    # which could overload to print its t/ip
    find_caller_line_labelled:
        my @h;
        my $line; # to disambiguate unnamed T points
        for (0..7) {
            my $l;
            my @q = qw'package filename line subroutine hasargs
            wantarray evaltext is_require hints bitmask hinthash';
            my @ca = caller($_);
            $l.>$_ = shift @ca for @q;
            @q = qw'hinthash line subroutine';
            $l = {map{$_=>$l.>$_ }@q};
            push @h, $l;
            if (my $hh = l.hinthash) {
                if ($hh->{':'} eq $s) {
                    $line = l.line;
                    last;
                }
            }
        }
        $line || sayre "Cannot find $s above: ".ddump \@h;
        $line
        
    
    #c J4-5 how connection desires
    u c
    
    # ways in to knowing which dream is where
    u c
    # classify wave, particle knowing in Matu
    typed 31: %of:mo,v:W
        my $t = 1s&typed ||= {};
        my $k = c&e ? 'e' : 'W';
        $t.>$k.>A.2 = A.2;
    
    # should be anywhereable, soft linked program structure
    # for when this travel is only for xo.some.some* havers
    # or to do anything to any C at any A, or h/w/n
    # the hard won fishing pole locates truth
    # and:
    # to refresh changed xo.way
    # for just wandering around
    
    # see Ghoster for top level figured travels
    # TODO doesn't want to be u c with v:sJ?
    xoJ 44: %of:mo,v:J
        $J = s&J;
        my $xo = Js&xo || return;
        if (my $xo = 1s&xo) {
            if (my $or = 3Cc&forxo) {
                my $any;
                each name,xop $or {
                    G&pint,$xo,@$xop || next;
                    A&want.forxos.>$name = 1;
                    $any++;
                }
                # contends with xo.way
                A&want.forxo = 7 * ($any ? 1 : -1);
            }
            if (my $ow = xo.way) {
                for my $way (keys %$ow) {
                    my $w = G&wup,$way || next;
                    my $od = {%{ $ow.>$way }};
                    delete $od.>w.sc.dige;
                    if (keys %$od) {
                        A&want.pin = 6;
                        A&want.pins.>$way = 6;
                    }
                    else {
                        # tends to travel anyway
                    }
                }
            }
        }
    
    # are we in or out
    J 45: %of:mo
        my $de;
        de.mo = A&want if A&want;
        de.C = c&want if c&want;
        de.J = 1c&want if 1c&want;
        $de || return;
        local A.V = 2;
        my $des = "C.t C.y.cv ".G&sn,3 ." -> ".ki $de;
        
        # want.* is weight if numeric, explanation if ref
        my $eq = sum grep {!ref} map{ values %$_ } values %$de;
        # want to add counterpoints
        # everything eventually sleeps way/u/W stuff
        
        if ($eq < 0) {
            saybl "Sleep $eq   $des";
            # we can skip 6, our mo C should re-sc from before
             
            my $ou = G&grist,A.2;
            my ($t) = grep {_s&J eq s&J} map {_.c.s} values %$ou;
            die "MIssing ground for C.t c.y.cv: ".ki $t if ts&J ne s&J;
            C.sc = {%{t.sc}};
            
            my $to = $eq < -6 ? '8' : '7';
            T.Z.>$to = $A;
        }
        else {
            saygr "Waker $eq   $des";
        }
Ghoster: | # Rw being for the 5
    # Ghoster is part of 5, working of its u lv
    # should track lv but not import it
    # assume none missed
    my $s = 1s&u.sc.s || die "Nou";
    my $z = ss&KC.sc.z;
    my $h = 1s&Ghoster ||= {};
    my @c; # {c:now, l:before}
    for my $W (grep {_.t eq 'w'} @$z) {
        next if Wc&el >6;
        way: for my $c (@{Ws&z}) {
            next if cc&el >6;
            next if h.adway.>c.t eq $c;
            
            my $l = c.y.r && c.y.r.c.o.y.L && c.y.r.c.o.y.L.c.s;
            if (!$l) {
                if ($l = h.adway.>c.t ) {
                    sayre "l c.t found only in hadway, not 5u osc";
                } #
                elsif (my $had = G.sc.pinark.>c.t ) {
                    my $ww;
                    each dige,arg,w $had {
                        $w = w.y.argumented;
                        $ww.>$w = $w;
                    }}
                    if (keys %$ww > 1) {
                        my $older;
                        each ref,w $ww {
                            if (my $ha = T.w && T.w.y.argumented) {
                                if ($ha eq $w) {
                                    1 && sayyl "w.t vs w.t";
                                    next way;
                                }
                            }
                            ws&digup || next;
                            if ($older) {
                                sayre "Many older: w.t";
                                undef $older;
                                last;
                            }
                        }
                    }
                    if (keys %$ww > 1) {
                        say "For ".ki $c;
                        my $n = keys %$ww;
                        die "GMany manyways x$n: ".wdump 3, $ww;
                        
                    }
                    ($l) = values %$ww;
                }
                else {
                    sayre "Ghoster: Didnt Rw c.t";
                    next;
                }
            }
            $l || die "Cannot find last ".ki $c;
            h.adway.>c.t = $c;
            push @c, {c=>$c,l=>$l}; # c
        }
    }
    # remotely four about all Jtv,
    my @l = Rw Matu;
    
    # do each 0.1 of either cv at a time?
    my $Wwq;
    for my $c (@c) {
        my $la = c.l;
        my $w = c.c;
        for my $W (@l) {
            next unless Ws&way && Ws&way.>w.t;
            $Wwq.>W.t.>w.t = {W=>$W,c=>$c}; # q
        }
    }
    #c tune to reduce travel
    my $Wr;
    my $tw;
    each Wt,wt,q $Wwq {
        my $W = q.W; # one Matu atom
        $tw.>$Wt = $W;
        my $r = $Wr.>$Wt ||= {};
        my $c = q.c; # many c by w.t
        if (my $in = Ws&Tin && Ws&Tin.>$wt ) {
            each label,line,count $in {
                # forget line and seek the T string
                my ($cs,$ls) = map {
                    my @l = split "\n", _.c.s;
                    my @h;
                    push @h, shift @l until !@l || $l[0] =~ /^\s*T $label/;
                    if (!@l) {
                        sayre "No finding ^\\s+T $label in:", _.c.s;
                        ""
                    }
                    else {
                        my $l = shift @l;
                        my $ind = $1 if $l =~ /^(\s*)/;
                        my @o;
                        unshift @o, pop @h while @h && $h[-1] =~ /^$ind/;
                        push @o, $l;
                        push @o, shift @l while @l && $l[0] =~ /^$ind/;
                        join "\n", @o;
                    }
                } c.c, c.l;
                
                my ($how,$s) = !$cs || !$ls ? ("go","Tinlos")
                    : $cs eq $ls ? ("vague","Tinels")
                    : ("go","Tincha");
                
                # needs to give distributed Travelings
                # clues about only Tin so and so updating
                my $v = $r.>$how.>$s = {t=>"Tin $label $wt:$line"};
                vs&was = $ls;
                vs&now = $cs;
                vc&how = $how;
                vc&forxo = [Tin=>$wt=>$label=>$line] if $how eq 'go';
            }}
        }
        r.go.flow = "ambience";
    }}
    my $rec;
    each Wt,W $tw {
        my $r = $Wr.>$Wt;
        my $c = $rec.>$Wt = {t=>$Wt};
        c.y.V = $W; # Vibe it has, foamed data unpacking layer
        c.y.cv = W.y.cv;
        c.y.c = $c; # 
        
        my $no = keys %{r.no||{}};
        if ($no / keys %$r > 0.6) {
            saygr "Still Travel W.t";
            c.c.el = 8;
        }
        else {
            c.c.el = 3;
            each how,s,v $r {
                ref $v || next;
                c.c.with.>v.t = $v;
            }}
        }
    }
    
    #c focus withs by actuator
    my @to;
    for my $Wt (sort keys %$rec) {
        my $c = $rec.>$Wt;
        my $R = {t=>$Wt,y=>{%{c.y}}};
        R.c.W = $Wt;
        each name,v cc&with {
            if (my $p = vc&forxo) {
                Rc&forxo.>$name = $p;
            }
            # more actuators
        }
        push @to, $R;
    }
        
    # u/ning sorting update paths
    
    # and jointed consequences
    
    # travel
    
    #G&timer,0.001,$_ for &{
        4s&toy ->({to=>\@to},{l=>$l[0]});
    #};
Matu: | # T room on Os
    # puddle display
    my $fo = A.4;
    my $ts;
    my $tt;
    # for all that is
    my $Jtv = fo.sc.Jtv;
    my $nine = 0.1;
    $Jtv.>fo.t.>$nine = $fo;
    
    each t,cv,J fo.sc.Jtv {
        $tt.>$t && die "Already had $t: ".ki($J)."\nunt: ".ki($tt.>$t);
        $ts.>$J = $tt.>$t = G&Ct,[$t,$cv,{J=>$J},{}];
    }}
    
    # make A.2 hierarchy
    # should all be A.4
    for my $k (sort keys %$tt) {
        my $C = $tt.>$k;
        my $upJ = c&J.2;
        C.c.>$_ = c&J.>$_ && c&J.>$_ ->{t} for 1..5;
        if (my $upC = $ts.>$upJ) {
            next if $upC eq $C;
            delete $tt.>C.t;
            push @{upC.sc.z||=[]}, $C;
        }
    }
    
    my @t = values %$tt;
    @t > 1 && sayre "Many tops: ".ki \@t;
    
    
    
    
    
    #c that makes T into tests with extremities
    # things recognised out from ...
    my @al = map {
        my $ub = &C{
            my $J = c&J;
            c&s = "C.t";
            s&chaos = keys %{Jc&chaos||{}} && Jc&chaos if !Jc&o;
            if (my $xo = Js&xo) {
                my $un;
                while (my ($k,$v) = each %$xo) {
                    if ($k eq 'way') {
                        s&way = {%{s&way||{}}, %$v};
                    }
                    elsif ($k eq 'Tin') {
                        s&Tin = $v;
                    }
                    else {
                        $un.>$k = $v;
                    }
                }
                s&xo = $un if $un;
            }
            if (my $t = Js&typed) {
                my $un;
                while (my ($k,$v) = each %$t) {
                    my $to;
                    $to = 'jointed' if $k eq 'W';
                    $to = 'elvised' if $k eq 'e';
                    if (!$to) {
                        $un.>$k = $v;
                        next;
                    }
                    while (my ($ref,$R) = each %$v) {
                        # is means its doing that for its 2
                        my $is = Rc&is || '';
                        my $oJ = R.2 if $is;
                        my $t = $oJ && oJ.t || R.t;
                        
                        my $c = C.sc.>$to.>$is.>$t ||= {};
                        
                        c.J && c.J ne $R && die
                            "Dup typed->mix $t/R.t:".ki(c.J)
                            ."\n   ".ki($R);
                        c.oJ = $oJ if $oJ;
                        c.i++;
                    }
                }
                s&typed = $un if $un;
            }
            #c constring
            if (my $w = s&way) {
                # pin: dige: count
                s&pins = join ',',sort keys %$w;
                s&strung.way.pins++;
            }
            for my $to ('jointed', 'elvised') {
                # Jc&is||'': oJ.t||J.t: {i=count, oJ?=J}
                # oJ is the W the is is for
                # becomes more specific
                my $mix = delete C.sc.>$to || next;
                my $h = {};
                G&chew,$mix,\'is,t',$_ for &c,is,t{
                    my $k = "$to".($is&&"($is)");
                    $k = 'u' if $k eq 'jointed(mind)';
                    acu $h,$k,$t;
                };
                C.sc.>$_ = join ",",@{$h.>$_ }
                    for sort keys %$h;
            }
            if (my $in = s&Tin) {
                s&Tins = ki $in;
                s&strung.Tin.Tins++;
            }
            $C
        };
        G&ind,$_,$ub;
    } @t;
    
    my $s = join "\n", map {
        my $in = _c&inds;
        my $sc = _.sc;
        my $ha = (keys %$sc && "\n").join "\n", map {
            my $v = $sc.>$_;
            $v = ki $v if ref $v;
            "$in  $_:".($v !~ /\n/ ? " $v"
                : "\n".join "\n", map { "$in    $_" }
                split /\n/, $v);
        } grep { $_ ne 'z' && $_ ne 'strung'
            && !(sc.strung && sc.strung.>$_ ) } sort keys %$sc;
        
        sprintf "%-20s %-30s", $in . _c&s , $ha
    } @al;
    #
    my ($top,@l) = @al;
    if (A.1.t ne "Matu") {
        #1 && saybl "Soup of fo.t:\n$s";
        4s&Matsoup = $s;
        4s&Matsup = $s; # to be more digital
        return @al
    }
    
    Jc&elvis = 'Dejo';
    n so=>1=>G&sn 
    n woov=>2=>"\nZouper: fo.t\n$s";
Towering: | # os->Os for test frames
    if (A.4.t ne 'os') {
        # are in the ElvisLower n c&est in Os
        T.ray = 2 if c&TC && c&TC.c.ray;
        return ar.t || die "4 no art";
    }
    my $t = Rw Telvis;
    # ElMatron hosts w since we began
    # and our idea of normal (theu)
    my $incs = {};
    my $inct = 'five';
    if (ar.m && !(ar.ar && ar.ar.m eq ar.m)) {
        # u things mixing into theu (normal) TODO
        /^_$/ ? $inct = 'normal'
            : push @{ $incs.>$inct ||=[] }, $_
        for @{ar.m}
    }
    my $oJtv;
    A.c.fivey ||= do {
        local 4s&Jtv = $oJtv = {};
        my $c = {};
        c.inc = $incs if keys %$incs;
        my $ma =
        n ElMatron=>W=>$c
        J.5 = A.5 = t.ntos->($ma,'J');
    };
    defined ar.n || die "4 making no arn";
    my $c = {t=>$t, main=>'ElvisLower', estC=>c&estC, est=>C.t, estn=>1+ar.n};
    c.oJtv = $oJtv if $oJtv;
    c.inc = incs.five if incs.five;
    n Os=>W=>$c
    return
ElvisLower: | # Os's main as tests like to dispatch
    sayyl "forez room: ".G&sn;
    
    my $c;
    c&est || die "Give test name ".G&sn;
    c.Se = c&estn if c&estn;
    c.ar.t = $t;
    c.TC = c&estC if c&estC;
    
    n c&est=>W=>$c
    
ElMatron: | # our 5, has normal + net decising
    Js&ein.t.w = &TesC{
        my $W = e.c.s;
        $W =~ /^(\w+)$/ || die "Give ecs way name";
        Jc&inc.add.>$W ++;
    };
    T.H = 8; # thawable
    local A.4.t = 'Os'; # want namespace
    
    Jc&inc = c&inc if c&inc; # reset
    my $i = Jc&inc;
    u ReU=>W=>{plus=>i.normal}
    
    #Jc&bowls ++ &&
    #sayyl "ElM the: ".ki $i;
    
    u $_ for sort keys %{i.add||{}};
    
    T.H = 3; # thaw/store
    u ElvisWayliases
    u $_ for @{i.five||[]};
    
    S
    # plan to continue process
    Js&desi && 
        Rw Js&desi;
ElvisWayliases: | # dialect patchbay
    # translate g/c stylehouse dialectics to g/s (a/allact (Mo) -> alact (mo))
    # to build PiMachine on Os
    n c=>''=>G.way.alc,'%of:w';
    n s=>''=>G.way.als,'%of:w';
    n a=>''=>G.way.alact,'%of:w';
    n i=>''=>G.way.alacgts,'%of:w';
ElvisSoftu: | # T Ghost maint for common u things, dialects جستجو
    my $t = Rw Towering Ang
        || return;
    
    # add many S pages
    if (c&Se == 1) {
        u Softu=>''=><<'','%of:w'
            T.H = 2; # stores
            n aly
            n alc
            n c
            n als
            n s
            n alact
            n a
            n alacgts
            n i
        t.e =
        n Softu
        t.en->('sc lastK c s', 'caches u');
    }
ReU: | # posit our 4.ii as normal (theu), share as W
    # host
    my $u = Js&normal ||= Js&theu ||= A.4.ii.theu;
    if (c&plus) {
        n Normal=>W=>{base=>$u,plus=>c&plus};
        $u = T.op;
    }
    n theu=>1=>{s=>$u},'%of:W'
    n normal=>1=>{s=>$u},'%of:W'
Normal: | # u receives adjustments to anything
    # as lv shipped off the top of the ghost mountain it is
    # would be imparted with 4/5 to start process
    # and then just continue itself as downstream from its true self
    # which is joining ghost change to it by travelling update paths
    # and sending it lv diffs
    
    # until base and its growth is not implanted by g/c and WayHeave:
    Jc&bases = c&base if c&base;
    n NormalWas=>W=>{base=>Jc&bases}
    
    Jc&plus = c&plus if c&plus;
    my $plus = Jc&plus;
    n $_=>3=>\'W' for @$plus;
    
NormalWas: |
    Jc&base = c&base || die "Give base to J.t";
    
Os: | # our 4
    G&mk4,$A;
    A.5.2 = A.5.4 = A.1;
    A.5.5 = A.5;
    # 4 includes Js created in ElMatron before 4
    if (my $Jtv = c&oJtv) {
        my @oJ = map{values %$_} values %$Jtv;
        sayyl "Boot C.t: ".join', ',sort map {_.t} @oJ;
        1s&Jtv.>_.t.>A&Jcv ||= $_ for @oJ;
        _.2 = _.4 = A.1 for @oJ;
    }
    
    4s&toy = &c,sc{
        G&elph,Os=>W=>$c,$sc;
    };
    
    
    # travellers
    ar.t = c&t if c&t;
    c&main ||= "Beer";
    Rw c&main;
Beer: | # our 3
    #
    c&to || return sayre "Noop: ".ki $C;
    saygr "Beering ".ki _.c for @{c&to};
    #saygr " - ".ki $_ for @{c&to};
    T.nose = 1;
    n $_ for @{c&to};

