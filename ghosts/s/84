Towering: | # makes sure you're in 4 Os
    return ar.t || die "Os no art" if A.4.t eq 'Os';
    my $t = Rw Telvis;
    my $incs = {};
    my $inct = 'five'; # u things into the 5 on $m first
    if (ar.m && !(ar.ar && ar.ar.m eq ar.m)) {
        # u things mixing into theu (normal) TODO
        /^_$/ ? $inct = 'normal'
            : push @{ $incs.>$inct ||=[] }, $_
        for @{ar.m}
    }
    A.c.fivey ||= do {
        my $c = {};
        c.inc = $incs if keys %$incs;
        my $ma =
        n ElMatron=>W=>$c
        J.5 = A.5 = t.ntos->($ma,'J');
    };
    defined ar.n || die "Os making no arn";
    my $c = {t=>$t, main=>'ElvisLower', estC=>c&estC, est=>C.t, estn=>1+ar.n};
    c.inc = incs.fo if incs.fo;
    n Os=>W=>$c
    return
ElvisLower: | # Os's main as tests like to dispatch
    sayyl "forez room: ".G&sn;
    
    my $c;
    c&est || die "Give test name ".G&sn;
    c.Se = c&estn if c&estn;
    c.ar.t = $t;
    c.TC = c&estC if c&estC;
    
    n c&est=>W=>$c
    
    return unless c.mat;

    t.e =
    n ElvisMatu
    my $W = t.ntos->(t.e,'J');

    t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s});
ElMatron: | # our 5, has normal + net decising
    T.H = 8;
    # ^ always see theu, in 5.ii.W...
    sayre "Wants normal += $_" for @{c&inc.normal||[]};
    u ReU
    # make c/s/a/i in 5.ii.w for for compiling PiMachine on PiMachine
    T.H = 3;
    u ElvisWayliases
    u $_ for @{c&inc.five||[]};
    #u Ang
    
    n some=>2=>3
ElvisWayliases: |
    n c=>''=>G.way.alc,'%of:w';
    n s=>''=>G.way.als,'%of:w';
    n a=>''=>G.way.alact,'%of:w';
    n i=>''=>G.way.alacgts,'%of:w';
ReU: | # our 4, is normal (theu), share as W
    # host
    my $u = A.4.ii.theu;
    n theu=>1=>{s=>$u},'%of:W'
Os: | # our 4
    G&mk4,$A;
    A.5.4 = A.1;
    # travellers
    ar.t = c&t if c&t;
    c&main ||= "Beer";
    Rw c&main;
Beer: | # our 3
    n Tube
    saygr "Upon: ".G&sn;
ElvisMatu: | # T room on Os
    saygr "Upon: ".G&sn;
    # puddle display
    my $fo = A.4;
    my $ts;
    my $tt;
    # for all that is
    my $Jtv = fo.sc.Jtv;
    my $nine = 0.9;
    $Jtv.>fo.t.>$nine = $fo;
    
    G&chew,fo.sc.Jtv,'t,cv',$_ for sub {
        my ($J,$t,$cv) = @_;
        $tt.>$t && die "Already had $t: ".ki($J)."\nunt: ".ki($tt.>$t);
        $ts.>$J = $tt.>$t = G&Ct,[$t,$cv,{},{J=>$J}];
    };
    
    # make A.2 or T hier
    for my $C (values %$tt) {
        my $upJ = s&J.2;
        C.c.>$_ = s&J.>$_ ->{t} for 1..5;
        if (my $upC = $ts.>$upJ ) {
            next if $upC eq $C;
            delete $tt.>C.t;
            push @{upC.sc.z||=[]}, $C;
        }
    }
    
    my @t = values %$tt;
    @t > 1 && sayre "Many tops: ".ki \@t;
    
    # that makes T into tests with extremities
    my $s = join "\n\n", map {
        my $ub = sub {
            my $C = shift;
            my $J = s&J;
            "C.t".(!J.c.o &&"   ,")
        };
        G&ind,$_,$ub;
    } @t;
    n so=>1=>G&sn
    n woov=>2=>"\nZouper: fo.t\n$s";
