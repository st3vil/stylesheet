To: | # party controls
    u i
    # complicated delete
    Tnot:
        sayre "! not A.t ".ki($C);
        A.cv = 0.9;
    # moves/spawns in time (cv)
    # eventually T.Z.56.3 = [$C] or $A means when pipe is at 56 do from 3
    Tz: %acgt:D
        my ($to,$ba) = keys %{T.Z};
        $ba && die "Too many TZ: ".ki T.Z;
        my $wh = delete T.Z.>$to;
        delete T.Z;
        $wh eq $A || die "Too complic TZ: ".ki T.Z;
        $to /= 10 while $to > 1;
        A.cv = $to - 0.001;
        T.nocvz = 1;
    # catch up children every 0.1 (before our 0.1)
    tugA:
        $s = G&A,$s,@Me;
        G&entug,$s;
        $s
    entug:
        my $o = A.c.tug->{s.c.sip};
        A.c.tug->{s.c.sip} = $s;
        delete A.c.tog if $o ne $s;
        $s
    # TODO go wide by 0.1?
    tug:
        my $og = A.c.tog ||= [sort keys %{A.c.tug}];
        saybl "A.c.sip A.t tugs $s -> ".@$og;
        for (@$og) {
            my $mo = A.c.tug->{$_};
            next if mo.y.cv >= $s;
            my $A = $mo;
            A.c.ov = $s;
            G&throat
        }
Day: | # world primitives
    u i
    # sympathetic to design some stuff
    # see 64 got
    # hidey machine thats giving you things
    G:
        $G = {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'};
        G.h = G.i.h;
        $G
    # find local things, look up trail of con centers
    # could also look down/allways for elvis proto
    t:
        my $wanted = pop @Me if @Me && ref $Me[-1] eq 'CODE';
        $C = G&s,$s,@Me;
        c&on ||= 'ii';
        c&max ||= 5;
        c&min ||= 0;
        for my $i (c&min .. c&max) {
            my $from = $i == 0 ? $A : $A.>$i;
            $from || next;
            my $on = $from.>c&on || next;
            my $t = $on.>C.t || next;
            if ($wanted) {
                $t = $wanted->($t,$from,$_);
            }
            $t || next;
            return $t;
        }
    # make call, in i, looks up to 5 many rare/little subs
    # precompiled args
    h:
        my $y;
        my $D = T.D if T.D;
        if (ref $s eq 'CODE') {
            $y = $s;
        }
        elsif (!ref $s && A.i && A.i.>$s) {
            $y = A.i.>$s;
        }
        else {
            my $C = G&s,$s;
            c&on = 'i';
            $y = G.i.t->($A,$C,$G,$T,$C);
        };
        $y || die "no h: $s";
        my @r = eval { $DB::single = G.ydrop; $y->($A,$C,$G,$T,@Me) };
        if ($@) {
            if ($@ !~ /Throh/) {
                $D ||= A.i.ii.i.y.tw->{$s};
                saybl D.c.s;
            }
            die "Throh D.y.cv D.t: ".ind('  ',$@)."\n";
        }
        wantarray ? @r : $r[0];
    
    #c looks up meaning of word
    # compiles for given args
    w:
        my $ar = {};
        # their $ar (+)
        if (ref $Me[0]) {
            my $ra = shift @Me;
            %$ar = %$ra;
        }
        # use this w call's ACGT
        (ar.A,ar.C,ar.G,ar.T) = ($A,$C,$G,$T);
        # their args
        my @o = @Me;
        while (@Me) {
            my $k = shift @Me;
            @Me || die "w odd hash after $k: ".ki\@o;
            my $v = shift @Me;
            $ar.>$k = $v;
        }
        
        ar.__D && die "w __D deprecated: ".ki$ar;
        
        my @args = sort keys %$ar;
        my $args = join',','ar',@args;
        
        # look in of=w up the network to 5
        my @lo;
        my $want = sub {
            my ($t,$f,$i) = @_;
            push @lo, $f;
            # if i > netmask
            # if t mentions some other way to get it
            my $tw = t.y.tw || die "w $s found no ytw on"
                ." A.1.t s A.t @ $i (f.t): ".ki$t;
            $tw.>$s
        };
        # they are pins near network of knowledge of T
        my $w = G&t,'w',$want;
        
        # or the old way,
        if (!$w) {
            # going, hash tied to a directory
            # makes digest when way entered
            (my $fi = $s) =~ s/\W/-/g;
            $w = {t=>$fi};
            wc&s = G.way->{$fi} || die "No way: $fi";
            ws&dige = G.way.o.dige->{$fi}
                || die "Not Gway not diges $fi: wayo: ".ki G.way.o;
            ws&of = 'w';
        }
        $w || die "No way to $s (on A.1.t's A.t)";
        
        if (!$w) {
            @lo = map{_.t} uniq @lo;
            $w || die "No w: $s (looked in: @lo)";
        }
        ws&dige || die "w no dige: ".ki$w;
        ws&of || die "w not of: ".ki$w;
        
        my $ark = G.sc.pinark ||= {};
        my $v = $ark.>w.t.>ws&dige.>$args ||= do {
            my $v = G&hup,$w;
            v.y.argumented = $w;
            vs&args = $args;
            G&perlcode,$v;
            v.c.code || die "no ccode back: ".ki$v;
            $v;
        };
        v.sc.called++;
        
        vc&code ->($ar,map{ $ar.>$_ }@args);
        
    # make s.c.code, see of
    perlcode:
        my $C = $s;
        # shade the edge, args etc.
        G&CoArgulate;
        # translate into perl
        G&CoBabbler;
        
        my $y = eval c&s;
        die "Nocompile C.t: ".ki($C)
            .ind('  ',$@)."\n\n c&s \n"
            if $@;
        die "Not code C.t: ".ki($C)
            if ref $y ne 'CODE' && !s&subpeel;
        c&code = $y;
    
    n $_=>1=>G.way.>$_ for qw'CoArgulate CoBabbler';
    
    # ^ compiler for old G.w
    n won=>'',join("\n",map{G.way->{$_} || die "no $_"}qw'cono CoBabbler')
    
Tube: |
    u i
    # be a A.y = A (means is full of wires)
    # J are A that inherit from each other
    # as A wave connection to them
    A: %acgt:s ov
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            A.up = $i;
            A.c.ip = [@{A.up.c.ip||[]}, A.up.c.ipi++];
            A.c.sip = join' ',@{A.c.ip};
            saygr "A.c.sip A.t from i.t";
        }
        if ($ov) {
            $ov /= 10 while $ov >= 1;
            A.c.ov = $ov;
            if (@Me) {
                A.c.N = \@Me;
            }
            G&throat;
        }
        return $A

    # go A
    # .t a We thing to actuate consciousness
    # net look up to 3
    throat:
        return if T.not;
        $s ||= A.c.of || A.t;
        my $of = G&s,$s;
        of.c.max = 3; # distance from A to look
        my $z = G&t,$of || return;
        #snooze 500;
        my $uov = A.c.ov;
        my $ntug = 0.1;
        my $keep; # going many same cv
        while ($z) {
            next if z.c.W;
            next if z.y.cv <= A.y.cv && (!$keep || z.y.cv > keep.y.cv);
            $keep = $z;
            last if $uov && z.y.cv > $uov;
            my $etug = $ntug;
            if (A.c.tug && $ntug <= z.y.cv) {
                $ntug += 0.1 until $ntug >= z.y.cv;
                G&tug,$ntug;
            }
            $C = A.c.s ||= {y=>{A=>$A}};
            $T = A.c.T ||= {};
            my @is = (A.c.N || $z);
            
            # z wants C
            if (z.sc.nk) {
                exists $C->{z.sc.nk} || next;
                @is = $C->{z.sc.nk};
                if (z.sc.gk) {
                    exists $C->{z.sc.nk}->{z.sc.gk} || next;
                    @is = $C->{z.sc.nk}->{z.sc.gk};
                }
            }
            if (z.sc.sk) {
                exists C.sc->{z.sc.sk} || next;
                @is = C.sc->{z.sc.sk};
            }
            if (z.sc.t) {
                my $sc = z.sc;
                ref sc.ip eq 'HASH' || die "Dsct ip not: ".ki$z;
                G&ip,\$sc,$C || next;
            }
            if (z.sc.Ifs) {
                die "A impli";
                @is = G&scIfs,z.sc.Ifs;
            }
            
            # z readies
            if (z.sc.acgt && !z.c.code) {
                my $y = eval z.c.s;
                die "Throcompile of.t z.y.cv: z.t: ".ind('  ',$@)."\n" if $@;
                z.c.code = $y;
            }
            
            say "A.c.sip \t Onto A.t A.y.cv ~ C.t ~ z.t z.y.cv";
            # happens
            for my $s (@is) {
                z.sc.acgt eq 's' || die "nonacgts".wdump $z;
                T.D = $z;
                my $y = z.c.code;
                ref $y || die "Compile z.y z.y.cv!";
                
                G.i.h->($A,$C,$G,$T,$y,$s);
                
                T.ut && G&Tut,$s;
                T.Z && G&Tz,$z;
                G.tuberay && G.tuberay->($A,$C,$G,$T);
                last if T.not || T.whack;
            }
            # back
            delete T.ut;
            
            A.y.cv = z.y.cv unless delete T.nocvz;
            last if delete T.whack || T.not;
        }
        continue {
            $z = z.y.in || z.y.next; # or timeout, mass comb via A.m
        }
        # leaving
        A.c.tug && G&tug,A.y.cv;
        delete A.c.ov;
        T.not && G&Tnot;
        saybl "A.c.sip \t<--  A.t A.cv";
        # TODO cycle all A.c.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    
    
Ce: | # ways at C, see 2/Sea for C chewing/itself
    u allacgts
    n Te
    peels: %subpeel
        qr/^[\{\%]\w+/;
    
    peel:
        return $s if ref $s;
        $s =~ s/^%//;
        my $c = {};
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c
    
    c: %acgt:D
        G&inDin,$C,@M;
    
    e: %acgt:D
        my $e = G&sces,C.c.e||return();
        G&inDin,$e,@M;
    
    us: %acgt:D
        my $e = G&sces,C.c.e||return();
        my $us = e.c.us||return();
        push @M, 'NOGK' if @M == 1;
        G&inDin,$us,@M;
    
    sces:
        my $i = 0;
        while (s.c.e) {
            $s = s.c.e;
            $i++ > 9 && die "HUGE $i recursing C.t CceCceCceCce... by ".ki $s;
        }
        return $s;
    
    inDin: %acgt:s D
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = G&interpD,@M if !ref $D;
        #
        my $v = G&Cngk,$s,$D;
        saybl "Got cnkgk: ".wdump 3,[\@M,$D,$v,$s] if A.VV.D;
        die "Unhandles any: $v: ".ki $D if $v eq '1';
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        @$v == 1 || die "Many somehowed ".wdump 3,[ki($D),$v];
        ($v) = @$v;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;
            return @$v;
        }
        return $v;
    
    interpD: %acgt:nk gk
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if ($nk =~ s/^(y|c|s)(?=\w+)//) {
            D.c.nk = $1 eq 's' ? 'sc' : $1;
            D.c.gk = $nk;
        }
        elsif (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    Cngk: %acgt:s D
        ref $A || die "nmonref A!";
        A.bangdesk.bang->{Cngek} = sub {
            sayre "was Cngk; ".ki($s)."\nWith: ".ki($D)
        } if 0;
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
Te: | # determine & introgress
    u allacgts
    # intel s, c properties
    # \$whereclause
    ip: %acgt:s c
        my $z;
        $s = G&peel,$$s if ref $s eq 'SCALAR';
        my $n;
        if (ref $s eq 'REF') {
            # do s.do
            $s = $$s;
            $n = $s;
            s.ip || die "sip no ref";
            $s = {map{$_=> \s.ip.>$_ }keys %{s.ip}};
        }
        # n.all keeps going after a pass--
        my $pass = 1;
        EE: for my $k (keys %$s) {
            $pass == 1 || n.all || return 0;
            my $y = $s.>$k;
            my $x = $c.>$k;
            if (ref $y eq 'REF') {
                $y = $$y;
                if (exists y.nk) {
                    $x = $c;
                    for my $k (grep{defined}y.nk,y.gk,y.tk) {
                        $pass--, next EE unless
                            ref $x eq 'HASH' && exists $x.>$k;
                        $x = $x.>$k;
                    }
                }
                my $wa = $pass;
                !defined $x || $pass-- if y.ndef;
                defined $x || $pass-- if y.def;
                y.is eq $x || $pass-- if exists y.is;
                y.not ne $x || $pass-- if exists y.not;
                y.in->{$x} || $pass-- if y.in;
                !y.nin->{$x} || $pass-- if y.nin;
                $x > y.gt || $pass-- if exists y.gt;
                $x < y.lt || $pass-- if exists y.lt;
                $x >= y.gteq || $pass-- if exists y.gteq;
                $x <= y.lteq || $pass-- if exists y.lteq;
                $x =~ y.re || $pass-- if exists y.re;
                $pass = $pass < $wa ? $wa : $pass-1
                    if y.neg;
            }
            elsif ($y ne $c.>$k) {
                $pass--;
            }
        }
        $pass == 1
    
    xoy: %acgt:s c
        $c = G&xot,{},$c;
        G&xot,$c,$s;
        return $s;
    
    xot: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : $v;
        }
        return $s
    
    xo: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = $v;
        }
        return $s
    
    hup:
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for
            grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    
Cee: | # ways at C, see 2/Sea for C chewing/itself
    u alacgts
    n Tee
    rand:
        3
    peels: %subpeel
        qr/^[\{\%]\w+/;
    
    peel:
        return $s if ref $s;
        $s =~ s/^%//;
        my $c = {};
        for (split ',', $s) {
            my ($k, $v) = split ':', $_, 2;
            $v = 1 if !defined $v;
            $c->{$k} = $v;
        }
        $c
    
    c: %acgt:D
        G&inDin,$C,@M;
    
    e: %acgt:D
        my $e = G&sces,C.c.e||return();
        G&inDin,$e,@M;
    
    us: %acgt:D
        my $e = G&sces,C.c.e||return();
        my $us = e.c.us||return();
        push @M, 'NOGK' if @M == 1;
        G&inDin,$us,@M;
    
    sces:
        my $i = 0;
        while (s.c.e) {
            $s = s.c.e;
            $i++ > 9 && die "HUGE $i recursing C.t CceCceCceCce... by ".ki $s;
        }
        return $s;
    
    inDin: %acgt:s D
        return () unless defined $s;
        return $s if $D eq 'C';
        #
        shift @M; # s
        $D = G&interpD,@M if !ref $D;
        #
        my $v = G&Cngk,$s,$D;
        saybl "Got cnkgk: ".wdump 3,[\@M,$D,$v,$s] if A.VV.D;
        die "Unhandles any: $v: ".ki $D if $v eq '1';
        #
        return () unless $v;
        # blankgk
        A.note->{D.c.nk}->{D.c.gk} = $v if A.note;
        #
        @$v == 1 || die "Many somehowed ".wdump 3,[ki($D),$v];
        ($v) = @$v;
        if (D.c.as eq 'list') {
            ref $v eq 'ARRAY' || die 'Cngk for list not array '.ki $D;
            return @$v;
        }
        return $v;
    
    interpD: %acgt:nk gk
        my $defnk = 'c';
        return $nk if ref $nk;
        my $D = {};
        D.c.as = 'list' if $nk =~ s/^_//;
        while ($gk =~ s/^%(.+?):(.+?)(?=%|$)//g) {
            D.c->{$1} = $2;
            pop @M if @M == 2;
        }
        if ($nk =~ s/^(y|c|s)(?=\w+)//) {
            D.c.nk = $1 eq 's' ? 'sc' : $1;
            D.c.gk = $nk;
        }
        elsif (@M == 1 && $nk eq 't') {
            D.c.nk = $nk;
        }
        elsif (@M == 1) { # or from t,,,
            D.c.nk ||= $defnk;
            D.c.gk ||= $nk;
        }
        elsif (@M == 2) {
            D.c.nk = $nk;
            D.c.gk = $gk;
        }
        delete D.c.gk if D.c.gk eq 'NOGK';
        $D
    
    Cngk: %acgt:s D
        ref $A || die "nmonref A!";
        A.bangdesk.bang->{Cngek} = sub {
            sayre "was Cngk; ".ki($s)."\nWith: ".ki($D)
        } if 0;
        return 1 if D.c.any;
        die "nonNKnk".ki$D if !D.c.nk;
        return 0 if !exists $s->{D.c.nk};
        return [$s->{D.c.nk}] if !exists D.c.gk;
        return 0 if !exists $s->{D.c.nk}->{D.c.gk};
        return [$s->{D.c.nk}->{D.c.gk}];
    
Tee: | # determine & introgress
    u alacgts
    # intel s, c properties
    # \$whereclause
    ip: %acgt:s c
        my $z;
        $s = G&peel,$$s if ref $s eq 'SCALAR';
        my $n;
        if (ref $s eq 'REF') {
            # do s.do
            $s = $$s;
            $n = $s;
            s.ip || die "sip no ref";
            $s = {map{$_=> \s.ip.>$_ }keys %{s.ip}};
        }
        # n.all keeps going after a pass--
        my $pass = 1;
        EE: for my $k (keys %$s) {
            $pass == 1 || n.all || return 0;
            my $y = $s.>$k;
            my $x = $c.>$k;
            if (ref $y eq 'REF') {
                $y = $$y;
                if (exists y.nk) {
                    $x = $c;
                    for my $k (grep{defined}y.nk,y.gk,y.tk) {
                        $pass--, next EE unless
                            ref $x eq 'HASH' && exists $x.>$k;
                        $x = $x.>$k;
                    }
                }
                my $wa = $pass;
                !defined $x || $pass-- if y.ndef;
                defined $x || $pass-- if y.def;
                y.is eq $x || $pass-- if exists y.is;
                y.not ne $x || $pass-- if exists y.not;
                y.in->{$x} || $pass-- if y.in;
                !y.nin->{$x} || $pass-- if y.nin;
                $x > y.gt || $pass-- if exists y.gt;
                $x < y.lt || $pass-- if exists y.lt;
                $x >= y.gteq || $pass-- if exists y.gteq;
                $x <= y.lteq || $pass-- if exists y.lteq;
                $x =~ y.re || $pass-- if exists y.re;
                $pass = $pass < $wa ? $wa : $pass-1
                    if y.neg;
            }
            elsif ($y ne $c.>$k) {
                $pass--;
            }
        }
        $pass == 1
    
    xoy: %acgt:s c
        $c = G&xot,{},$c;
        G&xot,$c,$s;
        return $s;
    
    xot: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = ref $v eq 'HASH' ?
                        {%{$s->{$k}||{}}, %$v}
            : $v;
        }
        return $s
    
    xo: %acgt:s c
        ref $c eq 'HASH' && ref $s eq 'HASH'
            || die "Hash up".wdump 3, [$s,$c];
        while (my($k,$v) = each %$c) {
            $s->{$k} = $v;
        }
        return $s
    
    hup:
        my $CC = {%$s};
        $CC->{$_} = {%{$CC->{$_}}} for
            grep {ref $CC->{$_} eq 'HASH'} keys %$CC;
        return $CC;
    

