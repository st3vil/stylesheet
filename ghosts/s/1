To: | # party controls
    u i
    # complicated delete
    Tnot:
        sayre "!\n! not A.t ".ki($C)."\n!";
        A.cv = 0.9;
    # moves/spawns in time (cv)
    Tz: %acgt:D
        die "A.t 's D.y.cv~D.t TZ moved C.y.cv~C.t ".wdump 3, T.Z;
    # catch up children every 0.1 (before our 0.1)
    tugA:
        $s = G&A,$s,@Me;
        G&entug,$s;
        $s
    entug:
        my $o = A.c.tug->{s.c.sip};
        A.c.tug->{s.c.sip} = $s;
        delete A.c.tog if $o ne $s;
        $s
    # TODO go wide by 0.1?
    tug:
        my $og = A.c.tog ||= [sort keys %{A.c.tug}];
        saybl "A.c.sip A.t tugs $s -> ".@$og;
        for (@$og) {
            my $mo = A.c.tug->{$_};
            next if mo.y.cv >= $s;
            my $A = $mo;
            A.c.ov = $s;
            G&throat
        }
Day: |
    u i
    # see 64 got
    G:
        $G = {%{$G||{}}, i=>{%{A.i||{}}}, t=>G.t||'nobody'};
        G.h = G.i.h;
        $G
    # find local things, look up trail of con centers
    t:
        $C = G&s,$s;
        c&on ||= 'ii';
        c&max ||= 5;
        for (1..c&max) {
            return $A->{$_}->{c&on}->{c&s}
                if $A->{$_}
                && $A->{$_}->{c&on} 
                && $A->{$_}->{c&on}->{c&s}
        }
    # make call
    h:
        my $y;
        my $D = T.D if T.D;
        if (ref $s eq 'CODE') {
            $y = $s;
        }
        elsif (!ref $s && A.i && A.i.>$s) {
            $y = A.i.>$s;
        }
        else {
            my $C = G&s,$s;
            c&on = 'i';
            $y = G.i.t->($A,$C,$G,$T,$C);
        };
        $y || die "no h: $s";
        my @r = eval { $y->($A,$C,$G,$T,@Me) };
        if ($@) {
            if ($@ !~ /Throh/) {
                $D ||= A.i.ii.i.y.tw->{$s};
                saybl D.c.s;
            }
            die "Throh D.y.cv D.t: ".ind('  ',$@)."\n";
        }
        wantarray ? @r : $r[0];
        # see 64 Ngwe
    
    0&&
    w:
        # looks up meaning of word
    # ^ compiler (via G.w)
    n won=>'',join("\n",map{G.way->{$_} || die "no $_"}qw'cono CoBabbler')
    
    # be a A.y = A (means is full of wires)
    A: %acgt:s ov
        if (ref $s) {
            $A = $s;
        }
        else {
            my $i = $A;
            $A = {%$A};
            A.t = $s;
            A.y = $A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
            A.up = $i;
            A.c.ip = [@{A.up.c.ip||[]}, A.up.c.ipi++];
            A.c.sip = join' ',@{A.c.ip};
            saygr "A.c.sip A.t from i.t";
            A.1 = $A;
        }
        if ($ov) {
            $ov /= 10 while $ov >= 1;
            A.c.ov = $ov;
            if (@Me) {
                A.c.N = \@Me;
            }
            G&throat;
        }
        return $A
Tube: |
    u i
    # go A
    throat:
        return if T.not;
        $s ||= A.c.of || A.t;
        my $of = G&s,$s;
        of.c.max = 2; # distance from A to look
        my $z = G&t,$of || return;
        #snooze 500;
        my $uov = A.c.ov;
        my $ntug = 0.1;
        while ($z) {
            next if z.c.W;
            next if z.y.cv <= A.y.cv;
            last if $uov && z.y.cv > $uov;
            my $etug = $ntug;
            if (A.c.tug && $ntug <= z.y.cv) {
                $ntug += 0.1 until $ntug >= z.y.cv;
                G&tug,$ntug;
            }
            $C = A.c.s ||= {y=>{A=>$A}};
            $T = A.c.T ||= {};
            my @is = (A.c.N || $z);
            
            # z wants C
            if (z.sc.nk) {
                exists $C->{z.sc.nk} || next;
                @is = $C->{z.sc.nk};
                if (z.sc.gk) {
                    exists $C->{z.sc.nk}->{z.sc.gk} || next;
                    @is = $C->{z.sc.nk}->{z.sc.gk};
                }
            }
            if (z.sc.sk) {
                exists C.sc->{z.sc.sk} || next;
                @is = C.sc->{z.sc.sk};
            }
            if (z.sc.t) {
                my $sc = z.sc;
                ref sc.ip eq 'HASH' || die "Dsct ip not: ".ki$z;
                G&ip,\$sc,$C || next;
            }
            if (z.sc.Ifs) {
                die "A impli";
                @is = G&scIfs,z.sc.Ifs;
            }
            
            # z readies
            if (z.sc.acgt && !z.c.code) {
                my $y = eval z.c.s;
                die "Throcompile of.t z.y.cv: z.t: ".ind('  ',$@)."\n" if $@;
                z.c.code = $y;
            }
            
            say "A.c.sip \t Onto A.t ~ C.t ~ z.t z.y.cv";
            # happens
            for my $s (@is) {
                z.sc.acgt eq 's' || die "nonacgts".wdump $z;
                T.D = $z;
                my $y = z.c.code;
                ref $y || die "Compile z.y z.y.cv!";
                
                G.i.h->($A,$C,$G,$T,$y,$s);
                
                T.ut && G&Tut,$s;
                T.Z && G&Tz,$z;
                last if T.not || T.whack;
            }
            # back
            delete T.ut;
            
            A.y.cv = z.y.cv;
            last if delete T.whack || T.not;
        }
        continue {
            $z = z.y.in || z.y.next; # or timeout, mass comb via A.m
        }
        # leaving
        A.c.tug && G&tug,A.y.cv;
        delete A.c.ov;
        T.not && G&Tnot;
        saybl "A.c.sip \t<--  A.t A.cv";
        # TODO cycle all A.c.N as C
        # TODO line with Targety interrupt potential
        # see 1 KnowTime/Cone
    
    

