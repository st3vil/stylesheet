Triangle: | # peel electrosn
    u a
    # sevenatim
    # time passes independently of your being in the room
    # once you know about the room
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # C is self for s
        # C is 's many for o
        A.c.s = G&sJ,A.2,'s';
    s 2:
        # number of things plugged in
        # o uses recursio as passed in
        if (my $W = c&whole) {
            my $s = G&t,$W || die "no $W";
            say "Whole ! ".ki $s;
            G&tugA,o=>8,$C,$s,'whole';
            return T.Z.8 = $A;
        }
        if (my $W = c&base) {
            my $s = G&t,$W || die "no $W";
            say "Base ! ".ki $s;
            G&tugA,o=>1,$C,$s,'base';
        }
        if (my $n = A.c.n) {
            s&ch = A.2.sc.ch if !defined s&ch;
            s&ch = '' if !defined s&ch;
            G&tugA,o=>1,$C,n.sc.a->{$ch},'zip';
        }
        G&tugA,o=>3,$C,A.c.tug,'whole';
    s 3:
        # J t/y awakens
    s 4:
        # pieces sorted
        # brings up W inners <9 like t/y clang
    s 5:
        # goS made
    s 6:
        # going - figure difference
        c&el = '2' if 1 == 3;
    s 7:
        # pack down goods
    s 8:
        # tie together
        A.c.expo.>$_ = 1 for qw'tv i ii';
        A.2.sc.>$_ = C.sc.>$_ for keys %{A.c.expo};
        # send out
    # listen, insward, moral law, has to give us power
    
    # cases:
    #  J.i <- o.i
    #  - i porty J..p.i tell non-$o of overwrites
    #  - recur bit J..b.i.>$o <- last C we make 
    #  - may see lv/otherness settling clues on o
    #  - knows i means pull o.i as t=>s
    #  - recur C shell of just t and c.s
    # so around t/cs/sc the other stff
    
    # eats other, splats self 
    # the splat modes of ts, tv (shade c), 
    
    # all making a big rising of data, you could 
    
    
    
    o 1:
        my ($i,$f,$t) = @$s;
        i.y eq $i || die "i must A";
        
        if (i.y ne $i) {
            C.c.p = $i;
            C.c.i = {};
            
        if ($i eq i.y) {
            c&i = $i;
            
            
            # Aish house
            # 
            # b / self/what / other separation in 
            C.c.i = $i;
            C.c.last = i.sc.b->{$t}
        }
        else {
            # C to put on?
        }
        if ($f eq f.y) {
            # A/Jish house
            # mix sc.tv into us... C only surface
            # fol sc.lv as has sc.tv thasp and lv thasp el follow
        }
        else {
            C.c.s = $i;
            # grasp as C
            # do z el follow and y.in
        }
        A.3 = shift @$s; # us
        A.c.z = G&sJ,A.3,'s';
        A.2 = shift @$s; # from
        A.c.s = G&sJ,A.2,'s';
        A.c.V = [ map { _.t ||= _.c.s } map{ G&s,$_ } @$s ];
    o 2:
        #G&A,$_=>
        # makes C of the operation to change A.o.akey
    
        # probably sameish geometry
        my $tv;
        my $vt;
        my $ov; # overwrites tv []
        for my $k (sort keys %$flux) {
            my $Y = $flux->{$k};
            Y.c || die "noY".ki$Y;
            my $Z = Y.c.s;
            defined Z.t && defined Z.y.cv || die "noZ(C): ".ki$Z;
            if ($tv->{Z.t}->{Z.y.cv}) {
                push @{$ov->{Z.t}->{Z.y.cv}||=[]}, delete $tv->{Z.t}->{Z.y.cv};
                delete $vt->{Z.y.cv}->{Z.t};
            }
            my $z = $tv->{Z.t}->{Z.y.cv} ||= {};
            $vt->{Z.y.cv}->{Z.t} = $z;
            z.t = Z.t;
            z.y.cv = Z.y.cv;
            z.y.f = $Y;
            z.c.s = Z.c.s if exists Z.c.s;
            z.sc = {%{Z.sc}};
        }
        saybl "A.c.sip A.t s2: ".wdump 4, $tv;
        # sort by cv, sip
        # names -> A fall replace to check inside
        # A -> J t/y images
Walks: | # othering
    u i
    # current & join expr
    wtch: %acgt:c d
        my $wt = {};
        wt.same = 1;
        for (keys %$d) {
            if (!exists $c->{$_}) {
                wt.new->{$_} = $d->{$_};
                wt.same = 0;
            } 
            elsif ($d->{$_} ne $c->{$_}) {
                wt.diff->{$_} = $c->{$_};
                wt.same = 0;
            }
            else {
                wt.sami++;
                wt.still->{$_} = $c->{$_};
            }
            wt.tot++;
        }
        for (grep { !exists $d->{$_} } keys %$c) {
            wt.gone->{$_} = $c->{$_};
            wt.same = 0;
        }
        $wt;
    

