Triangle: | # oscillate, peel electro ground moments, s n
    u a
    # sevenatim
    # time passes independently of your being in the room
    # once you know about the room
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # C is self for s
        # C is 's many for o
        A.c.s = G&sJ,A.2,'s';
    s 2:
        # number of things plugged in
        for my $J (A.2) {
            C.c.>$_ = J.c.>$_ for grep{ J.c.>$_ }qw'whole base';
        }
        if (my $W = c&whole) {
            my $s = G&t,$W || die "no $W";
            say "Whole ! ".ki $s;
            G&tugA,o=>8,$C,$s,'whole';
            return T.Z.8 = $A;
        }
        if (my $W = c&base) {
            my $s = G&t,$W || die "no $W";
            say "Base ! ".ki $s;
            G&tugA,o=>2,$C,$s,'base';
        }
        if (my $n = A.c.n) {
            s&ch = A.2.sc.ch if !defined s&ch;
            s&ch = '' if !defined s&ch;
            G&tugA,o=>2,$C,n.sc.a->{s&ch},'zip';
        }
        c&zip = G&tugA,o=>2,$C,A.c.tug,'zipover';
    s 3:
        say "S  3 A.2.t";
        my $z = c&zip;
        saybl "AN zip: z.t z.cv / z.c.sip ".wdump 7, z.c.cha;
        # J t/y awakens
        # W t/y awakens
    s 4:
        # pieces sorted
        # brings up W inners <9 like t/y clang
    s 5:
        # goS made
        sayyl "5  A.2.t";
    s 6:
        # going - figure difference
        c&el = '2' if 1 == 3;
    s 7:
        # pack down goods
    s 8:
        # tie together
        A.c.expo.>$_ = 1 for qw'tv i ii';
        A.2.sc.>$_ = C.sc.>$_ for keys %{A.c.expo};
        A.2.c.o = "Steved ".++C.c.imp;
        # send out
    
    
Circle: | # copy things
    u a
    # listen, insward, moral law, has to give us power
    
    # cases:
    #  J.i <- o.i
    #  - i porty J..p.i tell non-$o of overwrites
    #  - recur bit J..b.i.>$o <- last C we make 
    #  - may see lv/otherness settling clues on o
    #  - knows i means pull o.i as t=>s
    #  - recur C shell of just t and c.s
    # so around t/cs/sc the other stff
    #
    # eats other, splats self 
    # the splat modes of ts, tv (shade c), 
    
    # all making a big rising of data, you could 
    o 1:
        my ($i,$f,$t) = @$s;
        i.y eq $i || die "i must A";
        
        ($f,my $fis) = ($$f,1) if ref $f eq 'REF';
        $t = G&Ct,@$t if ref $t eq 'ARRAY';
        %$C = %$t if ref $t eq 'HASH';
        C.t = $t if $t && !ref $t;
        
        
        c&i = $i;
        c&m ||= C.t;
        c&m = 'zip' if c&m =~ /^zip(.+)$/;
        if (ref $f eq 'ARRAY') {
            c&m = 'z';
            c&s = $f;
        }
        elsif ($fis) {
            c&s = $f;
        }
        elsif (f.y) {
            if (f.y eq $f) {
                # A/J
                c&h = $f;
            }
            else {
                # C mo 3 W:of ...
                #  C mo 1 s:... of:mo,dig:...
                # y.in or sc.z
                c&s = $f;
                c&m = 'C';
            }
        }
        else {
            # a zip
            c&s = $f;
        }
        if (c&m eq 'i' || c&m eq 'ii') {
            c&kno = c&m;
        }
        if (c&kno) {
            my $h = c&h || die "unhoused kno C.t m:c&m";
            c&s = h.sc->{c&kno} || $h->{c&kno};
            # may have lvism & more via h.sc.s.
        }
    #c o2 intermediate whats-where
    o 2:
        my $oo = A.c.oo = {};
        if (my $o = c&oosh) {
            $oo = o.y.A.c.oo || die "not yet oosh: ".ki $o;
            sayyl "OO SHARED with o.t o.y.cv";
        }
        # < space-for (C) < t < y [many o with .c.s = $e, o.y.etc = etc]
        # per other itself in 3, way in is noise-ish
        if (c&m eq 'zip') {
            my $ads = [];
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                v.y && v.y eq $v || die "zip yon not A";
                next if $v eq $A;
                # light cones holding C or doing another o bunch
                my $D = v.c.s;
                if (v.t eq 'o') {
                    # D is inner o's C - index windups
                    push @$ads, $v;
                    D.c.i eq c&i || die "o oth i C.c.i.t <-> D.c.i.t";
                    D.c.j && die "o D.c.t already got j";
                    D.c.jC && die "o D.c.t already got jC";
                    D.c.jC = $C;
                    my $ii = v.c.oo || die "Too early to oo: D.t";
                    my $i = 0;
                    for my $t (keys %{ii.C}) {
                        my $vs = ii.C->{$t};
                        for my $cv (keys %$vs) {
                            my $os = $vs->{$cv};
                            push @{oo.C->{$t}->{$cv}||=[]}, @$os;
                            $i++ for @$os;
                        }
                    }
                    say "A.t A.c.sip C.t claims $i from: v.t v.c.sip D.t";
                }
                else {
                    # D is J moment C material to shade
                    my $e = G&Chade,$D;
                    my $o = G&Chs,$e;
                    o.y.D = $D;
                    o.y.R = $v;
                    o.y.k = $k;
                    push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
                }
            }
            @$ads = G&sortysip,$ads,'1' if @$ads > 1;
            G&entug,$_ for @$ads;
        }
        elsif (c&m eq 'i') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # inflated t -> s
                my $e;
                e.t = $k;
                e.y.cv = 0.1;
                e.c.s = $v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'ii') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # t -> C
                my $e = G&xot,$v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'C') {
            # C
            my $S = c&s;
            my $pr;
            while ($S) {
                my $e = G&hup,$S;
                my $o = G&Chs,$e;
                o.y.origin = $S;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
                if ($pr) {
                    o.sc.oz.yprev = $pr;
                    pr.sc.oz.ynext = $o;
                }
                $pr = $o;
                $S = S.y.next;
            }
        }
        elsif (c&m eq 'z') {
            # [ C... ]
            for my $S (@{ c&s }) {
                my $e = G&hup,$S;
                my $o = G&Chs,$e;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        else {
            die "How to read ".ki $C;
        }
        if (c&oosh) {
            # oo shared with something that will 3... for us
            T.not = 1;
        }
        
    #c o3 make diff
    o 3:
        # opens recursive shop on i called j using C.t
        my $j = G&offis,i=>j=>'t';
        j.c.Co = $C;
        my $jj = j.sc.oo;
        my $oo = A.c.oo;
        my $cha = A.c.cha ||= {};
        # falls until array, oo.C.t.cv = [thamany]
        G&Chew,$oo,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            my @o = @$o;
            
            # sort by zipped from A sips
            @o = G&sortysip,$o,'A','R' if @o > 1;
            
            my @under;
            my $i; # number from last
            for my $d (reverse @o) {
                my $e = d.c.s;
                
                if (!$i) {
                    $o = $d;
                    $oo.>$x.>$t.>$cv = $o;
                    my $l = $jj.>$x.>$t.>$cv;
                    o.y.l = $l if $l;
                    # todo weaken l.y.l
                    
                    G&Chang,$l,$o;
                }
                else {
                    sayre "Dupl ".ki $d;
                    # only mix W
                    next unless exists e.c.W;
                    next if e.y.cv >= 0.9;
                }
            
                # throw inward (yin falls to z)
                if (my $z = e.y.in || e.sc.z) {
                    my $t = {t=>"z $t $cv".($i&&" $i")};
                    t.c.jC = $C;
                    t.c.oup = $o;
                    push @under, [$z,$t];
                }
                
                $i++;
            }
            
            # spawn from first
            my $fi;
            map {
                if ($_ ne $fi) {
                    _.c.oosh = fi.c.oo ||= {}
                }
                else {
                    $_
                }
            } map {
                my $Y = G&A,o=>1,c&i,@$_;
                $fi ||= $Y;
                $Y
            } reverse @under;
            
            G&tugA,o=>3,c&i,@$_ for @under;
            
            # ty in above o
            if (my $u = c&oup) {
                if (my $al = u.sc.bz.>$t.>$cv) {
                    sayre "ALREADY a C.t: $t $cv: ".ki $al;
                }
                u.sc.bz.>$t.>$cv = $o;
            }
        };
    #c o4 A -> J t/y images
    #
    o 4:
        my $j = c&j;
        my $jj = j.sc.oo;
        my $oo = A.c.oo;
        my $cha = A.c.cha ||= {};
        G&Chew,$oo,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            say "Hi from $t $cv";
            my $l = o.y.l;
            
            # o.sc.bz.$t.$cv inward check
            my $sc = 'sc';
            my $z = 'z';
            if (my $bz = o.sc.bz) {
                G&Chew,$bz,'t,cv',$_ for sub {
                    my ($to,$dt,$dcv) = @_;
                    
                    my $m = !to.c.cha ? 'same' : to.y.l ? 'diff' : 'new';
                    o.c.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                    to.c.cha || return;
                    #sayyl " - $t $cv has: $dt $dcv ".ki to.c if to.c.cha;
                    o.c.cha.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                }
            }
            if (my $dz = $l && l.sc.bz) {
                my $bz = o.sc.bz;
                G&Chew,$dz,'t,cv',$_ for sub {
                    my ($to,$dt,$dcv) = @_;
                    $bz.>$dt.>$dcv && return;
                    my $m = 'gone';
                    o.c.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                    o.c.cha.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                }
            }
            
            # wires
            # notes from 2 - see upmost o's origin C ref index,
            # contributed to by all under
            if (my $oz = o.sc.oz) {
                for my $on (keys %$oz) {
                    my $to = $oz.>$on;
                    if (to.y.A eq $A) {
                        if (oo.C.>to.t.>to.y.cv eq $to) {
                            #sayre "  -- have $on: to.t to.y.cv";
                        }
                        else {
                            die "$t $cv Dont have $on: to.t to.y.cv ".wdump 2, oo.C;
                            # cha.lost? might be above or below o A
                        }
                    }
                    else {
                        sayre "   ++ $on: to.t to.y.cv from other A";
                    }
                }
            }
            sayyl "$t $cv is from o.y.A.t " if o.y.A ne $A;
            if (!o.y.l) {
                $cha.>$x.>$_.>$t.>$cv = $o for 'new';
                o.c.el = 1;
            }
            elsif (o.c.cha) {
                $cha.>$x.>$_.>$t.>$cv = $o for 'diff';
            }
        };
        G&Chew,$jj,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            $oo.>$x.>$t.>$cv && return;
            say "Goner C.t C.y.cv  --  $x $t $cv ----";
            $cha.>$x.>$_.>$t.>$cv = $o for 'gone';
        };
        !keys %$cha && delete A.c.cha;
        # names -> A fall replace to check inside
        j.sc.oo = $oo;
Compliers: | # othered
    u i
    # join/etc linked lists
    toget:
        G&together,$s,@Me
        
    together: %acgt:k c d
        my $o = c.y.>$k;
        c.y.>$k = $d;
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            d.y.>$ok = $c;
            if ($o) {
                d.y.>$k = $o;
                o.y.>$ok = $d;
            }
        }
    
    apart: %acgt:k c d
        $d ||= c.y.>$k;
        my $o = d.y.>$k;
        delete c.y.>$k;
        if ($o) {
            if ($c eq $o) { # mutual
                delete d.y.>$k;
            }
            else {
                c.y.>$k = $o;
            }
        }
        my $ok = {qw{next prev prev next}}->{$k};
        if ($ok) {
            delete d.y.>$k;
            if ($o) {
                delete d.y.>$ok;
                o.y.>$ok = $c;
            }
        }
        
Walks: | # othering, many C
    u i
    # iterator/map for index
    Chew:
        my $sort;
        my $it = pop @Me if ref $Me[-1] eq 'CODE';
        if (@Me == 1) {
            my $i = shift @Me;
            if (ref $i eq 'SCALAR') {
                $sort = 1;
                $i = $$i;
            }
            @Me = split ',', $i;
        }
        my $in;$in = sub {
            my ($p,$s,$i) = @_;
            if (!@$i || @$i==1 &&
                ref $s ne 'HASH' && $i->[0] =~ /\?$/) {
                return [$s,@$p];
            }
            defined $s || return;
            die "NO ".wdump 3,[$p,$s] if ref $s ne 'HASH';
            shift @$i;
            my @r = keys %$s;
            @r = sort @r if $sort;
            map {
                my $v = $s.>$_;
                $in->([@$p,$_],$v,[@$i]);
            } @r;
            
        };
        my @are = grep{defined} $in->([],$s,[@Me]);
        if ($it) {
            $it->(@$_) for @are 
        }
        else {
            sub { shift @are }
        }
        
    
    # history tables sold separately
    # prop up non val o.c.$cha.$nk.$gk = {}
    # which unify cha ne same into o.c.cha.$cha.$nk.$gk 
    # {} may extend meaning, eg z tys into
    Chang: %acgt:l o
        my $E = l.c.s if $l;
        my $e = o.c.s;
        my @p = (['t'],[y=>'cv'],[c=>{}],[sc=>{}]);
        while (@p) {
            my $p = shift @p;
            my ($nk,$gk) = @$p;
            my $u = $E.>$nk; # Eustobe
            my $v = $e.>$nk; # revelation
            if (ref $gk) {
                keys %$gk == 0 || die "Given a ref: ".ki $gk;
                $gk.>$_++ for keys(%$u), keys (%$v);
                unshift @p, [$nk,$_] for keys %$gk;
                next;
            }
            my $i = {};
            if ($gk) {
                if (!exists $u.>$gk) {
                    o.c.new.>$nk.>$gk = $i;
                }
                elsif (!exists $v.>$gk) {
                    o.c.gone.>$nk.>$gk = $i;
                }
                elsif ($u.>$gk ne $v.>$gk) {
                    o.c.diff.>$nk.>$gk = $i;
                }
                else {
                    o.c.same.>$nk.>$gk = $i;
                }
                
            }
            else {
                if (!exists $E.>$nk) {
                    o.c.new.>$nk = $i;
                }
                elsif (!exists $e.>$nk) {
                    o.c.gone.>$nk = $i;
                }
                elsif ($u ne $v) {
                    o.c.diff.>$nk = $i;
                }
                else {
                    o.c.same.>$nk = $i;
                }
            }
        }
        for (grep { o.c.>$_ } qw'new gone diff') {
            o.c.cha->{$_} = o.c.>$_;
        }
    # osc blinds previous empirica
    Chade:
        my $C = {};
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = s.c.s if exists s.c.s;
        C.sc = {%{s.sc}};
        return $C;
    # make an other holding it
    Chs:
        my $C = {};
        C.y.A = $A;
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = $s;
        return $C;
    # sort by many y.As
    sortysip:
        my $so;$so = sub {
            my ($i,@try) = @_;
            my ($yk) = @try;
            my ($c,$d) = (a.y->{$yk},b.y->{$yk});
            $c && $d || die "sort no y$yk";
            ($c,$d) = (c.c.ip,d.c.ip);
            $c && $d || die "sort noy$yk ip";
            unless (exists $c->[$i] || exists $d->[$i]) {
                shift @try;
                return $so->(0,@try) if @try;
                die "ip sort ran out:\n  ".ki($a)."\n  ".ki($b);
            }
            $c->[$i] <=> $d->[$i]
            || $so->($i+1,@try);
        };
        sort {$so->(0,@Me)} @$s;
    # hash then & now expr
    # goner, project everything onto C
    wtch: %acgt:c d
        my $wt = {};
        wt.same = 1;
        for (keys %$d) {
            if (!exists $c->{$_}) {
                wt.new->{$_} = $d->{$_};
                wt.same = 0;
            } 
            elsif ($d->{$_} ne $c->{$_}) {
                wt.diff->{$_} = $c->{$_};
                wt.same = 0;
            }
            else {
                wt.sami++;
                wt.still->{$_} = $c->{$_};
            }
            wt.tot++;
        }
        for (grep { !exists $d->{$_} } keys %$c) {
            wt.gone->{$_} = $c->{$_};
            wt.same = 0;
        }
        $wt;
    

