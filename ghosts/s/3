Triangle: | # <>< swim, oscillator, s n, 7, 
    u a
    # sevenatim
    # time passes independently of your being in the room
    # once you know about the room
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # C is self for s
        # C is 's many for o
        A.c.s = G&sJ,A.2,'s';
    #c s2 peel ground moments
    s 2:
        # number of things plugged in to s from J
        for my $J (A.2) {
            C.c.>$_ = J.c.>$_ for grep{ J.c.>$_ } qw'whole base';
        }
        if (my $W = c&whole) {
            my $s = G&t,$W || die "no $W";
            G&A,o=>8,$C,$s,'whole';
            # replicates indexen (tv, i, ii) to s
            sayre "WHole! s: A.2.t";
            # place on us
            return T.Z.8 = $A;
        }
        my $tug;
        if (my $W = c&base) {
            my $s = G&t,$W || die "no $W";
            say "Base ! ".ki $s;
            tug.base = G&A,o=>2,$C,$s,'base';
        }
        if (my $n = A.c.n) {
            s&ch = A.2.sc.ch if !defined s&ch;
            s&ch = '' if !defined s&ch;
            my $zip = n.sc.a->{s&ch};
            tug.ground = G&A,o=>2,$C,$zip,'zip';
        }
        $tug || die "No ground to A.2.t";
        c&zip = G&A,o=>6,$C,$tug,'zipover';
        G&A,c&zip=>6;
    #c s3 J t/y
    # ordered diff creates O's for awakened C 
    # hold the top and all in or out
    s 3:
        say "s3   A.2.t";
        my $o = c&zip;
        my $c = oc&s;
        my $j = cc&j || die "No o Acj! ".ki$c;
        # put through Hoop to make index & self
        
        A&inz = [map {
            my $O = G&A,O=>1,$_;
            a&topO = $O if os&top eq $_;
            my $c = O.c.s;
            c.y.x.y.O = $O;
            my $r = c.y.r || die "No yr: ".ki$c;
            Oc&el = rc&el if rc&el;
            Oc&osc = $C;
            $O
        } @{os&inz}];
        
        A&outz = [map {
            _.y.x.y.O || die "out not yxyO: ".ki $_;
        } @{os&outz}];
        
        G&A,$_,0.5 for @{A&inz};
        
    #c s4 humming
    # elsward going index posited awake
    s 4:
        s&swim ||= {};
        s&swam = {};
        for my $O (@{A&inz}) {
            my $c = O.c.s;
            my $X = c.y.x.y.X;
            Os&swim || Xs&swim || next;
            G&chew,Os&swim,'W,Wt,Wcv',$_ for sub {
                my ($etv,$W,$Wt,$Wcv) = @_;
                s&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv} = $c;
                s&swam ->{$W}->{$Wt}->{$Wcv}++;
            };
            G&chew,Xs&swim,'W,Wt,Wcv',$_ for sub {
                my ($etv,$W,$Wt,$Wcv) = @_;
                Os&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv} && return;
                delete s&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv};
                s&swam ->{$W}->{$Wt}->{$Wcv}++;
            };
            c.y.x.y.X = $O;
        }
        for my $X (@{A&outz}) {
            my $c = X.c.s;
            G&chew,Xs&swim,'W,Wt,Wcv',$_ for sub {
                my ($etv,$W,$Wt,$Wcv) = @_;
                delete s&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv};
                s&swam ->{$W}->{$Wt}->{$Wcv}++;
            };
        }
    #c s5 across the wormhole
    # things have animal desires
    s 5:
        A&ytWe = {};
        G&chew,s&swam,'W,Wt,Wcv',$_ for sub {
            my ($ctv,$W,$Wt,$Wcv) = @_;
            $ctv = s&swim ->{$W}->{$Wt}->{$Wcv};
            
            my $yt = G&yttv,$ctv;
            my $z = [];
            G&chew,$yt,\'cv,t' for sub {
                my ($c,$cv,$t) = @_;
                my $O = c.y.A;
                my $etv = Os&swim ->{$W}->{$Wt}->{$Wcv};
                # from this c's pushing to Wtcv
                G&chew,$etv,'t,cv' for sub {
                    my ($es,$t,$cv) = @_;
                    # the pushed thing, probably c itself
                    push @$z, $es;
                };
            };
            if (my $al = A&ytWe ->{$Wcv}->{$Wt}) {
                die "swim $W $Wt $Wcv already al.c.W";
            }
            my $e = G&Ct,[Swim=>3,{z=>$z}];
            A&ytWe ->{$Wcv}->{$Wt} = G&Ct,[$Wt=>$Wcv,{W=>$W,e=>$e}];
        };
        sayyl "s5   A.2.t";
    #c s6 goes
    s 6:
        # going - figure difference under top with osc'd
        my $t = a&topO;
        $t = t.c.s;
        my $tv = t.y.tv;
        # all the O under top
        my $z = [map{
            my $x = _.y.x || die "no yx bridge: ".ki$_;
            my $O = x.y.O || die "No yxyO on ".ki$_;
            O.c.s
        }map{values%$_}values%$tv];
        
        # and W returns
        G&chew,A&ytWe,\'Wcv,Wt',$_ for sub {
            my ($We,$Wcv,$Wt) = @_;
            # Tunnel e wants to know in general:
            #   We may provide forms of ground to return results
            #   e z may o and send diffs depending on connection
            # for now modemless e.c.z in, n.sc.z out
            my $n = 
            n $We
            my $W = n.c.s;
            say wdump 5, ["GOt n: ",$n];
            my $D = G&Ct,[$Wt=>$Wcv,{W=>We.c.W}];
            D.sc.z = W.sc.z || die "W no z ".ki$W;
            push @$z, $D;
        };
        
        $t = G&hup,$t;
        delete t.y.in;
        t.sc.z = $z if @$z;
        
        1 && sayyl "Top: $t ".(t.y.in && " yin   ").ki$t;
        1 && sayyl "mid: $_  _.t _.y.cv    y:"
            .join(',',sort keys %{_.y})."   ".ki(_.c)."   ".ki _.sc for @$z;
        
        c&zop = G&A,o=>6,$C,$t,'zopul';
    #c s7 traction/compress
    s 7:
        # pack down goods
        # zops are el and change Cs, 
        my $o = c&zop;
        A&zop = [map {
            my $O = G&A,K=>1,$_;
            my $r = _.y.r || die "No r: ".ki$_;
            Oc&el = rc&el if rc&el;
            Oc&osc = $C;
            $O
        } @{os&zop}];
        
        G&A,$_=>8 for @{A&zop};
        
        s&lastA = $A;
    
    #c s8 transmission
    s 8:
        # tie together
        A.c.expo.>$_ = 1 for qw'tv i ii';
        A.2.sc.>$_ = C.sc.>$_ for keys %{A.c.expo};
        A.2.c.o = "Steved ".++C.c.imp;
        # send out
    
    
Komp: | # K/D line protoClattice
    u a
    K 1:
        A.c.s = shift @$s; # us
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        1 && sayyl "To compress: C.y.cv  C.t   ".ki(C.c)."      ".ki(C.sc||{});
    D 2:
        # reverse it
    
Hoop: | # osc art, colour in
    u a
    O 1:
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = G&hup,A&from;
    O 2:
        C.y.A = $A;
        return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    O 4:
        for my $W ('of') {
            if (my $Wt = C.sc.>$W) {
                my $Wcv = 0.001;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
            }
        }
    
Circle: | # < copy things
    u a
    # listen, insward, moral law, has to give us power
    
    # cases:
    #  J.i <- o.i
    #  - i porty recur bit (G&offis) J.sc.jo.>$t tells non-$o of overwrites
    #  - recur bit J..b.i.>$o <- last C we make 
    #  - may see lv/otherness settling clues on o
    #  - knows i means pull o.i as t=>s
    #  - float C forms from k>v data, etc
    #  - c&noz to avoid diving into y.in/y.next 
    # so around t/cs/sc the other stff
    #
    # eats other, splats self 
    # the splat modes of ts, tv (shade c), 
    
    #c o1 all making a big rising of data, you could 
    o 1:
        my ($i,$f,$t) = @$s;
        i.y eq $i || die "i must A";
        
        defined $f || die "from undef o $t";
        
        ($f,my $fis) = ($$f,1) if ref $f eq 'REF';
        $t = G&Ct,$t if ref $t eq 'ARRAY';
        %$C = %$t if ref $t eq 'HASH';
        C.t = $t if $t && !ref $t;
        
        
        c&i = $i;
        c&m ||= C.t;
        c&m = 'zip' if c&m =~ /^zip(.+)$/;
        if (ref $f eq 'ARRAY') {
            c&m = 'z';
            c&s = $f;
        }
        elsif ($fis) {
            c&s = $f;
        }
        elsif (f.y) {
            if (f.y eq $f) {
                # A/J
                c&h = $f;
            }
            else {
                # C mo 3 W:of ...
                #  C mo 1 s:... of:mo,dig:...
                # y.in or sc.z
                c&s = $f;
                c&m = 'C';
            }
        }
        else {
            # a zip
            c&s = $f;
        }
        if (c&m eq 'i' || c&m eq 'ii') {
            c&kno = c&m;
        }
        if (c&kno) {
            my $h = c&h || die "unhoused kno C.t m:c&m";
            c&s = h.sc->{c&kno} || $h->{c&kno};
            # may have lvism & more via h.sc.s.
        }
    #c o2 intermediate whats-where, diff o/oo per zing
    o 2:
        my $oo = A.c.oo = {};
        # < space-for (C) < t < y [many o with .c.s = $e, o.y.etc = etc]
        # per other itself in 3, way in is noise-ish
        if (c&m eq 'zip') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                v.y && v.y eq $v || die "zip yon not A";
                next if $v eq $A;
                # light cones holding C or doing another o bunch
                my $D = v.c.s;
                if (v.t eq 'o') {
                    # D is inner o's C - index windups
                    D.c.i eq c&i || die "o oth i C.c.i.t <-> D.c.i.t";
                    D.c.j && die "o D.c.t already got j";
                    D.c.jC && die "o D.c.t already got jC";
                    D.c.jC = $C;
                    my $ii = v.c.oo || die "Too early to oo: D.t";
                    my $i = 0;
                    for my $t (keys %{ii.C}) {
                        my $vs = ii.C->{$t};
                        for my $cv (keys %$vs) {
                            my $os = $vs->{$cv};
                            push @{oo.C->{$t}->{$cv}||=[]}, map {
                                $_ = G&hup,$_;
                                $_
                            } @$os;
                            $i++ for @$os;
                        }
                    }
                    say "A.t A.c.sip C.t claims $i from: v.t v.c.sip D.t";
                }
                else {
                    # D is J moment C material to shade
                    my $e = G&hup,$D;
                    my $o = G&Chs,$e;
                    o.y.D = $D;
                    o.y.R = $v;
                    o.y.k = $k;
                    push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
                }
            }
        }
        elsif (c&m eq 'i') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # inflated t -> s
                my $e;
                e.t = $k;
                e.y.cv = 0.1;
                e.c.s = $v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'ii') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # t -> C
                my $e = G&hup,$v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'C') {
            # C
            my $S = c&s;
            my $pr;
            while ($S) {
                my $e = G&hup,$S;
                my $o = G&Chs,$e,$S;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
                if ($pr) {
                    o.sc.oz.yprev = $pr;
                    pr.sc.oz.ynext = $o;
                }
                $pr = $o;
                $S = S.y.next;
            }
        }
        elsif (c&m eq 'z') {
            # whole [ C... ], not rl
            for my $S (@{ c&s }) {
                my $e = G&hup,$S;
                my $o = G&Chs,$e;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'rl') {
            # rl same array growing more el=3 updatey dives
            # make A.c.r from el=3
            die "code rl";
            A.cv = 0.599;
        }
        else {
            die "How to read ".ki $C;
        }
        
    #c o3 make diff
    o 3:
        # opens recursive shop on i called j using C.t
        my $j = G&offis,i=>j=>'t';
        j.c.Co = $C;
        my $jj = j.sc.oo;
        my $oo = A.c.oo;
        my $cha = A.c.cha ||= {};
        # falls until array, oo.C.t.cv = [thamany]
        G&Chew,$oo,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            my @o = @$o;
            
            # sort by zipped from A sips
            @o = G&sortysip,$o,'A','R' if @o > 1;
            # later overwrite
            @o = reverse @o;
            
            sayre join"\n","Dupl: ",map{"  $t $cv from _.y.A.c.s.t"}@o if @o > 1;
            
            $o = $o[0];
            my $e = o.c.s;
            
            $oo.>$x.>$t.>$cv = $o;
            
            my $l = $jj.>$x.>$t.>$cv;
            o.y.l = $l if $l;
            # todo weaken l.y.l
            
            G&Chang,$l,$o;
            
            # throw inward (yin falls to z)
            # we 6 yin/ynext meshi
            if (my $z = e.y.in || e.sc.z) {
                my $t = {t=>"C.t/z $t $cv"};
                t.c.jC = $C;
                t.c.oup = $o;
                push @{A&notafterfive||=[]},
                G&tugA,o=>1,c&i,$z,$t
                    unless c&noz;
            }
            
            # ty in above o
            sayyl "$t $cv is from o.y.A.c.s.t" if o.y.A ne $A;
            
            if (my $u = c&oup) {
                if (my $al = u.sc.bz.>$t.>$cv) {
                    #sayre "ALREADY a C.t: on u.t: $t $cv from al.y.A.c.s.t: al.t al.y.cv";
                    # zip hup'd acquired o but still..?
                }
                o.y.up = $u;
                u.sc.bz.>$t.>$cv = $o;
                #sayyl "Place u.t u.y.cv $u (u.y.A.c.s.t) from C.t: o.t o.y.cv $o";
            }
        };
    #c o4 A -> J t/y images
    #
    o 4:
        my $j = c&j;
        my $jj = j.sc.oo;
        my $oo = A.c.oo;
        my $cha = A.c.cha ||= {};
        G&Chew,$oo,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            my $l = o.y.l; # last o
            
            # o.sc.bz.$t.$cv inward check
            my $sc = 'sc';
            my $z = 'z';
            if (my $bz = o.sc.bz) {
                G&Chew,$bz,'t,cv',$_ for sub {
                    my ($to,$dt,$dcv) = @_;
                    
                    my $m = !to.c.cha ? 'same' : to.y.l ? 'diff' : 'new';
                    o.c.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                    to.c.cha || return;
                    #sayyl " - $t $cv has: $dt $dcv ".ki to.c if to.c.cha; 
                    o.c.cha.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                }
            }
            if (my $dz = $l && l.sc.bz) {
                my $bz = o.sc.bz;
                G&Chew,$dz,'t,cv',$_ for sub {
                    my ($to,$dt,$dcv) = @_;
                    $bz.>$dt && $bz.>$dt.>$dcv && return;
                    my $m = 'gone';
                    o.c.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                    o.c.cha.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                }
            }
            
            # wires
            # notes from 2 - see upmost o's origin C ref index,
            # contributed to by all under
            if (my $oz = o.sc.oz) {
                for my $on (keys %$oz) {
                    my $to = $oz.>$on;
                    if (to.y.A eq $A) {
                        if (oo.C.>to.t && oo.C.>to.t.>to.y.cv eq $to) {
                            #sayre "  -- have $on: to.t to.y.cv";
                        }
                        else {
                            die "$t $cv Dont have $on: to.t to.y.cv ".wdump 2, oo.C;
                            # cha.lost? might be above or below o A
                        }
                    }
                    else {
                        sayre "   ++ $on: to.t to.y.cv from other A";
                    }
                }
            }
            
            if (!o.y.l) {
                $cha.>$x.>$_.>$t.>$cv = $o for 'new';
                o.c.el = 1;
            }
            elsif (o.c.cha) {
                $cha.>$x.>$_.>$t.>$cv = $o for 'diff';
            }
        };
        G&Chew,$jj,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            $oo.>$x && $oo.>$x.>$t && $oo.>$x.>$t.>$cv && return;
            say "Goner C.t C.y.cv  --  $x $t $cv ----";
            $cha.>$x.>$_.>$t.>$cv = $o for 'gone';
        };
        !keys %$cha && delete A.c.cha;
        # names -> A fall replace to check inside
        j.sc.oo = $oo;
    
    #c o5 join changed o as r (with el=3) by yt
    #
    o 5:
        my $oo = A.c.oo;
        my $cha = A.c.cha;
        die 'more than ooC: '.ki $oo if 1 != keys %$oo;
        # make ty -> yt
        my $ty = oo.C;
        my $oty = $cha && cha.C && cha.C.gone;
        my $yt = G&yttv,grep{defined}$ty,$oty;
        
        # iterate by yt
        my $la;
        my @z;
        G&Chew,$yt,\'cv,t',$_ for sub {
            my ($o,$cv,$t) = @_;
            my $l = o.y.l;
            my $E = l.c.s;
            my $e = o.c.s;
            my $cha = o.c.cha;
            my $r;
            r.t = $t;
            r.y.A = $A;
            r.y.cv = $cv;
            r.c.o = $o;
            if ($oty.>$t && $oty.>$t.>$cv) {
                # $o is last there
                # above knows on goneyt when there is no more z
                r.c.el = 9; # not here
                push @z, $r;
                $la = $r;
                return;
            }
            elsif ($cha) {
                if (cha.new && cha.new.t) {
                    r.c.el = keys %{ $ty.>r.t } == 1 ? 2 : 1;
                }
                else {
                    r.c.el = 3; # or 4 if only z more?
                }
            }
            else {
                r.c.el = 8;
                $la = $r;
                return
            }
            
            #c make co.path -> {nodestuff,co} trees
            my $co = r.sc.co ||= {};
            G&Chew,$cha,\'m,nk,gk?',$_ for sub {
                my ($wa,$m,$nk,$gk) = @_;
                return if $nk eq 'y' && $gk eq 'cv' && $m eq 'new';
                my $xe = $cha.>$m.>$nk;
                my $oe = $E.>$nk;
                my $ne = $e.>$nk;
                $xe = $xe.>$gk if @_ == 4;
                $oe = $oe.>$gk if @_ == 4;
                $ne = $ne.>$gk if @_ == 4;
                my $co = r.sc.co.co.>$nk ||= {};
                $co = co.co.>$gk ||= {} if @_ == 4;
                co.o = $oe;
                co.v = $ne unless $m eq 'gone';
                co.p = [$nk];
                co.m = $m;
                push @{co.p}, $gk if @_ == 4;
                if ($nk eq 'sc' && $gk eq 'z') {
                    my $wi;
                    G&Chew,$xe,\'t,cv',$_ for sub {
                        my ($zb,$t,$cv) = @_;
                        $wi++;
                        if ($m eq 'gone') {
                            co.goneyt.>$cv.>$t = $zb;
                        }
                        else {
                            co.ytm.>$cv.>$t.>$m = $zb;
                            co.Ams.>_.c.sip = $_ for zb.y.A;
                        }
                    };
                    my $sm = '=';
                    $sm = "+" if $m eq 'new';
                    $sm = "-" if $m eq 'gone';
                    co.sv .= "$sm$wi";
                }
            };
            #c co.paths in order make dis/z d microCs:
            # r tcv, c&o, c.z inside r, c.dis z d:   (climbs Cs)
            # d t=nk/gk, s=value, sc.z=inside d      (climbs paths)
            my $or;$or = sub { 
                my $co = shift; # outside/index
                my ($he,$ta) = ([],[]);
                my $tw;
                # nk/gk ordering
                for ([$he=>qw't cv y c sc'],
                    [$ta=>qw's z']) {
                    my ($l,@l) = @$_;
                    for my $t (@l) {
                        $co.>$t || next;
                        $tw.>$t ++;
                        push @$l, $t;
                    }
                }
                my @mi = sort grep { !$tw.>$_ } keys %$co;
                my $z = [];
                for my $t (@$he,@mi,@$ta) {
                    my $co = $co->{$t}; # inside/state
                    my $d;
                    d.t = $t;
                    my $zort;
                    if (co.co && keys %{co.co}) {
                        die "More to mid co: ".wdump 3, $co if keys %$co > 1;
                        d.sc.z = $or->(co.co);
                    }

                    if (co.ytm) {
                        my @mu = values %{co.Ams};
                        @mu = G&sortysip,\@mu,'1' if @mu > 1;
                        for my $oi (@mu) {
                            my $z = oi.c.r || sayre("no r on A.t A.cv A.c.s.t   from oi.t oi.cv  oi.c.s.t") && next;
                            push @{r.c.z||=[]},  @$z;
                        }
                        if (@mu > 1) {
                            sayre "Many A below r.t r.y.cv: ".ki co.Ams;
                            $zort = 1;
                        }
                    }

                    if (my $gt = co.goneyt) {
                        r.c.z ||= [];
                        # yonder thing disappears (maybe no A)
                        my @rm;
                        G&Chew,$gt,'cv,t',$_ for sub {
                            my ($d,$cv,$t) = @_;
                            my $zr;
                            zr.t = $t;
                            zr.y.cv = $cv;
                            zr.c.el = 9;
                            push @rm, $zr;
                        };
                        my @mr;
                        for my $zr (@rm) {
                            my $got;
                            @{r.c.z} = map {
                                _.t eq zr.t && _.y.cv eq zr.y.cv
                                    ? do { $got = 1; $zr }
                                    : $_
                            } @{r.c.z};
                            $got || push @mr, $zr;
                        }
                        # breaks el=8/previous thing ness?
                        if (@mr) {
                            push @{r.c.z}, @mr;
                            $zort = 1;
                        }
                    }

                    @{r.c.z} = sort {a.y.cv <=> b.y.cv || a.t cmp b.t} @{r.c.z}
                        if $zort;

                    for (qw'sv o m p') {
                        exists $co.>$_ || next;
                        d.c.>$_ = $co.>$_;
                    }
                    d.c.s = co.v if exists co.v;
                    push @$z, $d;
                }
                $z;
            };
            r.c.dis = $or->(co.co);

            push @z, $la if $la ne $z[-1] && r.c.el ne 3;
            push @z, $r;
            $la = $r;
        };
        _.cv = 0.9 for @{delete(A&notafterfive)||[]};
        A.c.r = \@z;
        
    #c o57 r -> rs, rsl readable/testable change text
    o 57:
        # r are ty and c.el=? of change
        #  c.dis is from $or, j describing co paths of change into C, in order
        #    j.sc.z is more j
        #  c.z is r children
        # (o should grow to know non-z things in things unis)
        
        # recurse branches of the C for display
        my $ja;$ja = sub {
            my ($d,$e) = @_;
            $e = $e.>d.t;
            my $etc;
            if (exists d.c.sv) {
                $etc = d.c.sv;
            }
            elsif (exists d.c.s) {
                my $m = '=';
                $m = "+" if d.c.m eq 'new';
                $m = "-" if d.c.m eq 'gone';
                my $s = d.c.s;
                if (length $s > 24) {
                    $s = slim(19,$s).'h'.slm(6,dig($s));
                }
                $s =~ s/\n/\\n/sg;
                $etc = $m.$s;
            }
            my @l = "d.t$etc";
            if (my $z = d.sc.z) {
                push @l,'{';
                my @lo = map {
                    $ja->($_, $e)
                } @$z;
                push @l, @lo;
                push @l, '}';
            }
            @l;
        };
        
        # climb the r
        # rs is array of arrays of display strings and more rs
        my $rs;$rs = sub {
            my ($z) = @_;
            my @r;
            for my $r (@$z) {
                my @l;
                push @l, r.t, r.y.cv;
                my $ul = {map{!ref r.c.>$_ ? ($_ => r.c.>$_ ) : ()}keys %{r.c}};
                push @l, ki $ul if keys %$ul;

                if (my $o = r.c.o) {
                    my $e = o.c.s || die "no ocs".ki$r;
                    if (my $dis = r.c.dis) { # change display elements
                        push @l, $ja->($_,$e) for @$dis
                    }
                    if (my $z = r.c.z) { # inside lines
                        push @l, $rs->($z);
                    }
                }
                sayre "Havenodis: ".ki $r if !@l;
                push @r, \@l;
            }
            \@r
        };
        
        A.c.rs = $rs->(A.c.r);
        
        # collapse rs
        # rsl is array of indented strings
        my $rsl;$rsl = sub {
            my ($x,$ind) = @_;
            $ind .= '  ';
            my $l = [];
            for my $d (@$x) {
                my $x = [];
                my $s = $ind . join ' ', grep { !ref$_ || do{push@$x,$_;0} } @$d;
                push @$l, $s;
                map { push @$l, @$_ }
                $rsl->($_,$ind) for @$x;
            }
            $l
        };
        
        A.c.rsl = $rsl->(A.c.rs);
    #c o6 r growth happens to our objects
    # we can skip into here with another o's r or rl converted to r
    # r tcv, el=3, o=$o?, dis=z j, z=inside r
    o 6:
        my $j = G&offis,i=>j=>'t';
        j.c.Co = $C;
        my @r = @{A&r};
        
        # we may have root elected by .c.root from the many
        my @root = grep { _.c.o && _.c.o.c.s.c.root } @r;
        @root > 1 && die "More than 1 root";
        for (@root) {
            if (my $root = js&root) {
                _.t eq root.t && _.y.cv eq root.y.cv
                    || die "Root wanders: ".ki({f=>$root,t=>$_});
            }
            js&root = $_;
        }
        # attach things in general to ...
        if (@r) {
        if (my $root = js&root) {
            if (!@root) {
                # make up r of el=3 to z=etc, put things in
                my $r = {};
                r.t = root.t;
                r.y.cv = root.y.cv;
                r.c.el = '3';
                r.c.z = [@r];
                @r = $r;
            }
            else {
                push @{root.c.z||=[]}, grep {$_ ne $root} @r;
                @r = $root;
            }
        }
        }
        
        my $tcvis = sub {
            my ($x,$y) = @_;
            x.t eq y.t && x.y.cv eq y.y.cv
        };
        # part of relink, sweep into Compliers with in->next corner
        my $unshiftover = sub {
            my ($l,$in) = @_;
            if ($tcvis->($l,$in)) {
                # replace self
                if (my $ne = in.y.next) {
                    l.y.next = $ne;
                    ne.y.prev = $l;
                }
            }
            else {
                # first becomes next
                l.y.next = $in;
                in.y.prev = $l;
            }
        };
        # attribute hammer
        my $dis;$dis = sub {
            my ($c,$z,$ch) = @_;
            for my $d (@$z) {
                if (ds&z) {
                    my $con = $c.>d.t ||= {};
                    my $ch = ch.K.>d.t ||= {}; # like co
                    $dis->($con,ds&z,$ch);
                }
                if (exists dc&s) {
                    ch.set.>d.t =
                    $c.>d.t = dc&s;
                }
                if (dc&m eq 'gone') {
                    ch.drop.>d.t = 1;
                    delete $c->{d.t};
                }
            }
        };
        # all as in changed or 3/8fected by change
        my @aro; # flat list of our changed or el=8ing C, ordered descent
        my @zop; # all change minima with c.el=?
        my @in; # all el < 8 (happenings)
        my @out; # all el == 9 (goners)
        # something just el3ing for z will be in
        my $ro;$ro = sub {
            my ($z,$up) = @_;
            my $la;
            for my $r (@$z) {
                # our C - the object for the other
                my $l = up.y.tv->{r.t}->{r.y.cv};
                my $new;
                if (!$l) {
                    $new = 1;
                    rc&el < 3 || die "Upel no hist ".ki($r).wdump 3, $j;
                    l.t = r.t;
                    l.y.cv = r.y.cv;
                }
                # has this 
                my $x = l.y.x ||= {t=>l.t,y=>{cv=>l.y.cv}};
                
                #c relink our C
                if (rc&el < 3) {
                    my $ol = $l;
                    if (!$new) {
                        # rl over/replace
                        $l = {};
                        l.t = r.t;
                        l.y.cv = r.y.cv;
                        $la ||= ol.y.prev;
                    }
                    if (!$la) {
                        # becomes first
                        my $in = up.y.in;
                        up.y.in = $l;
                        # TODO way out first + last?
                        $unshiftover->($l,$in) if $in;
                    }
                    else {
                        my $on = la.y.next;
                        la.y.next = $l;
                        l.y.prev = $la;
                        $unshiftover->($l,$on) if $on;
                    }
                }
                elsif (rc&el eq '9') {
                    my $prev = l.y.prev;
                    my $next = l.y.next;
                    if (up.y.in eq $l) {
                        $prev && die "First with prev: ".ki$l;
                        if ($next) {
                            up.y.in = $next;
                        }
                        else {
                            # empties
                            delete up.y.in;
                        }
                    }
                    if ($prev && $next) {
                        prev.y.next = $next;
                        next.y.prev = $prev;
                    }
                    elsif ($prev) {
                        delete prev.y.next;
                    }
                    elsif ($next) {
                        delete next.y.prev;
                    }
                }
                
                #c throw dis across
                # zop is l changed only and el=?
                my $ch = {};
                $dis->($l,rc&dis,$ch) if rc&dis;
                
                my $zop;
                zop.t = l.t;
                zop.y.cv = l.y.cv;
                zop.y.l = $l;
                zop.y.r = $r;
                die "zop change already contains el: ".ki$zop if zop.c.el;
                zop.c.el = r.c.el;
                for my $nk (sort keys %{ch.K||{}}) {
                    my $gh = ch.K.>$nk;
                    if (my $s = gh.set) {
                        $zop.>$nk.>$_ = $s.>$_ for keys %$s;
                    }
                    if (my $drop = gh.drop) {
                        my @gks = sort keys %$drop;
                        my $k = "drop$nk";
                        exists zop.c.>$k && die "zop already c.$k: ".ki$zop;
                        zop.c.>$k = join ',', @gks; # TODO texty line safety
                    }
                }
                push @zop, $zop;
                #
                l.y.r = $r;
                
                # internal index building, really 7 cos
                if (rc&el eq '9') {
                    push @out, $l;
                    my $tvt = up.y.tv.>l.t;
                    delete $tvt.>l.y.cv;
                    delete up.y.tv.>l.t if !keys %$tvt;
                    delete up.y.tw->{l.t} if up.y.tw->{l.t} eq $l;
                }
                elsif (rc&el ne '8') {
                    push @in, $l;
                    up.y.tv->{l.t}->{l.y.cv} = $l;
                    up.y.tw->{l.t} = $l;
                    # TODO ^ unless already by > other
                    # and backwards if other leaves
                }
                push @aro, $l;
                
                $ro->(rc&z,$l) if rc&z;
                
                $la = $l;
            }
        };
        
        $ro->(\@r,$j);
        
        a&aroz = \@aro;
        a&zop = \@zop;
        a&inz = \@in;
        a&outz = \@out;
        a&top = j.y.in || sayre "No toplevel! ".wdump 4, $j;
        

