Circle: | # < copy things
    u a
    # listen, insward, moral law, has to give us power
    
    # cases:
    #  J.i <- o.i
    #  - i porty recur bit (G&offis) J.sc.jo.>$t tells non-$o of overwrites
    #  - c&m modulation floats C forms from k>v data, etc
    #  - c&noz or c&nonext to avoid diving into sc.z/y.in or y.next
    #
    # eats other, splats self 
    # the splat modes of ts, tv (shade c), 
    
    #c o1 all making a big rising of data, you could
    # C is the desire to move the oo C
    o 1:
        my ($i,$f,$t,$c) = @$s;
        ref $i eq 'HASH' && i.y || die "i must A/C";
        defined $f || die "from undef o ".ki$t;
        
        $t = G&Ct,$t if ref $t eq 'ARRAY';
        %$C = %$t if ref $t eq 'HASH';
        C.t = $t if $t && !ref $t;
        C.c = $c if $c;
        
        c&i = $i;
        c&m = 'zip' if C.t =~ /^zip\w+$/;
        if (ref $f eq 'ARRAY') {
            # bunch of C
            c&m = 'z';
        }
        elsif (f.y) {
            if (f.y eq $f) {
                # A/J
                # try f.sc.top
                c&m = 'A';
            }
            else {
                # C mo 3 W:of ...
                #  C mo 1 s:... of:mo,dig:...
                # y.in or sc.z
                c&m ||= 'C'; # may be treated as A if 9
            }
        }
        else {
            # a zip
        }
        c&m ||= C.t;
        c&s = $f;
    #c o2 intermediate whats-where, diff o/oo per zing
    o 2:
        my $oo = A.c.oo = {};
        # resolving to stuff
        if (c&m eq 'A') {
            my $s = c&f = c&s;
            my $top = ss&top || s.y.in
                || die "o A from no sc top or yin: ".ki$s;
            c&finds.i = 1 if ss&i;
            c&finds.ii = 1 if ss&ii;
            c&s = $top;
            c&m = 'C';
        }
        # eating stuff
        # < space-for (C) < t < y [many o with .c.s = $e, o.y.etc = etc]
        # per other itself in 3, way in is noise-ish
        if (c&m eq 'zip') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                v.y && v.y eq $v || die "zip yon not A ".wdump 2, c&s;
                next if $v eq $A;
                next if v.c.T && v.c.T.not;
                # light cones holding C or doing another o bunch
                my $D = v.c.s;
                if (v.t eq 'o') {
                    # D is inner o's C - index windups
                    D.c.i eq c&i || die "o oth i C.c.i.t <-> D.c.i.t";
                    D.c.j && die "o D.c.t already got j";
                    D.c.jC && die "o D.c.t already got jC";
                    D.c.jC = $C;
                    my $ii = v.c.oo || die "Too early to oo: D.t";
                    my $i = 0;
                    for my $t (keys %{ii.C}) {
                        my $vs = ii.C->{$t};
                        for my $cv (keys %$vs) {
                            my $os = $vs->{$cv};
                            push @{oo.C->{$t}->{$cv}||=[]}, map {
                                $_ = G&hup,$_;
                                $_
                            } @$os;
                            $i++ for @$os;
                        }
                    }
                    say "A.t A.c.sip C.t claims $i from: v.t v.c.sip D.t";
                }
                else {
                    # D is J moment C material to shade
                    my $e = G&hup,$D;
                    my $o = G&Chs,$e;
                    o.y.D = $D;
                    o.y.R = $v;
                    o.y.k = $k;
                    push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
                }
            }
        }
        elsif (c&m eq 'i') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # inflated t -> s
                my $e;
                e.t = $k;
                e.y.cv = 0.1;
                e.c.s = $v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'ii') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # t -> C
                my $e = G&hup,$v;
                my $o = G&Chs,$e;
                o.y.k = $k;
                o.y.D = $v;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'C') {
            # C
            my $S = c&s;
            my $pr;
            while ($S) {
                !defined S.t && die "Dodge o m=C: ".wdump 3,
                    ["ot: C.t",S=>$S,after=>$pr];
                my $e = G&hup,$S;
                my $o = G&Chs,$e,$S;
                o.y.D = $S;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
                if ($pr) {
                    o.sc.oz.yprev = $pr;
                    pr.sc.oz.ynext = $o;
                }
                $pr = $o;
                $S = S.y.next;
                undef $S if c&nonext;
            }
        }
        elsif (c&m eq 'z') {
            # whole [ C... ], not rl
            for my $S (@{ c&s }) {
                !defined S.t && die "Dodge o m=z: ".wdump 3, [$S];
                my $e = G&hup,$S;
                my $o = G&Chs,$e;
                o.y.D = $S;
                push @{oo.C->{o.t}->{o.y.cv}||=[]}, $o;
            }
        }
        elsif (c&m eq 'rl') {
            # rl same array growing more el=3 updatey dives
            # make A.c.r from el=3
            die "code rl";
            T.Z.599 = 1;
        }
        else {
            die "How to read ".ki $C;
        }
        
    #c o3 make diff
    o 3:
        # opens recursive shop on i called j using C.t
        my $j = G&offis,i=>j=>'t';
        j.c.Co = $C;
        my $jj = j.sc.oo;
        my $oo = A.c.oo;
        my $cha = A.c.cha ||= {};
        # falls until array, oo.C.t.cv = [thamany]
        my $dupytt;
        G&Chew,$oo,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            my @o = @$o;
            
            # sort by zipped from A sips
            @o = G&sortysip,$o,'A','R' if @o > 1;
            # later overwrite
            @o = reverse @o;
            
            if (@o > 1) {
                for (@o) {
                    my $At = _.y.A && _.y.A.c.s && _.y.A.c.s.t;
                    push @{$dupytt.>$cv.>$t.>$At ||= []}, $_;
                }
            }
            
            $o = $o[0];
            my $e = o.c.s;
            
            map { $_ eq 's' || delete e.c.>$_ } keys %{e.c}
                if c&shade;
            
            $oo.>$x.>$t.>$cv = $o;
            
            my $l = $jj.>$x.>$t.>$cv;
            o.y.l = $l if $l;
            o.y.j = $j;
            # todo weaken l.y.l
            
            if (my $J = c&shade && ref es&J && es&J) {
                die "J also has z: ".ki$e if e.sc.z;
                if (my $lv = J.sc.s && J.sc.s.sc.lv) {
                    # see tips of other J
                    # TODO look at specific page of all the s,
                    # quick check of lv layery linkage, a shallow z
                    # may just signal the version change to go and get (beyond o)
                    # ideally lv0 stable and lv1+ replaces often
                    if (J.c.o) {
                        e.c.Jo = J.c.o;
                    }
                    else {
                        #G.ouJ = $J;
                        warn "Jo not ready e.t e.y.cv: ".G&sn;
                    }
                }
            }
            
            # throw inward (yin falls to z)
            # we 6 yin/ynext meshi
            if (my $z = e.y.in || e.sc.z) {
                my $t = {t=>"C.t/z $t $cv"};
                t.c.jC = $C;
                t.c.oup = $o;
                push @{A&notafterfive||=[]},
                G&tugA,o=>1,c&i,$z,$t
                    unless c&noz;
            }
            delete e.sc.z;
            
            # top acum o.y.D for relinkage
            G&Chang,$l,$o;
            
            
            # ty in above o
            sayyl "$t $cv is from o.y.A.c.s.t" if o.y.A ne $A;
            
            if (my $u = c&oup) {
                if (my $al = u.sc.bz.>$t.>$cv) {
                    # already
                }
                o.y.up = $u;
                # place above
                u.sc.bz.>$t.>$cv = $o;
            }
        };
        C.t =~ /^zopul/ ||
        G&Chew,$dupytt,'cv,t,At',$_ for sub {
            my ($o,$cv,$t,$At) = @_;
            my $times = 'x'.@$o;
            sayre "Dupe A.1.t o C.t $times: $cv $t: $At";
        };
    #c o4 A -> J t/y images
    #
    o 4:
        my $j = c&j;
        my $jj = j.sc.oo;
        my $oo = A.c.oo;
        my $cha = A.c.cha ||= {};
        G&Chew,$oo,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            my $l = o.y.l; # last o
            
            # o.sc.bz.$t.$cv inward check
            my $sc = 'sc';
            my $z = 'z';
            if (my $bz = o.sc.bz) {
                G&Chew,$bz,'t,cv',$_ for sub {
                    my ($to,$dt,$dcv) = @_;
                    
                    my $m = !to.c.cha ? 'same' : to.y.l ? 'diff' : 'new';
                    o.c.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                    to.c.cha || return;
                    #sayyl " - $t $cv has: $dt $dcv ".ki to.c if to.c.cha; 
                    o.c.cha.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                }
            }
            if (my $dz = $l && l.sc.bz) {
                my $bz = o.sc.bz;
                G&Chew,$dz,'t,cv',$_ for sub {
                    my ($to,$dt,$dcv) = @_;
                    $bz.>$dt && $bz.>$dt.>$dcv && return;
                    my $m = 'gone';
                    o.c.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                    o.c.cha.>$m.>$sc.>$z.>$dt.>$dcv = $to;
                }
            }
            
            # wires
            # notes from 2 - see upmost o's origin C ref index,
            # contributed to by all under
            if (my $oz = o.sc.oz) {
                for my $on (keys %$oz) {
                    my $to = $oz.>$on;
                    if (to.y.A eq $A) {
                        if (oo.C.>to.t && oo.C.>to.t.>to.y.cv eq $to) {
                            #sayre "  -- have $on: to.t to.y.cv";
                        }
                        else {
                            die "$t $cv Dont have $on: to.t to.y.cv ".wdump 2, oo.C;
                            # cha.lost? might be above or below o A
                        }
                    }
                    else {
                        sayre "   ++ $on: to.t to.y.cv from other A";
                    }
                }
            }
            
            if (!o.y.l) {
                $cha.>$x.>$_.>$t.>$cv = $o for 'new';
                o.c.el = 1;
            }
            elsif (o.c.cha) {
                $cha.>$x.>$_.>$t.>$cv = $o for 'diff';
            }
        };
        G&Chew,$jj,'x,t,cv',$_ for sub {
            my ($o,$x,$t,$cv) = @_;
            $oo.>$x && $oo.>$x.>$t && $oo.>$x.>$t.>$cv && return;
            say "Goner C.t C.y.cv  --  $x $t $cv ----";
            $cha.>$x.>$_.>$t.>$cv = $o for 'gone';
        };
        !keys %$cha && delete A.c.cha;
        # names -> A fall replace to check inside
        j.sc.oo = $oo;
    
    #c o5 join changed o as r (with el=3) by yt
    #
    o 5:
        my $oo = A.c.oo;
        my $cha = A.c.cha;
        warn "more than ooC: in C.t"
            .(c&jC && " on C.c.jC.t").": ".ki $oo
                if 1 != keys %$oo;
        # make ty -> yt
        my $ty = oo.C;
        my $oty = $cha && cha.C && cha.C.gone;
        my $yt = G&yttv,grep{defined}$ty,$oty;
        
        # iterate by yt
        my $la;
        my @z;
        G&Chew,$yt,\'cv,t',$_ for sub {
            my ($o,$cv,$t) = @_;
            my $l = o.y.l;
            my $E = l.c.s;
            my $e = o.c.s;
            my $cha = o.c.cha;
            my $r;
            r.t = $t;
            r.y.A = $A;
            r.y.cv = $cv;
            r.c.o = $o;
            if ($oty.>$t && $oty.>$t.>$cv) {
                # $o is last there
                # above knows on goneyt when there is no more z
                r.c.el = 9; # not here
                push @z, $r;
                $la = $r;
                return;
            }
            elsif ($cha) {
                if (cha.new && cha.new.t) {
                    r.c.el = keys %{ $ty.>r.t } == 1 ? 2 : 1;
                }
                else {
                    r.c.el = 3; # or 4 if only z more?
                }
            }
            else {
                r.c.el = 8;
                $la = $r;
                return
            }
            
            #c make co.path -> {nodestuff,co} trees
            my $co = r.sc.co ||= {};
            G&Chew,$cha,\'m,nk,gk?',$_ for sub {
                my ($wa,$m,$nk,$gk) = @_;
                return if $nk eq 'y' && $gk eq 'cv' && $m eq 'new';
                my $xe = $cha.>$m.>$nk;
                my $oe = $E.>$nk;
                my $ne = $e.>$nk;
                $xe = $xe.>$gk if @_ == 4;
                $oe = $oe.>$gk if @_ == 4;
                $ne = $ne.>$gk if @_ == 4;
                my $co = r.sc.co.co.>$nk ||= {};
                $co = co.co.>$gk ||= {} if @_ == 4;
                co.o = $oe;
                co.v = $ne unless $m eq 'gone';
                co.p = [$nk];
                co.m = $m;
                push @{co.p}, $gk if @_ == 4;
                if ($nk eq 'sc' && $gk eq 'z') {
                    my $wi;
                    G&Chew,$xe,\'t,cv',$_ for sub {
                        my ($zb,$t,$cv) = @_;
                        $wi++;
                        if ($m eq 'gone') {
                            co.goneyt.>$cv.>$t = $zb;
                        }
                        else {
                            co.ytm.>$cv.>$t.>$m = $zb;
                            co.Ams.>_.c.sip = $_ for zb.y.A;
                        }
                    };
                    my $sm = '=';
                    $sm = "+" if $m eq 'new';
                    $sm = "-" if $m eq 'gone';
                    co.sv .= "$sm$wi";
                }
            };
            #c co.paths in order make dis/z d microCs:
            # r tcv, c&o, c.z inside r, c.dis z d:   (climbs Cs)
            # d t=nk/gk, s=value, sc.z=inside d      (climbs paths)
            my $or;$or = sub { 
                my $co = shift; # outside/index
                my ($he,$ta) = ([],[]);
                my $tw;
                # nk/gk ordering
                for ([$he=>qw't cv y c sc'],
                    [$ta=>qw's z']) {
                    my ($l,@l) = @$_;
                    for my $t (@l) {
                        $co.>$t || next;
                        $tw.>$t ++;
                        push @$l, $t;
                    }
                }
                my @mi = sort grep { !$tw.>$_ } keys %$co;
                my $z = [];
                for my $t (@$he,@mi,@$ta) {
                    my $co = $co->{$t}; # inside/state
                    my $d;
                    d.t = $t;
                    my $zort;
                    if (co.co && keys %{co.co}) {
                        die "More to mid co: ".wdump 3, $co if keys %$co > 1;
                        d.sc.z = $or->(co.co);
                    }

                    if (co.ytm) {
                        my @mu = values %{co.Ams};
                        @mu = G&sortysip,\@mu,'1' if @mu > 1;
                        for my $oi (@mu) {
                            my $z = oi.c.r || sayre("no r on A.t A.cv A.c.s.t   from oi.t oi.cv  oi.c.s.t") && next;
                            push @{r.c.z||=[]},  @$z;
                        }
                        if (@mu > 1) {
                            sayre "Many A below r.t r.y.cv: ".ki co.Ams;
                            $zort = 1;
                        }
                    }

                    if (my $gt = co.goneyt) {
                        r.c.z ||= [];
                        # yonder thing disappears (maybe no A)
                        my @rm;
                        G&Chew,$gt,'cv,t',$_ for sub {
                            my ($d,$cv,$t) = @_;
                            my $zr;
                            zr.t = $t;
                            zr.y.cv = $cv;
                            zr.c.el = 9;
                            push @rm, $zr;
                        };
                        my @mr;
                        for my $zr (@rm) {
                            my $got;
                            @{r.c.z} = map {
                                _.t eq zr.t && _.y.cv eq zr.y.cv
                                    ? do { $got = 1; $zr }
                                    : $_
                            } @{r.c.z};
                            $got || push @mr, $zr;
                        }
                        # breaks el=8/previous thing ness?
                        if (@mr) {
                            push @{r.c.z}, @mr;
                            $zort = 1;
                        }
                    }

                    @{r.c.z} = sort {a.y.cv <=> b.y.cv || a.t cmp b.t} @{r.c.z}
                        if $zort;

                    for (qw'sv o m p') {
                        exists $co.>$_ || next;
                        d.c.>$_ = $co.>$_;
                    }
                    d.c.s = co.v if exists co.v;
                    push @$z, $d;
                }
                $z;
            };
            r.c.dis = $or->(co.co);

            push @z, $la if $la ne $z[-1] && r.c.el ne 3;
            push @z, $r;
            $la = $r;
        };
        _.cv = 0.9 for @{delete(A&notafterfive)||[]};
        A.c.r = \@z;
        
    #c o57 r -> rs, rsl readable/testable change text
    o 57:
        # r are ty and c.el=? of change
        #  c.dis is from $or, j describing co paths of change into C, in order
        #    j.sc.z is more j
        #  c.z is r children
        # (o should grow to know non-z things in things unis)
        
        # recurse branches of the C for display
        my $ja;$ja = sub {
            my ($d,$e,$r,$ud) = @_;
            $e = $e.>d.t;
            my $etc;
            if (exists d.c.sv) {
                $etc = d.c.sv;
            }
            elsif (exists d.c.s) {
                my $m = '=';
                $m = "+" if d.c.m eq 'new';
                die "gone had s: ".ki$d if d.c.m eq 'gone';
                my $s = d.c.s;
                my $slim = c&slim || 24;
                if (length $s > $slim) {
                    # where s is cloud of text to be ind 4 vs 2 of z
                    if (c&largesse && ud.t eq 'c' && d.t eq 's') {
                        $r || die "Norja";
                        rc&motd && die "Already trying to put motd ud.t\.d.t: "
                            .ki(rc&motd)."vs:\n".ki($s);
                        rc&motd = [map{[$_]}split"\n",$s];
                        $m = "<"."<''";
                        $s = "";
                    }
                    else {
                        my $va = c&slimvague;
                        $va = 100 if $va eq '1';
                        c&slimnodig ||= 1 if $va;

                        my $dig = 'h'.slm(6,dig($s)) unless c&slimnodig;
                        $s = slim($slim-5,$s).$dig;

                        $va && $s =~ 
                            s{\.\.(\d+)(h\S+)?$}
                            {'..<'.(int($1/$va) * $va)}e;
                    }
                }
                $s =~ s/\n/\\n/sg;
                $etc = $m.$s;
            }
            $etc = "-$etc" if d.c.m eq 'gone';
            my @l = "d.t$etc";
            if (my $z = d.sc.z) { # gk
                push @l,'{';
                my @lo = map {
                    $ja->($_,$e,$r,$d)
                } @$z;
                push @l, @lo;
                push @l, '}';
            }
            @l;
        };
        
        # climb the r
        # rs is array of arrays of display strings and more rs
        my $rs;$rs = sub {
            my ($z) = @_;
            my @r;
            for my $r (@$z) {
                my @l;
                push @l, r.t, r.y.cv;
                my $ul = {map{!ref r.c.>$_ ? ($_ => r.c.>$_ ) : ()}keys %{r.c}};
                push @l, ki $ul if keys %$ul;

                if (my $o = r.c.o) {
                    # triangle
                    my $e = o.c.s || die "no ocs".ki$r;
                    if (my $dis = r.c.dis) { # change display elements
                        push @l, $ja->($_,$e,$r) for @$dis
                    }
                    rc&motd && push @l, rc&motd;
                    if (my $z = r.c.z) { # inside lines
                        push @l, $rs->($z);
                    }
                }
                sayre "Havenodis: ".ki $r if !@l;
                push @r, \@l;
            }
            \@r
        };
        
        A.c.rs = $rs->(A.c.r);
        
        # collapse rs
        # rsl is array of indented strings
        my $rsl;$rsl = sub {
            my ($x,$ind) = @_;
            $ind .= '  ';
            my $l = [];
            sayre "Wasx " if ref $x ne 'ARRAY';
            for my $d (@$x) {
                my $x = [];
                sayre "Wasdin ".wdump 3, $x if ref $d ne 'ARRAY';
                my $s = $ind . join ' ', grep { !ref$_ || do{push@$x,$_;0} } @$d;
                push @$l, $s;
                map { push @$l, @$_ }
                $rsl->($_,$ind) for @$x;
            }
            $l
        };
        
        A.c.rsl = $rsl->(A.c.rs);
    #c o6 r growth happens to our objects
    # we can skip into here with another o's r or rl converted to r
    # r tcv, el=3, o=$o?, dis=z j, z=inside r
    o 6:
        my $j = G&offis,i=>j=>'t';
        j.c.Co = $C;
        my @r = @{A&r};
        
        # we may have root elected by .c.root from the many
        my @root = grep { _.c.o && _.c.o.y.D && _.c.o.y.D.c.root } @r;
        @root > 1 && die "More than 1 root: ".wdump 3, \@root;
        for (@root) {
            if (my $root = js&root) {
                _.t eq root.t && _.y.cv eq root.y.cv
                    || die "Root wanders: ".ki({f=>$root,t=>$_});
            }
            js&root = $_;
        }
        # attach things in general to ...
        if (@r) {
            if (my $root = js&root) {
                if (!@root) {
                    # make up r of el=3 to z=etc, put things in
                    my $r = {};
                    r.t = root.t;
                    r.y.cv = root.y.cv;
                    r.c.el = '3';
                    r.c.z = [@r];
                    @r = $r;
                }
                else {
                    push @{root.c.z||=[]}, grep {$_ ne $root} @r;
                    @r = $root;
                }
            }
        }
        else {
            # no changes
        }
        
        my $tcvis = sub {
            my ($x,$y) = @_;
            x.t eq y.t && x.y.cv eq y.y.cv
        };
        # part of relink, sweep into Compliers with in->next corner
        my $unshiftover = sub {
            my ($l,$in) = @_;
            if ($tcvis->($l,$in)) {
                # replace self
                if (my $ne = in.y.next) {
                    l.y.next = $ne;
                    ne.y.prev = $l;
                }
            }
            else {
                # first becomes next
                l.y.next = $in;
                in.y.prev = $l;
            }
        };
        # attribute hammer
        my $dis;$dis = sub {
            my ($c,$z,$ch) = @_;
            for my $d (@$z) {
                if (ds&z) {
                    my $con = $c.>d.t ||= {};
                    my $ch = ch.K.>d.t ||= {}; # like co
                    $dis->($con,ds&z,$ch);
                }
                if (exists dc&s) {
                    ch.set.>d.t =
                    $c.>d.t = dc&s;
                }
                if (dc&m eq 'gone') {
                    ch.drop.>d.t = 1;
                    delete $c->{d.t};
                }
            }
        };
        # all as in changed or 3/8fected by change
        my @aro; # flat list of our changed or el=8ing C, ordered descent
        my @zop; # all change minima with c.el=?
        my @in; # all el < 8 (happenings)
        my @out; # all el == 9 (goners)
        # something just el3ing for z will be in
        my $ro;$ro = sub {
            my ($z,$up) = @_;
            my $la;
            for my $r (@$z) {
                # our C - the object for the other
                my $l = up.y.tv->{r.t}->{r.y.cv};
                my $new;
                if (!$l) {
                    $new = 1;
                    rc&el < 3 || die "Upel no hist for el=rc&el :".wdump 3,[ki($up),ki($r),up.y.tv];
                    #ki($r).wdump 3, $j;
                    l.t = r.t;
                    l.y.cv = r.y.cv;
                }
                # has this 
                my $x = l.y.x ||= {t=>l.t,y=>{cv=>l.y.cv}};
                
                #c relink our C
                if (rc&el < 3) {
                    my $ol = $l;
                    if (!$new) {
                        # rl over/replace
                        sayre "overs r.t ".wdump 2, $r;
                        $l = {};
                        l.t = r.t;
                        l.y.cv = r.y.cv;
                        $la ||= ol.y.prev;
                    }
                    if (!$la) {
                        # becomes first
                        my $in = up.y.in;
                        up.y.in = $l;
                        # TODO way out first + last?
                        $unshiftover->($l,$in) if $in;
                    }
                    else {
                        my $on = la.y.next;
                        la.y.next = $l;
                        l.y.prev = $la;
                        $unshiftover->($l,$on) if $on;
                    }
                    if (up.y.in eq $l) {
                        l.y.prev && die "oel3 First with prev: ".ki$l;
                    }
                }
                elsif (rc&el eq '9') {
                    my $prev = l.y.prev;
                    my $next = l.y.next;
                    if (up.y.in eq $l) {
                        $prev && die "oel9 First with prev: prev.t prev.y.cv: ".wdump 4,[ki($prev),ki($l),ki($next),A&rsl];
                        if ($next) {
                            up.y.in = $next;
                        }
                        else {
                            # empties
                            delete up.y.in;
                        }
                    }
                    if ($prev && $next) {
                        prev.y.next = $next;
                        next.y.prev = $prev;
                    }
                    elsif ($prev) {
                        delete prev.y.next;
                    }
                    elsif ($next) {
                        delete next.y.prev;
                    }
                }
                
                #c apply dis changes to $l
                my $ch = {};
                $dis->($l,rc&dis,$ch) if rc&dis;
                
                # the change/elbits alone in $zop
                my $zop;
                zop.t = l.t;
                zop.y.cv = l.y.cv;
                zop.y.l = $l;
                zop.y.r = $r;
                die "zop change already contains el: ".ki$zop if zop.c.el;
                zop.c.el = r.c.el;
                for my $nk (sort keys %{ch.K||{}}) {
                    my $gh = ch.K.>$nk;
                    if (my $s = gh.set) {
                        $zop.>$nk.>$_ = $s.>$_ for keys %$s;
                    }
                    if (my $drop = gh.drop) {
                        my @gks = sort keys %$drop;
                        my $k = 'd'.substr($nk,0,1);
                        exists zop.c.>$k && die "zop already c.$k: ".ki$zop;
                        zop.c.>$k = join ',', @gks; # TODO texty line safety
                    }
                }
                push @zop, $zop;
                
                # wirings
                l.y.r = $r;
                rc&o.y.l = $l if rc&o;
                l.y.x || die "NO X ".ki $l;
                l.y.up = $up if $up ne $j;
                # internal index building, really 7 cos
                if (rc&el eq '9') {
                    push @out, $l;
                    my $tvt = up.y.tv.>l.t;
                    delete $tvt.>l.y.cv;
                    delete up.y.tv.>l.t if !keys %$tvt;
                    delete up.y.tw.>l.t if up.y.tw.>l.t eq $l;
                }
                elsif (rc&el ne '8') {
                    push @in, $l;
                    up.y.tv.>l.t.>l.y.cv = $l;
                    up.y.tw.>l.t = $l;
                    # TODO ^ unless already by > other
                    # and backwards if other leaves
                }
                push @aro, $l;
                
                $ro->(rc&z,$l) if rc&z;
                
                $la = $l unless rc&el eq '9';
            }
        };
        
        $ro->(\@r,$j);
        
        # of changed and el8ing (prev)
        a&aroz = \@aro; # fully + el8
        a&zop = \@zop; # skinny + el8
        a&inz = \@in; # fully 
        a&outz = \@out; # fully goners
        a&top = j.y.in || do {
            sayre "No toplevel! ".wdump 4, [j.sc.oo.C];
            j.sc.root
        };
        
    #c o7 surroundings/y-repoint our...
    # make an o.y.D -> o C.t -> $l ref index at the top
    # TODO same thing in many places
    o 7:
        my $l = c&j.y.in;
        my $Dl = {};
        my @Do;
        my $el;$el = sub {
            my ($l,$ind,$way) = @_;
            my $r = l.y.r || die "l no yr: ".ki$l;
            my $o = r.c.o || die "r no co: ".ki$r;
            my $D = o.y.D || die "o no yD: ".ki$o;
            my $j = o.y.j || die "o no yj: ".ki$o;
            if (my $pre = $Dl.>$D) {
                die "Has already a D.t D.y.cv: from ".ki$pre;
            }
            $Dl.>$D.>j.c.Co.t = $l;
            push @Do, $o;

            l.y.in && $el->(l.y.in, $ind."    ", "yin  ");
            l.y.next && $el->(l.y.next, "$ind", "ynext");
        };
        $el->($l);

        # indexes
        for my $fi (keys %{c&finds||{}}) {
            my $fr = c&f.sc.>$fi || die "o cf no $fi; ".ki$C;
            my $to = c&i.sc.>$fi ||= {};
            for my $k (keys %$fr) {
                my $v = $fr.>$k;
                if (my $re = $Dl.>$v) {
                    if (1 < keys %$re) {
                        die "Many same yonder:"
                            ." y$k\t v.t v.y.cv: ".wdump 2, $re;
                    }
                    my ($c) = values %$re;
                    $to.>$k = $c;
                }
                elsif (ref $v ne 'HASH') {
                    $to.>$k = $v;
                }
                else {
                    die "Not coming: ".ref($v).'  '.ki($v)
                        .wdump 2, A&rsl;
                }
            }
            for my $k (keys %$to) {
                $fr.>$k || next;
                delete $to.>$_;
            }
        }

        # our C's ys, in/up/next/prev already linked
        # TODO grow to seeing same objects in many places
        #   even inside a z? 
        # how? el + T like to lv for both places
        #   el=6 when things it cares about happen in this wave?
        for my $o (@Do) {
            my $D = o.y.D || die "o no yD: ".ki$o;
            my $l = o.y.l || die "o no yl: ".ki$o;
            for my $k (keys %{D.y}) {
                my $v = D.y.>$k;
                ref $v || next;
                my $re = $Dl.>$v;
                # only keeps links to things we were given
                $re || next;
                if (1 < keys %$re) {
                    die "Many same yonder:"
                        ." y$k\t D.t D.y.cv: ".wdump 2, $re;
                }
                my ($c) = values %$re;
                if (l.y.>$k eq $c) {
                    # already
                }
                else {
                    l.y.>$k = $c;
                }
            }
        }

