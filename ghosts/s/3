Triangle: | # peel electrosn
    u a
    # sevenatim
    # time passes independently of your being in the room
    # once you know about the room
    s 1:
        A.2 = shift @$s;
        A.c.n = G&sJ,A.2,'n';
        # C is self for s
        # C is 's many for o
        A.c.s = G&sJ,A.2,'s';
    s 2:
        # number of things plugged in
        # o uses recursio as passed in
        if (my $W = c&whole) {
            my $s = G&t,$W || die "no $W";
            say "Whole ! ".ki $s;
            G&tugA,o=>8,$C,$s,'whole';
            return T.Z.8 = $A;
        }
        if (my $W = c&base) {
            my $s = G&t,$W || die "no $W";
            say "Base ! ".ki $s;
            G&tugA,o=>2,$C,$s,'base';
        }
        if (my $n = A.c.n) {
            s&ch = A.2.sc.ch if !defined s&ch;
            s&ch = '' if !defined s&ch;
            G&tugA,o=>2,$C,n.sc.a->{$ch},'zip';
        }
        c&zip = G&tugA,o=>3,$C,A.c.tug,'zip';
    s 3:
        say "S 3";
        # J t/y awakens
        # W t/y awakens
    s 4:
        # pieces sorted
        # brings up W inners <9 like t/y clang
    s 5:
        # goS made
    s 6:
        # going - figure difference
        c&el = '2' if 1 == 3;
    s 7:
        # pack down goods
    s 8:
        # tie together
        A.c.expo.>$_ = 1 for qw'tv i ii';
        A.2.sc.>$_ = C.sc.>$_ for keys %{A.c.expo};
        # send out
    
    
Circle: |
    u a
    # listen, insward, moral law, has to give us power
    
    # cases:
    #  J.i <- o.i
    #  - i porty J..p.i tell non-$o of overwrites
    #  - recur bit J..b.i.>$o <- last C we make 
    #  - may see lv/otherness settling clues on o
    #  - knows i means pull o.i as t=>s
    #  - recur C shell of just t and c.s
    # so around t/cs/sc the other stff
    
    # eats other, splats self 
    # the splat modes of ts, tv (shade c), 
    
    # all making a big rising of data, you could 
    o 1:
        my ($i,$f,$t) = @$s;
        i.y eq $i || die "i must A";
        
        $t = G&Ct,@$t if ref $t eq 'ARRAY';
        %$C = %$t if ref $t eq 'HASH';
        C.t = $t if $t && !ref $t;
        
        c&i = $i;
        c&m ||= C.t;
        if (f.y) {
            if (f.y eq $f) {
                # A/J
                c&h = $f;
            }
            else {
                # C mo 3 W:of ...
                #  C mo 1 s:... of:mo,dig:...
                # y.in or sc.z
                c&s = $f;
                a&m = 'C';
            }
        }
        else {
            # a zip
            c&s = $f;
        }
        if (c&m eq 'i' || c&m eq 'ii') {
            c&kno = c&m;
        }
        if (c&kno) {
            my $h = c&h || die "unhoused kno C.t m:c&m";
            c&s = h.sc->{c&kno};
            # may have lvism & more via h.sc.s.
        }
    o 2:
        # per protocol/named holster
        my $j = c&j = C.c.i.sc.oo->{C.t} ||= {};
        my $r = c&r = {};
        my $oo = r.sc.oo = {};
        # per other itself, way in is noise-ish
        if (c&m eq 'zip') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # light cones holding C or doing another o bunch
                v.y && v.y eq $v || die "zip yon not A";
                my $D = v.c.s;
                if (v.t eq 'o') {
                    # D is inner o's C - index windups
                    if (v.cv >= 0.2) {
                        die "too late to grab self D.t";
                    }
                    else {
                        say "A.t A.c.sip C.t claims: v.t v.c.sip D.t";
                        D.c.i eq c&i || die "o oth i C.c.i.t <-> D.c.i.t";
                        D.c.i = c&j;
                        push @{oo.all->{D.t}||=[]}, $v;
                    }
                }
                else {
                    # D is J moment material to shade
                    my $e = G&Chade,$D;
                    e.y.D = $D;
                    e.y.R = $v;
                    e.y.k = $k;
                    push @{oo.C->{e.t}->{e.y.cv}||=[]}, $e;
                }
            }
        }
        elsif (c&m eq 'i') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # inflated t -> s
                my $e;
                e.t = $k;
                e.y.cv = 0.1;
                e.y.k = $k;
                e.c.s = $v;
                push @{oo.C->{e.t}->{e.y.cv}||=[]}, $e;
            }
        }
        elsif (c&m eq 'ii') {
            for my $k (keys %{c&s}) {
                my $v = c&s ->{$k};
                # t -> C
                my $e = G&xot,$v;
                e.y.k = $k;
                push @{oo.C->{e.t}->{e.y.cv}||=[]}, $e;
            }
        }
        elsif (c&m eq 'C') {
            # C
            my $e = G&xot,c&s;
            e.y && e.y ne c&s || die "nonyiv";
            # if y.in or sc.z make oo.all.
            push @{oo.C->{e.t}->{e.y.cv}||=[]}, $e;
        }
        else {
            die "How to read ".ki $C;
        }
        
    o 3: %johnny guitar:#c
        my $j = c&j;
        my $jj = j.sc.oo;
        my $r = c&r;
        my $oo = r.sc.oo;
        # sort by sip if somehow
        for my $t (keys %{oo.C}) {
            my $vs = oo.C.>$t;
            for my $cv (keys %$vs) {
                my $Cs = $vc->{$cv};
                if (@$Cs > 1) {
                    my $so;$so = sub {
                        my $i = shift;
                        my ($c,$d) = (a.y.v,b.y.v);
                        $c && $d || die "noabyv";
                        ($c,$d) = (c.c.ip,d.c.ip);
                        return die "ip sort ran out: a.t a.y.cv"
                            unless exists $c->[$i]
                                || exists $d->[$i];
                        c.c.ip->[$i] <=> d.c.ip->[$i]
                        || $so->($i+1);
                    };
                    @$Cs = reverse sort {$so->(0)} @$Cs;
                }
                my ($e,@out) = @$Cs;
                oo.C->{e.t}->{e.y.cv} = $e;
                my $l = jj.C->{e.t}->{e.y.cv};
                
            }
        }
        # names -> A fall replace to check inside
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        # A -> J t/y images
Walks: | # othering
    u i
    Chade:
        my $C = {};
        C.t = s.t;
        C.y.cv = s.y.cv;
        C.c.s = s.c.s if exists Z.c.s;
        C.sc = {%{Z.sc}};
        $C
    # current & join expr
    wtch: %acgt:c d
        my $wt = {};
        wt.same = 1;
        for (keys %$d) {
            if (!exists $c->{$_}) {
                wt.new->{$_} = $d->{$_};
                wt.same = 0;
            } 
            elsif ($d->{$_} ne $c->{$_}) {
                wt.diff->{$_} = $c->{$_};
                wt.same = 0;
            }
            else {
                wt.sami++;
                wt.still->{$_} = $c->{$_};
            }
            wt.tot++;
        }
        for (grep { !exists $d->{$_} } keys %$c) {
            wt.gone->{$_} = $c->{$_};
            wt.same = 0;
        }
        $wt;
    

