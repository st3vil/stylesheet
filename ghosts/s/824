
Fishis: | # Fish C.sc onto e for p(id)
    my $p;
    if (ar.p) {
        $p = G&Ct,[p=>''=>ar.p];
    }
    pc&nums = ar.nums if ar.nums;
    $p || die "In Fishformula";
    G&elph,Fish=>[$p];
    return @{ps&z||[]} if ar.nums > 1;
    $p
Fish: | # infinite plantulism
    Rw Tiot;
    # e receives a new G Ting
    # is their leader/his left-over intelligence
    # starts before everything, with the one thing to do
    # which is watch, scrub, and attract attention
    # dig in hole hath set me free
    
    # answer requests for its detail
    Js&ein.t.p = &TesCA{
        my $pid = e&s || c&e.c.s;
        my @fo = G&op,"pid:$pid";
        if (!@fo) {
            if (T.rep) {
                if (my $i = Js&ps.>$pid ) {
                    @fo = {sc=>$i};
                }
                else {
                    return G&vent,"Stillno:pid:$pid";
                }
            }
            return T.pos = 3;
        }
        G&xo,e.sc,_.sc for $fo[0];
        
        if (e&nums) {
            1 && sayyl "For es&num in...";
            es&z = [ grep { _s&num =~ /^es&num/ }
                G&op ];
        }
        
        T.pos = '';
    };
    S
    # toplevels 4t
    y.at.bg = '3484';
    c&s = G.c.bay.'/p';
    c&do = 'ls -1t';
    n for=>''=>c&s
    my @im = Rw Exe;
    my @pi = grep {-d && (!-l || /\/\d+$/) } @im;
    my $tp;
    $tp.>$_ =1 for grep {-l} @im;
    
    m $_=>-proc for reverse @pi;
    
    for my $C (@$M) {
        my $s = c&s;
        my ($d,$p) = $s =~ /^(.+)\/p\/(\d+)$/;
        my $i = Js&ps.>$p ||= do {
            my $i = {};
            my $so = read_file("$s/so");
            my @lives = split ' ', $so;
            my $it = pop @lives;
            $so = join ' ', (map{/^(\d+)/}@lives), $it;
            i.so = $so;
            my ($num,$t) = split ':', $so;
            i.sot = $t;
            i.num = $num;
            if ($num =~ /^(.+) (\d+)$/) {
                if ($2) {
                    i.turnum.progress = "$1 ".($2-1);
                }
                i.turnum.future = $1;
            }
            $i
        };
        G&xo,C.sc,$i;
    }
    for my $l (@$M) {
        for my $C (@$M) {
            my $tu = s&turnum;
            each t,v $tu {
                next unless ls&num eq $v && ls&sot eq s&sot;
                next if ls&insys;
                s&hasnum.>ls&num = $l;
                G&xo,s&hasnum,ls&hasnum if ls&hasnum;
                _s&surp = C.t for values %{s&hasnum};
            }
        }
    }
    for my $C (@$M) {
        if (my $s = -s "c&s/err") {
            s&hase.err = $s;
            delete s&surp;
        }
    }
    
    @$M = grep {!_s&surp || Js&opens.>_s&surp } @$M;
    #G&give,Toter=>sem=>[@{$M}];
    
    sayyl "Fishes ... ";
    y.imp = 1;
    y.res = 100;
    #n Twang
pi/proc: | # picture in picture rock
    my ($d,$p) = $s =~ /^(.+)\/p\/(\d+)$/;
    $p || return
        n err=>6=>"No pid: $p",'%hs:254'
    s&dis = 3;
    y.at.dos = 'Continues';
    
    s&dir = $s;
    
    
    Rw Thrext so $next_t:s&sot;
    n t=>1=>s&sot,'%hs:655,fs:15'
    n spc=>12=>' '
    
    n pid=>2=>$p,'%fs:7,hs:256,dos:Chaseout'
    s&pid = $p;
    
    -e "/proc/$p" || return
        n gone=>2=>'*'=>'%hs:856,dos:Reap'
    #n spc=>31=>' '
        
    
    
    my $pa = read_file("$s/pa");
    #n pa=>32=>{s=>$pa}=>'%hs:576'
    s&ppa = $pa;
    -e "$d/p/$pa" ||
        n noparent=>322=>'?'=>'%hs:856'
    
    if (my $ns = !s&surp && s&hasnum) {
        my $bush = keys %$ns;
        n hasnum=>4=>" +".$bush,'%hs:247,fs:8,dos:Uncoverprocs';
    }
    
    if (my $has = s&hase) {
        each type,v $has {
            n $type=>41=>" $type:$v ",'%hs:185,fs:14,dos:Chaseout'
        }
    }
    
    my ($mem) = `cat /proc/$p/statm` =~ /(\d+)/;
    $mem *= 3900.25;
    
    my $fs = $mem > 70000000000 ? 14 : 7;
    my $ms = Rw sciun $s:mem;
    n memu=>45=>" $ms","%fs:$fs,dos:Reap"
    
    Js&ope || return;
    
Uncoverprocs: |
    my $j = e&_hJ;
    Js&opens.>j.t = us&S ? 0 : 1;
    
Reap: |
    my $j = e&_hJ;
    my $c = j.C;
    my $f = cc&s;
    G&give,Repair=>f=>$f;
Repair: |
    Rw Tiot;
    Rw Elationist;
    y.at.fs = 6;
    S
    if (Jc&es ne Jc&ps) {
        my $f = Jc&es;
        f.t eq 'f' || die "Feed differently J.t";
        my ($p) = fc&s =~ /(\d+)$/;
        f.t = fc&s;
        fs&pid = $p;
        
        my $p = Rw Fishis $p $nums=1;
        # FactorEase hash partsing
        my @p = map { {t=>_s&dir,y=>{},sc=>{
            pid=>_s&pid,
            so=>_s&so
        } } } @{ps&z};
        
        _c&s = 'going' for @p;
        
        push @{Js&M||=[]}, @p;
        Jc&ps = Jc&es;
    }
    my $m = Js&M||=[];
    
    @$m = grep {
        my $r = 1;
        if (_c&s eq 'going') {
            `kill -KILL _s&pid`;
            _c&s = 'kilt';
        }
        if (_c&s =~ /^kilt/) {
            if (-e "/proc/_s&pid") {
                _c&s .= '.'
            }
            else {
                _.t =~ /\w+\/\w+/ || die "Teis".ki$_;
                _c&s = "rm _.t";
            }
        }
        $r
    } @$m;
    
    
    m $_ for @$m;
    _c&s = "_s&so: _c&s" for @$M;
    _s&dis = 3 for @$M;
    y.res = 1;
    
Chaseout: |
    my $j = e&_hJ;
    my $o = e&hC ->[-3];
    G&elph,Elvis=>[opt=>"Udder:Chase:the:os&pid"];
    T.pos = '';
    
Chase: | # follow
    Jc&tape = 'Dejo';
    Js&pid = c&the if c&the;
    Jc&pd = G.c.bay.'/p/'.Js&pid;
    
    n t=>1=>Jc&pd,'%hs:347,fs:14'
    
    n out=>-has_2
    n err=>-has_3
    
pi/has: | # log tail
    #y.at.over = 'scroll';
    y.at.dis = 1;
    #y.at.mh = '36';
    #y.at.mw = '48';
    Js&len ||= 30;
    my $f = 2c&pd || die "2 by c pd.";
    $f .= "/C.t";
    my @l = `tail -n Js&len $f`;
    
    chomp for @l;
    n t=>1=>C.t=>'%hs:349,fs:14'
    
    y.n = 12;
    #n C.t=>-pud=>\@l
    my (@c,$lc);
    @l = map {
        # group by line colour
        
        1 while s/^\x1b\[(\d+)m//;
        if ($1 ne $lc || !@c) {
            $lc = $1;
            push @c, {t=>$1,y=>{}};
        }
        my $c = $c[-1];
        push @{cs&z||=[]}, $_;
        $_
    } @l;
    #m l=>''=>join("\n",_s&z)$_,'%dis:3' for @c;
    for (@c) {
        my $hs = _.t eq '31' ? '066' # red
            : _.t eq '93' ? '276' # yellow
            : _.t eq '94' ? '676' # blue
            : _.t eq '37' ? '224' # non
            : "109";
        my $l = join "\n", @{_s&z};
        m bit=>''=>$l,"%hs:$hs,dis:3"
    }
    #n C.t=>-pud=>{dl=>6,s=>\@c};
    say "C.t is ".@l;
    #G&give,Toter=>o=>\;
    
    

