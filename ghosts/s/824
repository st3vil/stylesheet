
Fish: | # infinite plantulism
    Rw Tiot;
    # e receives a new G Ting
    # is their leader/his left-over intelligence
    # starts before everything, with the one thing to do
    # which is watch, scrub, and attract attention
    # dig in hole hath set me free
    
    # answer requests for its detail
    Js&ein.t.p = &TesCA{
        my $pid = e&s || c&e.c.s;
        1 && say "    Looking far $pid";
        my @fo = G&op,"pid:$pid";
        if (!@fo) {
            T.rep && return G&vent,"Stillno:pid:$pid";
            return T.pos = 3;
        }
        G&xo,e.sc,_.sc for $fo[0];
        T.pos = '';
    };
    S
    # toplevels 4t
    y.at.bg = '3484';
    c&s = G.c.bay.'/p';
    c&do = 'ls -1t';
    n for=>''=>c&s
    my @im = Rw Exe;
    my @pi = grep {-d && !-l} @im;
    my $tp;
    $tp.>$_ =1 for grep {-l} @im;
    
    m $_=>-proc for reverse @pi;
    
    for my $C (@$M) {
        my $s = c&s;
        my ($d,$p) = $s =~ /^(.+)\/p\/(\d+)$/;
        my $i = Js&ps.>$p ||= do {
            my $i = {};
            my $so = read_file("$s/so");
            my @lives = split ' ', $so;
            my $it = pop @lives;
            $so = join ' ', (map{/^(\d+)/}@lives), $it;
            i.so = $so;
            my ($num,$t) = split ':', $so;
            i.sot = $t;
            i.num = $num;
            if ($num =~ /^(.+) (\d+)$/) {
                if ($2) {
                    i.turnum.progress = "$1 ".($2-1);
                }
                i.turnum.future = $1;
            }
            $i
        };
        G&xo,C.sc,$i;
    }
    for my $l (@$M) {
        for my $C (@$M) {
            my $tu = s&turnum;
            each t,v $tu {
                next unless ls&num eq $v && ls&sot eq s&sot;
                next if ls&insys;
                s&hasnum.>ls&num = $l;
                G&xo,s&hasnum,ls&hasnum if ls&hasnum;
                _s&surp = C.t for values %{s&hasnum};
            }
        }
    }
    for my $C (@$M) {
        if (my $s = -s "c&s/err") {
            s&hase.err = $s;
            delete s&surp;
        }
    }
    
    @$M = grep {!_s&surp || Js&opens.>_s&surp } @$M;
    #G&give,Toter=>sem=>[@{$M}];
    
    sayyl "Fishes ... ";
    y.imp = 1;
    y.res = 100;
    #n Twang
pi/proc: | # picture in picture rock
    my ($d,$p) = $s =~ /^(.+)\/p\/(\d+)$/;
    $p || return
        n err=>6=>"No pid: $p",'%hs:254'
    s&dis = 3;
    y.at.dos = 'Continues';
    
    
    
    Rw Thrext so $next_t:s&sot;
    n t=>1=>s&sot,'%hs:655,fs:15'
    n spc=>12=>' '
    
    n pid=>2=>$p,'%fs:7,hs:256'
    s&pid = $p;
    
    -e "/proc/$p" || return
        n gone=>2=>'*'=>'%hs:856'
    #n spc=>31=>' '
        
    
    
    my $pa = read_file("$s/pa");
    #n pa=>32=>{s=>$pa}=>'%hs:576'
    s&ppa = $pa;
    -e "$d/p/$pa" ||
        n noparent=>322=>'?'=>'%hs:856'
    
    if (my $ns = !s&surp && s&hasnum) {
        my $bush = keys %$ns;
        n hasnum=>4=>" +".$bush,'%hs:247,fs:8,dos:Uncoverprocs';
    }
    
    if (my $has = s&hase) {
        each type,v $has {
            n $type=>41=>"$type: $v",'%hs:185,fs:14,dos:Chaseout'
        }
    }
    
    my ($mem) = `cat /proc/$p/statm` =~ /(\d+)/;
    $mem *= 3900.25;
    
    my $ms = Rw sciun $s:mem;
    n memu=>45=>"$ms"
    
    Js&ope || return;
    
Chaseout: |
    my $j = e&_hJ;
    my $o = e&hC ->[-3];
    G&elph,Opera=>[opt=>"Udder:Chase:the:os&pid"];
    T.pos = '';
    
Chase: | # follow
    Jc&tape = 'Dejo';
    Js&pid = c&the if c&the;
    Jc&pd = G.c.bay.'/p/'.Js&pid;
    
    n t=>1=>Jc&pd,'%hs:347,fs:14'
    m out=>-has
    m err=>-has
    
pi/has: | # log tail
    #y.at.over = 'scroll';
    y.at.dis = 1;
    #y.at.mh = '36';
    #y.at.mw = '48';
    Js&len ||= 30;
    my $f = 2c&pd || die "2 by c pd.";
    $f .= "/C.t";
    my @l = `tail -n Js&len $f`;
    
    chomp for @l;
    n t=>1=>C.t=>'%hs:349,fs:14'
    
    y.n = 12;
    #n C.t=>-pud=>\@l
    my (@c,$lc);
    @l = map {
        # group by line colour
        
        1 while s/^\x1b\[(\d+)m//;
        if ($1 ne $lc || !@c) {
            $lc = $1;
            push @c, {t=>$1,y=>{}};
        }
        my $c = $c[-1];
        push @{cs&z||=[]}, $_;
        $_
    } @l;
    #m l=>''=>join("\n",_s&z)$_,'%dis:3' for @c;
    for (@c) {
        my $hs = _.t eq '31' ? '066' # red
            : _.t eq '93' ? '276' # yellow
            : _.t eq '94' ? '676' # blue
            : _.t eq '37' ? '224' # non
            : "109";
        my $l = join "\n", @{_s&z};
        m bit=>''=>$l,"%hs:$hs,dis:3"
    }
    #n C.t=>-pud=>{dl=>6,s=>\@c};
    say "C.t is ".@l;
    #G&give,Toter=>o=>\;
    
Uncoverprocs: |
    my $j = e&_hJ;
    Js&opens.>j.t = us&S ? 0 : 1;
    
Ilan: | # O's zip of U, W switchup
    # & tractor e into a new Udder
    y.res = 100;
    Jc&refit_t = &C{
        "s&so C.t"
    };
    Js&ein.t.f.sMJ = &sMJjeTCA{
        if ($s =~ m{(.+)/p/(\d+)/W/(\w+)\.(\d+)}) {
            my ($d,$p,$t,$i) = ($1,$2,$3,$4);
            my $in = Js&index ||= {};
            my $new;
            my $C = $in.>$t.>$p ||= do { $new++; {y=>{}} };
            C.t ||= $t;
            C.c.pi ||= 'plaz';
            s&pid = $p;
            
            # find so/pa for self
            s&so ||= do {
                my $p = G&Ct,[p=>''=>$p];
                G&elph,Fish=>[$p];
                s&ppa = ps&ppa;
                ps&so;
            };
    
            # continuing W with parent pid
            if (my $p = delete $in.>$t.>s&ppa ) {
                s&ie = ps&ie;
                @$M = map { $_ eq $p ? $C : $_ } @$M;
                $new = 0;
                if (my $hi = ps&history) {
                    @$M = grep { _c&s ne $hi } @$M
                }
                my $M = c&forum = [];
                s&history = $p;
                ps&future = $C;
                m "$t ps&so"=>-pold=>{s=>$p}
                Js&blab = 1;
            }
            # same W stage appears from next fork
            elsif (s&so =~ /^(.+)(\d+):/) {
                my ($tun,$ti) = ($1,$2);
                $ti--;
                if ($ti >= 0) {
                    my ($p) = grep { _s&so =~ /^$tun$ti:$t/ } @$M;
                    if ($p) {
                        my $t = "$t ps&so";
                        my $n = G&Ct,[$t=>-pold=>{s=>$p}];
                        @$M = grep { ps&progresses ne $_ } @$M;
                        ps&progress = $C;
                        s&progresses = $n;
                        @$M = map { $_ eq $p ? $n : $_ } @$M;
                        Js&blab = 1;
                    }
                }
            }
            
            Rw Rebase $C $d $p $t $i;
            
            return unless $new;
            
            # so takesover parent's t not insys
            #   spawning little differ above, as old self
            # 
            
            $new && push @$M, $C;
        }
        else {
            die "Other Ilan ting: $s";
        }
    };
    Rw Tiot;
    Jc&tape = 'Dejo';
    S
    my $m = Js&M||[];
    @$m = map { @{delete(_c&forum)||[]}, $_ } @$m;
    #delete Js&blab && 
    y.imp++; #G&give,Toter=>s=>[Could=>$m];
    m $_ for @$m;
pi/plaz: |
    s&dis = 3;
    y.at.dos = 'Continues';
    y.at.fs = 8;
    
    Rw Thrext so $next_t=C.t;
    
    n t=>2=>C.t=>'%hs:555,fs:18'
    
    s&ie &&
    n ie=>22=>{s=>".s&ie"},'%fs:12,hs:258'
    
    n sh=>31=>{s=>"    o"},'%dos:Store'
    
    
    my @once = @{s&zin};
    @{s&zin} = ();
    Js&ison ||= 3;
    my $sc;
    sc.dis = Js&ope >= 0 ? 3 : 0;
    sc.zout = \@once if @once;
    n z=>89=>{}=>$sc
pi/pold: |
    s&dis = 3;
    my $t = s.t || C.t;
    s&so = ss&so;
    y.at.dos = 'Retrieve';
    y.at.fs = 7;
    
    Rw Thrext so $next_t:t;
    
    n t=>2=>$t=>'%hs:555,fs:16'
    
    if (my $C = c&s) {
        s&ie &&
        n ie=>22=>{s=>".s&ie"},'%fs:12,hs:258'
    }
    
    my $symb = "?";
    if (ss&progress) {
        # to another self
        # TODO fork testing
        $symb = ",";
    }
    if (ss&future) {
        # to a future
        $symb = ".";
    }
    n conti=>28=>$symb,'%fs:26'
    
    
Store: | # cops W (dos)
    G&give,Toter=>'storesitch'=>$e;
Retrieve: | # resurrect a point
    if ( us&S ) {
        my $j = e&_hJ;
        my $m = 3s&M;
        # $_ is source C of J
        my $o = ["j.t: ", map { G&aC,$_ } @$m];
        @$m = grep {_.t ne j.t} @$m;
    }
    else {
        my $j = e&hJ;
        G&give,Toter=>'resurref'=>$j;
    }
    
    

