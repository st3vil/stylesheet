  
Udder: | # go waiter
    # sets our W output
    Js&bowls++ ||
        Rw CleanUdder;
    # to resume
    while (1) {
        $_ = <STDIN>;
        chomp;
        snooze 333;
        $_ =~ /\w/ || next;
        my $C = eval { djson $_ };
        if ($@) {
            sayre "NOT json C: $_";
            $@ = '';
            return;
        }
        Rw CellDivision
            || next;
        n $C
        saybl "Done Udder";
        return saybl "Uddoff" if T.Uddoff;
    }
CleanUdder: | # dream feed connection Dejo->Ualve
    # set trip Dejo mo 7 to Js&ze = 'Flap'
    G&Ti,Trips=>[Catchelism=>''=>\'W:Dejo,At:mo,Acv:7'],$_
        for  &acgtlr{
            my $J = s&J;
            Js&ze = 'Ualve'
        };
Ualve: | # Udders' W z out for an Opper
    # 
    e&t eq 'z' || die "Not e z";
    my $z = e&s;
    my ($t) = @$z;
    my $i = Js&teli.>t.t ++;
    
    my $elv;$elv = &C{
        $C = G&hup,$C;
        C.y = C.y.cv;
        
        C.sc.z = [map{$elv->($_)}@{C.sc.z}] if C.sc.z;
        [C.t,C.y,C.c,C.sc]
    };
    my $d = "G.c.bay/p/$$/W";
    `mkdir -p $d`;
    my $f = "$d/t.t\.$i";
    write_file($f, sjson([map{ $elv->($_) }@$z])."\n");
    
    my $pull = [Ilan=>[f=>$f]];
    write_file("G.c.bay/p/Opper/in",{append=>1},sjson($pull)."\n");
    
Ilan: | # O's zip of U, W switchup
    # & tractor e into a new Udder
    Js&ein.t.f.sMJ = &sMJjeTCA{
        if ($s =~ m{(.+)/p/(\d+)/W/(\w+)\.(\d+)}) {
            my ($d,$p,$t,$i) = ($1,$2,$3,$4);
            my $in = Js&index ||= {};
            my $new;
            my $C = $in.>$t.>$p ||= do { $new++; {y=>{}} };
            C.t = $t;
            C.c.pi = 'plaz';
            s&pid = $p;
            
            my $Nf = [];
            if ($i > 0) {
                if (!defined s&i || s&i < $i - 1) {
                    my ($i,$p) = ($i,$p);
                    my $oi = $i;
                    $i--;
                    branch: while (-f "$d/p/$p/pa") {
                        1 && say "   in to: ".`cat $d/p/$p/so`." For W/$t.$i";
                        $p = read_file "$d/p/$p/pa";
                        -e "$d/p/$p" || die "No find pid $p ";
                        while (-f "$d/p/$p/W/$t.$i") {
                            1 && say "    -W $d/p/$p/W/$t.$i";
                            last branch if defined s&i && $i == s&i;
                            unshift @$Nf, "$d/p/$p/W/$t.$i";
                            last branch if $i == 0;
                            $i--;
                            
                        }
                    }
                    @$Nf || die "Wanted news $d $t: s&i-$oi"
                }
            }
            push @$Nf, $s;
            
            for my $s (@$Nf) {
                my $z = read_file($s);
                $z = djson $z;

                my $elv;$elv = &C{
                    $C = G&Ct,$C;
                    s&z = [map{$elv->($_)}@{s&z}] if s&z;
                    $C
                };
                #sayre "Do ".wdump 4, $z;
                $z = [map{ $elv->($_) }@$z];

                push @{s&zin||=[]}, @$z;
            }
            return unless $new;
            
            # try to find pid in Fish
            s&so ||= do {
                my $p = G&Ct,[p=>''=>$p];
                n Fish=>[$p]
                ps&so;
            };
            #G&give,Toter=>s=>$_ for [[G&op ]];
            #n ro=>-pud=>{s=>[[G&op ]]}

            $new && push @$M, $C;
        }
        else {
            die "Other Ilan ting: $s";
        }
    };
    Rw Tiot;
    S
    m $_ for @{Js&M||[]};
pi/plaz: |
    y.at.dis = 3;
    n t=>1=>C.t=>'%hs:555,fs:18';
    n i=>2=>s&pid
    my $z = delete s&zin || return;
    Js&ison ||= 3;
    n so=>3=>s&so
    n z=>6=>{}=>{zout=>$z,dis=>3} 

