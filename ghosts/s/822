  
ElvisMe: | # increase res
    my $bay = ar.bay ||= 'bay';
    
ElvisYou: | # YOUR
    my $M = [];
    G.c.bay ||= 'bay';
    `rm -rf G.c.bay/p/*`;
    m Opper
    m Udder
    for my $C (@$M) {
        # opens new land
        Rw CellDivision $C;
        s&pid || return;
        # first handles output
        G.c.opid ||= s&pid;
    }
Opper: | # consolidato
    Js&bowls++ ||
        Rw GhosMe;
    # receive W and switch through same telephone wire
    n Baye
    #return;
    snooze 222;
    n Fish
    n Opera
CellDivision: |
    my $i = G.c.oipi++;
    my $pa = $$;
    (s&pid = fork()) && return;
    G.c.oparent = $pa;
    G.c.oipi = 0;
    $0 .= " $i";
    if ($C && ref $C eq 'HASH') {
        $0 .= ":C.t";
        ar.take = C.t;
    }
    saybl "CellDivision: $0";
    Rw Washup;
    n $C
Udder: | # go waiter
    # sets our W output
    Js&bowls++ ||
        Rw CleanUdder;
    # to resume
    while (1) {
        $_ = <STDIN>;
        chomp;
        snooze 333;
        $_ =~ /\w/ || next;
        my $C = eval { djson $_ };
        if ($@) {
            sayre "NOT json C: $_";
            $@ = '';
            return;
        }
        Rw CellDivision
            || next;
        saybl "Done Udder";
        return saybl "Uddoff" if T.Uddoff;
    }
CleanUdder: | # dream feed connection Dejo->Ualve
    # set trip Dejo mo 7 to Js&ze = 'Flap'
    G&Ti,Trips=>[Catchelism=>''=>\'W:Dejo,At:mo,Acv:7'],$_
        for  &acgtlr{
            my $J = s&J;
            Js&ze = 'Ualve'
        };
Ualve: | # Udders' W z out for an Opper
    # 
    e&t eq 'z' || die "Not e z";
    my $z = e&s;
    my ($t) = @$z;
    my $i = Js&teli.>t.t ++;
    
    my $elv;$elv = &C{
        $C = G&hup,$C;
        C.y = C.y.cv;
        
        C.sc.z = [map{$elv->($_)}@{C.sc.z}] if C.sc.z;
        [C.t,C.y,C.c,C.sc]
    };
    my $d = "G.c.bay/p/$$/W";
    `mkdir -p $d`;
    my $f = "$d/t.t\.$i";
    write_file($f, sjson([map{ $elv->($_) }@$z])."\n");
    
    my $pull = [Ilan=>[f=>$f]];
    write_file("G.c.bay/p/Opper/in",{append=>1},sjson($pull)."\n");
    
Rebase: | # pull W into C=plaz
    # from many place's writings
    # from d p t i
    
            my $Nf = [];
            if ($i > 0) {
                if (!defined s&ie || s&ie < $i - 1) {
                    my ($i,$p) = ($i,$p);
                    my $oi = $i;
                    $i--;
                    branch: while (-f "$d/p/$p/pa") {
                        1 && say "   in to: ".`cat $d/p/$p/so`." For W/$t.$i";
                        $p = read_file "$d/p/$p/pa";
                        -e "$d/p/$p" || die "No find pid $p ";
                        while (-f "$d/p/$p/W/$t.$i") {
                            1 && say "    -W $d/p/$p/W/$t.$i";
                            last branch if defined s&ie && $i == s&ie;
                            unshift @$Nf, "$d/p/$p/W/$t.$i";
                            last branch if $i == 0;
                            $i--;
                            
                        }
                    }
                    @$Nf || die "Wanted news $d $t: s&i-$oi"
                }
            }
            s&ie = $i;
            push @$Nf, "$d/p/$p/W/$t.$i";
            
    Rw UpZs $Nf;
UpZs: |
            for my $s (@$Nf) {
                my $z = read_file($s);
                $z = djson $z;

                my $elv;$elv = &C{
                    $C = G&Ct,$C;
                    s&z = [map{$elv->($_)}@{s&z}] if s&z;
                    $C
                };
                #sayre "Do ".wdump 4, $z;
                $z = [map{ $elv->($_) }@$z];

                push @{s&zin||=[]}, @$z;
            }

