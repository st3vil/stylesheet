
Doings: | # Opera's changables, patch bay...
    my $M = [];
    y.at.bgh = '7892';
    # TODO sc css blocks others compiling to sc css in om_css_58/59
    y.at.css = 'border-radius:3em';
    y.at.ab = 1;
    
    
    my $t = 'Luca';
    47s&being = $t;
    my $no;
    my $first = !Js&bowls++;
    # etc
    if ($t eq 'Luca') {
        m comtu=>''=><<''
            U:Vindego  loop:3
            U:Luca asap
            U:Text
    }
    elsif ($t eq 'Ritim') {
        m comtu=>''=><<''
            U:Vindego  loop:12
            U:Ayer asap
            U:Ritim
            U:Puzl
            U:Player
            U:ACGT
            U:Tel
            U:Woov
    }
    elsif ($t eq 'Player') {
        m comtu=>''=><<''
            U:Vindego  loop:2
            U:Player asap
    }
    elsif ($t eq 'Ayer') {
        if ($first) {
            G&timer,0.4,$_ for &{ G&elph,Ghostrepel=>''; };
        }
        m comtu=>''=><<''
            U:Vindego  loop:2
            U:Ayer
            U:Flips
            U:Text
            U:ElvisMe
    }
    elsif ($t eq 'Vin') {
        if ($first) {
            G&timer,0.4,$_ for &{ G&elph,Ghostrepel=>''; };
        }
        m comtu=>''=><<''
            U:Vindego  loop:4
            U:Valve
            U:Tunes
            Tunes:Tunes
            U:DoSome asap
            U:Photon
            :Ghostig
            U:Text
    }
    elsif ($t eq 'Woov') {
        if ($first) {
            G&timer,0.4,$_ for &{ G&elph,Ghostrepel=>''; };
        }
        m comtu=>''=><<''
            U:Woov asap
            U:Waits
            :Ghostig
            U:Text
    }
    elsif ($t eq 'Photon') {
        G&elph,Ghostrepel=>'';
        m comtu=>''=><<''
            U:Photon asap
            U:Udder
            U:ElvisMe
    } #c
    elsif ($t eq 'DoSome') {
        m comtu=>''=><<''
            Udder:Text
            Udder:DoSome asap
            Udder:ElvisMe
            :Donot
            :Dopud
            :Chase
    }
    elsif ($t eq 'Photon') {
        m comtu=>''=><<''
            Udder:Blinks asap
            Blinks:Dopud asap
            :Chase
    }
    elsif ($t eq 'Photon') {
        m comtu=>''=><<''
            Udder:DoSome asap
            Udder:Calg
            DoSome:ReSim
            Calg
            Calg:Dopud
    }
    else {
        die "Unknown T t: $t";
    }
    
    if ($first) {
        unless (no.ghoster) {
            G&elph,Waytch=>'';
            5s&desi = "Ghoster";
            no.repel ||  
                G&timer,0.4,$_ for &{ G&elph,Ghostrepel=>''; };
        }
    }
    
    my @M = @$M;
    @$M = ();
    for (@M) {
        if (_.t eq 'comtu') {
            my @l = split "\n", _c&s;
            for my $l (@l) {
                my ($t,$c,$etc) = split / /,$l,3; # ' ' expands?
                $c = G&peel,$c;
                c.etc = G&peel,$etc if $etc;;
                m $t=>-comtu=>{%$c}
            }
        }
        else {
            die  "Unknown T ($t) c: ".ki $_;
        }
    }
    $M
Ghosi: |
    Rw Tiot;
    n Ghostrepel=>V
    T.op || return
        n err=>2=>"Notop",'%hs:138'
    my $l = G&op,'t:le';
    my $v = ls&J;
    T.op = vs&top || die "vnotop";
    my @le = G&op;
    n le=>-pud=>\@le;
    #
Ghostfall: |
    Rw Ghoster;
    eval {
        n Ghostrepel
    };
    sayre $@ if $@;
    $@ = "";
Ghostrepel: |
    #m _.t=>-prod=>{s=>$_} for @ma;
    #
    #my $o = G&A,o=>6,$J,\@ma,'producto';
    #delete Js&jo.producto;
    ##F
    #n le=>-pud=>[oc&rsl];
    #n eo=>-pre=>join("\n",'WayHeave:',@{oc&rsl});
    y.cyc = 100;
    Js&loose = 1;
    s&fs = 6;
    y.at.hue = 88;
    y.at.fs = 8;
    s&mw = 22;
    
    Jc&filter = c&filter if c&filter;
    # the thing is the thing, the pi giveth emotion
    Js&ein.pi.Gup.sMJ = &sMJjeTC{
        es&file =~ Jc&filter || return if Jc&filter;
        
        Js&TV.>e.t = G&Ct,[e.t=>''=>{s=>ec&s},{dig=>es&dig}];
        
        Js&sendguess = 47s&being || 47s&knowing || 'Woov';
        Rw Sendeth if e.t =~ /^(Photon|Woov|bay)$/ || es&file =~ /s\/81/;
        
        my $d = Js&lat;
        Js&lat = hitime();
        if ($d) {
            $d = Js&lat - $d;
            Js&say .= join(".",("") x int($d / 15));
            Js&say =~ s/^[^\.]+\.*// while length(Js&say) > 50;
        }
        
        Js&say .= e.t.' ';
    };
    S
    
    ##
    Rw Tiot;
    Js&ein.bo = 'Doable';
    n Goh=>-mez
    my $says = join",",sort keys %{Js&TV||{}};
    $says || return delete Jc&tape;
    n see=>3=>{s=>$says},'%dos:Sendeth'
Sendeth: |
    unless ( us&S ) {
        my $t = Js&sendguess || 'Woov';
        my $z = [values%{Js&TV||[]}];
        my $w = G&Ct,[w=>''=>{s=>$z}];
        G&elph,Elvis=>[opt=>''=>{s=>"$t:Go"=>etc=>{e=>$w}}];
        Js&say = '';
    }
    #
    %{Js&TV||[]} = ()
Go: | # Ghosteths: you receiving your mail
    Js&ein.t.w.sMJ = &sMJ{
        5s&desi = 'Ghoster';
        1 && sayyl "Go transceiving: ".ki $s;
        G&elph,WayHeave=>[w=>$s]
    };
    S
pi/prod: |
    if (G&always,J.sc,digup=>ss&digup) {
        S on
    }
    #
    n t=>1=>C.t=>'%hs:738'
    
    
Clutter: | # codes
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    y.at.miw = 22;
    y.at.dis = 2;
    Js&ein.t.w = &Te{
        Jc&es = e.c.s;
    };
    S
    # s = pin
    Jc&es = $s if $s;
    $s = Jc&es;
    Js&ever = [uniq @{Js&ever}, $s];
    if (1) { # out of memory
        my $f = 's/825';
        n $f=>-codof=>{}=>'%not,dis:0'
        m "$f are"=>-snakes=>{s=>$s},{ze=>[ G&op,'3' ]}
    }
    
    n hist=>8=>"h: @{Js&ever}",'%dis,hs:347'
    my $codon = &t{
        my $w = G&wops,$t;
        my $s = "wc&s";
        my @l = split "\n",$s;
        
        m w.t=>-tin=>{s=>$s}, {dig=>ws&dige,ha=>1}
    };
    $codon->($s);
    #$codon->('Clutter');
    
    # make a timer that asks Opper to redo it
    #y.imp++;
    #T.oT.ok = 1;
pi/snakes: | # centered views of clutter
    y.at.mw = 25;
    y.at.lh = 0.6;
    y.at.ml = 4;
    y.at.dis = 1;
    y.at.bo = '4px solid black';
    delete c&s;
            
    my $z = delete s&ze || die "No clutter";
    my @c = @$z;
    my $i = 0;
    for (@c) {
        $_ = G&Ct=>[$_=>''] if ref $_ ne 'HASH';
        _.t eq $s && last;
        $i++;
    }
    my $c = $c[$i];
    my $ii = $i;
    if (c&wi) {
        $i -= c&wi / 2;
        $i = 0 if $i < 0;
    }
    else {
        $i = 0;
    }
    while (exists $c[$i]) {
        my $C = $c[$i];
        my $d = $ii - $i;
        $d *= -1 if $d < 0;
        my $fs = int(40 / ($d+1) );
        $fs = 3 if $fs < 3;
        m C.t=>''=>C.t=>{fs=>$fs}
        $i++;
        last if c&wi && $i > $ii + c&wi / 2;
    }
    for my $C (@$M) {
        s&ma = 0.3;
        s&hs = int(rand 9).int(3+rand 6).int(3+rand 6);
        #C&fs = int(6 + rand 14);
        s&dos = 'Snack';
        s&sha = '2 2 5 849'
    }
    
Snack: |
    my $l = e&hC ->[-1];
    #G&give,Toter=>se=>[];
    G&elph,Clutter=>W=>{s=>lc&s}
Woov: | # look at Stoov, who is doing W
    Jc&tape = 'Dejo';
    Js&ein.bo = 'Doable';
    S
    n Clutter=>W=>C.t
    # wove bay, the W thaw with their local version
    my $i = Js&bowls++;
    if ($i == 2) {
        n Ghostig
    }
    elsif ($i == 1) {
        m Elvising=>-otop
        m ElVerse=>-otop
        m ElChorus=>-otop
    }
    else {
        1 &&
        n Stuvv
        1 &&
        n Stuvv=>-xofor
        # ##
        n Elvising=>-xofor_2
        n Elvising=>-Wave_3
        #n G.c.bay=>-bay_4
    }
    
    
Hutter: | # wire Store to bay, be 4=Z, 6=zafe
    my $h = hitime();
    local A.4.t = 'Z';
    local G.c.Stash = "G.c.bay";
    local G.c.t6 = 'zafe';
    #`rm -rf G.c.bay/Z`;
    
    ar.cb && ar.cb->();
    
        my $d = G&ron,hitime()-$h;
        n delta=>3=>"Took $d",'dis:1'
    
    
    
Stuvv: | # seeing W slosh
    #Jc&tape = 'Dejo';
    Rw Hutter $cb:_ for &{
        if (0) {
            T.H = 4;
            n ElBridge
        }
        else {
            T.H = 4;
            n Elvising
        }
    }
    my @dm = G&op;
    $deltan->();
    #
    #
    #my $o = G&A,o=>6,$J,\@dm,'producto';
    
    n ElBridge=>1=>"Fodu"
    #{s=>oc&rsl}
    
pi/xofor: |
    Rw pi/forWosc
        && return;
    $s = c&osc;
    my $xo = ss&xo || return
        n err=>2=>"Noxo",'%hs:138'
    n xo=>-pud_2=>{s=>$xo}
pi/otop: |
    Rw pi/forWosc
        && return;
    my $o = G&A,o=>6=>$J=>T.op;
    m osc=>2=>{s=>join("\n",@{oc&rsl})}
    
    
pi/Wave: | # find their W
    Rw pi/forWosc
        && return;
    m osc=>-pud_2=>{s=>c&osc,dl=>1}
    # inclusions whose lv feed into this lv (probably) have sJ
    my @m = G&op,'sW:';
    m inc=>-pud_3=>{s=>\@m}
    # expulsions - included in our lv/topuary, no 0.9, implies elvising
    # thus n c&W s&z = [what c&W should have] (according to us)
    my @w = G&op,'cW:';
    m exp=>-pud_4=>{s=>\@w}
    
    
pi/forWosc: | # find their W
    # can be Rw to sort this out first
    y.at.dis=3;
    n t=>1=>c&s
    n w=>12=>s&pi=>'%hs:694,fs:7'
    n c&s=>V
    my $t = T.op;
    $t || return
        n err=>2=>"Notop:c&s",'%hs:138'
    c&osc = t.y.s || return
        n err=>2=>"Noosc",'%hs:138'
    return;
Whats: | # given f, a piece of the bay or a bit of any kind of name to acquire
    Rw Tiot;
    Rw Elationist;
    S
    my $s = Jc&es || return
        n not=>2=>"nothing",'%hs:384'
    
    n how=>12=>sc&how
    n s.t=>-pud_2=>{s=>sc&s,dl=>4}
    
    
    
    
Waits: | # ghost pusher
    Jc&tape = 'Dejo';
    # etc
    #
    #
    n Waytch
    5s&desi = "Waits";
    say "Udoffi";
    
    T.oT.Uddoff = 1;
    n cee=>-pud=>{s=>$C}

