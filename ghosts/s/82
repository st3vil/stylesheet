

ElvisOver: | # Goh-listening way update channeling
    # must be forked from testrun due to wander, exit
    # testrun must check that it completes (waitpid & so on)
    # so pi/test wants to S initially and begin when all of 3's tests are declared
    # and 3 osc sweeps up children
    # pg way listen (G'd)
    my $t = Rw Towering Ang
        || return;
    return unless c&Se == 1;
    
    if (1) { # find way to relay test info
    # number of failures doesnt show in $? if we use exit?
    if (my $pid = fork()) {
        waitpid($pid,0);
        die "child failed with $?" if $?;
        is $?, 0, "Child completed";
        return;
    }
    }
    
    G.mkoJ->(); # frees us from test exit
    my $til = sub {
        my ($d,$cb) = @_;
        Rw timer $d $cb;
    };
    my $f = 'g/s/99';
    die "Already full of ".ki $_ for
        grep{ 'ElvisOvary' ne join'',keys %$_ }
        map { LoadFile($_) } grep { -s $_ } $f;
    
    my $blank = &{
    write_file($f, <<'');
        ElvisOvary: |
            3 + 5
    };
    $blank->();
    
    u ElvisOvzio=>''=><<'','of:w'
        my $v = Rw ElvisOvary;
        n Taking=>''=>$v
    
    
    $til->(4=>sub {
    
        t.e =
        n ElvisOvzio
        t.cs->('sc top', "ElvisOvzio way used");
        
    t.e =
    n Waytch=>W=>{filter=>qr{/s/99$}}
    t.cs->('sc lv,olv', "Waytch holding on to Mez");
    
    t.e =
    n Listen
    t.cs->('sc lv,olv', "Listen listening to Goh for Mez");
    t.cs->('sc top', "Listen again");
    
    $til->(0.02, sub { `echo '    -1' >> $f` });
    $til->(5.42, sub { `echo '    -1' >> $f` });
    $til->(9.8, sub {
        t.e =
        n Waytch
        t.cs->('sc top', "Waytch received notifies");
        t.e =
        n WayHeave
        t.cs->('sc top', "WayHeave has latest patch");
        t.e = 
        n ElMatron
        my $in = 0;
        my $unt = sub {
            my $l = shift;
            $in++ if $l =~ /^\s+w 0.001/;
            $in
        };
        t.cs->({ntos=>'sc J sc u sc s sc top',
            grepl=>$unt},"A5 u includes WayHeave");
        t.cs->('sc J sc u sc s sc lastK c s',"A5 u last wave");
        t.e =
        n ElvisOvzio
        t.cs->('sc top', "ElvisOvzio used new way");
        my $mo = t.ntos->('mo');
        t.dd->(mo.c.want, "ElvisOvzio notices pin change");
        
        t.e =
        n Mez
        t.cs->('sc top', "see Mez");
        t.e =
        n Listen
        t.cs->('sc top', "see Listen");

    });
    $til->(9.9, sub {
        $blank->();
        exit;
    });
    
    });
    
    
    
    
    
WayHeave: | # hold way updates to G since it began, plumbed by Waytch
    u Zpace
    Js&ein.t.w.sMJ = &sMJjeTC{
        local A.V = 2;
        ss&dig && sc&s || die "Not way? ".ki $s;
        m s.t=>'',sc&s,{digup=>ss&dig,of=>'w'};
    };
    S
    
    @$M = @{Js&M||[]};
    y.res = 1; # unsprawl by _.t
    # should be s9, is s8, late enough to consider itself already
    #   when called again in ElMatron
    Jc&sang = &acgt{
        sayyl "Updates pushing A.5.t from A.1.t";
        G&elph,A.5.t,[w=>A.1.t]
    };
    
    
    
Waytch: | # for ghost updates
    # to plot way changed into ElMatron and call the ghoster to calc wanderince
    u Zpace
    
    Jc&filter = c&filter if c&filter;
    Js&ein.pi.Gup.sMJ = &sMJjeTC{
        es&file =~ Jc&filter || return if Jc&filter;
        m e.t=>''=>{s=>ec&s}=>{dig=>es&dig}
    };
    
    S
    n Goh=>-mez
    
    y.n = 5;
    y.cyc = 100;
    @$M = @{Js&M||[]};
    Js&sels.dig.1 = &acgt{
        G&elph,WayHeave=>[w=>$C]
    };
pi/takeM: |
    y.cyc = 1000;
    @$M = @{c&M};
    @{c&M} = ();
pi/mez: | # your interpreted pg listener, makes e to A.2
    # yea heayh
    J.bowls ++ ||
    n Mez=>[to=>c&s]
    
pi/listen: | # your pg listener, makes e to A.2
    # yea heayh
    J.bowls ++ ||
    n Listen=>[to=>c&s]
    
Mez: | # listener for mezages with line protocols
    # inc /^[/ -> many e
    #     /^CCC (\w+) -> large item in mez where t=$1
    # like and in front Listen,
    # line clevered into e as it goes through to client
    u Zpace
    u pg
    y.res = 1; # M t replant
    
    Rw sWscribe; # has clients
    
    Js&eout.t.l = "heard elvises"; # fyi
    # distribute noises to froms
    Js&ein.t.l = &TesC{
        # large messages stashed and referred to
        $s = G&dmez,$1 if $s =~ /^CCC (\d+)$/;
        
        my $es = eval { djson $s };
        if ($@) {
            sayre "Spat: $@\n\nAbout: ".ki $s if $@;
            $@ = "";
            return;
        }
        
        for my $s (ref $es eq 'ARRAY' ? @$es : $es) {
            # e must go around a kind of corner here
            # for the hz strick cececece will not divide
            for (grep{ _c&s eq es&listen } @{Js&M||[]}) {
                _s&W || die "noW listenee ".ki$_;
                n _s&W => [$s]
            }
        }
        return T.pos = 0;
    };
    
    S
    
    Rw sMaps listen; # pour sM s->sc.listen
    
    # relative to el - overall C change
    my $l = Js&sels.listen = {};
    l.1 = &acgt{
        n Listen=>[to=>C.t]
    };
    l.9 = &acgt{
        n Listen=>[not=>C.t]
    };
    
    
    
    #
sWscribe: | # for your M of W wanting s
    Js&ein.t.to.sMJ = &sMJjeT{
        Js&tri.>$s.>j.t ++ && sayre("Ledup j.t")
            && return T.pos = 0;
        j.3 eq $j || die "listen $s to j.t not W";
        m "j.t $s"=>''=>{s=>$s,j=>$j}=>{W=>j.t}
    };
    Js&ein.t.not.sMJ = &sMJj{
        @$M = grep { _.t ne "j.t $s" } @$M;
    };
    
sMaps: | # maps unique Js&M.c.s into m $t:s and sc.$m0 = $s
    my ($sck) = @{ar.m||[]};
    # unique listen addresses
    my $st;
    $st.>_c&s.>_s&W = 1 for @{Js&M||[]};
    
    for my $s (sort keys %$st) {
        my $v = $st.>$s;
        my $sc = {};
        sc.clients = join' ',sort keys %$v;
        $sc.>$sck = $s if $sck;
        m $s=>''=>{}=>$sc
    }
sMpi: | # many pi=$m0 s=$s j=$j in W order
    my ($pi) = @{ar.m||[]};
    # so the pi can do tests etc on it
    # or be Ting the W to wake osc observer
    #  that the inner is further instructions for
    
    my $st = {};
    acu $st, _s&W, $_ for @{Js&M||[]};
    
    for my $s (sort keys %$st) {
        my $z = $st.>$s;
        for my $D (@$z) {
            m Ds&W." ".Dc&s=>''=>{pi=>$pi,s=>Dc&s,j=>Dc&j}
        }
    }
Listen: | # pg listen pool
    u Zpace
    u pg
    y.res = 1; # M t replant
    
    # accumulate the froms
    Rw sWscribe;
    
    Js&eout.t.l = "heard lines"; # fyi
    # distribute noises to froms
    Js&ein.t.l = &TesC{
        map {
            _s&W || die "noW listenee ".ki$_;
            n _s&W => $C
        } grep {
            _c&s eq es&listen 
        } @{Js&M||[]};
        T.pos = 0;
    };
    S
    
    Rw sMaps listen;
    
    y.imp++ if T.forked; # relistens all
    G&has,forked=>1; # <^ waker in between
    
    G&db ->unsubscribe('notification');
    G&db ->on(notification => &dtps{
        $s = encode_utf8($s);
        my $h = slm(9,dig($s));
        return sayre "Seen before (from $p)" if 1s&een.>$h ++;
        n Listen=>[l=>''=>{s=>$s}=>{listen=>$t}]
    });
    
    # for oscillation of sc.listen
    # relative to el - overall C change
    my $l = Js&sels.listen = {};
    l.1 = &acgt{
        G&db ->listen(C.t);
    };
    l.9 = &acgt{
        G&db ->unlisten(C.t);
    };
    

