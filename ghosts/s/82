

ElvisOver: | # use Goh notify for way change introduct
    # must be forked from testrun due to wander, exit
    # testrun must check that it completes (waitpid & so on)
    # so pi/test wants to S initially and begin when all of 3's tests are declared
    # and 3 osc sweeps up children
    # pg way listen (G'd)
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    return unless c&Se == 1;
    G.mkoJ->(); # frees us from test exit
    my $til = sub {
        my ($d,$cb) = @_;
        Rw timer $d $cb;
    };
    my $f = 'g/s/99';
    die "Already full of ".ki $_ for
        grep{ 'ElvisOvary' ne join'',keys %$_ }
        map { LoadFile($_) } grep { -s $_ } $f;
    
    my $blank = &{
    write_file($f, <<'');
        ElvisOvary: |
            3 + 5
    };
    $blank->();
    
    u ElvisOvzio=>''=><<'','of:w'
        my $v = Rw ElvisOvary;
        n Taking=>''=>$v
    
    
    $til->(4=>sub {
    
        t.e =
        n ElvisOvzio
        t.cs->('sc top', "ElvisOvzio way used");
        
    t.e =
    n Waytch=>W=>{filter=>qr{/s/99$}}
    t.cs->('sc lv,olv', "Waytch holding on to Mez");
    
    t.e =
    n Listen
    t.cs->('sc lv,olv', "Listen listening to Goh for Mez");
    t.cs->('sc top', "Listen again");
    
    $til->(0.02, sub { `echo '    -1' >> $f` });
    $til->(5.42, sub { `echo '    -1' >> $f` });
    $til->(9.8, sub {
        t.e =
        n Waytch
        t.cs->('sc top', "Waytch received notifies");
        t.e =
        n WayHeave
        t.cs->('sc top', "WayHeave has latest patch");
        t.e = 
        n ElMatron
        my $in = 0;
        my $unt = sub {
            my $l = shift;
            $in++ if $l =~ /^\s+w 0.001/;
            $in
        };
        t.cs->({ntos=>'sc J sc u sc s sc top',
            grepl=>$unt},"A5 u includes WayHeave");
        t.cs->('sc J sc u sc s sc lastK c s',"A5 u last wave");
        t.e =
        n ElvisOvzio
        t.cs->('sc top', "ElvisOvzio used new way");
        my $mo = t.ntos->('mo');
        t.dd->(mo.c.want, "ElvisOvzio notices pin change");
        
        t.e =
        n Mez
        t.cs->('sc top', "see Mez");
        t.e =
        n Listen
        t.cs->('sc top', "see Listen");

    });
    $til->(9.9, sub {
        $blank->();
        exit;
    });
    
    });
    
    
    
    
    
WayHeave: | # hold way updates to G since it began, plumbed by Waytch
    u Zpace
    Js&ein.t.w.sMJ = &sMJjeTC{
        local A.V = 2;
        ss&dig && sc&s || die "Not way? ".ki $s;
        m s.t=>'',sc&s,{digup=>ss&dig,of=>'w'};
    };
    S
    
    @$M = @{Js&M||[]};
    y.res = 1; # unsprawl by _.t
    Jc&sang = &acgt{
        1 && sayyl "Updates pushing A.5.t from A.1.t";
        G&elph,A.5.t,[w=>A.1.t]
    };
    
    
    
Waytch: | # for ghost updates
    # to plot way changed into ElMatron and call the ghoster to calc wanderince
    u Zpace
    
    
    Jc&filter = c&filter if c&filter;
    Js&ein.pi.Gup.sMJ = &sMJjeTC{
        es&file =~ Jc&filter || return if Jc&filter;
        m e.t=>''=>{s=>ec&s}=>{dig=>es&dig}
    };
    
    S
    n Goh=>-mez
    
    y.n = 5;
    y.cyc = 100;
    @$M = @{Js&M||[]};
    Js&sels.dig.1 = &acgt{
        G&elph,WayHeave=>[w=>$C]
    };
pi/takeM: |
    y.cyc = 1000;
    @$M = @{c&M};
    @{c&M} = ();
pi/mez: | # your interpreted pg listener, makes e to A.2
    # yea heayh
    J.bowls ++ ||
    n Mez=>[to=>c&s]
    
pi/listen: | # your pg listener, makes e to A.2
    # yea heayh
    J.bowls ++ ||
    n Listen=>[to=>c&s]
    
Mez: | # listener for mezages with line protocols
    # inc /^[/ -> many e
    #     /^CCC (\w+) -> large item in mez where t=$1
    # like and in front Listen,
    # line clevered into e as it goes through to client
    u Zpace
    u pg
    y.res = 1; # M t replant
    
    Rw sWscribe; # has clients
    
    Js&eout.t.l = "heard elvises"; # fyi
    # distribute noises to froms
    Js&ein.t.l = &TesC{
        # large messages stashed and referred to
        $s = G&dmez,$1 if $s =~ /^CCC (\d+)$/;
        
        my $es = eval { djson $s };
        if ($@) {
            sayre "Spat: $@\n\nAbout: ".ki $s if $@;
            $@ = "";
            return;
        }
        
        for my $s (ref $es eq 'ARRAY' ? @$es : $es) {
            # e must go around a kind of corner here
            # for the hz strick cececece will not divide
            for (grep{ _c&s eq es&listen } @{Js&M||[]}) {
                _s&W || die "noW listenee ".ki$_;
                n _s&W => [$s]
            }
        }
        return T.pos = 0;
    };
    
    S
    
    Rw sMaps listen; # pour sM s->sc.listen
    
    # relative to el - overall C change
    my $l = Js&sels.listen = {};
    l.1 = &acgt{
        n Listen=>[to=>C.t]
    };
    l.9 = &acgt{
        n Listen=>[not=>C.t]
    };
    
    
    
    #
sWscribe: | # for your M of W wanting s
    Js&ein.t.to.sMJ = &sMJjeT{
        Js&tri.>$s.>j.t ++ && sayre("Ledup j.t")
            && return T.pos = 0;
        j.3 eq $j || die "listen $s to j.t not W";
        1 && sayyl "J.t list $s  -> j.t  ".ki$e;
        m "j.t $s"=>''=>{s=>$s,j=>$j}=>{W=>j.t}
    };
    Js&ein.t.not.sMJ = &sMJj{
        sayre "J.t unlistens $s j.t";
        @$M = grep { _.t ne "j.t $s" } @$M;
    };
    
sMaps: | # maps unique Js&M.c.s into m $t:s and sc.$m0 = $s
    my ($sck) = @{ar.m||[]};
    # unique listen addresses
    my $st;
    $st.>_c&s.>_s&W = 1 for @{Js&M||[]};
    
    for my $s (sort keys %$st) {
        my $v = $st.>$s;
        my $sc = {};
        sc.clients = join' ',sort keys %$v;
        $sc.>$sck = $s if $sck;
        m $s=>''=>{}=>$sc
    }
Listen: | # pg listen pool
    u Zpace
    u pg
    y.res = 1; # M t replant
    
    # accumulate the froms
    Rw sWscribe;
    
    Js&eout.t.l = "heard lines"; # fyi
    # distribute noises to froms
    Js&ein.t.l = &TesC{
        map {
            _s&W || die "noW listenee ".ki$_;
            n _s&W => $C
        } grep {
            _c&s eq es&listen 
        } @{Js&M||[]};
        T.pos = 0;
    };
    S
    
    Rw sMaps listen;
    
    y.imp++ if T.forked; # relistens all
    G&has,forked=>1; # <^ waker in between
    
    G&db ->unsubscribe('notification');
    G&db ->on(notification => &dtps{
        $s = encode_utf8($s);
        my $h = slm(9,dig($s));
        return sayre "Seen before (from $p)" if 1s&een.>$h ++;
        n Listen=>[l=>''=>{s=>$s}=>{listen=>$t}]
    });
    
    # for oscillation of sc.listen
    # relative to el - overall C change
    my $l = Js&sels.listen = {};
    l.1 = &acgt{
        G&db ->listen(C.t);
    };
    l.9 = &acgt{
        G&db ->unlisten(C.t);
    };
    
pg: |
    u i
    db:
        use Mojo::Pg;
        G&has,pg=>1;
        my $pg = 4s&pg ||= Mojo::Pg->new('postgresql://s@/s');
        delete 1s&db unless 1s&db.stylepid eq $$;
        1s&db ||= do {
            my $db = $pg->db;
            db.stylepid = $$;
            $db
        };
    
    qp:
        G&db ->query($s,
        map{!ref && defined $_ ? decode_utf8($_) : $_ }
        @Me);
    
    tyable:
        $s ||= 'names';
        my @col = map{split','} @Me;
        push @col, 't','y real','c json','sc json';
        my $colum = join', ',map{s/:/ /g;/ /?$_:"$_ text"} @col;
        my $q = "create table if not exists $s ($colum)";
        say "Create: $q from".wdump 2, [$s,@Me] ;
        G&qp,$q
    
    qh:
        my @o;
        G&qp,$s,@Me ->hashes->map(sub{push @o,$_});
        for my $o (@o) {
            for my $k (keys %$o) {
                my $v = $o.>$k;
                $o.>$k = encode_utf8($v) if defined $v && !ref $v;
            }    
        }
        sayre "".(@o-1)." rows dropped from: @Me\n$s" if !wantarray && @o > 1;
        wantarray ? @o : $o[0]
    
    Jr:
        G&qh,<<'',$s
            select * from names where t = ?
    
    # select and then insert somewhat, osc updates it
    # with o {k=>v}, scalar ref v is sql hack #
    decj:
        $s = G&hup,$s unless @Me;
        my $auto = @Me == 1 && $Me[0] eq '';
        for (c=>sc=>@Me) {
            $_ || next;
            $s.>$_ ||= {} if $auto;
            $s.>$_ && !ref $s.>$_ || next;
            $s.>$_ = djson $s.>$_;
        }
        $s
    encj:
        $s = G&hup,$s;
        $s.>$_ = sjson $s.>$_ for 'c', 'sc';
        $s
    
    pet: %acgt:s o
        my @ks = sort keys %$o;
        my @sel;
        my $sel = "select * from $s where ".join" and ",map{
            my $z = $o.>$_;
            ref $z eq 'SCALAR' ? "$_ $$z" : do {
                push @sel, $z;
                "$_ = ?"
            };
        }@ks;
        my $n = G&qh,$sel,@sel;
        $n ||= do {
            my @ac = grep { ref $o.>$_ ne 'SCALAR' } @ks;
            my @in = map { $o.>$_ } @ac;
            my $in = "insert into $s (".join(',',@ac)
                .") values (".join(",",('?') x @ac)
                .") returning *";
            G&qh,$in,@in;
        };
        $n
    
    # add listenance via GW
    liz: %acgt:s J
        $s ||= C.c.W;
        $J ||= C.c.W;
        G.W.noti.>$s = $J;
        G.W.lizdb->listen($s) if G.W.lizdb;
        1
    
    # send message
    zen:
        my $m = @Me > 1 || ref $Me[0] ? sjson(\@Me) : $Me[0];
        if (length $m > 5000) {
            #G&tyable,mez=><<'' if !G.tabup++;
            #    f,s,ts:timestamptz:default:now(),mid:serial:primary:key
            my $h = G&qh,<<'',G.t,$s,$m;
                insert into mez (f,t,s) values (?,?,?) returning mid
            sayyl "Length of zen/notify $s: ".length $m;
            $m = "CCC h.mid";
        }
        else {
            $m = decode_utf8($m);
        }
        G&db ->notify($s,$m);

    dmez:
        my $h = G&qh,<<'',$s;
            select f,t,s,mid from mez where mid = ?
        length(h.s) || die "mized mez: $1";
        Rw timer $d=2 $cb:_ for sub { G&qp,<<'',h.mid };
            delete from mez where mid = ?
        $s = h.s;
        sayre "CCCC: h.t -> ".ki$s;
        $s

