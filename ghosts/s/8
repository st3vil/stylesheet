pi/pud: |
    Rw Typerack;
    
    # how many M inners before 'more' (depth first)
    A.3.C.c.intlim ||= 13;
    # max depth before like nothash
    c&dl = A.2.C.c.dl;
    c&dl = 5 if !defined c&dl;
    # travel boosts/cons depth
    c&dl += 1 if c&depth < 5 && C.t eq 'sc';
    c&dl += 2 if c&depth < 6 && C.t eq 's' && A.2.C.sc.istycsc;
    c&dl -= 1 if C.t eq 'y' && A.2.C.sc.istycsc;
    y.in = 0.21;
    my $ind = join'', ('  ') x (J.A.d - 1);
    
    n ind=>0.07=>"\n$ind"
    n sli=>0.08=>"<  ",'%hs:784'
    n title=>1=>"C.t"
    
    c&block = 'same' if $s eq A.2.C.c.s;
    c&block = 'b' if C.t eq 'ip' && A.2.C.t eq 'c';
    
    if (!c&block && ref $s eq 'HASH') {
        if (C.t eq 'G') {
            my $w = s.w;
            if (ref $w eq 'CODE' || ref \$w eq 'GLOB') {
                c&block = 'G';
            }
        }
        if (s.y eq $s) {
            C.sc.type = 'A';
            c&block = 'yA' if A.2.C.t eq 'y';
            c&block = 'AA' if A.2.C.sc.type eq 'A';
            if (c&block) {
                c&blos = "s.t @ s.cv";
                c&blos .= " (s.c.s.t)" if ref s.c.s eq 'HASH';
            }
        }
    }
    
    if (c&block) {
        n block=>2=>c&block,'%hs:855'
        c&blos &&
        n blocked=>21=>' '.c&blos,'%hs:827'
        return
    }
    
    my ($ks,$vs);
    if (ref $s eq 'ARRAY') {
        n is=>11=>'[','%hs:457'
        C.sc.type = 'array';
        $vs = [@$s];
        $ks = [0..(@$s-1)];
        if (A.2.2.C.sc.istycsc) {
            if (A.2.C.t eq 'c') {
                c&dl = 1 if C.t eq 'N';
            }
        }
    }
    else {
        if (ref $s ne 'HASH' || J.A.d > c&dl) {
            my $z = ki $s;
            my $bg;
            if (!ref $s) {
                $z =~ s/^!%://;
                $bg = ',bg:653';
                if (!defined $s) {
                    n know=>18=>'undef','%hs:845,fs:6'
                }
                elsif (!length $s) {
                    n know=>18=>"''",'%hs:845,fs:6'
                }
            }
            my $fs = 6;
            $fs = 8 if !ref $s;
            if (A.2.C.sc.istycsc) {
                if (C.t eq 't') {
                    $z = $s;
                    $fs = 23;
                }
            }
            if (A.2.2.C.sc.istycsc) {
                if (A.2.C.t eq 'y') {
                    $fs = 16 if C.t eq 'cv';
                }
            }
            
            n no=>2=>$z,"%fs:$fs,hs:398,lh:0.5,mt:1,mh:5$bg"
            return
        }
        if (s.y eq $s && J.A.d > c&dl) {
            return
            n A=>2=>"A s.t s.y.cv; ".ki(s.c)."    ".ki(s.sc);
        }
    }
    
    my ($hash,@ks) = Rw HashKs $s $ks $vs;
    
    n ind=>0.07=>"\n$ind"
    n siz=>12=>" x ".@ks,'%hs:283,fs:6';
    if (A.3.C.c.intl++ > A.3.C.c.intlim) {
        if (ref $s eq 'HASH') {
            if (defined s.t) {
                n peak=>3=>"s.t",'%hs:398,fs:11'
            }
        }
        return
        n more=>4=>"more",'%hs:544'
    }
    return if C.t =~ /^(ii?|up|T)$/
        || ( A.2.C.sc.type ne 'array' && C.t =~ /^\d+$/)
        #|| J.A.d > 5
        ;
    C.sc.css = 'border-left:3px solid 473' if @ks > 3;
    m $_=>-pud=>{s=>$hash->{$_}},'%ma:1' for @ks;
    
Typerack: | # makes a J for whitespaced typograph
    y.at.qs=1;
    y.at.ws=1;
    y.clos=1;
    A.3 = J.mo.J; # the W planted in A.4
    A.2 = J.Jiter; # the last J
    J.2 = A.2; # its last so A.2.2...
    #y.at.ml=J.A.d;
    c&depth = J.A.d;
    C.sc.istycsc = 1 if
        ref $s eq 'HASH' && defined s.t && s.y && (s.c || s.sc);
    
HashKs: | # order children, returns $hash,@ks
    # order children
    # use Walks/hord
    my $hord = sub {
        my ($s,$head,$tail) = @_;
        my ($he,$ta) = ([],[]);
        $head ||= [qw't cv y c sc'];
        $tail ||= [qw's z'];
        my $tw;
        for ([$he=>$head],[$ta=>$tail]) {
            my ($to,$k) = @$_;
            for my $t (@$k) {
                $s.>$t || next;
                $tw.>$t ++;
                push @$to, $t;
            }
        }
        my @mi = sort grep { !$tw.>$_ } keys %$s;
        [ map { [ $_ => $s.>$_ ] } @$he, @mi, @$ta ];
    };
    my (@he,@ta);
    push @he, qw't cv y' if C.sc.istycsc;
    push @ta, qw'c sc' if C.sc.istycsc;
    push @ta, qw'ip sip ipi T' if A.2.C.sc.istycsc && C.t eq 'c';
    
    my $se = ar.ks ? {map{$_=>shift@{ar.vs}}@{ar.ks}} : $s;
    my @ks = map{$_->[0]}map{@$_} $hord->($se,\@he,\@ta) if ref $se eq 'HASH';
    ($se,@ks)
    

