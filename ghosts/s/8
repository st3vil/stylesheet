ElvisLinkage: | # J succession of link
    my $t = Rw Telvis;
    my $pn = sub {
        my $s = shift;
        my $ty = sub{my $s = shift; $s && "s.t s.y.cv $s"};
        $ty->($s)."  ^ ".$ty->(s.y.prev)."  v ".$ty->(s.y.next)
    };
    my $tvlinkage = sub {
        my $tv = shift;
        $tv ||= c&so.sc.tv;
        my $yt = G&yttv,$tv;
        my @l;
        G&chew,$yt,\'cv,t',$_ for sub { push @l, $pn->(shift); };
        \@l
    };
    if ($n == 0) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
    if ($n == 1) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
    if ($n == 2) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
    if ($n == 3) {
        c&te =
        n ElvisLinkoy
        t.cs->('sc lastK c s','source');
        t.cs->({rsl=>$tvlinkage->()},'doorce');
    }
ElvisLinkoy: |
    # 123, 234, 345
    $s = 'seewooooorld';
    Rw pi/seawire + $s;
ElvisElvises: | # J e J,
    my $t = Rw Telvis;
    #A.V = 1;
    # your mo .e 
    # the J minded of=E awaken/resolve options
    # calls handlers or the pin to find handlers or handle as pin
    # handlers register into E (may want to J.ii only u wave '' or so)
    # handling e vars (via e&st -> G&e,'st', etc) tickles clues to pin
    G.ohno = [];
    delete A.4.sc.Jtv.Elvisrec->{0.1};
    
    if ($n == 0) {
        c&te =
        n Elviseso
        t.cs->('sc lastK c s','source');
        is 0+uniq(map{_.sc.J}values %{c&so.sc.tv.Elvisrec}), 1,
            "Same Elvisrec positioned twice";
        c&te =
        n Elvisrec
        t.cs->('sc lv,olv','lvour');
        
        t.cs->({rsl=>G.ohno},'none lost');
        
    }
    if ($n == 1) {
        c&te =
        n Walless=>W=>\'pin:Elviseso,droppy'
        t.cs->('sc lastK c s','source');
        c&te =
        n Elvisrec
        t.cs->('sc lv,olv','lvour');
        
        t.cs->({rsl=>G.ohno},'nonfirst lost');
    }
    if ($n == 2) {
        c&te =
        n Walley=>W=>\'pin:Elviseso,reeltool'
        t.cs->('sc lastK c s','source');
        c&te =
        n Elvisrec
        t.cs->('sc lv,olv','lvour');
        
        t.cs->({rsl=>G.ohno},'all lost');
    }
    
Elviseso: |
    #n ElBridge
    #return;
    1c&droppy = 1 if c&droppy;
    1c&reeltool = 1 if c&reeltool;
    my $e;
    $e = G&s,once=>"Dwiver";
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,twice=>"Sandpaper";
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,reeltool=>{s=>"Drier",us=>{p=>[['Elvisrec']]}};
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,twice=>"Dwivel";
    n Elvisrec=>W=>{e=>$e}
    
    $e = G&s,reeltool=>{s=>"Digly",us=>{p=>[['OthierElves']]}};
    n Elvisrec=>W=>{e=>$e}
    
    n Elvisrec=>3=>{W=>''}
Elvisrec: |
    if (2c&reeltool) {
        Js&ein.t.reeltool = 'reeltooled';
    }
    S
    if (my $e = (!2c&droppy || !J.bowls++) && e&C) {
        if (e.t eq 'twice') {
            Js&theword = e.c.s;
            J.seawire += 2;
        }
        1 && saybl "A minor ".ki $e;
    }
    
    J.seawire && J.seawire-- &&
        n seewooooorld=>-seawire=>
    
    n oa=>1=>33
    n ha =>2=> Js&theword||"unknown"
    n have =>3=>join", ", @{Js&bunch||[]}
    #Js&ein.t.tools = 'fixolid';
ElvisBystand: |
    1s&ein.t.reeltool = 'reeltooled';
reeltooled: |
    my $bu = Js&bunch ||= [];
    push @$bu, e.c.s;
    sayyl "Handled ".ki $e;
    T.pos = 1;
pi/seawire: |
    n snuff=>3=>"Wuff";
    my $i = ++J.bowls;
    for (split '', $s||C.t) {
        n $_=>'0.'.sprintf('%04d',$i++)=>$_
    }
Elvising: | # new way
    n ElVerse
    n ElBridge
    n ElChorus
    
ElVerse: | # hyperactive With
    u i
    
    # looking for C.c.e.?.? in a pin
    # could see/ip what they are looking for too
    # and give A&E clues for what the thing can do
    # to take back to the client
    e:
        my $e = c&e || sayre("Noce: ".ki$C) && return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = G&pang,$s;
        exists $e.>$nk || return ();
        my $n = $e.>$nk;
        exists $n.>$gk || return ();
        my $g = $n.>$gk;
        $list ? @$g : $g
    
    # looking for C.c.e.c.us.?_? in a pin
    # explicit nk/gk sep with _
    # clot of universalish nonhouse
    # for our trusted their message
    # an e&us at E 1 is a security bang
    # us should float across as e sces
    us:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        $e = e.c.us || return ();
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = split'_',$s;
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # describe A net
    sn:
        my $la;
        my $s;
        for (map { $A.>$_ } y=>1..5) {
            my ($cvb) = _.cv =~ /^0\.(\d+)$/ if $_ eq $A;
            my $sep = '.' unless !$s;
            $sep = '@' if $la eq $A;
            if ($la eq A.2) {
                # can go funny directions
                if (la.3 ne A.3) {
                    # J inherit 12345 before its set right
                    $sep = "(".($la eq la.3 ? "" : "la.3.t)");
                }
            }
            $s .= $sep."_.t$cvb";
            $la = $_;
        }
        $s
    # describe A net and e
    es:
        my $cv = A.mo.cv;
        $cv =~ s/^0\.//;
        my $e = G&e,\'C';
        G&sn .": ".ki $e;
    
    # means vector is about to do new ground
    # solves mind - which should row the of=S somewhere
    # also tugA,mo so E can resolve and tell S/mo to sleep pin if T.pos=0;
    # spaces out ground over time
    # or headers from bodies of work, making sleep if same
    # want to substrata bits of the ground,
    # make pages of osc for groups of time
    vent:
        my $E = A.mo.c.E;
        my ($cvb) = E.cv =~ /^0\.(\d+)$/;
        $s = "Elos $cvb $s\n  at ".G&es;
        push @{G.ohno||=[]},$s;
        sayre $s;
        T.Z.8 = $A;
    S:
        1&&saygr "Hyper C.t ".G&sn;
        G&A,n=>2,A.1,[];
    # marks a point for ghost chopchoping
    T:
        1&&saygr "T C.t".G&sn;
    # etc
ElBridge: | # mo joins E
    u c
    n \'of:mo'
    # how the web works
    # event finds a way into remote's mind
    
    # heaven's above me on a street called love
    # J must make known elvising to use .e hooks to answer calls
    
    
    # three ways in to E:
    # - 36: before/without pin (J has itself)
    # - 63211: within pin at time2 (J becomes)
    #      allowing J completion with th(e)m in one
    # - 67: after pin (J becomes)
    #       T.oke to force J redoing
    #     T.pos = 0 to waylay J redoing
    
    # ^ points to tug E
    # 
    
    # handlers include stuff in of=E
    #  - pin could make handler subs
    #  - pin could always happen, chews e itself
    #      probe if nothing uses eg e&_z
    
    
ElChorus: | # E joins your language
    u a
    n \'of:E'
    # tries to route to handlers/pin
    # changing e lingo will disturb ElvisWorlds 1: ofts made
    
    # sympathetic postbotany
    # do the pin/vent unknownness lest J.sc.ein handlers
    
    # mo tugs, wait for mind
    e 1:
        local A.V = 2;
        my $mo = A.mo;
        A&s = $C = $s->[0];
        my $e = A&oure = c&e || die "E no e: ".wdump 3, A.c.N;
        # routes do new C.c.e = C this e came from
        # reel in the tube of routes before the request
        my @hz;
        while ($e) {
            push @hz, $e;
            $e = e.c.e || last;
        }
        e.c.hz = \@hz if @hz > 1;
        if (!@hz) {
            if (!e.c.us && e.c.s =~ /^\{/) {
                # network line comes in on e as listen event
                # should onward aft hz an e as meaning/request
                # making the meaning beyond the book
                # and the readers in front of it
                my $us = eval{djson e.c.s};
                die "elvis line decode error: $@\n\n cs: ".slim 300, e.c.s if $@;
                # stylehut says {event:{...}}
                if (keys %$us == 1 && us.event) {
                    $us = us.event;
                }
                if (us.p) {
                    # parse string/not to [[t,cv]...]
                }
                
            }
        }
        A&e = $e;
        
        G&block,$_ && return for sub {
            !(1s&ein || 1s&seemstoe || A&pines)
        };
    
    e 2:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        if (!$in) { # ein & seemstoe may be, pins if 
            if (A&pines) {
                # just did pin that e& - finished
                sayyl "Pines";
                return T.Z.8 = $A
            }
            elsif (1s&seemstoe) {
                # may want hC etc in the pin, if us.p...
                # e should be before S, or it keeps going
                # so e is self in the equation that uses it
                # and handles it, since it hands it...
                die "Got toking E unknown too late: ".G&es if A.mo.cv > 0.5;
                sayyl "Must pine";
                A&wantpine = 1;
                A.mo.c.want.elvis = 6;
                return T.Z.8 = $A;
            }
            else {
                die "Got in to E unknown quick: ".G&es if A.mo.cv < 0.5;
                # doesn't need to know anything,
                # gets route, vent if lost
                sayyl "Gets lost?";
            }
        }
        
        # tractorbeam makes deeper look even if routable
        unless (in.tractor && Ec&trJ ne A.1
            # or not routable
            || !$us
            # or is routed to us
            || us.ids && do {
                # not anymore, but could warp them up
                # the J finds its easiest way in
                # for now the chain must be linked
                us.ids->[us.idi - 1] eq 1s&id
            }
            || us.p && do {
                # for now the chain must be fully linked also
                my $tcv = us.p->[Ec&us.p_i - 1];
                $tcv && $tcv->[0] eq J.t
            }) {
            return T.Z.6 = $A;
        }
    #c e3 enter linguistically
    e 3:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein;
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        if (in.tractor) {
            ec&trJ eq A.1 && return G&vent,'Doublysendo';
            ec&trJ = A.1;
        }
        
        my @being = $e;
        # can multiplex lines, must handle simply here or be lost
        while (@being) {
            $e = shift @being;
            # pass to E 7 if match not saying resolve E 4 (tree from A.3)
            T.com = 1;
            # make e& and us& pick into A&e if A&e && A.t eq 'E'
            if (in.o && A.1 ne A.2) { # from other? may talk to self
                Rw in.o;
            }
            elsif (in.li) {
                Rw in.li;
            }
            # avoid trying to hard for us.p
            
            # handle e that is pi, kind of a grammar/form it wants
            elsif (my $pin = in.f && in.f.>e.sc.pi ) {
                ref $pin && die "More pinfotic";
                Rw $pin;
            }
            # and other c/sc grabbing interest where e.t = its identity
            # before e.t is a thing we want:
            elsif (my $pin = in.t && in.t.>e.t ) {
                if (!ref $pin) {
                    Rw $pin;
                }
                else {
                    die "e t complexi ".ki $pin if !pin.s || pin.s ne 'M' || keys %$pin != 1;
                    # s=M used to open envelopes of e etc without leaving here
                    my $M = djson e.c.s;
                    push @being, @$M;
                    sayre "Multied ".@$M." For ".G&es;
                }
            }
            else {
                T.com = '';
            }
            # and then
            if (T.com eq '4') {
                # handler says keep going into E 4
            }
            elsif (T.com eq '6') {
                # handler says route
                T.Z.6 = $A;
            }
            elsif (T.com) {
                # handled
                T.Z.7 = $A;
            }
            else {
                # unhandled
                if (in.tractor) {
                    if (in.demand) {
                        G&vent,'Tractiondemand';
                    }
                    else {
                        # can try E4/5, probably route for 6
                    }
                }
            }
        }
        sayre "Done";
    
    #c e4 treeify hJ/hC
    # bo or handler will use the remotest does
    e 4:
        local A.V = 2;
        my $e = A&e;
        my $us = e.c.us;
        my $in = 1s&ein;
        # detect way in after this route from the tree of J we have
        my $J = A.1;
        return G&vent,'NoE6point' unless $us && us.p && ref us.p eq 'ARRAY';
        
        my $c = Js&top || # needs to reblock until after osc
            return G&vent,"e4Notop:J.t";
        my $p = us.p || return G&vent,"NoE4point";
        my @p = @$p[ us.p_i .. (@$p-1) ];
        my $i = 0;
        my @hC;
        for (@p) {
            my ($t,$cv) = @$_;
            if ($i == 0 && $t eq C.t) {
                1&&saygr "hop 1 is C.t";
            }
            else {
                $t || die "No way in";
                my $tv = c.y.tv || die "No tv on ".ki$c;
                my $vs = $tv.>$t;
                if (!defined $cv) {
                    ($cv,my@mi) = keys %$vs;
                    @mi && die "Ambiguous way in"; # could keep going
                }
                $c = $vs.>$cv;
            }
            if (!$c) {
                my $rea = "E4pointlost: at $i ($t $cv): ".wdump 3,\@p;
                return G&vent,$rea;
            }
            push @hC, $c;
        }
        e.c.hJ = [grep{defined}map{_.sc.J}@hC];
        e.c.hC = \@hC;
        
    #c e5 could route into pi?
    e 55:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein;
        # tug indy uov
        T.com = 1;
        if (in.bo) {
            Rw in.bo;
        }
        else {
            T.com = '';
        }
        if (T.com eq '6') {
            # handler says do route
            # e is on a many pointed mission
            # us.p changes/grows around corners
        }
        elsif (T.com eq '1') {
            # handled
            T.Z.7 = $A;
        }
        else {
            # unhandled
            G&vent,"E55nosolution";
        }
        
        
        #
    
    #c e6 route W, beyond here - could have done stuff too
    # may like to build onward meaing if so
    e 6:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        return G&vent,'NoE6point' unless $us && us.p && ref us.p eq 'ARRAY';
        
        my $point = us.p->[us.p_i||=0];
        $point || return G&vent,'Nomorepoint';
        my ($t,$cv) = @$point;
        
        my $vs = 4s&Jtv.>$t;
        $cv ||= 0.1;
        my $oJ = $vs.>$cv;
        
        if ($oJ) {
            us.p_i++;
            # readers move in in front of the meaning
            sayyl "Routing: oJ.t <-- C.t";
            n oJ.t=>W=>{e=>$C}
            T.pos = 0;
        }
        else {
            G&vent,"SpaceGoing:$t";
            # could make it up for it wants the name
            # makes networked light injector
        }
    
    #c e7 completion desires to J now or in a second
    e 7:
        local A.V = 2;
        my $mo = A.mo || die "Nomo"; # mo
        if (T.oke) {
            # do pin now
            if (mo.cv < 0.5) {
                # mo for it is still early
                mo.c.want.elvis = 6;
                # doesnt take T.oke, may Sleep
                # e floatilla should TGW without Toke
                sayyl "Want elvis";
            }
            elsif (mo.cv < 0.6) {
                # doing pin, tugged while S, tell it not to sleep
                mo.c.T.oke = 1;
                sayyl "Want toke";
            }
            else {
                sayyl "toolate Elvuis";
                C.c.W || die "aft 6 Toke non W: ".ki$C;
                #Rw waited $J;
            }
            sayre "Toking mo.cv into ".G&es;
            return;
        }
        T.pos = 1 if !defined T.pos;
        if (T.pos || !defined T.pos) {
            # do J in a second
            sayyl "Do A.1.t in a second";
            #Rw waito $J $C;
        }
    
e: | # for elvis handlers
    n alact
    e 4223: %acgt:s,act,of:mo
        # make their v for .c.e
        # and various expand to shape pieces of server/etc protocols
        s&of ||= 'E';
    
Routable: | # look for routes in J (vie li, tractor?)
    # using pi to track remote pi
    # tables of stuff to match, could double the cv for the solution
    # route C could have sc.opel, a new path
    # have to T.com = 6 to skip 4/5ing the p here, which wont work
    # 
Doable: | # look for dos in hC (vie bo)
    my @doers = grep {_.sc.dos} @{e.c.hC};
    @doers || return G&vent,"Nodoing";
    @doers == 1 || G&vent,"Manydoing";
    my ($c) = @doers;
    1&&sayyl "dos e.t for c.sc.dos: ".ki$c;
    Rw c.sc.dos;
    
ElvisHoists: | # J uphoist any {{{
    my $t = Rw Telvis;
    # J.sc.X fishtail connection, index clues needed, or eg co
    # see pud re T
    

