
Elvising: | # new way
    n ElVerse
    n ElBridge
    n ElChorus
    
    n PaintedStripes
    n Hosthing
    #n Zpace
    # not very stuck in alacgt etc u, only compilable on Os
    #n Zpace
    
    # heaven's above me on a street called love
    # J must make known elvising to use .e hooks to answer calls
    
    
    # three ways in to E:
    # - 36: before/without pin (J has itself)
    # - 63211: within pin at time2 (J becomes)
    #      allowing J completion with th(e)m in one
    # - 67: after pin (J becomes)
    #       T.oke to force J redoing
    #     T.pos = 0 to waylay J redoing
    
    # ^ points to tug E
    # 
    
    # handlers include stuff in of=E
    #  - pin could make handler subs
    #  - pin could always happen, chews e itself
    #      probe if nothing uses eg e&_z
    
    
    
    
    
    # localised implica expanded into universal (still localised)
    # eg make everything acgt:s
    
    #  # decompression wants to live in of=D and be for nonJ
    # and be the thing knowing/isolating a ghost
    # making A.D = receipt for the pin/scheme/O cause/elvis handling
    # or the convo/dialect state applied within
    # falling A bounds like .mo:
    
    # U al4noJ 3 spawns our encoding on the J6ing.mo:
    #     A.D = {self,J=A.D}
    #         marking D above ours (unless already) as the norm for doing J
    # then mo dome 2:
    #    A.D = A.D.J if c&J && A.D && A.D.J;
    #       peels off encodings/holes to A.mo.up.mo's intention
    #         for this A.mo, so it can speak nonJ n normally
    #   runs D
    #        with A.D for direction/self
    # and U al4noJ 7:
    #    finishes our encoding
    
    # D may make good interface to pages to reset (when J 6)
    # or unrestart (when S sleeps)
    # or partition (with names) and despatch to whatever process
    
    # so encodings should all of=D
    # a W reverses line protocols from remote stream
    # via m into golden box acum space
    # fills <5 at lum top, 8-9 lum/3, 7-8 lum/7, etc towards 555555555555
    # into streams of atoms for your A.3 to officially reposition
    # there's a ghost bridge
    
    # of=U = runs when mind made up/down
    # of=M = for the $M produced by 6, incs depth of atoms
    # of=S = check for escaping gas (sleeps minor changes)
    
ElVerse: | # hyperactive With
    u i
    # see also With/elph for the ephemeral elvis n
    
    # e&way -> c&e.sc.way
    # to get bits of the request
    # endmost if A&E
    # could see/ip what they are looking for too
    # and give A&E clues for what the thing can do
    # to take back to the client
    e:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        return e.t if $s eq 't';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = G&pang,$s,'c';
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            return $e if $gk eq 'C';
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # looking for C.c.e.c.us.?_? in a pin
    # explicit nk/gk sep with _
    # clot of universalish nonhouse
    # for our trusted their message
    # an e&us at E 1 is a security bang
    # us should float across as e sces
    us:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        $e = e.c.us || return ();
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = split'_',$s;
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # describe A net
    sn:
        my @net = ('y',1,2,3,4,5);
        shift @net if $s eq '5';
        my ($s,$h,$la);
        for my $i (@net) {
            my $Y = $A->{$i} || die "Npo $i on ".ki $A;
            ref $Y eq 'HASH' || die "Got $i from A.t: ".ki $Y;
            my ($cvb) = Y.cv =~ /^0\.(\d+)$/ if $Y eq $A;
            my $sep = '.' if $s;
            $sep = '@' if $la eq $A;
            my $th = Y.t;
            if (my $ii = $h.>$Y ) {
                $th = ','.$ii;
                $sep = '';
            }
            $h.>$Y ||= $i;
            if ($la eq A.2) {
                # can go funny directions
                if ($la ne A.5 && $la ne A.4 && la.3 ne A.3) {
                    # J inherit 12345 before its set right
                    $sep = "(".($la eq la.3 ? "" : "la.3.t)");
                }
            }
            $s .= "$sep$th$cvb";
            $la = $Y;
        }
        $s
    # describe A net and e
    es:
        my $cv = A.mo.cv;
        $cv =~ s/^0\.//;
        my $e = G&e,\'C';
        G&sn .":\n    ".ki($e).(e.c.hC && ki(e.c.hC));
    
    # means vector is about to do new ground
    # solves mind - which should row the of=S somewhere
    # also tugA,mo so E can resolve and tell S/mo to sleep pin if T.pos=0;
    # spaces out ground over time
    # or headers from bodies of work, making sleep if same
    # want to substrata bits of the ground,
    # make pages of osc for groups of time
    vent:
        my $E = A.mo.c.E;
        my ($cvb) = E.cv =~ /^0\.(\d+)$/;
        $s = "Elos $cvb $s\n  at ".G&es;
        push @{G.ohno||=[]},$s;
        push @{E.c.vent||=[]},$s;
        !4c&mutelos && sayre $s;
        T.Z.8 = $A;
ElBridge: | # hoisting, desire
    u i
    # background processes to being a network of such things
    # non-thing in 
    
    # make A that is 4
    mk4:
        my $J = A.1;
        $A.>$_ = $J for 1..4;
        $J.>$_ = $J for 1..4;
    # connect a resource to the vortexey hoist
    # for credits that pool up to the top level
    # want to be strung into roots, vaguing out
    # to allow G triggers
    has: %acgt:k v
        $v = 1 if !defined $v;
        T.has.>$k = $v
    # 3 xo reoccurs k v, adds undef for goners
    # wants more index, where changes within rehash up to the depth
    newxo: %acgt:xo x
        my $so = $xo;
        $xo = {};
        my $oxo = xs&xo;
        for my $k (keys %$so) {
            my $v = $so.>$k;
            my $ov = $oxo.>$k;
            $xo.>$k = $v eq $ov ? $ov : $v;
        }
        for my $k (keys %$oxo) {
            exists $xo.>$k && next;
            $xo.>$k = undef;
        }
        xs&xo = $xo;
    # sum many xo
    # may want to know top/our xo
    multiv:
        my $inf = a&infxo;
        my $sa = sub {
            push @$inf, shift;
            sayyl "Inf A.1.t: ".$inf->[-1]
        };
        if ($s eq 'way') {
            my $td = {};
            map {
                while (my ($t,$ds) = each %$_) {
                    while (my ($d,$q) = each %$ds) {
                        $td.>$t.>$d += $q
                    }
                }
            } map{_.c.s}@Me;
            $sa->(" $s from ".join(',',map{_.t}@Me).": ".ki $td);
            $td
        }
        else {
            my $total = sum map {_.c.s} @Me;
            $sa->(" $s totals $total from: ".ki \@Me);
            $total;
        }
    
    # 
    #c see their xo in O
    u a
    # dials: these things want to say of in t but set t to xo
    # so they are labelled as other here and in We embryos
    
    xo 6: %of:O
        c&Jo || return;
        my $x = a&x;
        my $J = a&J;
        my $s = Js&s;
        ss&xo || xs&xo || return;
        my $Y = A.sA || die "No us osc O xo: ".ki $C;
        my $xo = Ys&ox.>C.y.cv.>C.t = G&newxo,ss&xo,$x;
        
        
    # unify harvested xo and hoisted ox (y t xo) as xo
    xo 78: %of:s
        my $top = s&top || return;
        my $te = A.mo.c.T;
        my $xo = te.has; # our xo
        my $x = top.y.x || c&imparted && return
            || die "No x on A.1.t: ".ki s&top;
        my $oxo = xs&xo; # our past xo
        
        $xo = A&xo if A&xo; # thawing
        my $we = G&newxo,$xo,$x if $xo || $oxo;
        
        my $ox = a&ox; # many y t xo (inc undef goners)
        my $xox = s&xox; # many k y t v past
        
        $xo || $ox || $oxo || $xox || return delete s&xo;
        
        if (!$ox && !$xox) { # just ourself
            s&xo = $xo;
            return;
        }
        
        if ($we) {
            my $cv = 0.9;
            $ox.>$cv.>A.1.t = $xo;
        }
        # ox is y t to xo
        # unified back to single xo with others
        my $kyt = {};
        G&chew,$ox,\'cv,t,k',$_ for sub {
            my ($v,$cv,$t,$k) = @_;
            my $ov = G&pint,$xox,[$k,$cv,$t];
            if ($v ne $ov) {
                $kyt.>$k++;
            }
            if (!defined $v) {
                delete $xox.>$k.>$cv.>$t;
                delete $xox.>$k.>$cv if !keys%{$xox.>$k.>$cv };
                delete $xox.>$k if !keys%{$xox.>$k };
            }
            else {
                $xox.>$k.>$cv.>$t = $v;
            }
        };
        
        # xo is our k v
        a&infxo = [];
        $xo = s&xo;
        for my $k (sort keys %$kyt) {
            my $yt = $xox.>$k || {};
            my @M;
            G&chew,$yt,\'cv,t',$_ for sub {
                my ($v,$cv,$t) = @_;
                push @M, {t=>$t,y=>{cv=>$cv},c=>{s=>$v}};
            };
            if (!@M) {
                delete $xo.>$k;
            }
            else {
                $xo.>$k = G&multiv,$k,@M;
            }
        }
        s&xox = $xox;
        s&xo = $xo;
        delete s&xo if !keys %$xo;
    
    #c J44 desire
    u s
    n \'of:mo'
        
    # 
    J 44:
        my $xo = Js&xo || return;
        my $ow = xo.way || return;
        local A.V = 2;
        for my $way (keys %$ow) {
            my $w = G&wup,$way || next;
            my $od = {%{ $ow.>$way }};
            delete $od.>w.sc.dige;
            if (keys %$od) {
                A&want.pin = 6;
                A&want.pins.>$way = 6;
            }
            else {
                # stays
            }
        }
        
    
ElChorus: | # mo->E joins your request to a J
    # tries to route to handlers instead of pin
    # vents unknowns
    # elvectricity flowing through the space
    u c
    n \'of:mo'
    e 36:
        A.1 eq A.2 && sayre "Elvising same: ".G&es;
        A&E && die "Elvising already: A&E.c.s.c.e.t vs e.t";
        A&E = G&tugA,E=>1,$C;
    
    # elvis should have resolved
    # or been accessed e&la in pin (see Ce e)
    e 72:
        my $E = A&E;
        return if E.cv >= 0.6 && !Ec&wantpine && !Ec&pines;
        if (Ec&pines) {
            1s&seemstoe = 1;
        }
        else {
            G&vent,"Notcompleted";
        }
    
    u a
    n \'of:E'
    # mo tugs, wait for mind
    e 1:
        local A.V = 2;
        my $mo = A.mo;
        A&s = $C = $s->[0];
        my $e = A&oure = c&e || die "E no e: ".wdump 3, A.c.N;
        # routes do new C.c.e = C this e came from
        # reel in the tube of routes before the request
        my @hz;
        while ($e) {
            push @hz, $e;
            $e = e.c.e || last;
        }
        if (@hz > 1) {
            e.c.hz = \@hz;
        }
        else {
            if (!e.c.us && e.c.s =~ /^\{/) {
                # network line comes in on e as listen event
                # should onward aft hz an e as meaning/request
                # making the meaning beyond the book
                # and the readers in front of it
                my $us = eval{djson e.c.s};
                die "elvis line decode error: $@\n\n cs: ".slim 300, e.c.s if $@;
                # stylehut says {event:{...}}
                if (keys %$us == 1 && us.event) {
                    $us = us.event;
                }
                if (us.p) {
                    # parse string/not to [[t,cv]...]
                }
                
            }
            if (e.c.p) {
                e.c.us.p = [map{[split '-', $_]}@{delete e.c.p}];
            }
        }
        
        # opens
        A&E = $A;
        A&e = $e;
        
        G&block,$_ && return for sub {
            !(1s&ein || 1s&seemstoe || A&pines || 1s&tv)
        };
    #c e2 arrived to some mind: enter or route or wait for it to begin
    e 2:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        if (!$in) { # ein & seemstoe may be, pins if 
            if (A&pines) {
                # just did pin that e& - finished
                return T.Z.8 = $A
            }
            elsif (1s&seemstoe) {
                # may want hC etc in the pin, if us.p...
                # e should be before S, or it keeps going
                # so e is self in the equation that uses it
                # and handles it, since it hands it...
                die "Got toking E unknown too late: ".G&es if A.mo.cv > 0.5;
                A&wantpine = 1;
                A.mo.c.want.elvis = 6;
                return T.Z.6 = $A;
            }
            else {
                # doesn't need to know anything,
                # gets route, vent if lost
                return T.Z.6 = $A;
            }
        }
        
        # tractorbeam makes deeper look even if routable
        # so we can log e
        unless (in.tractor && Ec&trJ && Ec&trJ->[-1] ne A.1
            # or not routable
            || !$us
            # or is routed to us
            || us.ids && do {
                # not anymore, but could warp them up
                # the J finds its easiest way in
                # for now the chain must be linked
                us.ids->[us.idi - 1] eq 1s&id
            }
            || us.p && do {
                # for now the chain must be fully linked also
                my $tcv = us.p->[Ec&us.p_i - 1];
                $tcv && $tcv->[0] eq A.1.t
            }) {
            return T.Z.6 = $A;
        }
    #c e3 enter lingis, try solve, pin if cant
    e 3:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein || return saybl "No Ein for e.t";
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        if (in.tractor) {
            ec&trJ && ec&trJ->[-1] eq A.1 && return G&vent,'Doublysendo';
            push @{ec&trJ||=[]}, A.1;
        }
        
        my @being = $e;
        # can multiplex lines, must handle simply here or be lost
        while (@being) {
            $e = shift @being;
            T.com = 1;
            if (in.o && A.1 ne A.2) { # from other? may talk to self
                Rw in.o;
            }
            elsif (in.li) {
                Rw in.li;
            }
            #  pi (or can translate object through)
            elsif (my $pin = in.pi && in.pi.>e.sc.pi ) {
                ref $pin && die "More pinfotic";
                Rw $pin;
            }
            # c spaced things
            elsif (my $pin = in.t && in.t.>e.t ) {
                if (!ref $pin) {
                    Rw $pin;
                }
                else {
                    for my $k (sort keys %$pin) {
                        my $v = $pin.>$k;
                        if ($k eq 's' && $v eq 'M') {
                            # used to open envelopes of e etc without leaving here
                            my $M = djson e.c.s;
                            push @being, @$M;
                            sayre "Multied ".@$M." For ".G&es;
                        }
                        else {
                            Rw $k + $v $us;
                        }
                    }
                }
            }
            # 
            else {
                T.com = '';
            }
            # and then
            if (T.com eq '4') {
                # handler says keep going into E 4
            }
            elsif (T.com eq '6') {
                # handler says route
                # leave J be? hang for a response?
                T.Z.6 = $A;
            }
            elsif (T.com) { # handled
                # break from tuggance and transfer desires to A.mo
                T.Z.7 = $A;
                A&ov = 0.9;
                T.seek = 1;
            }
            else {
                # unhandled
                in.tractor && in.demand && return G&vent,'Tractiondemand';
                # can try E 4, probably route for 6
                if (A&pines) {
                    T.pos = 0; # doneA
                    sayyl "3 doneA pin";
                    return T.Z.7 = $A;
                }
                elsif (1s&seemstoe && !($us && us.p)) {
                    A&wantpine = 1;
                    A.mo.c.want.elvis = 6;
                    sayre "3 want pin";
                    return T.Z.7 = $A;
                }
            }
        }
        return if T.Z;
    
    #c e37 treeify hJ/hC
    # bo or handler will use the remotest does
    e 37:
        local A.V = 2;
        my $e = A&e;
        my $us = e.c.us;
        my $in = 1s&ein;
        # detect way in after this route from the tree of J we have
        my $J = A.1;
        my $c = Js&top;
        $c || return T.Z.6 = $A; #A&pines || A&wantpine ||
            #G&vent,"e4Notop:J.t:J.c.o"; # try again later
        my $p = $us && us.p || return
            A&pines || G&vent,"NoE4point";
        
        my @p = @$p[ us.p_i .. (@$p-1) ];
        my $i = 0;
        for (@p) {
            my ($t,$cv) = @$_;
            my $cc = $c;
            my $v;
            if ($i == 0 && $t eq C.t) {
                1&&saygr "hop 1 is C.t";
            }
            else {
                $t || die "No way in";
                my $v = c.y.tv || c.sc.J && c.sc.J.sc.tv
                    || die "No tv on ".ki$c;
                $v = $v.>$t;
                if (!defined $cv) {
                    ($cv,my@mi) = sort keys %$v;
                    @mi && return
                        G&vent,"Amb:$t:".join',',$cv,@mi; # could keep going
                }
                $c = $v.>$cv;
            }
            if (!$c) {
                my @p = map { "@$_" } @p;
                splice @p, $i,0,'lost:';
                my $rea = "E4pointlost: on cc.t cc.y.cv: ".join' ',@p;
                $rea .= '  among:'.slim(44,join',',sort keys %{cc.y.tw});
                return G&vent,$rea;
            }
            push @{e.c.hC ||= []}, $c;
            push @{e.c.hJ ||= []}, c.sc.J if c.sc.J;
            $i++;
        }
        
    #c e5 route into J - tree climbing
    e 4:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein;
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        # tug indy uov
        T.com = 1;
        if (in.bo) {
            Rw in.bo;
        }
        else {
            T.com = '';
        }
        if (T.com eq '6') {
            # handler says do route
            # e is on a many pointed mission
            # us.p changes/grows around corners
        }
        elsif (A&vent) {
            return;
        }
        elsif (T.com eq '1') { # handled
            # break from tuggance and transfer desires to A.mo
            T.Z.7 = $A;
            A&ov = 0.9;
            T.seek = 1;
        }
        else {
            # unhandled
            G&vent,"E55nosolution";
        }
        
        
        #
    
    #c e6 route W, beyond here - could have done stuff too
    # may like to build onward meaing if so
    e 63:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        unless ($us && us.p && ref us.p eq 'ARRAY') {
            #G&vent,'NoE6point' unless A&pines;
               return;
        }
        
        my $point = us.p->[us.p_i||=0];
        $point || return G&vent,'Nomorepoint';
        my ($t,$cv) = @$point;
        
        my $vs = 4s&Jtv.>$t;
        $cv ||= 0.1;
        my $oJ = $vs.>$cv;
        
        if ($oJ) {
            us.p_i++;
            # readers move in in front of the meaning
            _.c.mo.c.T.not = 1 for
            n oJ.t=>W=>{e=>$C}
            T.pos = 0;
        }
        else {
            G&vent,"SpaceGoing:$t";
            # could make it up for it wants the name
            # makes networked light injector
        }
    
    #c e7 completion desires to J now or in a second
    e 7:
        local A.V = 2;
        my $mo = A.mo || die "Nomo"; # mo
        my $te = mo.c.T;
        # inherit from mo positivity
        $T.>$_ = $te.>$_ for grep{ defined $te.>$_ } qw'oke pos';
        
        T.pos = 0 if !defined T.pos && A&wantpine;
        T.pos = 1 if !defined T.pos;
        
        if (T.oke || T.pos) {
            # do pin now to update picture with this change
            if (mo.cv < 0.5) {
                # mo for it is still early
                # todo because elvis
                mo.c.want.elvis = 6;
                # e floatilla should TGW without Toke
            }
            elsif (mo.cv < 0.6) {
                # doing pin, tugged complete in S
                mo.c.want.elvis = 6;
                # tell it not to Sleep
                mo.c.T.oke = 1; # extra
            }
            elsif (mo.cv < 0.7) {
                if (T.oke) {
                    # could do pin again then osc?
                    G&vent,"Tokelate";
                }
                else {
                    # could be impossible to render the change locally
                    # W is upstreaming for its true self
                }
                C.c.W || die "aft 6 Toke non W: ".ki$C;
                sayyl "Do A.1.t again before osc: mo.cv ".G&es;
                #Rw waited $J;
                #te.nose = 1; # or oscs twice?
                # A not meant to be wound back
            }
            else {
                if (T.oke) {
                    G&vent,"WAAAAYTokelate";
                }
                sayyl "Do A.1.t in a second: ".G&es
                #Rw waito $J $C;
            }
            return;
        }
    
Routable: | # look for routes in J (vie li, tractor?)
    # using pi to track remote pi
    # tables of stuff to match, could double the cv for the solution
    # route C could have sc.opel, a new path
    # have to T.com = 6 to skip 4/5ing the p here, which wont work
    # 
Doable: | # look for dos in hC (vie bo)
    my @doers = grep {_.sc.dos} @{e.c.hC};
    @doers || return G&vent,"Nodoing";
    @doers == 1 || G&vent,"Manydoing";
    my ($c) = @doers;
    1&&sayyl "dos e.t for c.sc.dos: ".ki$c;
    
    Rw c.sc.dos + $c;
    
sMJ: | # for Js&M map in
    my $M = Js&M ||= [];
    my $s = e&s;
    my $j = ss&J || die "snoJ" if ref $s eq 'HASH';
    $j ||= do {
        1 && saygr "On te A.1.t A.2.t ?";
        A.2;
    };
    $v->($s,$M,$J,$j,$e);
    
HasWay: | # pin upsurge
    G.hasway = sub {
        my ($A,$C,$G,$T,$v) = @_;
        my $te = A.mo && A.mo.c.T || return;# saybl "Nowhere to mo T has";
        # should multi the name from the first one
        my $w = v.y.argumented || die "Not argumented? ".ki$v;
        te.has.way.>w.t.>w.sc.dige ++;
    };
Hosthing: | # <-- Hosting
    u a
    # try wormhole/avoidance, wants Tractor to override regularly
    # force T.H
    #    1 nothing
    #    2 stores only
    #    3 everything (ofs of, of evals code(d))
    #    4 with wires (tw, iiyt) to resume osc from 76- (evals coded)
    #    5 ^ stores only
    #    8+ thaws only
    thawJ 34: %of:mo,t:y:A:mo:up:mo:c:T:H || y:A:mo:c:T:H
        c&e && return;
        
        keys %{C.c} == 2 && c&W eq c&J && c&W eq C.t || return;
        
        # 
        a&thawable = 1 unless $s < 3 || $s == 5;
        a&storable = 1 unless $s < 2 || $s > 7;
        
        a&storable && A.up.c.store++;
        a&stowexp = 1 if $s >= 4 && $s < 6;
        saybl "Thawable ($s) C.t: a&thawable    a&stowexp";
         
        a&thawable || return;
        my $V = A.1.t =~ /^[A-Z]/ && A.2.t ne 'u';
        my $d = G&thaws,$V || return;
        
        $V && saygr " for ".G&sn;
        
        # is upCc&parts from s
        # which may skip s to 76-
        # or at least not do the pin
        c&parts = $d;
        T.Z.7 = $A;
        delete a&storable;
        
    stawJ 78: %of:n,t:y:A:c:store
        for my $m (@{A&mos||[]}) {
            ms&storable || next;
            my $c = mc&s;
            my $J = cs&J;
            my $s = Js&s;
            $A = $m;
            $C = m.c.s;
            # hmm ^
            G&stores,$s;
            #G.ouJ = $s;
        }
        
    u i
    thaws:
        local C.c.V = 1;
        n Stro=>[get=>$C]
        delete s&top
    
    # make flat list of C that should reosc to what it was
    stores:
        my $t = s.sc.top || die "Store no top: ".ki $s;
        my $m; # for ns&meta - indexes to take
        my $n; # the first - top
        if (a&stowexp) {
            # expensiver keeping ii/tv/etc in a bundle
            # could fork, ind without hup to shave y
            # yaml it all
            return Rw StowExp $C:s;
        }
        my @all = G&ind,$t;
        my ($u) = @all;
        for (@all) {
            delete _c&ind;
            _s&coded = 1 if delete _c&code;
            _.y = {cv=>_.y.cv};
            my $in = delete(_c&inside) || [];
            my $z = delete _s&z;
            delete _s&J;
            G&oleak,$_,5 && die "Leaks: @$in: ".ki $_;
            _s&z = $z;
        }
        # put in meta, know not imparted unless m.unreal
        u.sc.xo = s.sc.xo if s.sc.xo;
        n Stro=>[put=>$u]
    
StowExp: | # as C = s, store itself, see Parts/unreal
    local A.V = 2;
    
    if (my $pid = fork()) {
        waitpid($pid,0);
        die "child failed with $?" if $?;
        return;
    }
    
    my ($ok,$dr);
    ok.y.>$_ = 1 for qw'up in prev next';
    ok.y.>$_ = 2 for qw'tv tw';
    dr.y.>$_ = 1 for qw'D x r s';
    dr.c.code = 3;
    ok.sc.ip = 2;
    
    my $ha; # have seen
    my $pa; # paths to seen
    my $se; # see from
    my @or;
    my $ub = &Cd{
        $ha.>$C = $C;
        my $p = join "/", @{d.path};
        $pa.>$p = $C;
        push @or, 
        G&chew,$C,'nk,gk',$_ for &v,nk,gk{
            ref $v || return;
            $se.>$nk.>$gk.>$v.>$C = $C;
        };
        return; # means no c.ind/inside labegy
    };
    my @all = G&ind,s&top,$ub,{nohup=>1};
    
    my $pass = 1;
    G&chew,$se,'nk,gk,v',$_ for &vv,nk,gk,v{
        return if $nk eq 'sc' && $gk =~ /ex$/;
        my $M = [values %$vv];
        if (my $k = $ok.>$nk.>$gk ) {
            my $c = $ha.>$v;
            $v = "C c.t c.y.cv" if $c;
            unless ($c || $k == 2) {
                sayre "Unhad $nk $gk $v from ".ki $M;
                $pass--;
            }
        }
        elsif (my $k = $dr.>$nk.>$gk ) {
            #saybl "Droppy $nk $gk $v from ".ki $M;
            delete $_.>$nk.>$gk for @$M;
            if ($k == 3) {
                my $gkd = $gk.'d';
                _.sc.>$gkd = 1 for @$M;
            }
        }
        else {
            my $c = $ha.>$v;
            my $had = " (had: c.t c.y.cv)" if $c;
            sayre "Unknown $nk $gk $v$had from ".ki $M;
            delete $_.>$nk.>$gk for @$M;
            $pass--;
        }
    };
    
    G&chew,s&iiyt,'cv,t',$_ for &l,cv,t{
        $ha.>$l && return;
        $pass--;
        sayre "Missing iiyt $cv $t: ".ki$l;
        saygr "Was it ".ki $_ for 
            grep { _.t eq l.t && _.y.cv eq _.y.cv } values %$ha;
    };
    die "Shave missed spots" if $pass != 1;
    
    my $t = s&top;
    ts&meta && die "Already had topscmeta: ".ki($t)."\n  ".ki(ts&meta);
    my $m = ts&meta = {}; # takes over as impart, sets tv,top,etc in self
    m.sc.iiyt = s&iiyt;
    m.unreal.sc.iiyt++; # iiyt maintained xarefully, drop before J for real
    m.sc.top = $t;
    m.c.>$_ = C.c.>$_ for qw'imp wil mat';
    m.sc.xo = s&xo if s&xo;
    m.paths = $pa;
    
    # do in parallel, child kills parent
    my $dl = 99;
    if (G&oleak,$t,$dl ) {
        write_file('eak', wdump $dl, $t);
        die "t.t t.y.cv still leaks at depth=$dl, wrote file 'eak'";
    }
    
    G&elph,Stro=>[put=>$t];
    exit;
    
Parts: | # osc eats self
    local A.V = 2;
    my $m = delete ds&meta;
    
    m.sc.xo = delete ds&xo if ds&xo;
    for ('c','sc') {
        my ($s,$c) = ($C.>$_ , $m.>$_ );
        $c || next;
        G&hoh,$s,$c;
    }
    
    if (A.1.t eq 'Zpace' && !m.unreal) {
        sayyl "Space light: ".wdump 3, $m;
    }
    return saygr "Parts lightly A.1.t" unless m.unreal;
    
    # make a parts top that o2parts can make look like a ground
    my $z = [];
    my $S = d.y.in;
    while ($S) {
        push @$z, $S;
        $S = S.y.next;
    }
    ds&z = $z;
    
    my $ub = &Cd{
        return unless delete s&coded;
        G&Code,"Parts";
        return; # means no c.ind/inside labegy
    };
    my @all = G&ind,$d,$ub,{nohup=>1};
    
    saybl "Parts 76 A.1.t  ". (1c&semiport && "SEMI PORT");
     # makes s Z to 76- un
    c&imparted = $m;
Imparted: | # osc continues after eating self
    local A.V = 2;
    my $J = A.1;
    sayre "Render last lv of A.1.t: c&o";

    my $t = m.sc.top || die "No metatop";
    ts&meta = $m;
    # our c&imparted already deleted
    c&parts = $t;
    delete s&top.y.tv;
    sayyl "reOscillate J.t   ".c&o ." But jo ".ki s&jo;
    # so the next lv action applies on top of the one frozen
    Jc&gripo = 1;
    # ^ wants to be a T thing wired into v instead of bounced off the J
    Jc&semiport = 1;
    G&A,s=>8=>$J;
    
    while (my ($nk,$v) = each %{m.unreal||die"m not unreal"}) {
        sayyl "Deleting C.t's $nk's: ".ki [sort keys %$v];
        delete $C.>$nk.>$_ for keys %$v
    }
    
    sayyl "Done: ".wdump 4, [c&o];
    delete c&parts;
    # and now returns into o2
Stro: | # storage aJent for Hosthing, just needs A.G
    T.nose = 2; # no osc but keep J (4s&Jtv)
    T.pos = 0; # always thinks its right
    my $f = 'w/St';
    my $c = e&s; # sets C.c.e.c.s.sc.top = got
    my @p = map { s/\W//g;$_ } A.4.t, c.t;
    my $p = join '/', $f, @p;
    my $f = "$p/head";
    if (e&t eq 'put') {
        `mkdir -p $p`;
        DumpFile($f,$c);
        C.c.V && sayyl "Store $f";
    }
    elsif (e&t eq 'get') {
        -f $f && -s $f || return;
        my $u = LoadFile($f);
        $u || return;
        cs&top = $u;
        C.c.V && sayyl "Get $f";
    }
    else { G&vent,"NHogo" }
ElvisMatters: |
    map {
        n fivi=>$_=>"fi"
    } map { $_ / 7 * $_ / 3 } 33..54;
    n hoov=>-tinput
    
ElPassTape: | # Jc&elvis sends e=s oscillations through Herers
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    
    if (c&Se == 1) {
        u Zpace
        u FeelTapey=>'',<<'','%of:w'
            u Zpace
            Jc&elvis = 'ElvisTape';
            Jc&elvis = 'ElvisTape:lineout:Dejo' if Js&wls;
            
            map {
                m feo=>''=>"Soe Js&wls $_",'%hs:349,bgh:843'
            } 1..(3 + Js&wls);
            
            map {
                my $zc = G&Ct,[cod=>1=>''=>'%cod,con:3,dige:485859'];
                zc.c.s = "JBowls-Js&wls";
                _s&z = [$zc];
            } @$M;
            
            Js&wls++;
            y.lum = 8 * Js&wls++ || return;
            y.at.lumwas = y.lum;
            y.imp++ if Js&wls == 6; # reset lv
        
        t.e =
        n FeelTapey
        t.cs->('sc lastK c s', "See");
        my $seeit = sub {
            my $W = t.ntos->(t.e,'J');
            t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s,time=>6,nopre=>1});
            sleep 1;
        };
        G.Wouter = sub { # send stuff from 4=Os (g/s)
            # to 4=Oth (g/c) which can web it out
            my ($te,$c) = @_;
            c.time = 6;
            sayyl "Wouter $te: ".ki $c;
            t.mkoJ->($te=>$c);
        };
        #$seeit->();
        t.e =
        n FeelTapey
        t.cs->('sc lastK c s', "See again");
        #$seeit->();
        t.e =
        n FeelTapey
        t.cs->('sc lastK c s', "See third, imp reset");
        
        t.e =
        n ElvisTape
        {
            local t.toc.largesse = 1;
            t.cs->('sc lv,olv', "Aggregate it all");
        } 
        t.cs->('sc top', "top sees only tops of pis");
        t.cs->('sc lastK c s', "shlop");
        
        t.e =
        n Dejo
        # this assertion misses duped many top K in the same z
        t.cs->('sc lv,olv', "Tape out");
        t.cs->('sc top', "Tape top");
        
        t.e =
        n Monitor
        t.toc.slim = 100;
        t.cs->('sc lv,olv', "Monitor out");
        t.cs->('sc top', "Monitor top");
    }
ElvisTape: | # to receive W production for run compara
    u Zpace
    # Tendon room, scuttle
    # wants to minglo unique G-s
    y.rev = 1000;
    Js&ein.t.s.sMJ = &sMJje{
        # TODO + A here or e&C will look at first pin A&E
        m j.t=>-TapeRack=>{s=>$s,%{e.sc||{}}}
    };
    S
    
    push @$M, @{Js&M||=[]};
    # have have the tw in another unity that can be included to W search
    # but not having .ii itself
pi/TapeRack: | # for s, points make ghosts, quotation maker
    S no
    # should be storyboard frames and realtime
    n instant =>1=> 4s&inst
    my $see = c&see ||= {};
    
    # seek shotlist from ET/test client
    see.top.p = [qw'sc top'] if !keys %$see;
    # and help wires to the problems
    
    # take some photo
    my @ks = sort keys %$see;
    for my $k (@ks) {
        my $q = $see.>$k;
        my $x = $s;
        my ($c,$sc);
        # seek angle of thing
        if (q.p) {
            my $o = {};
            $x = G&pint,$x,@{q.p},$o;
            if (exists o.fail) {
                sayre "C.t C.y.cv: Path @{o.have}   !o.fail    (@{o.mong})";
                sc.misspoint = "@{o.have} !o.fail (@{o.mong})";
            }
        }
        # expose
        if (defined $x) {
            my $o = G&A,o=>6=>$J=>$x,'wellbeing';
            c.s = join("\n", @{oc&rsl});
        }
        else {
            sc.isundef = 1 if !defined $x;
        }
        n $k=>3=>$c=>$sc
    }
    
    if (my $t = c&lineout) {
        # soul is the root of communicative mutations
        G&elph,$t=>[s=>$s];
    }
    
    y.at.o = sc&o;
    y.at.see = "@ks";
    
LineOut: | # K hoisting
    my $t = s.sc.top || die "Store no top: ".ki $s;
        if (a&stowexp) {
            # expensiver keeping ii/tv/etc in a bundle
            # could fork, ind without hup to shave y
            # yaml it all
        }
        my @all = G&ind,$t;
        my ($u) = @all;
        for (@all) {
            delete _c&ind;
            _s&coded = 1 if delete _c&code;
            _.y = {cv=>_.y.cv};
            my $in = delete(_c&inside) || [];
            my $z = delete _s&z;
            delete _s&J;
            G&oleak,$_,5 && die "Leaks: @$in: ".ki $_;
            _s&z = $z;
        }
Dejo: | # cyclical spreebuilding, bunch of oscillators to keep draining
    u Zpace
    u TapePlay
    # Tower uplink, wants to secure names
    # uses the s ref to dedupe now
    # (network store needs globey namespace)
    y.rev = 8;
    Js&zeat = 'Junup';
    Js&ze = 'Monitor';
    Js&ein.t.s.sMJ = &sMJj{
        Js&tri.>$s ++ && return;
        m j.t=>''=>{}=>{oJ=>$j,s=>$s}
    };
    S
    
    push @$M, grep {
        # For TapePlay: update o (orderliness), since we dont say its J (o 3 would Jo)
        _s&o = _s&s && _s&s.c.o
            || die "nots: ".ki$_;
    } @{Js&M||=[]};
TapePlay: | # osc follow s&jJ's s&s, using K 2 Jo
    u als
    o 18: %of:K
        c&Jo = s&o || die "Give opy";
        my $l = a&l || die "No l";
        a&J = ls&oJ || die "NotJ";
        a&ys = ls&s || die "No o";
        delete s&oJ;
        
    o 3: %of:K
        my $z = s&z || return;
        
        C.t = "Our C.t";
        delete s&o;
        if (my $t = 1s&ze) {
            G&elph,$t=>[z=>$z];
        }
        if (my $t = 1s&zeat) {
            G.Wouter->($t,{eat=>$z});
        }
        #delete s&z;
Monitor: | # batches for ocean views
    u Zpace
    y.rev = 100;
    Js&ein.t.z.sMJ = &sMJj{
        Js&wls++;
        for (@$s) {
            my @ext = G&ind,$_;
            my $s = "_.t _.y.cv: ".ki({c=>_.c,sc=>_.sc});
            m Js&wls=>''=>$s,{lines=>0+@ext}
        }
    };
    S
    
    push @$M, @{Js&M||=[]};
    
Wout: | # sends up
    
Junup: | # display z of c&eat (K)
    u urw
    G&xo,y.at||={},$_ for G&peel,'ws:pre,wb,mw:60%,mh:60%';
    
    J.ev.li = 'Juned'; # way back in
    
    return T.nose = 1 unless C.c.eat;
    
    # z must leak no refs, except .y.* which will be ycv only
    my $z = [ref $eat eq 'ARRAY' ? @$eat : $eat];
    # dripfeed time
    my $deal = 0.3 if @$z > 1;
    
    my $elv;$elv = sub {
        my ($C,$d,$la) = @_;
        
        $C = G&hup,$C;
        C.y = C.y.cv;
        
        if ($la) {
            c&s = "\n".c&s if $la && (C.y =~ /0\.(\d)/)[0]
                             ne ($la->[1] =~ /0\.(\d)/)[0]
        }
        my $la;
        C.sc.z = [map{my$l=$elv->($_,$d+1,$la);$la=$l;}@{C.sc.z}] if C.sc.z;
        C.sc.deal ||= $deal if $deal;
        [C.t,C.y,C.c,C.sc]
    };
    my $eat = C.c.eat;
    my @z = map { $elv->($_) } ref $eat eq 'ARRAY' ? @$eat : $eat;
    
    n itc=>0.0001=>{}=>{z=>\@z,mw=>'80%',mh=>'80%'}
    
Juned: | # handle input
    sayyl "J.t: ".ki us&C;
    Rw talkzyh;
    T.pos = 0;

