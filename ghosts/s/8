
Elvising: | # new way
    n ElVerse
    n ElBridge
    n ElChorus
    n PaintedStripes
    n Hosthing
    # not very stuck in alacgt etc u, only compilable on Os
    #n Zpace
    
    # heaven's above me on a street called love
    # J must make known elvising to use .e hooks to answer calls
    
    
    # three ways in to E:
    # - 36: before/without pin (J has itself)
    # - 63211: within pin at time2 (J becomes)
    #      allowing J completion with th(e)m in one
    # - 67: after pin (J becomes)
    #       T.oke to force J redoing
    #     T.pos = 0 to waylay J redoing
    
    # ^ points to tug E
    # 
    
    # handlers include stuff in of=E
    #  - pin could make handler subs
    #  - pin could always happen, chews e itself
    #      probe if nothing uses eg e&_z
    
    
    
    
    
    # localised implica expanded into universal (still localised)
    # eg make everything acgt:s
    
    #  # decompression wants to live in of=D and be for nonJ
    # and be the thing knowing/isolating a ghost
    # making A.D = receipt for the pin/scheme/O cause/elvis handling
    # or the convo/dialect state applied within
    # falling A bounds like .mo:
    
    # U al4noJ 3 spawns our encoding on the J6ing.mo:
    #     A.D = {self,J=A.D}
    #         marking D above ours (unless already) as the norm for doing J
    # then mo dome 2:
    #    A.D = A.D.J if c&J && A.D && A.D.J;
    #       peels off encodings/holes to A.mo.up.mo's intention
    #         for this A.mo, so it can speak nonJ n normally
    #   runs D
    #        with A.D for direction/self
    # and U al4noJ 7:
    #    finishes our encoding
    
    # D may make good interface to pages to reset (when J 6)
    # or unrestart (when S sleeps)
    # or partition (with names) and despatch to whatever process
    
    # so encodings should all of=D
    # a W reverses line protocols from remote stream
    # via m into golden box acum space
    # fills <5 at lum top, 8-9 lum/3, 7-8 lum/7, etc towards 555555555555
    # into streams of atoms for your A.3 to officially reposition
    # there's a ghost bridge
    
    # of=U = runs when mind made up/down
    # of=M = for the $M produced by 6, incs depth of atoms
    # of=S = check for escaping gas (sleeps minor changes)
    
ElVerse: | # hyperactive With
    u i
    
    # looking for C.c.e.?.? in a pin
    # could see/ip what they are looking for too
    # and give A&E clues for what the thing can do
    # to take back to the client
    e:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        return e.t if $s eq 't';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = G&pang,$s,'c';
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # looking for C.c.e.c.us.?_? in a pin
    # explicit nk/gk sep with _
    # clot of universalish nonhouse
    # for our trusted their message
    # an e&us at E 1 is a security bang
    # us should float across as e sces
    us:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        $e = e.c.us || return ();
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = split'_',$s;
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # describe A net
    sn:
        my @net = ('y',1,2,3,4,5);
        shift @net if $s eq '5';
        my ($s,$h,$la);
        for my $i (@net) {
            my $Y = $A->{$i} || die "Npo $i on ".ki $A;
            ref $Y eq 'HASH' || die "Got $i from A.t: ".ki $Y;
            my ($cvb) = Y.cv =~ /^0\.(\d+)$/ if $Y eq $A;
            my $sep = '.' if $s;
            $sep = '@' if $la eq $A;
            my $th = Y.t;
            if (my $ii = $h.>$Y ) {
                $th = ','.$ii;
                $sep = '';
            }
            $h.>$Y ||= $i;
            if ($la eq A.2) {
                # can go funny directions
                if ($la ne A.5 && $la ne A.4 && la.3 ne A.3) {
                    # J inherit 12345 before its set right
                    $sep = "(".($la eq la.3 ? "" : "la.3.t)");
                }
            }
            $s .= "$sep$th$cvb";
            $la = $Y;
        }
        $s
    # describe A net and e
    es:
        my $cv = A.mo.cv;
        $cv =~ s/^0\.//;
        my $e = G&e,\'C';
        G&sn .":\n    ".ki($e).(e.c.hC && ki(e.c.hC));
    
    # means vector is about to do new ground
    # solves mind - which should row the of=S somewhere
    # also tugA,mo so E can resolve and tell S/mo to sleep pin if T.pos=0;
    # spaces out ground over time
    # or headers from bodies of work, making sleep if same
    # want to substrata bits of the ground,
    # make pages of osc for groups of time
    vent:
        my $E = A.mo.c.E;
        my ($cvb) = E.cv =~ /^0\.(\d+)$/;
        $s = "Elos $cvb $s\n  at ".G&es;
        push @{G.ohno||=[]},$s;
        push @{E.c.vent||=[]},$s;
        !4c&mutelos && sayre $s;
        T.Z.8 = $A;
    # engage mind
    # $s && mark pages of osc for groups of time
    S:
        G&A,n=>2,A.1,[];
        1&&saygr "S C.t ".G&sn;
        $A = A.mo;
         G&tug,0.6; # eg E can pos=1 awake
        1 unless "can" eq "sleep";
        
    # marks a point for ghost chopchoping
    T:
        1&&saygr "T C.t ".G&sn;
        1;
    # etc
ElChorus: | # mo->E joins your request to a J
    # tries to route to handlers instead of pin
    # vents unknowns
    # elvectricity flowing through the space
    u c
    n \'of:mo'
    e 36:
        A.1 eq A.2 && sayre "Elvising same: ".G&es;
        A&E && die "Elvising already: A&E.c.s.c.e.t vs e.t";
        A&E = G&tugA,E=>1,$C;
    
    # elvis should have resolved
    # or been accessed e&la in pin (see Ce e)
    e 72:
        my $E = A&E;
        return if E.cv >= 0.6 && !Ec&wantpine && !Ec&pines;
        if (Ec&pines) {
            1s&seemstoe = 1;
        }
        else {
            G&vent,"Notcompleted";
        }
    
    u a
    n \'of:E'
    # mo tugs, wait for mind
    e 1:
        local A.V = 2;
        my $mo = A.mo;
        A&s = $C = $s->[0];
        my $e = A&oure = c&e || die "E no e: ".wdump 3, A.c.N;
        # routes do new C.c.e = C this e came from
        # reel in the tube of routes before the request
        my @hz;
        while ($e) {
            push @hz, $e;
            $e = e.c.e || last;
        }
        if (@hz > 1) {
            e.c.hz = \@hz;
        }
        else {
            if (!e.c.us && e.c.s =~ /^\{/) {
                # network line comes in on e as listen event
                # should onward aft hz an e as meaning/request
                # making the meaning beyond the book
                # and the readers in front of it
                my $us = eval{djson e.c.s};
                die "elvis line decode error: $@\n\n cs: ".slim 300, e.c.s if $@;
                # stylehut says {event:{...}}
                if (keys %$us == 1 && us.event) {
                    $us = us.event;
                }
                if (us.p) {
                    # parse string/not to [[t,cv]...]
                }
                
            }
            if (e.c.p) {
                e.c.us.p = [map{[split '-', $_]}@{delete e.c.p}];
            }
        }
        
        # opens
        A&E = $A;
        A&e = $e;
        
        G&block,$_ && return for sub {
            !(1s&ein || 1s&seemstoe || A&pines || 1s&tv)
        };
    #c e2 arrived to some mind: enter or route or wait for it to begin
    e 2:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        if (!$in) { # ein & seemstoe may be, pins if 
            if (A&pines) {
                # just did pin that e& - finished
                return T.Z.8 = $A
            }
            elsif (1s&seemstoe) {
                # may want hC etc in the pin, if us.p...
                # e should be before S, or it keeps going
                # so e is self in the equation that uses it
                # and handles it, since it hands it...
                die "Got toking E unknown too late: ".G&es if A.mo.cv > 0.5;
                A&wantpine = 1;
                A.mo.c.want.elvis = 6;
                return T.Z.6 = $A;
            }
            else {
                # doesn't need to know anything,
                # gets route, vent if lost
                return T.Z.6 = $A;
            }
        }
        
        # tractorbeam makes deeper look even if routable
        # so we can log e
        unless (in.tractor && Ec&trJ && Ec&trJ->[-1] ne A.1
            # or not routable
            || !$us
            # or is routed to us
            || us.ids && do {
                # not anymore, but could warp them up
                # the J finds its easiest way in
                # for now the chain must be linked
                us.ids->[us.idi - 1] eq 1s&id
            }
            || us.p && do {
                # for now the chain must be fully linked also
                my $tcv = us.p->[Ec&us.p_i - 1];
                $tcv && $tcv->[0] eq A.1.t
            }) {
            return T.Z.6 = $A;
        }
    #c e3 enter linguistically, solve simple requests or try pin if seemstopine
    e 3:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein || return saybl "No Ein for e.t";
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        if (in.tractor) {
            ec&trJ && ec&trJ->[-1] eq A.1 && return G&vent,'Doublysendo';
            push @{ec&trJ||=[]}, A.1;
        }
        
        my @being = $e;
        # can multiplex lines, must handle simply here or be lost
        while (@being) {
            $e = shift @being;
            T.com = 1;
            if (in.o && A.1 ne A.2) { # from other? may talk to self
                Rw in.o;
            }
            elsif (in.li) {
                Rw in.li;
            }
            #  pi (or can translate object through)
            elsif (my $pin = in.pi && in.pi.>e.sc.pi ) {
                ref $pin && die "More pinfotic";
                Rw $pin;
            }
            # c spaced things
            elsif (my $pin = in.t && in.t.>e.t ) {
                if (!ref $pin) {
                    Rw $pin;
                }
                else {
                    die "e t complexi ".ki $pin if !pin.s || pin.s ne 'M' || keys %$pin != 1;
                    # s=M used to open envelopes of e etc without leaving here
                    my $M = djson e.c.s;
                    push @being, @$M;
                    sayre "Multied ".@$M." For ".G&es;
                }
            }
            # 
            else {
                T.com = '';
            }
            # and then
            if (T.com eq '4') { # handler says keep going into E 4
            }
            elsif (T.com eq '6') { # handler says route
                T.Z.6 = $A;
            }
            elsif (T.com) { # handled
                T.Z.7 = $A;
            }
            else {
                # unhandled
                in.tractor && in.demand && return G&vent,'Tractiondemand';
                # can try E 4, probably route for 6
                if (A&pines) {
                    T.pos = 0; # doneA
                    sayyl "3 doneA pin";
                    return T.Z.7 = $A;
                }
                elsif (1s&seemstoe && !($us && us.p)) {
                    A&wantpine = 1;
                    A.mo.c.want.elvis = 6;
                    sayre "3 want pin";
                    return T.Z.7 = $A;
                }
            }
        }
        return if T.Z;
    
    #c e37 treeify hJ/hC
    # bo or handler will use the remotest does
    e 37:
        local A.V = 2;
        my $e = A&e;
        my $us = e.c.us;
        my $in = 1s&ein;
        # detect way in after this route from the tree of J we have
        my $J = A.1;
        my $c = Js&top;
        $c || return T.Z.6 = $A; #A&pines || A&wantpine ||
            #G&vent,"e4Notop:J.t:J.c.o"; # try again later
        my $p = $us && us.p || return
            A&pines || G&vent,"NoE4point";
        
        my @p = @$p[ us.p_i .. (@$p-1) ];
        my $i = 0;
        for (@p) {
            my ($t,$cv) = @$_;
            my $cc = $c;
            my $v;
            if ($i == 0 && $t eq C.t) {
                1&&saygr "hop 1 is C.t";
            }
            else {
                $t || die "No way in";
                my $v = c.y.tv || c.sc.J && c.sc.J.sc.tv
                    || die "No tv on ".ki$c;
                $v = $v.>$t;
                if (!defined $cv) {
                    ($cv,my@mi) = sort keys %$v;
                    @mi && return
                        G&vent,"Amb:$t:".join',',$cv,@mi; # could keep going
                }
                $c = $v.>$cv;
            }
            if (!$c) {
                my @p = map { "@$_" } @p;
                splice @p, $i,0,'lost:';
                my $rea = "E4pointlost: on cc.t cc.y.cv: ".join' ',@p;
                $rea .= '  among:'.slim(44,join',',sort keys %{cc.y.tw});
                return G&vent,$rea;
            }
            push @{e.c.hC ||= []}, $c;
            push @{e.c.hJ ||= []}, c.sc.J if c.sc.J;
            $i++;
        }
        
    #c e5 can route into pi pins, see who wakes up
    e 4:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein;
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        # tug indy uov
        T.com = 1;
        if (in.bo) {
            Rw in.bo;
        }
        else {
            T.com = '';
        }
        if (T.com eq '6') {
            # handler says do route
            # e is on a many pointed mission
            # us.p changes/grows around corners
        }
        elsif (A&vent) {
            return;
        }
        elsif (T.com eq '1') {
            # handled
            T.Z.7 = $A;
        }
        else {
            # unhandled
            G&vent,"E55nosolution";
        }
        
        
        #
    
    #c e6 route W, beyond here - could have done stuff too
    # may like to build onward meaing if so
    e 63:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        unless ($us && us.p && ref us.p eq 'ARRAY') {
            #G&vent,'NoE6point' unless A&pines;
               return;
        }
        
        my $point = us.p->[us.p_i||=0];
        $point || return G&vent,'Nomorepoint';
        my ($t,$cv) = @$point;
        
        my $vs = 4s&Jtv.>$t;
        $cv ||= 0.1;
        my $oJ = $vs.>$cv;
        
        if ($oJ) {
            us.p_i++;
            # readers move in in front of the meaning
            _.c.mo.c.T.not = 1 for
            n oJ.t=>W=>{e=>$C}
            T.pos = 0;
        }
        else {
            G&vent,"SpaceGoing:$t";
            # could make it up for it wants the name
            # makes networked light injector
        }
    
    #c e7 completion desires to J now or in a second
    e 7:
        local A.V = 2;
        my $mo = A.mo || die "Nomo"; # mo
        my $te = mo.c.T;
        # inherit from mo positivity
        $T.>$_ = $te.>$_ for grep{ defined $te.>$_ } qw'oke pos';
        if (T.oke) {
            # do pin now
            if (mo.cv < 0.5) {
                # mo for it is still early
                mo.c.want.elvis = 6;
                # doesnt take T.oke, may Sleep
                # e floatilla should TGW without Toke
                sayyl "Want elvis";
            }
            elsif (mo.cv < 0.6) {
                # doing pin, tugged while S, tell it not to sleep
                mo.c.T.oke = 1;
                sayyl "Want toke";
            }
            else {
                sayyl "toolate Elvuis";
                C.c.W || die "aft 6 Toke non W: ".ki$C;
                #Rw waited $J;
            }
            sayre "Toking mo.cv into ".G&es;
            return;
        }
        T.pos = 0 if !defined T.pos && A&wantpine;
        T.pos = 1 if !defined T.pos;
        if (T.pos) {
            # do J in a second
            sayyl "Do A.1.t in a second: ".G&es
            #Rw waito $J $C;
        }
    
e: | # for elvis handlers
    n alact
    e 4223: %acgt:s,act,of:mo
        # make their v for .c.e
        # and various expand to shape pieces of server/etc protocols
        s&of ||= 'E';
    
Routable: | # look for routes in J (vie li, tractor?)
    # using pi to track remote pi
    # tables of stuff to match, could double the cv for the solution
    # route C could have sc.opel, a new path
    # have to T.com = 6 to skip 4/5ing the p here, which wont work
    # 
Doable: | # look for dos in hC (vie bo)
    my @doers = grep {_.sc.dos} @{e.c.hC};
    @doers || return G&vent,"Nodoing";
    @doers == 1 || G&vent,"Manydoing";
    my ($c) = @doers;
    1&&sayyl "dos e.t for c.sc.dos: ".ki$c;
    
    Rw c.sc.dos + $c;
    

ElvisRopeWay: | # J uphoisted xo way, causes activity, G.hasway
    my $t = Rw Telvis;

    my $dd = sub {
        t.cs->({rsl=>[split"\n",ddump shift]},shift);
    };
    my $xo = sub {
        my $s = t.ntos->(c&te);
        my $xo = s.sc.xo;
        my $l = shift;
        t.cs->({rsl=>s.sc.infxo},$l);
        $dd->($xo,"xo: ".$l);
        $xo
    };
    Rw HasWay;

    if ($n == 0) {
        c&te =
        n ElvisWithGhosts
        my $W = t.ntos->(c&te,'J');
        A.5 = $W;
        
        t.cs->('sc lastA 1 ii w y in', 'has ghost w');
        my $pi = G&pint,$W,split'-',"ii-w-y-tw-pi/somiplace";
        ok pi.c.s =~ /# Difference/, "pi/somiplace with a little difference";
        ok pi.c.s !~ /n moreso=>/, "pi/somiplace non-moreso";
        
        c&te =
        n Elvariurgre=>W=>{lim=>4}
        t.en->('sc lastK c s', 'they have stuff');
        J.xo1 = $xo->("Has 14 total");
        my $mo = t.ntos->(c&te,'mo');
        $dd->(mo.c.want, "Elvari no wanted");
        
        c&te =
        n ElvisWithGhosts
        t.cs->('sc lastA 1 ii w y in', 'has ghost w differently');
        t.cs->('sc lastA 1 sc u sc s sc lastK c s', 'has ghost w differently u K');
        
        my $W = t.ntos->(c&te,'J');
        my $pi = G&pint,$W,split'-',"sc-u-sc-ii-w-y-tw-pi/somiplace";
        ok pi.c.s =~ /# Difference/, "pi/somiplace with a little difference";
        ok pi.c.s =~ /n moreso=>/, "pi/somiplace is moreso";
        
        c&te =
        n Elvariurgre=>W=>{lim=>5,vangoats=>3}
        t.en->('sc lastK c s', 'they have stuff moreso');
        J.xo2 = $xo->("Has 15 moreso + vang");
        my $mo = t.ntos->(c&te,'mo');
        $dd->(mo.c.want, "Elvari notices pin change");
    }
HasWay: | # pin upsurge
    G.hasway = sub {
        my ($A,$C,$G,$T,$v) = @_;
        my $te = A.mo && A.mo.c.T || return;# saybl "Nowhere to mo T has";
        # should multi the name from the first one
        my $w = v.y.argumented || die "Not argumented? ".ki$v;
        te.has.way.>w.t.>w.sc.dige ++;
    };
Hosthing: | # <-- Hosting
    u a
    # try wormhole/avoidance, wants Tractor to override regularly
    # force T.H
    #    1 nothing
    #    2 stores only
    #    3 everything
    #    4 
    #    5 ^ + ii, s7ing slightly more whole, know how to eval code
    # fork to commit the change
    #   8+ thaws only
    thawJ 34: %of:mo,t:y:A:mo:up:mo:c:T:H || y:A:mo:c:T:H
        c&e && return;
        
        keys %{C.c} == 2 && c&W eq c&J && c&W eq C.t || return;
        
        # 
        a&thawable = 1 unless $s < 3;
        a&storable = 1 unless $s < 2 || $s > 7;
        a&storable && A.up.c.store++;
        a&thawable || return;
        my $V = A.1.t =~ /^[A-Z]/ && A.2.t ne 'u';
        my $d = G&thaws,$V || return;
        
        $V && saygr " for ".G&sn;
        if ($s == 4) {
            # thaws tv etc too, puts on Js&tv before doing pin as usu.
            a&stowexp = 1; # anything exported from s sc > J sc
        }
        elsif ($s == 5) {
            # as above but sets up the osc to continue the W lv
            # B imp/wil/mat resume
            # B means being of a W, branch name
            # the lv writer needs to understand [,,,,[newlv]]
        }
        else { # 3-7
            # skips it all
            c&parts = $d;
            T.Z.7 = $A;
            delete a&storable;
        }
        
    stawJ 78: %of:n,t:y:A:c:store
        for my $m (@{A&mos||[]}) {
            ms&storable || next;
            my $c = mc&s;
            my $J = cs&J;
            my $s = Js&s;
            G&stores,$s;
            #G.ouJ = $s;
        }
        
    u i
    thaws:
        local C.c.V = 1;
        n Stro=>[get=>$C]
        delete s&top
    
    # make extra xo about W
    stores:
        my $t = s.sc.top || die "Store no top: ".ki $s;
        if (a&stowexp) {
            # expensiver keeping ii/tv/etc in a bundle
            # could fork, ind without hup to shave y
            # yaml it all
        }
        my @all = G&ind,$t;
        my ($u) = @all;
        for (@all) {
            delete _c&ind;
            _s&coded = 1 if delete _c&code;
            _.y = {cv=>_.y.cv};
            my $in = delete(_c&inside) || [];
            my $z = delete _s&z;
            delete _s&J;
            G&oleak,$_,5 && die "Leaks: @$in: ".ki $_;
            _s&z = $z;
        }
        u.sc.xo = s.sc.xo if s.sc.xo;
        n Stro=>[put=>$u]
    
Stro: | # storage aJent
    T.nose = 2; # no osc but keep J (4s&Jtv)
    T.pos = 0; # always thinks its right
    my $f = 'w/St';
    my $c = e&s; # sets C.c.e.c.s.sc.top = got
    my @p = map { s/\W//g;$_ } A.4.t, c.t;
    my $p = join '/', $f, @p;
    my $f = "$p/head";
    if (e&t eq 'put') {
        `mkdir -p $p`;
        DumpFile($f,$c);
        C.c.V && sayyl "Store $f";
    }
    elsif (e&t eq 'get') {
        -f $f && -s $f || return;
        my $u = LoadFile($f);
        $u || return;
        cs&top = $u;
        C.c.V && sayyl "Get $f";
    }
    else { G&vent,"NHogo" }
ElvisPaintedStripes: | # T O->Style valve copy, Style separately on 5
    my $t = Rw Towering Ang
        || return;
    c&Se == 1 || return;
    
    my $head = sub {
        my $i;
        (grepl=>sub{ $i++ < 10 });
    };
    T.ray = 2 if c&TC && c&TC.c.ray;
    # trick is to make s&coded that stored without c&code
    # to avoid making a sub within a sub as args get put on
    T.ray ||= 5; # adjust to refresh PaintedStripes from And
    if (T.ray <3) {
        t.e = 
        n Ang
        t.cs->({$head->(),ntos=>'sc lastK c s'}, "Ang/Stripes");
        t.cs->({$head->(),rsl=>t.lookii->()}, "has ii");
        my $s = t.ntos->(t.e);
        my $mu = s.sc.ii.O.y.tw.muchofany;
        ok $mu, "got muchofany coded";
        my $m = G&hup,$mu;
        m.y = {cv=>m.y.cv};
        delete m.c.code;
        m.sc.coded = 1;
        
        G&oleak,$m,5 && die "ray store leaks: ".wdump 4, $m;
        DumpFile('w/StyleValve',$m);
    }
    
    if (T.ray <6) {
        t.e = 
        n PaintedStripes
        t.cs->({$head->(),ntos=>'sc lastK c s'}, "PaintedStripes valve");
        t.cs->({$head->(),rsl=>t.lookii->()}, "PaintedStripes has ii");
    }
    
    t.e = 
    n PaintingWithStripes
    t.cs->({$head->(),ntos=>'sc lastK c s'}, "PaintingWithStripes artworks");
    t.cs->({grepl=>sub{/muchofany/},rsl=>t.lookii->('ii')}, "PaintingWithStripes has ii");
    
    
    
PaintingWithStripes: | # stuff using the O->Styles valve
    u PaintedStripes
    n do=>1=>"Fosci",'%hs:345,fs:30'
    n eove=>2=>"Fascin",'%bgh:8745,he:23,wi:23,opa:4'
PaintedStripes: | # O -> Style bridge (ElvisPaintedStripes to cross)
    my $mu = LoadFile('w/StyleValve');
    #####
    # # ##
    n $mu
ElvisMatters: |
    map {
        n fivi=>$_=>"fi"
    } map { $_ / 7 * $_ / 3 } 33..54;
    n hoov=>-tinput
    
Junup: | # display z of c&eat
    u urw
    #y.at.tag = 'pre' unless c&nopre;
    y.at.ws = 'pre';
    y.at.wb = 1;
    y.at.mw = '60%';
    y.at.mh = '60%';
    #y.at.ab = 1;
    J.ev.li = 'Juned';
    return unless C.c.eat;
    my $z = [];
    my $elv;$elv = sub {
        my ($C,$d,$la) = @_;
        my $l = {};
        l.t = C.t;
        l.y = C.y.cv;
        l.c = C.c;
        l.sc = C.sc;
        $C = $l;
        if ($la) {
            c&s = "\n".c&s if $la && (C.y =~ /0\.(\d)/)[0] ne ($la->[1] =~ /0\.(\d)/)[0]
        }
        my $la;
        C.sc.z = [map{my$l=$elv->($_,$d+1,$la);$la=$l;}@{C.sc.z}] if C.sc.z;
        [C.t,C.y,C.c,C.sc]
        #$l;
    };
    my $l = $elv->(C.c.eat);
    n itc=>0.0001=>{}=>{z=>[$l],mw=>'80%',mh=>'80%'}
    #n reo=>-pre=>wdump 5, $l
    #J.VV.N = 1;
Juned: | # handle input
    sayyl "J.t: ".ki us&C;
    Rw talkzyh;
ElBridge: | # hoisting, desire
    u i
    # search last mo things top
    op:
        my $Wr = T.op || die "No Top to op";
        my $C;
        C.t = 'oping';
        s&t = $s || die "No t to op";
        Rw conot $C;
        my $ub = sub {
            my $D = shift;
            my $p = G&ip,s&ip,$D;
            return $D if $p;
        };
        my @ma = G&ind,$Wr,$ub;
        @ma
    # climb in/next/z with a sub giving returns in list
    ind: %acgt:s y d
        my $D = $s;
        $s = G&hup,$s;
        s.y.D = $D;
        $y ||= sub { shift };
        my $d = {%{$d||{}}};
        d.d++;
        my @out;
        if (my $z = s.sc.z) {
            push @out, map{ G&ind,$_,$y,$d } grep{defined} @$z;
        }
        if (my $in = s.y.in) {
            push @out, G&ind,$in,$y,$d;
        }
        my $my = [];
        @out = map {
            ! ref$_ ? "  ".$_ :
            ref $_ eq 'HASH' ? do{
                if (!_.c.ind) {
                    _.c.ind = d.d;
                    push @$my, $_;
                };
                unshift @{_.c.inside||=[]},s.t;
                $_
            } :
            $_
        } grep {defined} @out;
        
        if (my $next = s.y.next) {
            push @out, G&ind,$next,$y,{%$d,d=>d.d-1};
        }
        
        unshift @out, $s = $y->($s);
        
        @out = grep{$_} @out;
        return () if !@out;
        
        if (d.d == 1 && !grep{ref}@out) {
            join "\n", grep{defined} @out;
        }
        else { # an $N?
            s.sc.z = $my if @$my && ref $s eq 'HASH';
            return grep{$_} @out;
        }
        
    # make A that is 4
    mk4:
        my $J = A.1;
        $A.>$_ = $J for 1..4;
        $J.>$_ = $J for 1..4;
    # connect a resource to the vortexey hoist
    # for credits that pool up to the top level
    # want to be strung into roots, vaguing out
    # to allow G triggers
    has: %acgt:k v
        $v = 1 if !defined $v;
        T.has.>$k = $v
    # 3 xo reoccurs k v, adds undef for goners
    # wants more index
    newxo: %acgt:xo x
        my $so = $xo;
        $xo = {};
        my $oxo = xs&xo;
        for my $k (keys %$so) {
            my $v = $so.>$k;
            my $ov = $oxo.>$k;
            $xo.>$k = $v eq $ov ? $ov : $v;
        }
        for my $k (keys %$oxo) {
            exists $xo.>$k && next;
            $xo.>$k = undef;
        }
        xs&xo = $xo;
    # join many xo
    # may want to know top/our xo
    multiv:
        my $inf = s&infxo;
        my $sa = sub {
            push @$inf, shift;
            sayyl "Inf A.1.t: ".$inf->[-1]
        };
        if ($s eq 'way') {
            my $td = {};
            map {
                while (my ($t,$ds) = each %$_) {
                    while (my ($d,$q) = each %$ds) {
                        $td.>$t.>$d += $q
                    }
                }
            } map{_.c.s}@Me;
            $sa->(" $s from ".join(',',map{_.t}@Me).": ".ki $td);
            $td
        }
        else {
            my $total = sum map {_.c.s} @Me;
            $sa->(" $s totals $total from: ".ki \@Me);
            $total;
        }
    
    u a
    # 
    #c their xo
    O 6:
        c&Jo || return;
        my $x = a&x;
        my $J = a&J;
        my $s = Js&s;
        ss&xo || xs&xo || return;
        
        my $xo = A.up.sc.ox.>C.y.cv.>C.t = G&newxo,ss&xo,$x;
        
        
    # unify harvested xo and hoisted ox (y t xo) as xo
    s 7999: %v:sctop
        my $top = s&top || return;
        my $te = A.mo.c.T;
        my $xo = te.has; # our xo
        my $x = top.y.x || die "No x on A.1.t: ".ki s&top;
        my $oxo = xs&xo; # our past xo
        
        $xo = A&xo if A&xo; # W incoming
        my $we = G&newxo,$xo,$x if $xo || $oxo;
        
        my $ox = a&ox; # many y t xo (inc undef goners)
        my $xox = s&xox; # many k y t v past
        
        $xo || $ox || $oxo || $xox || return delete s&xo;
        
        if (!$ox && !$xox) {
            # harvested one
            s&xo = $xo;
            return;
        }
        
        if ($we) {
            my $cv = 0.9;
            $ox.>$cv.>A.1.t = $xo;
        }
        # ox is y t to xo
        # unified back to single xo with others
        my $kyt = {};
        G&chew,$ox,\'cv,t,k',$_ for sub {
            my ($v,$cv,$t,$k) = @_;
            my $ov = G&pint,$xox,[$k,$cv,$t];
            if ($v ne $ov) {
                $kyt.>$k++;
            }
            if (!defined $v) {
                delete $xox.>$k.>$cv.>$t;
                delete $xox.>$k.>$cv if !keys%{$xox.>$k.>$cv };
                delete $xox.>$k if !keys%{$xox.>$k };
            }
            else {
                $xox.>$k.>$cv.>$t = $v;
            }
        };
        
        # xo is our k v
        s&infxo = [];
        $xo = s&xo;
        for my $k (sort keys %$kyt) {
            my $yt = $xox.>$k || {};
            my @M;
            G&chew,$yt,\'cv,t',$_ for sub {
                my ($v,$cv,$t) = @_;
                push @M, {t=>$t,y=>{cv=>$cv},c=>{s=>$v}};
            };
            if (!@M) {
                delete $xo.>$k;
            }
            else {
                $xo.>$k = G&multiv,$k,@M;
            }
        }
        s&xox = $xox;
        s&xo = $xo;
        delete s&xo if !keys %$xo;
    
    #c J44 desire
    u s
    n \'of:mo'
        
    # 
    J 44:
        my $xo = Js&xo || return;
        my $ow = xo.way || return;
        local A.V = 2;
        for my $way (keys %$ow) {
            my $w = G&wup,$way || next;
            my $od = {%{ $ow.>$way }};
            delete $od.>w.sc.dige;
            if (keys %$od) {
                A&want.pin = 6;
                A&want.pins.>$way = 6;
            }
            else {
                # stays
            }
        }
        
    

