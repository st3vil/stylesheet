
Elvising: | # new way
    n ElVerse
    n ElBridge
    n ElChorus
    
ElVerse: | # hyperactive With
    u i
    
    # looking for C.c.e.?.? in a pin
    # could see/ip what they are looking for too
    # and give A&E clues for what the thing can do
    # to take back to the client
    e:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = G&pang,$s,'c';
        exists $e.>$nk || return ();
        my $n = $e.>$nk;
        exists $n.>$gk || return ();
        my $g = $n.>$gk;
        $list ? @$g : $g
    
    # looking for C.c.e.c.us.?_? in a pin
    # explicit nk/gk sep with _
    # clot of universalish nonhouse
    # for our trusted their message
    # an e&us at E 1 is a security bang
    # us should float across as e sces
    us:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        $e = e.c.us || return ();
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = split'_',$s;
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # describe A net
    sn:
        my $la;
        my $s;
        for (map { $A.>$_ } y=>1..5) {
            my ($cvb) = _.cv =~ /^0\.(\d+)$/ if $_ eq $A;
            my $sep = '.' unless !$s;
            $sep = '@' if $la eq $A;
            if ($la eq A.2) {
                # can go funny directions
                if (la.3 ne A.3) {
                    # J inherit 12345 before its set right
                    $sep = "(".($la eq la.3 ? "" : "la.3.t)");
                }
            }
            $s .= $sep."_.t$cvb";
            $la = $_;
        }
        $s
    # describe A net and e
    es:
        my $cv = A.mo.cv;
        $cv =~ s/^0\.//;
        my $e = G&e,\'C';
        G&sn .":\n    ".ki($e).(e.c.hC && ki(e.c.hC));
    
    # means vector is about to do new ground
    # solves mind - which should row the of=S somewhere
    # also tugA,mo so E can resolve and tell S/mo to sleep pin if T.pos=0;
    # spaces out ground over time
    # or headers from bodies of work, making sleep if same
    # want to substrata bits of the ground,
    # make pages of osc for groups of time
    vent:
        my $E = A.mo.c.E;
        my ($cvb) = E.cv =~ /^0\.(\d+)$/;
        $s = "Elos $cvb $s\n  at ".G&es;
        push @{G.ohno||=[]},$s;
        push @{E.c.vent||=[]},$s;
        !4c&mutelos && sayre $s;
        T.Z.8 = $A;
    # engage mind
    # $s && mark pages of osc for groups of time
    S:
        G&A,n=>2,A.1,[];
        $A = A.mo;
         G&tug,0.6; # eg E can pos=1 awake
        1 unless "can" eq "sleep";
        
    # marks a point for ghost chopchoping
    T:
        1&&saygr "T C.t".G&sn;
    # etc

ElChorus: | # E joins your language
    # tries to route to handlers instead of pin
    # vents unknowns
    # elvectricity flowing through the space
    u c
    n \'of:mo'
    e 36:
        A.1 eq A.2 && sayre "Elvising same: ".G&es;
        A&E && die "Elvising already: A&E.c.s.c.e.t vs e.t";
        A&E = G&tugA,E=>1,$C;
    
    # elvis should have resolved
    # or been accessed e&la in pin (see Ce e)
    e 72:
        my $E = A&E;
        return if E.cv >= 0.6 && !Ec&wantpine && !Ec&pines;
        if (Ec&pines) {
            1s&seemstoe = 1;
        }
        else {
            G&vent,"Notcompleted";
        }
    
    u a
    n \'of:E'
    # mo tugs, wait for mind
    e 1:
        local A.V = 2;
        my $mo = A.mo;
        A&s = $C = $s->[0];
        my $e = A&oure = c&e || die "E no e: ".wdump 3, A.c.N;
        # routes do new C.c.e = C this e came from
        # reel in the tube of routes before the request
        my @hz;
        while ($e) {
            push @hz, $e;
            $e = e.c.e || last;
        }
        if (@hz > 1) {
            e.c.hz = \@hz;
        }
        else {
            if (!e.c.us && e.c.s =~ /^\{/) {
                # network line comes in on e as listen event
                # should onward aft hz an e as meaning/request
                # making the meaning beyond the book
                # and the readers in front of it
                my $us = eval{djson e.c.s};
                die "elvis line decode error: $@\n\n cs: ".slim 300, e.c.s if $@;
                # stylehut says {event:{...}}
                if (keys %$us == 1 && us.event) {
                    $us = us.event;
                }
                if (us.p) {
                    # parse string/not to [[t,cv]...]
                }
                
            }
            if (e.c.p) {
                e.c.us.p = [map{[split '-', $_]}@{delete e.c.p}];
            }
        }
        
        # opens
        A&E = $A;
        A&e = $e;
        
        G&block,$_ && return for sub {
            !(1s&ein || 1s&seemstoe || A&pines || 1s&tv)
        };
    #c e2 arrived to some mind: enter or route or wait for it to begin
    e 2:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        if (!$in) { # ein & seemstoe may be, pins if 
            if (A&pines) {
                # just did pin that e& - finished
                return T.Z.8 = $A
            }
            elsif (1s&seemstoe) {
                # may want hC etc in the pin, if us.p...
                # e should be before S, or it keeps going
                # so e is self in the equation that uses it
                # and handles it, since it hands it...
                die "Got toking E unknown too late: ".G&es if A.mo.cv > 0.5;
                A&wantpine = 1;
                A.mo.c.want.elvis = 6;
                return T.Z.6 = $A;
            }
            else {
                # doesn't need to know anything,
                # gets route, vent if lost
                return T.Z.6 = $A;
            }
        }
        
        # tractorbeam makes deeper look even if routable
        # so we can log e
        unless (in.tractor && Ec&trJ && Ec&trJ->[-1] ne A.1
            # or not routable
            || !$us
            # or is routed to us
            || us.ids && do {
                # not anymore, but could warp them up
                # the J finds its easiest way in
                # for now the chain must be linked
                us.ids->[us.idi - 1] eq 1s&id
            }
            || us.p && do {
                # for now the chain must be fully linked also
                my $tcv = us.p->[Ec&us.p_i - 1];
                $tcv && $tcv->[0] eq A.1.t
            }) {
            return T.Z.6 = $A;
        }
    #c e3 enter linguistically, solve simple requests or try pin if seemstopine
    e 3:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein || return saybl "No Ein for e.t";
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        if (in.tractor) {
            ec&trJ && ec&trJ->[-1] eq A.1 && return G&vent,'Doublysendo';
            push @{ec&trJ||=[]}, A.1;
        }
        
        my @being = $e;
        # can multiplex lines, must handle simply here or be lost
        while (@being) {
            $e = shift @being;
            T.com = 1;
            if (in.o && A.1 ne A.2) { # from other? may talk to self
                Rw in.o;
            }
            elsif (in.li) {
                Rw in.li;
            }
            #  pi (or can translate object through)
            elsif (my $pin = in.pi && in.pi.>e.sc.pi ) {
                ref $pin && die "More pinfotic";
                Rw $pin;
            }
            # c spaced things
            elsif (my $pin = in.t && in.t.>e.t ) {
                if (!ref $pin) {
                    Rw $pin;
                }
                else {
                    die "e t complexi ".ki $pin if !pin.s || pin.s ne 'M' || keys %$pin != 1;
                    # s=M used to open envelopes of e etc without leaving here
                    my $M = djson e.c.s;
                    push @being, @$M;
                    sayre "Multied ".@$M." For ".G&es;
                }
            }
            # 
            else {
                T.com = '';
            }
            # and then
            if (T.com eq '4') { # handler says keep going into E 4
            }
            elsif (T.com eq '6') { # handler says route
                T.Z.6 = $A;
            }
            elsif (T.com) { # handled
                T.Z.7 = $A;
            }
            else {
                # unhandled
                in.tractor && in.demand && return G&vent,'Tractiondemand';
                # can try E 4, probably route for 6
                if (A&pines) {
                    T.pos = 0; # doneA
                    sayyl "3 doneA pin";
                    return T.Z.7 = $A;
                }
                elsif (1s&seemstoe && !($us && us.p)) {
                    A&wantpine = 1;
                    A.mo.c.want.elvis = 6;
                    sayre "3 want pin";
                    return T.Z.7 = $A;
                }
            }
        }
        return if T.Z;
    
    #c e37 treeify hJ/hC
    # bo or handler will use the remotest does
    e 37:
        local A.V = 2;
        my $e = A&e;
        my $us = e.c.us;
        my $in = 1s&ein;
        # detect way in after this route from the tree of J we have
        my $J = A.1;
        my $c = Js&top;
        $c || return T.Z.6 = $A; #A&pines || A&wantpine ||
            #G&vent,"e4Notop:J.t:J.c.o"; # try again later
        my $p = $us && us.p || return
            A&pines || G&vent,"NoE4point";
        
        my @p = @$p[ us.p_i .. (@$p-1) ];
        my $i = 0;
        for (@p) {
            my ($t,$cv) = @$_;
            my $cc = $c;
            my $v;
            if ($i == 0 && $t eq C.t) {
                1&&saygr "hop 1 is C.t";
            }
            else {
                $t || die "No way in";
                my $v = c.y.tv || c.sc.J && c.sc.J.sc.tv
                    || die "No tv on ".ki$c;
                $v = $v.>$t;
                if (!defined $cv) {
                    ($cv,my@mi) = sort keys %$v;
                    @mi && return
                        G&vent,"Amb:$t:".join',',$cv,@mi; # could keep going
                }
                $c = $v.>$cv;
            }
            if (!$c) {
                my @p = map { "@$_" } @p;
                splice @p, $i,0,'lost:';
                my $rea = "E4pointlost: on cc.t cc.y.cv: ".join' ',@p;
                $rea .= '  among:'.slim(44,join',',sort keys %{cc.y.tw});
                return G&vent,$rea;
            }
            push @{e.c.hC ||= []}, $c;
            push @{e.c.hJ ||= []}, c.sc.J if c.sc.J;
            $i++;
        }
        
    #c e5 can route into pi pins, see who wakes up
    e 4:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein;
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        # tug indy uov
        T.com = 1;
        if (in.bo) {
            Rw in.bo;
        }
        else {
            T.com = '';
        }
        if (T.com eq '6') {
            # handler says do route
            # e is on a many pointed mission
            # us.p changes/grows around corners
        }
        elsif (A&vent) {
            return;
        }
        elsif (T.com eq '1') {
            # handled
            T.Z.7 = $A;
        }
        else {
            # unhandled
            G&vent,"E55nosolution";
        }
        
        
        #
    
    #c e6 route W, beyond here - could have done stuff too
    # may like to build onward meaing if so
    e 63:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        unless ($us && us.p && ref us.p eq 'ARRAY') {
            #G&vent,'NoE6point' unless A&pines;
               return;
        }
        
        my $point = us.p->[us.p_i||=0];
        $point || return G&vent,'Nomorepoint';
        my ($t,$cv) = @$point;
        
        my $vs = 4s&Jtv.>$t;
        $cv ||= 0.1;
        my $oJ = $vs.>$cv;
        
        if ($oJ) {
            us.p_i++;
            # readers move in in front of the meaning
            _.c.mo.c.T.not = 1 for
            n oJ.t=>W=>{e=>$C}
            T.pos = 0;
        }
        else {
            G&vent,"SpaceGoing:$t";
            # could make it up for it wants the name
            # makes networked light injector
        }
    
    #c e7 completion desires to J now or in a second
    e 7:
        local A.V = 2;
        my $mo = A.mo || die "Nomo"; # mo
        if (T.oke) {
            # do pin now
            if (mo.cv < 0.5) {
                # mo for it is still early
                mo.c.want.elvis = 6;
                # doesnt take T.oke, may Sleep
                # e floatilla should TGW without Toke
                sayyl "Want elvis";
            }
            elsif (mo.cv < 0.6) {
                # doing pin, tugged while S, tell it not to sleep
                mo.c.T.oke = 1;
                sayyl "Want toke";
            }
            else {
                sayyl "toolate Elvuis";
                C.c.W || die "aft 6 Toke non W: ".ki$C;
                #Rw waited $J;
            }
            sayre "Toking mo.cv into ".G&es;
            return;
        }
        T.pos = 0 if !defined T.pos && A&wantpine;
        T.pos = 1 if !defined T.pos;
        if (T.pos) {
            # do J in a second
            sayyl "Do A.1.t in a second";
            #Rw waito $J $C;
        }
    
e: | # for elvis handlers
    n alact
    e 4223: %acgt:s,act,of:mo
        # make their v for .c.e
        # and various expand to shape pieces of server/etc protocols
        s&of ||= 'E';
    
Routable: | # look for routes in J (vie li, tractor?)
    # using pi to track remote pi
    # tables of stuff to match, could double the cv for the solution
    # route C could have sc.opel, a new path
    # have to T.com = 6 to skip 4/5ing the p here, which wont work
    # 
Doable: | # look for dos in hC (vie bo)
    my @doers = grep {_.sc.dos} @{e.c.hC};
    @doers || return G&vent,"Nodoing";
    @doers == 1 || G&vent,"Manydoing";
    my ($c) = @doers;
    1&&sayyl "dos e.t for c.sc.dos: ".ki$c;
    
    Rw c.sc.dos + $c;
    

ElvisRopeWay: | # J uphoisted xo way, causes activity, G.hasway
    my $t = Rw Telvis;

    my $dd = sub {
        t.cs->({rsl=>[split"\n",ddump shift]},shift);
    };
    my $xo = sub {
        my $s = t.ntos->(c&te);
        my $xo = s.sc.xo;
        my $l = shift;
        t.cs->({rsl=>s.sc.infxo},$l);
        $dd->($xo,"xo: ".$l);
        $xo
    };
    G.hasway = sub {
        my ($A,$C,$G,$T,$v) = @_;
        my $te = A.mo && A.mo.c.T || return saybl "Nowhere to mo T has";
        # should multi the name from the first one
        my $w = v.y.argumented || die "Not argumented? ".ki$v;
        te.has.way.>w.t.>w.sc.dige ++;
    };

    if ($n == 0) {
        c&te =
        n ElvisWithGhosts
        my $W = t.ntos->(c&te,'J');
        A.5 = $W;
        
        t.cs->('sc lastA 1 ii w y in', 'has ghost w');
        my $pi = G&pint,$W,split'-',"ii-w-y-tw-pi/somiplace";
        ok pi.c.s =~ /# Difference/, "pi/somiplace with a little difference";
        ok pi.c.s !~ /n moreso=>/, "pi/somiplace non-moreso";
        
        c&te =
        n Elvariurgre=>W=>{lim=>4}
        t.en->('sc lastK c s', 'they have stuff');
        J.xo1 = $xo->("Has 14 total");
        my $mo = t.ntos->(c&te,'mo');
        $dd->(mo.c.want, "Elvari no wanted");
        
        c&te =
        n ElvisWithGhosts
        t.cs->('sc lastA 1 ii w y in', 'has ghost w differently');
        t.cs->('sc lastA 1 sc u sc s sc lastK c s', 'has ghost w differently u K');
        
        my $W = t.ntos->(c&te,'J');
        my $pi = G&pint,$W,split'-',"sc-u-sc-ii-w-y-tw-pi/somiplace";
        ok pi.c.s =~ /# Difference/, "pi/somiplace with a little difference";
        ok pi.c.s =~ /n moreso=>/, "pi/somiplace is moreso";
        
        c&te =
        n Elvariurgre=>W=>{lim=>5,vangoats=>3}
        t.en->('sc lastK c s', 'they have stuff moreso');
        J.xo2 = $xo->("Has 15 moreso + vang");
        my $mo = t.ntos->(c&te,'mo');
        $dd->(mo.c.want, "Elvari notices pin change");
    }
ElvisTower: | # J pool net namer: puts on the screen
    my $t = Rw Telvis;

    my $dd = sub {
        t.cs->({rsl=>[split"\n",ddump shift]},shift);
    };
    my $xo = sub {
        my $s = t.ntos->(c&te);
        $dd->(s.sc.xo,shift);
    };
    G.hasway = sub {
        my ($A,$C,$G,$T,$v) = @_;
        my $te = A.mo && A.mo.c.T || return saybl "Nowhere to mo T has";
        # should multi the name from the first one
        my $w = v.y.argumented || die "Not argumented? ".ki$v;
        te.has.way.>w.t.>w.sc.dige ++;
    };

    if ($n == 0) {
        my $ma =
        n ElMatron
        my $W = t.ntos->($ma,'J');
        J.5 = A.5 = $W;
        
        c&te = 
        n Os
        t.en->('sc top', 'A Os');
        J.4 = A.4 = t.ntos->($ma,'J');
        
        c&te = 
        n Tube
        t.en->('sc lastK c s', 'A throat');
        $xo->("Tube way");
        
        c&te = 
        n Sequencing
        t.en->('sc lastK c s', 'A Sequencing');
        $xo->("Sequencing way");
        
        return;
        # c&te = 
        # n PiMachine
        # t.en->('sc lastK c s', 'A PiMachine');
        
    
        c&te =
        n ElvisMatters
        my $W = t.ntos->(c&te,'J');
        
        t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s});
        exit;
    }
ElMatron: | # our 5
    # make our w able to compile PiMachine
    u ElvisWayliases
    u ReU
    n some=>2=>3
    1 && sayyl "Our c: ".ki G&wup,'c';
ReU: | # our A.ii.theu 
    # host
    my $u = A.4.ii.theu;
    n theu=>1=>{s=>$u},'%of:W'
Os: | # our 4
    # travellers
    Rw Beer;
Beer: | # our 3
    n Tube
ElvisMatters: |
    map {
        n fivi=>$_=>"fi"
    } map { $_ / 7 * $_ / 3 } 33..54;
    n hoov=>-tinput
    
Junup: |
    u urw
    y.at.tag = 'pre';
    J.ev.li = 'Juned';
    my $z = [];
    my $elv;$elv = sub {
        my ($C,$d,$la) = @_;
        my $l = {};
        l.t = C.t;
        l.y = C.y.cv;
        l.c = C.c;
        l.sc = C.sc;
        $C = $l;
        if (c&s) {
            c&s .= "\n" if $la && (C.y =~ /0\.(\d)/)[0] ne ($la->[1] =~ /0\.(\d)/)[0]
        }
        my $la;
        C.sc.z = [map{my$l=$elv->($_,$d+1,$la);$la=$l;}@{C.sc.z}] if C.sc.z;
        [C.t,C.y,C.c,C.sc]
        #$l;
    };
    my $l = $elv->(C.c.eat);
    n itc=>2=>{}=>{z=>[$l]}
    #n reo=>-pre=>wdump 5, $l
Juned: | # handle input
    sayyl ki us&C;
ElBridge: | # mo joins E
    u i
    # connect a resource to the vortexey hoist
    # for credits that pool up to the top level
    # want to be strung into roots, vaguing out
    # to allow G triggers
    has: %acgt:k v
        $v = 1 if !defined $v;
        T.has.>$k = $v
    # 3 xo reoccurs k v, adds undef for goners
    # wants more index
    newxo: %acgt:xo x
        my $so = $xo;
        $xo = {};
        my $oxo = xs&xo;
        for my $k (keys %$so) {
            my $v = $so.>$k;
            my $ov = $oxo.>$k;
            $xo.>$k = $v eq $ov ? $ov : $v;
        }
        for my $k (keys %$oxo) {
            exists $xo.>$k && next;
            $xo.>$k = undef;
        }
        xs&xo = $xo;
    # join many xo
    multiv:
        my $inf = s&infxo;
        my $sa = sub {
            push @$inf, shift;
            sayyl "Inf: ".$inf->[-1]
        };
        if ($s eq 'way') {
            my $td = {};
            map {
                while (my ($t,$ds) = each %$_) {
                    while (my ($d,$q) = each %$ds) {
                        $td.>$t.>$d += $q
                    }
                }
            } map{_.c.s}@Me;
            $sa->(" $s from ".join(',',map{_.t}@Me).": ".ki $td);
            $td
        }
        else {
            my $total = sum map {_.c.s} @Me;
            $sa->(" $s totals $total from: ".ki \@Me);
            $total;
        }
    
    u a
    # 
    # their xo
    K 18:
        c&Jo || return;
        my $x = a&x;
        my $J = a&J;
        my $s = Js&s;
        ss&xo || xs&xo || return;
        
        my $xo = A.up.sc.ox.>C.y.cv.>C.t = G&newxo,ss&xo,$x;
        
        
    # unify harvested xo and hoisted ox (y t xo) as xo
    s 7999: %v:sctop
        local A.V = 2;
        my $top = s&top || return;
        my $te = A.mo.c.T;
        my $xo = te.has; # our xo
        my $x = top.y.x || die "No x on A.1.t: ".ki s&top;
        my $oxo = xs&xo; # our past xo
        
        my $we = G&newxo,$xo,$x if $xo || $oxo;
        
        my $ox = a&ox; # many y t xo (inc undef goners)
        my $xox = s&xox; # many k y t v past
        
        $xo || $ox || $oxo || $xox || return delete s&xo;
        
        if (!$ox && !$xox) {
            # harvested one
            s&xo = $xo;
            return;
        }
        
        if ($we) {
            my $cv = 0.9;
            $ox.>$cv.>A.1.t = $xo;
        }
        # ox is y t to xo
        # unified back to single xo with others
        my $kyt = {};
        G&chew,$ox,\'cv,t,k',$_ for sub {
            my ($v,$cv,$t,$k) = @_;
            my $ov = G&pint,$xox,[$k,$cv,$t];
            if ($v ne $ov) {
                $kyt.>$k++;
            }
            if (!defined $v) {
                delete $xox.>$k.>$cv.>$t;
                delete $xox.>$k.>$cv if !keys%{$xox.>$k.>$cv };
                delete $xox.>$k if !keys%{$xox.>$k };
            }
            else {
                $xox.>$k.>$cv.>$t = $v;
            }
        };
        
        # xo is our k v
        s&infxo = [];
        $xo = s&xo;
        for my $k (sort keys %$kyt) {
            my $yt = $xox.>$k || {};
            my @M;
            G&chew,$yt,\'cv,t',$_ for sub {
                my ($v,$cv,$t) = @_;
                push @M, {t=>$t,y=>{cv=>$cv},c=>{s=>$v}};
            };
            if (!@M) {
                delete $xo.>$k;
            }
            else {
                $xo.>$k = G&multiv,$k,@M;
            }
        }
        s&xox = $xox;
        s&xo = $xo;
        delete s&xo if !keys %$xo;
    
    #c J44 how the web works, including ape
    u s
    n \'of:mo'
    # how the web works
    # event finds a way into remote's mind
    
    # 
    J 44:
        my $xo = Js&s && Js&s.sc.xo || return;
        my $ow = xo.way || return;
        T.pass = 1;
        local A.V = 2;
        for my $way (keys %$ow) {
            my $w = G&wup,$way || next;
            my $od = {%{ $ow.>$way }};
            delete $od.>w.sc.dige;
            if (keys %$od) {
                A&want.pin = 6;
                A&want.pins.>$way = 6;
            }
            else {
                # stays
            }
        }
    
    # heaven's above me on a street called love
    # J must make known elvising to use .e hooks to answer calls
    
    
    # three ways in to E:
    # - 36: before/without pin (J has itself)
    # - 63211: within pin at time2 (J becomes)
    #      allowing J completion with th(e)m in one
    # - 67: after pin (J becomes)
    #       T.oke to force J redoing
    #     T.pos = 0 to waylay J redoing
    
    # ^ points to tug E
    # 
    
    # handlers include stuff in of=E
    #  - pin could make handler subs
    #  - pin could always happen, chews e itself
    #      probe if nothing uses eg e&_z
    
    

