
Slow: | # learns t-say, injecting behaviour remotely or localisinG & so on
    # type in pin to begin, looks for it in G
    # want more specific/closer places to drag things
    $M = [];
    
    #m lops=>typin
    
    G&elph,Mudit=>[N=>$M]
Elvising: | # new way
    n Elation
    n ElVerse
    n ElBridge
    n ElChorus
    
    # heaven's above me on a street called love
    # J must make known elvising to use .e hooks to answer calls
    # that is, the Js&e mindworlder
    # notice all
    # travel next
    
    # opt things in to ground off e
    
    
    
    # three ways in to E:
    # - 36: before/without pin (J has itself)
    # - 63211: within pin at time2 (J becomes)
    #      allowing J completion with th(e)m in one
    # - 67: after pin (J becomes)
    #       T.oke to force J redoing
    #     T.pos = 0 to waylay J redoing
    
    # ^ points to tug E
    # 
    
    # handlers include stuff in of=E
    #  - pin could make handler subs
    #  - pin could always happen, chews e itself
    #      probe if nothing uses eg e&_z
    
    
    
    
    
    # localised implica expanded into universal (still localised)
    # eg make everything acgt:s
    
    #  # decompression wants to live in of=D and be for nonJ
    # and be the thing knowing/isolating a ghost
    # making A.D = receipt for the pin/scheme/O cause/elvis handling
    # or the convo/dialect state applied within
    # falling A bounds like .mo:
    
    # U al4noJ 3 spawns our encoding on the J6ing.mo:
    #     A.D = {self,J=A.D}
    #         marking D above ours (unless already) as the norm for doing J
    # then mo dome 2:
    #    A.D = A.D.J if c&J && A.D && A.D.J;
    #       peels off encodings/holes to A.mo.up.mo's intention
    #         for this A.mo, so it can speak nonJ n normally
    #   runs D
    #        with A.D for direction/self
    # and U al4noJ 7:
    #    finishes our encoding
    
    # D may make good interface to pages to reset (when J 6)
    # or unrestart (when S sleeps)
    # or partition (with names) and despatch to whatever process
    
    # so encodings should all of=D
    # a W reverses line protocols from remote stream
    # via m into golden box acum space
    # fills <5 at lum top, 8-9 lum/3, 7-8 lum/7, etc towards 555555555555
    # into streams of atoms for your A.3 to officially reposition
    # there's a ghost bridge
    
    # of=U = runs when mind made up/down
    # of=M = for the $M produced by 6, incs depth of atoms
    # of=S = check for escaping gas (sleeps minor changes)
    
Elation: | # e activity
    u i
    # the synapse fills
    give:
        my $es = ref $Me[0] eq 'ARRAY' ? G&Ct,shift@Me
            : do {
                @Me == 1 && unshift @Me, 's';
                G&s,@Me
            };
        G&elph,$s=>[give=>$es]
    # and drains
    take:
        my $es = ref $Me[0] eq 'ARRAY' ? G&Ct,shift@Me
            : do {
                @Me == 1 && unshift @Me, 's';
                G&s,@Me
            };
        G&elph,$s=>[take=>$es]
    # and tips out
    forget:
        my $es = ref $Me[0] eq 'ARRAY' ? G&Ct,shift@Me
            : do {
                @Me == 1 && unshift @Me, 's';
                G&s,@Me
            };
        G&elph,$s=>[forget=>$es]
Elationist: | # Rw being for e holds
    # give receiver, holds by source extras xo
    Js&ein.t.give = &TesC{
        1 && sayyl "J.t eats ".G&aC,$s ." from C.y.A.2.t";
        Jc&from = C.y.A.2;
        Jc&es = $s;
    };
    Js&ein.t.take = &TesC{
        1 && sayyl "J.t spits ".G&aC,$s ." from C.y.A.2.t";
        Jc&from = C.y.A.2;
        Jc&es = $s;
    };
    # these happen automatically when a G drops out (cascade...)
    Js&ein.t.forget = &TesC{
        1 && sayyl "J.t forgets all about ".G&aC,$s ." from C.y.A.2.t";
        Jc&from = C.y.A.2;
        Jc&es = $s;
    };
    
ElVerse: | # hyperactive With for e
    u i
    # see also With/elph for the ephemeral elvis n
    
    # e&way -> c&e.sc.way
    # to get bits of the request
    # endmost if A&E
    # could see/ip what they are looking for too
    # and give A&E clues for what the thing can do
    # to take back to the client
    e:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        return e.t if $s eq 't';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = G&pang,$s,'c';
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            return $e if $gk eq 'C';
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # looking for C.c.e.c.us.?_? in a pin
    # explicit nk/gk sep with _
    # clot of universalish nonhouse
    # for our trusted their message
    # an e&us at E 1 is a security bang
    # us should float across as e sces
    us:
        my $e = c&e || return ();
        (my$q,$s) = (1,$$s) if ref $s eq 'SCALAR';
        $e = A&E.c.e if A&E; # endmost
        $e = e.c.us || return ();
        A&E && !$q && A&E.c.pines++;
        return $e if $s eq 'C';
        my $list = $s =~ s/^_//;
        my ($nk,$gk) = split'_',$s;
        exists $e.>$nk || return ();
        $e = $e.>$nk;
        if (defined $gk) {
            exists $e.>$gk || return ();
            $e = $e.>$gk;
        }
        $list ? @$e : $e
    
    # describe A net
    sn:
        $s ||= 6;
        my @net = ('y',1,2,3,4,5);
        shift @net if $s < 6;
        pop @net if $s < 5;
        pop @net if $s < 4;
        
        my ($s,$h,$la);
        for my $i (@net) {
            my $Y = $A->{$i} || die "Npo $i on ".ki $A;
            ref $Y eq 'HASH' || die "Got $i from A.t: ".ki $Y;
            my ($cvb) = Y.cv =~ /^0\.(\d+)$/ if $Y eq $A;
            my $sep = '.' if $s;
            $sep = '@' if $la eq $A;
            my $th = Y.t;
            if (my $ii = $h.>$Y ) {
                # number position if seen before
                $th = ','.$ii;
                $sep = '';
            }
            $h.>$Y ||= $i;
            if ($la eq A.2) {
                # can go funny directions
                if ($la ne A.5 && $la ne A.4 && la.3 ne A.3) {
                    # J inherit 12345 before its set right
                    $sep = "(".($la eq la.3 ? "" : "la.3.t)");
                }
            }
            $s .= "$sep$th$cvb";
            $la = $Y;
        }
        $s =~ s/\(,/(/g;
        $s
    # describe A net and e
    es:
        my $cv = A.mo.cv;
        $cv =~ s/^0\.//;
        my $e = G&e,\'C';
        G&sn .":\n    ".ki($e)
            .(e.c.us && "\n        us: ".ki(e.c.us));
    
    # unhandled elvis
    # means vector is about to learn a new trick
    vent:
        my $E = A.mo.c.E;
        my ($cvb) = E.cv =~ /^0\.(\d+)$/;
        my $clear = "  (in by 1s\&tv)" if Ec&inbytv;
        $s = "Elos $cvb $s\n  at ".G&es;
        push @{G.ohno||=[]},$s;
        push @{E.c.vent||=[]},$s;
        $s =~ s/\n/$clear\n/;
        4c&mutelos || sayre $s;
        T.Z.8 = $A;
ElBridge: | # hoisting, desire
    # see Sleep/Ghoster for actuative end
    u i
    # background processes to being a network of such things
    # non-thing in 
    
    # connect a value to the vortexey hoist
    # for credits that pool up to the top level
    # want to be strung into roots, vaguing out
    # needs corner bit in multiv to merge other than sum
    # to allow G triggers
    has: %acgt:1
        @Me || die "Nothing to have";
        my $Y = $A;
        if (ref $Me[0]) {
            my $move = shift @Me;
            $move = [$$move] if ref $move eq 'SCALAR';
            for (@$move) {
                $Y = $Y.>$_ || die "No move: @$move (at $_) from ".ki $Y;
            }
        }
        my $v = @Me == 1 ? 1 : pop @Me;
        my $T = Y.c.T;
        my $S = T.has ||= {};
        my $last = pop @Me;
        $S = $S.>$_ ||= {} for @Me;
        return $S.>$last += $v if $v eq '1';
        $S.>$last = $v;
    
    # 3 xo reoccurs k v, adds undef for goners
    # wants more index, where changes within rehash up to the depth
    newxo: %acgt:xo x
        my $so = $xo;
        $xo = {};
        my $oxo = xs&xo;
        for my $k (keys %$so) {
            my $v = $so.>$k;
            my $ov = $oxo.>$k;
            $xo.>$k = $v eq $ov ? $ov : $v;
        }
        for my $k (keys %$oxo) {
            exists $xo.>$k && next;
            $xo.>$k = undef;
        }
        xs&xo = $xo;
    # sum many xo
    # may want to know top/our xo
    multiv:
        my $inf = a&infxo;
        my $sa = sub {
            push @$inf, shift;
            sayyl "Inf A.1.t: ".$inf->[-1]
        };
        if ($s eq 'Tin') { # T ... markers
            my $td = {};
            for my $x (map{_.c.s}@Me) {
                G&chew,$x,'pin,label,line',$_ for &itsl{
                    $td.>$t.>$s.>$l += $i;
                };
            } ;
            $td;
        }
        elsif ($s eq 'way') {
            my $td = {};
            for (@Me) {
                next if _s&W;
                # TODO know W separately up to a...
                each tdq _c&s {
                    $td.>$t.>$d += $q;
                }}
            };
            $sa->(" $s from ".join(',',map{_.t}@Me).": ".ki $td);
            $td
        }
        else {
            my $total = sum map {_.c.s} @Me;
            $sa->(" $s totals $total from: ".ki \@Me);
            $total;
        }
    
    # 
    #c see their xo in O
    u a
    # dials: these things want to say of in t but set t to xo
    # so they are labelled as other here and in We embryos
    
    xo 6: %of:O
        c&Jo || return;
        my $x = a&x;
        my $J = a&J;
        my $s = Js&s;
        ss&xo || xs&xo || return;
        my $Y = A.sA || die "No us osc O xo: ".ki $C;
        my $xo = Ys&ox.>C.y.cv.>C.t = G&newxo,ss&xo,$x;
        
        
    # osc unifies xo (burrow of universals)
    # two the
    #    from A.mo.c.T.has with history by top.y.x
    #    and hoisted ox (y t xo)
    # into s&xo (osc sc xo)
    xo 78: %of:s
        if (c&imparted) { # thawing
            s&xo = A&xo if A&xo;
            return 
        }
        my $J = A.1;
        my $top = s&top || return sayre " : : no top on J.t, skip xo";
        my $te = A.mo.c.T;
        my $xo = te.has; # our xo
        my $x = top.y.x || die "No x on A.1.t: ".ki s&top;
        my $oxo = xs&xo; # our past xo
        
        $xo = A&xo if A&xo; # thawing
        my $we = G&newxo,$xo,$x if $xo || $oxo;
        
        my $ox = a&ox; # many y t xo (inc undef goners)
        my $xox = s&xox; # many k y t v past
        $xo || $ox || $oxo || $xox || return delete s&xo;
        
        if (!$ox && !$xox) { # just oneself
            s&xo = $xo;
            return;
        }
        
        if ($we) {
            my $cv = 0.9;
            $ox.>$cv.>A.1.t = $xo;
        }
        # ox is y t to xo
        # unified back to single xo with others
        my $kyt = {};
        G&chew,$ox,\'cv,t,k',$_ for sub {
            my ($v,$cv,$t,$k) = @_;
            my $ov = G&pint,$xox,[$k,$cv,$t];
            if ($v ne $ov) {
                $kyt.>$k++;
            }
            if (!defined $v) {
                delete $xox.>$k.>$cv.>$t;
                delete $xox.>$k.>$cv if !keys%{$xox.>$k.>$cv };
                delete $xox.>$k if !keys%{$xox.>$k };
            }
            else {
                $xox.>$k.>$cv.>$t = $v;
            }
        };
        
        # xo is our k v
        a&infxo = [];
        $xo = s&xo;
        for my $k (sort keys %$kyt) {
            my $yt = $xox.>$k || {};
            my @M;
            G&chew,$yt,\'cv,t',$_ for sub {
                my ($v,$cv,$t) = @_;
                my $z = G&Ct,[$t,$cv,{s=>$v},{}];
                if (my $D = top.y.tv.>$t.>$cv) {
                    zs&W = Ds&W if Ds&W;
                }
                push @M, $z;
            };
            if (!@M) {
                delete $xo.>$k;
            }
            else {
                $xo.>$k = G&multiv,$k,@M;
            }
        }
        s&xox = $xox;
        s&xo = $xo;
        delete s&xo if !keys %$xo;
    
ElChorus: | # mo->E joins your request to a J
    # tries to route to handlers instead of pin
    # vents unknowns
    # elvectricity flowing through the space
    u c
    n \'of:mo'
    e 36:
        if (A.1 eq A.2) {
            snooze 500;
            sayre "Elvising same: e.t on ".G&sn;
        }
        A&E && die "Elvising already: A&E.c.s.c.e.t vs e.t";
        A&E = G&tugA,E=>1,$C;
    
    # elvis should have resolved
    # or been accessed e&la in pin (see Ce e)
    e 72:
        my $E = A&E;
        return if E.cv >= 0.6 && !Ec&wantpine && !Ec&pines;
        if (Ec&pines) {
            1s&seemstoe = 1;
        }
        else {
            G&vent,"Notcompleted";
        }
    
    u a
    n \'of:E'
    # mo tugs, wait for mind
    e 1:
        local A.V = 2;
        my $mo = A.mo;
        A&s = $C = $s->[0];
        my $e = A&oure = c&e || die "E no e: ".wdump 3, A.c.N;
        # routes do new C.c.e = C this e came from
        # reel in the tube of routes before the request
        my @hz;
        while ($e) {
            push @hz, $e;
            $e = e.c.e || last;
        }
        if (@hz > 1) {
            e.c.hz = \@hz;
        }
        else {
            if (!e.c.us && e.c.s =~ /^\{/) {
                # network line comes in on e as listen event
                # should onward aft hz an e as meaning/request
                # making the meaning beyond the book
                # and the readers in front of it
                my $us = eval{djson e.c.s};
                die "elvis line decode error: $@\n\n cs: ".slim 300, e.c.s if $@;
                # stylehut says {event:{...}}
                if (keys %$us == 1 && us.event) {
                    $us = us.event;
                }
                if (us.p) {
                    # parse string/not to [[t,cv]...]
                }
                
            }
            if (e.c.p) {
                e.c.us.p = [map{[split '-', $_]}@{delete e.c.p}];
            }
        }
        
        # opens
        A&E = $A;
        A&e = $e;
        
        G&block,$_ && return for sub {
            !(1s&ein || 1s&seemstoe || A&pines ||
                do { A&inbytv = 1 if 1s&tv  }
                )
        };
    #c e2 arrived to some mind: enter or route or wait for it to begin
    e 2:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        if (!$in) { # ein & seemstoe may be, pins if 
            if (A&pines) {
                # just did pin that e& - finished
                return T.Z.8 = $A
            }
            elsif (1s&seemstoe) {
                # may want hC etc in the pin, if us.p...
                # e should be before S, or it keeps going
                # so e is self in the equation that uses it
                # and handles it, since it hands it...
                die "Got toking E unknown too late: ".G&es if A.mo.cv > 0.5;
                A&wantpine = 1;
                A.mo.c.want.elvis = 6;
                return T.Z.6 = $A;
            }
            else {
                # doesn't need to know anything,
                # may find body,
                # gets route, vent if lost
            }
        }
        
        # tractorbeam makes deeper look even if routable
        # so we can log e
        
        unless (in.tractor && Ec&trJ && Ec&trJ->[-1] ne A.1
            # or not routable
            || !$us
            # or is routed to us
            || us.ids && do {
                # not anymore, but could warp them up
                # the J finds its easiest way in
                # for now the chain must be linked
                us.ids->[us.idi - 1] eq 1s&id
            }
            || us.p && do {
                # for now the chain must be fully linked also
                my $tcv = us.p->[Ec&us.p_i - 1];
                my $t = $tcv->[0];
                $t && $t eq A.1.t
            }) {
            return T.Z.6 = $A;
        }
    #c e3 enter lingis, try solve, pin if cant #
    e 3:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein || return saybl "No Ein for e.t";
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        if (in.tractor) {
            ec&trJ && ec&trJ->[-1] eq A.1 && return G&vent,'Doublysendo';
            push @{ec&trJ||=[]}, A.1;
        }
        
        T.com = 1;
        # put this J's top forth
        if (my $s = 1s&s) {
            if (my $op = ss&top) {
                T.op = $op;
            }
        }
        
        my $pin;
        if (in.o && A.1 ne A.2) { # from other? may talk to self
            Rw in.o;
        }
        elsif (in.li) {
            Rw in.li;
        }
        #  pi (or can translate object through)
        elsif ($pin = in.pi && in.pi.>e.sc.pi ) {
        }
        # c spaced things
        elsif ($pin = in.t && in.t.>e.t ) {
        }
        # 
        else {
            T.com = '';
        }
        
        if ($pin) {
            if (!ref $pin) {
                Rw $pin;
            }
            elsif (ref $pin eq 'CODE') {
                $pin->($T,$e,e.c.s,$C,$A,$G);
            }
            else {
                for my $k (sort keys %$pin) {
                    my $v = $pin.>$k;
                    Rw $k + $v $us;
                }
            }
        }
        
        #A&vent && return;
            # and then
            if (T.com eq '4') {
                # handler says keep going into E 4
                # same as if no ein
                # so pointing to anything results in something
            }
            elsif (T.com eq '6') {
                # handler says route
                # leave J be? hang for a response?
                T.Z.6 = $A;
            }
            elsif (T.com) { # handled
                # break from tuggance and transfer desires to A.mo
                # also desire no pin
                T.Z.7 = $A;
                A&ov = 0.9;
                T.seek = 1;
            }
            else {
                # unhandled
                in.tractor && in.demand && return G&vent,'Tractiondemand';
                # can try E 4, probably route for 6
                if (A&pines) {
                    T.pos = 0; # doneA
                    sayyl "3 doneA pin";
                    return T.Z.7 = $A;
                }
                elsif (1s&seemstoe && !($us && us.p)) {
                    A&wantpine = 1;
                    A.mo.c.want.elvis = 6;
                    sayre "3 want pin";
                    return T.Z.7 = $A;
                }
            }
    
    #c e37 treeify hJ/hC
    # bo or handler will use the remotest does
    e 37:
        local A.V = 2;
        my $e = A&e;
        my $us = e.c.us;
        my $in = 1s&ein; # can find body without
        # detect way in after this route from the tree of J we have
        my $J = A.1;
        my $oJ = $J;
        my $c = Js&top;
        $c || return do {
            sayre("notop EZ6");
            T.Z.6 = $A; #A&pines || A&wantpine ||
            #G&vent,"e4Notop:J.t:J.c.o"; # try again later
        };
        my $p = $us && us.p || return
            A&pines || G&vent,"NoE4point";
        
        my @p = @$p[ us.p_i .. (@$p-1) ];
        my $i = 0;
        my @exact; # reresolve our C resolved by other J before here
        for (@p) {
            my ($t,$cv) = @$_;
            my $cc = $c;
            my $v;
            if ($i == 0 && $t eq C.t) {
                1&&saygr "hop 1 is C.t";
            }
            else {
                $t || die "No way in";
                my $J = c.sc.J;
                my $v;
                if ($v = c.y.tv) {
                }
                elsif (my $Jtv = $J && Js&tv) {
                    A&othward = 1 if $J->{3} eq $J; # resolving C into other J
                    my $z = J.C;
                    my $s = join ' ', grep {$_}
                        map { z.sc.>$_ && "$_=".z.sc.>$_ }
                        qw'depth pi';
                    sayyl "othing oJ.t $i $t $cv -> $s \t\t".G&aC,J.C;
                    $v = $Jtv;
                }
                else {
                    $v = {}; # nothing inside = no tv
                }
                $v = $v.>$t;
                if (!defined $cv) {
                    ($cv,my@mi) = sort keys %$v;
                    @mi && return
                        G&vent,"Amb:$t:".join',',$cv,@mi; # could keep going
                }
                $c = $v.>$cv;
                if (my $top = !$c && $J && J.t eq $t && $cv == 0.9
                    && Js&top) {
                    $c = $top if top.t eq $t && top.y.cv == 0.9;
                }
            }
            if (!$c) {
                my @p = map { "@$_" } @p;
                splice @p, $i,0,'lost:';
                my $rea = "E4pointlost: on cc.t cc.y.cv: ".join' ',@p;
                $rea .= '  among:'.slim(44,join',',sort keys %{cc.y.tw});
                A&reslos = $rea;
                # keeps going, building only known tree v
                last;
            }
            my $ii;
            if ($i == 0 && ec&hC && grep {$ii++;$c eq $_} @{ec&hC}) {
                $ii--;
                saygr "Cut: $ii: ".ki ec&hC;
                @exact = splice @{ec&hC}, $ii;
            }
            if (@exact) {
                # our resolved by others must be same as ours
                my $o = shift @exact;
                $o eq $c || G&vent,"PassedwrongC:o.t/c.t";
            }
            push @{ec&hC ||= []}, $c;
            push @{ec&hJ ||= []}, cs&J if cs&J;
            $i++;
        }
        if (@exact) {
            # extra piled on the right of that
            # so left/right dos linga
            sayyl "Extended: ".ki(ec&hC).":\n    ".ki \@exact;
            push @{ec&hC}, @exact;
        }
        
    #c e5 route into J - tree climbing
    e 4:
        local A.V = 2;
        my $e = A&e; # endmost e, we got A&oure on C
        my $us = e.c.us;
        my $in = 1s&ein;
        my $ar;
        ar.J = A.1;
        ar.e = $e;
        # tug indy uov
        T.com = 1;
        if (!A&reslos && !A&othward) {
            # reslos here if not certain the path points in here
            #   or is supposed to route
            # othward if we had to hop through sc.J to resolve path
            #   to be routed there, hC stretches across
            if (in.bo) {
                Rw in.bo;
            }
            else {
                T.com = '';
            }
        }
        else {
            T.com = '';
        }
        if (T.com eq '6') {
            # handler says do route
            # e is on a many pointed mission
            # us.p changes/grows around corners
        }
        elsif (A&vent) {
            return;
        }
        elsif (T.com eq '1') { # handled
            # break from tuggance and transfer desires to A.mo
            T.Z.7 = $A;
            A&ov = 0.9;
            T.seek = 1; # throats with new ov
        }
        else {
            # unhandled
            A&reslos ||= "E55nosolution";
        }
        
        
        #
    
    #c e6 route W, beyond here - could have done stuff too
    # may like to build onward meaing if so
    e 63:
        local A.V = 2;
        my $E = A&e;
        my $us = E.c.us;
        my $in = 1s&ein;
        
        unless ($us && us.p && ref us.p eq 'ARRAY') {
            G&vent,'NoE6point' unless A&pines;
            #G&vent,A&reslos if A&reslos;
               return;
        }
        
        my $point = us.p->[us.p_i||=0];
        $point || return G&vent,'Nomorepoint';
        my ($t,$cv) = @$point;
        
        my $vs = 4s&Jtv.>$t;
        undef $cv if $cv == 0.9;
        $cv ||= 0.1;
        my $oJ = $vs.>$cv;
        
        if ($oJ) {
            us.p_i++;
            # readers move in in front of the meaning
            _.c.mo.c.T.not = 1 for
            n oJ.t=>W=>{e=>$C}
            T.pos = 0;
        }
        else {
            sayre "Not amongst: ".ki [sort keys %{4s&Jtv}];
            A&reslos ||= "SpaceGoing:$t";
            G&vent,A&reslos;
            # could make it up for it wants the name
            # makes networked light injector
        }
    
    #c e7 completion desires to J now or in a second
    e 7:
        local A.V = 2;
        my $mo = A.mo || die "Nomo"; # mo
        my $te = mo.c.T;
        # inherit from mo positivity
        $T.>$_ = $te.>$_ for grep{ defined $te.>$_ } qw'oke pos';
        
        T.pos = 0 if !defined T.pos && A&wantpine;
        T.pos = 1 if !defined T.pos;
        
        if (T.oke || T.pos) {
            # do pin now to update picture with this change
            if (T.pos eq '3') {
                if (T.rep) {
                    G&vent,"repagain";
                    delete T.rep;
                }
                else {
                    sayre "Repeating elvis while mo@ mo.cv";
                    T.rep = 3;
                }
            }
            
            if (mo.cv < 0.5) {
                # mo for it is still early
                # todo because elvis
                mo.c.want.elvis = 6;
                T.whack = 1;
                # e floatilla should TGW without Toke
            }
            elsif (mo.cv < 0.6) {
                # doing pin, tugged complete in S
                mo.c.want.elvis = 6;
                # tell it not to Sleep
                mo.c.T.oke = 1; # extra
            }
            elsif (mo.cv < 0.7) {
                if (T.oke) {
                    # could do pin again then osc?
                    G&vent,"Tokelate";
                }
                else {
                    # could be impossible to render the change locally
                    # W is upstreaming for its true self
                }
                C.c.W || die "aft 6 Toke non W: ".ki$C;
                sayyl "Do A.1.t again before osc: mo.cv ".G&es;
                #Rw waited $J;
                #te.nose = 1; # or oscs twice?
                # A not meant to be wound back
            }
            else {
                if (T.oke) {
                    G&vent,"WAAAAYTokelate";
                }
                sayyl "Do A.1.t in a second: ".G&es
                #Rw waito $J $C;
            }
            return;
        }
    #c e8 aim vented gas for further helping
    # A.elvis? last person to know how to pipe com
    e 8:
        local A.V = 2;
        if (T.rep == 3) {
            sayre "8->3ing elvis";
            T.rep--;
            T.Z.3 = $A;
            T.seek = 1; # throat one way
            return;
        }
        A&vent || return;
        my $e = A&e;
        4c&sit && return G&elph,4c&sit,[e=>$e];
    
Routable: | # look for routes in J (vie li, tractor?)
    # using pi to track remote pi
    # tables of stuff to match, could double the cv for the solution
    # route C could have sc.opel, a new path
    # have to T.com = 6 to skip 4/5ing the p here, which wont work
    # 
Doable: | # look for dos in hC (vie bo)
    my @doers = grep {_.sc.dos} @{e.c.hC};
    @doers || return G&vent,"Nodoing";
    @doers == 1 || #G&vent,"Manydoing" ,
        sayre "Manydoing: ".ki(e.c.hC)."   Have some: ".ki\@doers;
    my ($c) = @doers;
    1&&sayyl "dos e.t for c.sc.dos: ".ki$c;
    
    Rw c.sc.dos + $c;
    
sMJ: | # for Js&M map in
    my $M = Js&M ||= [];
    my $s = e&s;
    my $j;
    $j = ss&J if ref $s eq 'HASH';
    $j ||= A.2.3; # from sender's W
    
    ref $v eq 'CODE' || die "sMJ not code: ".ki Js&ein;
    $v->($s,$M,$J,$j,$e,$T,$C,$A);
    
sMt: | # for Js&Mt = W -> M map in
    my $s = e&s;
    my $j;
    $j = ss&J if ref $s eq 'HASH';
    $j ||= A.2.3; # from sender's W
    
    my $M = Js&Mt.>j.t ||= [];
    $v->($s,$M,$J,$j,$e,$T,$C);
ElvisDoolify: | # J webbed events
    my $t = Rw Towering Ang
        || return;
    
    # wants to magnetise tape observation for anything
    
    if (c&Se == 1) {
        # with developer changing ghost
        n Waytch
        
        t.e =
        n Dooli
        t.en->('sc lastK c s', "See tarps");
        t.e =
        n Dejo
        t.en->('sc lv,olv', "See Tape");
        
    }
Dooli: |
    u Zpace
    
    Jc&tape = 'Dejo';
    S
    n Fergus =>-imigis=>'eye/fug','%qz,qs'
    
    m 'Fergus'=>-tiss
    m _.t=>''=>\'helum',{tag=>'img',src=>_c&s} for G&op;
    
    y.lum = 2;
    y.thi = 20;
pi/imigis: |
    # /home/s/Music/Where Rivers And Mountains Sing mp3s/10 Borbangnadyr With Water.mp3
    c&only = 'image';
    my @imgs = Rw Exe;
    my $i = 3;
    n (/.+\/(.+?)$/)[0]=>'3'.$i++=>$_=>{pi=>'relim'} for @imgs;
    
    G&has,image=>0+@imgs;
pi/tiss: | # t is s
    c&s = C.t;
    delete s&J, delete s&pi ;

