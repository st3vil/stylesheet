
ElvuseZpace: | # check hosting con u Zpace, using ElvZpace not Zpace
    my $t = Rw Towering Ang
        || return;
    c&Se == 1 || return;
    
    if (0) {
        T.H = 5;
        t.e = 
        n ElvZpace
        t.cs->('sc top', "updated ElvZpace");
        exit;
    }
    
    u Zpacer=>''=><<'','%of:w'
        u ElvZpace
        m sone=>''=>wop
        m sone=>''=>wop
    
    t.e = 
    n Zpacer
    t.cs->('sc top', "See");
    my $W = t.ntos->(t.e,'J');
    t.dd->(W.sc.xo,'Zpacer xo, exc. u etc for now');
    my $mo = t.ntos->(t.e,'mo');
    is mo.c.pin, 'Zpacer', 'Zpacer did pin';
    
    T.H = 4;
    t.e = 
    n ElvZpace
    t.toc.slimvague = 1;
    t.cs->('sc top', "Seeu");
    t.cs->('sc ii mo,nonext', "mo");
    my $W = t.ntos->(t.e,'J');
    t.dd->(W.sc.xo,'thawed Zpacer xo');
    my $mo = t.ntos->(t.e,'mo');
    is mo.c.pin, undef, 'Zpace without pin';
    
    t.cs->('sc lv,olv', "lv not there yet");
    my $s = t.ntos->(t.e);
    is s.c.o, "Steved 1 1", "origin's id";
    
    T.H = 1;
    t.e = 
    n ElvZpace
    t.cs->('sc lv,olv', "lv looks freshly made");
    t.cs->('sc top', "top as usual");
    my $s = t.ntos->(t.e);
    is s.c.o, "Steved 1 1", "origin's id";
    my $W = t.ntos->(t.e,'J');
    t.dd->(W.sc.xo,'imparted Zpace xo');
    
    t.e = 
    n ElvZpace=>W=>{banana=>1}
    t.cs->('sc lv,olv', "lv with banana");
    t.cs->('sc top', "top with banana");
    is s.c.o, "Steved 1 2", "next id";
    my $W = t.ntos->(t.e,'J');
    t.dd->(W.sc.xo,'next imparted Zpace xo');
    
    t.e = 
    n ElvZpace=>W=>{banana=>1,mango=>2}
    t.cs->('sc lv,olv', "lv with mango");
    t.cs->('sc top', "top with mango");
    is s.c.o, "Steved 1 3", "next id";
    my $W = t.ntos->(t.e,'J');
    t.dd->(W.sc.xo,'next next imparted Zpace xo');
ElvZpace: | # not Zpace
    u alact
    n \'of:L'
    y.at.coil = 'tldo';
    
    c&banana &&
    Banana 5:
        2 + 3
    c&mango &&
    Mango 5: %of:mo
        2 + 3
    M 15: %of:mo,tldo:nogindex:y:L,vor:cM
        my $M = c&M;
        my $i = 0.1;
        my $inc = 0.8  / @$M;
        for (@$M) {
            n _.t=>$i=>_.c,_.sc
            $i += $inc;
        }
    
    # create L uC, the actuating
    # its y may be here if we are an atom within it
    L 1:
        (A&s) = @$s;
    a 1: %of:a
        (A&s) = @$s;
    
    # any gk of L to pull mo into an L (nogindex)
    M: %v:cM
        # etc
    n: %v:yn
        # to almost fill space
    spc: %v:yspc
        # to take up space
    u: %v:yu
        # to take space up til
    rev: %v:yspc
        # composite \d+ ? y.cyc : peels into y
    cyc: %v:ycyc
        # sweeping over itself, round and round
    erse: %v:yerse
        # flip n,u, stack floor to ceiling
    # so goes from ground to mind, instead of in to out
    # since we use y.in now for the first insider
    in 12: %v:yin,vatis:!ref
        C.y.n = delete C.y.in if !ref C.y.in;
    out 12: %v:yout,vatis:!ref
        C.y.u = delete C.y.out if !ref C.y.out
    
    L 2:
        return die "MdubL"
    
     # lum uC shapes curve, wants to be with limn
     # might mean a few lum qualities, make them switchupable
     # supposedly osc can measure itself, hoist geometry
     #    descriptions for ascii art buildings
    lum 23: %v:ylum
        return die "MdubL"
    
    # 3 the allocations, M start happening
    bal 3: %v:ybal
        return die "MdubL"
    # refit cv by t, spawn L per added pieces
    # to fit back into M above,
    refit 4: %v:yres
        return die "MdubL"
    # L fits curve
    barel 5: %v:cM
        return die "MdubL"
    
    # a eats space, sliding y.v.v along (Ya-Habibi)
    # spiral much space away from spine
    # build wave plot manifold, solar systems
    many 6: %of:a
        return die "MdubL"
    
    # feel effects of...
    res 7: %v:yres
        return die "MdubL"
    
    # t-rewirey formulae:
    lum 7: %v:ylum
        return die "MdubL"
    
    # ground into creation
    ground 8:
        return die "MdubL"
    

