Valve: | # Ilan's switch tree, heading to elvis sorted under opera
    Rw Tiot;
    y.at.bgh = '3824';
    Jc&tape = 'Dejo:curve:Junug';
    Js&Simp = 'Sweeptapes';
    Js&ein.t.C.sMJ = &sMJje{
        m s.t=>-lvf=>{s=>$s}
    };
    S
    if (my $not = delete Js&notif) {
        #n not=>11=>ki($not),'%fs:8,hs:000'
    }
    my $m = Js&M ||= [];
    for my $C (@$m) {
        if (c&pi eq 'lvf') {
            if (!s&seen) {
                s&file = G.c.bay."/t/".C.t;
                if (-f s&file) {
                    s&base = [map{djson$_} split"\n", read_file s&file];
                    c&forum = my $M = [];
                    m "t C.t"=>-tl=>{s=>$C}
                }
                s&seen = 1;
            }
        }
    }
    @$m = map { @{delete(_c&forum)||[]}, $_ } @$m;
    m $_ for @$m;
    y.cyc = 100;
    
pi/tl: | # test lvs
    y.at.dis = 2;
    n t=>1=>C.t,"%dis:2"
    y.at.dos = 'Continues';
    Js&ope || return
        n on=>12=>" and G.c.bay",'%hs:347,fs:7'
    
    if (Js&done++ ){
        S no
    }
    my @l = @{ss&base};
    my $z = sc&s; # -tl holds -lvf holds -plaz or so
    my @v = map { @{_s&lv} } @{zs&flv};
    #n dwko=>-pud=>{s=>[\@l,\@v]}
    #return;
    
    my $i = 0;
    while (1) {
        my ($l,$v) = ($l[$i],$v[$i]);
        last if !$l && !$v;
        # both Cs of the top level
        my $C = G&Ct,[$i=>''=>{}];
        my $c = G&A,o=>6,$C,$l,'compare' if $l;
        my $o = G&A,o=>6,$C,$v,'compare' if $v;
        if (!$v || @{oc&rsl||[]}) {
            my $ba = !$v ? "missing" : !$l ? "madeup" : "changed";
            $ba = "$i $ba" if $i;
            m no=>''=>"ss&file! $ba",'%hs:777'
            
            m good=>''=>join("\n",@{cc&rsl||[]}),'%fs:7,hs:340,dis'
            m bad=>''=>join("\n",@{oc&rsl||[]}),'%fs:7,hs:999,dis'
            undef $C
        }
        else {
            c&s = " correct";
        }
        $C &&
        m $C
    }
    continue {
        $i++;
    }
    
    
    
pi/lvf: |
    y.at.dis = 3;
    n t=>1=>C.t,"%dis:2"
    n flav=>-aims_12=>'ind-aC ind-aC-w/etc ind-ki o-rsl ind-Mpud'
    #n lvf=>-pud_2=>{dl=>1,s=>$s}
    y.n = 3;
    
    my $flv = ss&flv;
    my $i = 3;
    my @l;
    for my $f (@{ss&flv}) {
        my $lv = fs&lv;
        my ($li,$more) = (28);
        for my $C (@$lv) {
            push @l, $C;
            my $s;
            my $pi = '';
            my $m = Js&flav;
            if ($m <3) {
                my $y = &Cd{
                    $C = C.y.D;
                    $more++, return '' if $li-- < 1;
                    y.at.lh = 1.6 if $m == 1;
                    $m == 0 ?
                        G&aC,$C
                    : $m == 1 ?
                        G&aC,$C ."\t".ki $d
                    : $m == 2 ?
                        ki $C
                    : die "?"
                };
                $s = G&ind,$C,$y;
            }
            elsif ($m == 3) {
                my $o = G&A,o=>6,$J,$C,'producto';
                delete Js&jo.producto;
                $s = join"\n",@{oc&rsl};
            }
            elsif ($m == 4) {
                my @M = G&ind,$C;
                m _.t=>-pud=>{s=>$_},'%dis' for @M;
                undef $pi;
            }
            else {
                n no=>1=>"No flac $m"
            }
            defined $pi || next;
            $s =~ s/\s+$//s;
            my $h;
            $h .= "$1\n" while $s =~ s/\t([^\n]+)$//m;
            $h &&
            m flev=>$pi=>{s=>$h},"%hs:${i}467,hue:180,ab,ml:30%,mt:0.4,dis,sha:1 1 3 847,zi:-5"
            
            $s .= "\n... $more more" if $more;
            m flv=>$pi=>{s=>$s},"%hs:${i}46,dis,fs:7"
        }
        $i = 3 if $i++ > 8;
    }
    y.at.dos = &{
        my $f = s&file || die "nofile:C.t";
        write_file $f, join "\n", map{ sjson $_ } @l;
        push @{3s&notif||=[]}, "C.t saves";
        
    };
pi/aims: | # select a number
    my @pos = split ' ', $s;
    Js&clsc = A.2.sc;
    my $t = C.t;
    my $i = Js&clsc.>$t || 0;
    s&dos = &AC{
        $i += us&S ? -1 : 1;
        $i = @pos-1 if $i < 0;
        $i = 0 if $i > @pos-1;
        1 && sayyl "Claim to $t ".ki us&C;
        Js&clsc.>$t = $i;
    };
    n t=>1=>C.t=>'%fs:7'
    n col=>2=>':','%hs:489,fs:6'
    n s=>3=>$pos[$i]=>'%fs:8'
    
Player: |
    Rw Tiot;
    Js&Simp = 'Sweeptapes';
    Js&Cimp = 'Pause';
    Js&ein.t.play.sMJ = &sM{
        m $s=>-plalv
    };
    c&s = G.c.bay.'/t';
    S
    my @l = Rw Exe;
    m $_=>''=>{s=>$_}=>{dis=>3,dos=>"Fratil"} for @l;
    
    my $m = Js&M ||= [];
    @$m = G&Ct,[$l[0]=>-plalv] if @l == 1 && !@$m;
    
    for my $p (@$m) {
        @$M = grep { p.t ne _.t } @$M;
        # engage Sequines with our osc l
        Jc&sung.Sequines = 1;
        # but only if its not above us already
        delete Jc&sung.Sequines if A.2.t eq 'Sequines';
        m $p
    }
    
    
pi/plalv: |
    s&dis = 3;
    y.at.dis = 2;
    y.at.dos = 'Fratil';
    delete c&s;
    n t=>1=>C.t,'%hs:389';
    n a=>2=>"Play "
    -f $s || die "Notafile: $s";
    my $p = Js&plays ||= [map{djson$_} split"\n", read_file $s];
    my $i = Js&playi++;
    my $z = $p->[$i];
    if (my $n = $p->[$i+1]) {
        if (ns&plat) {
            s&plat = ns&plat;
            sayyl "C.t next plays at s&plat";
        }
    }
    else {
        s&done = 1;
    }
    
    n at=>23=>($i+1)."/".@$p,'%fs:6,hs:498'
    $z = [$z] if ref $z ne 'ARRAY';
    n z=>6=>{}=>{zout=>$z,dis=>3}
Sequines: | # never returns, plays Player
    my $x = Js&feed ||= {};
    Js&ein.t.seq.sMJ = &sMJ{
        $x.>s.t = $s;
    };
    S
    
    my $i;
    my $time = 0;
    my @next;
    while (1) {
        $i++ || next;
        # for x/t=top, Player if any plalv not s&done
        for (@next) {
            sayre "Playing $_";
            n $_
        }
        $i > 5 && return sayre "Runout";
    }
    continue {
        @next = ();
        my $next;
        each t,op $x {
            T.op = $op;
            my @ha = grep {!_s&done} G&op,'pi:plalv';
            map { $next = $_ if $_ < $next || !$next }
                grep {defined} map {_s&plat} @ha;
            saygr "As of $t (op.t): $next  x".@ha;
            push @next, $t if @ha;
        }
        return sayre "Done" if !@next;
        $next ||= 4;
        sleep $next;
        $time += $next;
    }
Fratil: |
    G&elph,J.t=>[play=>c.c.s];
    sayyl "Done to J.t the ".ki c.c.s;
pi/bay: |
    # the view
    y.at.dis = 2;
    s&dis = 3;
    y.at.ml = c&depth;
    n t=>1=>C.t,'%dis:2'
    if (-f $s) {
        n f=>2=>"-f",'%hs:048'
        n ti=>21=>{s=>"x".-s$s},'%fs:7,hs:487,dos:Continues'
        if (Js&ope > Js&bowls) {
            sayre "Isopen: $s";
            Js&bowls++;
            my $he = `head -n1 $s`;
            if ($he =~ /^---\s+/) {
                my $yam = LoadFile($s);
                G&give,Whats=>$s=>{how=>'yamlfile',s=>$yam}
                #n yaml=>-pud=>{s=>$yam,dl=>c&depth + 3}
                
            }
            else {
                n cont=>22=>{s=>slim(80,''.read_file($s))},'%fs:7,dis:2'
            }
        }
        return;
    }
    if (c&depth == 1) {
        my $void;
        $void = "pids" if C.t =~ /^(p)$/;
        $void && return 
            n void=>23=>" $void",'%hs:847'
    }
    my @im = Rw Exe;
    y.cyc = 100;
    y.n = 12;
    for (@im) {
        my $f = $1 if /^c&s\/(.+)$/ || die "Nof c&s in $_";
        m $f=>-bay=>{s=>$_,depth=>c&depth + 1}
    }

