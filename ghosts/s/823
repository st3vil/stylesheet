

Opera: | # put instructions together
    Rw Tiot;
    Rw Elationist;
    if (my $i = Jc&es) {
        my $p = G&Ct,[p=>i.c.s];
        
        #m Ghostig=>-comtu=>Ghostig
        G&give,Toter=>Operaselects=>$i;
    }
    #$i
    my @l = split "\n", <<'';
        Udder:DoSomi asap
        Udder:Calg
        DoSomi:ReSim
        Calg
        Calg:Dopud
    for my $l (@l) {
        my ($t,$c) = split ' ',$l;
        $c = G&peel,$c;
        m $t=>-comtu=>{%$c}
    }
pi/comtu: |
    y.at.dos = 'Continues';
    
    Js&ope ||= c&asap if c&asap;
    
    my ($to,$t) = split ':', C.t;
    $t ||= $to;
    if ($t ne $to) {
        $to &&
            n src=>12=>$to
        n pings=>13=>':','%hs:489,fs:6'
    }
    n t=>2=>$t
    
    Js&ope > Js&bowls || return;
    Js&bowls++;
    
    my $pid;
    if (!$to) {
        my $i = Jc&es || return
            n wha=>4=>"with?"=>"%hs:289"
        if (i.t eq 'p') {
            $pid = ic&s
        }
        else {
            die "send comptu to ".ki$i;
        }
    }
    my $d = G.c.bay."/p";
    if (!$pid) {
        $pid = readlink "$d/$to";
        G&always,J.sc,atpid=>$pid ||
            n pidchange=>1=>"pidchange",'%hs:666'
    }
    
    $pid || die "Continuing with no pid";
    $t || die "Contuinuing with no t";
    
    my $in = "$d/$pid/in";
    my $s = G&Ct,[$t=>'W'];
    sayyl "Writing $in For ".ki $s;
    write_file($in,{append=>1},sjson($s)."\n");
Fish: | # infinite plantulism
    Rw Tiot;
    # e receives a new G Ting
    # is their leader/his left-over intelligence
    # starts before everything, with the one thing to do
    # which is watch, scrub, and attract attention
    # dig in hole hath set me free
    
    # answer requests for its detail
    Js&ein.t.p = &TesCA{
        my $pid = e&s || c&e.c.s;
        1 && say "    Looking far $pid";
        my @fo = G&op,"pid:$pid";
        if (!@fo) {
            T.rep && return G&vent,"Stillno:pid:$pid";
            return T.pos = 3;
        }
        G&xo,e.sc,_.sc for $fo[0];
        T.pos = '';
    };
    S
    # toplevels 4t
    y.at.bg = '3484';
    c&s = G.c.bay.'/p';
    c&do = 'ls -1t';
    n for=>''=>c&s
    my @im = Rw Exe;
    my @pi = grep {-d && !-l} @im;
    my $tp;
    $tp.>$_ =1 for grep {-l} @im;
    
    m $_=>-proc for reverse @pi;
    
    for my $C (@$M) {
        my $s = c&s;
        my ($d,$p) = $s =~ /^(.+)\/p\/(\d+)$/;
        my $i = Js&ps.>$p ||= do {
            my $i = {};
            my $so = read_file("$s/so");
            my @lives = split ' ', $so;
            my $it = pop @lives;
            $so = join ' ', (map{/^(\d+)/}@lives), $it;
            i.so = $so;
            my ($num,$t) = split ':', $so;
            i.sot = $t;
            i.num = $num;
            if ($num =~ /^(.+) (\d+)$/) {
                if ($2) {
                    i.turnum.progress = "$1 ".($2-1);
                }
                i.turnum.future = $1;
            }
            $i
        };
        G&xo,C.sc,$i;
    }
    for my $l (@$M) {
        for my $C (@$M) {
            my $tu = s&turnum;
            each t,v $tu {
                next unless ls&num eq $v && ls&sot eq s&sot;

                s&hasnum.>ls&num = $l;
                G&xo,s&hasnum,ls&hasnum if ls&hasnum;
                _s&surp = C.t for values %{s&hasnum};
            }
        }
    }
    @$M = grep {!_s&surp || Js&opens.>_s&surp } @$M;
    #G&give,Toter=>sem=>[@{$M}[-3..-1]];
    
    sayyl "Fishes ... ";
    y.res = 100;
    #y.at.over = 'scroll';
    #y.at.dis = 1;
    #y.at.mh = '12';
    #n Twang
pi/proc: | # picture in picture rock
    my ($d,$p) = $s =~ /^(.+)\/p\/(\d+)$/;
    $p || return
        n err=>6=>"No pid: $p",'%hs:254'
    s&dis = 3;
    y.at.dos = 'Continues';
    
    
    
    Rw Thrext so $next_t:s&sot;
    n t=>1=>s&sot,'%hs:655,fs:15'
    n spc=>12=>' '
    
    n pid=>2=>$p,'%fs:7,hs:256'
    s&pid = $p;
    
    -e "/proc/$p" || return
        n gone=>2=>'*'=>'%hs:856'
    #n spc=>31=>' '
        
    
    my $pa = read_file("$s/pa");
    #n pa=>32=>{s=>$pa}=>'%hs:576'
    s&ppa = $pa;
    -e "$d/p/$pa" || return
        n gone=>322=>'?'=>'%hs:856'
    
    if (my $ns = !s&surp && s&hasnum) {
        my $bush = keys %$ns;
        n hasnum=>4=>" +".$bush,'%hs:247,fs:8,dos:Uncoverprocs';
    }
    
    Js&ope || return;
    
Uncoverprocs: |
    my $j = e&_hJ;
    Js&opens.>j.t = us&S ? 0 : 1;
    
Ilan: | # O's zip of U, W switchup
    # & tractor e into a new Udder
    y.res = 100;
    Jc&refit_t = &C{
        "s&so C.t"
    };
    Js&ein.t.f.sMJ = &sMJjeTCA{
        if ($s =~ m{(.+)/p/(\d+)/W/(\w+)\.(\d+)}) {
            my ($d,$p,$t,$i) = ($1,$2,$3,$4);
            my $in = Js&index ||= {};
            my $new;
            my $C = $in.>$t.>$p ||= do { $new++; {y=>{}} };
            C.t ||= $t;
            C.c.pi ||= 'plaz';
            s&pid = $p;
            
            # find so/pa for self
            s&so ||= do {
                my $p = G&Ct,[p=>''=>$p];
                G&elph,Fish=>[$p];
                s&ppa = ps&ppa;
                ps&so;
            };
    
            # continuing W with parent pid
            if (my $p = delete $in.>$t.>s&ppa ) {
                s&ie = ps&ie;
                @$M = map { $_ eq $p ? $C : $_ } @$M;
                $new = 0;
                if (my $hi = ps&history) {
                    @$M = grep { _c&s ne $hi } @$M
                }
                my $M = c&forum = [];
                s&history = $p;
                ps&future = $C;
                m "$t ps&so"=>-pold=>{s=>$p}
                Js&blab = 1;
            }
            # same W stage appears from next fork
            elsif (s&so =~ /^(.+)(\d+):/) {
                my ($tun,$ti) = ($1,$2);
                $ti--;
                if ($ti >= 0) {
                    my ($p) = grep { _s&so =~ /^$tun$ti:$t/ } @$M;
                    if ($p) {
                        my $t = "$t ps&so";
                        my $n = G&Ct,[$t=>-pold=>{s=>$p}];
                        @$M = grep { ps&progresses ne $_ } @$M;
                        ps&progress = $C;
                        s&progresses = $n;
                        @$M = map { $_ eq $p ? $n : $_ } @$M;
                        Js&blab = 1;
                    }
                }
            }
            
            Rw Rebase $C $d $p $t $i;
            
            return unless $new;
            
            # so takesover parent's t not insys
            #   spawning little differ above, as old self
            # 
            
            $new && push @$M, $C;
        }
        else {
            die "Other Ilan ting: $s";
        }
    };
    Rw Tiot;
    Jc&tape = 'Dejo';
    S
    my $m = Js&M||[];
    @$m = map { @{delete(_c&forum)||[]}, $_ } @$m;
    #delete Js&blab && 
    y.imp++; #G&give,Toter=>s=>[Could=>$m];
    m $_ for @$m;
pi/plaz: |
    s&dis = 3;
    y.at.dos = 'Continues';
    y.at.fs = 8;
    
    Rw Thrext so $next_t=C.t;
    
    n t=>2=>C.t=>'%hs:555,fs:18'
    
    s&ie &&
    n ie=>22=>{s=>".s&ie"},'%fs:12,hs:258'
    
    n sh=>31=>{s=>"o"},'%dos:tiestow'
    
    
    my @once = @{s&zin};
    @{s&zin} = ();
    Js&ison ||= 3;
    my $sc;
    sc.dis = Js&ope >= 0 ? 3 : 0;
    sc.zout = \@once if @once;
    n z=>89=>{}=>$sc
pi/pold: |
    s&dis = 3;
    my $t = s.t || C.t;
    s&so = ss&so;
    y.at.dos = 'Retrieve';
    y.at.fs = 7;
    
    Rw Thrext so $next_t:t;
    
    n t=>2=>$t=>'%hs:555,fs:16'
    
    if (my $C = c&s) {
        s&ie &&
        n ie=>22=>{s=>".s&ie"},'%fs:12,hs:258'
    }
    
    my $symb = "?";
    if (ss&progress) {
        # to another self
        # TODO fork testing
        $symb = ",";
    }
    if (ss&future) {
        # to a future
        $symb = ".";
    }
    n conti=>28=>$symb,'%fs:26'
    
    
Store: | # cops W (dos)
    G&give,Toter=>'storesitch'=>$e;
Retrieve: | # resurrect a point
    if ( us&S ) {
        my $j = e&_hJ;
        my $m = 3s&M;
        # $_ is source C of J
        my $o = ["j.t: ", map { G&aC,$_ } @$m];
        @$m = grep {_.t ne j.t} @$m;
    }
    else {
        my $j = e&hJ;
        G&give,Toter=>'resurref'=>$j;
    }
    
    
DoSomi: | # decor
    Jc&tape = 'Dejo';
    thing:
        is
    n eo=>2=>"s $0",'%hs:774'
    m $_ for @{c&ex||[]};
ReSim: | # DoSomi amp
    my $M = [];
    m Tangle=>3=>Twangiola
    m Tungle=>4=>Topova
    n DoSomi=>W=>{ex=>$M};
    n Not=>1=>I
Chunkfall: | # image list
    n ElTarfigure
    m _.t=>''=>_c&s for G&op,'spi:=relim'
    
Calg: | # lum spin cycle
    Jc&tape = 'Dejo';
    
    n Chunkfall
            for (G&op,'t:~^[tT]' ) {
                m _.t=>{thy=>0.5}=>_c&s=>''
            }
            J.bowls < 5 && shift @$M for 1..J.bowls;
            for (@$M) {
                (_s&tag,_s&src) = ('img',delete(_c&s));
                _c&helum = 1.1;
            }            
            y.lum = 2 + 3 * J.bowls++ || return;
            J.bowls < 5 &&
            n do=>1=>"Fosci J.bowls\n",'%hs:345,fs:'.(5 * J.bowls)
            y.at.lumwas = y.lum;
            my $b = J.bowls;
            y.thi = 22 - $b * 3;
            y.thi *= -1 if y.thi < 1;
            y.thi = 2 if y.thi < 1;
            y.in = 3 - $b * 0.4;
            y.out = 6 + $b * 0.445;
            J.bowls = J.bowls - 10 if J.bowls > 12;
            y.at.ws = 3;
            y.imp++ ;#if J.bowls =
    
Dopud: | # show graphs
    n Calg=>V
    my @m = G&op;
    my $v = [$J,$v];
    G&give,Toter=>s=>$v;
Continues: | # reactiona
    my $p = e&_hJ;
    ps&ope += us&S ? -1 : 1;
    saygr G&sn,$p ,"p.t continues to ps&ope";
Forsys: | # to
    my $v = e&_hC;
    my $p = vs&pid || die "No pid on ".ki$c;
    G&give,Opera=>p=>$p;
GhosMe: | # for ghoster ups
    n Waytch
    5s&desi = "Ghoster";
    

