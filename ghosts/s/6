ImCom: | # ing
    T is your mess with the mind/world throughput
    ^ you are here, left is mind, right is world
    or up (at ElM) down (on Os)
    Os gather wormholes for reconvenience to ElM summers
    
    ghost host, telling ElMs of any change
    
    the inconceivables go in 5 (S, T)
    around them on the of are go implementors, skips
    
    D 9-99 can mess with outgoing K deletes with a valve
    
    
    
JugleHue: |
    my $h = 0;
    my $d = 15;
    for (@$M) {
        _s&hue = $h += $d;
        _s&deal = 0.014;
    }
ElPassTape: | # Jc&elvis sends e=s oscillations
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    
    if (c&Se == 1) {
        u Zpace
        u FeelTapey=>'',<<'','%of:w'
            u Zpace
            u PaintedStripes
            Jc&elvis = 'ElvisTape';
            
            map {
                m feo=>''=>"Soe J.bowls $_",'%hs:349,bgh:843'
            } 1..(3 + J.bowls);
            
            map {
                my $zc = G&Ct,[cod=>1=>''=>'%cod,con:3,dige:485859'];
                zc.c.s = "JBowls-J.bowls";
                _s&z = [$zc];
            } @$M;
            
            J.bowls++;
            y.lum = 8 * J.bowls++ || return;
            y.at.lumwas = y.lum;
            y.imp++ if J.bowls == 6; # reset lv
        
        t.e =
        n FeelTapey
        t.cs->('sc lastK c s', "See");
        my $seeit = sub {
            my $W = t.ntos->(t.e,'J');
            t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s,time=>6,nopre=>1});
            sleep 1;
        };
        #$seeit->();
        t.e =
        n FeelTapey
        t.cs->('sc lastK c s', "See again");
        #$seeit->();
        t.e =
        n FeelTapey
        t.cs->('sc lastK c s', "See third, imp reset");
        t.xo->("Has xo");
        
        t.e =
        n ElvisTape
        my $J = t.ntos->(t.e,'J');
        #G.ouJ = $J;
        {
          local t.toc.unslim = 1;
          t.cs->('sc lv,olv', "Aggregate it all");
        } 
        t.cs->('sc top', "top sees only tops of pis");
        t.cs->('sc lastK c s', "shlop");
    }
ElvisTape: |
    u Zpace
    Js&ein.t.s = 'EatsTriangle';
    S v
    saygr <<'' .'     '.J.t;
        |\
        | \
        ---
    
    push @$M, @{Js&M||=[]};
    y.ttl = 1000;
    # have have the tw in another unity that can be included to W search
    # but not having .ii itself
    # Tendon room, scuttle
EatsTriangle: |
    my $s = e&s;
    sayyl "Given: s.c.o";
    my $M = Js&M ||= [];
    my $j = ss&J || ss&lastA.1 || die "no es J";
    
    m j.t=>-TapeRack=>{s=>$s}
    # add to hoisting of moment of lv
    # wants to compress or not unique G-s
    T.oke = 1;
pi/TapeRack: |
    S no
    n instant =>1=> 4s&inst
    
    my $se = s.sc.top || return
        n 'no top'=>-pre
    
    my $o = G&A,o=>6=>$J=>$se,'wellbeing';
    n or =>2=>join("\n", @{oc&rsl})
    
    y.at.talk = "sc top @ sc&o";
    
EliPticMany: |
    #
ModNs: | # modulate M/N/etc with way, s=$way(:$s_arg)?
    my $z = $s =~ s/:(.+)// ? $1 : '';
    Rw $s + $s:z;
nogindex: |
    my ($nk,$of) = split ':', $s;
    $nk && $of || die "not nk:of: $s";
    my $i = s&nogindex = {};
    for (@$N) {
        _s&nk eq $nk && _s&of eq $of && _s&gk || next;
        $i.>_s&gk = _s&vatis || 1;
    }
    s&t && die "Receiver has nogint already: ".ki $C;
    s&t = 1;
    my $p = s&ip = {};
    p.y.hasany = $i;
    if (s&vor) {
        my $r = $p.>s&vor = {};
        (r.nk,r.gk) = G&pang,s&vor;
        r.exi = 1; # exists
        p.y.or = 1;
        p.order = [s&vor,'y'];
    }
Zpace: | # hang La space charts off mo
    u alact
    n \'of:L'
    y.at.coil = 'tldo';
    
    # fix Zuup re something
    
    # A.3 pools lists up from c.y.A.1 pi etc.
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
        # oir rhythm style joins
    # ^ always wants a new one somewhere
        # 4d jelly slower-downer
            # TRansituio, soul spread
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
    
    # plumb moment
    # or any that nogy things
    M 16: %of:mo,tldo:nogindex:y:L,vor:cM
        return if C.y.a; # already placed
        return if C.y.L; # already placing
        my $M = c&M;
        if (A.V) {
            sayre "C.t manies!: ".(exists c&M)."  ".ki $M;
            my $D = T.D;
            my $ybrow = Ds&nogindex;
            my @ym = grep{C.y.>$_ } keys %$ybrow;
            1 && sayyl "Neg: C.t y: ".join',',@ym;
            1 && saybl "noym: ".wdump 2, [C.c,C.y] if !@ym;
        }
        C.y.L = G&A,L=>8,$C
    
    0 && # ground descript, floating tool
    J 69: %of:mo,v:sJ
        local A.V = 1;
        sayyl "HAve ".ki $C;
        saybl wdump 2, J.sc.root.c.s;
        my $uz = G&grind,$J;
        my $grimd = sub { 
            my $uz = shift;
            [map{my$c=_.c.s;"_.t _.cv: c.t c.y.cv ("
                .join(' ',sort keys %{c.c}).")  "
                .join(' ',sort keys %{c.sc})
            } map {$uz.>$_ } sort keys %$uz];
        };
        my $l = $grimd->($uz);
        push @$l, "For J.t";
        saybl @$l;
        
    # create L uC, the actuating
    # its y may be here if we are an atom within it
    L 1:
        (A&s) = @$s;
    a 1: %of:a
        (A&s) = @$s;
    
    # any gk of L to pull mo into an L (nogindex)
    M: %v:cM
        # etc
    n: %v:yn
        # to almost fill space
    spc: %v:yspc
        # to take up space
    u: %v:yu
        # to take space up til
    
    # so goes from ground to mind, instead of in to out
    # since we use y.in now for the first insider
    in 12: %v:yin,vatis:!ref
        C.y.n = delete C.y.in if !ref C.y.in;
    out 12: %v:yout,vatis:!ref
        C.y.u = delete C.y.out if !ref C.y.out
    
    #c a space to fill
    # if !M:
    #   y.in/out give it that much space & make holes in 1s&root's M
    #   y.thi that many C
    # 
    # L plots M as a, which may know more L/a around
    # C->root.c.M masses for piping parallel pi
    # sync around mo, can hang on/replot with 
    L 2:
        A&y && die "You Ay L 2";
        A.1.c.s || die "J has no mo C: ".G&sn;
        #local A.V = 1;
        # mo C that began the J we are now inside is the trick
        # we are probably at 17 of their root mo, which has c&M
        my $Jy = 1Cy&C;
        my $y = C.y;
        my $M = c&M;
        
        # some L uC spawns the A nC lattice
        # what to do with the L uC?
        if ($M) {
            # has M
            # L uC can be forgotten, probably mo'd with root in J6
            # it could be placement metadata/unity
            my @M;
            while (y.thi && @$M < y.thi) { # copies out to there
                @M = @$M if !@M;
                last if !@M;
                push @$M, G&hup,shift@M;
            }
        }
        else {
            # is first in its own M
            # to make holes in space other M must flow around
            c&M = $M = [$C];
            y.thi > 1 &&
                   push @$M, map { G&hup,$C } 1 .. y.thi - 1;
        }
        
        # limits apply, thi being for ^ iterator length 
        #                          and v limit of output
        my $lims = {};
        lims.thi = y.thi if defined y.thi;
        lims.limn = int(9 * y.limn * Jy.spc)
            if y.limn && (Jy.spc || die "No space! J.t");
        my $lim;
        while (my ($k,$v) = each %$lims) {
            @$M > $v || next;
            say "Limof: $k $v to C.t";
            $lim = $k if !$lim || $lims.>$lim > $lims.>$k;
        }
        if ($lim) {
            my $it = $lims.>$lim;
            my $from = 0;
            if (y.tail) {
                $from = -1;
                $it *= -1;
            }
            else {
                $it -= 1;
            }
            $lims = $lim; # name
            $lim = @$M; # limited from
            @$M = @{$M}[$from .. $it];
        }
        
        A.V = 0;
        y.thi = @$M;
        y.thi || die "No M: ".ki $C;
        #c & point/seek to things coming in with our surrounds
        
        # if we were placed with enough room
        # let atoms slide up to the top J
        # things saying they're in both places
        #   leads to nice grouping, ref integrity
        y.J = A.3 if Jy.spc > 0.1;
        delete y.J if y.clos;
        my $clos = Jy.spc && !y.J;
        #  they can want to be inside too
        #  geo to chain together floating/not atoms
        #  so its like wires over machines
        
        # ml (margin-left)
        # high lum makes tree bends up towards margin
        # like it is open inside, like bet. rummager.
        y.inde = Jy.inde + 0.06 if y.J;
        
        # sliver of attention
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        # carpenting
        y.n ||= $clos ? 0.3 : Jy.J ? Jy.cv + $sl : 0.1;
        y.u ||= $clos ? 0.4 : Jy.J ? Jy.ov - $sl : 0.9;
        
        # set width
        y.u = y.n + y.space if defined y.space;
        # may be way less than 0...
        # a cv scaled back, will have defiantly huge spc
        y.u /= 10 until y.u < 1;
        y.n /= 10 until y.n < 1;
        # corner noted
        if ($lim) {
            my $s = "$lim>".@$M;
            my $cv = y.tail ? y.n : y.u;
            # TODO += here blows up zopul:
            $cv -= 0.002;
            my $M = A&XM ||= []; # labely meta
            m lim=>$cv,$s,'%fs:7,hs:7487,limit:'.$lims;
        }
        # fit in multiple of
        if (my $ert = y.ert) {
            $ert += y.ert while y.thi > $ert;
            y.thi = $ert;
        }
        if (y.ttl) {
            # guess we'll hold 1 per second
            y.thi = y.ttl;
            # TODO decommission limited
        }
        y.space = y.u - y.n;
        my $outer;
        if (y.res) {
            $outer = y.space / y.thi;
            y.space -= $outer;
        }
        y.space *= -1 if y.space < 0;
        y.v.v = y.n; # rolls
        y.v.v += $outer / 2 if $outer; #
        # average size
        y.v.aspace = G&roun,y.space/y.thi;
        # thy -> mu bends out
        y.v.Ly = $y; # u is shared placevolve meta
        my $i;
        for (@$M) {
            _.y.v = y.v;
            _.y.i = $i++;
            _.y.a = G&tugA,a=>2=>$_;
            _.y.a.L = $A;
        }
        # L can M the C also in a
    
     #c lum uC shapes curve, wants to be with limn
     # might mean a few lum qualities, make them switchupable
     # supposedly osc can measure itself, hoist geometry
     #    descriptions for ascii art buildings
    lum 23: %v:ylum
        my $M = c&M || die "lum no M";
        my $y = C.y;
        my $u;
        (u.l,u.r) = split ',', $lum;
        $u.>$_ = do {
            $u.>$_ =~ m/^(?:(\d+)-)??(?:(\d+))(?:-(\d)+)?$/
                || die "notunder: $_ ".wdump 2, $u;
            {i=>$1,u=>$2,o=>$3}
        } for grep {$u.>$_ } keys %$u;
        u.l.u ||= 3;
        u.r.u ||= u.l.u / 4;
        u.l.o ||= u.r.u / 3;
        my $i = 0;
        for (@$M) {
            _.y.thy = 1 if !defined y.thy;
            _.y.thy += u.l.u;
            $i++;
            if ($i > u.l.o) {
                u.l.u -= 2 if u.l.u > 0.1;
            }
        }
    
    # 3 the allocations, M start happening
    bal 3: %v:ybal
        my $M = c&M;
        Rw ModNs $M $s:bal;
    #c refit cv by t, spawn L per added pieces
    # to fit back into M above,
    refit 4: %v:yres
        #local A.V = 2;
        my $y = C.y;
        my $M = c&M || die "refit no M";
        y.res == 2 && return
            saygr "A.1.t fits ".@$M." into C.t";
        my $res = y.res = 1s&res.>C.t ||= {res=>$res};
        my $ctv = res.ctv ||= {};
        my $la; # known from
        my @news;
        my $bend = sub {
            my ($from,$to,@M) = @_;
            @M = map {
                _.y.a || die "has no ya: ".ki$_;
                _.y.a.c.s eq $_ || die "ya cs not _: ".ki[_.y.a.c.s,$_];
                # their a C becomes for cv/spc for real heighting etc
                _.y.realy = _.y.a.c.s = G&hup,_.y.a.c.s;
                # takeover original ref:
                $_
            } @M;
            my $nu = G&Ct,["Bend$from->$to",{}];
            nu.y.n = $from;
            nu.y.u = $to;
            nu.y.res = 2; # makes spc/2 away from edges but not M<>ctv
            nu.c.M = \@M;
            nu.c.oM = [];
            # ^ our ground splices this L's stuff into $M
            # as it is A.y=A in an M of C
            G&tugA,L=>4,$nu;
        };
        return keys %$ctv &&
            saygr "All new refit C.t C.y.res -- ".G&sn
            unless grep{ $ctv.>_.t } @$M;
        my @M;
        for (@$M) {
            my $at = $ctv.>_.t;
            if ($at && !_.c.refit) {
                sayyl "Have _.t  -> $at";
                if ($la && $at < $la) {
                    # has to opt out for M order via c&refit
                    # la cause may have moved out already
                    saybl " is from earlier";
                }
                _.y.cv = $at;
                push @M, $_;
                if (@news) {
                    # bend @news between $la and $_
                    $la ||= y.n;
                    saygr "Bend from $la to $at:\n".ki \@news;
                    push @M,
                        $bend->($la,$at,@news);
                    @news = ();
                }
                $la = $at;
            }
            else {
                saybl "New _.t".(_.c.refit && " (repo)");
                push @news, $_;
            }
        }
        $bend->($la,y.u,@news) if @news;
    
    #c L fits curve
    barel 5: %v:cM
        my $y = C.y;
        my $total = sum(map{ _.y.thy || 1 } @$M) || 1;
        y.v.muav = @$M / $total;
    
    # a eats space, sliding y.v.v along (Ya-Habibi)
    # spiral much space away from spine
    # build wave plot manifold, solar systems
    many 6: %of:a
        my $y = C.y;
        y.mu = defined y.thy ? y.thy : 1;
        y.mu = y.mu * y.v.muav if y.v.muav;
        my $was = y.v.v;
        y.cv = G&roun,y.v.v if !y.cv;
        y.pcv = G&roun,y.i/y.v.Ly.thi;
        my $in = y.v.aspace * y.mu;
        y.v.v += $in;
        y.ov = G&roun,y.v.v;
        y.spc = y.ov - y.cv;

        C.sc.yspc = y.spc if C.sc.nspc;
        C.sc.ml = (y.v.Ly.inde * 40)."%" if y.v.Ly.inde;
    
    res 7: %v:yres
        ref $res || return;
        my $y = C.y;
        my $M = c&M;
        my $ctv = res.ctv;
        for (@$M) {
            $ctv.>_.t && delete $ctv.>_.t;
            $ctv.>_.t = _.y.cv || die "No cv res yet: ".ki$_;
        }
    
    # feel effects of...
    # t-rewirey formulae:
    lum 7: %v:ylum
        my $M = c&M || die "lum no M";
        for my $C (@$M) {
            my $y = C.y;
            my $upt = 0;
            y.spc = 0.01 if y.spc < 0.01;
            my $fs = y.spc * 20 * 4;
            if (c&helum) {
                s&he = G&rou,$fs/c&helum;
            }
            else {
                $fs = 3 if $fs < 3;
                s&fs = G&rou,$fs;
            }
        }
    
    # ground the creation
    ground 8:
        my $M = c&M || die "L 8 with no M: ".ki$C;
        my $y = C.y;
        # first was ourself that is already in mo
        shift @$M if $M->[0] eq $C;
        my $J = y.J || A.1;
        A&XM && push @$M, @{A&XM}; # labely meta
        # resolve any L in M to its many
        @$M = map {
            my $oM = _.y eq $_ && (_.c.s.c.oM || die
                "NoM on inner _.t from C.t: ".ki _c&s );
            $oM ? @$oM : $_
        } @$M;
        # stash out many for the above
        c&oM && return push @{c&oM}, @$M;
        if (A.V) {
            1 && sayyl "For J.t: ";
            1 && saygr "_.t: ".ki _.y for @$M;
        }
        
        Rw ModNs $M $s:y.mod if y.mod;
        
        G&A,n=>8=>$J,@$M;
    

