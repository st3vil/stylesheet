ElvisMany: | # J m C # candidate for moving C جستجو
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    
    # add many S pages
    if (c&Se == 1 && 0) {
        t.e =
        n Softu
        t.en->('sc lastK c s', 'caches u');
    }
    if (c&Se == 5) {
        
        t.e =
        n Zpace
        t.en->('sc lastK c s', 'has Zpace');
        my $W = t.ntos->(t.e,'J');
        saybl wdump 3, W.sc.ii.mo.y.tw.M.sc.ip;
        exit;
    }

    if (c&Se == 1) {
        t.e =
        n HasMany
        t.en->('sc lastK c s', 'put couple of things');
        my $W = t.ntos->(t.e,'J');
        #saybl wdump 3, W.ii.mo.y.tw;
        #t.cs->('sc lastK c s', 'they have stuff');
        t.e =
        n HasMany
        t.en->('sc lastK c s', 'few things, large Dozer');
        t.en->('sc top', 'few things, large Dozer top');
        
        t.e =
        n HasMany
        t.en->('sc top', 'few things, small Dozer');
        
        t.e =
        n HasMany
        t.en->('sc top', 'same thing multi Joy!');
        
        t.e =
        n HasMany
        t.en->('sc top', 'same thing multi!');
    }
        
    # yeah
HasMany: |
    u Zpace
    my $n = J.bowls++;
    if ($n == 0) {
        y.in = 3;
        m Zpacer=>''=>"Blow"
        m Dooz=>''=>"Wind"
    }
    if ($n == 1) {
        y.in = 22;
        m Zpacer=>''=>"Blow"
        m Dozer=>{thy=>1.4}=>"Thrill"
        m Dooz=>''=>"Wind"
    }
    if ($n == 2) {
        m Zpacer=>''=>"Blow"
        m Dozer=>{thy=>0.2}=>"Thrill"
        m Dooz=>''=>"Wind"
        y.out = 5;
    }
    if ($n == 3) {
        n joy=>'1..3x7'=>'Joy'
    }
    if ($n == 3) {
        n joy=>'1..3x7'=>'Joy'
    }
nogindex: |
    my ($nk,$of) = split ':', $s;
    $nk && $of || die "not nk:of: $s";
    my $i = s&nogindex = {};
    for (@$N) {
        _s&nk eq $nk && _s&of eq $of && _s&gk || next;
        $i.>_s&gk = _s&vatis || 1;
    }
    s&t && die "Receiver has nogint already: ".ki $C;
    s&t = 1;
    my $p = s&ip = {};
    p.y.hasany = $i;
    if (s&vor) {
        my $r = $p.>s&vor = {};
        (r.nk,r.gk) = G&pang,s&vor;
        r.exi = 1; # exists
        p.y.or = 1;
        p.order = [s&vor,'y'];
    }
Zpace: | # hang La space charts off mo
    u alact
    n \'of:L'
    y.at.coil = 'tldo';
    
    # fix Zuup re something
    
    # A.3 pools lists up from c.y.A.1 pi etc.
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
        # oir rhythm style joins
    # ^ always wants a new one somewhere
        # 4d jelly slower-downer
            # TRansituio, soul spread
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
    
    # plumb moment
    # or any that nogy things
    M 16: %of:mo,tldo:nogindex:y:L,vor:cM
        return if C.y.a; # already placed
        return if C.y.L; # already placing
        my $M = c&M;
        if (A.V) {
            sayre "C.t manies!: ".(exists c&M)."  ".ki $M;
            my $D = T.D;
            my $ybrow = Ds&nogindex;
            my @ym = grep{C.y.>$_ } keys %$ybrow;
            1 && sayyl "Neg: C.t y: ".join',',@ym;
            1 && saybl "noym: ".wdump 2, [C.c,C.y] if !@ym;
        }
        C.y.L = G&A,L=>8,$C
    
    0 &&
    J 69: %of:mo,v:sJ
        local A.V = 1;
        sayyl "HAve ".ki $C;
        saybl wdump 2, J.sc.root.c.s;
        my $uz = G&grind,$J;
        my $grimd = sub { 
            my $uz = shift;
            [map{my$c=_.c.s;"_.t _.cv: c.t c.y.cv ("
                .join(' ',sort keys %{c.c}).")  "
                .join(' ',sort keys %{c.sc})
            } map {$uz.>$_ } sort keys %$uz];
        };
        my $l = $grimd->($uz);
        push @$l, "For J.t";
        saybl @$l;
        
    # create L uC, the actuating
    # its y may be here if we are an atom within it
    L 1:
        (A&s) = @$s;
    a 1: %of:a
        (A&s) = @$s;
    
    
    # any gk of L to pull mo into an L (nogindex)
    n: %v:yn
        # to almost fill space
    spc: %v:yspc
        # to take up space
    u: %v:yu
        # to take space up til
    
    # so goes from ground to mind, instead of in to out
    # since we use y.in now for the first insider
    in 12: %v:yin,vatis:!ref
        C.y.n = delete C.y.in if !ref C.y.in;
    out 12: %v:yout,vatis:!ref
        C.y.u = delete C.y.out if !ref C.y.out
    
    #c a space to fill
    # if !M:
    #   y.in/out give it that much space & make holes in 1s&root's M
    #   y.thi that many C
    # 
    # L plots M as a, which may know more L/a around
    # C->root.c.M masses for piping parallel pi
    # sync around mo, can hang on/replot with 
    L 2:
        A&y && die "You Ay L 2, should TZ3";
        A.1.C || die "J has no mo C: ".G&sn;
        my $Jy = A.1.C.y;
        my $y = C.y;
        my $M = c&M;
        # some L uC spawns the A nC lattice
        # what to do with the L uC?
        if ($M) {
            # has M
            # L uC can be forgotten, probably mo'd with root in J6
            # it could be placement metadata/unity
        }
        else {
            # is first in its own M
            # to make holes in space other M must flow around
            A&M = $M = [$C];
            y.thi > 1 &&
                   push @$M, map { G&hup,$C } 1..y.thi;
        }
        y.thi = @$M;
        y.thi || die "No M: ".ki $C;
        # & point/seek to things coming in
        
        # if we were placed with enough room
        # let atoms slide up to the top J
        # things saying they're in both places
        #   leads to nice grouping, ref integrity
        y.J = A.3 if Jy.spc > 0.1;
        delete y.J if y.clos;
        my $clos = Jy.spc && !y.J;
        #  they can want to be inside too
        #  geo to chain together floating/not atoms
        #  so its like wires over machines
        
        # ml (margin-left)
        # high lum makes tree bends up towards margin
        # like it is open inside, like bet. rummager.
        y.inde = Jy.inde + 0.06 if y.J;
        
        # sliver of attention
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        # carpenting
        y.n ||= $clos ? 0.3 : Jy.cv ? Jy.cv + $sl : 0.1;
        y.u ||= $clos ? 0.4 : Jy.ov ? Jy.ov - $sl : 0.9;
        # set width
        y.u = y.n + y.space if defined y.space;
        y.u /= 10 until y.u < 1;
        y.n /= 10 until y.n < 1;
        # fit in multiple of
        if (my $ert = y.ert) {
            $ert += y.ert while y.thi > $ert;
            y.thi = $ert;
        }
        y.space = y.u - y.n;
        y.space *= -1 if y.space < 0;
        # average size
        y.v.aspace = G&roun,y.space/y.thi;
        # thy -> mu bends out
        y.v.y = $y; # u is shared placevolve meta
        y.v.v = y.n; # rolls
        my $i;
        for (@$M) {
            _.y.v = y.v;
            _.y.i = $i++;
            _.y.a = G&tugA,a=>2=>$_;
            _.y.a.L = $A;
        }
        # all ying applies now to M
        # tugging M
    
     #c uC shapes curve, wants to be with limn
     # might mean a few lum qualities, make them switchupable
     # supposedly osc can measure itself, hoist geometry
     #    descriptions for ascii art buildings
    lum 23: %v:ylum
        die "Inlum";
        my $M = c&M || die "lum no M";
        my $y = C.y;
        my $um;
        (um.l,um.r) = split ',', $lum;
        for (grep{defined $um->{$_}} keys %$um) {
            $um->{$_} =~ /^(?:(\d+)-)??(?:(\d)+)(?:-(\d)+)?$/
                || die "notunder: ".wdump 2, $um;
            $um->{$_} = {i=>$1,um=>$2,o=>$3};
        }
        1 && saybl "Lum C.t: ". wdump 2, $um;
        
        um.l.um ||= 3;
        my $lumhalvesby = (um.l.um / 2) / (um.r.um || 3);
        my $i = 0;
        for (@$M) {
            _.y.thy = 1 if !defined y.thy;
            _.y.thy+=um.l.um;
            $i++;
            if ($i > um.l.o) {
                um.l.um -= $lumhalvesby if um.l.um > 0.1;
            }
        }
    
    # 3 the allocations, M start happening
    # uC fits curve
    barel 5: %v:cM
        my $y = C.y;
        my $total = sum(map{ _.y.thy || 1 } @$M) || 1;
        y.v.muav = @$M / $total;
    
    # could spiral much space away from spine
    # build wave plot manifold, solar systems
    many 6: %of:a
        my $y = C.y;
        y.mu = defined y.thy ? y.thy : 1;
        y.mu = y.mu * y.v.muav if y.v.muav;
        my $was = y.v.v;
        y.cv = G&roun,y.v.v;
        y.pcv = G&roun,y.i/y.v.y.thi;
        my $in = y.v.aspace * y.mu;
        y.v.v += $in;
        y.ov = G&roun,y.v.v;
        y.spc = y.ov - y.cv;

        C.sc.yspc = y.spc if C.sc.nspc;
        C.sc.ml = (y.v.y.inde * 40)."%" if y.v.y.inde;
    
    # feel effects of...
    # t-rewirey formulae:
    lum 7: %of:a,v:ylum
        my $y = C.y;
        my $upt = 0;
        y.spc = 0.1 if y.spc < 0.1;
        my $fs = y.spc * 20 * 4;
        s&fs = $fs if $fs < 9;
    
    # ground the creation
    ground 8:
        my $M = A&M || c&M || die "L 8 with no M: ".ki$C;
        my $y = C.y;
        shift @$M if $M->[0] eq $C;
        my $J = y.J || A.1;
        if (A.V) {
            1 && sayyl "For J.t: ";
            1 && saygr "_.t: ".ki _.y for @$M;
        }
        G&A,n=>8=>$J,@$M;
    

