ImCom: | # ing
    T is your mess with the mind/world throughput
    ^ you are here, left is mind, right is world
    or up (at ElM) down (on Os)
    Os gather wormholes for reconvenience to ElM summers
    
    ghost host, telling ElMs of any change
    
    the inconceivables go in 5 (S, T)
    around them on the of are go implementors, skips
    
    D 9-99 can mess with outgoing K deletes with a valve
    
    
    
JugleHue: | # y.mod for dealing out and colouration
    my $h = 0;
    my $d = 15;
    for (@$M) {
        _s&hue = $h += $d;
        _s&deal = 0.014;
    }
ModNs: | # modulate M/N/etc with way, s=$way(:$s_arg)?
    if (ref $s eq 'CODE') {
        $s->($M);
    }
    else {
        my $z = $s =~ s/:(.+)// ? $1 : '';
        Rw $s + $s:z;
    }
nogindex: |
    my ($nk,$of) = split ':', $s;
    $nk && $of || die "not nk:of: $s";
    # reuses refs if they look the same:
    my ($tr,$i,$p) = G&superindex,'nogindex','ip';
    
    for (@$N) {
        _s&nk eq $nk && _s&of eq $of && _s&gk || next;
        $i.>_s&gk = _s&vatis || 1;
    }
    
    s&t = 1; # throat connected, if
    
    p.y.hasany = $i;
    if (s&vor) {
        my $r = $p.>s&vor = {};
        (r.nk,r.gk) = G&pang,s&vor;
        r.exi = 1; # exists
        p.y.or = 1;
        p.order = [s&vor,'y'];
    }
    
    $tr->();
ElvisZpace: | # T u Zpace fast, caching its s 76-
    # see also ElvuseZpace for checking thinking around here
    my $t = Rw Towering Ang
        || return;
    c&Se == 1 || return;
    
    T.H = 3;
    T.H = 5 if T.ray;
    t.e = 
    n Zpace
    t.cs->('sc top', "See");
    
Zpace: | # hang La space charts off mo
    u alact
    n \'of:L'
    y.at.coil = 'tldo';
    
    # fix Zuup re something
    
    # A.3 pools lists up from c.y.A.1 pi etc.
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
        # oir rhythm style joins
    # ^ always wants a new one somewhere
        # 4d jelly slower-downer
            # TRansituio, soul spread
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
    
    # plumb moment of cM-any
    # or any that nogy things
    M 15: %of:mo,tldo:nogindex:y:L,vor:cM
        return if C.y.a; # already placed
        return die "MdubL" if C.y.L; # already placing
        return if !@{C.c.M||[]};
        my $D = T.D;
        
        my $L = C.y.L = G&A,L=>1,$C;
        Lc&ybrow = Ds&nogindex;
        G&A,$L,8;
    
    0 && # ground descript, floating tool
    J 69: %of:mo,v:sJ
        local A.V = 1;
        sayyl "HAve ".ki $C;
        saybl wdump 2, J.sc.root.c.s;
        my $uz = G&grind,$J;
        my $grimd = sub { 
            my $uz = shift;
            [map{my$c=_.c.s;"_.t _.cv: c.t c.y.cv ("
                .join(' ',sort keys %{c.c}).")  "
                .join(' ',sort keys %{c.sc})
            } map {$uz.>$_ } sort keys %$uz];
        };
        my $l = $grimd->($uz);
        push @$l, "For J.t";
        saybl @$l;
        
    # create L uC, the actuating
    # its y may be here if we are an atom within it
    L 1:
        (A&s) = @$s;
    a 1: %of:a
        (A&s) = @$s;
    
    # any gk of L to pull mo into an L (nogindex)
    M: %v:cM
        # etc
    n: %v:yn
        # to almost fill space
    spc: %v:yspc
        # to take up space
    u: %v:yu
        # to take space up til
    rev: %v:yspc
        # composite \d+ ? y.cyc : peels into y
    cyc: %v:ycyc
        # sweeping over itself, round and round
    erse: %v:yerse
        # flip n,u, stack floor to ceiling
    # so goes from ground to mind, instead of in to out
    # since we use y.in now for the first insider
    in 12: %v:yin,vatis:!ref
        C.y.n = delete C.y.in if !ref C.y.in;
    out 12: %v:yout,vatis:!ref
        C.y.u = delete C.y.out if !ref C.y.out
    
    #c a space to fill
    # if !M:
    #   y.in/out give it that much space & make holes in 1s&root's M
    #   y.thi that many C
    # 
    # L plots M as a, which may know more L/a around
    # C->root.c.M masses for piping parallel pi
    # sync around mo, can hang on/replot with 
    L 2:
        A&y && die "You Ay L 2";
        my $J = A.1;
        Jc&s || die "Jcs not holding mo C: ".G&sn;
        #local A.V = 1;
        # mo C that began the J we are now inside is the trick
        # we are probably at 17 of their root mo, which has c&M
        my $Jy = 1Cy&C;
        my $y = C.y;
        my $M = c&M;
        
        if (my $r = y.rev) {
            for my $r (split ' ', $r) {
                if ($r =~ /^\d+$/) {
                    y.cyc = $r;
                }
                else {
                    G&xot,$y,$_ for G&peel,$r;
                }
            }
        }
        
        # some L uC spawns the A nC lattice
        # what to do with the L uC?
        # always gets M
        if ($M) {
            # has M
            # L uC can be forgotten, probably mo'd with root in J6
            # it could be placement metadata/unity
            my @M;
            while (y.thi && @$M < y.thi) { # copies out to there
                @M = @$M if !@M;
                last if !@M;
                push @$M, G&hup,shift@M;
            }
            if (y.cyc && @$M > y.cyc) { # sweeping over itself
                my @M = splice @$M, 0, y.cyc while @$M > y.cyc;
                splice @M, 0, 0+@$M;
                push @$M, @M;
                # decommissions them?
            }
        }
        else {
            # is first in its own M
            # to make holes in space other M must flow around
            c&M = $M = [$C];
            y.thi > 1 &&
                   push @$M, map { G&hup,$C } 1 .. y.thi - 1;
        }
        
        # limits apply, thi being for ^ iterator length 
        #                          and v limit of output
        my $lims = {};
        for (qw'thi') {
            $lims.>$_ = $y.>$_ if defined $y.>$_;
        }
        lims.limn = int(9 * y.limn * Jy.spc)
            if y.limn && (Jy.spc || die "No space! J.t");
        my $lim;
        while (my ($k,$v) = each %$lims) {
            @$M > $v || next;
            say "Limof: $k $v to C.t";
            $lim = $k if !$lim || $lims.>$lim > $lims.>$k;
        }
        if ($lim) {
            my $it = $lims.>$lim;
            my $from = 0;
            if (y.tail) {
                $from = -1;
                $it *= -1;
            }
            else {
                $it -= 1;
            }
            $lims = $lim; # name
            $lim = @$M; # limited from
            @$M = @{$M}[$from .. $it];
        }
        
        A.V = 0;
        y.thi = @$M;
        y.thi || die "No M: ".ki $C;
        y.thi = y.cyc if y.cyc;
        #c & point/seek to things coming in with our surrounds
        
        # if we were placed with enough room
        # let atoms slide up to the top J
        # things saying they're in both places
        #   leads to nice grouping, ref integrity
        y.J = A.3 if Jy.spc > 0.1;
        delete y.J if y.clos;
        my $clos = Jy.spc && !y.J;
        #  they can want to be inside too
        #  geo to chain together floating/not atoms
        #  so its like wires over machines
        
        # ml (margin-left)
        # high lum makes tree bends up towards margin
        # like it is open inside, like bet. rummager.
        y.inde = Jy.inde + 0.06 if y.J;
        
        # sliver of attention
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        # carpenting
        y.n ||= $clos ? 0.3 : Jy.J ? Jy.cv + $sl : 0.1;
        y.u ||= $clos ? 0.4 : Jy.J ? Jy.ov - $sl : 0.9;
        
        # set width
        y.u = y.n + y.space if defined y.space;
        if (y.erse) {
            (y.u,y.n) = (y.n,y.u);
            y.tail = y.thi; # lightly
        }
        
        # may be way less than 0...
        # a cv scaled back, will have defiantly huge spc
        y.u /= 10 until y.u < 1;
        y.n /= 10 until y.n < 1;
        # corner noted
        if ($lim) {
            my $s = "$lim>".@$M;
            my $cv = y.tail ? y.n : y.u;
            # TODO += here blows up zopul:
            $cv -= 0.002;
            my $M = A&XM ||= []; # labely meta
            m lim=>$cv,$s,'%fs:7,hs:7487,limit:'.$lims;
        }
        # fit in multiple of
        if (my $ert = y.ert) {
            $ert += y.ert while y.thi > $ert;
            y.thi = $ert;
        }
        y.space = y.u - y.n;
        my $outer;
        if (y.res) {
            $outer = y.space / y.thi;
            y.space -= $outer;
        }
        y.space *= -1 if y.space < 0;
        y.v.v = y.n; # rolls
        y.v.v += $outer / 2 if $outer; #
        # average size
        y.v.aspace = G&roun,y.space/y.thi;
        # thy -> mu bends out
        y.v.Ly = $y; # u is shared placevolve meta
        my $i;
        for (@$M) {
            _.y.v = y.v;
            _.y.i = $i++;
            _.y.a = G&tugA,a=>2=>$_;
            _.y.a.L = $A;
        }
        # L can M the C also in a
    
     #c lum uC shapes curve, wants to be with limn
     # might mean a few lum qualities, make them switchupable
     # supposedly osc can measure itself, hoist geometry
     #    descriptions for ascii art buildings
    lum 23: %v:ylum
        my $M = c&M || die "lum no M";
        my $y = C.y;
        my $u;
        (u.l,u.r) = split ',', $lum;
        $u.>$_ = do {
            $u.>$_ =~ m/^(?:(\d+)-)??(?:(\d+))(?:-(\d)+)?$/
                || die "notunder: $_ ".wdump 2, $u;
            {i=>$1,u=>$2,o=>$3}
        } for grep {$u.>$_ } keys %$u;
        u.l.u ||= 3;
        u.r.u ||= u.l.u / 4;
        u.l.o ||= u.r.u / 3;
        my $i = 0;
        for (@$M) {
            _.y.thy = 1 if !defined y.thy;
            _.y.thy += u.l.u;
            $i++;
            if ($i > u.l.o) {
                u.l.u -= 2 if u.l.u > 0.1;
            }
        }
    
    # 3 the allocations, M start happening
    bal 3: %v:ybal
        my $M = c&M;
        Rw ModNs $M $s:bal;
    #c refit cv by t, spawn L per added pieces
    # to fit back into M above,
    refit 4: %v:yres
        #local A.V = 2;
        my $y = C.y;
        my $M = c&M || die "refit no M";
        y.res == 2 && return
            saygr "A.1.t fits ".@$M." into C.t";
        my $res = y.res = 1s&res.>C.t ||= {res=>$res};
        my $ctv = res.ctv ||= {};
        my $la; # known from
        my @news;
        my $bend = sub {
            my ($from,$to,@M) = @_;
            @M = map {
                _.y.a || die "has no ya: ".ki$_;
                _.y.a.c.s eq $_ || die "ya cs not _: ".ki[_.y.a.c.s,$_];
                # their a C becomes for cv/spc for real heighting etc
                _.y.realy = _.y.a.c.s = G&hup,_.y.a.c.s;
                # takeover original ref:
                $_
            } @M;
            my $nu = G&Ct,["Bend$from->$to",{}];
            nu.y.n = $from;
            nu.y.u = $to;
            nu.y.res = 2; # makes spc/2 away from edges but not M<>ctv
            nu.c.M = \@M;
            nu.c.oM = [];
            # ^ our ground splices this L's stuff into $M
            # as it is A.y=A in an M of C
            G&tugA,L=>4,$nu;
        };
        return keys %$ctv &&
            saygr "All new refit C.t C.y.res -- ".G&sn
            unless grep{ $ctv.>_.t } @$M;
        my @M;
        for (@$M) {
            my $at = $ctv.>_.t;
            if ($at && !_.c.refit) {
                sayyl "Have _.t  -> $at";
                if ($la && $at < $la) {
                    # has to opt out for M order via c&refit
                    # la cause may have moved out already
                    saybl " is from earlier";
                }
                _.y.cv = $at;
                push @M, $_;
                if (@news) {
                    # bend @news between $la and $_
                    $la ||= y.n;
                    saygr "Bend from $la to $at:\n".ki \@news;
                    push @M,
                        $bend->($la,$at,@news);
                    @news = ();
                }
                $la = $at;
            }
            else {
                saybl "New _.t".(_.c.refit && " (repo)");
                push @news, $_;
            }
        }
        $bend->($la,y.u,@news) if @news;
    
    #c L fits curve
    barel 5: %v:cM
        my $y = C.y;
        my $total = sum(map{ _.y.thy || 1 } @$M) || 1;
        y.v.muav = @$M / $total;
    
    # a eats space, sliding y.v.v along (Ya-Habibi)
    # spiral much space away from spine
    # build wave plot manifold, solar systems
    # TODO: causes Mudit to place a out of order (tug..?):
    #many 6: %of:a
    many 6: %v:cM
        for my $C (@$M) {
            my $y = C.y;
            y.mu = defined y.thy ? y.thy : 1;
            y.mu = y.mu * y.v.muav if y.v.muav;
            my $was = y.v.v;
            y.cv = G&roun,y.v.v if !y.cv;
            y.pcv = G&roun,y.i/y.v.Ly.thi;
            my $in = y.v.aspace * y.mu;
            y.v.v += $in;
            y.ov = G&roun,y.v.v;
            y.spc = y.ov - y.cv;

            C.sc.yspc = y.spc if C.sc.nspc;
            C.sc.ml = (y.v.Ly.inde * 40)."%" if y.v.Ly.inde;
        }
    
    # feel effects of...
    res 7: %v:yres
        ref $res || return;
        my $y = C.y;
        my $M = c&M;
        my $ctv = res.ctv;
        for (@$M) {
            $ctv.>_.t && delete $ctv.>_.t;
            $ctv.>_.t = _.y.cv || die "No cv res yet: ".ki$_;
        }
    
    # t-rewirey formulae:
    lum 7: %v:ylum
        my $M = c&M || die "lum no M";
        for my $C (@$M) {
            my $y = C.y;
            my $upt = 0;
            y.spc = 0.01 if y.spc < 0.01;
            my $fs = y.spc * 20 * 4;
            if (c&helum) {
                s&he = G&rou,$fs/c&helum;
            }
            else {
                $fs = 3 if $fs < 3;
                s&fs = G&rou,$fs;
            }
        }
    
    #c ground into creation
    ground 8:
        my $M = c&M || die "L 8 with no M: ".ki$C;
        my $y = C.y;
        # first was ourself that is already in mo
        shift @$M if $M->[0] eq $C;
        my $J = y.J || A.1;
        A&XM && push @$M, @{A&XM}; # labely meta
        # resolve any L in M to its many
        @$M = map {
            my $oM = _.y eq $_ && (_.c.s.c.oM || die
                "NoM on inner _.t from C.t: ".ki _c&s );
            $oM ? @$oM : $_
        } @$M;
        # stash out many for the above
        c&oM && return push @{c&oM}, @$M;
        if (A.V || 1c&Mhat) {
            1 && sayyl "For J.t: ";
            1 && saygr "_.t: _.y.cv (spc=_.y.spc)" for @$M;
        }
        
        Rw ModNs $M $s:y.mod if y.mod;
        if (!@$M) {
            my $inte;
            $inte.>$_ = $y.>$_ for grep{$y.>$_ } keys %{A&ybrow};
            1 && sayre "NOthing!? in M C.t"
                .($inte && ": intyresty: ".ki $inte);
            return
        }
        G&A,n=>8=>$J,@$M;
    

