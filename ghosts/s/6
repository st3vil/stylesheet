ImCom: | # ing
    T is your mess with the mind/world throughput
    ^ you are here, left is mind, right is world
    or up (at ElM) down (on Os)
    Os gather wormholes for reconvenience to ElM summers
    
    
    
    
    ghost host, telling ElMs of any change
    
ElPictMany: | # T sequence
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    1 && return
        Rw ElPassTape;
    if (c&Se == 1) {
        u CheckMott=>'',<<'','%of:w'
            u CheckMotti=>'',<<'','%of:w'
                u Zpace
                u 'pi/CorA'=>'',<<'','%of:w'
                    ref $s eq 'HASH' || return
                        n un=>1=>ki $s
                    n t =>1=> s.t
                    my $wh = s.y eq $s ? 'A' :
                        exists s.t && ref s.y && (ref s.c || ref s.sc) ? 'C'
                        : 'unco';
                    my $hs = $wh eq 'A' ? '3574' : $wh eq 'C' ? '845' : '598';
                    n isa =>14=> $wh =>'%hs:'.$hs

                    n cv =>2=>s.y.cv

                    n c =>5=>{s=>join',',sort keys %{s.c}}
                    n sc =>7=>{s=>join',',sort keys %{s.sc}}
                y.in = 5;
                m 'C'=>-CorA=>{s=> $C }
                m '1'=>-CorA=>{s=> A.1 }
                m '2'=>-CorA=>{s=> A.2 }
                m '2CyA'=>-CorA=>{s=> 2Cy&A }
                m Amoupmo=>-CorA=>{s=>A.mo.up.mo}
            n CheckMotti
        # etc
        
        t.e =
        n CheckMott
        t.toc.slim = 100;
        t.toc.slimvague = 100;
        my $j = t.en->('sc lastK c s', "Splay out some A!");
        is j.t, 'CheckMotti', "Last J returned from t\.en";
    }
    # !
    if (c&Se == 2) {
        ok 0 == keys %{t.toc}, "t\.toc cleared between Se (n)";
        
        G&T,'Onte';
        # apply thy etc natively
        u ye =>'',<<'','%of:i,acgt:s'
            ss&pi eq 'code' && sayre "For eg";
            {thy=>0.5}
        
        u Zpace
        u Chunkfalls=>'',<<'','%of:w'
            u Chunkfall=>'',<<'','%of:w'
                u Zpace
                n ElTarfigure
                for (G&op,'spi:=relim' ) {
                    m _.t=>''=>_c&s
                }
            u Zpace
            u PaintedStripes
            n Chunkfall
            for (G&op,'t:~^[tT]' ) {
                m _.t=>G&ye,$_ =>_c&s=>''
            }
            shift @$M for 1..J.bowls;
            for (@$M) {
                (_s&tag,_s&src) = ('img',delete(_c&s));
                _c&helum = 1;
            }
            y.lum = 8 * J.bowls++ || return;
            n do=>1=>"Fosci J.bowls",'%hs:345,fs:'.(30 * J.bowls)
            y.at.lumwas = y.lum;
            y.imp++;# if J.bowls == 2; # reset lv
        
        t.toc.slim = 220;
        t.e =
        n Chunkfalls
        t.en->('sc lastK c s', "See tarps");
        my $s = T.op.y.s;
        n Chunkfalls
        t.cs->('sc lastK c s', "See tarps lum 1, fresh lv");
        my $seeit = sub {
            my $W = t.ntos->(t.e,'J');
            t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s,time=>6});
            sleep 1;
        };
        $seeit->();
        n Chunkfalls
        t.cs->('sc lastK c s', "See tarps lum 2");
        $seeit->(); # doesn't find elements to change?
        n Chunkfalls
        t.cs->('sc lastK c s', "See tarps lum 3");
        $seeit->();
        # feed onto screen as img tags
        # c.R callup W Top
        
        return;
        t.e =
        n ElvisMatu
        my $W = t.ntos->(t.e,'J');
        t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s});
    }
ElPassTape: |
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    if (c&Se == 1) {
        u Zpace
        u FeelTapey=>'',<<'','%of:w'
            u Zpace
            u PaintedStripes
            m feo=>''=>"Soe $_",'%hs:349,bgh:843' for 1..3;
            
            y.lum = 8 * J.bowls++ || return;
            _s&helum = 1 for @$M;
            n do=>1=>"Fosci J.bowls",'%hs:345,fs:'.(30 * J.bowls)
            y.at.lumwas = y.lum;
            #y.imp++;# if J.bowls == 2; # reset lv
        
        t.e =
        n FeelTapey
        t.en->('sc lastK c s', "See tarps");
        my $seeit = sub {
            my $W = t.ntos->(t.e,'J');
            t.mkoJ->(Junup=>{eat=>W.sc.s.sc.lastK.c.s,time=>6});
            sleep 1;
        };
        $seeit->();
    }
EliPticMany: |
    #
ElvisMany: | # J m C # candidate for moving C جستجو
    my $t = Rw Towering
        || return;
    Rw HasWay;
    
    if (c&Se == 1 && 0) {
        t.e =
        n Zpace
        t.en->('sc lastK c s', 'has Zpace');
        my $W = t.ntos->(t.e,'J');
        saybl wdump 3, W.sc.ii.mo.y.tw.M.sc.ip;
        exit;
    }

    if (c&Se == 1) {
        t.e =
        n HasMany
        t.en->('sc lastK c s', 'put couple of things');
        my $W = t.ntos->(t.e,'J');
        #saybl wdump 3, W.ii.mo.y.tw;
        #t.cs->('sc lastK c s', 'they have stuff');
        t.e =
        n HasMany
        t.en->('sc lastK c s', 'few things, large Dozer');
        t.en->('sc top', 'few things, large Dozer top');
        
        t.e =
        n HasMany
        t.en->('sc top', 'few things, small Dozer');
        
        t.e =
        n HasMany
        t.en->('sc top', 'same thing multi Joy');
        #exit;
        
        t.e =
        n HasMany
        t.en->('sc top', 'same interleaving');
        
        t.e =
        n HasMany
        t.en->('sc top', 'many Joy and threes');
        
    }
        
    # yeah
HasMany: |
    u Zpace
    my $n = J.bowls++;
    if ($n == 0) {
        y.in = 3;
        m Zpacer=>''=>"Blow"
        m Dooz=>''=>"Wind"
    }
    if ($n == 1) {
        y.in = 22;
        m Zpacer=>''=>"Blow"
        m Dozer=>{thy=>1.4}=>"Thrill"
        m Dooz=>''=>"Wind"
    }
    if ($n == 2) {
        m Zpacer=>''=>"Blow"
        m Dozer=>{thy=>0.2}=>"Thrill"
        m Dooz=>''=>"Wind"
        y.out = 5;
    }
    if ($n == 3) {
        n joy=>'1..3x7'=>'Joy'
    }
    if ($n == 4) { # interleaving
        n joy=>'1..3x7'=>'Joy'
        my $thy = 1;
        m threes=>{thy=>($thy += $thy / 3)}=>3=>"%fs:$_" for 14..20;
    }
    if ($n == 5) { # many Joy and threes
        n joy=>'..7x37'=>'Joy'
        my $thy = 1;
        m threes=>{thy=>($thy += $thy / 3)}=>3=>"%fs:$_" for 3..20;
    }
    if ($n == 6) { # limiting
        y.thi = 6;
        my $thy = 1;
        m threes=>{thy=>($thy += $thy / 3)}=>3=>"%fs:$_" for 3..20;
    }
ElvisResMany: | # J m C, add more while keeping as much order as possible
    my $t = Rw Towering
        || return;
    Rw HasWay;
    # fits new items in between existing ones
    # ie open code pages
    # La keeps cvs same as possible, spc into heights
    
    # can make up an el=6 for moving parts to send to W dependents
    
    if (c&Se == 1) {
        my $all = {};
        my $te = sub {
            my ($l) = @_;
            my $grepl = sub {
                my $l = shift;
                $1 ne 'ElvisHasResMany' && $all.>$1.>$2 ++
                    if $l =~ /^\s+(\w+)\s+(\S+)/;
                1;
            };
            t.cs->({ntos=>'sc lastK c s',grepl=>$grepl}, $l);
        };
        t.e =
        n ElvisHasResMany
        $te->('put a few things');
        
        n ElvisHasResMany
        $te->('news sorted in between');
        
        n ElvisHasResMany
        $te->('things go');
        
        n ElvisHasResMany
        $te->('news, Atoms come back');
        
        t.dd->($all, "All t cv'd once");
        
        n ElvisHasResMany
        $te->('ThenSome refits, Wide doesnt');
        
        t.dd->($all, "All t cv'd again");
    }
    
ElvisHasResMany: |
    u Zpace
    my $n = J.bowls++;
    y.res = 1;
    if ($n == 0) {
        m $_,'',$_ for qw'Five Atoms Wide';
    }
    if ($n == 1) {
        m $_,'',$_ for qw'Five Actual Atoms Wide ThenSome MoreDown';
    }
    if ($n == 2) {
        m $_,'',$_ for qw'Five Actual MoreDown';
    }
    if ($n == 3) {
        m $_,'',$_ for qw'Neverwrong Finding Five Actual Vacsosity MoreDown Atoms';
    }
    if ($n == 4) {
        for (qw'Neverwrong Wide ThenSome Finding Five Actual Vacsosity MoreDown Atoms') {
            my $c;
            c.s = $_;
             c.refit++ if /ThenSome/;
            m $_,'',$c
        }
    }
nogindex: |
    my ($nk,$of) = split ':', $s;
    $nk && $of || die "not nk:of: $s";
    my $i = s&nogindex = {};
    for (@$N) {
        _s&nk eq $nk && _s&of eq $of && _s&gk || next;
        $i.>_s&gk = _s&vatis || 1;
    }
    s&t && die "Receiver has nogint already: ".ki $C;
    s&t = 1;
    my $p = s&ip = {};
    p.y.hasany = $i;
    if (s&vor) {
        my $r = $p.>s&vor = {};
        (r.nk,r.gk) = G&pang,s&vor;
        r.exi = 1; # exists
        p.y.or = 1;
        p.order = [s&vor,'y'];
    }
Zpace: | # hang La space charts off mo
    u alact
    n \'of:L'
    y.at.coil = 'tldo';
    
    # fix Zuup re something
    
    # A.3 pools lists up from c.y.A.1 pi etc.
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
        # oir rhythm style joins
    # ^ always wants a new one somewhere
        # 4d jelly slower-downer
            # TRansituio, soul spread
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
    
    # plumb moment
    # or any that nogy things
    M 16: %of:mo,tldo:nogindex:y:L,vor:cM
        return if C.y.a; # already placed
        return if C.y.L; # already placing
        my $M = c&M;
        if (A.V) {
            sayre "C.t manies!: ".(exists c&M)."  ".ki $M;
            my $D = T.D;
            my $ybrow = Ds&nogindex;
            my @ym = grep{C.y.>$_ } keys %$ybrow;
            1 && sayyl "Neg: C.t y: ".join',',@ym;
            1 && saybl "noym: ".wdump 2, [C.c,C.y] if !@ym;
        }
        C.y.L = G&A,L=>8,$C
    
    0 && # ground descript, floating tool
    J 69: %of:mo,v:sJ
        local A.V = 1;
        sayyl "HAve ".ki $C;
        saybl wdump 2, J.sc.root.c.s;
        my $uz = G&grind,$J;
        my $grimd = sub { 
            my $uz = shift;
            [map{my$c=_.c.s;"_.t _.cv: c.t c.y.cv ("
                .join(' ',sort keys %{c.c}).")  "
                .join(' ',sort keys %{c.sc})
            } map {$uz.>$_ } sort keys %$uz];
        };
        my $l = $grimd->($uz);
        push @$l, "For J.t";
        saybl @$l;
        
    # create L uC, the actuating
    # its y may be here if we are an atom within it
    L 1:
        (A&s) = @$s;
    a 1: %of:a
        (A&s) = @$s;
    
    
    # any gk of L to pull mo into an L (nogindex)
    n: %v:yn
        # to almost fill space
    spc: %v:yspc
        # to take up space
    u: %v:yu
        # to take space up til
    
    # so goes from ground to mind, instead of in to out
    # since we use y.in now for the first insider
    in 12: %v:yin,vatis:!ref
        C.y.n = delete C.y.in if !ref C.y.in;
    out 12: %v:yout,vatis:!ref
        C.y.u = delete C.y.out if !ref C.y.out
    
    #c a space to fill
    # if !M:
    #   y.in/out give it that much space & make holes in 1s&root's M
    #   y.thi that many C
    # 
    # L plots M as a, which may know more L/a around
    # C->root.c.M masses for piping parallel pi
    # sync around mo, can hang on/replot with 
    L 2:
        A&y && die "You Ay L 2";
        A.1.c.s || die "J has no mo C: ".G&sn;
        #local A.V = 1;
        # mo C that began the J we are now inside is the trick
        # we are probably at 17 of their root mo, which has c&M
        my $Jy = 1Cy&C;
        my $y = C.y;
        my $M = c&M;
        
        # some L uC spawns the A nC lattice
        # what to do with the L uC?
        if ($M) {
            # has M
            # L uC can be forgotten, probably mo'd with root in J6
            # it could be placement metadata/unity
        }
        else {
            # is first in its own M
            # to make holes in space other M must flow around
            A&M = $M = [$C];
            y.thi > 1 &&
                   push @$M, map { G&hup,$C } 1 .. y.thi - 1;
        }
        
        # limits apply, thi being for ^ iterator length 
        #                          and v limit of output
        my $lims = {};
        lims.thi = y.thi if defined y.thi;
        lims.limn = int(9 * y.limn * Jy.spc)
            if y.limn && (Jy.spc || die "No space! J.t");
        my $lim;
        while (my ($k,$v) = each %$lims) {
            @$M > $v || next;
            say "Limof: $k $v to C.t";
            $lim = $k if !$lim || $lims.>$lim > $lims.>$k;
        }
        if ($lim) {
            my $it = $lims.>$lim;
            my $from = 0;
            if (y.tail) {
                $from = -1;
                $it *= -1;
            }
            else {
                $it -= 1;
            }
            $lims = $lim; # name
            $lim = @$M; # limited from
            @$M = @{$M}[$from .. $it];
        }
        
        A.V = 0;
        y.thi = @$M;
        y.thi || die "No M: ".ki $C;
        #c & point/seek to things coming in with our surrounds
        
        # if we were placed with enough room
        # let atoms slide up to the top J
        # things saying they're in both places
        #   leads to nice grouping, ref integrity
        y.J = A.3 if Jy.spc > 0.1;
        delete y.J if y.clos;
        my $clos = Jy.spc && !y.J;
        #  they can want to be inside too
        #  geo to chain together floating/not atoms
        #  so its like wires over machines
        
        # ml (margin-left)
        # high lum makes tree bends up towards margin
        # like it is open inside, like bet. rummager.
        y.inde = Jy.inde + 0.06 if y.J;
        
        # sliver of attention
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        # carpenting
        y.n ||= $clos ? 0.3 : Jy.J ? Jy.cv + $sl : 0.1;
        y.u ||= $clos ? 0.4 : Jy.J ? Jy.ov - $sl : 0.9;
        # set width
        y.u = y.n + y.space if defined y.space;
        y.u /= 10 until y.u < 1;
        y.n /= 10 until y.n < 1;
        # corner noted
        if ($lim) {
            my $s = "$lim>".@$M;
            my $cv = y.tail ? y.n : y.u;
            # TODO += here blows up zopul:
            $cv -= 0.002;
            my $M = A&XM = [];
            m lim=>$cv,$s,'%fs:7,hs:7487,limit:'.$lims;
        }
        # fit in multiple of
        if (my $ert = y.ert) {
            $ert += y.ert while y.thi > $ert;
            y.thi = $ert;
        }
        y.space = y.u - y.n;
        my $outer;
        if (y.res) {
            $outer = y.space / y.thi;
            y.space -= $outer;
        }
        y.space *= -1 if y.space < 0;
        y.v.v = y.n; # rolls
        y.v.v += $outer / 2 if $outer; #
        # average size
        y.v.aspace = G&roun,y.space/y.thi;
        # thy -> mu bends out
        y.v.y = $y; # u is shared placevolve meta
        my $i;
        for (@$M) {
            _.y.v = y.v;
            _.y.i = $i++;
            _.y.a = G&tugA,a=>2=>$_;
            _.y.a.L = $A;
        }
        # all ying applies now to M
        # tugging M
    
     #c lum uC shapes curve, wants to be with limn
     # might mean a few lum qualities, make them switchupable
     # supposedly osc can measure itself, hoist geometry
     #    descriptions for ascii art buildings
    lum 23: %v:ylum
        my $M = c&M || die "lum no M";
        my $y = C.y;
        my $um;
        (um.l,um.r) = split ',', $lum;
        for (grep{defined $um->{$_}} keys %$um) {
            $um->{$_} =~ /^(?:(\d+)-)??(?:(\d)+)(?:-(\d)+)?$/
                || die "notunder: ".wdump 2, $um;
            $um->{$_} = {i=>$1,um=>$2,o=>$3};
        }
        
        um.l.um ||= 3;
        my $lumhalvesby = (um.l.um / 2) / (um.r.um || 3);
        my $i = 0;
        for (@$M) {
            _.y.thy = 1 if !defined y.thy;
            _.y.thy+=um.l.um;
            $i++;
            if ($i > um.l.o) {
                um.l.um -= $lumhalvesby if um.l.um > 0.1;
            }
        }
    
    # 3 the allocations, M start happening
    
    #c refit reoccur cv by _.t, spawn L per added piece
    refit 4: %v:yres
        #local A.V = 2;
        my $y = C.y;
        my $M = A&M || c&M;
        y.res == 2 && return
            saygr "A.1.t fits ".@$M." into C.t";
        my $res = y.res = 1s&res.>C.t ||= {res=>$res};
        my $ctv = res.ctv ||= {};
        my $la; # known from
        my @news;
        my $bend = sub {
            my ($from,$to,@M) = @_;
            @M = map {
                _.y.a || die "has no ya: ".ki$_;
                _.y.a.c.s eq $_ || die "ya cs not _: ".ki[_.y.a.c.s,$_];
                # their a C becomes for cv/spc for real heighting etc
                _.y.realy = _.y.a.c.s = G&hup,_.y.a.c.s;
                # takeover original ref:
                $_
            } @M;
            my $nu = G&Ct,["Bend$from->$to",{}];
            nu.y.n = $from;
            nu.y.u = $to;
            nu.y.res = 2; # makes spc/2 away from edges but not M<>ctv
            nu.c.M = \@M;
            nu.c.oM = [];
            # ^ our ground splices this L's stuff into $M
            # as it is A.y=A in an M of C
            G&tugA,L=>4,$nu;
        };
        return keys %$ctv &&
            saygr "All new refit C.t C.y.res -- ".G&sn
            unless grep{ $ctv.>_.t } @$M;
        my @M;
        for (@$M) {
            my $at = $ctv.>_.t;
            if ($at && !_.c.refit) {
                sayyl "Have _.t  -> $at";
                if ($la && $at < $la) {
                    # has to opt out for M order via c&refit
                    # la cause may have moved out already
                    saybl " is from earlier";
                }
                _.y.cv = $at;
                push @M, $_;
                if (@news) {
                    # bend @news between $la and $_
                    $la ||= y.n;
                    saygr "Bend from $la to $at:\n".ki \@news;
                    push @M,
                        $bend->($la,$at,@news);
                    @news = ();
                }
                $la = $at;
            }
            else {
                saybl "New _.t".(_.c.refit && " (repo)");
                push @news, $_;
            }
        }
        $bend->($la,y.u,@news) if @news;
    
    #c a C fits curve
    barel 5: %v:cM
        my $y = C.y;
        my $total = sum(map{ _.y.thy || 1 } @$M) || 1;
        y.v.muav = @$M / $total;
    
    # could spiral much space away from spine
    # build wave plot manifold, solar systems
    many 6: %of:a
        my $y = C.y;
        y.mu = defined y.thy ? y.thy : 1;
        y.mu = y.mu * y.v.muav if y.v.muav;
        my $was = y.v.v;
        y.cv = G&roun,y.v.v if !y.cv;
        y.pcv = G&roun,y.i/y.v.y.thi;
        my $in = y.v.aspace * y.mu;
        y.v.v += $in;
        y.ov = G&roun,y.v.v;
        y.spc = y.ov - y.cv;

        C.sc.yspc = y.spc if C.sc.nspc;
        C.sc.ml = (y.v.y.inde * 40)."%" if y.v.y.inde;
    
    res 7: %v:yres
        ref $res || return;
        my $y = C.y;
        my $M = A&M || c&M;
        my $ctv = res.ctv;
        for (@$M) {
            $ctv.>_.t && delete $ctv.>_.t;
            $ctv.>_.t = _.y.cv || die "No cv res yet: ".ki$_;
        }
    
    # feel effects of...
    # t-rewirey formulae:
    lum 7: %v:ylum
        my $M = c&M || die "lum no M";
        for my $C (@$M) {
            my $y = C.y;
            my $upt = 0;
            y.spc = 0.1 if y.spc < 0.1;
            my $fs = y.spc * 20 * 4;
            if (c&helum) {
                s&he = $fs;
            }
            else {
                s&fs = $fs;
            }
        }
    
    # ground the creation
    ground 8:
        my $M = A&M || c&M || die "L 8 with no M: ".ki$C;
        my $y = C.y;
        shift @$M if $M->[0] eq $C;
        my $J = y.J || A.1;
        A&XM && push @$M, @{A&XM};
        # resolve any L in M to its many
        @$M = map {
            my $oM = _.y eq $_ && (_.c.s.c.oM || die
                "NoM on inner _.t from C.t: ".ki _c&s );
            $oM ? @$oM : $_
        } @$M;
        # stash out many for the above
        c&oM && return push @{c&oM}, @$M;
        if (A.V) {
            1 && sayyl "For J.t: ";
            1 && saygr "_.t: ".ki _.y for @$M;
        }
        G&A,n=>8=>$J,@$M;
    

