ElvisMany: | # J m C
    my $t = Rw Towering Ang
        || return;
    Rw HasWay;
    
    # add many S pages
    if (c&Se == 1 && 0) {
        t.e =
        n Softu
        t.en->('sc lastK c s', 'caches u');
    }

    if (c&Se == 1) {
        t.e =
        n HasMany
        t.en->('sc lastK c s', 'they have stuff');
        my $W = t.ntos->(t.e,'J');
        #saybl wdump 3, W.ii.mo.y.tw;
        #t.cs->('sc lastK c s', 'they have stuff');
    }
        
    # yeah
Softu: |
    T.H = 2; # stores
    n aly
    n alc
    n als
    n alacgts
HasMany: |
    u Zpace
    m Zpacer=>''=>"Blow"
    saybl "Hasss ". ki A.ii.mo.y.tw.M;
nogindex: |
    my ($nk,$of) = split ':', $s;
    $nk && $of || die "not nk:of: $s";
    s&nogindex = {map{_s&gk=>1}
        grep{_s&nk eq $nk && _s&of eq $of && _s&gk}
    @$N};
    
Zpace: |
    u alc
    y.at.coil = 'tldo';
    # A.3 pools lists up from c.y.A.1 pi etc.
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
        # oir rhythm style joins
    # ^ always wants a new one somewhere
        # 4d jelly slower-downer
            # TRansituio, soul spread
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
    
    # plumb moment
    # or any that nogy things
    M 16: %of:mo,tldo:nogindex:y:L
        sayre "C.t manies!: ".ki $M;
            my $D = T.D;
            my $ybrow = Ds&nogindex;
            sayyl "Neg: C.t ".ki $ybrow;
        G&A,L=>8,$C
    
    u alact
    n \'of:L'
    # create L uC, the actuating
    # its y may be here if we are an atom within it
    L 1:
        (A&s,A&y) = @$s;
        T.Z.3 = $A if A&y;
    
    # if !M:
    #   y.in/out give it that much space & make holes in 1s&root's M
    #   y.thi that many C
    # 
    # L makes a each M, which may be able to see into things,
    # C->root.c.M masses for piping parallel pi
    # sync around mo, can hang on/replot with 
    L 2: %tldo:nogindex:y:L
        A&y && die "You Ay L 2, should TZ3";
        A.1.C || die "J has no mo C: ".G&sn;
        my $Jy = A.1.C.y;
        my $y = C.y;
        my $M = c&M;
        # some L uC spawns the A nC lattice
        # what to do with the L uC?
        if ($M) {
            # has M
            # L uC can be forgotten, probably mo'd with root in J6
            # it could be placement metadata/unity
        }
        else {
            # is first in its own M
            # to make holes in space other M must flow around
            $M = [$C];
            y.thi > 1 &&
                   push @$M, map { G&hup,$C } 1..y.thi;
        }
        y.thi = @$M;
        # & point/seek to things coming in
        
        # if we were placed with enough room
        # let atoms slide up to the top J
        # things saying they're in both places
        #   leads to nice grouping, ref integrity
        y.J = A.3 if Jy.spc > 0.1;
        delete y.J if y.clos;
        my $clos = Jy.spc && !y.J;
        #  they can want to be inside too
        #  geo to chain together floating/not atoms
        #  so its like wires over machines
        
        # ml (margin-left)
        y.inde = Jy.inde + 0.06 if y.J;
        
        # sliver of attention
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        # carpenting
        y.in  ||= $clos ? 0.3 : Jy.cv ? Jy.cv + $sl : 0.1;
        y.out ||= $clos ? 0.4 : Jy.ov ? Jy.ov - $sl : 0.9;
        # set width
        y.out = y.in + y.space if defined y.space;
        # fit in multiple of
        if (my $ert = y.ert) {
            $ert += y.ert while y.thi > $ert;
            y.thi = $ert;
        }
        y.space = y.out - y.in;
        y.space *= -1 if y.space < 0;
        # average size
        y.aspace = G&roun,y.space/y.thi;
        # thy -> mu bends out
        
        y.u.y = $y; # u is shared placevolve meta
        y.u.v = y.in; # rolls
        my $i;
        for (@$M) {
            _.y.u = y.u;
            _.y.i = $i++;
            _.y.a = G&tugA,a=>2=>$_,$y;
            _.y.a.L = $A;
        }
        # all ying applies now to M
        # tugging M
     #c uC shapes curve, wants to be with limn
     # might mean a few lum qualities, make them switchupable
     # supposedly osc can measure itself, hoist geometry
     #    descriptions for ascii art buildings
    lum 23: %of:L,v:ylum
        my $M = c&M || die "lum no M";
        my $um;
        (um.l,um.r) = split ',', $lum;
        for (grep{defined $um->{$_}} keys %$um) {
            $um->{$_} =~ /^(?:(\d+)-)??(?:(\d)+)(?:-(\d)+)?$/
                || die "notunder: ".wdump 2, $um;
            $um->{$_} = {i=>$1,um=>$2,o=>$3};
        }
        1 && saybl "Lum C.t: ". wdump 2, $um;
        
        um.l.um ||= 3;
        my $lumhalvesby = (um.l.um / 2) / (um.r.um || 3);
        my $i = 0;
        for (@$M) {
            _.y.thy = 1 if !defined y.thy;
            _.y.thy+=um.l.um;
            $i++;
            if ($i > um.l.o) {
                um.l.um -= $lumhalvesby if um.l.um > 0.1;
            }
        }
    
    # 3 the allocations, M start happening
    # any gk on L to pull mo in here (nogindex)
    in: %of:L
    
    
    # uC fits curve
    barel 5: %of:L,v:cM
        my $total = sum(map{ _.y.thy || 1 } @$M) || 1;
        y.u.muav = @$M / $total;
    
    # could spiral much space away from spine
    # build wave plot manifold, solar systems
    many 6: %of:a
        y.mu = defined y.thy ? y.thy : 1;
        y.mu = y.mu * y.u.muav if y.u.muav;
        my $was = y.u.v;
        y.cv = G&roun,y.u.v unless defined y.cv;
        y.pcv = G&roun,y.i/y.u.y.thi;
        my $in = y.aspace * y.mu;
        y.u.v += $in;
        y.ov = G&roun,y.u.v;
        y.spc = y.ov - y.cv;

        C.sc.yspc = y.spc if C.sc.nspc;
        C.sc.ml = (C.y.over * 40)."%" if y.over;
    
    # feel effects of...
    # t-rewirey formulae:
    lum 7: %of:a,v:ylum
        my $upt = 0;
        y.spc = 0.1 if y.spc < 0.1;
        my $fs = y.spc * 20 * 4;
        s&fs = $fs if $fs < 9;
    
    # ground the creation
    ground 8: %of:L,v:cM
        shift @$M if $M->[0] eq $C;
        my $J = y.J || A.1;
        G&A,n=>8=>$J,$M;
    

