ImCom: | # ing
    T is your mess with the mind/world throughput
    ^ you are here, left is mind, right is world
    or up (at ElM) down (on Os)
    Os gather wormholes for reconvenience to ElM summers
    
    ghost host, telling ElMs of any change
    
    the inconceivables go in 5 (S, T)
    around them on the of are go implementors, skips
    
    D 9-99 can mess with outgoing K deletes with a valve
    
    
    
FactorEasy: | # arty maps
    u i
    # search last mo things top
    op:
        my $Wr = T.op || die "No Top to op";
        my $ub = !$s ? sub {
            my ($D,$d) = @_;
            $D if d.d == 2;
        } : do {
            my $C;
            C.t = 'oping';
            s&t = $s || die "No t to op";
            Rw conot $C;
            sub {
                my ($D,$d) = @_;
                $D if G&ip,s&ip,$D;
            }
        };
        my @ma = G&ind,$Wr,$ub,{noind=>1};
        @ma
Art: | # goner: collection of
    # Ang, of=Style etc which lives on 5
    # gives us a gateway over to it:
    n PaintedStripes
    
    #n Zpace
    # ^ only compilable on Os
    
    #n Texture
    # know/make patterns for believer's beliefs
JugleHue: | # y.mod for dealing out and colouration
    my $h = 0;
    my $d = 15;
    for (@$M) {
        _s&hue = $h += $d;
        _s&deal = 0.014;
    }
ModNs: | # modulate M with way, s=$way(:$s_arg)?
    if (ref $s eq 'CODE') {
        $s->(ar.M);
    }
    else {
        ar.J ||= A.1;
        my $z = $s =~ s/:(.+)// ? $1 : '';
        Rw $s + $s:z;
    }
nogindex: |
    my ($nk,$of) = split ':', $s;
    $nk && $of || die "not nk:of: $s";
    # reuses refs if they look the same:
    my ($tr,$i,$p) = G&superindex,'nogindex','ip';
    
    for (@$N) {
        _s&nk eq $nk && _s&of eq $of && _s&gk || next;
        $i.>_s&gk = _s&vatis || 1;
    }
    
    s&t = 1; # throat connected, if
    
    p.y.hasany = $i;
    if (s&vor) {
        my $r = $p.>s&vor = {};
        (r.nk,r.gk) = G&pang,s&vor;
        r.exi = 1; # exists
        p.y.or = 1;
        p.order = [s&vor,'y'];
    }
    
    $tr->();
ElvisZpace: | # T u Zpace fast, caching its s 76-
    # see also ElvuseZpace for checking thinking around here
    my $t = Rw Towering Ang
        || return;
    c&Se == 1 || return;
    
    T.H = 3;
    T.H = 5 if T.ray;
    t.e = 
    n Zpace
    t.cs->('sc top', "See");
    
Space: | # hang La space charts off mo
    u alact
    n \'of:L'
    y.at.coil = 'tldo';
    
    # fix Zuup re something
    
    # A.3 pools lists up from c.y.A.1 pi etc.
    # resuming back into itselves repeatedly
    # kind of go yonder, certain travelishing
        # oir rhythm style joins
    # ^ always wants a new one somewhere
        # 4d jelly slower-downer
            # TRansituio, soul spread
        # stackable A with stitchable others interleaved in time
        # 6 FLIES
    
    # create L uC, the space
    # plumb moment of cM or any of these nogindex'd things
    # documented just below
    M 15: %of:mo,tldo:nogindex:y:L,vor:cM
        return if C.y.a; # already placed
        return die "MdubL" if C.y.L; # already placing
        my $D = T.D;
        my $yknow = Ds&nogindex;
        return unless @{c&M||[]} || grep{C.y.>$_ } keys %$yknow;
        
        C.y.L = G&A,L=>8,{s=>$C,yknow=>$yknow};
    
    # an A for each of the many C
    # the graphspace (L) tugs the atoms (a) along with its computation
    # so C.y.a means the thing was a many, throw an untugged A on there
    # we can do everything from L tho...
    # L tugging slightly on mo would be more interesting
    0 &&
    a: %of:a
        #
    
    0 && # ground descript, floating tool
    J 69: %of:mo,v:sJ
        local A.V = 1;
        sayyl "HAve ".ki $C;
        saybl wdump 2, J.sc.root.c.s; # is n, look for A.c.mo
        my $uz = G&grind,$J;
        my $grimd = sub { 
            my $uz = shift;
            [map{my$c=_.c.s;"_.t _.cv: c.t c.y.cv ("
                .join(' ',sort keys %{c.c}).")  "
                .join(' ',sort keys %{c.sc})
            } map {$uz.>$_ } sort keys %$uz];
        };
        my $l = $grimd->($uz);
        push @$l, "For J.t";
        saybl @$l;
        
    # its y may be here if we are an atom within it
    
    # any gk of L to pull mo into an L (nogindex)
    M: %v:cM
        # etc
    n: %v:yn
        # to almost fill space
    spc: %v:yspc
        # to take up space
    u: %v:yu
        # to take space up til
    rev: %v:yspc
        # composite \d+ ? y.cyc : peels into y
    cyc: %v:ycyc
        # sweeping over itself, round and round
    erse: %v:yerse
        # flip n,u, stack floor to ceiling
    # so goes from ground to mind, instead of in to out
    # since we use y.in now for the first insider
    in 12: %v:yin,vatis:!ref
        C.y.n = delete C.y.in if !ref C.y.in;
    out 12: %v:yout,vatis:!ref
        C.y.u = delete C.y.out if !ref C.y.out
    
    #c L2 space to fill
    # if !M:
    #   y.in/out give it that much space & make holes in 1s&root's M
    #   y.thi that many C
    # 
    # L plots M as a, which may know more L/a around
    # C->root.c.M masses for piping parallel pi
    # sync around mo, can hang on/replot with 
    L 2:
        A&y && die "You Ay L 2: ".G&aC,$A ."\nAc: ".ki A.c;
        my $J = A.1;
        Jc&s || die "Jcs not holding mo C: ".G&sn;
        #local A.V = 1;
        # mo C that began the J we are now inside is the trick
        # we are probably at 17 of their root mo, which has c&M
        my $Jy = 1Cy&C;
        my $y = C.y;
        my $M = c&M;
        my $had = $M;
        $M ||= [];
        A&M = $M; # for the ModNs
        
        if (my $r = y.rev) {
            for my $r (split ' ', $r) {
                if ($r =~ /^\d+$/) {
                    y.cyc = $r;
                }
                else {
                    G&xot,$y,$_ for G&peel,$r;
                }
            }
        }
        
        #c y.man, $M-odulate before L does anything
        Rw ModNs $M $s:y.man if y.man;
        
        # positation of many from L C to a C lattice
        # what else to do with the L C?
        # may be the one to get multiplied out
        # always gets M
        if ($had) {
            # C had M
            # L C can be forgotten, probably mo'd with root in J6
            # it could be placement metadata/unity
            my @M;
            while (y.thi && @$M < y.thi) { # copies out to there
                @M = @$M if !@M;
                last if !@M;
                push @$M, G&hup,shift@M;
            }
            if (y.cyc && @$M > y.cyc) { # sweeping over itself
                my @M = splice @$M, 0, y.cyc while @$M > y.cyc;
                splice @M, 0, 0+@$M;
                push @$M, @M;
                # decommissions them?
            }
        }
        else {
            # is first in its own M
            # to make holes in space other M must flow around
            @$M = ($C);
            c&M = $M;
            push @$M, map { G&hup,$C } 1 .. y.thi - 1
                if y.thi > 1;
        }
        
        
        # limits apply, thi being for ^ iterator length 
        #                         and v limit of output
        my $lims = {};
        for (qw'thi') {
            $lims.>$_ = $y.>$_ if defined $y.>$_;
        }
        if (y.limn) {
            Jy.spc || die "No space! J.t";
            lims.limn = int(9 * y.limn * Jy.spc);
        }
        my $lim;
        while (my ($k,$v) = each %$lims) {
            @$M > $v || next;
            say "Limof: $k $v to C.t";
            $lim = $k if !$lim || $lims.>$lim > $lims.>$k;
        }
        if ($lim) {
            my $it = $lims.>$lim;
            my $from = 0;
            if (y.tail) {
                $from = -1;
                $it *= -1;
            }
            else {
                $it -= 1;
            }
            $lims = $lim; # name
            $lim = @$M; # limited from
            @$M = @{$M}[$from .. $it];
        }
        
        y.thi = @$M;
        y.thi || die "No M: ".ki $C;
        y.thi = y.cyc if y.cyc;
        
        # all should have some M by now
        # unless its itself with shape instructions but no content
        # would have posited itself
        !@$M || @$M == 1 && $M->[0] eq $C && c&root
            && return T.not = 1;
            
        #c & point/seek to things coming in with our surrounds
        
        # if we were placed with enough room
        # let atoms slide up to the top J
        # things saying they're in both places
        #   leads to nice grouping, ref integrity
        y.J = A.3 if Jy.spc > 0.1;
        delete y.J if y.clos;
        my $clos = Jy.spc && !y.J;
        #  they can want to be inside too
        #  geo to chain together floating/not atoms
        #  so its like wires over machines
        
        # ml (margin-left)
        # high lum makes tree bends up towards margin
        # like it is open inside, like bet. rummager.
        y.inde = Jy.inde + 0.06 if y.J;
        
        # sliver of attention
        my $sl = Jy.spc * 0.01;
        $sl = 0.02 if $sl < 0.02;
        # carpenting
        y.n ||= $clos ? 0.3 : Jy.J ? Jy.cv + $sl : 0.1;
        y.u ||= $clos ? 0.4 : Jy.J ? Jy.ov - $sl : 0.9;
        
        # set width
        y.u = y.n + y.space if defined y.space;
        if (y.erse) {
            (y.u,y.n) = (y.n,y.u);
            y.tail = y.thi; # lightly
        }
        
        # may be way less than 0...
        # a cv scaled back, will have defiantly huge spc
        y.u /= 10 until y.u < 1;
        y.n /= 10 until y.n < 1;
        # corner noted
        if ($lim) {
            my $s = "$lim>".@$M;
            my $cv = y.tail ? y.n : y.u;
            # TODO += here blows up zopul:
            $cv -= 0.002;
            my $M = A&XM ||= []; # labely meta
            m lim=>$cv,$s,'%fs:7,hs:7487,limit:'.$lims;
        }
        # fit in multiple of
        if (my $ert = y.ert) {
            $ert += y.ert while y.thi > $ert;
            y.thi = $ert;
        }
        y.space = y.u - y.n;
        my $outer;
        if (y.res) {
            $outer = y.space / y.thi;
            y.space -= $outer;
        }
        y.space *= -1 if y.space < 0;
        
        # space being an increasing Ls&v
        A.L = $A;
        ALs&v = y.n; # rolls
        ALs&v += $outer / 2 if $outer; #
        # average size
        ALs&aspace = G&roun,y.space/y.thi;
        # thy -> mu bends out
        ALs&Ly = $y; # u is shared placevolve meta
        my $i;
        for (@$M) {
            _.y.i = $i++;
            # could tugA,a
            _.y.a = G&A,a=>0=>{s=>$_};
        }
        # L can M the C also in a
    
    #c lum uC shapes curve, wants to be with limn
    # might mean a few lum qualities, make them switchupable
    # supposedly osc can measure itself, hoist geometry
    #    descriptions for ascii art buildings
    lum 23: %v:ylum
        my $M = c&M || die "lum no M";
        my $y = C.y;
        my $u;
        (u.l,u.r) = split ',', $lum;
        $u.>$_ = do {
            $u.>$_ =~ m/^(?:(\d+)-)??(?:(\d+))(?:-(\d)+)?$/
                || die "notunder: $_ ".wdump 2, $u;
            {i=>$1,u=>$2,o=>$3}
        } for grep {$u.>$_ } keys %$u;
        u.l.u ||= 3;
        u.r.u ||= u.l.u / 4;
        u.l.o ||= u.r.u / 3;
        my $i = 0;
        for (@$M) {
            _.y.thy = 1 if !defined y.thy;
            _.y.thy += u.l.u;
            $i++;
            if ($i > u.l.o) {
                u.l.u -= 2 if u.l.u > 0.1;
            }
        }
    
    #c y.bal modulation after lum formula, before togethering/allocations
    bal 3: %v:ybal
        my $M = c&M;
        
        Rw ModMs $M $s:bal;
    #c refit cv by t, spawn L per added pieces
    # to fit back into M above,
    refit 4: %v:yres
        #local A.V = 2;
        my $y = C.y;
        my $M = c&M || die "refit no M";
        y.res == 2 && return
            saygr "A.1.t fits ".@$M." into C.t";
        my $res = y.res = 1s&res.>C.t ||= {res=>$res};
        my $ctv = res.ctv ||= {};
        my $la; # known from
        my @news;
        my $bend = sub {
            my ($from,$to,@M) = @_;
            @M = map {
                _.y.a || die "has no ya: ".ki$_;
                _.y.a.c.s eq $_ || die "ya cs not _: ".ki[_.y.a.c.s,$_];
                # their a C becomes for cv/spc for real heighting etc
                _.y.realy = _.y.a.c.s = G&hup,_.y.a.c.s;
                # takeover original ref:
                $_
            } @M;
            my $nu = G&Ct,["Bend$from->$to",{}];
            nu.y.n = $from;
            nu.y.u = $to;
            nu.y.res = 2; # makes spc/2 away from edges but not M<>ctv
            nu.c.M = \@M;
            nu.c.oM = [];
            # ^ our ground splices this L's stuff into $M
            # as it is A.y=A in an M of C
            G&tugA,L=>4,$nu;
        };
        A&refit_t ||= 1c&refit_t || &C{ C.t };
        return keys %$ctv &&
            saygr "All new refit C.t C.y.res -- ".G&sn
            unless grep{ my $t = A&refit_t->($_); $ctv.>$t } @$M;
        my @M;
        for (@$M) {
            my $t = A&refit_t->($_);
            my $at = $ctv.>$t;
            if ($at && !_.c.refit) {
                sayyl "Have $t  -> $at";
                if ($la && $at < $la) {
                    # has to opt out for M order via c&refit
                    # la cause may have moved out already
                    saybl " is from earlier";
                }
                _.y.cv = $at;
                push @M, $_;
                if (@news) {
                    # bend @news between $la and $_
                    $la ||= y.n;
                    saygr "Bend from $la to $at:\n".ki \@news;
                    push @M,
                        $bend->($la,$at,@news);
                    @news = ();
                }
                $la = $at;
            }
            else {
                saybl "New $t".(_.c.refit && " (repo)");
                push @news, $_;
            }
        }
        $bend->($la,y.u,@news) if @news;
    
    #c L fits curve, many, res, lum
    barel 5: %v:cM
        my $y = C.y;
        my $total = sum(map{ _.y.thy || 1 } @$M) || 1;
        ALs&muav = @$M / $total;
    
    # a eats space, sliding ALs&v along (Ya-Habibi)
    # spiral much space away from spine
    # build wave plot manifold, solar systems
    # TODO: causes Mudit to place a out of order (tug..?):
    #many 6: %of:a
    many 6: %v:cM
        for my $C (@$M) {
            my $y = C.y;
            y.mu = defined y.thy ? y.thy : 1;
            y.mu = y.mu * ALs&muav if ALs&muav;
            my $was = ALs&v;
            y.cv = G&roun,ALs&v if !y.cv;
            y.pcv = G&roun,y.i/ALs&Ly.thi;
            my $in = ALs&aspace * y.mu;
            ALs&v += $in;
            y.ov = G&roun,ALs&v;
            y.spc = y.ov - y.cv;

            C.sc.yspc = y.spc if C.sc.nspc;
            C.sc.ml = (ALs&Ly.inde * 40)."%" if ALs&Ly.inde;
        }
    
    # feel effects of...
    res 7: %v:yres
        ref $res || return;
        my $y = C.y;
        my $M = c&M;
        my $ctv = res.ctv;
        for (@$M) {
            my $t = A&refit_t ->($_); # TODO store from 4
            $ctv.>$t && delete $ctv.>$t;
            $ctv.>$t = _.y.cv || die "No cv res yet: ".ki$_;
        }
    
    # t-rewirey formulae:
    lum 7: %v:ylum
        my $M = c&M || die "lum no M";
        for my $C (@$M) {
            my $y = C.y;
            my $upt = 0;
            y.spc = 0.01 if y.spc < 0.01;
            my $fs = y.spc * 20 * 4;
            if (c&helum) {
                s&he = G&rou,$fs/c&helum;
            }
            else {
                $fs = 3 if $fs < 3;
                s&fs = G&rou,$fs;
            }
        }
    
    #c ground into creation
    ground 8:
        my $M = c&M || die "L 8 with no M: ".ki$C;
        my $y = C.y;
        # first was ourself that is already in mo
        shift @$M if $M->[0] eq $C;
        my $J = y.J || A.1;
        A&XM && push @$M, @{A&XM}; # labely meta
        # resolve any L in M to its many
        @$M = map {
            my $oM = _.y eq $_ && (_.c.s.c.oM || die
                "NoM on inner _.t from C.t: ".ki _c&s );
            $oM ? @$oM : $_
        } @$M;
        # stash out many for the above
        c&oM && return push @{c&oM}, @$M;
        if (A.V || 1c&Mhat) {
            1 && sayyl "For J.t: ";
            1 && saygr "_.t: _.y.cv (spc=_.y.spc)" for @$M;
        }
        
        #c y.mod, $M-odulate after cv-ation, before ground/mo
        Rw ModNs $M $s:y.mod if y.mod;
        if (!@$M) {
            my $inte;
            $inte.>$_ = $y.>$_ for grep{$y.>$_ } keys %{A&yknow};
            1 && sayre "NOthing!? in M C.t"
                .($inte && ": intyresty: ".ki $inte);
            return
        }
        # all should be C
        ref $_ eq 'HASH' && _.y && _.y ne $_
            || die "notC L M: ".ki($_)."\n  Midst: ".ki $M
            for @$M;
        G&A,mo=>8=>{s=>$_} for @$M;
    

