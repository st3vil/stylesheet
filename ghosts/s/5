Hoop: | # osc art, colour in
    u a
    O 1:
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = G&hup,A&from;
        # G&hup,
    O 2:
        C.y.A = $A;
        #return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    
    # indexes posited awake
    O 4:
        for my $W ('oft','of') {
            if (my $Wt = C.sc.>$W) {
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        if (my $J = s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.ii; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    for my $z (@{ Ds&z }) {
                        a&swim.>D.c.W.>D.t.>D.y.cv.>z.t.>z.y.cv = $z;
                        saybl "^ A.1.t's J.t's z.t z.y.cv swims to D.t-D.y.cv-D.c.W";
                    }
                    $D = D.y.over
                }
            }
        }
        # not needed? Hoops all the C inside..., they of
        # when swallowing whole=thingwithz
        elsif (0 && c&W && C.y.in && C.y.in.y.cv != 0.9) {
            # freeze dried ii composed into o, a base set
            my $S = C.y.in;
            while ($S) {
                a&swim.>C.c.W.>C.t.>C.y.cv.>S.t.>S.y.cv = $S;
                1 && saybl "^ A.1.t's S.t S.y.cv swimeth C.t-C.y.cv-C.c.W";
                $S = S.y.next;
            }
        }
    
    # shrinkwarp
    O 7:
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        if (s&J) {
            if (s&W) {
                # W implies J in mo:W:12, they can look it up
                delete s&J if s&W eq s&J;
            }
        }
        
        if (my $J = s&J) {
            # ^ should be o'd for lv, updates inc root.9 z onto here
            # unless C.sc.qz (quiet z)
            # unless s&W (they can look it up)
            
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
            }
            else {
                s&J = Js&name || J.t;
            }
            1 && saybl "J.t was J.sc.name";
        }
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs qz sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
        
Komp: | # K/D line protoClattice
    u a
    K 1:
        A.c.s = shift @$s; # us
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        my $beam = "C.y.cv  C.t   ".ki(C.c)."      ".ki(C.sc||{});
        $beam =~ s/\n/\\n/g;
        sayyl "K: $beam";
        
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $l = C.y.l || die "No KC yl: ".ki$C;
            my $J = ls&J || die "No sJ for Jo K: ".ki$l;
            if (!ref $J) {
                # Hoop probably mutes sJ, go back before o zip for it
                my $r = l.y.r || die "KCyl no yr: ".ki$l;
                my $o = r.c.o || die "KCylyr no co: ".ki$r;
                my $D = o.y.D || die "KCylyrco no yD: ".ki$o;
                # ^ ours from zip, Hoop munted 
                my $Dr = D.y.r || die "KCylyrcoyD no yr: ".ki$D;
                my $Do = Dr.c.o || die "KCylyrcoyDyr no co: ".ki$Dr;
                my $CJ = Do.c.s || die "KCylyrcoyDyrco no cs: ".ki$Do;
                $J = CJ.sc.J || die "KCylyrcoyDyrco no sJ: ".ki$CJ;
            }
            my $x = l.y.x || die "KCyl no yx: ".ki$l;
            my $lo = xc&Jo;
            if ($lo ne c&Jo) {
                my $s = Js&s || die "No s on J for K Jo lv: ".ki$J;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # imp++ means lv restarts
                # wil++ means lv grows
                my $wil = xc&Jowil || 1;
                my $conti = sc&imp eq xc&Joimp && $lv eq xc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                xc&Jolv = $lv;
                xc&Joimp = sc&imp;
                xc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # Hoisting,
        }
        # mute refs
        # tells you things that are not there, see o 7 apply
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                next if $nk eq 'sc' && $gk eq 'z';
                next if $ref eq 'CODE';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
    D 2:
        # reverse it
    
WaysAcro: | # osc thing through cached pi into meta/waytogetat
    # install libaudio-scan-perl
WhereAmI: | # 
    # install lshw
Tan: | # encodings

    u O
    0 &&
    of: %of:O
        #n $s=>''=>{W=>'of'}
        say "OFing ! C.t C.y.cv ".ki C.sc;
        # compile language, see 9 cono
        # container process is traveling bunches of code, see 99 Traweil
        # place toward A.ii.>$s, linked list of embryo
        
        # rennovating around town
        # a geodesic self-mover
        # keeps rebuilding in different locations
        
Tal: | # displayings
    u i
    say: %nobasay
        $s eq 'saygr' ? saygr(@Me) :
        $s eq 'sayyl' ? sayyl(@Me) :
        $s eq 'saybl' ? saybl(@Me) :
        $s eq 'sayre' ? sayre(@Me) :
        $s eq 'say' ? say(@Me) :
        die "New kinda talk: $s\n".wdump 2, \@Me;
        

