Well: | # it had to be
    =pod
    
    The many, the usual + qualation
    
    =head1 Qualation
    
    Is an understanding of a universal for Circle to know
    For knowing its yay C character or an index to thing
    Entering sc.l as a travels left join
      or sc.jointed as a $how/$J=$J or however thing
      osc just says it changed
        but it can have its own scan limits
      someone then must read the beyond-C stuff
      as in Matu, etc
        wants to do data grabbing by a pattern
        which reveals sleepables.
        see Tripical/Tripserv
    
    =cut
Triangle: | # <>< swim, oscillator, s n, 7, 
    u a
    # sevenatim
    # time passes independently of your being in the room
    #c s1 once you know about the room
    # C is current page's s particle, in J.sc.s
    s 1:
        A.1 = shift @$s;
        A.s = $C = A&s = G&sJ,A.1,'s';
        s&J = A.1;
        A.sA = $A;
    #c s2 peel ground moments
    s 2:
        # parameters plugged in to s.sc from Jc
        my $pl;
        pl.gripo = delete 1c&gripo;
        pl.base = 1c&base;
        pl.parts = delete upCc&parts;
        pl.whole = 1c&whole;
        while (my ($k,$v) = each %$pl) {
            delete(C.c.>$k), next if !defined $v;
            C.c.>$k = $v;
        }
        my $whole = c&whole;
        
        if (!c&parts && c&imparted) {
            # contains another imping s to resume branching from
            G&imparted;
        }
        
        if (delete 1c&imping) {
            # zipover/zopul/etc reoccur through
            delete C.sc.>$_ for qw'jo swim';
        }
        
        # TODO make C.t for the page of ground this s (C) is for
        # J.t can wander
        my ($zip,$ch) = G&grind,A.1;
        G&always,C.sc,ch=>$ch || die "Chinout: s&ch $ch";
        
        
        # complexity hider, T may want to tho
        $whole = delete c&base if c&base && !$zip;
        A&V = A.1 eq A.3 && A.2.t ne 'u' && A.1.t =~ /^[A-Z]/;
        
        if (my $W = $whole) {
            my $s = ref $W && $W || G&Wup,$W || G&t,$W || die "no $W on ".G&sn;
            # s is a top not an s, but has s.y.s for s
            sayre "WHole! s: A.1.t: s.t" if A&V;
            # m=A makes meta looks
            A&who = G&A,o=>8,$C,$s,'whole',{m=>'A'};
            # s C or J, s&top and/or y.in etc to copy
            # if s.sc.ii/s.y.s.sc.ii (etc) then copy too
            # repoint as tv to this side, to C.sc.ii
            # which is our top.y.s.sc.ii (etc)
            # 
            # gives us s&top, tv, i/ii like osc
            #   can make our own lv for our slice of it
            # letting us export it to the J in 8
            # place on us, eg u.sc.ii, you must 
            return T.Z.8 = $A;
        }
        
        # shade .c down to s (whole/imparted doesn't)
        my $oc = {shade=>1};
        my $tug;
        if (my $d = c&parts) {
            G&imparts;
            return T.Z.76 = $A if c&imparted;
            return T.Z.8 = $A if delete c&sameparts;
            $d = G&hup,$d;
            # have frozen stuff's top
            # make flat z that c&root elects top
            # so o histories (j) work for full J/zip
            my $z = [$d, @{ delete ds&z || []}];
            d.c.root = 1;
            # also, had ground before, now just parts
            undef $zip;
            # parts o are hoisted to zip o
            # things
            oc.nonext = oc.noyin = 1;
            tug.parts = G&A,o=>2,$C,$z,'parts';
        }
        if (my $W = c&base) {
            my $s = ref $W && $W || G&Wup,$W || G&t,$W || die "no $W on ".G&sn;
            sayyl "Base ! ".ki $s;
            my $z = ss&z || s.y.in;
            # TODO know top C with settling clues
            # see s&top above
            tug.base = G&A,o=>2,$C,$z,'base';
        }
        if ($zip) {
            tug.ground = G&A,o=>2,$C,$zip,'zip';
        }
        $tug || die "No ground to A.1.t";
        
        
        c&zip = G&A,o=>6,$C,$tug,'zipover',$oc;
        G&A,c&zip=>6;
    #c s3 changes -> O
    # ordered by o, creates O per C to be awake
    # zip is good for a look at whats entering the osc
    s 3:
        my $o = c&zip;
        my $c = oc&s;
        my $j = cc&j || die "No o Acj! ".ki$c;
        
        if (!@{ os&zop }) {
            A&V && saybl "No changes: C.t ".G&sn,5;
            return T.Z.8 = $A;
        }
        
        A&inz = [map {
            my $O = G&A,O=>1,$_;
            a&topO = $O if os&top eq $_;
            my $c = O.c.s;
            c.y.x.y.O = $O; # follow to bring O up to date
            my $r = c.y.r || die "No yr: ".ki$c;
            Oc&el = rc&el if rc&el;
            # can see our s/A on A.s/sA
            # might like to be handed changes from r
            # and origin, somewhere like 
            $O
        } @{os&inz}];
        
        A&outz = [map {
            if (_.sc.J && !_.sc.W) {
                if (1s&Jtv && 1s&Jtv.>_.t && 1s&Jtv.>_.t.>_.y.cv) {
                    delete 1s&Jtv.>_.t.>_.y.cv;
                }
            }
            _.y.x.y.O || die "out not yxyO: ".ki $_;
        } @{os&outz}];
        
        # put through Hoop to make index & self
        G&A,$_,8 for @{A&inz};
        
    #c s4 humming
    # elsward going index posited awake
    # see ElBridge/their
    #   for more of the semi-sleeping grouper
    s 4:
        s&swim ||= {};
        s&swam = {};
        for my $O (@{A&inz}) {
            my $c = O.c.s;
            my $X = c.y.x.y.X;
            my $x = X.c.s;
            Os&swim || Xs&swim || next;
            G&chew,Os&swim,'W,Wt,Wcv',$_ for sub {
                my ($etv,$W,$Wt,$Wcv) = @_;
                # to order the C swimming bunches by origin yt
                s&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv} = $c;
                s&swam ->{$W}->{$Wt}->{$Wcv}++;
            };
            G&chew,Xs&swim,'W,Wt,Wcv',$_ for sub {
                my ($etv,$W,$Wt,$Wcv) = @_;
                # keep swim from the C unless all etv gone
                my $sb = Os&swim ->{$W}->{$Wt}->{$Wcv};
                for my $et (keys %$etv) {
                    for my $ecv (keys %{ $etv.>$et }) {
                        $sb.>$et && $sb.>$et.>$ecv && return;
                    }
                }
                delete s&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv};
                s&swam ->{$W}->{$Wt}->{$Wcv}++;
            };
            c.y.x || die "O C no yx joinery: ".ki $c;
            c.y.x.y.X = $O;
        }
        for my $X (@{A&outz}) {
            my $c = X.c.s;
            G&chew,Xs&swim,'W,Wt,Wcv',$_ for sub {
                my ($etv,$W,$Wt,$Wcv) = @_;
                delete s&swim ->{$W}->{$Wt}->{$Wcv}->{c.t}->{c.y.cv};
                s&swam ->{$W}->{$Wt}->{$Wcv}++;
            };
        }
    #c s5 across the wormhole
    # things have animal desires
    s 5:
        A&ytWe = {};
        # Wtv swam awakes Wtv in swim to a tv of froms
        # froms yA.sc.swim ^ and then tv of sent/elvising
        # so puts tv in Wtv
        G&chew,s&swam,'W,Wt,Wcv',$_ for sub {
            my ($ctv,$W,$Wt,$Wcv) = @_;
            $ctv = s&swim ->{$W}->{$Wt}->{$Wcv};
            # froms in order so it clobbers
            my $yt = G&yttv,$ctv;
            my $z = [];
            G&chew,$yt,\'cv,t',$_ for sub {
                my ($c,$cv,$t) = @_;
                my $O = c.y.A;
                my $etv = Os&swim ->{$W}->{$Wt}->{$Wcv};
                # this c is pushing tv to Wtv
                my $eyt = G&yttv,$etv;
                # ordered ^ for the occasional test looking at details
                G&chew,$eyt,\'cv,t',$_ for sub {
                    my ($es,$et,$ecv) = @_;
                    # the pushed thing, probably c itself - separates
                    $es = G&hup,$es if $es eq $c;
                    push @$z, $es;
                };
            };
            if (my $al = A&ytWe ->{$Wcv}->{$Wt}) {
                die "swim $W $Wt $Wcv already al.c.W";
            }
            if (!@$z) {
                delete s&ytWe ->{$Wcv}->{$Wt};
                return;
            }
            # wants to W source from A.3 only...
            my $e = G&Ct,[Swim=>3,{z=>$z}];
            s&ytWe ->{$Wcv}->{$Wt} =
            A&ytWe ->{$Wcv}->{$Wt} =
                G&Ct,[$Wt=>$Wcv,{W=>$W,e=>$e,nogro=>1}];
        };
        sayyl "s5   A.1.t";
    #c s6 goes
    s 6:
        # going - figure difference under top with osc'd
        my $t = a&topO;
        $t = t.c.s;
        my $tv = t.y.tv;
        # from zip ourob, yx (its expandings) has yO (osc time)
        # which holds the carbon with the effect
        my $z = [];
        each tyZ $tv {
            my $x = Z.y.x || die "no yx bridge: ".ki$Z;
            my $O = x.y.O || die "No yxyO on ".ki$Z;
            if (my $T = O.c.T) {
                next if T.not;
            }
            my $C = O.c.s; # clone of $_, zip ourob
            C.y.A eq $O || die "C not yA=O ".ki$C;
            push @$z, $C;
        }}
        
        
        # mix in anything z Js want to export to here (ii)
        # look for their yl in previous ylytvs to give hierarchy
        # make dupes here > through from Js (TODO) later yt of positor > earlier
        
        # and W returns
        # mix in unswam ytWe without doing
        my $Wez = [];
        G&chew,s&ytWe,\'Wcv,Wt',$_ for sub {
            my ($We,$Wcv,$Wt) = @_;
            my $D = We.c.D;
            if ($D) {
                # no swimming
            }
            else {
                # Tunnel e wants to know in general:
                #   We may provide forms of ground to return results
                #   e z may o and send diffs depending on connection
                # for now modemless e.c.z in, n.sc.z out
                my ($mo) = values %{_.c.tug} for
                
                G&elph,\'nomem',$We;
                
                my $W = mo.c.s;
                $D = G&Ct,[$Wt=>$Wcv,{W=>We.c.W}];
                Ds&z = Ws&z;
                #Ws&z || sayre "W no z ".ki$W;
                Ds&z ||= We.c.e.c.z;
                We.c.D = $D;
            }
            push @$z, $D;
            push @$Wez, $D;
        };
        
        #c coil feeds unification causes all We things
        if (my $o = ts&coil) { # root.sc/y.at
            my $N = [map {@{_.sc.z}} @$Wez];
            for my $o (split ' ',$o) {
                my $s = $1 if $o =~ s/:(.+)//;
                # ^ guidance more likely from the C using this point to unify:
                for my $C (grep { _.sc.>$o }@$N) {
                    my $way = C.sc.>$o;
                    my $s = $way =~ s/:(.+)// ? $1 : $s;
                    Rw $way $C $N $s
                }
            }
        }
        
        
        $t = G&hup,$t;
        delete t.y.in;
        t.sc.z = $z if @$z;
        delete t.sc.z if !@$z;
        
        my $o = c&zop = G&A,o=>6,$C,$t,'zopul';
    #c s7 traction/compress - dig out root    --> K
    s 7:
        # K packs down goods
        # zops are el and change Cs, have y l (
        my $o = c&zop;
        A&zop = [map {
            my $K = G&A,K=>1,$_;
            Kc&osc = $C;
            my $c = Kc&s;
            # l is indexed whole
            my $l = c.y.l || die "No yl (in O, hupd): ".ki$c;
            # x tracks falling wavelets
            my $x = l.y.x || die "No ylyx: ".wdump 2,$l;
            x.c.K = $K;
            if (A&ytWe && A&ytWe ->{c.y.cv} && A&ytWe ->{c.y.cv}->{c.t}) {
                # put in s&iiyt to squish into s&ii
                # store in x for when 9 because no ytWe
                die "ytWe el 9: ".ki $c if cc&el eq '9';
                s&iiyt ->{c.y.cv}->{c.t} = $l;
                x.c.wasin.iiyt = 1;
            }
            if (cc&el eq '9') {
                for my $in (keys %{x.c.wasin||{}}) {
                    if ($in eq 'iiyt') {
                        delete s&iiyt ->{c.y.cv}->{c.t};
                        keys %{s&iiyt ->{c.y.cv}} ||
                        delete s&iiyt ->{c.y.cv}->{c.t};
                    }
                }
            }
            elsif (l.y.tv) {
                c.sc.z = [];
            }
            
            if (my $up = l.y.up) {
                my $ux = up.y.x || die "Up from c.t no x: ".ki$up;
                my $uK = ux.c.K || die "upyx no K: ".ki$ux;
                my $U = uK.c.s || die "No C in upyxcK: ".ki$uK;
                ref U.sc.z eq 'ARRAY' || die "upKCsz not array: ".ki($U)
                    .wdump 2, l.y.o;
                # an lv/ely plant between K C
                push @{U.sc.z}, $c;
            }
            $K
        } @{os&zop}];
        
        G&A,$_=>8 for @{A&zop}; # K
        
        # no K/zop may mean a sublte c.Jo/something awoke it
        # but the change fell through/is handled otherwise,
        # eg xo, hoisting 
        # the index we pool up using of knowledge for geo
        # makes stats bubbling to the top
        # each index geo/type knows spherical sanity (re largeness)
        # so osc tracksobjects piping whatever
        # with the {} replace/whatever trick on of=T
        return T.Z.78 = $A if !@{A&zop};
    #c log log
    s 73:
        s&lastK = A&zop ->[0] || die "no change by 73? ".G&sn;
        my $c = s&lastK.c.s || die "noshc";
        
        A&waschange = 1;
        
        local c&imp, local c&wil, local c&mat if delete c&gripo;
        
        # lv is K log, have y.everything
        if (cc&el < 3) {
            c&imp++;
            c&wil = 1;
            c&mat = 1 if c&mat;
            s&lv = [$c];
        }
        else {
            c&wil++;
            c&mat = 1 if c&mat;
            if (my $la = @{s&lv} && s&lv ->[-1]) {
                # TODO could wire forward/back
                # check back is our last eg blogs
            }
            # TODO there's wire/sJ/sA free lv maker
            # yA K has clues for writing liney/etc text
            push @{s&lv}, $c;
        }
        s&KC = $c;
        
        # top is our C this side of zop
        s&top = c.y.l;
        
        
    #c index index
    # may be flung thawing top and iiyt to rebuild
    s 76:
        my $l = s&top;
        # top is this side of zop or thawed stuff
        # also (A | s&lastA).sc.topO = zip out top as O A
        #   which hup into Hooped
        # and s&lastK is zop out top as K A, incremental changes
        #   mungled by Komp
        # maintained by ...
        s&tv = l.y.tv || {};
        
        my $bu;
        # ii is tw of We things
        bu.ii = {};
        if (keys %{ s&iiyt ||{} }) {
            G&chew,s&iiyt,\'cv,t',$_ for sub {
                my ($l,$cv,$t) = @_;
                if (my $o = bu.ii->{$t}) {
                    # join We things above next/prev
                    # climbing down a ladder into a hole
                    o.y.over = $l;
                    l.y.under = $o;
                }
                else {
                     bu.ii->{$t} = $l;
                }
            };
        }
        # i is t -> c.code, from We thing i tw
        bu.i = {};
        if (my $i = bu.ii.i) {
            my $itw = i.y.tw || die "No ytw on ii_i: ".ki $i;
            while (my ($t,$c) = each %$itw) {
                my $code = c.c.code;
                $code || sayre("No code on itw: ".ki$c);
                $code || next;
                bu.i->{$t} = $code;
            }
        }
        
        # only osc.sc have such index
        # unless otherwise whacked out
        # top.y.s is osc
        # so we can host/W the top unto u/whole/base 
        # later should see C.y.A is for osc..?
        while (my ($k,$v) = each %$bu) {
            for ($C) {
                if (values %$v) {
                    _.sc.>$k = $v;
                }
                else {
                    delete _.sc.>$k;
                    
                }
            }
        }
    #c open con flux, uphoisting xo
    # here even if zop still (O mutes its own stimuli, eg Jo)
    # but not if zip still (no O)
    0 &&
    s 78:
        # other
    #c s8 transfer, send out
    s 8:
        my $l = s&top;
        G&always,l.y,s=>$C || die "s top ys elswhere: "
                            .wdump 3,[$l,l.y.s,G&sn ];
        # root of this cone branch
        s&lastA = $A;
        # export outsides
        A&expo.>$_ = 1 for qw'top tv i ii xo';
        my $J = A.1;
        for (keys %{A&expo}) {
            if (exists C.sc.>$_ ) {
                J.sc.>$_ = C.sc.>$_
            }
            else {
                delete J.sc.>$_;
            }
        }
        # + page of itself
        # + layering of stable/sprawly lv
        #     c/sc in a larger sense, dna/rna of this temple of truth
        #   awaits o branching or so...
        # also G branching, where to put this...
        
        Jc&o = c&o = "Steved ".c&imp." ".c&wil.(c&mat && " ".c&mat);
        
        # beyond nothing/mat changing, pump news, send out
        if (A&waschange) {
            if (my $t = Jc&tape) {
                for my $t (split ' ', $t) {
                    my $s = $1 if $t =~ s/:(.+)//;
                    my $sc = G&peel,$s if $s;
                    G&elph,$t=>[s=>8=>{s=>$C},$sc];
                }
            }
            if (my $s = Jc&sang) {
                $s->($A,$C,$G,$T);
            }
        }
        
Hoop: | # live the C, colour art in, make swims
    u a
    # for any zip change (and its parents)
    O 1:
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = $C = G&hup,A&from;
        # C is (was) the l from zip
        my $x = a&x = C.y.x || die "OC no yx: ".ki$C;
        if (my $J = s&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
        T.not = 1 if C.sc.not eq '1';
        # G&hup,
    O 2:
        C.y.A = $A;
        #return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    
    # indexes posited awake
    O 4:
        # universals on the ground
        for my $W ('oft','of') {
            if (my $Wt = C.sc.>$W) {
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                saybl "A.1.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        
        # indexed ground within universals
        if (my $J = s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.ii; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    my $S = D.y.in || die "A.1.t's J.t's scii D.t no in";
                    while ($S) {
                        a&swim.>D.c.W.>D.t.>D.y.cv.>S.t.>S.y.cv = $S;
                        saybl "^ A.1.t's J.t's S.t S.y.cv swims to D.t-D.y.cv-D.c.W";
                        $S = S.y.next;
                    }
                    $D = D.y.over
                }
            }
        }
        
        # not needed? Hoops all the C inside..., they of
        # when swallowing whole=thingwithz
        elsif (0 && c&W && C.y.in && C.y.in.y.cv != 0.9) {
            # freeze dried ii composed into o, a base set
            my $S = C.y.in;
            while ($S) {
                a&swim.>C.c.W.>C.t.>C.y.cv.>S.t.>S.y.cv = $S;
                1 && saybl "^ A.1.t's S.t S.y.cv swimeth C.t-C.y.cv-C.c.W";
                $S = S.y.next;
            }
        }
        
        if (my $sel = 1s&sels) {
            while (my ($k,$els) = each %$sel) {
                exists C.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    A&el eq $el || A&el eq '2' && $el eq '1' || next;
                    $do->($A,$C,$G,$T);
                }
            }
        }
    
    O 5:
        return unless A.ii.S;
        local A.cv = 0.4999;
        local A.ov = 0.5999;
        G&throat,'S';
    
    # O 6 - hoisting, ElBridge/xo
    
    # shrinkwarp for our tv, 
    O 7:
        delete c&Jo if s&W;
        
        # is wrong in js, update to fix
        s&height = delete s&he if s&he;
        
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
        
Komp: | # K/D line protoClattice, post prod
    u a
    K 1:
        A&from = shift @$s; # us
        A&s = $C = G&hup,A&from;
        my $l = a&l = C.y.l || die "No KC yl: ".ki$C;
        my $x = a&x = l.y.x || die "KCyl no yx: ".ki$l;
        if (my $J = ls&J) {
            a&J = $J;
            a&ys = Js&s || die "No s on J for K Jo lv: ".ki$J;
        }
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        my $l = a&l;
        delete c&Jo if ls&W || ls&qz;
        if (c&Jo) {
            s&z && die "Jo with z: ".ki$C;
            my $J = a&J || die "No sJ for Jo K: ".ki$l;
            my $x = a&x;
            my $lo = xc&Jo;
            if ($lo ne c&Jo) {
                my $s = a&ys;
                my $lv = ss&lv || die "No lv on J s for K Jo lv: ".ki$s;
                # J are names on a branch, their content evolves
                # imp++ means lv restarts
                # wil++ means lv grows
                # mat++ means out of band stuff changes, xo
                my $wil = xc&Jowil || 1;
                my $conti = sc&imp eq xc&Joimp && $lv eq xc&Jolv;
                $wil = 1 if !$conti;
                
                my $lets = !$conti || sc&wil > $wil;
                $wil += 1 if $conti; # slice after already
                my @new = @{$lv}[($wil-1) .. (sc&wil-1)] if $lets;
                
                xc&Jolv = $lv;
                xc&Joimp = sc&imp;
                xc&Jowil = sc&wil;
                s&z = \@new if @new;
                delete c&Jo;
            }
            else {
                1 && saygr "Same Jo: C.t C.y.cv @ $lo";
            }
            # other hoistings in O 6/s -8, eg xo
        }
        if (my $J = s&J) {
            # scJ could describe it, versions at head/remote
            # place it, in a net, can talk to with the address
            if (s&pi) {
                # implies s&J, which remains in osc C but not Komp
                delete s&J;
                delete c&s if Js&tv; # has inside
            }
            else {
                s&J = Js&name || J.t;
            }
            # W implies J in mo:W:12, they can look it up
            delete s&J if ls&W eq s&J;
        }
    # set Js&Kels.sending.3 = $s to G&h,$s for sc.sendings el3ing
    K 3:
        my $l = a&l;
        my $r = l.y.r || die "no lyr";
        rc&el || die "no rcel";
        if (my $sel = 1s&Kels) {
            my $up = l.y.up;
            if ($up && up.y.cv eq 0.9) {
            while (my ($k,$els) = each %$sel) {
                exists l.sc.>$k || next;
                while (my ($el,$do) = each %$els) {
                    rc&el eq $el || rc&el eq '2' && $el eq '1' || next;
                    G&h,$do;
                }
            }
            }
        }
    K 4:
        # mute refs
        # tells you things that are not there, see o 7 apply
        s&z = delete s&zout if s&zout;
        my $ok;
        ok.sc.>$_ = 1 for qw'z ip';
        G&oh,$ok,3s&oks if 3s&oks;
        for my $nk ('c','sc') {
            my $gh = $C.>$nk;
            my $mute;
            for my $gk (keys %$gh) {
                my $ref = ref $gh.>$gk || next;
                # eg nogindex 
                next if $ok.>$nk && $ok.>$nk.>$gk
                    || $nk eq 'sc' && $gk =~ /ex$/;
                next if $ref eq 'CODE';
                # and if in some known universal
                # We stirred index piling into here
                # eg Stripes...
                delete $gh.>$gk;
                $mute.>$gk ++;
            }
            if ($mute) {
                my @gks = sort keys %$mute;
                my $k = 'm'.substr($nk,0,1);
                exists C.c.>$k && die "Komp already c $k: ".ki$C;
                C.c.>$k = "@gks";
            }
        }
        delete C.sc.>$_ for qw'qz';
        
    D 2:
        # reverse it
    
Tal: | # displayings
    u i
    say: %nobasay
        $s eq 'saygr' ? saygr(@Me) :
        $s eq 'sayyl' ? sayyl(@Me) :
        $s eq 'saybl' ? saybl(@Me) :
        $s eq 'sayre' ? sayre(@Me) :
        $s eq 'say' ? say(@Me) :
        die "New kinda talk: $s\n".wdump 2, \@Me;
        

