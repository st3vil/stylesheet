Hoop: | # osc art, colour in
    u a
    O 1:
        # from = C out of o in osc, yryoyD is origin mo C
        # themselves yin/ynext etc will point to from
        A&from = shift @$s;
        A&s = G&hup,A&from;
        # G&hup,
    O 2:
        C.y.A = $A;
        #return T.not = 1 if A&el eq '9';
        # if 9 unposit T and disappear
    
    # indexes posited awake
    O 4:
        for my $W ('oft','of') {
            if (my $Wt = C.sc.>$W) {
                my $Wcv = s&Wv || 0.001;
                $Wcv /= 10 while $Wcv >= 1;
                a&swim.>$W.>$Wt.>$Wcv.>C.t.>C.y.cv = $C;
                1 && saybl "A.2.t's C.t C.y.cv swims to $Wt-$Wcv-$W";
            }
        }
        if (my $J = s&J) {
            # tune to s page? assume simple
            my $tw = J.sc.ii; # Water
            for my $t (keys %$tw) {
                my $D = $tw.>$t;
                while ($D) {
                    for my $z (@{ Ds&z }) {
                        a&swim.>D.c.W.>D.t.>D.y.cv.>z.t.>z.y.cv = $z;
                        1 && saybl "^ A.2.t's J.t's z.t z.y.cv swims to D.t-D.y.cv-D.c.W";
                    }
                    $D = D.y.over
                }
            }
            unless (s&W) {
                # lines
                if (my $s = Js&s) {
                    s&z = ss&lv if ss&lv;
                }
            }
        }
    
    # shrinkwarp
    O 7:
        if (ref c&s) {
            # replace with c&S locator/descriptor if complicated
            # for the See elvis, travel inwarden
        }
        delete c&s if s&qs; # quiet s
        
        # C.c should be shaded down to s, injext o
        # should wake up if they change tho, for hidden clocks
        if (s&J) {
            if (s&W) {
                # W implies J in mo:W:12, they can look it up
                delete s&J if s&W eq s&J;
            }
        }
        
        if (my $J = s&J) {
            # ^ should be o'd for lv, updates inc root.9 z onto here
            # unless C.sc.qz (quiet z)
            # unless s&W (they can look it up)
            
            # describe it, versions at head/remote
            s&J = Js&name || J.t;
        }
        
        # sc vanishing
        delete C.sc.>$_ for qw'ux oWl qs qz sq idly nspc path yspc';
        
        # sc becomes c - instructions for display
        my @sc = qw'Wid Mid tag id ht cod';
        push @sc, split ',', delete s&pc if s&pc;
        C.c.>$_ = delete C.sc.>$_ for grep { exists C.sc.>$_ } @sc;
        
Komp: | # K/D line protoClattice
    u a
    K 1:
        A.c.s = shift @$s; # us
    D 1:
        A.c.s = shift @$s; # us
    K 2:
        my $beam = "C.y.cv  C.t   ".ki(C.c)."      ".ki(C.sc||{});
        $beam =~ s/\n/\\n/g;
        sayyl "K: $beam";
        
        # ^ some sc upgrade to c
        
    D 2:
        # reverse it
    
WaysAcro: | # osc thing through cached pi into meta/waytogetat
    # install libaudio-scan-perl
WhereAmI: | # 
    # install lshw
Tan: | # encodings

    u O
    of: %of:O
        #n $s=>''=>{W=>'of'}
        say "OFing ! C.t C.y.cv ".ki C.sc;
        # compile language, see 9 cono
        # container process is traveling bunches of code, see 99 Traweil
        # place toward A.ii.>$s, linked list of embryo
        
        # rennovating around town
        # a geodesic self-mover
        # keeps rebuilding in different locations
        
Tal: | # displayings
    u i
    say: %nobasay
        $s eq 'saygr' ? saygr(@Me) :
        $s eq 'sayyl' ? sayyl(@Me) :
        $s eq 'saybl' ? saybl(@Me) :
        $s eq 'sayre' ? sayre(@Me) :
        $s eq 'say' ? say(@Me) :
        die "New kinda talk: $s\n".wdump 2, \@Me;
        

