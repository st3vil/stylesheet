NutErupts	9	Jo:1.1
  e	001	W:javascript
    einlookup			{"acgt":"s","act":"1","any":"1","coded":"1","dige":"834a60d11b2f","js":"e","v":"ceinlookup","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        T.once = 1;
        var Js = C.c.Jat ? C.c.Jat.slice() : [A[1]];
        var anein = 0;
        Js.reverse();
        for (var i in Js) {
            var J = Js[i];
            // last resort/undelivered
            if (J == J[4]) {
                break
            }
            // if near attention should try to create the handler
            //J == J[3]
            // A[1] will not be correct...
            // < isolate reaction down this Jath
            //J != J[3]
            // otherwise, the usual...
        
        var ein = J.sc.ein;
        if (!ein) {
            continue
        }
        anein = 1
        //!ein and return T.not = 2;
        
        A.c.idea = ein[C.t];
        if (!A.c.idea) {
            var parts = C.t.split('+');
            for (var i in parts) {
            var t = parts[i];
                A.c.idea = ein[t];
            }
        }
        if (typeof A.c.idea == 'function') {
            A.c.idea = {i:A.c.idea}
        }
        
        var id = A.c.idea ? A[4].sc.ki(A.c.idea) : 'no ein';
        G.h(A,C,G,T,"c",'>86 elvis',[ki(J,2), C.t, id]);
        // first/deepest one
        if (A.c.idea) {
            break
        }
        
        }
        if (!anein) {
            return T.not = 2;
        }
        if (!A.c.idea) {
            return T.not = 1;
        }
        
        
        };
    edo	4		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"b0f19d78e00a","js":"e","v":"cedo","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        T.once = 1;
        if (T.el) {
            return
        }
        // some vars
        var ar = {};
        ar.M = A[1].sc.M = A[1].sc.M || [];
        var e = ar.e = C;
        if (e.c.s) {
            ar.s = e.c.s;
        }
        C = A.n.c.s;
        // two ways about it
        for (var way in A.c.idea) {
            var pin = A.c.idea[way];
            if (way == 'w') {
                G.h(A,C,G,T,'way',pin,ar);
            }
            else
            if (way == 'i') {
                var l = G.h(A,C,G,T,'arfgunc',pin);
                // s = e.c.s? good for NutText/typing which 'says'
                if (l == 'A,C,G,T,s') {
                    pin(A,C,G,T,ar.s)
                }
                else if (l == 'A,C,G,T,s,c') {
                    // < Ec is the most pointed to thing... see Ch
                    var c = G.h(A,C,G,T,"E",'hC -1');
                    pin(A,C,G,T,ar.s,c)
                }
                else {
                    {var er = new Error("Buildargs: "+l); er.tc = [s]; throw er}
                }
            }
            else {
                {var er = new Error("idea not i/w"); er.tc = [A.c.idea]; throw er}
            }
        }
        // can repeat: e.t -> A.c.idea -> here ^
        if (T.seek) {
            return delete T.once;
        }
        T.el = 1;
        
        };
    edone	5		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"13a6e2e98b66","js":"e","v":"cedone","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        if (T.ok) {
            A.cv = 0.9;
            if (A.n.cv <= 0.6) {
        G.h(A,C,G,T,"c",'Can avoid J6ing',[]);
                T.not = 1;
                var oT = A.n.c.T;
                oT.not = 1;
                // put a 5 block e doing id
                oT.leaves = 'elvis';
                return;
            }
        G.h(A,C,G,T,"c",'Could avoid J6 next time',[]);
        }
        T.not = 2;
        
        };
    music	8	"function(A,C,G,T,s) {\n// yep\n\n};\n"	{"acgt":"s","act":"1","any":"1","coded":"1","dige":"c9e43ca60feb","js":"e","v":"cmusic","args":"A,C,G,T,s","Wavel":"NutEl"}
  ev	001	W:javascript
    ev			{"acgt":"s","act":"1","any":"1","coded":"1","dige":"c21fa0aab7e9","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'way','EleVisAn',{},'noop');
        G.h(A,C,G,T,'way','EleMento');
        
        };
    ev	2		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"ea80b0b0f02e","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'way','EleVisAn');
        if (T.el) {
            return T.not = 'satisfied ev@2'
        }
        
        };
    ev	3		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"41624d678aa7","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        var n = A.sc.wouldn;
        if (!n) {
            return
        }
        T.not = 'A:n ev@3'; // stop ev forever
        G.h(A,C,G,T,'n',n);
        
        };
    ev	4		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"f8d7f21d0a1a","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        A.sc.msg.set("state","no");
        
        
        };
  eye	001	W:javascript
    Compress			{"acgt":"s d","args":"A,C,G,T,s,d","coded":1,"dige":"627de72dfdfb","js":"eye","Wavel":"NutLands"}
      c s: |
        function(A,C,G,T,s,d) {
        // the other things are around, also via y.{tw,tv,in} etc
        delete s.sc.z;
        
        // especially if pi
        if (s.sc.J) {
            delete s.c.s;
        }
        if (typeof s.c.s == 'object') {
            delete s.c.s
        }
        if (typeof s.sc.J == 'object') {
            delete s.sc.J
        }
        
        var mute = {c:['code'],sc:[]};
        var unmuted_objects = [Object,Array];
        // this just does:
        //   s.c.code and delete s.c.code; s.c.mc = 'code';
        // < Be properties
        for (var nk in mute) {
            var gks = mute[nk];
            var he = s[nk];
            var muted = {};
            for (var gk in he) {
            var v = he[gk];
                if (gks[gk]) {
                    muted[gk] = 1; continue
                }
                // data should be limited somehow...
                if (typeof v != 'object') {
                    continue
                }
                if (unmuted_objects.indexOf(v.constructor) >= 0) {
                    continue
                }
                // name of v.constructor
                muted[gk] = G.h(A,C,G,T,'arfgunc',v) || 1;
        
            }
            for (var gk in muted) {
            var reason = muted[gk];
                delete he[gk]
            }
            // say that it is muted, eg C.c.mc = 'muted Cc keys'
            //  in a thing that could pretend to be a hash for simplicity...
            if (Object.keys(muted).length) {
                var ou = 'm' + nk.slice(0,1);
                var was = s.c[ou];
                if (was) {
                    was = G.h(A,C,G,T,"peel",was,{sep:' '});
                    $.extend(muted, was);
                }
                s.c[ou] = G.h(A,C,G,T,"depeel",muted,{sep:' '});
            }
        }
        
        };
    E			{"acgt":"s","coded":"1","dige":"3140720556c3","js":"eye","args":"A,C,G,T,s","Wavel":"NutFactorEase"}
      c s: |
        function(A,C,G,T,s) {
        var d = s.split(' ');
        s = d.shift();
        var e = C.c.e;
        if (!e) {
            throw new Error("Where's e?");
        }
        if (s == 'hC') {
            s = e.c.hC = e.c.hC || G.h(A,C,G,T,'get_hC',e);
        }
        else { throw "What data? "+s }
        
        if (!d.length) {
            return s
        }
        d = d.join(' ');
        return G.h(A,C,G,T,'F',s,d)
        
        };
    F			{"acgt":"s d","args":"A,C,G,T,s,d","coded":1,"dige":"f933035b03ab","js":"eye","Wavel":"NutFactorEase"}
      c s: |
        function(A,C,G,T,s,d) {
        var m;
        var p = function(r){
            m = d.match(r);
            if (!m) {
                return
            }
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        var dstart = d;
        var v;
        
        // all Array of items, assume the spec also de-arrays it
        if (s.constructor == Object) {
            s = [s];
        }
        
        // calling it C means grep for
        // < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            var typology = m[0];
            var nk = m[1];
            var gk = m[2];
            s = s.filter(function(s){ 
                if (s && s[nk] && s[nk][gk] != null) {
                    v = s[nk][gk]; return 1
                }
            });
        }
        
        // calling it s means grep for and move to
        // items replace with something that must be true
        if (p(/^(s\.A\.c\.s) ?/)) {
            s = s.map(function(s){ return s.A && s.A.c.s }).filter(function(s){ return s });
        }
        
        // remove items until...
        if (p(/^(since) (yA1) (==) (A1) ?/)) {
            while (s.length) {
                var z = s[0]; // ]
                if (z.y.A && z.y.A && z.y.A[1] == A[1]) {
                    break;
                }
                s.shift();
            }
        }
        
        // Array of items -> item
        
        // last one
        if (p(/^-1 ?/)) {
            s = s.slice(-1)[0]
        }
        
        // end of being item as collection of properties
        
        // peel:a:b:c given v=e:r:t:y gives {a:e,b:r,c:'t:y'}
        if (p(/^peel:([\w:\@]+) ?/)) {
            if (!v) {
                {var er = new Error("no value"); er.tc = [dstart]; throw er}
            }
            // ref v could be done, eg C t:cs the center,
            //   unless keys appear in sc
            if (typeof v != 'string') {
                {var er = new Error("value not string"); er.tc = [dstart]; throw er}
            }
            var ar = {};
            var spec = m[0].split(':');
            var vars = v.split(':');
            while (spec.length) {
                var k = spec.shift();
                var array = k.slice(0,1) == '@';
                if (array) {
                    k = k.replace(/^\@/,'');
                }
                ar[k] = spec.length ? vars.shift() :
                    array ? vars : vars.join(':');
            }
            s = ar
        }
        
        if (d.length) {
            throw new Error("FE spec leftover: "+d);
        }
        return s
        
        };
    get_hC			{"acgt":"e","coded":"1","dige":"aaa66d621e32","js":"eye","args":"A,C,G,T,e","Wavel":"NutFactorEase"}
      c s: |
        function(A,C,G,T,e) {
        if (!A[1].sc.s) {
            {var er = new Error("Never osc'd"); er.tc = [A[1]]; throw er}
        }
        var r = A[1].sc.s.sc.top;
        
        var path = G.h(A,C,G,T,"F",e.c.path,'s.A.c.s since yA1 == A1');
        
        var tv = r.y.tv;
        e.c.hC = [];
        for (var i in path) {
            var D = path[i];
            // climbing C.sc.J.sc.ss['top'](A,C,G,T)
            if (!tv && D.c.root) {
                tv = D.y.tv || D.y.OC.y.tv; continue
            }
            if (tv && tv[D.t] && tv[D.t][D.y.cv]) {
                var o = tv[D.t][D.y.cv];
                e.c.hC.push(o);
                tv = o.y.tv;
            }
            else {
                var res = tv ? "404" : "notv";
        G.h(A,C,G,T,"c",'>96 point',[res, i+' in:', ki(path,2)]);
                break; //throw new Error("Broken pointer");
            }
        }
        return e.c.hC
        
        };
    gev			{"acgt":"ev J","args":"A,C,G,T,ev,J","coded":1,"dige":"ce309bdffedb","js":"eye","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,ev,J) {
        ev = ev || event;
        if (ev.target.tagName == 'H2') {
            return
        }
        // locate A:top of A:4
        if (!ev.target) {
            if (A.c.event_A) {
                A = A.c.event_A;
            }
        }
        else {
            var S = ev.target;
            while (S && !(S.A && S.A[4])) {
                S = S.parentNode;
            }
            // must be clicking <body>, <html>
            //   or something above .A element space
            if (!S) {
                return
            }
            var Four = S.A[4];
            A = Four.up;
            if (!A) {
                throw new Error("out of cone");
            }
            A.c.event_A = A;
        }
        if (A.c.event_A) {
            if (A.c.event_A != A) {
                G.h(A,C,G,T,"c",'innerA',[A[4].t]);
            }
            A = A.c.event_A;
        }
        G.h(A,C,G,T,'Aye','ev',9,{ev:ev})
        
        };
    heading			{"acgt":"s","coded":"1","dige":"e2121d1d431d","js":"eye","args":"A,C,G,T,s","Wavel":"NutTal"}
      c s: |
        function(A,C,G,T,s) {
        var Hz = 15;
        if (s == 'Hz:50') {
            Hz = 50; s = '';
        }
        if (G.h(A,C,G,T,'jam',Hz)) {
            {var er = new Error("jamming"); er.tc = [A[1]]; throw er}
        }
        var size = A[1] == A[3] ? "200" : "150";
        var n = G.h(A,C,G,T,'n',['t',0.01,{s:A[1].t},{ab:1,blr:'2px',zi:-20}]);
        n.sc.fs = size+'%';
        n.sc.mt = '-0.7em';
        n.sc.dow = 'do/Shrinkage';
        
        var r = A[1].sc.root;
        r.sc.mt = '1em';
        r.sc.mih = '2em';
        
        r.sc.dis = 'block';
        if (A[1] == A[3]) {
            r.sc.width = '50%';
        }
        
        if (s) {
            if (s == '55') {
                r.sc.left = '50%';
                r.sc.width = '100%';
                r.sc.ab = '1';
            }
            else {
                {var er = new Error("unknown heading style"); er.tc = [s]; throw er}
            }
        }
        
        A[1].sc.ein = A[1].sc.ein || {};
        A[1].sc.ein.click = {w:'dosclick'};
        
        A[1].sc.M = A[1].sc.M || [];
        
        return n
        
        };
    oleak			{"acgt":"s d l","args":"A,C,G,T,s,d,l","coded":1,"dige":"2aeade7a4585","js":"eye","Wavel":"NutLands"}
      c s: |
        function(A,C,G,T,s,d,l) {
        var fail = 0;
        var was = window.maxyamling;
        window.maxyamling = d * 3;
        var code;
        try { code = jsyaml.safeDump(s) }
        catch (er) {
            window.maxyamling = was;
            if (er.message != "Too much to yaml") {
                (er.catches = er.catches || []).push({stack:er.stack}); throw er;
            }
            fail = 1;
        }
        if (l && code && code.length > l) {
            fail = 'large-ish'
        }
        window.maxyamling = was;
        return fail
        
        };
    readLines			{"acgt":"s opt","args":"A,C,G,T,s,opt","coded":1,"dige":"665aef4cd849","js":"eye","Wavel":"NutLands"}
      c s: |
        function(A,C,G,T,s,opt) {
        opt = opt || {};
        var L = s.split("\n");
        var oL = [];
        var tot = L.length;
        var N = [];
        var stack = [];
        var paniconce = 0;
        
        while (L.length) {
        
        var l = L.shift();
        oL.push(l);
        if (!l.length) {
            continue
        }
        var lin = l.match(/^(\s*)(.*)$/);
        var ind = lin[1];
        var d = ind.length / 2;
        l = lin[2];
        var li = l.split("\t");
        var t = li[0];
        var y = li[1];
        var c = li[2];
        var sc = li[3];
        // sc can kick in early, still one \t
        if (y && y[0] == '%') {
            sc = y.slice(1); y = '';
        }
        if (c && c[0] == '%') {
            sc = c.slice(1); c = '';
        }
        if (y && opt.y1 && opt.y1[0] == '%') {
            (opt.tosc = opt.tosc || {})[opt.y1.slice(1)] = y; y = '';
        }
        var s = li[4];
        
        if (t.match(/^\W/)) {
            t = $.parseJSON(t);
        }
        
        y = y || 1
        y = 1*('0.'+y);
        
        if (s && s.match(/^\W/)) {
            s = $.parseJSON(s);
        }
        if (c && c.match('^"')) {
            s = $.parseJSON(c);
            c = {};
        }
        else if (c && c.match(/^\W/)) {
            c = $.parseJSON(c)
        }
        else if (c) {
            c = G.h(A,C,G,T,'peel',c)
        }
        else { c = {} }
        
        if (s) {
            c.s = s;
        }
        
        if (sc && sc.match(/^\W/)) {
            sc = $.parseJSON(sc)
        }
        else if (sc) {
            sc = G.h(A,C,G,T,'peel',sc)
        }
        else { sc = {} }
        
        var C = {t:t,y:{cv:y},c:c,sc:sc};
        
        //c readLines indented bits
        
        var k;
        var v;
        var indenting = function(){
            if (!L.length) {
                return;
            }
            var m = L[0].match("^"+ind+"  (\\w[\\w ]+):(?: (\\||.+))?$");
            if (!m) {
                return;
            }
            k = m[1];
            v = m[2];
            return 1;
        };
        while (indenting()) {
            var string;
            if (v === '|') {
                string = 1;
                v = undefined;
            }
            if (v && v.match(/^\W/)) {
                v = $.parseJSON(v)
            }
            L.shift();
            k = k.split(' ');
            var nk = k.shift();
            var gk = k.join(' ');
            if (!v) {
                var s = [];
                var one;
                var blockquoting = function(){
                    if (!L.length) {
                        return;
                    }
                    var m = L[0].match("^"+ind+"    (.*)$");
                    if (!m) {
                        return;
                    }
                    one = m[1];
                    return 1;
                }
                while (blockquoting()) {
                    s.push(one);
                    L.shift();
                }
                v = s.join("\n");
                // console.log("Loaded "+nk+gk+": "+v+'  Next: '+L[0]);
                if (!string) {
                    v = jsyaml.safeLoad(v);
                }
                else {
                    if (!v.match(/\n$/)) {
                        v = v+"\n"
                    }
                }
            }
            C[nk][gk] = v;
        }
        
        if (d.toFixed() != d) {
            G.h(A,C,G,T,"c",'fractionalind',[d, C, T.readinglv]);
        }
        d = 1 * d.toFixed();
        if (d > 0) {
            var p;
            var dl = d;
            while (dl--) {
                p = stack[dl];
                if (p) {
                    break
                }
            }
            if (dl < d - 1) {
                var few = oL.slice(-3);
                if (! paniconce++)
        G.h(A,C,G,T,"c",'toomuchind',[d, dl, T.readinglv, few]);
                d = dl+1;
            }
            // use io?
            p.sc.z = p.sc.z || [];
            p.sc.z.push(C);
            // tv/tw/in/next?
            var tv =
            p.y.tv = p.y.tv || {};
            tv[C.t] = tv[C.t] || {};
            tv[C.t][C.y.cv] = C;
            // a mass inCing, dialecting
        }
        else {
            N.push(C);
        }
        stack[d] = C;
        while (stack[d+1])
            stack.pop();
        if (opt.tosc) {
            ex(C.sc,opt.tosc);
        }
        
        }
        return N
        
        };
    Serialise			{"acgt":"s comp c","args":"A,C,G,T,s,comp,c","coded":1,"dige":"fe89b1144300","js":"eye","Wavel":"NutLands"}
      c s: |
        function(A,C,G,T,s,comp,c) {
        if (!s) {
            throw new Error("undef");
        }
        var ers = [];
        var cb = function(s,d){
            var part = "Compress";
            try {
                // put this one bit back so ind can keep moving in order
                var z = s.sc.z;
                part = 'comp';
                comp && comp(s,d);
                if (d.not) {
                    return
                }
                part = 'Compress';
                G.h(A,C,G,T,'Compress',s);
                part = 'toLines';
                var string = G.h(A,C,G,T,'toLines',s);
                if (z) {
                    s.sc.z = z
                }
                return string;
        
            }
            catch (er) {
                ers.push([part,d,s,er]);
                return ki(s,2)+"   !"+part+"! "+er
            }
        };
        var op = {hup:1};
        if (c) {
            $.extend(op,c);
        }
        var l = G.h(A,C,G,T,'ind',s,cb,op);
        if (ers.length) {
            G.h(A,C,G,T,"c",'>29 unserial',[ki(ers)]);
        }
        if (!l.match(/\n$/)) {
            l += "\n"
        }
        return l
        
        };
    toLines			{"acgt":"s","coded":"1","dige":"80c5607f7936","js":"eye","args":"A,C,G,T,s","Wavel":"NutLands"}
      c s: |
        function(A,C,G,T,s) {
        if (s) {
            C = s;
        }
        var t = C.t;
        var y = C.y.cv;
        // aims for simplicity of notation for G.h(A,C,G,T,'readLines'), G.h(A,C,G,T,'C'), G.h(A,C,G,T,'peel')
        // block quotes (BQ) big strings or data after the  line
        // uses json for anything complicated
        // z insides done by the process around this one Line
        //  - they have the same indent as BQs
        //    but their t should json or not look like BQ
        // hath
        var h = {};
        h.c  = $.extend({},C.c||{});
        h.sc = $.extend({},C.sc||{});
        delete h.sc.z;
        // needs json
        var n = {};
        // needs blockquote
        var q = {};
        
        // check out how sayable the values on the line are
        // for c/sc as peelable, 
        // < we can know thing:thing:thing
        //   means thing = 'thing:thing'
        var peelok = /^[\w\.\-%\/:]+$/;
        var nameok = /^\w[\w\.\-%\/]*$/;
        var simp = function(s){
            s = ''+s;
            return s.match(nameok) && s.length < 24
        };
        // inject 2sphere
        var lod = function(n,nk,gk,v){
            n[nk] = n[nk] || {};
            n[nk][gk] = v;
        };
        for (var nk in h) {
            var gkv = h[nk];
            if(typeof gkv != 'object') { continue }
        for (var gk in gkv) {
            var v = gkv[gk];
            if (!simp(gk)) {
                lod(n,nk,gk,v);
                continue
            }
            if (typeof v != 'string' && typeof v != 'number') {
                // is > 4*3 nodes or encodes to > 42 chars
                if (G.h(A,C,G,T,'oleak',v,4,42) ) {
                    if (G.h(A,C,G,T,'oleak',v,24)) {
                        throw "Leaky "+nk+"."+gk+": "+ki(v);
                    }
                    // big enough to quote, simplifies remainder
                    lod(q,nk,gk,v);
                }
                else {
                    // ref too small to quote, json hemisphere
                    lod(n,nk,gk,v);
                }
            }
            else {
                if (v.length > 42 && v.match(/\n/)) {
                    // long enough to quote
                    lod(q,nk,gk,v);
                }
                else if ((v+'').match(peelok)) {
                    // decipherable to G.h(A,C,G,T,'peel')
                }
                else {
                    // midway to unwieldy
                    lod(n,nk,gk,v);
                }
            }
        }}
        
        // quote freaks, if just a few break the peelability of many
        for (var nk in n) {
            var g = n[nk];
            var v = h[nk];
            if (!Object.keys(v).length) {
                continue;
            }
            var complex_keys;
            for (var i in g) {
            var k = g[i];
                if (!simp(k)) {
                    complex_keys = 1;
                }
            }
            if (complex_keys) {
                continue;
            }
        
            if (Object.keys(g).length / Object.keys(v).length < 0.3) {
                for (var i in g) {
            var k = g[i];
                    lod(q,nk,k,h[nk][k]);
                }
            }
        }
        
        // remove quoted things and their need of json from the line
        for (var nk in q) {
            var gkv = q[nk];
            if(typeof gkv != 'object') { continue }
        for (var gk in gkv) {
            var v = gkv[gk];
            h[nk] && delete h[nk][gk];
            n[nk] && delete n[nk][gk];
        }}
        for (var nk in n) {
            var gks = n[nk];
            // all freaks got quoted:
            if (!Object.keys(gks).length) {
                delete n[nk]
            }
        }
        //c toLines encoded bits
        // may pass a T.enj_catch, so functions can warn/show up as 'CODE'
        var enj = function(s){ return window.enj(s,T) };
        
        // t can be messy
        var l = simp(t) ? t : enj(t);
        
        // y.cv = 1 is implied
        if (!y) {
            y = 1
        }
        y = (y+'').replace(/^0\./,'');
        l += "\t"+(y == "1" ? '' : y);
        
        // throw it one way or another
        var hem = ['c','sc'];
        for (var i in hem) {
            var nk = hem[i];
            var v = h[nk];
            if (nk == 'c' && 0 == Object.keys(v).length) {
                // blank
                l += "\t";
            }
            else if (nk == 'c' && 1 == Object.keys(v).length && v.s) {
                // t y "the s" sc
                l += "\t"+enj(v.s);
            }
            else if (n[nk]) {
                // json bits: t y {W:"At"} {et:3,se:"te",ra:1}
                l += "\t"+enj(v);
            }
            else if (Object.keys(v).length) {
                // G.h(A,C,G,T,'peel') bits: t y W:At et:3,se:te,ra
                l += "\t"+G.h(A,C,G,T,'depeel',v);
            }
        }
        
        var L = [];
        //c toLines indented bits
        // < quoting with Line other N/C looking vals
        for (var nk in q) {
            var gkv = q[nk];
            if(typeof gkv != 'object') { continue }
        for (var gk in gkv) {
            var v = gkv[gk];
            var k = "  "+nk+" "+gk+":";
            if (typeof v != 'string') {
                // BQ yaml data
                T.eny_nkgk = [nk,gk];
                var v = eny(v,T);
                delete T.eny_nkgk;
                var vs = [];
                v = v.split("\n");
                for (var i in v) {
            var s = v[i];
                    vs.push("    "+s);
                }
                k += "\n"+vs.join("\n");
            }
            else if (simp(v)) {
                // simple strings
                // not confusible into 'Thing 2'
                k += " "+v;
            }
            else if (!v.match(/\n$/)) {
                // BQ implies trailing \n
                k += " "+enj(v);
            }
            else {
                // BQ string
                var vs = [];
                v = v.split("\n");
                for (var i in v) {
            var s = v[i];
                    vs.push("    "+s);
                }
                k += " |\n"+vs.join("\n");
            }
            k = k.replace(/\n\s*$/,'');
            L.push(k);
        }}
        
        // extra lines (L) sorted, larger bits after smaller
        L = L.sort();
        var tidy = [];
        var large = [];
        for (var i in L) {
            var s = L[i];
            s.length > 300 ? large.push(s) : tidy.push(s)
        }
        l = [l];
        if (tidy.length) {
            l.push(tidy.join("\n"))
        }
        if (large.length) {
            l.push(large.join("\n"))
        }
        l = l.join("\n");
        
        return l
        
        };
  n	001	W:javascript
    e	2		{"acgt":"s","act":"1","coded":"1","dige":"ac0581da29d1","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        var e = s;
        var E = e.y.A;
        if (E && E.t == 'ev') {
            E = null;
        }
        if (!E) {
            // spawn A:e after A:n@13, inherits A[1] = C.sc.J
            E = e.y.A = G.h(A,C,G,T,'Aye','e',2,{s:e});
            A.e = E;
            E.n = A;
            // wake us
            E.sc.N = E.sc.N || [];
            E.sc.N.push(A);
        }
        if (E.n != A) {
            {var er = new Error("A:e.n not us"); er.tc = [E, A]; throw er}
        }
        if (A.e != E) {
            {var er = new Error("A:n.e not elvis"); er.tc = [A, E]; throw er}
        }
        // happens in steps in sync with n wakeness
        G.h(A,C,G,T,'thro',A.e,2)
        
        };
    e	4		{"acgt":"s","act":"1","coded":"1","dige":"15676def659f","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'thro',A.e,4)
        
        };
    e	5		{"acgt":"s","act":"1","coded":"1","dige":"2c4e9278a511","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'thro',A.e,5)
        
        };
    e	8		{"acgt":"s","act":"1","coded":"1","dige":"1814d91e4155","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'thro',A.e,8);
        if (A.e.cv < 0.8) {
            G.h(A,C,G,T,"c",'>17 lost e',[A.e.cv+'/'+A.cv+'@'+C.t, A[4].sc.ki(C.c.e)]);
        }
        
        };
  NutEl			W:NutEl,ha:f7fbe7c085a9
  NutFactorEase			W:NutFactorEase,ha:a710184e55de
  NutLands			W:NutLands,ha:473237cc44ba
  NutTal			W:NutTal,ha:8c06537d440f
