NutMachine	9	Jo:1.1
  eye		W:javascript
    add_script			{"acgt":"src cb","args":"A,C,G,T,src,cb","dige":"69efd9a80fc7","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,src,cb) {
        var script = document.createElement('script');
        script.setAttribute('src', src);
        script.setAttribute('type', 'text/javascript');
        if (cb) {
            script.onload = function(e){ cb(script,e) };
        }
        A[4].on.appendChild(script);
        return script
        
        };
    arfgunc			{"acgt":"s","coded":"1","dige":"a86cd8aa8821","js":"eye","args":"A,C,G,T,s","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s) {
        var reg = /^function (\w*)\((.*?)\)/;
        if (typeof s == 'object') {
            var m = s.constructor.toString().match(reg);
            return m && m[1]
        }
        if (typeof s != 'function') {
            return
        }
        var m = s.toString().match(reg);
        return m && m[2]
        
        };
    Aye			{"acgt":"s ov c sc","args":"A,C,G,T,s,ov,c,sc","dige":"5623acef97b8","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s,ov,c,sc) {
        if (s && typeof s == 'object') {
            A = s;
        }
        else {
            var V = A;
            A = $.extend({},A);
            A.t = s;
            A.y = A;
            A.y.cv = 0;
            A.c = {};
            A.sc = {};
        
            A.up = V;
            A.c.ip = (A.up.c.ip||[]).slice(0);
            A.up.c.ipi = A.up.c.ipi || 0;
            A.c.ip.push(A.up.c.ipi++);
            A.c.sip = A.c.ip.join(' ');
        
            // trip A
        }
        if (c && typeof c.t == 'string' && c.y && c.c && c.sc) {
            A.c.s = c; c.y.A = A; c = null
        }
        if (c) {
            $.extend(A.c,c);
        }
        if (sc) {
            $.extend(A.sc,sc);
        }
        
        if (ov && ov*1 == ov) {
            A.c.ov = G.h(A,C,G,T,'sca',ov);
            G.h(A,C,G,T,'thro');
        }
        return A
        
        };
    Ban			{"acgt":"er msg url lineNo colNo","args":"A,C,G,T,er,msg,url,lineNo,colNo","dige":"99bf5dc8e06e","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,er,msg,url,lineNo,colNo) {
        var B = G.c.B;
        B = B.y.up;
        if (typeof er == 'string') {
            msg = msg || er;
        G.h(A,C,G,T,"c",'>9 throwstring',[er+'']);
        }
        // msg sometimes stringified er, message is less noisy
        if (er.message) {
            msg = er.message;
        }
        if (msg.slice(0,5) == 'async') {
            // test for unhandled asyncs
            //G.h(A,C,G,T,'waylay','checkov_async',{B:B})
            G.h(A,C,G,T,"c",'>9 '+msg);
            er.nobigdeal = 1;
            return
        }
        if (msg.slice(0,5) == 'waits') {
            er.nobigdeal = 1;
        }
        
        msg = msg.replace(/^Uncaught /,'');
        var m = [
            G.h(A,C,G,T,"intag",'>97 !')
            ,G.h(A,C,G,T,"intag",'>75:Wtitle')
            ,G.h(A,C,G,T,"intag",'>9:Bangmsg '+msg)
            ,G.h(A,C,G,T,"intag",'>8:weirdness')
            ,G.h(A,C,G,T,"intag",'>4:subinfo ?')
        ];
        if (er.tc) {
            m.push( G.h(A,C,G,T,"intag",'>2:tnc '+ki(er.tc,3) ));
            m.push(m.splice(-2,1));
        }
        
        var it = G.h(A,C,G,T,"c",m.join(' '));
        
        var w = B.sc.way;
        var cat = er.catches; // places of rethrow
        // may get restacked when rethrowing
        //   if running chrome < 2012 ?
        var stack = er.stack;
        if (cat) {
            stack = cat[0].stack;
        }
        if (!stack) {
            return;
        }
        var k = stack.split("\n");
        k.shift();
        var end = k[0];
        console.log("er: ",msg,url,lineNo,er,w,cat,end);
        if (url && location.href == url) {
            url = null
        }
        var beyond = 0;
        G.er = er;
        
        while (k.length) {
            end = k.shift();
        
            if (beyond) {
                it.set('weirdness','+'+beyond);
            }
        
            // anon sub if way
            var m = end.match(/<anonymous>:(\d+):(\d+)\)$/);
            if (m) {
                if (url && !url.match(/\/js\/NutMachine[^\/]*\.js$/)) {
                    debugger;
                }
                if (w) {
                    // works only if B is still the G.h(A,C,G,T,'way')
                    it.set('Wtitle', 'w:'+w.t);
                    var l = w.c.s.split("\n")[m[1] - 1 - 1];
                    it.set('subinfo', l);
                }
                return
            }
        
            // a url if <script>
            var m = end.match(/ \((.+?\/js\/.+?):(\d+):(\d+)\)$/);
            if (m) {
                url = m[1];
                lineNo = m[2];
                colNo = m[3];
                G.h(A,C,G,T,'Ban_url',it,er,msg,url,lineNo,colNo);
                return
            }
        
            beyond++;
        }
        
        //debugger;
        G.h(A,C,G,T,"c",'92 Neither url or way',[]);
        
        };
    Ban_url			{"acgt":"it er msg url lineNo colNo","args":"A,C,G,T,it,er,msg,url,lineNo,colNo","dige":"552779ed23e1","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,it,er,msg,url,lineNo,colNo) {
        // make sense of the resource
        var v = new URL(url);
        var src = v.pathname;
        var m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
        
        if (!m) {
            // other js resource
            return it.set('subinfo', '?: '+url)
        }
        
        // should be some A:u'
        var W = m[1];
        it.set('Wtitle',W);
        
        // get the lines, in the <script> already?
        $.ajax(src).done(function(s,how,c){
            if (how != 'success') {
                {var er = new Error("Ban faile: "+how); er.tc = [c]; throw er}
            }
            var src = c.getResponseHeader('Location');
            var m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            var W = m[1];
            var ver = m[2];
            var lines = s.split("\n");
            var l = lines[lineNo-1];
            var prior = 1;
            var sub;
            while (1) {
                prior++;
                var line = lines[lineNo-prior];
                if (line == null) {
                    break;
                }
                var fu = line.match('^function '+W+'_'+ver
                    +'_(\\w+)_(\\d+)_(\\w+)_(\\d+)\\(');
                if (!fu) {
                    continue
                }
                var cv = '';
                if (fu[4] != '1') {
                    cv = fu[4]
                }
                sub = fu[1]+cv+'/'+fu[3];
                break
            }
            sub = sub || "?: "+src;
            var m = [
                G.h(A,C,G,T,"intag",'>2:subtitle '+sub)
                ,G.h(A,C,G,T,"intag",'>45:subline '+l)
            ];
            it.set('subinfo', m.join(': '));
        });
        
        // check if current
        $.ajax('/js/'+W).done(function(s,how,c){
            if (how != 'success') {
                {var er = new Error("Ban faile: "+how); er.tc = [c]; throw er}
            }
            var rep = c.getResponseHeader('Location');
            if (src != rep) {
                it.set('Wtitle',"(old)",1);
            }
        });
        
        };
    c			{"acgt":"s M","args":"A,C,G,T,s,M","coded":1,"dige":"5cef4642dcbe","js":"eye","Wavel":"NutPhonica/NutCons"}
      c s: |
        function(A,C,G,T,s,M) {
        M = M || [];
        var l = G.h(A,C,G,T,'Cye',['',1,{},{M:M}]);
        l.t = l.t || s;
        l.sc.now = G.h(A,C,G,T,'time');
        
        var L = A[4];
        L.sc.log = L.sc.log || [];
        L.sc.log.unshift(l);
        G.h(A,C,G,T,'lim',L.sc.log,-9);
        // human readable
        var format = function(s){ return G.h(A,C,G,T,'intag',s) };
        
        var says = [];
        for (var i in M) {
            var v = M[i];
            var say = typeof v == 'number' || typeof v == 'string' ? v 
                : '%'+typeof v;
            says.push(format(say));
        }
        if (says.length) {
            s += ': '+says.join(' ');
        }
        
        msgs = A[4].sc.msgs || $('#msgs');
        var it =
        $(msgs).prepend("<m>"+format(s)+"</m>\n").children()[0];
        // and links? make J? know #msgs?
        l.sc.A = A;
        l.sc.Acv = A.cv;
        var B = G.c.B;
        l.sc.B = B.y.up;
        it.log = l;
        it.set = function(t,s,append){
            s = format(s);
            var el = t == '$' ? it : $(it).find(t)[0];
            if (el == it || append) {
                s = el.innerHTML + s
            }
            if (!el) {
                {var er = new Error("unknown set: "+t); er.tc = [it]; throw er}
            }
            el.innerHTML = s;
        };
        return it
        
        };
    clusp			{"acgt":"s","dige":"0b1def1fe8f3","js":"eye","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        if (!A[4].sc.NormalI) {
            return
        }
        
        // a u still, could lead to not picking it up when elvising?
        if (A[1].sc.u && A[1].sc.u.c.N && A[1].sc.u.c.N.length == 0) {
            return
        }
        
        var u = G.h(A,C,G,T,'sJ','u');
        u.c.is = 'mind';
        var J = A[1];
        var I;
        
        var A = G.h(A,C,G,T,'Aye','clusping',0);
        A[1] = u;
        A[2] = J;
        
        var N = A[1].c.N || [];
        // squash the [''], from: u ''
        if (G.h(A,C,G,T,'datam',N,"[['']]")) {
            N = [];
        }
        
        A[1].c.N = [];
        
        if (N.length) {
            // local A.trip, A.c.trip;
            // anyway, check form and name the wave of u
        
            // always assumed to be difference from Normal
            // should be able to get it to wake by C.sc.v++ through A[4].sc.mind.Normal
            // it (A:u' for Normal) would have a lot of A.sc.N
            var Normal = G.h(A,C,G,T,'Cye',['Normal',1,{I:A[4].sc.NormalI}]);
            N.unshift(Normal);
        
            var NisWs = 1;
            var con = [];
            for (var i in N) {
            var n = N[i];
                if (n.constructor == Object) {
                    con.push(n.t); continue
                }
                if (G.h(A,C,G,T,'datam',n,"['*']")) {
                    con.push(n[0]); continue
                }
                NisWs = 0;
            }
            if (!NisWs) {
                {var er = new Error("Complicated u Cs"); er.tc = [s]; throw er}
            }
            var uname = A.sc.uname = con.join(',');
        
            // A:u resyncs
            A[1].sc.minds = A[1].sc.minds || {};
            var newuname = !A[1].sc.minds[uname];
            var Y = A[1].sc.minds[uname];
        
            if (Y) {
                // A:u comes back to itself
                // u 8 checks use-by dates of u', which TN=3 if check needed
                //   means it does 3 in this thro,
                //   and come out wanting to go async,
                G.h(A,C,G,T,'thro',Y,8);
            }
            else {
                var C = G.h(A,C,G,T,'Cye',[uname,'',{N:N}]);
                Y = G.h(A,C,G,T,'Aye','u',8,{s:C});
            }
        
            // shelve
            A[1].sc.minds[uname] = Y;
        
            // wake us
            Y.sc.N = Y.sc.N || [];
            Y.sc.N.push(A);
        
            if (Y.cv < 0.8) {
                throw new Error("async clusp: "+Y.c.s.t);
            }
            if (!Y.sc.I) {
                {var er = new Error("No I back"); er.tc = [uname, Y]; throw er}
            }
            if (newuname) {
                G.h(A,C,G,T,"c",'>5 u!',[uname]);
            }
            I = Y.sc.I;
        }
        else {
            // clone I?
            // A:u anyway so everything can have depends on Normal?
            I = A[4].sc.NormalI;
        };
        
        J.I = I;
        
        // get this A:n new mind for the next step
        // (seek=0 redoes this step, seek=3 does 3 onward, etc)
        T.seek = '';
        
        };
    Compress			{"acgt":"s d","args":"A,C,G,T,s,d","coded":1,"dige":"627de72dfdfb","js":"eye","Wavel":"NutErupts/NutLands"}
      c s: |
        function(A,C,G,T,s,d) {
        // the other things are around, also via y.{tw,tv,in} etc
        delete s.sc.z;
        
        // especially if pi
        if (s.sc.J) {
            delete s.c.s;
        }
        if (typeof s.c.s == 'object') {
            delete s.c.s
        }
        if (typeof s.sc.J == 'object') {
            delete s.sc.J
        }
        
        var mute = {c:['code'],sc:[]};
        var unmuted_objects = [Object,Array];
        // this just does:
        //   s.c.code and delete s.c.code; s.c.mc = 'code';
        // < Be properties
        for (var nk in mute) {
            var gks = mute[nk];
            var he = s[nk];
            var muted = {};
            for (var gk in he) {
            var v = he[gk];
                if (gks[gk]) {
                    muted[gk] = 1; continue
                }
                // data should be limited somehow...
                if (typeof v != 'object') {
                    continue
                }
                if (unmuted_objects.indexOf(v.constructor) >= 0) {
                    continue
                }
                // name of v.constructor
                muted[gk] = G.h(A,C,G,T,'arfgunc',v) || 1;
        
            }
            for (var gk in muted) {
            var reason = muted[gk];
                delete he[gk]
            }
            // say that it is muted, eg C.c.mc = 'muted Cc keys'
            //  in a thing that could pretend to be a hash for simplicity...
            if (Object.keys(muted).length) {
                var ou = 'm' + nk.slice(0,1);
                var was = s.c[ou];
                if (was) {
                    was = G.h(A,C,G,T,"peel",was,{sep:' '});
                    $.extend(muted, was);
                }
                s.c[ou] = G.h(A,C,G,T,"depeel",muted,{sep:' '});
            }
        }
        
        };
    Cye			{"acgt":"s c","args":"A,C,G,T,s,c","dige":"087d8b44a250","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s,c) {
        var C = {};
        if (!s) {
            debugger;
        }
        if (s.constructor == Object) {
            if (null != s.t && s.y && s.c && s.sc) {
                var C = {t:'',y:{},c:{},sc:{}};
                C.t = s.t;
                $.extend(C.y,s.y);
                $.extend(C.c,s.c);
                $.extend(C.sc,s.sc);
                return C
            }
            else {
                {var er = new Error("Unhandle hash C"); er.tc = [s]; throw er}
            }
        }
        else
        if (s.constructor == Array) {
            C.t = s[0];
            C.y = s[1];
            C.c = s[2];
            if (s.length == 1) {
                C.c = {W:C.t}
            }
            C.sc = s[3];
            if (typeof C.c  === 'string') {
                C.c =  G.h(A,C,G,T,'peel',C.c)
            }
            if (typeof C.sc === 'string') {
                C.sc = G.h(A,C,G,T,'peel',C.sc)
            }
            // < extra -pi
        }
        
        if (!typeof C.t === 'string') {
            {var er = new Error("Non string t"); er.tc = [C]; throw er}
        }
        C.c = C.c || {};
        
        C.sc = C.sc || {};
        
        if (typeof C.y == 'string' || typeof C.y == 'number') {
            var i = 1
            while (C.y * 1 != C.y) {
                if (i++ > 5) {
                    throw new Error("MAAANY");
                }
                // to W other than C.t? call extra parsers?
                var t   = /^([a-z0-9\/]+)($|_)/i;
                var pi = /^-([a-z0-9\/]+)($|_)/i;
                if (C.y.match(t)) {
                    var symb = C.y.match(t)[1];
                    C.c[symb] = C.t;
                    C.y = C.y.replace(t,'');
                }
                else
                if (C.y.match(pi)) {
                    C.c.pi = C.y.match(pi)[1];
                    C.y = C.y.replace(pi,'');
                }
                else {
                    throw "Non number y left: "+A[4].sc.ki(C)
                }
            }
            C.y = {cv: C.y };
        }
        C.y = C.y || {};
        if (C.y.cv < 0) {
            C.y.cv *= -1;
        }
        if (C.y.cv >= 1) {
            C.y.cv = G.h(A,C,G,T,'sca',C.y.cv);
        }
        
        return C;
        
        };
    datam			{"acgt":"s c","args":"A,C,G,T,s,c","dige":"3dc73aeb362f","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s,c) {
        if (typeof c == 'string') {
            c = {s:c};
        }
        c.d = c.d || 1;
        if (c.d > 3) {
            throw new Error("large datam");
        }
        // read the question
        var after = c.s;
        if (c.s.match('^\\[')) {
            after = c.s.replace(/^\[|\]$/g, '');
            c.array = 1
        }
        if (c.s.match("^'")) {
            c.eq = c.s.replace(/^'|'$/g, '');
            after = ''
        }
        c.s = after;
        // make an answer
        if (c.array) {
            if (!(typeof s == 'object' && s.constructor == Array)) {
                return
            }
        }
        if (c.eq != null) {
            if (!(typeof s == 'string' || typeof s == 'number')) {
                return
            }
            if (c.eq != '*' && s != c.eq) {
                return
            }
        }
        if (!c.s) {
            return 1
        }
        // more inside
        var ss = c.s.split(',');
        // check the size of the next set in
        if (s.length != ss.length) {
            //~diflen: s, ss
            return
        }
        // check each thing
        for (var si in ss) {
            var oc = ss[si];
            var os = s[si];
            oc = {s:oc,d:c.d+1};
            var re = G.h(A,C,G,T,'datam',os,oc);
            if (!re) {
                //~subfa: os, oc
                return
            }
        }
        return 1
        
        };
    delay			{"acgt":"delay cb","args":"A,C,G,T,delay,cb","coded":1,"dige":"2cfd1893c443","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,delay,cb) {
        setTimeout(cb, delay * 1000);
        
        };
    depeel			{"acgt":"s d","args":"A,C,G,T,s,d","coded":1,"dige":"e46f4c607d5d","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s,d) {
        d = d || {};
        var ks = Object.keys(s).sort();
        var hs = [];
        for (var i in ks) {
            var k = ks[i];
            var set = k;
            if (s[k] != '1') {
                set += (d.hie||":")+s[k]
            }
            hs.push(set);
        }
        return hs.join(d.sep||",");
        
        };
    desca			{"acgt":"s precision","args":"A,C,G,T,s,precision","coded":1,"dige":"886e31d7db83","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s,precision) {
        if (null == precision) {
            precision = 4;
        }
        var mul = '1e'+precision;
        return (s * mul).toFixed() / mul
        
        
        
        };
    e			{"acgt":"c s","args":"A,C,G,T,c,s","dige":"58a9c0932a8d","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,c,s) {
        C = c;
        c = {};
        if (C.constructor == Array) {
            C = G.h(A,C,G,T,'Cye',C)
        }
        if (s && s.constructor == Array) {
            s = G.h(A,C,G,T,'Cye',s)
        }
        // if first C is {} but not C it is A.c spec,
        // and second becomes first: like n with A.c spec
        if (!(C.y && C.c && C.sc)) {
            c = C; C = s; s = null;
        }
        if (!C) {
            throw new Error("No C spec");
        }
        if (s) {
            C.c.e = s
        }
        c.nogro = 1;
        c.s = C;
        
        // < should same say function as J creation
        var et = ''
        if (s) {
            et = s.t
        }
        G.h(A,C,G,T,"c",'e',[C.t, et]);
        
        var Y = G.h(A,C,G,T,'Aye','n',0,c);
        try {
            G.h(A,C,G,T,'thro',Y,c.ov||8)
        }
        catch (er) {
            var async = (er.message || er).match(/^async/);
            var title = "via "+A[1].t+" e "+C.t;
            if (!async || Y.c.T.sync) {
                (er.catches = er.catches || []).push({stack:er.stack,tc:[title]}); throw er;
            }
        G.h(A,C,G,T,"c",'>9 evoidsync',[title]);
            G.h(A,C,G,T,'Ban',er);
            // give async e to 4, as their J may not be Jtv'd yet
            A[4].sc.N.push(Y);
        }
        return Y.c.s
        
        };
    E			{"acgt":"s","coded":"1","dige":"3140720556c3","js":"eye","args":"A,C,G,T,s","Wavel":"NutErupts/NutFactorEase"}
      c s: |
        function(A,C,G,T,s) {
        var d = s.split(' ');
        s = d.shift();
        var e = C.c.e;
        if (!e) {
            throw new Error("Where's e?");
        }
        if (s == 'hC') {
            s = e.c.hC = e.c.hC || G.h(A,C,G,T,'get_hC',e);
        }
        else { throw "What data? "+s }
        
        if (!d.length) {
            return s
        }
        d = d.join(' ');
        return G.h(A,C,G,T,'F',s,d)
        
        };
    F			{"acgt":"s d","args":"A,C,G,T,s,d","coded":1,"dige":"f933035b03ab","js":"eye","Wavel":"NutErupts/NutFactorEase"}
      c s: |
        function(A,C,G,T,s,d) {
        var m;
        var p = function(r){
            m = d.match(r);
            if (!m) {
                return
            }
            m.shift();
            d = d.replace(r,'');
            return 1
        };
        var dstart = d;
        var v;
        
        // all Array of items, assume the spec also de-arrays it
        if (s.constructor == Object) {
            s = [s];
        }
        
        // calling it C means grep for
        // < put selected values on limb if given
        if (p(/^(C)\.(y|c|sc)\.(\w+) ?/)) {
            var typology = m[0];
            var nk = m[1];
            var gk = m[2];
            s = s.filter(function(s){ 
                if (s && s[nk] && s[nk][gk] != null) {
                    v = s[nk][gk]; return 1
                }
            });
        }
        
        // calling it s means grep for and move to
        // items replace with something that must be true
        if (p(/^(s\.A\.c\.s) ?/)) {
            s = s.map(function(s){ return s.A && s.A.c.s }).filter(function(s){ return s });
        }
        
        // remove items until...
        if (p(/^(since) (yA1) (==) (A1) ?/)) {
            while (s.length) {
                var z = s[0]; // ]
                if (z.y.A && z.y.A && z.y.A[1] == A[1]) {
                    break;
                }
                s.shift();
            }
        }
        
        // Array of items -> item
        
        // last one
        if (p(/^-1 ?/)) {
            s = s.slice(-1)[0]
        }
        
        // end of being item as collection of properties
        
        // peel:a:b:c given v=e:r:t:y gives {a:e,b:r,c:'t:y'}
        if (p(/^peel:([\w:\@]+) ?/)) {
            if (!v) {
                {var er = new Error("no value"); er.tc = [dstart]; throw er}
            }
            // ref v could be done, eg C t:cs the center,
            //   unless keys appear in sc
            if (typeof v != 'string') {
                {var er = new Error("value not string"); er.tc = [dstart]; throw er}
            }
            var ar = {};
            var spec = m[0].split(':');
            var vars = v.split(':');
            while (spec.length) {
                var k = spec.shift();
                var array = k.slice(0,1) == '@';
                if (array) {
                    k = k.replace(/^\@/,'');
                }
                ar[k] = spec.length ? vars.shift() :
                    array ? vars : vars.join(':');
            }
            s = ar
        }
        
        if (d.length) {
            throw new Error("FE spec leftover: "+d);
        }
        return s
        
        };
    Four			{"acgt":"fourt fivet","args":"A,C,G,T,fourt,fivet","coded":1,"dige":"5a59b5792f29","js":"eye","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,fourt,fivet) {
        fourt = fourt || 'Four';
        fivet = fivet || 'Five';
        var el = A.on;
        if (window.A != A) {
            A = A[4].up;
            if (!A) {
                throw new Error("requires an enclosing event forwarding A4");
            }
            A = G.h(A,C,G,T,'Aye','atop');
        }
        A.on = el || A.on;
        A.on.A = A;
        
        A[1] = A; // so A:top == A[4].up
        
        A.I = $.extend({},A.I);
        delete A.I.w; // way cache
        
        var J = A[1] = A[2] = A[3] = A[4] = G.h(A,C,G,T,'J',fourt);
        J[1] = J[2] = J[3] = J[4] = J;
        var f = G.h(A,C,G,T,'J',fivet);
        A[5] = J[5] = f[5] = f;
        // BAB: put A[1].sc.Jtv A[4].t 0.01 A[4]
        A[1].sc.Jtv = A[1].sc.Jtv || {};
        A[1].sc.Jtv[A[5].t] = A[1].sc.Jtv[A[5].t] || {};
        A[1].sc.Jtv[A[5].t][0.01] = A[5];
        A[1].sc.Jtv[A[4].t] = A[1].sc.Jtv[A[4].t] || {};
        A[1].sc.Jtv[A[4].t][0.01] = A[4];
        // A[1].sc.z etc for showing state
        // A[1].sc.N is A-ction, stuff to do,
        // Jambien everything in A[1].sc.Jtv
        A[4].sc.NormalI = A.I;
        
        // pretty printer
        A[4].sc.ki = A[4].sc.ki || function(s,d){ return "!kiyet:"+typeof s };
        G.h(A,C,G,T,'waylay','NutGravy');
        // ^ then G.h(A,C,G,T,'waylay','NutReady')
        // should wait for that ^ before init W
        
        // textual umbiloca t
        A[4].sc.ws = G.h(A,C,G,T,'Aye','ws',9);
        
        // msgs - should be clickable somehow
        var msgs = $(A.on).find('> #msgs')[0];
        msgs = msgs || $("<div id='msgs' style=\"white-space: pre;position:absolute;font-size:60%;left:0em;bottom:0em;width:100%;height:28%; padding:0.2em;color:#abc;overflow:scroll;z-index:200\" onclick=\"G.keon();G.clon();G.togwid(this,'100%','5%');\"> </div>").appendTo(A.on)[0];
        A[4].sc.msgs = msgs;
        
        
        
        // DNS - a list of current A[4] by name
        //  this is really A[6].sc.Jtv? or if A[4].2.Jtv[A[4].t]... == A[4]?
        //   TES callbacks should use G.h(A,C,G,T,'back'):
        //    - rejoining G.c.B, A,
        //    - possible G.DNS[A[4].t] != A[4] and return;
        var dns = G.DNS = G.DNS || {};
        var old = dns[A[4].t];
        dns[A[4].t] = A[4];
        
        A[4].sc.uuid = G.h(A,C,G,T,'desca',Math.random(),8);
        
        return A[4];
        
        
        };
    get_hC			{"acgt":"e","coded":"1","dige":"aaa66d621e32","js":"eye","args":"A,C,G,T,e","Wavel":"NutErupts/NutFactorEase"}
      c s: |
        function(A,C,G,T,e) {
        if (!A[1].sc.s) {
            {var er = new Error("Never osc'd"); er.tc = [A[1]]; throw er}
        }
        var r = A[1].sc.s.sc.top;
        
        var path = G.h(A,C,G,T,"F",e.c.path,'s.A.c.s since yA1 == A1');
        
        var tv = r.y.tv;
        e.c.hC = [];
        for (var i in path) {
            var D = path[i];
            // climbing C.sc.J.sc.ss['top'](A,C,G,T)
            if (!tv && D.c.root) {
                tv = D.y.tv || D.y.OC.y.tv; continue
            }
            if (tv && tv[D.t] && tv[D.t][D.y.cv]) {
                var o = tv[D.t][D.y.cv];
                e.c.hC.push(o);
                tv = o.y.tv;
            }
            else {
                var res = tv ? "404" : "notv";
        G.h(A,C,G,T,"c",'>96 point',[res, i+' in:', ki(path,2)]);
                break; //throw new Error("Broken pointer");
            }
        }
        return e.c.hC
        
        };
    gev			{"acgt":"ev J","args":"A,C,G,T,ev,J","coded":1,"dige":"ce309bdffedb","js":"eye","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,ev,J) {
        ev = ev || event;
        if (ev.target.tagName == 'H2') {
            return
        }
        // locate A:top of A:4
        if (!ev.target) {
            if (A.c.event_A) {
                A = A.c.event_A;
            }
        }
        else {
            var S = ev.target;
            while (S && !(S.A && S.A[4])) {
                S = S.parentNode;
            }
            // must be clicking <body>, <html>
            //   or something above .A element space
            if (!S) {
                return
            }
            var Four = S.A[4];
            A = Four.up;
            if (!A) {
                throw new Error("out of cone");
            }
            A.c.event_A = A;
        }
        if (A.c.event_A) {
            if (A.c.event_A != A) {
                G.h(A,C,G,T,"c",'innerA',[A[4].t]);
            }
            A = A.c.event_A;
        }
        G.h(A,C,G,T,'Aye','ev',9,{ev:ev})
        
        };
    h			{"acgt":"s so st sh sf si","args":"A,C,G,T,s,so,st,sh,sf,si","dige":"8518ef126e4f","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s,so,st,sh,sf,si) {
        var z = s;
        if (typeof s === 'string') {
            z = G.t(A,C,G,T,'eye',s);
            z = z || G.t(A,C,G,T,'i',s);
        }
        if (!z) {
            throw new Error("No h: "+s);
        }
        var t = typeof s == 'object' ? s.sc.js+'/'+s.t+'@'+s.y.cv : z.t;
        var d = {t:t,y:{},c:{},sc:{z:[]}};
        var B = G.c.B;
        if (B) {
            B.sc.z.push(d); d.y.up = B; d.c.d = (B.c.d || 0) + 1;
        }
        G.c.B = d;
        d.sc.D = T.D = z;
        d.sc.C = C; d.sc.A = A;
        
        var r = z.c.code(A,C,G,T,so,st,sh,sf,si);
        
        G.c.B = B;
        return r
        
        };
    headi			{"acgt":"s t","args":"A,C,G,T,s,t","coded":1,"dige":"77aa0e8c4a24","js":"eye","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,s,t) {
        t = t || s
        
        $('body h2').filter(function(i,v){
            if (v.innerHTML.match('^'+s)) {
                v.remove()
            }
        });
        
        var func = "G.h(A,C,G,T,'"+t+"')";
        $('<h2 id="'+t+'" onclick="'+func+'">'+s+'</h2>')
            .appendTo('body')
        
        };
    heading			{"acgt":"s","coded":"1","dige":"e2121d1d431d","js":"eye","args":"A,C,G,T,s","Wavel":"NutErupts/NutTal"}
      c s: |
        function(A,C,G,T,s) {
        var Hz = 15;
        if (s == 'Hz:50') {
            Hz = 50; s = '';
        }
        if (G.h(A,C,G,T,'jam',Hz)) {
            {var er = new Error("jamming"); er.tc = [A[1]]; throw er}
        }
        var size = A[1] == A[3] ? "200" : "150";
        var n = G.h(A,C,G,T,'n',['t',0.01,{s:A[1].t},{ab:1,blr:'2px',zi:-20}]);
        n.sc.fs = size+'%';
        n.sc.mt = '-0.7em';
        n.sc.dow = 'do/Shrinkage';
        
        var r = A[1].sc.root;
        r.sc.mt = '1em';
        r.sc.mih = '2em';
        
        r.sc.dis = 'block';
        if (A[1] == A[3]) {
            r.sc.width = '50%';
        }
        
        if (s) {
            if (s == '55') {
                r.sc.left = '50%';
                r.sc.width = '100%';
                r.sc.ab = '1';
            }
            else {
                {var er = new Error("unknown heading style"); er.tc = [s]; throw er}
            }
        }
        
        A[1].sc.ein = A[1].sc.ein || {};
        A[1].sc.ein.click = {w:'dosclick'};
        
        A[1].sc.M = A[1].sc.M || [];
        
        return n
        
        };
    ind			{"acgt":"s y d","args":"A,C,G,T,s,y,d","coded":1,"dige":"b387dc6f295b","js":"eye","Wavel":"NutProcess/NutCertainty"}
      c s: |
        function(A,C,G,T,s,y,d) {
        var D = s;
        // setup
        d = d || {};
        if (!d.refs) {
            d.refs = []; // all things
            d.refid = {}; // those indices to d
        }
        y = y || function(s){ return s }
        if (typeof y == 'string') {
            if (y.slice(0,2) == 'ki') {
                var dl = y.slice(2);
                y = function(s){ return ki(s,dl) }
            }
            else { 
                {var er = new Error("ind y named"); er.tc = [y]; throw er}
            }
        }
        
        // dedupe (s always an Object)
        var ri = d.refs.indexOf(s);
        if (ri < 0) {
            ri = d.refs.push(s) - 1;
            d.refid = d.refid || {};
            d.refid[ri] = d;
        }
        else {
            var od = d.refid[ri];
            // dupe seeing very interesting for -jod
            return;
        }
        
        if (d.hup) {
            // clone each thing, not repointing tw/tv/z etc
            // < a separate object, a map to the result of the map this is
            //d.infolate == null and d.infolate = 1;
            s = G.h(A,C,G,T,'Cye',s);
            s.y.D = D;
        }
        
        var dd = function(d){
            d = $.extend({},d);
            d.path = (d.path||[]).slice();
            return d
        };
        var up = d.out && d;
        d = dd(d);
        if (up) {
            d.up = up
        }
        d.s = s;
        d.path.push(s.t+' '+s.y.cv);
        if (d.ind == null) {
            d.ind = '  ';
        }
        // ^ accumulates on every depth's return of a string
        d.d = d.d || 0;
        d.d++;
        // depth limit vs depth
        if (d.dl && d.dl < d.d) {
            return;
        }
        
        var out = d.out = [];
        var one;
        var my = [];
        
        if (d.cbfirst) {
            one = y(s,d)
        }
        if (d.not) {
            return
        }
        if (d.nofurther) {
            return one
        }
        
        // )
        //c the ways to go deep, should be all? will dedup
        // user throws something on any way
        if (s.sc.z) {
            var z = s.sc.z.filter(function(s){ return 1 && s });
            if (d.zort) {
                d.zort(z,s,d);
            }
            for (var i in z) {
            var D = z[i];
                out.push( G.h(A,C,G,T,'ind',D,y,d) );
            }
        }
        
        if (s.y.in) {
            out.push( G.h(A,C,G,T,'ind',s.y.in,y,d) );
        }
        
        if (s.y.tw) {
            for (var t in s.y.tw) {
            var D = s.y.tw[t];
                out.push( G.h(A,C,G,T,'ind',D,y,d) );
            }
        }
        
        if (s.y.tv) {
            for (var t in s.y.tv) {
            var vv = s.y.tv[t];
            if(typeof vv != 'object') { continue }
            for (var v in vv) {
            var D = vv[v];
                out.push( G.h(A,C,G,T,'ind',D,y,d) );
            }}
        }
        
        out = out.filter(function(s){ return 1 && s });
        // flatten a bit, G.h(A,C,G,T,'ind') returns js arrays
        var oute = []; 
        out.map(function(s){
            s.constructor == Array ? 
                s.map(function(s){ oute.push(s) })
            : oute.push(s)
        });
        out = oute;
        
        out = out.filter(function(s){ return 1 && s }).map(function(s){
            if (typeof s == 'string')
                return s.split("\n").map(function(s){ return d.ind+s }).join("\n")
        
            if (typeof s.constructor == Object) {
                if (d.infolate) {
                    if (!s.c.ind) {
                        // (once) write where things are
                        // on the things themselves
                        s.c.ind = d.d;
                        s.c.inds = '';
                        var i = 0; // to d.d==1 for the first level
                        while (i++ < d.d)
                            s.c.inds += '  ';
                        s.c.inside = d.path;
                    }
                }
                my.push(s);
            }
            return s
        });
        
        if (s.y.next && !d.nonext) {
            var od = dd(d);
            od.path.pop();
            od.d--;
            out.push( G.h(A,C,G,T,'ind',s.y.next,y,od) );
        }
        
        if (!d.cbfirst) {
            one = y(s,d)
        }
        if (d.not) {
            return
        }
        out.unshift(one);
        
        out = out.filter(function(s){ return 1 && s });
        if (!out.length) {
            return
        }
        var retrefs = out.filter(function(s){ return typeof s != 'string' }).length > 0;
        
        if (d.d == 1 && !retrefs) {
            if (d.wantarray) {
                return out
            }
            return out.join("\n");
        }
        else {
            // an N with insidenesses, has been organised, located...
            // put insides (C.sc.z,yin) in a z on the outside
            if (my.length && typeof one == Object) {
                one.sc.z = my
            }
            // return every C in N, each G.h(A,C,G,T,'ind') leaves [] to dissolve
            var flat = [];
            for (var i in out) {
            var s = out[i];
                if (s.constructor != Array) {
                    flat.push(s); continue
                }
                for (var I in s) {
            var S = s[I];
                    flat.push(S);
                }
            }
            return flat
        }
        
        };
    intag			{"acgt":"s","coded":"1","dige":"284ddc1cd43d","js":"eye","args":"A,C,G,T,s","Wavel":"NutPhonica/NutCons"}
      c s: |
        function(A,C,G,T,s) {
        var M = [s];
        if (typeof s == 'object') {
            // TODO apply s[0] around s[*], ref s[n] and s[n] = G.h(A,C,G,T,'intag',s[n])
        }
        s = M[0];
        s = ''+s;
        var num = /^>(\d+)?(?::(\w*))? ?/;
        var m = s.match(num);
        if (m) {
            s = s.replace(num,'');
            var style = '';
            if (m[1]) {
                var col = m[1].substr(0,1);
                var siz = m[1].substr(1,1);
                if (col) {
                    // 0 red, 3 yellow, 6 blue, 9 purple
                    // the 2-3 and 5-6 is hard to discern
                    var lig = col == 3 || col == 6 ? '30' : '60';
                    style += "color:hsl("+(col*30)+", 90%, "+lig+"%);";
                }
                if (siz) {
                    style += "font-size:"+(siz*15)+"%;";
                }
            }
            var tag = m[2] || 'n';
            s = '<'+tag+(style.length ? ' style="'+style+'"' : '')+'>'
                + s + '</'+tag+'>';
        }
        return s
        
        };
    J			{"acgt":"J s","args":"A,C,G,T,J,s","dige":"a29a14b25b0e","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,J,s) {
        if (typeof J == 'string') {
            s = J; J = A[1];
        }
        var V = A;
        var A = J||A;
        var J = G.h(A,C,G,T,'Aye',s);
        // on a chain
        J[2] = J[1];
        J[1] = J;
        // pulls A
        J.sc.N = J.sc.N || [];
        return J
        
        };
    jam			{"acgt":"Hz notmany","args":"A,C,G,T,Hz,notmany","coded":1,"dige":"a21ec4733d9a","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,Hz,notmany) {
        Hz = Hz || 5
        
        var t = A.t;
        var jams = A[1].sc.jams = A[1].sc.jams || {};
        var jam = jams[t];
        if (jam) {
            return jam()
        }
        
        var times = 1;
        var msg;
        jams[t] = function(){
            G.h(A,C,G,T,"yl",1000,function(){ times-- < 1 && delete jams[t] });
            if (times++ < Hz) {
                return 0
            }
            if (!msg) { msg =
        G.h(A,C,G,T,"c",'>38 jam',[A[1].t, t, '>37:times', '>'+Hz+'Hz']);
            }
            msg.set('times',times);
            return 1
        };
        return 0
        
        
        
        };
    Jin			{"acgt":"s","coded":"1","dige":"45ffa00d23eb","js":"eye","args":"A,C,G,T,s","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,s) {
        if (A[1] != A[4]) {
            G.h(A,C,G,T,"c",'wherefour',[]);
        }
        // toggle
        if (s && s.t.match(/^S\+/)) {
            return G.h(A,C,G,T,'waylay','Jinloop');
        }
        // thinking
        G.h(A,C,G,T,'Jinthe','reset_event_listeners');
        G.h(A,C,G,T,'waylay','AndContinue');
        
        };
    Jinthe			{"acgt":"s","coded":"1","dige":"f23e94b1fbdb","js":"eye","args":"A,C,G,T,s","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,s) {
        // comes from event sometimes
        A = window.A;
        
        var reset_event_listeners = function(){
            G.clof(); G.keof();
            G.clon(); G.keon();
            delete G.c.B;
        };
        if (s == 'reset_event_listeners') {
            return reset_event_listeners();
        }
        
        A.c.ws = A.c.ws || 1;
        
        G.c = {};
        G.sc = {};
        G.DNS = {};
        
        var glo = ['h','t'];
        for (var i in glo) {
            var t = glo[i];
            var z = G.t(A,C,G,T,'i',t);
            var code = z.c.code;
            if (typeof code != 'function') {
                throw new Error("Give I.i."+t);
            }
            G[t] = code;
        }
        // ^ v ?
        G.h = A.I.eye.y.tw.h.c.code;
        
        // many G means many A[4] for now,
        // find the A:top to sprout the document -> stylehousings
        //   G.h(A,C,G,T,'Ban') for errors
        //   G.h(A,C,G,T,'gev') for events - target will climb up to an A[4] element
        //     and non-target evs (keydown) will go to the last targeted A[4]
        //     you could setup more handlers on inners that ev.stopPropagation
        window.BamonG = function(){
            var A = G.c.B.sc.A;
            return A[4].up
        };
        window.onerror = function(msg,url,lineNo,colNo,error){
            A = BamonG();
            if (A.c.bang) {
                return
            }
            A.c.bang = 1;
            G.h(A,C,G,T,'Ban',error,msg,url,lineNo,colNo,error);
            delete A.c.bang;
            return
        };
        
        A.t = 'top';
        A.y = A;
        delete A.c.T;
        
        A.on = $('body')[0];
        
        G.h(A,C,G,T,'Four');
        
        // location.search.match('^\\\?v=')
        
        // click, keys - outsiders starting with A[5]
        G.clon = function(){ $(window).on("click", function(ev){ G.h(A,C,G,T,'gev',ev) }) };
        G.keon = function(){ $(window).on("keydown", function(ev){ G.h(A,C,G,T,'gev',ev) }) };
        G.clof = function(){ $(window).off("click") };
        G.keof = function(){ $(window).off("keydown") };
        G.doh = function(ev,h){ G.h(A,C,G,T,'doh',ev,h) };
        
        G.togwid = function(m,fr,to){
            if ($(m).attr('togwid') == to)
                to = fr
            $(m).attr('togwid', to)
            $(m).css('width', to);
        };
        
        G.h(A,C,G,T,'headi','A','Jin');
        G.h(A,C,G,T,'headi','C','Typ');
        G.h(A,C,G,T,'headi','G','begoin');
        G.h(A,C,G,T,'headi','T','Tri');
        
        reset_event_listeners();
        
        
        };
    ks			{"acgt":"s","coded":"1","dige":"cf5e1282af2d","js":"eye","args":"A,C,G,T,s","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s) {
        return Object.keys(s).sort().join(',')
        
        };
    lim			{"acgt":"s lim cb","args":"A,C,G,T,s,lim,cb","coded":1,"dige":"2c14ff1ed6eb","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s,lim,cb) {
        var len = s.length;
        lim = lim || 9;
        var rev;
        if (lim < 0) {
            rev = 1; lim *= -1;
        }
        var rem = [];
        while (len > lim) {
            var v;
            if (rev) {
                v = s.pop()
            }
            else {  v = s.shift() }
            if (cb) {
                cb(v);
            }
            rem.push(v);
            len--;
        }
        if (rem.length) {
            return rem
        }
        
        };
    m			{"acgt":"M s","args":"A,C,G,T,M,s","dige":"9b214b81f338","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,M,s) {
        if (typeof s != 'object') {
            throw new Error("weird M s"+s);
        }
        if (typeof M != 'object') {
            throw new Error("weird M"+M);
        }
        //G.h(A,C,G,T,'clusp');
        C = G.h(A,C,G,T,'Cye',s);
        M.push(C);
        return C
        
        };
    n			{"acgt":"s ov","args":"A,C,G,T,s,ov","dige":"6891daf48202","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s,ov) {
        if (typeof s != 'object') {
            {var er = new Error("weird n"); er.tc = [s]; throw er}
        }
        //G.h(A,C,G,T,'clusp');
        
        var C = G.h(A,C,G,T,'Cye',s);
        if (T.nN) {
            T.nN.push(C); return C
        }
        var c = {};
        if (typeof ov == 'object') {
            c = ov; ov = null;
        }
        var Y = G.h(A,C,G,T,'Aye','n',0,C,c);
        
        var ret = ov ? Y : C;
        
        try {
            G.h(A,C,G,T,'thro',Y,ov||8)
        }
        catch (e) {
            var async = (e.message || e).match(/^async/);
            var title = "via "+A[1].t+" e "+C.t;
        
            if (async && (Y.c.async || A.c.async)) {
        G.h(A,C,G,T,"c",'>99 nasync',[e.message, title]);
                return ret
            }
            // TES top level continues
            if (!Y.c.T.oT) {
                A[4].sc.N.push(Y);
            }
        
        G.h(A,C,G,T,"c",'>9 nvoidsync',[title]);
        
            if (!async || Y.c.T.sync) {
                // error is not about async
                // , or we can't handle it being ab
                //e.tc = e.tc || [];
                //e.tc.unshift(title);
                (e.catches = e.catches || []).push({stack:e.stack,tc:["inn"]}); throw e;
            }
            // throw means pin must redo to retrigger this n
            (e.catches = e.catches || []).push({stack:e.stack,tc:["inn"]}); throw e;
            // J7 could find ground yAcv < 8
        }
        
        return ret
        
        };
    oleak			{"acgt":"s d l","args":"A,C,G,T,s,d,l","coded":1,"dige":"2aeade7a4585","js":"eye","Wavel":"NutErupts/NutLands"}
      c s: |
        function(A,C,G,T,s,d,l) {
        var fail = 0;
        var was = window.maxyamling;
        window.maxyamling = d * 3;
        var code;
        try { code = jsyaml.safeDump(s) }
        catch (er) {
            window.maxyamling = was;
            if (er.message != "Too much to yaml") {
                (er.catches = er.catches || []).push({stack:er.stack}); throw er;
            }
            fail = 1;
        }
        if (l && code && code.length > l) {
            fail = 'large-ish'
        }
        window.maxyamling = was;
        return fail
        
        };
    peel			{"acgt":"s d","args":"A,C,G,T,s,d","coded":1,"dige":"57ce0653db2e","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s,d) {
        d = d || {};
        var c = {};
        if (!s.length) {
            return c
        }
        var m = s.split(d.sep || ',');
        for (var i in m) {
            var n = m[i];
            n = n.split(d.hie || ':');
            var k = n.shift();
            var v = n.length == 1 ? n[0]
                : n.length > 1 ? n.join(d.hie || ':')
                : 1;
            if (v && typeof v == 'string' && v.match(/^-?\d+\.\d+$/)) {
                v = v * 1
            }
            c[k] = v;
        }
        return c
        
        };
    readLines			{"acgt":"s opt","args":"A,C,G,T,s,opt","coded":1,"dige":"665aef4cd849","js":"eye","Wavel":"NutErupts/NutLands"}
      c s: |
        function(A,C,G,T,s,opt) {
        opt = opt || {};
        var L = s.split("\n");
        var oL = [];
        var tot = L.length;
        var N = [];
        var stack = [];
        var paniconce = 0;
        
        while (L.length) {
        
        var l = L.shift();
        oL.push(l);
        if (!l.length) {
            continue
        }
        var lin = l.match(/^(\s*)(.*)$/);
        var ind = lin[1];
        var d = ind.length / 2;
        l = lin[2];
        var li = l.split("\t");
        var t = li[0];
        var y = li[1];
        var c = li[2];
        var sc = li[3];
        // sc can kick in early, still one \t
        if (y && y[0] == '%') {
            sc = y.slice(1); y = '';
        }
        if (c && c[0] == '%') {
            sc = c.slice(1); c = '';
        }
        if (y && opt.y1 && opt.y1[0] == '%') {
            (opt.tosc = opt.tosc || {})[opt.y1.slice(1)] = y; y = '';
        }
        var s = li[4];
        
        if (t.match(/^\W/)) {
            t = $.parseJSON(t);
        }
        
        y = y || 1
        y = 1*('0.'+y);
        
        if (s && s.match(/^\W/)) {
            s = $.parseJSON(s);
        }
        if (c && c.match('^"')) {
            s = $.parseJSON(c);
            c = {};
        }
        else if (c && c.match(/^\W/)) {
            c = $.parseJSON(c)
        }
        else if (c) {
            c = G.h(A,C,G,T,'peel',c)
        }
        else { c = {} }
        
        if (s) {
            c.s = s;
        }
        
        if (sc && sc.match(/^\W/)) {
            sc = $.parseJSON(sc)
        }
        else if (sc) {
            sc = G.h(A,C,G,T,'peel',sc)
        }
        else { sc = {} }
        
        var C = {t:t,y:{cv:y},c:c,sc:sc};
        
        //c readLines indented bits
        
        var k;
        var v;
        var indenting = function(){
            if (!L.length) {
                return;
            }
            var m = L[0].match("^"+ind+"  (\\w[\\w ]+):(?: (\\||.+))?$");
            if (!m) {
                return;
            }
            k = m[1];
            v = m[2];
            return 1;
        };
        while (indenting()) {
            var string;
            if (v === '|') {
                string = 1;
                v = undefined;
            }
            if (v && v.match(/^\W/)) {
                v = $.parseJSON(v)
            }
            L.shift();
            k = k.split(' ');
            var nk = k.shift();
            var gk = k.join(' ');
            if (!v) {
                var s = [];
                var one;
                var blockquoting = function(){
                    if (!L.length) {
                        return;
                    }
                    var m = L[0].match("^"+ind+"    (.*)$");
                    if (!m) {
                        return;
                    }
                    one = m[1];
                    return 1;
                }
                while (blockquoting()) {
                    s.push(one);
                    L.shift();
                }
                v = s.join("\n");
                // console.log("Loaded "+nk+gk+": "+v+'  Next: '+L[0]);
                if (!string) {
                    v = jsyaml.safeLoad(v);
                }
                else {
                    if (!v.match(/\n$/)) {
                        v = v+"\n"
                    }
                }
            }
            C[nk][gk] = v;
        }
        
        if (d.toFixed() != d) {
            G.h(A,C,G,T,"c",'fractionalind',[d, C, T.readinglv]);
        }
        d = 1 * d.toFixed();
        if (d > 0) {
            var p;
            var dl = d;
            while (dl--) {
                p = stack[dl];
                if (p) {
                    break
                }
            }
            if (dl < d - 1) {
                var few = oL.slice(-3);
                if (! paniconce++)
        G.h(A,C,G,T,"c",'toomuchind',[d, dl, T.readinglv, few]);
                d = dl+1;
            }
            // use io?
            p.sc.z = p.sc.z || [];
            p.sc.z.push(C);
            // tv/tw/in/next?
            var tv =
            p.y.tv = p.y.tv || {};
            tv[C.t] = tv[C.t] || {};
            tv[C.t][C.y.cv] = C;
            // a mass inCing, dialecting
        }
        else {
            N.push(C);
        }
        stack[d] = C;
        while (stack[d+1])
            stack.pop();
        if (opt.tosc) {
            ex(C.sc,opt.tosc);
        }
        
        }
        return N
        
        };
    S			{"acgt":"s t talk params","args":"A,C,G,T,s,t,talk,params","coded":1,"dige":"7e7e520c86b4","js":"eye","Wavel":"NutProcess/Domes"}
      c s: |
        function(A,C,G,T,s,t,talk,params) {
        if (A[4].c.Srupto) {
            return A[4].c.Srupto(A,C,G,T,s,t,talk,params)
        }
        G.h(A,C,G,T,'clusp');
        A.e && G.h(A,C,G,T,'thro',A.e,6);
        if (A.c.S) {
            return A.c.S(s,t,talk,params)
        }
        // sync progress to ground...
        var g = A.ground;
        if (!g) {
            throw new Error("groundless doming");
        }
        var Do =
        g.sc.Doing = g.sc.Doing || {};
        if (Do[s+t]) {
            return 0
        }
        Do[s+t] = 1;
        return 1
        
        
        
        };
    sca			{"acgt":"s precision","args":"A,C,G,T,s,precision","coded":1,"dige":"480b36f18398","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s,precision) {
        if (s && s*1 != s) {
            return
        }
        while (s >= 1)
            s /= 10
        return +s.toPrecision(precision || 4)
        
        };
    Serialise			{"acgt":"s comp c","args":"A,C,G,T,s,comp,c","coded":1,"dige":"fe89b1144300","js":"eye","Wavel":"NutErupts/NutLands"}
      c s: |
        function(A,C,G,T,s,comp,c) {
        if (!s) {
            throw new Error("undef");
        }
        var ers = [];
        var cb = function(s,d){
            var part = "Compress";
            try {
                // put this one bit back so ind can keep moving in order
                var z = s.sc.z;
                part = 'comp';
                comp && comp(s,d);
                if (d.not) {
                    return
                }
                part = 'Compress';
                G.h(A,C,G,T,'Compress',s);
                part = 'toLines';
                var string = G.h(A,C,G,T,'toLines',s);
                if (z) {
                    s.sc.z = z
                }
                return string;
        
            }
            catch (er) {
                ers.push([part,d,s,er]);
                return ki(s,2)+"   !"+part+"! "+er
            }
        };
        var op = {hup:1};
        if (c) {
            $.extend(op,c);
        }
        var l = G.h(A,C,G,T,'ind',s,cb,op);
        if (ers.length) {
            G.h(A,C,G,T,"c",'>29 unserial',[ki(ers)]);
        }
        if (!l.match(/\n$/)) {
            l += "\n"
        }
        return l
        
        };
    sJ			{"acgt":"J s","args":"A,C,G,T,J,s","dige":"f7b59465a9f8","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,J,s) {
        if (typeof J == 'string') {
            s = J; J = A[1];
        }
        if (J.sc[s]) {
            return J.sc[s];
        }
        var j = G.h(A,C,G,T,'J',J,s);
        J.sc[s] = j;
        j.I = A[4].I;
        return j
        
        };
    sortsip			{"acgt":"s","coded":"1","dige":"82d41fd84572","js":"eye","args":"A,C,G,T,s","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s) {
        var sortsip;
        return sortsip = function(l,r,i){
        i = i || 0
        if (l.c.ip[i] == null) {
            return 0
        }
        if (r.c.ip[i] == null) {
            return 1
        }
        if (l.c.ip[i] > r.c.ip[i]) {
            return 1
        }
        if (l.c.ip[i] < r.c.ip[i]) {
            return 0
        }
        return sortsip(l,r,i+1)
        }
        
        };
    t			{"acgt":"s t","args":"A,C,G,T,s,t","dige":"08efbe4eac10","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s,t) {
        if (typeof s == 'object') {
            throw new Error("Nevers");
        }
        var D;
        for (var n = 1; n <= 5; n++) {
            var Y = A[n];
            if (!Y) {
                continue
            }
            var I = Y.I;
            if (!I) {
                continue
            }
            // container/personality/embryo
            D = I[s];
            // thing/step/nodule/item
            if (D && t != null) {
                D = D.y.tw[t];
            }
            if (D) {
                break
            }
        }
        return D;
        
        };
    thime			{"acgt":"s","coded":"1","dige":"caf786994c25","js":"eye","args":"A,C,G,T,s","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,s) {
        s = G.h(A,C,G,T,'desca',s,4);
        if (s < 1) {
            return (s * 1000)+'ms';
        }
        return s+'s';
        
        };
    thro			{"acgt":"ov sC","args":"A,C,G,T,ov,sC","dige":"ec4f916bdf49","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,ov,sC) {
        if (ov && typeof ov == 'object') {
            if (!(typeof ov.t == 'string' && ov.y && ov.c && ov.sc)) {
                throw "given foreign object ov: "+A[4].sc.ki(ov)
            }
            if (ov.y != ov) {
                if (!ov.y.A) {
                    throw new Error("given C not yA");
                }
                A = ov.y.A;
                if (A.c.s != ov) {
                    throw new Error("given CyA not Acs=C");
                }
            }
            else { A = ov }
            ov = null;
        }
        if (sC && typeof sC == 'number') {
            ov = sC; sC = null;
        }
        var T = A.c.T = A.c.T || {};
        if (T.not) {
            return
        }
        if (ov) {
            A.c.ov = G.h(A,C,G,T,'sca',ov);
        }
        if (sC) {
            A.c.s = sC;
        }
        C = A.c.s = A.c.s || {t:'',y:{A:A},c:{},sc:{}};
        var t = G.h(A,C,G,T,'t',A.t);
        if (!t) {
            throw new Error("thro no t: "+A.t);
        }
        var z = t.y.in;
        while (z && A.c.ov >= z.y.cv) {
            if (T.not) {
                break
            }
            var D = z;
            z = z.y.next;
        
            if (A.cv > D.y.cv) {
                continue
            }
            if (T.once && A.cv == D.y.cv) {
                continue
            }
            // seek refinds I, resuming from the same D, sub-cv
            if (T.seek && (T.seek.t != D.t || T.seek.y.cv != D.y.cv)) {
                continue
            }
            else { delete T.seek }
            var Acv = A.cv;
        
            T.N = T.N || {};
            C = A.c.s;
        
            if (!D.sc.any) {
                if (D.sc.nk) {
                    if (!C[D.sc.nk]) {
                        continue;
                    }
                }
                if (D.sc.gk) {
                    if (!C[D.sc.nk][D.sc.gk]) {
                        continue;
                    }
                }
            }
            var es;
            if (D.sc.gk) {
                es = C[D.sc.nk][D.sc.gk];
            }
            if (D.sc.s) {
                es = D.sc.s;
            }
        
            // temp? until A.cv decided to be set before doing?
            T.thro = D;
        
            if (G.c.bugt) {
                debugger;
            }
            G.h(A,C,G,T,D,es);
        
            if (typeof T.N == 'object' && Object.keys(T.N).length == 0) {
                delete T.N
            }
            if (T.N != null) {
                G.h(A,C,G,T,'TN',T.N); delete T.N
            }
            if (T.not == '2') {
                return delete T.not
            }
            if (Acv == A.cv) {
                A.cv = D.y.cv;
            }
        
            if (T.whack || T.not || T.seek != null) {
                break
            }
        }
        if (T.seek != null) {
            if (T.seek == '') {
                T.seek = z
            }
            else
            if (T.seek != 0) {
                A.cv = G.h(A,C,G,T,'sca',T.seek)
            }
            // A.t probably changed, become new personality
            if (typeof T.seek != 'object') {
                delete T.seek;
            }
            return G.h(A,C,G,T,'thro');
        }
        delete T.whack;
        if (T.not == 1) {
            delete T.not;
        }
        
        };
    time			{"acgt":"time delta","args":"A,C,G,T,time,delta","coded":1,"dige":"68d6c156ba2f","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,time,delta) {
        var now = Date.now() / 1000;
        // delta as ttl
        if (time && delta) {
            return time + delta > now
        }
        // time since time, 4dp (floating float?)
        if (time) {
            return G.h(A,C,G,T,'desca',now-time)
        }
        // time
        return now
        
        };
    TN			{"acgt":"s","dige":"39958b2a8d97","js":"eye","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        A[1].sc.N.push(A);
        
        if (typeof s == 'object') {
            // take T.N.$tocv = $time,
            // or T.N = $tocv
            var tocv;
            var time;
            $.each(s, function(k,v){
                if (tocv != null) {
                    throw new Error("com TN{}");
                }
                tocv = 0+k;
                time = 0+v;
                // check back/rerequest/slomo time
            });
            s = tocv;
            // does the identity as eg 3 remain?
            if (time) {
                A.sc.due = G.h(A,C,G,T,'time') + time;
            }
        }
        if (typeof s != 'number') {
            throw new Error("com TN");
        }
        T.not = 1;
        // first number sets A.cv
        if (s != 0) {
            A.cv = G.h(A,C,G,T,'sca',s); T.not = 2;
        }
        // exit before Acv == A.cv we set, eg when 6 did T.N=6
        if (s != 0) {
            T.not = 2;
        }
        // second number is time due
        
        };
    toLines			{"acgt":"s","coded":"1","dige":"86f59472ba1d","js":"eye","args":"A,C,G,T,s","Wavel":"NutErupts/NutLands"}
      c s: |
        function(A,C,G,T,s) {
        if (s) {
            C = s;
        }
        var t = C.t;
        var y = C.y.cv;
        // aims for simplicity of notation for G.h(A,C,G,T,'readLines'), G.h(A,C,G,T,'C'), G.h(A,C,G,T,'peel')
        // block quotes (BQ) big strings or data after the  line
        // uses json for anything complicated
        // z insides done by the process around this one Line
        //  - they have the same indent as BQs
        //    but their t should json or not look like BQ
        // hath
        var h = {};
        h.c  = $.extend({},C.c||{});
        h.sc = $.extend({},C.sc||{});
        delete h.sc.z;
        // needs json
        var n = {};
        // needs blockquote
        var q = {};
        
        // check out how sayable the values on the line are
        // for c/sc as peelable, 
        // < we can know thing:thing:thing
        //   means thing = 'thing:thing'
        var peelok = /^[\w\.\-%\/:]+$/;
        var nameok = /^\w[\w\.\-%\/]*$/;
        var simp = function(s){
            s = ''+s;
            return s.match(nameok) && s.length < 24
        };
        // inject 2sphere
        var lod = function(n,nk,gk,v){
            n[nk] = n[nk] || {};
            n[nk][gk] = v;
        };
        for (var nk in h) {
            var gkv = h[nk];
            if(typeof gkv != 'object') { continue }
        for (var gk in gkv) {
            var v = gkv[gk];
            if (!simp(gk)) {
                lod(n,nk,gk,v);
                continue
            }
            if (typeof v != 'string' && typeof v != 'number') {
                // is > 4*3 nodes or encodes to > 42 chars
                if (G.h(A,C,G,T,'oleak',v,4,42) ) {
                    if (G.h(A,C,G,T,'oleak',v,24)) {
                        throw "Leaky "+nk+"."+gk+": "+ki(v);
                    }
                    // big enough to quote, simplifies remainder
                    lod(q,nk,gk,v);
                }
                else {
                    // ref too small to quote, json hemisphere
                    lod(n,nk,gk,v);
                }
            }
            else {
                if (v.length > 42 && v.match(/\n/)) {
                    // long enough to quote
                    lod(q,nk,gk,v);
                }
                else if ((v+'').match(peelok)) {
                    // decipherable to G.h(A,C,G,T,'peel')
                }
                else {
                    // midway to unwieldy
                    lod(n,nk,gk,v);
                }
            }
        }}
        
        // quote freaks, if just a few break the peelability of many
        for (var nk in n) {
            var g = n[nk];
            var v = h[nk];
            if (!Object.keys(v).length) {
                continue;
            }
            var complex_keys;
            for (var i in g) {
            var k = g[i];
                if (!simp(k)) {
                    complex_keys = 1;
                }
            }
            if (complex_keys) {
                continue;
            }
        
            if (Object.keys(g).length / Object.keys(v).length < 0.3) {
                for (var i in g) {
            var k = g[i];
                    lod(q,nk,k,h[nk][k]);
                }
            }
        }
        
        // remove quoted things and their need of json from the line
        for (var nk in q) {
            var gkv = q[nk];
            if(typeof gkv != 'object') { continue }
        for (var gk in gkv) {
            var v = gkv[gk];
            h[nk] && delete h[nk][gk];
            n[nk] && delete n[nk][gk];
        }}
        for (var nk in n) {
            var gks = n[nk];
            // all freaks got quoted:
            if (!Object.keys(gks).length) {
                delete n[nk]
            }
        }
        //c toLines encoded bits
        // may pass a T.enj_catch, so functions can warn/show up as 'CODE'
        var enj = function(s){ return window.enj(s,T) };
        
        // t can be messy
        var l = simp(t) ? t : enj(t);
        
        // y.cv = 1 is implied
        if (!y) {
            y = 1
        }
        y = (y+'').replace(/^0\./,'');
        l += "\t"+(y == 1 ? '' : y);
        
        // throw it one way or another
        var hem = ['c','sc'];
        for (var i in hem) {
            var nk = hem[i];
            var v = h[nk];
            if (nk == 'c' && 0 == Object.keys(v).length) {
                // blank
                l += "\t";
            }
            else if (nk == 'c' && 1 == Object.keys(v).length && v.s) {
                // t y "the s" sc
                l += "\t"+enj(v.s);
            }
            else if (n[nk]) {
                // json bits: t y {W:"At"} {et:3,se:"te",ra:1}
                l += "\t"+enj(v);
            }
            else if (Object.keys(v).length) {
                // G.h(A,C,G,T,'peel') bits: t y W:At et:3,se:te,ra
                l += "\t"+G.h(A,C,G,T,'depeel',v);
            }
        }
        
        var L = [];
        //c toLines indented bits
        // < quoting with Line other N/C looking vals
        for (var nk in q) {
            var gkv = q[nk];
            if(typeof gkv != 'object') { continue }
        for (var gk in gkv) {
            var v = gkv[gk];
            var k = "  "+nk+" "+gk+":";
            if (typeof v != 'string') {
                // BQ yaml data
                T.eny_nkgk = [nk,gk];
                var v = eny(v,T);
                delete T.eny_nkgk;
                var vs = [];
                v = v.split("\n");
                for (var i in v) {
            var s = v[i];
                    vs.push("    "+s);
                }
                k += "\n"+vs.join("\n");
            }
            else if (simp(v)) {
                // simple strings
                // not confusible into 'Thing 2'
                k += " "+v;
            }
            else if (!v.match(/\n$/)) {
                // BQ implies trailing \n
                k += " "+enj(v);
            }
            else {
                // BQ string
                var vs = [];
                v = v.split("\n");
                for (var i in v) {
            var s = v[i];
                    vs.push("    "+s);
                }
                k += " |\n"+vs.join("\n");
            }
            k = k.replace(/\n\s*$/,'');
            L.push(k);
        }}
        
        // extra lines (L) sorted, larger bits after smaller
        L = L.sort();
        var tidy = [];
        var large = [];
        for (var i in L) {
            var s = L[i];
            s.length > 300 ? large.push(s) : tidy.push(s)
        }
        l = [l];
        if (tidy.length) {
            l.push(tidy.join("\n"))
        }
        if (large.length) {
            l.push(large.join("\n"))
        }
        l = l.join("\n");
        
        return l
        
        };
    Tri			{"acgt":"s","coded":"1","dige":"b3b1a5e32a42","js":"eye","args":"A,C,G,T,s","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,s) {
        // toggle time to live
        if (s && s.t.match(/^S\+/)) {
            return G.h(A,C,G,T,'waylay','VastTimeout');
        }
        
        if (A[1].t != 'Tri') {
            return G.h(A,C,G,T,'n',['Tri']);
        }
        
        G.h(A,C,G,T,'way',A[1].t);
        
        };
    TuneTimeMachine			{"acgt":"s","dige":"2ff2808cb81f","js":"eye","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        A[1].sc.N.push(A);
        // to detangle - make sure A[1] is stashed elsewhere
        if (A.c.Jupstash) {
            A.c.Jupstash();
        }
        // probably like a T.nose with instant doming abort
        var D = T.thro;
        if (D && !T.once) {
            A.cv = D.y.cv;
        }
        // make a little view of the A/B stacks?
        var per = A.t+'@'+A.cv;
        throw new Error("async "+per+": "+s);
        };
    Typ			{"acgt":"s","coded":"1","dige":"c6bdb4f8a3c2","js":"eye","args":"A,C,G,T,s","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,s) {
        if (A[1].t != 'Typ') {
            return G.h(A,C,G,T,'n',['Typ']);
        }
        
        G.h(A,C,G,T,'way',A[1].t);
        
        };
    u			{"acgt":"s","dige":"d02ec7757727","js":"eye","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        var u = G.h(A,C,G,T,'sJ','u');
        u.c.N = u.c.N || [];
        u.c.N.push(s);
        if (s.constructor == Array && s[0] == '') {
            G.h(A,C,G,T,'clusp')
        }
        
        };
    way			{"acgt":"t ar cb noop","args":"A,C,G,T,t,ar,cb,noop","dige":"c7803c5bb647","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,t,ar,cb,noop) {
        var w = typeof t == 'object' ? t : G.h(A,C,G,T,'t','w',t);
        var ttl = A[4].c.ttl || 5;
        if (!(w && w.sc.now && G.h(A,C,G,T,'time',w.sc.now,ttl))) {
            w = null
        }
        if (noop == 'nottl') {
            w = null
        }
        
        if (!w) {
            if (cb == 'noop') {
                cb = function(){};
            }
            else
            if (typeof cb == 'string') {
                throw new Error("Cant go async: "+cb);
            }
            var get = '/way/'+t;
            var is_done;
            var done = function(s,how,c){
                is_done = 1;
                if (how != 'success') {
                    {var er = new Error("Failed request: "+how); er.tc = [c]; throw er}
                }
                var dige = c.getResponseHeader('Dige');
                var w = G.h(A,C,G,T,'Cye',[t,1,{s:s},{of:'w',dige:dige}]);
                A[5].I = A[5].I || {};
                var D = A[5].I.w = A[5].I.w || G.h(A,C,G,T,'Cye',['w','',{},{z:[]}]);
                D.y = D.y || {};
                D.y.tw = D.y.tw || {};
                D.y.tw[t] = w;
                w.sc.now = G.h(A,C,G,T,'time');
                // < check it compiles? but we don't know its args,
                //   unless they are vaguely known by bumping into compile errors
                //   awaiting better field recording (MelTest frontier of)
                A.sc.ready = 1;
                //~w!: t
                if (cb) {
                    if (G.h(A,C,G,T,'arfgunc',cb) == "s") {
                        // wants its return value with given ar...
                        //~w cb s: t
                        var s = G.h(A,C,G,T,'way',t,ar,'already_async');
                        cb(s);
                    }
                    else {
                        // containing a sync G.h(A,C,G,T,'way') call
                        // or a way to get the w back?
                        //~w cb: t
                        cb(t,ar,w);
                    }
                }
            };
            var r = $.ajax(get);
            r.done(done);
            var checks = 5;
            var check = function(){
                if (is_done) {
                    return;
                }
                if (!r.statusText) {
                    if (checks-- > 0) {
                        return G.h(A,C,G,T,'yl',150,check);
                    }
                    console.log("Long wait going to: "+get)
                    if (checks > -3) {
                        return G.h(A,C,G,T,'yl',666,check);
                    }
                    return
                }
                if (r.statusText == 'Not Found') {
                    throw new Error("No way: "+t);
                }
                if (r.statusText != 'OK') {
                    throw new Error("Weird ajaxtus: "+r.statusText);
                }
                //~>57 waylo: t
                done(r.responseText, 'success', r);
            };
            check();
            //~w?: t
            if (!cb) {
                G.h(A,C,G,T,'TuneTimeMachine','w:'+t)
            }
            return
        }
        
        ar = ar || {};
        var args = G.h(A,C,G,T,'ks',ar);
        if (args != w.c.code_args) {
            delete w.c.code;
        }
        // code is already JaBabz'd
        // < CoArgulate for ar, put as knowable source file?
        // < make it c.code and G.h(A,C,G,T,'h') for a B?
        if (!w.c.code) {
            var name = 'w_'+w.t+'_'+w.sc.dige+'_'+args;
            name = name.replace(/\W+/g,'_');
            var ways = A[5].I.w;
            ways.sc.namedcode = ways.sc.namedcode || {};
            var code = ways.sc.namedcode[name];
            if (code) {
                w.c.code = code;
            }
            else {
                var tar = 'ar';
                if (args) {
                    tar += ','+args;
                }
                // help Ban find its source
                G.c.B.sc.way = w;
                var code = 'w.c.code = function '+name+"(A,C,G,T,"+tar+"){\n"+w.c.s+"}";
                try{
                    eval(code);
                }
                catch(er){
                    // eval this on the console to see source...
                    window.lacode = code;
                    (er.catches = er.catches || []).push({stack:er.stack}); throw er;
                }
                // now compiled, we are not "in" it until run
                delete G.c.B.sc.way;
                ways.sc.namedcode[name] = w.c.code;
            }
            if (args) {
                w.c.code_args = args;
            }
        }
        if (noop || cb == 'noop') {
            return
        }
        var arm = [];
        var ark = args.split(',');
        for (var i in ark) {
            var k = ark[i];
            arm.push(k);
        }
        var so = ar[arm[0]];
        var st = ar[arm[1]];
        var sh = ar[arm[2]];
        var sf = ar[arm[3]];
        var si = ar[arm[4]];
        
        // help Ban find its source
        G.c.B.sc.way = w;
        return w.c.code(A,C,G,T,ar,so,st,sh,sf,si);
        
        };
    waylay			{"acgt":"t ar delay cb","args":"A,C,G,T,t,ar,delay,cb","dige":"f2ba131f16e5","js":"eye","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,t,ar,delay,cb) {
        if (typeof ar != 'object') {
            delay = ar; ar = {};
        }
        if (typeof delay == 'function') {
            cb = delay; delay = 0;
        }
        cb = cb || function(s){};
        if (delay) {
            // wait and then way
            // < expect download's tiny delay as well?
            G.h(A,C,G,T,"delay",delay,function(){ G.h(A,C,G,T,'waylay',t,ar,0,cb) });
        G.h(A,C,G,T,"c",'waylayter',[t, delay]);
            return
        }
        //~waylaydo: t
        G.h(A,C,G,T,'way',t,ar,cb)
        
        };
    Who			{"acgt":"s","coded":"1","dige":"49670fb3efb4","js":"eye","args":"A,C,G,T,s","Wavel":"NutC"}
      c s: |
        function(A,C,G,T,s) {
        if (A[1].t != 'Who') {
            return G.h(A,C,G,T,'n',['Who']);
        }
        
        G.h(A,C,G,T,'way',A[1].t);
        
        };
    yl			{"acgt":"delay cb","args":"A,C,G,T,delay,cb","coded":1,"dige":"30ae21b9bd5c","js":"eye","Wavel":"NutPhonica/NutPhone"}
      c s: |
        function(A,C,G,T,delay,cb) {
        setTimeout(cb, delay);
        
        };
  e		W:javascript
    einlookup			{"acgt":"s","act":"1","any":"1","coded":"1","dige":"834a60d11b2f","js":"e","v":"ceinlookup","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        T.once = 1;
        var Js = C.c.Jat ? C.c.Jat.slice() : [A[1]];
        var anein = 0;
        Js.reverse();
        for (var i in Js) {
            var J = Js[i];
            // last resort/undelivered
            if (J == J[4]) {
                break
            }
            // if near attention should try to create the handler
            //J == J[3]
            // A[1] will not be correct...
            // < isolate reaction down this Jath
            //J != J[3]
            // otherwise, the usual...
        
        var ein = J.sc.ein;
        if (!ein) {
            continue
        }
        anein = 1
        //!ein and return T.not = 2;
        
        A.c.idea = ein[C.t];
        if (!A.c.idea) {
            var parts = C.t.split('+');
            for (var i in parts) {
            var t = parts[i];
                A.c.idea = ein[t];
            }
        }
        if (typeof A.c.idea == 'function') {
            A.c.idea = {i:A.c.idea}
        }
        
        var id = A.c.idea ? A[4].sc.ki(A.c.idea) : 'no ein';
        G.h(A,C,G,T,"c",'>86 elvis',[ki(J,2), C.t, id]);
        // first/deepest one
        if (A.c.idea) {
            break
        }
        
        }
        if (!anein) {
            return T.not = 2;
        }
        if (!A.c.idea) {
            return T.not = 1;
        }
        
        
        };
    edo	4		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"b0f19d78e00a","js":"e","v":"cedo","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        T.once = 1;
        if (T.el) {
            return
        }
        // some vars
        var ar = {};
        ar.M = A[1].sc.M = A[1].sc.M || [];
        var e = ar.e = C;
        if (e.c.s) {
            ar.s = e.c.s;
        }
        C = A.n.c.s;
        // two ways about it
        for (var way in A.c.idea) {
            var pin = A.c.idea[way];
            if (way == 'w') {
                G.h(A,C,G,T,'way',pin,ar);
            }
            else
            if (way == 'i') {
                var l = G.h(A,C,G,T,'arfgunc',pin);
                // s = e.c.s? good for NutText/typing which 'says'
                if (l == 'A,C,G,T,s') {
                    pin(A,C,G,T,ar.s)
                }
                else if (l == 'A,C,G,T,s,c') {
                    // < Ec is the most pointed to thing... see Ch
                    var c = G.h(A,C,G,T,"E",'hC -1');
                    pin(A,C,G,T,ar.s,c)
                }
                else {
                    {var er = new Error("Buildargs: "+l); er.tc = [s]; throw er}
                }
            }
            else {
                {var er = new Error("idea not i/w"); er.tc = [A.c.idea]; throw er}
            }
        }
        // can repeat: e.t -> A.c.idea -> here ^
        if (T.seek) {
            return delete T.once;
        }
        T.el = 1;
        
        };
    edone	5		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"13a6e2e98b66","js":"e","v":"cedone","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        if (T.ok) {
            A.cv = 0.9;
            if (A.n.cv <= 0.6) {
        G.h(A,C,G,T,"c",'Can avoid J6ing',[]);
                T.not = 1;
                var oT = A.n.c.T;
                oT.not = 1;
                // put a 5 block e doing id
                oT.leaves = 'elvis';
                return;
            }
        G.h(A,C,G,T,"c",'Could avoid J6 next time',[]);
        }
        T.not = 2;
        
        };
    music	8	"function(A,C,G,T,s) {\n// yep\n\n};\n"	{"acgt":"s","act":"1","any":"1","coded":"1","dige":"c9e43ca60feb","js":"e","v":"cmusic","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
  ev		W:javascript
    ev			{"acgt":"s","act":"1","any":"1","coded":"1","dige":"c21fa0aab7e9","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'way','EleVisAn',{},'noop');
        G.h(A,C,G,T,'way','EleMento');
        
        };
    ev	2		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"ea80b0b0f02e","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'way','EleVisAn');
        if (T.el) {
            return T.not = 'satisfied ev@2'
        }
        
        };
    ev	3		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"41624d678aa7","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        var n = A.sc.wouldn;
        if (!n) {
            return
        }
        T.not = 'A:n ev@3'; // stop ev forever
        G.h(A,C,G,T,'n',n);
        
        };
    ev	4		{"acgt":"s","act":"1","any":"1","coded":"1","dige":"f8d7f21d0a1a","js":"ev","v":"cev","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        A.sc.msg.set("state","no");
        
        
        };
  n		W:javascript
    n			{"acgt":"s","act":"1","any":"1","dige":"3327fdf4d9a7","js":"n","v":"cn","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        A.n = A;
        C.y.A = C.y.A || A;
        if (C.y.A != A) {
            {var er = new Error("wild C"); er.tc = [C]; throw er}
        }
        if (A.c.nogro) {
            return
        }
        var g = A.ground;
        if (!g) {
            return;
        }
        g.sc.z = g.sc.z || [];
        g.sc.z.push(C);
        //~grounds: A[1].t, C.t
        
        };
    V	11		{"acgt":"s","act":"1","dige":"2f7deb67cc72","gk":"V","js":"n","nk":"c","v":"cV","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        C.c.W = s;
        A.c.twotoeight = 1;
        
        };
    pi	12		{"acgt":"s","act":"1","dige":"5ff04f807721","gk":"pi","js":"n","nk":"c","v":"cpi","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        if (!s) {
            {var er = new Error("Give pi"); er.tc = [C]; throw er}
        }
        C.c.J = "pi/"+s;
        A.c.way = 'way';
        
        };
    W	12		{"acgt":"s","act":"1","dige":"8fbbf8055da4","gk":"W","js":"n","nk":"c","v":"cW","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        if (!s || s == '1') {
            s = C.c.W = C.t;
        }
        if (typeof s != 'string') {
            throw 'ref cW', C
        }
        if (!s) {
            throw 'non t W', C;
        }
        C.c.J = s;
        C.sc.W = s;
        A.c.Jup = A[4];
        A.c.Jcv = 0.1;
        
        };
    J	13		{"acgt":"s","act":"1","dige":"42c54e5e4721","gk":"J","js":"n","nk":"c","v":"cJ","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        var upn = A.n.up.n;
        if (upn && upn.c.T) {
            T.oT = upn.c.T;
        }
        
        if (C.sc.J) {
            return;
        }
        
        A.c.Jup = A.c.Jup || A[1];
        A.c.Jcv = A.c.Jcv || C.y.cv;
        
        var J;
        if (!A.c.nomem) {
            // or G.h(A,C,G,T,'pint',A.c.Jup,sc=>Jtv=>C.t,A.c.Jcv)
            // and so A.c.Jup.sc.Jtv babs to check each non-nk piece like so:
            var Jtv = A.c.Jup && A.c.Jup.sc.Jtv;
            if (Jtv && Jtv[C.t] && Jtv[C.t][A.c.Jcv])
                J = Jtv[C.t][A.c.Jcv]
            // so lets share the Jup stasher
            A.c.Jupstash = function(){
                if (!A.c.Jup) { // weirdness
        G.h(A,C,G,T,"c",'noJup',[A]);
                    if (A[1] == A[1]) {
                        G.h(A,C,G,T,"c",'noJup,A1=2',[ki(C)]);
                    }
                    A.c.Jup = A[2];
                }
                A.c.Jup.sc.Jtv = A.c.Jup.sc.Jtv || {};
                A.c.Jup.sc.Jtv[C.t] = A.c.Jup.sc.Jtv[C.t] || {};
                A.c.Jup.sc.Jtv[C.t][A.c.Jcv] = C.sc.J;
            };
        }
        if (J) {
            C.sc.J = J;
        }
        
        if (A.c.twotoeight) {
            T.oT.op = J && J.sc.s && J.sc.s.sc.top;
            return T.not = '2->8'
        }
        
        if (!C.sc.J) {
            C.sc.J = G.h(A,C,G,T,'J',A.c.Jup,C.t);
        }
        A[2] = A[1];
        A[1] = C.sc.J;
        if (C.c.W) {
            A[3] = C.sc.J[3] = C.sc.J;
        }
        A[1].c.s = C;
        A[1].c.T = T;
        
        
        };
    e	2		{"acgt":"s","act":"1","coded":"1","dige":"ac0581da29d1","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        var e = s;
        var E = e.y.A;
        if (E && E.t == 'ev') {
            E = null;
        }
        if (!E) {
            // spawn A:e after A:n@13, inherits A[1] = C.sc.J
            E = e.y.A = G.h(A,C,G,T,'Aye','e',2,{s:e});
            A.e = E;
            E.n = A;
            // wake us
            E.sc.N = E.sc.N || [];
            E.sc.N.push(A);
        }
        if (E.n != A) {
            {var er = new Error("A:e.n not us"); er.tc = [E, A]; throw er}
        }
        if (A.e != E) {
            {var er = new Error("A:n.e not elvis"); er.tc = [A, E]; throw er}
        }
        // happens in steps in sync with n wakeness
        G.h(A,C,G,T,'thro',A.e,2)
        
        };
    M	2		{"acgt":"s","act":"1","dige":"e74cdd0394ac","gk":"M","js":"n","nk":"c","v":"cM","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        if (!C.c.M.length) {
            delete C.c.M; return
        }
        if (!A.c.iM) {
            // cursor to resync to the same one
            A.c.iM = 0;
            var cv = A.c.Mcv || 0.300;
            // ground to set order
            var g = A.ground;
            if (A.c.Mground) {
                g = A.c.Mground;
            }
            if (!g) {
                return;
            }
            g.sc.z = g.sc.z || [];
            C.c.M.map(function(n){
                // give yA
                var Y = G.h(A,C,G,T,'Aye','n',0,n);
                g.sc.z.push(n);
                if (n.y.cv) {
                    return
                }
                // suggest y.cv of 30i+
                n.y.cv = G.h(A,C,G,T,'desca',cv,8);
                cv += 0.001;
            });
            // keep placement but figure
            if (C.c.reverse) {
                C.c.M.reverse();
            }
        }
        A.c.tow = function(ov){
            while (C.c.M[A.c.iM]) {
                var n = C.c.M[A.c.iM];
                var Y = n.y.A;
                //~>3 catchuppy: A[1].t, n.t, Y.cv, ov
                G.h(A,C,G,T,'thro',Y,ov);
                // advance to next n if that worked
                A.c.iM++;
                // fail/async/retry if Y.cv < ov?
                //  doesn't really mean anything for n?
            }
            // still here? 
            A.c.iM = 0
        };
        // async happens
        A.c.tow(7);
        A.c.tow(8);
        // TODO hide from G.h(A,C,G,T,'Hut')
        delete C.c.M;
        
        
        };
    pi	3		{"acgt":"s","act":"1","dige":"462f042fb122","gk":"pi","js":"n","nk":"c","v":"cpi","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        C.sc.pi = s;
        A[1].c.d = A[2].c.d ? A[2].c.d + 1 : 1;
        
        };
    e	4		{"acgt":"s","act":"1","coded":"1","dige":"15676def659f","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'thro',A.e,4)
        
        };
    e	5		{"acgt":"s","act":"1","coded":"1","dige":"2c4e9278a511","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'thro',A.e,5)
        
        };
    J	6		{"acgt":"s","act":"1","dige":"63e08e2ec700","gk":"J","js":"n","nk":"c","v":"cJ","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        if (T.nose) {
            return G.h(A,C,G,T,"c",'knows',[C.t]);
        }
        
        A.c.pin = A.c.pin || C.c.pin || A[1].c.pin || C.c.J || C.sc.J.t;
        A.c.page = A.c.page || '';
        
        // start each W as Normal, wander
        A.I = A[1] == A[3] ? A[4].I : A[2].I;
        
        // ground and root could be the same thing
        // as long as s knows 9sJ is not foreign
        // nice having yourself
        A[1].sc.grounds = A[1].sc.grounds || {};
        A[1].sc.grounds[A.c.page] = A.ground = G.h(A,C,G,T,'Cye',[A.c.page,1,{},{J:C.sc.J}]);
        if (A[1][2].c.imping) {
            A[1].c.imping++ // reset lv
        }
        
        var ise = '';
        if (C.c.e) {
            ise = " (e:"+C.c.e.t+")";
        }
        var de = "("+A.c.pin+")"+ise;
        if (A[1].t == A.c.pin) {
            de = ise
        }
        if (!A[1].sc.brains) {
        G.h(A,C,G,T,"c",'>2 J',[A[1].t, de]);
        }
        else {
        G.h(A,C,G,T,"c",'>6 J',[A[1].t, de]);
        }
        
        var y = {cv:0.9};
        var r = A.r = A[1].sc.root = G.h(A,C,G,T,'Cye',[A[1].t,y,{root:1},{}]);
        // y like a T apart from?
        y.sc = r.sc;
        y.c = r.c;
        G.h(A,C,G,T,'Aye','n',0,r);
        // begin 9 n so it hangs on to Normal A.I
        // will be last unless we can nonrethro its 1?
        var ar = C.c.ar || {};
        var s = ar.s = C.c.s;
        var M = r.c.M = ar.M = [];
        ar.y = y; // bundle of wires
        ar.J = A[1]; // yourself
        // if we make an Error can we rethrow it keeping its origin?
        // catch use case:
        //   the throw from G.h(A,C,G,T,'TuneTimeMachine') wants to abort pin/doming,
        //   put this A:n into A[1].sc.N, but A[1] isn't yet in A[4]...
        //   it wants to T.nose=6 with instant bail out of the pin...
        
        
        try {
            G.h(A,C,G,T,'way',A.c.pin,ar);
        }
        catch (er) {
            if (A.c.onbail) {
                A.c.onbail.map(function(cb){ cb(er) })
            }
            var waits = (er.message || er).match(/^waits/);
            if (!waits) {
                (er.catches = er.catches || []).push({stack:er.stack,tc:["pin:"+A.c.pin]}); throw er;
            }
            // waits means progress halted abruptly
        }
        
        delete y.c; delete y.sc;
        if (T.nose) {
            return;
        }
        
        if (A[1][2].c.imping) {
            y.imp = 1
        }
        if (y.imp) {
            A[1].c.imping = 1; delete y.imp;
        }
        
        if (!M.length) {
            delete c.M
        }
        
        G.h(A,C,G,T,'thro',r,8);
        
        };
    J	7		{"acgt":"s","act":"1","dige":"1f14cd529b81","gk":"J","js":"n","nk":"c","v":"cJ","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        // 8 up J.sc.root, has yA=n, and C.c.M:
        //   full of n things towed by n/M@2
        G.h(A,C,G,T,'thro',A[1].sc.root,8);
        // also anything looking behind
        if (A.ground.sc.z) {
            A.ground.sc.z.map(function(Y){ Y.cv < 0.8 && G.h(A,C,G,T,'thro',Y,8) });
        }
        
        // keep pulling on groundA&
        // say domes are finished (A.ground remaining will do)
        // an empty-ish step here so s can go async and not redo the 6
        if (T.nose != '1') {
            if (A.c.Jupstash) {
                A.c.Jupstash();
            }
            delete A.c.Jupstash;
        }
        
        };
    e	8		{"acgt":"s","act":"1","coded":"1","dige":"1814d91e4155","gk":"e","js":"n","nk":"c","v":"ce","args":"A,C,G,T,s","Wavel":"NutErupts/NutEl"}
      c s: |
        function(A,C,G,T,s) {
        G.h(A,C,G,T,'thro',A.e,8);
        if (A.e.cv < 0.8) {
            G.h(A,C,G,T,"c",'>17 lost e',[A.e.cv+'/'+A.cv+'@'+C.t, A[4].sc.ki(C.c.e)]);
        }
        
        };
    J	8		{"acgt":"s","act":"1","dige":"72128991e9f2","gk":"J","js":"n","nk":"c","v":"cJ","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        // T.N sets cv=6 and queues A in A[1].sc.N, which 4 finds via Jtv
        if (T.nose == '6') {
            delete T.nose; return T.N = 6;
        }
        if (T.nose == '2') {
            T.not = 1
        }
        if (T.nose == '7') {
            delete T.nose
        }
        if (T.nose) {
            return G.h(A,C,G,T,"c",'knows',[C.t]);
        }
        
        G.h(A,C,G,T,'s');
        
        // acgt/sMJ/etc hook protocols, and where they go?
        //Rw $_ - $J for @{A.c.wayght||[]};
        //$_->($J) for @{A.c.codeght||[]};
        
        if (T.oT && A[1].sc.s) {
            T.oT.op = A[1].sc.s.sc.top;
        }
        
        };
    sweet_music	8		{"acgt":"s","act":"1","any":"1","dige":"a663f9b17731","js":"n","v":"csweet_music","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        // has something to do with comp-letion
        
        };
  u		W:javascript
    u			{"acgt":"s","act":"1","any":"1","dige":"7eb6a385983e","js":"u","v":"cu","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        A.u = A;
        C.y.A = C.y.A || A;
        if (C.y.A != A) {
            {var er = new Error("wild C"); er.tc = [C]; throw er}
        }
        };
    N	11		{"acgt":"s","act":"1","dige":"28f327d60305","gk":"N","js":"u","nk":"c","v":"cN","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        var N = s;
        // A:u sprouts A:u's
        A.sc.z = [];
        for (var i in N) {
            var n = N[i];
            var t;
            if (n.constructor == Object) {
                t = n.t;
            }
            else {
                // just a t means W    # ]
                if (!G.h(A,C,G,T,'datam',n,"['*']")) {
                    {var er = new Error("NonWt u"); er.tc = [n]; throw er}
                }
                t = n[0];
            }
            // A:u's may resync
            A[4].sc.mind = A[4].sc.mind || {};
            var Y = A[4].sc.mind[t];
        
            if (!Y) {
                var C = G.h(A,C,G,T,'Cye',n);
                // being stylehut means javascript
                if (!C.c.I) {
                    C.c.W = 'javascript';
                }
                Y = G.h(A,C,G,T,'Aye','u',2,{s:C});
            }
        
            // shelve
            A[4].sc.mind[t] = Y;
        
            // wake us
            Y.sc.N = Y.sc.N || [];
            Y.sc.N.push(A);
        
            // them
            A.sc.z.push(Y);
        }
        // proceed to succeed
        A.cv = 0.8;
        
        };
    W	12		{"acgt":"s","act":"1","dige":"d7239041d1f4","gk":"W","js":"u","nk":"c","v":"cW","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        if (s == 'javascript') {
            C.c.js = C.t
        }
        
        };
    js	3		{"acgt":"s","act":"1","dige":"e7509d65a652","gk":"js","js":"u","nk":"c","v":"cjs","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        A.sc.I = {};
        // lookup code, come back:
        var get = '/js/'+C.t;
        // T would put this C.c.v to wind back from bugs
        if (C.c.v) {
            get += '-'+C.c.v;
        }
        $.ajax(get).done(function(s,how,c){
            if (how != 'success') {
                {var er = new Error("Failed request: "+how); er.tc = [c]; throw er}
            }
            var src = c.getResponseHeader('Location');
            var m = src.match('^\/js\/(\\w+)-(\\w+)(\\.js)');
            var W = m[1];
            var ver = m[2];
        
            // others can let us know 
            A.sc.v = C.sc.v = ver;
            A.sc.now = G.h(A,C,G,T,'time');
        
            var callback = function(script,e){
                // check for errors from that script?
                var tocfunc = W+'_'+ver;
                var toc = window[tocfunc]();
                var D;
                for (var k in toc) {
                    var v = toc[k];
                    var ind = v[0];
                    var t = v[1];
                    var cv = v[2];
                    var c = v[3];
                    var sc = v[4];
                    var C = {t:t, y:{cv:cv}, c:c, sc:sc};
                    if (ind == '') {
                        D = A.sc.I[t] = C;
                        D.y.tw = {};
                        D.y.tv = {};
                        D.sc.z = D.sc.z || [];
                    }
                    else if (ind == '  ') {
                        if (D.t != C.sc.js) {
                            {var er = new Error("Csjs not last D"); er.tc = [C, D]; throw er}
                        }
                        C.c.code = window[C.sc.name];
                        if (typeof C.c.code != 'function') {
                            {var er = new Error("Cccode not function"); er.tc = [C, D]; throw er}
                        }
                        // grow I
                        D.y.tv[C.t] = D.y.tv[C.t] || {};
                        D.y.tv[C.t][C.y.cv] = C;
                        D.y.tw[C.t] = C;
                        var l = D.sc.z.slice(-1);
                        if (l[0]) {
                            l[0].y.next = C;
                        }
                        D.sc.z.push(C);
                        D.y.in = D.y.in || C;
                        if (D.t === 'i' && (C.t === 'h' || C.t === 't')) {
                            G[C.t] = C.c.code;
                        }
                    }
                    else {
                        {var er = new Error("deep C: "+W+"/"+t); er.tc = [v]; throw er}
                    }
                }
        
                A.cv = 0.4;
                A.sc.ready = 1;
            };
        
            var have = $('body script[src="'+src+'"]');
            if (have.length) {
                return callback();
            }
            G.h(A,C,G,T,'add_script',src,callback);
        });
        
        A.sc.ready = 0;
        A[4].sc.N.push(A);
        T.not = 1;
        
        //   fail, chase W startup
        //   uptodate TN8
        
        // get, callback fills in A.c.v
            // so the bunch assembles on A[1].sc.minds[uname] = A:u with sc.I
        
            // have to use Js if complex, eg T wants to mess with it
        
            // build out of A:u if possible, or doing a J if any C specifics
            // an A:u 6 unifies A:u 3s, and A:u 7s compile it, 5wichboard 4ces
            // present N into A:u
            // another A.u
        
        };
    N	6		{"acgt":"s","act":"1","dige":"8075027704aa","gk":"N","js":"u","nk":"c","v":"cN","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        var have = [];
        // write this next bit:
        // the AC in A.sc.z require A.sc.I & C.sc.v: have.push(C.t+' '+C.sc.v)
        for (var i in A.sc.z) {
            var Y = A.sc.z[i];
            // u' 8 should have I
            if (!Y.sc.I) {
                throw "No I back"+A[4].sc.ki(Y)
            }
            var D = Y.c.s;
            if (!D.sc.v) {
                {var er = new Error("u' with no version"); er.tc = [D]; throw er}
            }
            have.push(D.t+' '+D.sc.v);
        }
        have = have.join(', ');
        
        //have == A.sc.have and return
        // mix them all together...
        
        var hup = function(s){
            var C = {y:{},c:{},sc:{}};
            C.t = s.t;
            C.y.cv = s.y.cv;
            //$.extend(C.y,s.y);
            $.extend(C.c,s.c);
            $.extend(C.sc,s.sc);
            return C
        };
        var I = {}; // t:I with .y.tv for
        // can be t:cv:I?
        for (var i in A.sc.z) {
            var Y = A.sc.z[i];
            if (!Y.sc.I) {
                {var er = new Error("no I on u'"); er.tc = [Y]; throw er}
            }
            var C = Y.c.s;
            //
            for (var of in Y.sc.I) {
            var W = Y.sc.I[of];
                var z = W.sc.z;
                if (!z) {
                    {var er = new Error("No items in We"); er.tc = [W]; throw er}
                }
                c = I[W.t];
                if (c) {
                    c.sc.contrib += ','+C.t;
                    c.sc.many_contrib = 1;
                    W = c;
                }
                else {
                    W = hup(W);
                    W.sc.z = [];
                    W.y.tv = {};
                    W.y.tw = {};
                    W.sc.contrib = C.t;
                    I[W.t] = W;
                }
                for (var i in z) {
            var D = z[i];
                    // dedup (z and many-z/A.sc.z/u order matters)
                    if (W.y.tv[D.t] && W.y.tv[D.t][D.y.cv]) {
                        var was = W.y.tv[D.t] && W.y.tv[D.t][D.y.cv];
                        var rz = [];
                        for (var i in W.sc.z) {
            var E = W.sc.z[i];
                            if (E != was) {
                                rz.push(E);
                            }
                        }
                        W.sc.z = rz;
                        if (W.y.tw[D.t] == was) {
                            delete W.y.tw[D.t]
                        }
                    }
                    W.y.tv[D.t] = W.y.tv[D.t] || {};
                    W.y.tv[D.t][D.y.cv] = D;
                    W.y.tw[D.t] = W.y.tw[D.t] || D;
                    W.sc.z.push(D);
                }
            }
        }
        
        for (var of in I) {
            var W = I[of];
            // concatenated zs for this W must be sorted
            if (W.sc.many_contrib) {
                delete W.sc.many_contrib;
                W.sc.z = W.sc.z.sort(function(a,b){
                    return a.y.cv < b.y.cv ? -1 : a.y.cv > b.y.cv ? 1
                    : a.t < b.t ? -1 : a.t > b.t ? 1
                    : 0
                });
            }
            var la = null;
            for (var i in W.sc.z) {
            var D = W.sc.z[i];
                if (typeof D.c.code != 'function') {
                    {var er = new Error("no Dccode"); er.tc = [W, D]; throw er}
                }
                if (!la) {
                    W.y.in = D;
                }
                else {
                    la.y.next = D;
                    D.y.prev = la;
                }
                la = D;
            }
        }
        
        A.sc.I = I;
        A.sc.have = have;
        
        
        //c whatif
        if (Y != A) {
            // here u = J.sc.u, the u J:
        
            // A:u A.sc.N's the A.clusping waiting on it,
            //  for A[4].sc.N when done
            //     or we could put the A.clusping into u.sc.N
            //      u = A.clusping[1], so
            //       u.sc.Ns['N'](A,C,G,T) and A[3].sc.N that 1
            //      which it will see is 
            //   for 4 will rethro A:n from the last W,
            //    with (A[3].sc.N) intention to get this one A:n finished
            //     or perhaps a couple of A:n inside of each other
            //     but the thing about A:clusping is casually ignored,
            //     trusting the action to find its way through to that
            //     (and succeed immediately)
            //     
            //    which is a non-pin act, some osc? depends where it is,
            //    if it is FactorEase'd into pin process do that
            //    usually we can static update one thing and see how
            //    it mixes up in osc, eg. things swim,
            //    or it might just change a link
        
            // so A:u know A.clusping to get back to Jaction, once:
        
            // A:u's A.sc.N the A:u waiting on it,
            //  so all those A:u's A.sc.N's of A.clusping's are:
            //   sent to their A[1].sc.N 
            //   or their A[3].sc.N, who will be from 4 cos C.sc.N
            //   then it groups the desires in its A[1].sc.N,
            //   like it's receiving codechange to be with,
            //   and the limb of A:n it converns
        
            // a chunk of this ^ should 
        
            // so the A[4].sc.N reader is wanting grouped to 3-
            // it also picks up on Jtv's A[3].sc.N being there,
            // each A is the last in a chain reaction to resume
            //  eg A:n(W:Typ) > A:clusping
        
            // the A:n can be resync'd?
            // the A:n may have A:other then A:clusping,
        
        
            // and A[4].sc.N A grouped by A[3] can become A[3].sc.N,
            // it is a general pay-attention scheme,
        
            // A:n that W make borders/relationabla,
            //   the thing can be figured/resolved below
            //   and push its content to the yonder A:n,
            //    if they really need it, it may be just a link
            //    or it may require pinning,
            //      since FactorEase connected it into a process that
            //      must then be shunted along
            // the A:n upward should correlate to the
        
        }
        
        };
    I	8		{"acgt":"s","act":"1","dige":"34a32ac96377","gk":"I","js":"u","nk":"c","v":"cI","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        A.sc.I = C.c.I;
        C.sc.v = C.sc.v || 3; // bring from hut init/jsung?
        A.sc.v = C.sc.v;
        A.sc.now = G.h(A,C,G,T,'time');
        
        };
    N	8		{"acgt":"s","act":"1","dige":"8923e1c31a60","gk":"N","js":"u","nk":"c","v":"cN","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        var not
        // check u' 8
        for (var i in A.sc.z) {
            var Y = A.sc.z[i];
            // u' 8 checks the linkage/version on some object
            // winds back to 3 if not
            G.h(A,C,G,T,'thro',Y,8);
            if (Y.cv < 0.8) {
                not = 1;
            }
        }
        if (not) {
            // set u < 8, so above knows just like we know u' < 8
            // so u 8 checks again, u 6 mixes when u' 8
        G.h(A,C,G,T,"c",'>5 u rewind',[C.t]);
            A.cv = 0.7;
            return T.not = 2;
            // they have A[4].sc.N to bring them back,
            // who must also take care of their A.sc.N,
            // bringing back our A:u,
            // and must also take care of that A.sc.N,
            // bringing back A.cluspings,
            // who without a T is gone past/up to:
            // the A:n that wants to thro some more
        }
        // check versions given by u' to what we last took in
        var have = [];
        for (var i in A.sc.z) {
            var Y = A.sc.z[i];
            var D = Y.c.s;
            if (!D.sc.v) {
                {var er = new Error("u' with no version"); er.tc = [D]; throw er}
            }
            have.push(D.t+' '+D.sc.v);
        }
        have = have.join(', ');
        
        if (have != A.sc.have) {
            return T.seek = 6;
        }
        
        //
        // be simple
        
        };
    W	8		{"acgt":"s","act":"1","dige":"3187bac0ff9f","gk":"W","js":"u","nk":"c","v":"cW","args":"A,C,G,T,s","Wavel":"NutWorld"}
      c s: |
        function(A,C,G,T,s) {
        var ttl = (A[4].c.ttl || 5) * 2;
        var ok = A.sc.I
            && C.sc.v == A.sc.v
            && A.sc.now && G.h(A,C,G,T,'time',A.sc.now,ttl);
        if (ok) {
            if (A.cv < 0.8) {
                G.h(A,C,G,T,"c",'>5 u W',[C.t]);
            }
            return
        }
        T.seek = 3;
        
        };
  NutC			W:NutC,ha:48f0229ed4b7
  NutErupts			W:NutErupts,ha:3c704424ca83
  NutPhonica			W:NutPhonica,ha:7358f3f8161d
  NutProcess			W:NutProcess,ha:16e87e6613db
  NutWorld			W:NutWorld,ha:0ea54edbf33d
