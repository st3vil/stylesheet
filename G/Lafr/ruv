# I
# me/io global:
$me = 4c&me;
!me and throw "no me";
$io = me.io;
window.io = io;
window.me = me;

me.ruv = &acgt{ return [
    ... me&Beepingness ,

    ... me&DisplayTwoness ,
    ... me&Rscinsideness,'ruv' ,
    ... me&Ballingness ,
    ... me&Linesingness ,
    ... me&Diffingness ,
    ... me&Slepingness ,
    ... me&Actingness ,
    ... me&Toolingness ,
    
    # notify tinger
    ['Pearch','3',&acgtRs{
        G&way,'Pearch',{R};
    },'ift,D'],
    &{
    # will go weird if we're not one Ring deep
    me.JRom_asyncQs = &acgtR{
        T.asyncQs = [];
        return &{
            $was = delete T.asyncQs
            was.length and T.cancel = was.map(n=>n.t).join(', ')
        }
    };
    },
    
    ['Peace','3',&acgtRs{
        #n Sleigh  R %Slei,ting:W,Gens,tingspot
        # run field of exclaimation into others
        $done = me&JRom_asyncQs,R;
        me&way,R,'Peace',{R,col:3}
        done();
    },'ift,D'],
    
    ['COmbac','3',&acgtRs{
        $r = me&Rsc,R,'COmbac';
        $Q = rs&Q;
        $s = Qc&s;
        s && !sc&code and me&tsc,'Nocode',0,'B'
        
        me&nu,'s',s;
        me&nu,'Q',Q;
        me&nu,'P',Qs&P;
    },'ift,D'],
]};

# find things from %Search
#  _ting with proper args
# < for many %Searches, a lighter Q
#    ein() them outoftime
# < i and I will not %Search
# h: me&i,'i','name' .c.code(...)
me.t = &acgtRst{
    !isR(R) and throw "!R"
    isC(s) and $Q = s
    else
    isha(s) and $Q = Cye([t,1,s])
    else {
        t == null and t = s; s = "I"
        $Q = Cye([t,1,{of:s}]);
    }
    
    if (Qc&of == 'i' || Qc&of == 'I') {
        # A.I.* (embryos) are just $of, not $of/$t
        #  Ghost/In/$of is not the I-thing they want,
        #  u might t of:W or of:js from Search
        #   which generates A.I unto the slope
        # A.I.$of(/$t)?
        throw "iI"
    }
    else {
        # %Search
        $Search = me&Rsc,R,'^^Inn';
        T.asyncQs and Qc&async = &{ T.asyncQs.push(Q) };
        $s = Searchs&_ting(Q,R);
        # we would be async
        return s
    }
};

# function call, named params
#  might throw async, to come back somehow
#  a&ready=0/1 as waiting/ready
#  TuneTimeMachine pushes to 4s&N or so
me.way = &acgtRtry{
    !isR(R) and throw "!R"
    $ar = r || {};
    $cb = y;
    
    # args = 'ar'+tar
    # < remove code_args, argumentation
    $tar = G&ks,ar;
    $args = 'ar';
    tar and args += ','+tar
    
    # the index to an of:wjs
    $Q = G&Cye,[t,'',{of:'wjs',args}];
    
    cb == 'noop' and cb = &{}
    # throw async if not ready
    Qc&async = &{
        typeof cb == 'string' and throw "Cant go async: "+cb

        # Jin should avoid this A for a while
        a&ready = 0;
        # and throw/abort if no callback
        !cb and G&TuneTimeMachine,'w:'+t
    };
    
    # ready leads to retry
    Qc&ready = &{
        # Jin should accept this A again
        a&ready = 1;
        if (!cb) {
            ~>3 no way back?: t, R.t
        }
        elsif (G&arfgunc,cb == "s") {
            # GOING
            # way randomly happens, give return value to cb
            # without A lining up around it (it may do so itself)
            # see G&waylay for use case as delayed call
            $s = G&way,t,ar,'already_async';
            cb(s);
        }
        else {
            # containing a sync G&way call
            # or a way to get the context revisted
            #  eg me&wayel crosses off its waiting list thus
            cb(t,ar,w);
        }
    };
    
    $w = me&t,R,Q;
    if (!w) {
        T.asyncQs && T.asyncQs.includes(Q) and return
        throw "no way: "+Q.t
    }
    
    $argumas = tar.split(',').map(k => ar[k]);
    # see Ban
    # < finding sources
    Gc&B.sc.way = w;
    if (cb) {
        # containing a sync G&way call
        #  or a way to get the w back
        return cb(t,ar,w)
    }
    return wc&code(A,C,G,T,ar,...argumas)
};
# < noop=nottl could Qc&Want_Check=1
# < make it c.code and G&h for a B?
        