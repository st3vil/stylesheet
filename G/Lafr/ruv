# I
# me/io global:
$me = 4c&me;
!me and throw "no me";
$io = me.io;
window.io = io;
window.me = me;
# redisable feta
me.hacks = &acgt{
    # Peace is redoing the idea of
    # %play enabling meanings in s.sc%ball
    $Be = me.Be;
    # adds A.4/$W via Elvisory/
    delete Be.sc.J;
    # adds ^^%gee via openness[] etc
    delete Be.sc.W;
    # already disabled/broken somehow:
    delete Be.sc.R;
};
me.ruv = &acgt{ return [
    ... me&Beepingness ,

    ... me&DisplayTwoness ,
    ... me&Rscinsideness,'ruv' ,
    ... me&Ballingness ,
    ... me&Linesingness ,
    ... me&Diffingness ,
    ... me&Slepingness ,
    ... me&Actingness ,
    ... me&Toolingness ,
    
    # notify tinger
    ['Pearch','3',&acgtRs{
        G&way,'Pearch',{R};
    },'ift,D'],
    &{
    # will go weird if we're not one Ring deep
    me.JRom_asyncQs = &acgtR{
        T.asyncQs = [];
        return &{
            $was = delete T.asyncQs
            was.length and return T.cancel = was.map(n=>n.t).join(', ')
        }
    };
    },
    
    ['Neutrons','291',&acgtRs{
        me&tsc,'beamdap',0,'g'
    },'ift,D'],
    
    # J: w (Peace) with W (R.t)
    # unfold a structure from code and data
    ['Peace','291',&acgtRs{
        #n Sleigh  R %Slei,ting:W,Gens,tingspot
        # run field of exclaimation into others!
        
        # A:Peace
        # uses A.1-5 for %Peace=1-5
        # relies on %Peace all the way down
        $p = Ry&up;
        $Y = A;
        ps&Ace and A = ps&Ace
        A = Y;
        # < RbitX might extend to deal b into Ace/**
        $Y = Rs&Ace = G&Aye,'Peace';
        Yc&Y = A;
        # stash the A.I somewhere, our G.t uses:
        !ps&Ace and Y.6 = Y.4; Y.7 = Y.5;
        !ps&Ace and [2,3,4,5].map(&k{ delete Y[k] })
        # A.1=R, usually J
        Y.1 = R;
        # R's part of the %Peace organism
        num(Rs&Peace) and $step = A&Sonly = Rs&Peace
        # A.2-5=A, usually J
        # < suppose you go A.up to where A.1==A.3 etc
        step && step > 1 and Y[step] = Y
        ah(R,'reawakens','Peace',{
            rollbs:'Peace,Ace'
        });
        
        # J 6 pin
        $done = me&JRom_asyncQs,R;
        me&way,R,'Peace',{R,Y};
        done() and return
        
        # default some steps
        $step = A&Sonly;
        if (step) {
            # done ? base types : defaults
            # < way might want to around something, etc
            $done = ahsk(A&doings,step,'done');
            if (step == 9) {
                # 9 5s
                # < see if there's a w:R.t
                #   to use as well as w:Peace
                #    and its meanings for W ball
                n $R.t  R %Peace:5,Gens
            }
            if (step == 5) {
                # 5: bits of housing (boh), store <-> self
                #  eg ballRom does JRom/5/3
                !Rs&Gens and throw "5!Gens"
                ah(R,'reawakens','Gens',{
                    rollbs:'Gens,self,Here,Zaving'
                });
                delete Rs&ting;
                
                Rs&Zaving = "mem,W";
                
                # 5/4 then 5/3
                $four = me.cby(R,"^^^Peace")
                    .filter(n=>ns&Peace==4)[0];
                $next = !four ? 4 : 3;
                ah(R,'inheritscif','ball',{Peace:next})
                # %Gens is about to %Here = %self)%ball
            }
            if (step == 4) {
                # in this blob of Peace
                Rs&Abodo = 1;
            }
            if (step > 1 && step < 5) {
                !Rs&ball and throw step+"!ball"
                !isC(s) and throw step+"!s"
                # a node sloping 4,(3,2)+
                # spreading 2
                ah(R,'inheritscif','ball',{Peace:2})
                
                if (ss&W || ss&J || ss&R) {
                    # switch on layers of person
                    s&bgh = '010';
                    $r = me&personify,R,s,Y,step;
                    r == 'nothing' and return
                    # < collect things, G lang
                }
            }
            if (step == 8) {
                # JRom/osc transaction join
                #  plot out of time together
                !Rs&JRom and throw "8!JRom"
            }
            if (step == 1) {
                # an edge
            }
        }
        
    },'ift,D'],
    &{
    me.personify = &acgtRsY,step{
        [ss&W,ss&J,ss&R].filter(n=>n).length > 1 and throw "mul"
        # auto near tops
        $wouldJ = step <3 && Y.5 == Y.4[5];
        $wouldR = step >= 3;
        !(Rs&play || ss&R && wouldR || !ss&R && wouldJ) and return
        $c = {};
        # the $s <-> $self
        #  outside $s/** may be to inside $self/** related
        #   the R|W|J already having a pile here
        #    < ein ledger
        #   or thing%W:javascript/** compiling thinger
        #    < via e to javascript%W
        #      does c&W need babbling and s&W not?
        #   or simply being more stuff here,
        #    which the inside is allowed to use
        #  balls for it may happen or dup out
        #   if the inside R uses them first
        $outsphere = (ss&z||[]).length;
        
        # J into the last J
        # < %Zaving %directory=p%Zaving
        ss&J and c.directory = Y.5[1]
        
        # < using W to mean thinger (see the $s)
        # < $W1/$W2 looks for $W2 and $W1/$W2
        ss&W and ''
        
        if (ss&R) {
            if (isst(ss&R) && ss&R.substr(0,1) == '+') {
                # modes to enable on R
                # < it might want to be here from the start
                #   rollhauntedb, ghost of a process
                ss&R.split('+').map(&k{
                    !k and return
                    # ballRom would copy ss&* to rs&*
                    R.sc[k] = hak(s.sc,k) ? s.sc[k] : 1
                });
                return 'nothing'
            }
            # ballRom:
            #  makes r%Some%Thing if R=Some+Thing
            #   or r%Peace may be all if R=1
            #  copies ss&* to rs&*
            #  rs&other = s
            # R Ret 6
            c.Doming = 2;
            c.Peace = 6;
        }
        else {
            # W|J JRom 8 Gens 5
            c.Doming = 3;
            c.JRomc = {Peace:8};
            c.Peace = 5;
            # ballRom compulsively r%Gens once ^^%Gens
            c.Gens = 1;
        }
        
        c.Doming <3 and 'Ret'
        else {
            # Rom may normalise %task
            # < JRom should be fairly normal
            #   this could be the osc identity
            #   the G lang for out/in connection
            #  so we can leave a mind with one call
            c.task = 'ruv';
            # ss&task might be
        }
        # < let A:Peace out there?
        # < e all 4s&things
        
        $r = me&ballRom,R,s,c;
        # does only Ret, put in Rc&N
        c.Doming <3 and me&zN,r
        # uplink for the A.2
        return r
    }
    },
    # traversee
    ['COmbac','3',&acgtRs{
        $r = me&Rsc,R,'COmbac';
        $Q = rs&Q;
        $s = Qc&s;
        s && !sc&code and me&tsc,'Nocode',0,'B'
        
        me&nu,'s',s;
        me&nu,'Q',Q;
        me&nu,'P',Qs&P;
    },'ift,D'],
]};

# find things from A[1-9].I
G.t = &acgtst{
    typeof s == 'object' and throw "Nevers";
    $D;
    for (var n = 1; n <= 9; n++) {
        $Y = A[n];
        !Y and continue
        $I = Y.I;
        !I and continue
        # container/personality/embryo
        D = I[s];
        # thing/step/nodule/item
        D && t != null and D = D.y.tw[t];
        D and break
    }
    return D;
};

# find things from %Search
#  _ting with proper args
# < for many %Searches, a lighter Q
#    ein() them outoftime
# < i and I will not %Search
# h: me&i,'i','name' .c.code(...)
me.t = &acgtRst{
    !isR(R) and throw "!R"
    isC(s) and $Q = s
    else
    isha(s) and $Q = Cye([t,1,s])
    else {
        t == null and t = s; s = "I"
        $Q = Cye([t,1,{of:s}]);
    }
    
    if (Qc&of == 'i' || Qc&of == 'I') {
        # A.I.* (embryos) are just $of, not $of/$t
        #  Ghost/In/$of is not the I-thing they want,
        #  u might t of:W or of:js from Search
        #   which generates A.I unto the slope
        # A.I.$of(/$t)?
        throw "iI"
    }
    else {
        # %Search
        $Search = me&Rsc,R,'^^Inn';
        T.asyncQs and Qc&async = &{ T.asyncQs.push(Q) };
        $s = Searchs&_ting(Q,R);
        # we would be async
        return s
    }
};

# function call, named params
#  might throw async, to come back somehow
#  a&ready=0/1 as waiting/ready
#  TuneTimeMachine pushes to 4s&N or so
me.way = &acgtRtry{
    !isR(R) and throw "!R"
    $ar = r || {};
    $cb = y;
    
    # args = 'ar'+tar
    # < remove code_args, argumentation
    $tar = G&ks,ar;
    $args = 'ar';
    tar and args += ','+tar
    
    # the index to an of:wjs
    $Q = G&Cye,[t,'',{of:'wjs',args}];
    
    cb == 'noop' and cb = &{}
    # throw async if not ready
    Qc&async = &{
        typeof cb == 'string' and throw "Cant go async: "+cb

        # Jin should avoid this A for a while
        a&ready = 0;
        # and throw/abort if no callback
        !cb and G&TuneTimeMachine,'w:'+t
    };
    
    # ready leads to retry
    Qc&ready = &{
        # Jin should accept this A again
        a&ready = 1;
        if (!cb) {
            ~>3 no way back?: t, R.t
        }
        elsif (G&arfgunc,cb == "s") {
            # GOING
            # way randomly happens, give return value to cb
            # without A lining up around it (it may do so itself)
            # see G&waylay for use case as delayed call
            $s = G&way,t,ar,'already_async';
            cb(s);
        }
        else {
            # containing a sync G&way call
            # or a way to get the context revisted
            #  eg me&wayel crosses off its waiting list thus
            cb(t,ar,w);
        }
    };
    
    $w = me&t,R,Q;
    if (!w) {
        T.asyncQs && T.asyncQs.includes(Q) and return
        throw "no way: "+Q.t
    }
    
    $argumas = tar.split(',').map(k => ar[k]);
    # see Ban
    # < finding sources
    Gc&B.sc.way = w;
    if (cb) {
        # containing a sync G&way call
        #  or a way to get the w back
        return cb(t,ar,w)
    }
    return wc&code(A,C,G,T,ar,...argumas)
};
# < noop=nottl could Qc&Want_Check=1
# < make it c.code and G&h for a B?


# S for an osc pin, bump through segments of the work
me.Srupto = &A,C,G,T,s,t,talk,params{
    s == '' && t == '' and throw "no io"
    
    #~Sonly: s, ':', t, '%', talk
    
    A&Sonly && num(s) && s != A&Sonly and return 0
    
    t ||= s;
    
    A&doings ||= {};
    $l = A&doings[t] ||= {};
    l.done and return
    l.done = 1;
    #~sttalk: ki([s,t,talk,params]);
    return 1;
};
