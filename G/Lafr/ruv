# I
# me/io global:
$me = 4c&me;
!me and throw "no me";
$io = me.io;
window.io = io;
window.me = me;

me.ruv = &acgt{ return [
    ... me&Beepingness ,

    ... me&DisplayTwoness ,
    ... me&Rscinsideness,'ruv' ,
    ... me&Ballingness ,
    ... me&Linesingness ,
    ... me&Diffingness ,
    ... me&Slepingness ,
    ... me&Actingness ,
    ... me&Toolingness ,
    
    # notify tinger
    ['Pearch','3',&acgtRs{
        G&way,'Pearch',{R};
    },'ift,D'],
    &{
    # will go weird if we're not one Ring deep
    me.JRom_asyncQs = &acgtR{
        T.asyncQs = [];
        return &{
            $was = delete T.asyncQs
            was.length and return T.cancel = was.map(n=>n.t).join(', ')
        }
    };
    },
    
    # J: w (Peace) with W (R.t)
    ['Peace','291',&acgtRs{
        #n Sleigh  R %Slei,ting:W,Gens,tingspot
        # run field of exclaimation into others!
        A = G&Aye,'J';
        A.1 = R;
        num(Rs&Peace) and A&Sonly = Rs&Peace
        ah(R,'reawakens','Peace',{
            rollbs:'Peace'
        });
        if (Rs&Gens) {
            ah(R,'reawakens','Gens',{
                rollbs:'Gens,self,Here,Zaving'
            });
            delete Rs&ting;
            Rs&Zaving = "mem,W";
        }
        $done = me&JRom_asyncQs,R;
        me&way,R,'Peace',{R,col:3};
        done() and return
        
        # default some steps
        $step = A&Sonly;
        if (step) {
            # done ? base types : defaults
            # < way might want to around something, etc
            $done = ahsk(A&doings,step,'done');
            if (step == 9 && !done) {
                # 9 5s
                # < see if there's a w:R.t
                #   to use as well as w:Peace
                #    and its meanings for W ball
                n $R.t  R %Peace:5,Gens
            }
            if (step == 5) {
                # 5: bits of housing (boh)
                #  eg ballRom does JRom/5/3
                !Rs&Gens and throw "5!Gens"
                # 5/4 then 5/3
                $four = me.cby(R,"^^^Peace")
                    .filter(n=>ns&Peace==4)[0];
                $next = !four ? 4 : 3;
                ah(R,'inheritscif','ball',{Peace:next})
                # %Gens is about to %Here = %self)%ball
            }
            if (step == 4) {
                # in this blob of Peace
                Rs&Abodo = 1;
            }
            if (step > 1 && step < 5) {
                !Rs&ball and throw "2-4!ball"
                # spreading 2
                ah(R,'inheritscif','ball',{Peace:2})
            }
            if (step == 1) {
                # an edge
                me&tsc,"Peaceout",0,'y'
            }
        }
        
    },'ift,D'],
    ['Peace+Gens','31',&acgtRs{
        $h = Rs&Here;
        # set natinhesc=Peace, for ball + Here sprouts
        me&tsc,"GensHere:"+(h&&"is"||'-')
    },'ift,D'],
    
    ['COmbac','3',&acgtRs{
        $r = me&Rsc,R,'COmbac';
        $Q = rs&Q;
        $s = Qc&s;
        s && !sc&code and me&tsc,'Nocode',0,'B'
        
        me&nu,'s',s;
        me&nu,'Q',Q;
        me&nu,'P',Qs&P;
    },'ift,D'],
]};

# find things from %Search
#  _ting with proper args
# < for many %Searches, a lighter Q
#    ein() them outoftime
# < i and I will not %Search
# h: me&i,'i','name' .c.code(...)
me.t = &acgtRst{
    !isR(R) and throw "!R"
    isC(s) and $Q = s
    else
    isha(s) and $Q = Cye([t,1,s])
    else {
        t == null and t = s; s = "I"
        $Q = Cye([t,1,{of:s}]);
    }
    
    if (Qc&of == 'i' || Qc&of == 'I') {
        # A.I.* (embryos) are just $of, not $of/$t
        #  Ghost/In/$of is not the I-thing they want,
        #  u might t of:W or of:js from Search
        #   which generates A.I unto the slope
        # A.I.$of(/$t)?
        throw "iI"
    }
    else {
        # %Search
        $Search = me&Rsc,R,'^^Inn';
        T.asyncQs and Qc&async = &{ T.asyncQs.push(Q) };
        $s = Searchs&_ting(Q,R);
        # we would be async
        return s
    }
};

# function call, named params
#  might throw async, to come back somehow
#  a&ready=0/1 as waiting/ready
#  TuneTimeMachine pushes to 4s&N or so
me.way = &acgtRtry{
    !isR(R) and throw "!R"
    $ar = r || {};
    $cb = y;
    
    # args = 'ar'+tar
    # < remove code_args, argumentation
    $tar = G&ks,ar;
    $args = 'ar';
    tar and args += ','+tar
    
    # the index to an of:wjs
    $Q = G&Cye,[t,'',{of:'wjs',args}];
    
    cb == 'noop' and cb = &{}
    # throw async if not ready
    Qc&async = &{
        typeof cb == 'string' and throw "Cant go async: "+cb

        # Jin should avoid this A for a while
        a&ready = 0;
        # and throw/abort if no callback
        !cb and G&TuneTimeMachine,'w:'+t
    };
    
    # ready leads to retry
    Qc&ready = &{
        # Jin should accept this A again
        a&ready = 1;
        if (!cb) {
            ~>3 no way back?: t, R.t
        }
        elsif (G&arfgunc,cb == "s") {
            # GOING
            # way randomly happens, give return value to cb
            # without A lining up around it (it may do so itself)
            # see G&waylay for use case as delayed call
            $s = G&way,t,ar,'already_async';
            cb(s);
        }
        else {
            # containing a sync G&way call
            # or a way to get the context revisted
            #  eg me&wayel crosses off its waiting list thus
            cb(t,ar,w);
        }
    };
    
    $w = me&t,R,Q;
    if (!w) {
        T.asyncQs && T.asyncQs.includes(Q) and return
        throw "no way: "+Q.t
    }
    
    $argumas = tar.split(',').map(k => ar[k]);
    # see Ban
    # < finding sources
    Gc&B.sc.way = w;
    if (cb) {
        # containing a sync G&way call
        #  or a way to get the w back
        return cb(t,ar,w)
    }
    return wc&code(A,C,G,T,ar,...argumas)
};
# < noop=nottl could Qc&Want_Check=1
# < make it c.code and G&h for a B?


# S for an osc pin, bump through segments of the work
me.Srupto = &A,C,G,T,s,t,talk,params{
    s == '' && t == '' and throw "no io"
    
    #~Sonly: s, ':', t, '%', talk
    
    A&Sonly && num(s) && s != A&Sonly and return 0
    
    t ||= s;
    
    A&doings ||= {};
    $l = A&doings[t] ||= {};
    l.done and return
    l.done = 1;
    #~sttalk: ki([s,t,talk,params]);
    return 1;
};
