# proxy Search!!!!!!!!!
# this way for a J
R.t != "Pearch" and throw "notinR"
$Top = Ry&up;
Tops&JRom and Top = Topy&up
Rs&Inn = R;
$Search = me&Rsc,Ry&up,'^^Inn';
$upting = Searchs&_ting;
!upting and throw "^^Inn!_ting", Search
# < why is Searchs&do_permanence not always

# with of:w notifies via the Ghost of GhodigWap
$Ghodig = 4s&Ghodig;
Rs&Ghodigup = &QP{
    # from Ghodig/sub/...c&ready()
    # towards Qc&ready() via refresh
    # < many Q thing, many P thing...
    Qs&notsync = Qs&Want_Check = 1;
    Searchs&_ting(Q);
    Qs&P != P and ~>5 QP:
}
# Rs&Qu (Q updated) -> elvis to reality
Rs&Qup = &{
    $N = delete Rs&Qu;
    !N and return ~>4 nothing
    $wake = [];
    each iQ N {
        $P = Qs&P;
        $s = Qc&s || Pc&s;
        !s and throw "Qup!s"
        ~>6 WayQup: Qc&of, Q.t
        # tell by the args if it emits me
        $isme = Qc&of == 'wjs' &&
            ss&args.match(/\bme\b/);
        if (isme) {
            # < e to Pearch to set things up
            Rs&dropRcache();
            me&way,R,Q.t,{me};
        }
        else {
            wake.push(Qy&R)
        }
    }
    ~>6 aonee: N.length, ki(wake,2)
    me&elvis,R,'Qup',{wake:Top}
}
# drops Ring's task cache, recompiling me.ruv
Rs&dropRcache = &{
    each tw A.5.I.w.y.tw {
        delete ws&makesI;
        delete ws&makesIw;
    }
}
# bind Q-uestion to r-eason
Rs&_ting = &Qr{
    !isC(Q) and throw "ting !C"
    # dispatch change, Q<->R:
    r and Qy&R = r
    
    $already = Qc&ready;
    if (already) {
        # use it if we are !ready now
        #  if T.non (eg me&way !cb) default to:
    }
    # from out of time Pull_a completion
    #  per Q that we listened up
    Qc&ready = &CP{
        ac(R,'Qu',Q);
        # delay to allow batching
        $cb = me&sccb,R,'Quping',&{Rs&Qup()};
        G&delay,0.03,cb;
    }
    
    $s = upting(Q);
    $P = Qs&P;
    !P and ~>5 upting!P: Q.t
    #!s and ~>5 upting!s: Q.t
    !s || !P and return 
    
    # as found things go by, listen them
    # c&of is containing, s&of is having
    if (ss&of == 'w' && !Ps&listened) {
        # GhodigWap subscribes w.t
        Ghodigy&subscribe(s);
        # finds us here:
        i $Ghodig/sub/#Q.t/#R.t:s
        # < hist crunch,
        #   the w < Ps pulling dialect < Qs using it
        # the last P, Q will work for now
        $r = me&Rsc,ya,'R';
        ac(ya,'Ps',P,"Q",Q);
        yas&R = R;
        #yas&P && yas&P != P and debugger
        yas&P = P;
        yas&ein = &w{
            # dispatch ready() on all these:
            yas&Ps_Q.map(Q => ac(P,'readyingC',Q))
            # dispatching the request on one:
            Rs&Ghodigup(Q,P)
        };
        Ps&listened = 1;
    }
    # < use a new G&way that _tings
    #   its Wayc&chin is creating the sub!!
    # < Searches may trust upstream,
    return s
}
