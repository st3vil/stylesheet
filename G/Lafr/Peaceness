# I J
# part of ruv, which is assembled on the outside, so:
# me/io global:
$me = 4c&me;
!me and throw "no me";
$io = me.io;
window.io = io;
window.me = me;

me.Peaceness = &acgt{ return [
    ... me&SCones ,
    &{
    # wrap calls to me&t so they don't throw if !ready
    # will go weird if we're not one Ring deep
    me.JRom_asyncQs = &acgtR{
        T.asyncQs = [];
        return &{
            $was = delete T.asyncQs
            was.length and return T.cancel = was.map(n=>n.t).join(', ')
        }
    };
    },
    # J: w (Peace) with W (R.t)
    # unfold a structure from code and data
    ['Peace','291',&acgtRs{
        #n Sleigh  R %Slei,ting:W,Gens,tingspot
        # run field of exclaimation into others!
        
        # A:Peace
        # uses A.1-5 for %Peace=1-5
        # relies on %Peace all the way down
        $p = Ry&up;
        $Y = A;
        ps&Ace and A = ps&Ace
        A = Y;
        # < RbitX might extend to deal b into Ace/**
        $Y = Rs&Ace = G&Aye,'Peace';
        Yc&Y = A;
        # stash the A.I somewhere, our G.t uses:
        !ps&Ace and Y.6 = Y.4; Y.7 = Y.5;
        !ps&Ace and [2,3,4,5].map(&k{ delete Y[k] })
        # A.1=R, usually J
        Y.1 = R;
        # R's part of the %Peace organism
        num(Rs&Peace) and $step = A&Sonly = Rs&Peace
        # A.2-5=A, usually J
        # < suppose you go A.up to where A.1==A.3 etc
        step && step > 1 and Y[step] = Y
        ah(R,'reawakens','Peace',{
            rollbs:'Peace,Ace',
            #bg:1,
        });
        
        # J 6 pin
        $done = me&JRom_asyncQs,R;
        me&way,R,'Peace',{R,Y};
        done() and return
        
        # default some steps
        $step = A&Sonly;
        if (step) {
            # done ? base types : defaults
            # < way might want to around something, etc
            $done = ahsk(A&doings,step,'done');
            if (step == 9) {
                # 9 5s
                # < see if there's a w:R.t
                #   to use as well as w:Peace
                #    and its meanings for W ball
                n $R.t  R %Peace:5,Gens
            }
            if (step == 5) {
                # 5: bits of housing (boh), store <-> self
                #  eg ballRom does JRom/5/3
                !Rs&Gens and throw "5!Gens"
                ah(R,'reawakens','Gens',{
                    rollbs:'Gens,self,Here,Zaving'
                });
                delete Rs&ting;
                
                Rs&Zaving = "mem,W";
                
                # 5/4 then 5/3
                $four = me.cby(R,"^^^Peace")
                    .filter(n=>ns&Peace==4)[0];
                $next = !four ? 4 : 3;
                ah(R,'inheritscif','ball',{Peace:next})
                # %Gens is about to %Here = %self)%ball
            }
            if (step == 4) {
                # in this blob of Peace
                Rs&Abodo = 1;
            }
            if (step > 1 && step < 5) {
                !Rs&ball and throw step+"!ball"
                !isC(s) and throw step+"!s"
                # a node sloping 4,(3,2)+
                # spreading 2
                ah(R,'inheritscif','ball',{Peace:2})
                
                if (ss&W || ss&J || ss&R) {
                    # switch on layers of person
                    s&bgh = '010';
                    $r = me&personify,R,s,Y,step;
                    r == 'nothing' and return
                    Rs&Inner = r;
                    # < resolve through JRom
                    # < collect things, G lang
                }
            }
            if (step == 8) {
                # JRom/osc transaction join
                #  plot out of time together
                !Rs&JRom and throw "8!JRom"
            }
            if (step == 1) {
                # an edge
            }
        }
        
    },'ift,D'],
    &{
    me.personify = &acgtRsY,step{
        [ss&W,ss&J,ss&R].filter(n=>n).length > 1 and throw "mul"
        # auto near tops
        $wouldJ = step <3 && Y.5 == Y.4[5];
        $wouldR = step >= 3;
        $would = ss&R ? wouldR : wouldJ;
        
        !(Rs&play || would) and return
        Rs&play && would and return
        
        $c = {};
        # the $s <-> $self
        #  outside $s/** may be to inside $self/** related
        #   the R|W|J already having a pile here
        #    < ein ledger
        #   or thing%W:javascript/** compiling thinger
        #    < via e to javascript%W
        #      does c&W need babbling and s&W not?
        #   or simply being more stuff here,
        #    which the inside is allowed to use
        #  balls for it may happen or dup out
        #   if the inside R uses them first
        $outsphere = (ss&z||[]).length;
        
        # J into the last J
        # < %Zaving %directory=p%Zaving
        ss&J and c.directory = Y.5[1]
        
        # < using W to mean thinger (see the $s)
        # < $W1/$W2 looks for $W2 and $W1/$W2
        ss&W and ''
        
        if (ss&R) {
            if (isst(ss&R) && ss&R.substr(0,1) == '+') {
                # modes to enable on R
                # < it might want to be here from the start
                #   rollhauntedb, ghost of a process
                ss&R.split('+').map(&k{
                    !k and return
                    # ballRom would copy ss&* to rs&*
                    R.sc[k] = hak(s.sc,k) ? s.sc[k] : 1
                });
                return 'nothing'
            }
            # ballRom:
            #  makes r%Some%Thing if R=Some+Thing
            #   or r%Peace may be all if R=1
            #  copies ss&* to rs&*
            #  rs&other = s
            # R Ret 6
            c.Doming = 2;
            c.Peace = 6;
        }
        else {
            # W|J JRom 8 Gens 5
            c.Doming = 3;
            c.JRomc = {Peace:8};
            c.Peace = 5;
            # ballRom compulsively r%Gens once ^^%Gens
            c.Gens = 1;
        }
        
        c.Doming <3 and 'Ret'
        else {
            # Rom may normalise %task
            # < JRom should be fairly normal
            #   this could be the osc identity
            #   the G lang for out/in connection
            #  so we can leave a mind with one call
            c.task = 'ruv';
            # ss&task might be
        }
        # < let A:Peace out there?
        # < e all 4s&things
        
        $r = me&ballRom,R,s,c;
        # does only Ret, put in Rc&N
        c.Doming <3 and me&zN,r
        # uplink for the A.2
        return r
    }
    },
]};

=pod reintroduce MindInto
 GONE is %ting, %tracting
  That%Gracto makes:
   > That/tings%folder%eph for a W/G counterpartistry
   < That/**%Pave gently, a %Zave that doesnt expect here
     as if it was That/**%W
 < %Pave slow thing puller, spreads implying ting configuration:
  > Cloadsc writes stuff up/down
    < C able to deduce impliables
  < That%directory=ForThe/That will be implied by That%J
  < Know/**%directory=else/ward are else/ward/$t
  <   $t%director childrens implied %directory += $t
  < %Search for %species
   < local %Search host
  
  me&bal fills in to/from the schema:
   steps adopt/make our R/*%balls
    or %ball%eph for floating steps, not in Rc&s
  < s&J see 'resolve through JRom'
    which SCA would get some extra controls on,
     doing many tiny Rings etc.
     needs a self-awareness module,
      combined with slomo elvising
      see 'cant always trust whatever these might be'
  
=cut
me.SCones = &acgt{ return [
    ['Abodo',0.7,&acgtRs{
        delete s&bgi;
    },'ift,D'],
    # < timing: after/inside ^%MindInto->%SupplyChai @305
    #    which should delay children while it sets up
    #   then Y:SupplyChai: Steps walk @6
    #     which Y:Steps: Gracto @3 Rings in
    ['Pavings',0.306,&acgtRs{
        me&tsc,'Pavings';
        # borrow %Paving params
        me&adherePaving,R,R;
        # to give on to %Paving
        me&inherePaving,R;
        
        $r = me&nu,'Pavings',R;
        me&Ring,R,{und:r,ov:0.58}
    },'ift,D'],
    &{
    # inhere
    me.inherePaving = &acgtR{
        me&ioty,R,'ball' .map(&r{
            rs&Paving = 1;
            me&adherePaving,R,r;
        })
    };
    # adhere eg r%dir = s%dir || R%dir
    me.adherePaving = &acgtRr{
        $s = Rc&s;
        $z = rc&s;
        ['directory'].map(&k{
            # each of any params that matter
            #  on s when not as inherited from R
            $is = hak(z.sc,k) ? z.sc[k] : R.sc[k];
            # and eg. %directory='' leaves
            is and r.sc[k] = is
        })
    };
    me.reaw = &acgtR,gks{
        $k = gks.split(',')[0];
        ah(R,'reawakens',k,{rollbs:gks});
    };
    },
    ['Paving',0.36,&acgtRs{
        $of = Rs&Paving;
        of == 1 and of = 'W'
        me&reaw,R,'Paving,directory';
        # see if there's a HEAD-type method for this Qc&of
        $M = [];
        if (of == 'W') {
            m W.5 2  %species:5
            Rs&fully &&
                m $of 1
        }
        else {
            m $of 1  
        }
        each in M {
            n.t = s.t+" Paves "+n.t;
            # Rs&* and rs&* -> Qc&*, Qc&of = %Pave
            ns&Pave ||= of;
            nc&R = 1;
            n $n
        }
    },'ift,D'],
    ['Pave','291',&acgtRs{
        $p = Ry&up;
        # %Paves collect
        # since Zaving@294, reuse foldy thing
        ah(p,'Zaving',Rs&Pave,R);
        # similar to %Zave,
        #  G&t,Q directly, no %Saveting
        #  no %Here
        #   until download+decode
        #   or a write is proposed
        #   or our cache (dige/versiona) could go there

        $Q = me&rollbsc,R,'Q';
        Q.t = s.t;
        Qc&of = 'W';
        Qc&async = &{};
        Qc&ready = &CP{};
        ['directory','species'].map(&k{
            $is = r.sc[k] || p.sc[k];
            is and Q.c[k] = is
            else { delete Q.c[k] }
        });
        
        # Q refinds P each G&t
        $w = me&t,R,Q;
        me&nu,Q.t,Q.c;
        
        # $w may wander off, usu clones into %Gens%self
        # < following P into the future (%Differ)
        !Qs&ready and return me&waits,'!ready','...'
        
        # then something posits string to follow:
        Rs&commitstring = &s{
            # < require they know parent==Ps&dige
            Rs&Committing = Qs&string = s;
            me&t,R,Q;
        };
        
        me&nu,"Q",Q
        #$r = me&nu,'Pavings',R;
        #me&Ring,R,{und:r,ov:0.58}
    },'ift,D'],
# Paving 0.5
    ['Paving',0.5,&acgtRs{
        # waits for each Pave,
        #  draws clues together
    },'ift,D'],
    ['KnowThee','304',&acgtRs{
        $h = me&SChema,R,'KnowThee',{};
        n Know 1  %bri:0.7,Pavings
        n Compiling 3  %hue:70,supr:Comal
        n Seq 5  %hue:110,supr:Comste,Omplateau
        n That 7  %Pavings

        hy&domed()
    },'ift,D'],
]};
