
me.Yingwhen = &acgtRY{
    # see what's tunneled
    $N = me&ioty,R;
    if (!Rs&tunneling) {
        # nothing
        # < a loose wave of attention,
        #   do 100ms work, etc.
        #   casually refreshing around:
        #   $R/*/(*/*), $R/(*/*), ($R/*)
        # ($R/*)
    }
    $tunneling = N.filter(n => ns&tunneling && Rc&N.includes(n));
    if(0) {
        $blab = tunneling.map(&n{
            return n.t + (ns&sleeping ? "%sleeping" : "")
                + (!ns&tunneling ? "!tun" : "")
                + " P="+ns&Peace
        }).join(',');
        ~>3 tunneling: blab
    }
    $b = Rc&b;
    $est = b && bs&Ying;
    
    # the main things, $p%ball
    $two = tunneling.filter(n => ns&Peace == 2);
    # $p only, eg delivering %%eto:$p
    est && two.filter(n => !ns&sleeping).map(n => ns&onlyish = 1)
    # $R/$p only, all of them
    !tunneling.length and est && ah(R,'inheritscif','ball','onlyish',1)
    else
    # no &Ying for $R/$nonp (Yingu)
    !two.length and return 1
};
me.Yingmind ||= {};
me.Yingmind.Schema = &acgt{ return [
    # SC/Schema/Y:$src/$step+ posit SC/Steps/$step+
    #  every time R%Ying wakes
    # < slep @2
    # %*T pronounces how it will be, arranging for SCing:
    # A:SC@1 %SupplyChai=C macro laterer
    #  A:Schema@1 %SCh/$t=C micro schema
    #   ...gets finished:
    #  A:Schema@2 can slep & tell macro
    #   @3 with each other, notice late joiners
    #   @4 patterns emerge
    #   @5 decide how to change the game in progress
    #   @6 Ret (via bal) the step

    # SCing:
    # A:SC@2 inits
    #  A:Schema@6 may be moved in here,
    #   to avoid it Ringing outside the SCing
    # %KnowThat forks SC/Schema/t=KnowThat
    ['+Schema',0.01,&acgtRYs,SC{
        # organise SC's Ys as of/t:
        $Sch = me&Yingio,SC,'Schema';
        $t = Ys&t;
        !t and throw "give t"
        # el:1 recreates, string t makes spacer
        #  and sets sy&Y = Y
        $s = me&Yingio,Sch,t,{el:1,Y:Y};
        # drop cache # < wake Y:Schema if diff
        delete Schc&compiled;
        # makes the subject of iteration, sets sy&Y=Y
        return s
    },'ift,D'],
    # day, display zone
    ['on',0.02,&acgtRYs,SC{
        sy&R = R;
        # nowhere:
        $g = sy&g = me&opeolo,s.t,{walls:'b:2.2h6',label:{walls:'bg'}};
        Rc&brackuiet = 1;
        gy&can('ope',&{ Rc&brackuiet = 0 });
    },'ift,D'],
    # i $s:schema/$step o T.nN/*:step
    # steps adopted from recent: n ...
    ['steps adopted',0.11,&acgtRYs,SC{
        $N = Ys&N;
        !N and throw "nosteps"
        each in N {
            $p = fio(s,[n.t,n.y.cv||1]);
            py&Schema_step and throw "multi schema step", n
            py&Schema_step = n;
        }
    },'ift,D'],
]};
