# scheep
# scheep
    // %%eto - externalising state
        # $to += %%efrom...
        me.etos_o3 = &acgtrs{
            $ef = sy&efroms;
            !ef and return
            me&ioty,ef .map(&fo,{
                $h = fos&etos;
                # h may re-node_hoist before we 7, if from /**
                fos&using = hs&current;
                hc&el == 9 and foc&el = 9; return
                !hs&vers.includes(hs&current) and throw "vers!"
                !hs&from and throw "!from"
                hs&to != s and throw "to!"
                me&ioty,h .map(&n{
                    # each row is mixed in, +%%efrom
                    n = r&ha,n,{efrom:hs&from}
                    # < looking at s & n should notice this link:
                    ny&efrom = fo;
                });
                me&ioty,h .map(&n{
                    # each row is mixed in, +%%efrom
                    n = r&ha,n,{efrom:hs&from}
                    # < looking at s & n should notice this link:
                    ny&efrom = fo;
                });
            })
        };
        # $from %%eto
        #   -> $from sy&etos
        #   -> Ying%%etos
        # < brackstill config/slep
        # < riding X, hoisting all the way up...
        #  < a/b/-c/d should revoke d's stuff on b, a
        me.etos_6 = &acgtRprs{
            # all %%eto from this node
            $eto = r&jaa,'eto' .filter (n => !ns&efrom);
            # node s resolve to a %Ying/(pa/th)
            $tpath = &to,{
                $jo = toy&R;
                $N = me.cby(jo,&r{
                    return rc&s == Rc&s
                });
                N[0].c.s != Rc&s and throw "!^^%Ying"
                N.shift();
                N = N.filter(r => rs&ball);
                !N.length and throw "!tpath"
                return N.map(r => r.t).join('/')
                N = N.filter(r => rs&ball);
                !N.length and throw "!tpath"
                return N.map(r => r.t).join('/')
                N = N.filter(r => rs&ball);
                !N.length and throw "!tpath"
                return N.map(r => r.t).join('/')
            };
            $fromt = tpath(r);
            # C:from/C:to/row
            # grouped by where they're going
            # with c&el=9
            $ing = sy&etos ||= Cye([fromt,1]);
            $gone = (ings&z||[]).slice();
            each in eto {
                $to = ns&eto;
                # %%eto=1 means to the step
                to == 1 and to = p
                # select s given p/r/s
                $jo = toy&R;
                to = joc&s;
                
                $tot = tpath(to);
                $h = fio(ing,tot);
                $gi = gone.indexOf(h);
                if (gi >= 0) {
                    gone.splice(gi,1);
                    # new bunch of rows
                    hs&z = [];
                }
                
                hs&to = to;
                hs&from  = s;
                ac(h,'z',n);
                
            }
        }