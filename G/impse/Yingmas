# SCA revival!
# R%Ying becomes - see %Ying in Sch_emas
# < rename Ys&returns Yc&s?
# < make Yc&tug?

// Yingwards
 // Yingf
    me.Yingmind ||= {};
    # get I = me.Yingminds.$t ||= me.Yingmind.$t
    me.Yingminds ||= {};
    me.Yingmindo = &acgtt{
        !t and throw "SCmind!t"
        $N = me.Yingminds[t];
        N and return N
        !me.Yingmind[t] and throw "SCmind!t:"+t
        $M = me.Yingmind[t](A,C,G,T);
        $N = [];
        each in M {
            # sack of me.functions
            isfu(n) and n(); continue
            N.push(Cye(n))
        }
        N.map(n => n.c = {s:n.c})
        me.Yingminds[t] = N;
        return N
    };
    # drink grounds into Ying/Schema
    me.Ying_Schema = &acgtRtc{
        $SC = me&rollbsc,R,'Ying';
        $s = me&Yong,R,SC,'Schema',{t:t},1;
        # steps adopted from recent: n ...
        sy&domed = &{
            $N = me&ydome;
            me&Yong,R,s,{N:N},2;
        };
        return s
    };
    
 // fiu
    # fio() setting y&up, saying c.el
    # < more than one level
    # < io pipes A to A
    # making ny&up=s on el=1
    # < replace Yingio with fiu
    me.fiu = me.Yingio = &acgtstc{
        c ||= {};
        isnu(c) and c = {el:c}
        # many
        t == '' and return me&ioty,s,[''],['']
        # read only
        $n = fio(s,t,0);
        # 7 must be there, 8 read only
        c.el == 7 && !n and throw "No "+s.t+"/"+t
        c.el == 8 || c.el == 7 and return n
        !n and c.el ||= 1
        else {
            # if we were placing a different object
            isob(t) && n != t and c.el = 1
            # remove the one we found
            c.el == 1 || c.el == 9 and fio(s,t,9)
        }
        if (c.el == 1) {
            $n = fio(s,t);
            # inputting sets y&up
            ny&up = s
        }
        return n
    };

 // Yong - use sy&Y link to Ying $s**
    =pod conventionae Yongus

      Yong,$s:Steps,{sc},ov
        has Stepsy&Y to resume
      Yong,$s:SC,$t=Steps,{sc},ov
        is a difft, Ying Steps@o1 to create/find $s:Steps
         giving it this new Y
     either then:
      sy&R!future - Ying @o2, resyncing new R
        saving higher cv/ov until Steps does Yc&resumeov()
     and:
      Ying up to that ov

    =cut
    # me&Yong R $s(y&Y?) $mind? {Y.sc intro} $ov||=9 - 
    #  $mind on est. might return forked Y/Y:$mind
    me.Yong = &acgtRst,sc,ov{
        isob(t) and ov = sc; sc = t; t = null
        ov = scaf(ov) || 0.9;
        
        # s may be inside SC
        # < io: optimise SC**/$s knowing sy&up
        # < slope sy&up and know stuff, part of wider Aing
        $dive = me.cby(s);
        $SC = dive[0];
        $Y = sy&Y;
        
        $began = Y && Yc&cv || 0;
        $rem = "";
        if (t) {
            rem += " +Y:"+t;
            # o1 with new Y:Yc&t, create/find s for itself
            #   starting from the s
            $Y = me&Ying,R,s,{t:t,ov:0.01},sc,SC;
            # intro Yong(...sc) once, any of these places
            sc = {};
            s = Ys&returns;
            !s and throw t+"@01 !returns"
        }
        if (sy&R && me&yfuture,sy&R != sy&R) {
            # o2 per sy&R checks Y into lowov
            #  join macro A (eg R)
            #   so it can give/take grounds there
            $c = {};
            c.cv = c.ov = 0.02;
            # saving higher cv/ov until Y is ready
            Yc&resumeov = extemp(Y.c,c);
            c.Y = Y;
            # doing o2 even if cv==o2
            # < rename incv=ov, for iterating same t
            c.incv = c.ov;
            $Y = me&Ying,R,s,c,sc,SC;
            sc = {};
            rem += " ~R"
        }
        # what to do
        $c = {ov};
        if (!Y) {
            # begins itself, mind Yc&t = s.t
            c.t = s.t;
            rem += " s+Y:"+c.t;
        }
        else {
            c.Y = Y
        }
        !Y || Yc&cv < ov and Y = me&Ying,R,s,c,sc,SC
        
        $ind = dive.map(s=>s.t).join('/');
        SCc&verbose and ~>6 Yingd: ind, began, Yc&cv, ov, rem, ki(c)
        
        $re = Ys&returns || (Yc&M||[])[0];
        rey&Y != Y and throw "returning !yY=Y"
        return re
    };

 // Ying - mind (Yc&N) over matter (Yc&M)
    # as a way to find C about how to A
    # may c.t=newmind
    # may !c.Y, is created
    # sets sy&Y=Y for Yc&M/*
    #  and on itself if it returns so from 0.01
    me.Ying = &acgtRsc,sc,SC{
        # incv allows doing Ycv==tcv
        $incv = delete c.incv;
        # Y = c.Y explicitly, probably is sy&Y
        $Y = delete c.Y;
        if (!Y) {
            # init happens this way, from Yong $t
            # 
            # could Yy&up = sy&Y before it reinits?
            Y = Cye(['Y:'+c.t,'']);
        }
        # A:$t cv-ov are life + time to be
        # < see me&tempwind undoing some of this, 
        ex(Y.c,c);
        Yc&ov and Yc&ov = sca(Yc&ov)
        Yc&cv and Yc&cv = sca(Yc&cv)
        # its quest for a specific etc
        ex(Y.sc,sc);
        # of this linguistic actuation linearity
        Yc&N = me&Yingmindo,Yc&t;
        $il = 30;
        while (1) {
            il-- < 0 and throw "ManyYing"
            # < near Yc&N being changed while Yinging
            $ci = t ? Yc&N.indexOf(t) : -1;
            $t = Yc&N[ci+1];
            !t and break
            ty&cv > Yc&ov and break
            ty&cv <= Yc&cv && incv != ty&cv and continue
            
            
            # usu so many at == cv all happen
            incv = ty&cv;
            # <=@o2 iterate themselves
            $M = ty&cv > 0.02 && Yc&M || [s];
            each in M {
                # t act, n ground
                
                # deciding
                $T = {};
                if (ns&sleeping) {
                    # misses everything but sleeping spells
                    !(ts&sleeping || t.t.substr(0,8) == 'sleeping') and T.not = 'sleeping'
                }
                T.not and continue
                
                # can't always trust whatever these might be:
                #$r = ny&R || sy&R || Cy&R;
                # R is from the Ying above (R%SC)
                # < elabourate argumentation
                sc&verbose and ~>4 Ying: s.t, t.t, t.y.cv, n.t, Yc&ov
                $re = tc&s(A,C,G,T,R,Y,n,SC);
                
                T.Z and me&T_Z,Y
                $nocvt = delete T.nocvt;
                !nocvt and Yc&cv = ty&cv;
                if (ty&cv == 0.01) {
                    # Y claims what o1 returns
                    #  or $s if non-forking o1
                    re ||= Ys&returns || s;
                    !isC(re) and throw "o1ret!C"
                    # < may switch to it?
                    rey&Y and rey&oldY = rey&Y
                    rey&Y = Y;
                    Ys&returns ||= re;
                    s = re;
                }
            }
        }
        # so Y looks @2, if last ty&cv < 2
        Yc&cv = Yc&ov;
        Yc&M and Yc&M.map(s => sy&Y = Y)
        return Y
    };
    me.T_Z = &acgtY{
        $cv = delete T.Z;
        T.nocvt = 1;
        Yc&cv = scaf(cv);
    };

# Y:Ying - the top
me.Yingmind.Ying = &acgt{ return [
    # @1 figure out where things are at every so often
    # > misuse of 0.01 to declare functions
    # @o1 discerns itself from SC, which it doesn't
    
    # < set out unififying crawlythings
    #  eg check legitimacy of W Iing from its .5
    #  or do some update
    #   they set out, taking their parts of the wormhole
    ['Ying',0.01,&acgtRYs,SC{
        ~>3 Ying forks:
    },'ift,D'],

    # @02 when R%SC relives,
    #  ~SCy&R winds SCy&Y back to here
    ['on',0.02,&acgtRYs,SC{
        s != SC and throw "should be the one"
        sy&R = R;
        me&brackStepso2,R,s;
    },'ift,D'],

    #  mix Schema/$h/$p into Steps/$p
    # < Schema knowing export to Steps/$p
    #   or sharing as $p:step, and Steps inhales :steps
    ['Schema to Steps',0.021,&acgtRYs,SC{
        $Sch = me&Yingio,SC,'Schema',7;
        Schc&compiled and return
        $N = [];
        me&Yingio,Sch,'' .map(&h{
            me&Yingio,h,'' .map(p => N.push(p))
        });
        tvsortz(N);
        # start new Steps
        #   and imports new Steps/$p
        s = Ys&Steps = me&Yong,R,SC,'Steps',{adoptees:N},'o2';
        Schc&compiled = 1;
    },'ift,D'],

    # @023 Steps per R%SC
    ['Steps per R',0.023,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o2';
    },'ift,D'],

    # @03 Steps per walk through Y:SC
    #   pull up a map for this Aing,
    ['Steps per walk',0.03,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o3';
    },'ift,D'],

    # @6 Steps take walk through Y:Steps
    #   pull up a map for this Aing,
    ['Steps walk',0.6,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},9;
    },'ift,D'],
    # 
    ['Steps e',0.8,&acgtRYs,SC{
        me&brackSteps8,R,s;
    },'ift,D'],
]};

# Y:Steps
me.Yingmind.Steps = &acgt{ return [
      // <=o2 Steps R

        # o1 schema doming recreates SC/Y:Steps
        # per awake R%Ying%SomeSchema
        ['Steps',0.01,&acgtRYs,SC{
            s != SC and throw "s!=SC"
            $Steps = me&Yingio,s,'Steps',1;
            # grounded $p:steps flow into o2
            each ip Ys&adoptees {
                # < slep here
                me&Yingio,Steps,p
            }
            #~>3 Steps fork:
            return Steps
        },'ift,D'],
        
        # o2 Steps/$p <-> R/$r awake
        # per any R%Ying
        ['are',0.02,&acgtRY,Steps,SC{
            Stepsy&R = R;
            
            # we can see tunnelled $r already
            $N = me&ioty,R,'ball';
            $sleeping = [];
            if (N.length) {
                $awake = [];
                # mixed with recycling
                N = arou(N,&n{ return Rc&N.includes(n) },awake);
                $tunneling = Rs&tunneling;
                !tunneling and throw "early !tun"
                # by the sleeping since we know r -> p
                sleeping = N.map(r => rc&s.y.p);
            }
            
            # this reverse + bal adjust Rs&z to flow upwards
            # links p,r,s (+n)
            Stepss&z.slice().reverse().map(&p{
                sleeping.includes(p) and return ps&sleeping = 1
                delete ps&sleeping
                
                $n = py&Schema_step;
                # bal inputs to ups%ball, unless %eph
                # < compile this on the Schema
                ns&supr and ns&eph = 1
                
                # n.sc -> r.sc
                $r = me&bal,n.t,n.sc;
                $s = rc&s;
                # n.c -> s.sc
                ex(s.sc,n.c);
                
                # < pc&s = s)%ball?
                py&s = s;
                sy&p = p;
                py&R = sy&R = r;
            });
            
            # goes on as each SC/Steps/$p
            SCs&steps = Yc&M = Stepss&z;
            # GOING
            Rs&Lastly = Stepss&z.slice().pop();
        },'ift,D'],
      
      // o2=> Steps attr
        
        # o21 per awake Steps/(p,r,s) attr init
        ['attrise',0.021,&acgtRYp,SC{
            $Steps = py&up;
            $r = py&R;
            $s = rc&s;
            
            # joins t-t
            ss&twin and me&attrise_twin,p,r,s;
            rs&Pavings and ss&twmt = ps&priority = 1
            rs&Travels and ss&twmt = 1
            # map for W hierarchical looking W/[W,W,W]
            ss&twmt and ah(r,'adhere','twmt',1)
            # < check out. effectively %twmt?
            # prefer specific tw, altering supr-isms
            # they seem to have storable ambitions
            # eg including to /W/ ways to use
            #   With/$trick/$hack
            #    + $hack = $trick trick
            #   and SCinway
            ss&tw and rs&tw = ss&tw
            #  allowing calm isolated spacewalks
            rs&gently && rs&Gracto and rs&tw = 1
        },'ift,D'],
        
        ['arrive',0.022,&acgtRYp,SC{
            $r = py&R;
            Rs&waits and return T.Z = 8
            # enough to have Rs&C, Rc&b, Ace
            me&Ring,r,{und:r,ov:0.295};
        },'ift,D'],
      
      // being 03
        # @03 each Steps/(p,r,s) wake up, have features
        #  may be different, may be time to something!
        ['being',0.03,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            sy&R = r;
            
            # p's current Y:Walk around Y:Steps?
            #$Ob = py&O;
            #$O = py&O = Cye([p.t,py&cv]);
            #Ob and Oc&b = Ob; delete Obc&b
            
            # $p earlier (Know-ward) and later
            me.neigh(p,&lr{ py&l = l; py&r = r })
            
            me&brackstepo3,p;
            
            # me&inode arrives jc&s into:
            sy&N ||= [];
            # < reliable ordering
            #    putting them in around their neigh/up
            # < some way to traverse j/** in dialect,
            #   using slep, avoiding %folder, !%supr,
            #   that they should be in sy&N, etc.
            #   %supr might:
            #    each step/* is sy&top, has another pool sy&N
            # %adhere-ants like %supr, %twmt me&inode
        },'ift,D'],
        
      // Steps 5 6 7
        ['seee',0.5,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.315};
        },'ift,D'],
        ['aseee',0.6,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        # and again to wake things generated into other steps
        #  ie from inside:r, out to where Ring isn't
        # < notice things like that,
        # < use wai to organise elvising it in there
        ['Steps may other',0.67,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        ['Trip report',0.7,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            me&brackstep7,R,p,r,s;
        },'ift,D'],
]};
// brackstepnodeism
  // huh
    # alphabet layercake
    # join our decisions of how
    #  into an over-realm, a computed individual's unity
    #  so decisions that can't be made by anyone
    #  can be made by that mind
    # wording so it applies force around a structure
    #  the decision being to break or not

    # < %supr-ish list/pile process via me&ind, slepping
    #   a natural migration pathway, among slopes...
    #   < know users of the things changing,
    # < writing Ghost/**%dige where not Know/**%dige
    // yep
        
  // func
        # py&l|r - linked listness of a step
        me.neigh = &py{
            $Steps = py&up;
            $z = Stepss&z;
            $pi = z.indexOf(p);
            pi <0 and throw "!step"
            y(z[pi-1],z[pi+1])
        };
        # makes eg R&za,c,o -> &acgtco{ za(acgtRco) }
        # R.prototype.za? R = this? etc
        #  does every haks(R) out there get confused?
        # < Babz for each in me&thing { # call me&thing once
        # < Babz R&za -> me&za,R (single character == self)
        #   have me&za solve z for R
        # takes a function that calls me&brack(i|o),R,z
        #  which itself takes a function that solves z for R
        me.Racgty = &y{
            return &acgt{
                $args = [...arguments].slice(4);
                return y (A,C,G,T,args)
            }
        };
  // o3 - open
      # < ha that can think, stream news downstream (z gets read)
      # < sa that can log, selection replayable, dome input slep
      #   to check the conditions for a decision are still so,
      #    without having to conduce the decision again
      # NervOS fibre bundles arm sleepy processes
      #  limbs becoming available
      
        me.brackstepo3 = &acgtp{
            me&sahazaja,p;
        }
        me.bracknodeo3 = &acgtj{
            me&sahazaja,j;
        }
        me.brackStepso2 = &acgtRs{
            me&sahazaja,R;
        }
        
        # as r/** wake up & want nodesing
        me.inode = &acgtj{
            if (jy&R) {
                # < might be eg Ace to arrive into
                $meant = j;
                j = jy&R;
            }
            $z = jc&s;
            zy&path = me.cbyb(j,&r{ return rc&s.y.N },'ball')
                .map(r=>rc&s);
            !zy&path and throw "nonoder"
            $S = zy&path[0];
            $N = Sy&N;
            !N.includes(z) and N.push(z)
            zy&R = j;
            
            # pseudo Nodes init o3
            !jy&sa and me&bracknodeo3,j
            
            # Step's R that last o3'd, not sleeping
            !Sy&p and throw "Step !y&p"
            !Sy&R and throw "Step !y&R"
            #T.act and jy&ha({noded:T.act})
            return Sy&R
        };
        
        # io %wou, a feedback loop
        #   experience -> notion, notion -> etc
        me.sahazaja = &acgtj{
            jy&R and j = jy&R
            $k = 'wou';
            
            # brackology openness becomes on the way in
            me&brackope,j,k
            
            # making acgt R&za,'things'
            # ! currently R.* inherits to r.*, which is weird
            # see '< Babz R&za -> me&za,R'
            
            # resolve z, expanding args to bracko
            #  eg j&za,c,o -> me.bracko(acgtjzco)
            $brack = &ky{
                k = 'brack'+k;
                return me.Racgty(&acgt,args{
                    $z = y ();
                    !z and return
                    return me&$k,j,z,...args;
                });
            };
            
            # i - enterer
            # is our chance to react in a Ring,r hang way,
            #  returning/jumping somewhere to think/reapproach
            $z = j.sc[k] ||= Cye([k,1,{}]);
            zy&R ||= j;
            j.ha = brack('i',&{ return z })
            
            # o - reading,
            # from what is beginning,
            #  what was mid-way,
            #  what got to the end
            #   < without &bready? or just !sleep?
            
            # ja always now
            j.ja = brack('o',&{ return j.sc[k] });
            
            # sa last time
            $saz = me&ollbs,j,k
            j.sa = brack('o',&{ return saz });
            
            # za always >7
            $zak = k+'_accepted';
            $zaz = me&rollbs,j,zak;
            me&reaw,j,zak;
            j.za = brack('o',&{ return zaz });
            
            # and they can always return arrays (to .map...)
            $thisj = j
            j.saa = &{ return thisj.sa(...arguments) || [] }
            j.zaa = &{ return thisj.za(...arguments) || [] }
            j.jaa = &{ return thisj.ja(...arguments) || [] }
            
            # GOING - call them with this ACGT until converted
            jy&za = &{ return thisj&za,...arguments }
            jy&sa = &{ return thisj&sa,...arguments }
            jy&ja = &{ return thisj&ja,...arguments }
            jy&ha = &{ return thisj&ha,...arguments }

            # differ before <-> now
            # < caching sa/za, then:
            #   < versioned X, re-waigh if ha since da
            jy&da = &loose,tight,c{
                return 1; # too-caching wou
                me&diffwaia,j,loose,tight,c;
            };
        }
        
  // 5 - select
    // readiness
      =pod todo
        
        < %%dome and other %%tricks
        < S o AnotherStep/... would &settle?
        < &settle meaning a wants b to be settled,
          quickly decided, else
            comeback
            ps&sleepy til met?
        < io making sense of eg %%tw, %ein,
          but probably not &settle,
           blocking reads only for Pinnings
        < upper levels of %acty or R/r tugging lower
          %Paving would become acty=2,
           meaning something acty=1 (%%openey) succeeded
          and produce a %%Live (Qc&s)
        < %Paving basically top-down &settle,
           and some kind of r%acty=R%acty-1 tugging spread
          runs out of %acty=1->%openey far enough in
          so $p/* should &settle,
            but $p/*/*/* neednt be %openey (or settled?)
          > becoming %Paving_good|in all the way down|up
          might be up to r:Know to %%wants:r/*,acty:1,settled,
         
      // 78Ying stator features
        %%dome:$t,... - a row that resurrects
         # not: another $z to seem in this one via bracko
         @o3 sa'dome' -> ha, each nc&recycled=1
         @6:
           you ja your permanent-er state out of it
           eg %Ying has orders of $p waiting
           or commit log
           or %Paving sanity checking as we .5<->.1
         @7 you ha %dome:$t - to drop it
           or ha %dome:$t,... - to replace them
        
        %%eto... - going somewhere
         expanded from eto=1 meaning to $p
         brackstill etc, see nodeio
         lazily ttl if !%%dome
        
        # solves:
        leaving cos &bready drops state between
          usually youd export the ready state somewhere,
           eg the bunch of C to compile
          such that it can pull changes,
           eg CBing with a Know**%fully turnaround
        by:
          not accepting CBing while busy doing other stuff
          simply not getting around to doming CBing inward
        
      // nodeio
       focused on:
       &nodeo
        reading C (with Q)
        immediate return
       &nodei
        putting brack for transport
        to mix in there with their attention
       
       < hypothetically:
       &nodeo
        could be brack transported
        return once $to produces an answer
         loosely an accessor starting null 
       &nodei
        could find a sync handler
        immediate return
       
       somehow using %%dome=lookup or so,
        to keep these connections open
         around having faffy runtimes
        you periodically refreshing that dome
       
       &nodee,to,t,a,q
        is &nodei $to %%e:t,...q
        expecting %%efrom:to,e:t,...a
         supposing $to:
          &nodeein,t,&from,q{produce %%a-ish}
           which &nodei back to $from
           including %%e
       
       usu. &nodei,
        moving intention around
        ie,
        gets delivered, revoked
         attend when different, by way of:
       
       brackstilling
        has %%stuff changed?
        if still:
         &nodee can same answer same question
          immediate return potential
        if diff:
         the $to must attend,
          returning to $from once &settle
           or sooner if $to &nodei back to $from
          all %Ying managed
        helps:
         receivers of %%efrom,...
          eg CBing (value contest/news)
          accept versions of it when ready
          see 'check CBing &nodei is as it was'
          could -%%e%done or +%%rebase if diff
           if &nodeein +%done it when done
           or %%rebase = prescribed differencing,
            is applied, via a big-deal filter, eg:
              a %Compiling in its push-phase,
               can decide to redo, because CBing, already
               depending on the algorithm (||= C percolation)
                to be able to tune inputs near the end of their workload
                including just after it,
                 if the answer is invalidated
                is nice reflexive terrain
       
       basically,
        $from %%stuff -> $to, esp if diff
        comes back to $from once &settle,
         or sooner if $to %%answer -> $from
       
       eg.
        $from = a %Compiling sequencing operations:
         gets Know%fully and selects %%Live
          $Live = &nodee $to %%Live %%e:fully
           and e:fully is ein there, subplot:
            an anyone-elected %acty=3
            must produce %%Live,
         
         $from %%waits for a response?
          or %%fail if e%edone and !%%Live
         
         $to avoid doming their 'main thing'
           eg CBing
          until all %%e%done
           would new CBing before $from receives %%Live,
           so $from receives also the new CBing,
            bound to the %%Live used for thinging
       
       underneath &nodei:
        $from &nodei $to %%stuff
         put into $from%%eto:to,stuff
        %Ying hoists %%eto,stuff
         brackstilling %%stuff
          attending $to
         then (once &settle or sooner)
          attending $from
          may know when complete:
           if $from%%eto,stuff also %%domes,
            %Ying could mutate as it rolls in
            for &nodei to reconnect, see progress
             eg that e%edone or $to then &settle
           if %%eto,stuff also %%e,
            &nodee makes an %%e:e to round trip:
             $to forwards it %%efrom -> %%eto,
             $from relating exact %%eto <-> %%efrom
       
       =elvis
      // nodeeio
        # %%e:action, expects reply re the same %%e
        # < $e might encode and wander the network meanwhile
        #   coming back to pick up that $e again,
        #    contracting some %Search to keep a way in:
        #     matching a rebooted %%eto
        #      by brackstill == that $e that left
        # see &nodei re c+o
        me.nodee = &acgt,j,to,t,a,c,o{
            $jo = toy&R;
            to = ojc&s;
            c.e = t;
            # the %eto:to,e:C:question,...details
            $n = me&nodei,j,to,c,o;
            $e = ns&e;
            !isC(e) and throw "nodei!%%eto,e"
            # the %efrom:to,e:C:question,...answers
            $replying = j&ja,{e};
            $an = j&ja,ex({e},a);
            
            if (es&done) {
                !an and j&ha,{fail:'done',e}
                else {
                    if (hak(a) == 1) {
                        # eg returning %%Live sent back
                        an.length > 1 and throw "many rows"
                        return an[0].sc[haks(a)[0]]
                    }
                    # rows returning from this %%e
                    return an
                }
            }
            else {
                # waits?
                # %%eto hoisting should gently hurry up etc
            }
        }
        # %%e:handler, sync response
        #  %Ying will otherwise attend $to
        me.nodeein = &acgt,j,t,cb{
            # for e:t into j
            # cb = &from,q{produce %%a-ish}
        }
        # moving intention around
        #  row = c(identifying marks) + o(other stuff)
        #  so c finds the rolling %%eto,
        #   and reuse $e when o changes
        # < require %%dome? as T.Mw?
        me.nodei = &acgtj,to,c,o{
            # < bracko C.t == t
            $q = ex({eto:to},c);
            
            $sending = j&ja,q;
            ex(q,o);
            if (sending) {
                sending.length > 1 and throw "cant tell %%eto apart"
                $n = sending[0];
                c.e && !ns&e and throw "bug"
                ns&e && !c.e and throw "bug"
                # still this apparently
                #  may !e%done when %Ying brackstills it
                ns&e and q.e = ns&e
            }
            # < %Ying relays progress via %%eto?
            #    maybe if we %%uniq this it would return the recycled one
            #   or just via e, how else?
            $n = j&ha,q;
            
            return n
        };
        # S o $remote/$Q using|returning %%tw,...
        # < persistent query, knowing io it pipes into,
        me.nodeo = &acgtj,to,Q,qe{
            $qs = ex({tw:Q.t},Q.c);
            $N = toy&za(qs);
            if (!N) {
                me&may,j,'input','s',{tw:Q.t,waits:'not-found'},qe
                .map(&n{
                    ~>3 CREATE: ki(n.sc.s,4.23)
                    #  < may already have {s,may:input} if el=2
                    #   < use %Pavings%ein to input
                });
                me&tsc,'non';
                return
            }
            if (N.legnth > 1) {
                # in the web you would want many answers,
                #  perhaps candidates get see s** to rank/sync
                me&tsc,'unc';
                me&waits,'unclear'
            }
            return N
        };
       =elvis
      // 78Ying # further into %Compiling re nodeio
      # Know etc means a Know/** node
      # and that &nodei somewhere revisits somewhere
       Know builds tw, &settle
       Know have clients for CBing
        Ghost &nodeo Know their thing,
        Ghost &nodei Know their downstreamness,
         Ghost%dige if not as Know%dige implies
       Know !Ghost, 
        %%may create some Travel/$t c&W=Looking of it,
         to start doing something
       Know CBing per downstream,
        &nodei Ghost %%cha,
         which Ghost &nodei Travel %%cha
       
       Travel/$W,
         receives &nodei %%cha,
          - decides to update itself,
          - gets the inputs ready,
          - runs the thing,
          - tractions a bunch of $n/$u etc
            artifacts to save
             by way of a %Search that accepts writes itself,
              then presenting a tree of things to:
             n all G&t it put, push to That/**
              a downstream Know, non-CBing
              < via another %twin
             u all G&t it used, to Know/**
            push must:
             check CBing &nodei is as it was,
               so a %%rebase might emerge to Travel/$W
                in/near &nodei brackstill
               which our work (bunch of %%e:push) hangs off
              ie know Qs&parent on push,
              different:
               $n - %%rebase strangeness,
                 our downstream changed without us
               $n+$u - Travel/$W again, must know current
                 eg $W loading/saving itself
               $u - new input since Travel/$W
                 eg %dige can CBing again after we push
            if push:
              push all $n, That/**%%e:push,n (->%Paving->G&t)
              note all $u, Know/**%%e:pulled,u (%dige = that used)
               disimplying Ghost/*/**%dige must be expressed
                  semi-syncd Ghost mappings should be resolved after Travel/$W
                   until everything is aligned with Know/**,
                   might end up chasing loops,
                    diff the Travel of several $W in time
               
            $n/$u sets for %twin/$W/* may be canonical or not
             when its not invoking all the G&t the $W gets up to
               
            ideally all those G&t + W:KnowThee%Ying itself
             are in an Over%Search
              branching things for KnowThee
              to be merged with the Uber%Search above that,
               saving each thing,
                can sorta undo if interrupted,
                 from memory or Uber git reset
               < getting the new tree of changed things ready,
                 then commit just changing a link
             
            then!
            back to:
            CBing &nodei as before, since the %dige is out
            which might be real fast since the gear
             is all ready to pass another %Live through
          
      // 78Ying again
      
         most behaviour decisions wait for &settle
          waiting for confidence
          eg selecting nodes eg S o ... or &nodeo
            they/we should %bready

         most behaviour reflexes wait for &bready
          just needing a bit of resolution
          eg begin reaction as txn on brack
            as in %%may,... -> ...,%may, sorta
        
      // specifically

         &waits,... modulates something%waits
          R%waits has it
          
         &bready and return # implements a waitsology
          R%waits -> %%waits
          %%wants:$n%%waits -> %%waits:wants,...
          %%waits -> pause|shy $R
           and inners, unless $n%%waits,
             or %%waits:wants them,
             fuzzy line? who is waiting for who
             top down if same cv?
           might be a recognisable solution
           might be retry loop,
           do others first (moreso if %%waits:wants)

         &settle is a node that is:
          if relative to another node that wants it:
             eg %%wants...settled,
            %sleeping - not able to unsettle
          not pending elvising:
            as in %%wants:n,acty:1,settled,
             unless %%acty has transmit
          &halfsettled:
           @7:
            < &bready
            < brack seemingly stable: ja == za
          and:
           nodes above/below are at least &halfsettled
            eg: Settled/Unsettled/Chaos
             where Chaos is not brackstable etc but Unsettled is

         and they form loops!
      =elvis
        me.bready = &acgtR{
            # got to via %%wants:R below
            !Ry&ja and return Rs&waits
            # R%waits -> %%waits
            each in Rs&waits {
                R&ja,{waits:n} and continue
                R&ha,{waits:n}
            }
            # %%wants:$n%%waits -> %%waits:wants,...
            R&jaa,'wants' .map(&n{
                # < %%waits bracktrick out the rest of the values,
                #   unless viewed from the right angle, through waits?
                ns&waits and return
                $z = ns&wants;
                !isC(z) and return
                # could be p/r/s
                $j = zy&R;
                if (!jy&ha) {
                    # not a node
                    js&waits and R&ha,{waits:'wants',wants:z,notanode:1}
                }
                else {
                    # < unpossiblate infinite recursion
                    #   with me&ind bit on the T?
                    me&bready,j and R&ha,{waits:'wants',wants:z}
                }
            })
            
            !R&ja,'waits' and return
            # < %%waits -> pause|shy $R
            # avoiding the rest of the activity
            return 1
        };
        # < bracktricks:
        #  ha ...uniq - not if exactly like another row
        #  transmit - solving %%may or %%wants
        #   to be rolled into %wou early
        #  ha waits... - could arrest Ring:r,
        #   < wants Rc&ip.contains()
        #  7 wants:n,acty:1,settled
        #   acty transmit to $n,
        #   waits for it to settle
        #  ta - ternary ja $want ? ha $consequence : ha $waitsish
        #  conseq - for the above, and %%may
        #    hangs up the ja(expression),
        #     we can tell if the rows were transmit to it etc
        // yep
        
  // 7 - close
      // ending ready
        # < everyone &bready?
        # < call &stail if !&bready but otherwise &settle
        # < catching that %Pave elvis async already @315
        #    coming back to complete bunches at a time
        # < avoiding any more Ring r**,
        #    < wants Rc&ip.contains()
        #   as soon as ha ...waits
        #    winding them past mind they can't reach,
        #     recycling domes of stuff
        # < alterior sleeping - when %%waits stops Ring
        #   does it accept r as b? suppose, to display
        #    r/** want winding past their whole lives if strange
        #     winds to 9...Display while %sleeping?
       // accept - node|step commits za
        # should we commit za... usually
        #  unless &bready has taken extra exception (%sleepung)
        #  or it's %sleeping or so
        # >0 if r is not able to commit (za)
        # >1 if r is not able to display
        me.node_acceptable = &acgtRrs{
            if (rs&sleepung) {
                # displayable after sleepywind
                ~>3 node pung: r.t
                return 1
            }
            elsif (rs&sleeping) {
                # reawakened + tunneled through (Know)
                #~>3 node sleeping: r.t
            } 
            elsif (!Rc&N.includes(r)) {
                # not awakened
                #~>3 node avoid: r.t
            }
            else {
                return 0
            }
            return 2
        }
        # accepts new za
        #  and hoists to R%Ying anything transporting
        me.node_accept = &acgtRrs{
            # when not &bready, ask R%Ying to come back:
            me&bready,r and R&ha,{waits:'wants',wants:r}
            
            rs&wou_accepted = rs&wou
            
            # anything transporting, ask R%Ying to take it
            #  could let $p route amongst itself..?
            $eto = r&zaa,'eto' .filter(n => ns&eto != 1);
            eto.length and R&ha,{etoing:r}
        }
      // ending
        # %Ying/$p** done
        # < wake $p on da hoistings
        #   dome %%eto etc, then put for $p?
        me.brackstep7 = &acgtRprs{
            $stepsleeping = me&node_acceptable,R,r,s;
            
            each iz sy&N {
                $j = zy&R;
                $nodesleeping = me&node_acceptable,R,j,z;
                if (!nodesleeping) {
                    me&node_accept,R,j,z;
                    me&stepbrack,j;
                    # %%eto=$C 
                }
                if (!stepsleeping) {
                    # hoist to step, even if nodesleeping
                    # eg %%tw, names throughout r**
                    #  ja%%tw reads|wants them, to &settle,
                    #   and %acty++ etc per process
                    # kind of e-ish
                    # < keep N in order
                    # < goes via %Ying brackstill etc
                    #   where %%eto=1 means %%eto:p
                    j&zaa,'eto' .filter(n => ns&eto == 1)
                        .map(n => r&ha,n,{node:z} )
                }
            }
            
            if (!stepsleeping) {
                # w:KnowThee: toplevel automation on &settle
                # < maybrack
                if (ry&za('ready')) {
                    # < bring back?
                    # j%wou..ready travel on
                    $n = py&n;
                    !n and me&mtsc,g,"nonext"; return
                    ny&R and n = ny&R
                    ~>5 ready: j.t, '->', n.t
                    rs&gently && !me&rolltog,j,{may:'leaves?',tsc:'y',once:1} and return
                    # builds j** into n/
                    me&suprise,r,n
                }
                
                # < steps might all ^ then:
                # commit %wough to be za next time
                me&node_accept,R,r,s;
                
                $g = me&stepbrack,r;
                me&walls,g,'b:3.3h9';
            }
        }
        # %Ying done, comeback to steps|nodes
        # < give up on brackstable %%waits
        # < posit wakers into a few visits, to pick up on:
        #  < p%priority or $p ref'd by another waker first
        #  < undropped e when sccb throttles
        # < also have to wake the connections
        me.brackSteps8 = &acgtRs{
            me&node_accept,R,R,s;
            
            me&rollbs,R,'Iinint',0;
            $starting = Rs&Iinint++ < 5;
            
            $froms = R&jaa,'etoing',1;
            froms.map(&r{
                ~>5 etoing: r.t
            });
            
            # %Ying %%waits,wants=r
            $wakers = R&ja,'waits','wants';
            if (wakers) {
                # visits those r**
                wakers = wakers.map(&n{
                    !isR(n) and throw "notR"
                    return me&elvis,R,'reYn',{wake:n,ret:1}
                });
                # on a single trip to %Ying
                $elvising = &{
                    # pack: es&z are e, simultaneously
                    wakers = wakers.map(r => me&yfuture,r )
                    me&elvis,R,"Yingvoids",{pack:R},wakers
                };
                # avoids usual timing of Elvoids:
                # < should ec&when exactly
                $del = starting ? 30 : 3000;
                $Co = me&rollbsc,R,'Corresp';
                # limit to one feedback loop
                $yeah = me&sccb,Co,'Yingvoids',elvising;
                G&yl,del,yeah;
            }
            
            $g = me&stepbrack,R;
            me&walls,g,'b:3.3h9';
        };
        # display brackology
        me.stepbrack = &acgtjz{
            $g = me&brackology,j,z||'wou';
            me&walls,g,'b:2.2';
            # attaching C to r without doming:
            ac(j,'M',g);
            return g
        }
        
  // 8 - dial
      
        # introduce some %Part of it
        # < be a heading swallowed-by or swallowing brack
        #  < knowing T.act here and when ha
        # acty:8 meaning dialectical,
        # acty:1 would be openey,
        #   buttons for the first layers of mind atop
        # they are cv-ish, yet individual doables...
        #   %%may:ha,openey:1,acty:1 - advertise route
        # then just increase %%acty to wander in to things
        #  eg when depending on something being awake
        #  eg acty=5 might be enough to know expected Wup affects
        me.acting = &acgtRt{
            t ||= T.act.t;
            $ope = me&rolltog,R,{may:t,tsc:'l',acty:8};
            return ope
        };
