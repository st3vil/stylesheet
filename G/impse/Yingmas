# SCA revival
# R%Ying becomes
me.YingA = &acgt{ return [
    # early
    ['Ying','28',&acgtRs{
        ~>5 Ying 28:
    },'ift,D,sleeping'], 
    # children have sprung out
    ['Ying','305',&acgtRs{
        T.Mw = 'SC';
        # wait for R/*%ball to kinda happen
        #me.hacks && me&bewind,R and return
        
        # < feedback, early intro tunneling
        ah(R,'nextlifesc','Ying',2);
        
        Rs&nonDescribable = '%Ying';

        # phases: to be minding the steps

        $SC = me&rollbsc,R,'Ying';
        # steps congealed
        $s = me&Ying,R,SC,{},1;
        #debugger;
        $s = me&Ying,R,SC,{},9;

        me&nu,'SC',SC;
        #me&nu,'SCminds',me.SCminds;

        s&boc = 588;
    },'ift,D'],
    
]};
me.Yingmind ||= {};
// functions: Y:A, Yingmindo, tempwind, Yingio
    # each school (of thought) eg %KnowThat
    # gets mixed/attached/progressed
    # With: local knowledge about certain names etc
    me.Yingmind.A = &acgt{ [
        ['on',0.02,&acgtRYs,SC{
            s != SC and throw "should init the one"
            sy&R = R;
            sy&Y = Y;
            # list of atoms to loop, default:
            # Yc&M = [s]
        },'ift,D'],
    ] };
    
    # get I = me.Yingminds.$t ||= me.Yingmind.$t
    me.Yingminds = {};
    me.Yingmindo = &acgtt{
        !t and throw "SCmind!t"
        $N = me.Yingminds[t];
        N and return N
        !me.Yingmind[t] and throw "SCmind!t:"+t
        $N = me.Yingmind[t](A,C,G,T);
        N = N.map(n => Cye(n));
        N.map(n => n.c = {s:n.c})
        me.Yingminds[t] = N;
        return N
    };
    
    
    # ah() for C with A (Y) sense
    # < more than one level
    # < io pipes A to A
    # auto ny&up = s
    me.Yingio = &acgtstc{
        c ||= {};
        isnu(c) and c = {el:c}
        # many
        t == '' and return me&ioty,s,[''],['']
        # read only
        $n = fio(s,t,0);
        # 7 must be there, 8 read only
        c.el == 7 && !n and throw "No "+s.t+"/"+t
        c.el == 8 || c.el == 7 and return n
        !n and c.el ||= 1
        else {
            # if we were placing a different object
            isob(t) && n != t and c.el = 1
            # remove the one we found
            c.el == 1 || c.el == 9 and fio(s,t,9)
        }
        if (c.el == 1) {
            $n = fio(s,t);
            # inputting sets y&up
            ny&up = s
        }
        c.Y and ny&Y = c.Y
        return n
    };

// me&Ying,R,Ying|Y,c,$ov - to be Aing Ying**
    # or me&Ying R $s(y&Y) $mind? {Y.sc intro} $ov||=9
    #  ~$mind on est. might return forked Y/Y:$mind 
    # Ying/Y
    # $s = 
    me.Ying = &acgtRstc,ov{
        $R = Cy&R;
        isob(t) and ov = c; c = t; t = null
        # ov='o2' -> @02
        isst(ov) && ov.substr(0,1) == 'o' and ov = ov.substr(1)/100
        ov ||= 0.9;
        
        # may be inside SC
        # < slope sy&up and know stuff, part of wider Aing
        $dive = me.cby(s);
        $SC = dive[0];
        
        # init a possibility
        #   they may resume their previous cv/ov after
        # s may have sy&Y to continue,
        # or begin:
        #  forks@01 - alters Yc&M=[s]
        #   the ground/world/atoms we want to be,
        #   may structure them itself, eg:
        #     $h = me&SCA,SC,'Schema',{t:t},1
        #   makes $SC/Schema/$h named $t with hy&Y = Y
        #   or if still Yc&M=[s], sy&Y = Y
        # or resync:
        #   if sy&R is not current
        #  on@02 - join macro A (eg R)
        #   so it can give/take grounds there
        
        $diffR = sy&R && me&yfuture,sy&R != sy&R;
        $Y = sy&Y;
        
        
        $difft = t && Y && Yc&t != t;
        if (!Y || diffR || difft || ov <= 0.1) {
            # s may look like the mind its expecting
            t ||= Y && Yc&t || ss&of || s.t;
            # start/resync the Y
            if (Y && Yc&t != t) {
                # going to fork a different Y,
                #  happens as we SCA,SC,'Schema',... when SCy&Y
                # < knowing we came from this Y (is in sy&up)
                Y = null;
                # < some Aing of Y to use a different mind
                #   wouldn't go here
                #  it's a different Y...
                #   a layer projecting C alterations into te pipeline
                #   Y:Comste has Y:Encode travelling
                #    such Y:Nodes from Y:Step
            }
            
            # about this vector if init:
            $gen = {cv:0,ov:0.1};
            if (ov <= 0.1) {
                # low ov takes init temporality,
                if (!Y || (Yc&cv||0) < ov) {
                    # from (after) current low cv, to this low ov
                    gen.cv = Y && Yc&cv || 0;
                    gen.ov = ov;
                }
                else {
                    # including cv=ov, to 0.1 as usual
                    c.ashocks = 1;
                    gen.cv = ov;
                    gen.ov = 0.1;
                }
            }
            
            # here's the Yc&t - SCmind to have
            gen.t ||= t;
            if (Y) {
                $wascv = Yc&cv;
                # put cv/ov back where they were after
                $cb = me&tempwind,Y.c,gen;
                # may skip forks@0.01 if sy&Y
                gen.Y = Y;
                gen.cv ||= 0.01;
            }
            
            Y = me&Yinging,R,s,gen,c,SC;
            
            $thencv = Yc&cv;
            cb && cb();
            # keep a progressed cv
            #  if cb() wound back as expected
            if (wascv < thencv && wascv == Yc&cv)
                Yc&cv = thencv
        }
        
        # Yc&M would be different if it was complicated forks@01
        # < persis this
        Yc&M ||= [s];
        (Yc&M||[]).length == 1 && Yc&M[0] == s and sy&Y = Y
        
        # < Aing >1 may now sc=c
        #  until sc.ov etc conduces a decision to etc
        Yc&cv < ov and Y = me&Yinging,R,s,{Y:Y,ov:ov},c,SC
        
        # sy&Y to say "needs /schema/*"
        return Ys&returns || (Yc&M||[])[0]
    };
    
    # when SCA about to ex(Y.c,gen)
    # returns function to replace originals
    #  not exception handling, a brittle strategy
    #   maybe it could have a stack of jobs in Y.sc
    #   to be plucked into Y.c, committing to it
    # to allow SCA to temporarily be:
    #   SCAing 0-1 every time we SCA,
    #   is really another A's work,
    #   though it might still present this A (Y)
    #   as the Y to I that don't know the distinction
    me.tempwind = &acgtcs{
        $set = {};
        each kv s {
            hak(c,k) and set[k] = c[k]
        }
        return &{
            each kv set {
                c[k] = set[k]
            }
        }
    };
    
    
// Yinging - mind over matter
    # as a way to find C about how to A
    # we have the t
    me.Yinging = &acgtRsc,sc,SC{
        # incv - allows doing Ycv==tcv
        #  usu so many at == cv all happen
        $incv = delete c.ashocks&&c.cv;
        # awareness may already be in sy&Y,
        #  which will already be:
        $Y = delete c.Y;
        Y ||= Cye(['A:'+c.t,'']);
        # A:$t cv-ov are life + time to be
        # < see me&tempwind undoing some of this, 
        ex(Y.c,c);
        Yc&ov and Yc&ov = sca(Yc&ov)
        Yc&cv and Yc&cv = sca(Yc&cv)
        # its quest for a specific etc
        ex(Y.sc,sc);
        # of this routine
        Yc&N = me&Yingmindo,Yc&t;
        $il = 30;
        while (1) {
            il-- < 0 and throw "ManyYinging"
            $ci = t ? Yc&N.indexOf(t) : -1;
            $t = Yc&N[ci+1];
            !t and break
            ty&cv > Yc&ov and break
            ty&cv <= Yc&cv && incv != ty&cv and continue
            incv = ty&cv;
            # to the insides from s=SC
            $M = Yc&M || [s];
            each in M {
                # t act, n ground
                # can't always trust whatever these might be:
                #$r = ny&R || sy&R || Cy&R;
                # R is from the Ying above (R%SC)
                # < elabourate argumentation
                tc&s(A,C,G,T,R,Y,n,SC);
                Yc&cv = ty&cv;
            }
        }
        # so Y looks @2, if last ty&cv < 2
        Yc&cv = Yc&ov;
        Yc&M and Yc&M.map(s => sy&Y = Y)
        return Y
    };

# Y:Ying - the top
me.Yingmind.Ying = &acgt{ return [
    # @1 figure out where things are at every so often
    ['forks',0.01,&acgtRYs,SC{
        # steps etc wai %wou
        $woudef = &c{
            return me&waidef,c,'',{k:'wou'};
        };
        SCy&waia = &jc{
            !j and return &{}
            jy&R and j = jy&R
            c = woudef(c);
            # G already @7, use the one of it
            js&Gracto and delete c.b; c.gh = 'gh'
            return me&waier,j,c || &{}
        };
        SCy&tip = &jc{
            c = woudef(c);
            return me&brackdown,j,c
        };
    },'ift,D'],

    # @02 when R%SC relives,
    #  ~SCy&R winds SCy&Y back to here
    ['on',0.02,&acgtRYs,SC{
        s != SC and throw "should be the one"
        sy&R = R;
        sy&Y = Y;
    },'ift,D'],

    #  mix Schema/$h/$p into Steps/$p
    # < Schema knowing export to Steps/$p
    #   or sharing as $p:step, and Steps inhales :steps
    ['Schema to Steps',0.021,&acgtRYs,SC{
        $Sch = me&Yingio,SC,'Schema',7;
        Schc&compiled and return
        $N = [];
        me&Yingio,Sch,'' .map(&h{
            me&Yingio,h,'' .map(p => N.push(p))
        });
        tvsortz(N);
        # start new Steps
        #  SCyYct != 'Steps', so will @01
        #   which recreates SC/Steps
        #     if it didn't we could make it:
        #       $was = me&Yingio,SC,'Steps',9;
        #   and imports new Steps/$p
        s = Ys&Steps = me&Ying,SC,'Steps',{N:N},'o2';

        #~>3 Compi: SC.t
        Schc&compiled = 1;
    },'ift,D'],

    # @023 Steps per R%SC
    ['Steps per R',0.023,&acgtRYs,SC{
        # covered by Schema always recompiling
        #me&SCA,Ys&Steps,{},'o2';
    },'ift,D'],

    # @023 Steps per walk through Y:SC
    #   pull up a map for this Aing,
    ['Steps per walk',0.03,&acgtRYs,SC{
        me&SCA,Ys&Steps,{},'o3';
    },'ift,D'],

    # @023 Steps take walk through Y:SC
    #   pull up a map for this Aing,
    ['Steps walk',0.6,&acgtRYs,SC{
        me&SCA,Ys&Steps,{},9;
    },'ift,D'],
]};

# Y:Steps
me.Yingmind.Steps = &acgt{ return [
    # Y:SC/Y:Steps/$p:step
    # @01 downloading from Ys&N (Schema/*/$p)
    # @02 having r and its s
    # @03 runtime oncily
    #   grasps/feeds the whims of the steps
    # for r that might be any of (p,r,s),
    #   find the one we want
    # eg r=p||s, uses yR
    
        # compulsive recreate SC/Y:Steps, give z of Ys&N
        ['forks',0.01,&acgtRYs,SC{
            $s = Ys&returns = me&Yingio,SC,'Steps',{el:1,Y:Y};
            sy&Y = Y;
            # a&N[$p:steps flow into @02
            Ys&N .map(p => me&Yingio,s,p );
        },'ift,D'],
        
        # per R%SC:
        # @02 as Y:Steps each $p:step has r which has s
        ['steps are',0.02,&acgtRYs,SC{
            $s = Ys&returns;
            sy&R = R;
            # reverse: bal shall adjust Rs&z to flow upwards
            ss&z.slice().reverse().map(&p{
                $n = py&Schema_step;
                # bal inputs to ups%ball, unless %eph
                ns&supr && !ns&tings && !ns&Pavings and ns&eph = 1
                # n.sc -> r.sc
                $r = me&bal,n.t,n.sc;
                $s = rc&s;
                # n.c -> s.sc
                ex(s.sc,n.c);
                py&s = s;
                sy&p = p;
                # < is b
                py&R = sy&R = r;
            });
            # goes on as each SC/Steps/$p
            SCs&steps = Yc&M = ss&z;
            # GOING
            Rs&Lastly = ss&z.slice().pop();
        },'ift,D'],
        
        # still per R%SC:
        # @021 each Steps/(p,r,s) attr init
        ['on',0.021,&acgtRYp,SC{
            $r = py&R;
            $s = py&s;
            
            rs&tings and ss&trac = 'ting'
            # G, storage type of step
            #  hierarchical looking, W/[W,W,W]
            #   to conserve the main things from:
            #     Ghost/Inn/W/$t
            #   in a pile easier to read than all the W.5s everywhere
            ss&Pavings and rs&Gracto = rs&Pavings = 1
            
            # prefer specific tw, altering supr-isms
            # they seem to have storable ambitions
            # eg including to /W/ ways to use
            #   With/$trick/$hack
            #    + $hack = $trick trick
            #   and SCinway
            ss&tw and rs&tw = ss&tw
            #  allowing calm isolated spacewalks
            rs&gently && rs&Gracto and rs&tw = 1
            
            # enough to have Rs&C, Rc&b, etc
            me&Ring,R,{und:r,ov:0.28};
            
            rs&Pavings and ps&priority = 1
            # prevent early %ball etc until we Ring und:it later
            # or grounds might happen too early to %supr@291
            #  works anyway if you don't bewind until here
            #   otherwise the bewind will wait forever
            #rs&supr and rs&nextlifesc = {nottilund:1}
        },'ift,D'],
        
        #c Y:Steps per current walk around
        # < Y:Walk - delivering the goods or not this dome
        #   decides if it's done or to keep going around
        #     like c&e's T.pos/T.el
        #   then Y:Steps decides whether to multiply Walks per Step, etc
        # 
        # @03 each Steps/(p,r,s) wake up, have features
        #  may be different, may be time to something!
        ['on',0.03,&acgtRYp,SC{
            $r = py&R;
            
            # p's current walk around Y:Steps
            $Ob = py&O;
            $O = py&O = Cye([p.t,py&cv]);
            Ob and Oc&b = Ob; delete Obc&b
            
            !rs&supr and return
            
            # < know if this is to sleep, and
            # < avoid suprising to it etc
            #   do it more elvisily
            # so we can suprise anywhere along the chain:
            me&Ring,R,{und:r,ov:0.304};
            
            # %supr puts sy&R, Steps@02 puts {s,p}y&R
            me&yfuture,r,R != r and throw r.t+" yfuted"

            # each step/* is sy&top, has pool sy&N
            #  iterate through here to get:
            #   (j,s) - all %supr things inside/including $p
            # < climb however, refs limited to those in sy&N
            py&nodes = &y{
                me&ioty,r,'ball' .map(&j{
                    me&yfuture,j,R != j and throw j.t+" yfuted"
                    js&folder and return
                    $s = jc&s;
                    # must be used on %supr, or anywhere y&N is?
                    !sy&supr and throw "wandering"
                    sy&N .map(s => y(sy&R,s))
                })
            };
            
            # set by %supr@291
            # also to init from suprised
            !rs&Gracto and py&nodes(&js{ me&persis,s,'y','R',j })
        },'ift,D'],
        
        # as if G has mostly happened,
        #   even if it is the next step @6
        ['Gracto',0.3,&acgtRYp,SC{
            $r = py&R;
            
            !rs&Gracto and return
            
            # ting@5 gets %flook():
            me&Ring,R,{und:r,ov:0.505};
            
            # ball+tracting@51 etcs
            me&Ring,R,{und:r,ov:0.58};
        },'ift,D'],
        
        # steps happen in order
        ['Steps',0.6,&acgtRYp,SC{
            $r = py&R;
            rs&sleeping and return
            # Steps
            $S = Ys&returns;
            $i = Yc&M.indexOf(p);
            i < 0 and throw "nop"
            # $p:step's neighbours, earlier and next
            $l = Yc&M[i-1];
            $n = Yc&M[i+1];
            
            # being three states at once
            # la has happened
            $la = SCy&waia(l);
            $ra = SCy&waia(p,{b:1});
            $na = SCy&waia(n,{b:1});
            
            $g = SCy&tip(r);
            $leaves = &jn{
                if (!n) {
                    me&mtsc,g,"nonext";
                    # at the end, zy&l?
                    return
                }
                ny&R and n = ny&R
                
                ~>5 ready: j.t, '->', n.t
                rs&gently && !me&rolltog,j,{may:'ready>',tsc:'y',once:1} and return
                # builds j** into n/
                me&suprise,j,n
            };
            
            # < Y:step could take it from here
            #   to step 12222112232323343456 in one R%SC
            #   usually we have enough leash to do such runs
            #  and to attach the Gractoids more sidily:
            
            if (rs&Gracto) {
                # G already @7, conclude
                #!l and me&mtsc,g,"noprev"
                $N = ra('ready','r');
                each ij N {
                    # < apply/contest/reverse That change
                    leaves(j,n);
                }
                #!N || N.length < me&ioty,r .length and anyGbusy = 1
                # SCfcommit applies change/Cuploadism as they finish
                return
            }
            #c Y:Walk
            if (0) {
                # anyGbusy && rc&b) {
                ~>7 Geeping: r.t
                #rs&sleeping = 1;
                # seems to have children that keep going already
                #  even if we move the bal to SCenter
                # continue;
            }
            !py&nodes and return me&nu,"Bort-!nodes",p
            py&nodes(&js{
                # y&l change already fatal

                # waigh:wou from last time, feedback loop
                #   experience -> notion, notion -> etc
                jy&sa = SCy&waia(j,{b:1});

                # wai:wou this time enterer
                jy&ha = aha(j,'wou');

                # differ before <-> now
                # < caching sa/za, then:
                #   < versioned X, re-waigh if ha since da
                jy&da = &loose,tight,c{
                    return 1; # too-caching wough
                    c ||= {};
                    # what you want/specifically
                    isst(loose) and loose = G&peel,loose
                    isst(tight) and tight = G&peel,tight
                    $sa = SCy&waia(j,ex({b:1},c));
                    $za = SCy&waia(j,ex({},c));
                    !(sa && za) and return
                    $was = sa(loose);
                    $now = za(loose);
                    # gets zu grounding into j
                    $C = js&C;
                    me&zu,'da',{was,now,tight};
                    $cha = {};
                    each kv tight {
                        # k - the column in either
                        # v - change type/reaction
                        #  ref, slep, in/decrease, growth...
                    }
                    return cha
                };
            });

            # @31 domecheck, from!
            me&Ring,R,{und:r,ov:0.31};

            # wouey is wough before 32
            # < assume everything in 31 sleeps 32
            #waia(r,{gh:'ey'});
            #waia(r,{gh:'ey',b:1});

            me&Ring,R,{und:r,ov:0.32};
            
            
            # wough is finally here!
            $za = SCy&waia(r);
            py&nodes(&js{
                # < insist ready is the first column
                #   so we can simply js&wou.*.ready
                $ja = SCy&waia(j,{gh:'ad'});
                !ja('ready') and return
                # j%wou..ready travel on
                leaves(j,n);
                
                # alphabet layercake
                # all our decisions of how are joined
                #  into an over-realm, a computed individual's unity
                #  so decisions that can't be made by either hand
                #  can be made by that mind
                # and wording that so it applies to force around a structure
                #  the decision being to break or not
                
                # < subtype step:Seq's ready to -> step:Compiling
                #   same way step:Compiling would then -> That..G
                #   That..G wants all parents of the things changing
                # < or step:Apply after seq,
                #   or is it This..G?

            });
            me&walls,g,'b:3.3h9';
        },'ift,D'],
        
        # and again to wake things generated into other steps
        #  ie from inside:r, out to where Ring isn't
        ['Steps may other',0.67,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.31};
        },'ift,D'],
        
        # and again to wake things generated
        ['Trip report',0.7,&acgtRYp,SC{
            $r = py&R;
            rs&sleeping and return
            py&nodes && py&nodes(&js{
                js&wough and throw "Hadwough: "+j.t
                $g = SCy&tip(j);
                me&walls,g,'b:2.2';
            });
        },'ift,D'],
]};
