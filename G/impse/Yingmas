# SCA revival!
# R%Ying becomes - see %Ying in Sch_emas
=pod conventionae Yongus
 
  Yong,$s:Steps,{sc},ov
    has Stepsy&Y to resume
  Yong,$s:SC,$t=Steps,{sc},ov
    is a difft, Ying Steps@o1 to create/find $s:Steps
     giving it this new Y
 either then:
  sy&R!future - Ying @o2, resyncing new R
    saving higher cv/ov until Steps does Yc&resumeov()
 and:
  Ying up to that ov
 
=cut

// Yingf
    me.Yingmind ||= {};
    # get I = me.Yingminds.$t ||= me.Yingmind.$t
    me.Yingminds ||= {};
    me.Yingmindo = &acgtt{
        !t and throw "SCmind!t"
        $N = me.Yingminds[t];
        N and return N
        !me.Yingmind[t] and throw "SCmind!t:"+t
        $M = me.Yingmind[t](A,C,G,T);
        $N = [];
        each in M {
            # sack of me.functions
            isfu(n) and n(); continue
            N.push(Cye(n))
        }
        N.map(n => n.c = {s:n.c})
        me.Yingminds[t] = N;
        return N
    };
    # drink grounds into Ying/Schema
    me.Ying_Schema = &acgtRtc{
        $SC = me&rollbsc,R,'Ying';
        $s = me&Yong,R,SC,'Schema',{t:t},1;
        # steps adopted from recent: n ...
        sy&domed = &{
            $N = me&ydome;
            me&Yong,R,s,{N:N},2;
        };
        return s
    };
    
// fiu
    # fio() setting y&up, saying c.el
    # < more than one level
    # < io pipes A to A
    # making ny&up=s on el=1
    # < replace Yingio with fiu
    me.fiu = me.Yingio = &acgtstc{
        c ||= {};
        isnu(c) and c = {el:c}
        # many
        t == '' and return me&ioty,s,[''],['']
        # read only
        $n = fio(s,t,0);
        # 7 must be there, 8 read only
        c.el == 7 && !n and throw "No "+s.t+"/"+t
        c.el == 8 || c.el == 7 and return n
        !n and c.el ||= 1
        else {
            # if we were placing a different object
            isob(t) && n != t and c.el = 1
            # remove the one we found
            c.el == 1 || c.el == 9 and fio(s,t,9)
        }
        if (c.el == 1) {
            $n = fio(s,t);
            # inputting sets y&up
            ny&up = s
        }
        return n
    };

// Yong - use sy&Y link to Ying $s**
    # me&Yong R $s(y&Y?) $mind? {Y.sc intro} $ov||=9 - 
    #  $mind on est. might return forked Y/Y:$mind
    me.Yong = &acgtRst,sc,ov{
        isob(t) and ov = sc; sc = t; t = null
        ov = scaf(ov) || 0.9;
        
        # s may be inside SC
        # < io: optimise SC**/$s knowing sy&up
        # < slope sy&up and know stuff, part of wider Aing
        $dive = me.cby(s);
        $SC = dive[0];
        $Y = sy&Y;
        
        $began = Y && Yc&cv || 0;
        $rem = "";
        if (t) {
            rem += " +Y:"+t;
            # o1 with new Y:Yc&t, create/find s for itself
            #   starting from the s
            $Y = me&Ying,R,s,{t:t,ov:0.01},sc,SC;
            # intro Yong(...sc) once, any of these places
            sc = {};
            s = Ys&returns;
            !s and throw t+"@01 !returns"
        }
        if (sy&R && me&yfuture,sy&R != sy&R) {
            # o2 per sy&R checks Y into lowov
            #  join macro A (eg R)
            #   so it can give/take grounds there
            $c = {};
            c.cv = c.ov = 0.02;
            # saving higher cv/ov until Y is ready
            Yc&resumeov = extemp(Y.c,c);
            c.Y = Y;
            # doing o2 even if cv==o2
            # < rename incv=ov, for iterating same t
            c.incv = c.ov;
            $Y = me&Ying,R,s,c,sc,SC;
            sc = {};
            rem += " ~R"
        }
        # what to do
        $c = {ov};
        if (!Y) {
            # begins itself, mind Yc&t = s.t
            c.t = s.t;
            rem += " s+Y:"+c.t;
        }
        else {
            c.Y = Y
        }
        !Y || Yc&cv < ov and Y = me&Ying,R,s,c,sc,SC
        
        $ind = dive.map(s=>s.t).join('/');
        SCc&verbose and ~>6 Yingd: ind, began, Yc&cv, ov, rem, ki(c)
        
        $re = Ys&returns || (Yc&M||[])[0];
        rey&Y != Y and throw "returning !yY=Y"
        return re
    };

// Ying - mind (Yc&N) over matter (Yc&M)
    # as a way to find C about how to A
    # may c.t=newmind
    # may !c.Y, is created
    # sets sy&Y=Y for Yc&M/*
    #  and on itself if it returns so from 0.01
    me.Ying = &acgtRsc,sc,SC{
        # incv allows doing Ycv==tcv
        $incv = delete c.incv;
        # Y = c.Y explicitly, probably is sy&Y
        $Y = delete c.Y;
        if (!Y) {
            # init happens this way, from Yong $t
            # 
            # could Yy&up = sy&Y before it reinits?
            Y = Cye(['Y:'+c.t,'']);
        }
        # A:$t cv-ov are life + time to be
        # < see me&tempwind undoing some of this, 
        ex(Y.c,c);
        Yc&ov and Yc&ov = sca(Yc&ov)
        Yc&cv and Yc&cv = sca(Yc&cv)
        # its quest for a specific etc
        ex(Y.sc,sc);
        # of this linguistic actuation linearity
        Yc&N = me&Yingmindo,Yc&t;
        $il = 30;
        while (1) {
            il-- < 0 and throw "ManyYing"
            # < near Yc&N being changed while Yinging
            $ci = t ? Yc&N.indexOf(t) : -1;
            $t = Yc&N[ci+1];
            !t and break
            ty&cv > Yc&ov and break
            ty&cv <= Yc&cv && incv != ty&cv and continue
            
            
            # usu so many at == cv all happen
            incv = ty&cv;
            # <=@o2 iterate themselves
            $M = ty&cv > 0.02 && Yc&M || [s];
            each in M {
                # t act, n ground
                
                # deciding
                $T = {};
                if (ns&sleeping) {
                    # misses everything but sleeping spells
                    !(ts&sleeping || t.t.substr(0,8) == 'sleeping') and T.not = 'sleeping'
                }
                T.not and continue
                
                # can't always trust whatever these might be:
                #$r = ny&R || sy&R || Cy&R;
                # R is from the Ying above (R%SC)
                # < elabourate argumentation
                sc&verbose and ~>4 Ying: s.t, t.t, t.y.cv, n.t, Yc&ov
                $re = tc&s(A,C,G,T,R,Y,n,SC);
                
                T.Z and me&T_Z,Y
                $nocvt = delete T.nocvt;
                !nocvt and Yc&cv = ty&cv;
                if (ty&cv == 0.01) {
                    # Y claims what o1 returns
                    #  or $s if non-forking o1
                    re ||= Ys&returns || s;
                    !isC(re) and throw "o1ret!C"
                    # < may switch to it?
                    rey&Y and rey&oldY = rey&Y
                    rey&Y = Y;
                    Ys&returns ||= re;
                    s = re;
                }
            }
        }
        # so Y looks @2, if last ty&cv < 2
        Yc&cv = Yc&ov;
        Yc&M and Yc&M.map(s => sy&Y = Y)
        return Y
    };
    me.T_Z = &acgtY{
        $cv = delete T.Z;
        T.nocvt = 1;
        Yc&cv = scaf(cv);
    };
# Y:Ying - the top
me.Yingmind.Ying = &acgt{ return [
    # @1 figure out where things are at every so often
    # > misuse of 0.01 to declare functions
    # @o1 discerns itself from SC, which it doesn't
    
    # < set out unififying crawlythings
    #  eg check legitimacy of W Iing from its .5
    #  or do some update
    #   they set out, taking their parts of the wormhole
    ['Ying',0.01,&acgtRYs,SC{
        ~>3 Ying forks:
    },'ift,D'],

    # @02 when R%SC relives,
    #  ~SCy&R winds SCy&Y back to here
    ['on',0.02,&acgtRYs,SC{
        s != SC and throw "should be the one"
        sy&R = R;
    },'ift,D'],

    #  mix Schema/$h/$p into Steps/$p
    # < Schema knowing export to Steps/$p
    #   or sharing as $p:step, and Steps inhales :steps
    ['Schema to Steps',0.021,&acgtRYs,SC{
        $Sch = me&Yingio,SC,'Schema',7;
        Schc&compiled and return
        $N = [];
        me&Yingio,Sch,'' .map(&h{
            me&Yingio,h,'' .map(p => N.push(p))
        });
        tvsortz(N);
        # start new Steps
        #   and imports new Steps/$p
        s = Ys&Steps = me&Yong,R,SC,'Steps',{adoptees:N},'o2';
        Schc&compiled = 1;
    },'ift,D'],

    # @023 Steps per R%SC
    ['Steps per R',0.023,&acgtRYs,SC{
        # covered by Schema always recompiling
        me&Yong,R,Ys&Steps,{},'o2';
    },'ift,D'],

    # @03 Steps per walk through Y:SC
    #   pull up a map for this Aing,
    ['Steps per walk',0.03,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},'o3';
    },'ift,D'],

    # @6 Steps take walk through Y:Steps
    #   pull up a map for this Aing,
    ['Steps walk',0.6,&acgtRYs,SC{
        me&Yong,R,Ys&Steps,{},9;
    },'ift,D'],
]};

# Y:Steps
me.Yingmind.Steps = &acgt{ return [
    # $SC/$s:Steps/$p:step
    # @01 downloading from Ys&N (Schema/*/$p)
    # @02 having r and its s
    # @03 runtime oncily
    #   grasps/feeds the whims of the steps
        # Y:Steps per current walk around
        # < Y:Walk - delivering the goods or not this dome
        #   carrying to the future what matters
        #   decides if it's done or to keep going around
        #     like c&e's T.pos/T.el
        #   if we could travel R:Steps/$p y&R at will
        #     which is deleteRbitX + Re synthesis from tunneling
        #    we could Walk here many times to mutate solutions
      // Steps <=o2

        # o1 schema doming recreates SC/Y:Steps
        # per awake R%Ying%SomeSchema
        ['Steps',0.01,&acgtRYs,SC{
            s != SC and throw "s!=SC"
            $Steps = me&Yingio,s,'Steps',1;
            # grounded $p:steps flow into o2
            each ip Ys&adoptees {
                # < slep here
                me&Yingio,Steps,p
            }
            #~>3 Steps fork:
            return Steps
        },'ift,D'],
        
        # o2 Steps/$p <-> R/$r awake
        # per any R%Ying
        ['are',0.02,&acgtRY,Steps,SC{
            Stepsy&R = R;
            
            # we can see tunnelled $r already
            $N = me&ioty,R,'ball';
            $sleeping = [];
            if (N.length) {
                $awake = [];
                # mixed with recycling
                N = arou(N,&n{ return Rc&N.includes(n) },awake);
                $tunneling = Rs&tunneling;
                !tunneling and throw "early !tun"
                # by the sleeping since we know r -> p
                sleeping = N.map(r => rc&s.y.p);
            }
            
            # this reverse + bal adjust Rs&z to flow upwards
            # links p,r,s (+n)
            Stepss&z.slice().reverse().map(&p{
                sleeping.includes(p) and return ps&sleeping = 1
                delete ps&sleeping
                
                $n = py&Schema_step;
                # bal inputs to ups%ball, unless %eph
                # < compile this on the Schema
                ns&supr and ns&eph = 1
                
                # n.sc -> r.sc
                $r = me&bal,n.t,n.sc;
                $s = rc&s;
                # n.c -> s.sc
                ex(s.sc,n.c);
                
                # < pc&s = s)%ball?
                py&s = s;
                sy&p = p;
                py&R = sy&R = r;
            });
            
            # goes on as each SC/Steps/$p
            SCs&steps = Yc&M = Stepss&z;
            # GOING
            Rs&Lastly = Stepss&z.slice().pop();
        },'ift,D'],
      // Steps o2-3
        
        # o21 per awake Steps/(p,r,s) attr init
        ['attrise',0.021,&acgtRYp,SC{
            $Steps = py&up;
            $r = py&R;
            $s = rc&s;
            
            # joins t-t
            ss&twin and me&attrise_twin,p,r,s;
            rs&Pavings and ss&twmt = ps&priority = 1
            rs&Travels and ss&twmt = 1
            # map for W hierarchical looking W/[W,W,W]
            ss&twmt and ah(r,'adhere','twmt',1)
            # < check out:
            # prefer specific tw, altering supr-isms
            # they seem to have storable ambitions
            # eg including to /W/ ways to use
            #   With/$trick/$hack
            #    + $hack = $trick trick
            #   and SCinway
            ss&tw and rs&tw = ss&tw
            #  allowing calm isolated spacewalks
            rs&gently && rs&Gracto and rs&tw = 1
        },'ift,D'],
        
        ['arrive',0.022,&acgtRYp,SC{
            $r = py&R;
            Rs&waits and return T.Z = 8
            # enough to have Rs&C, Rc&b, Ace
            me&Ring,r,{und:r,ov:0.295};
        },'ift,D'],
        &{
        # py&l|r - linked listness of a step
        me.stepneigh = &acgtp{
            $Steps = py&up;
            $z = Stepss&z;
            $pi = z.indexOf(p);
            pi <0 and throw "!step"
            py&l = z[pi-1];
            py&r = z[pi+1];
        };
        },
        # @03 each Steps/(p,r,s) wake up, have features
        #  may be different, may be time to something!
        ['being',0.03,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            sy&R = r;
            
            # p's current walk around Y:Steps
            $Ob = py&O;
            $O = py&O = Cye([p.t,py&cv]);
            Ob and Oc&b = Ob; delete Obc&b
            
            # being three states at once
            #  they may have happened
            me&stepneigh,p;
            
            # sa za la na o, ha i
            me&stepbrackio,p;
            # me&inode arrives $s:step/**$z:node into:
            sy&N ||= [];
            # %adhere-ants like %supr, %twmt realise they're nodes
            # > no room for the totality:
            # %supr was nodesey:
            #  Ring r 304 would have them all sy&R,
            #  provided py&nodes(&j{ for each j }),
            # %supr might:
            #  each step/* is sy&top, has another pool sy&N
            # sy&N order is unreliable
            # < some way to traverse j/** in dialect,
            #   using slep, avoiding %folder, !%supr,
            #   that they should be in sy&N, etc.
            if (rs&supr) {
                # othering C
                # < sleps, sleeping
                # so we can suprise any of them
                me&Ring,R,{und:r,ov:0.304};
                
                #  iterate through here to get:
                #   (j,s) - all %supr things inside/including $p
                # < climb however, refs limited to those in sy&N
                py&nodes = &y{
                    ~>5 nodesing: r.t
                    me&ioty,r,'ball' .map(&j{
                        me&yfuture,j,R != j and throw j.t+" yfuted"
                        js&folder and return
                        $s = jc&s;
                        # must be used on %supr, or anywhere y&N is?
                        !sy&supr and throw "wandering"
                        sy&N .map(s => y(sy&R,s))
                    })
                };
            
                # set by %supr@291
                # also to init from suprised
                py&nodes(&js{ me&persis,s,'y','R',j })
            }
        },'ift,D'],
        
      // Steps 5 6 7
        # < rename Ys&returns Yc&s
        # < make Yc&tug?
        
        # alphabet layercake
        # join our decisions of how
        #  into an over-realm, a computed individual's unity
        #  so decisions that can't be made by anyone
        #  can be made by that mind
        # wording so it applies force around a structure
        #  the decision being to break or not

        # < %supr-ish list/pile process via me&ind, slepping
        #   a natural migration pathway, among slopes...
        #   < know users of the things changing,
        # < writing Ghost/**%dige where not Know/**%dige
        
        ['seee',0.5,&acgtRYp,SC{
            $r = py&R;
            
            me&Ring,r,{und:r,ov:0.315};
            
            # synthesise what S o AnotherStep/... would do
            # < immediately on discovery, check if it is so
            #    takes thinking jy&ha
            #  so io can make sense of eg %twmt
            # < expands to ps&sleeping until condition is met,
            #   possibly this time?
            each waitel,t,n ahsk(rs&wou,'waitel_t_n') {
                ~>3 waitel: n.t,'>=',waitel,'then',p.t
                me&zaft,Yc&M,n,p;
            }}
            
        },'ift,D'],

        ['aseee',0.6,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            
            me&Ring,r,{und:r,ov:0.7};
            
            # hoist the nodes
            each iz sy&N {
                $j = zy&R;
                if (Rc&N.includes(j)) {
                    # awake - accept new za
                    jy&za = me&bracko,j,{now:1};
                }
                # eto even if sleeping
                #  posited as e-ish, of tw, here-ables
                # < keep N in order
                each in jy&za({eto:1}) {
                    ry&ha(n,{node:z})
                }
                
                if (jy&za('ready')) {
                    # < bring back?
                    # j%wou..ready travel on
                    leaves(j,py&n);
                    !n and me&mtsc,g,"nonext"; return
                    ny&R and n = ny&R
                    ~>5 ready: j.t, '->', n.t
                    rs&gently && !me&rolltog,j,{may:'leaves?',tsc:'y',once:1} and return
                    # builds j** into n/
                    me&suprise,j,n
                }
            }
            
            ry&za = me&bracko,r,{now:1};
            $g = me&stepbrack,r;
            me&walls,g,'b:3.3h9';
        },'ift,D'],
        
        # and again to wake things generated into other steps
        #  ie from inside:r, out to where Ring isn't
        # < notice things like that,
        # < use wai to organise elvising it in there
        ['Steps may other',0.67,&acgtRYp,SC{
            $r = py&R;
            me&Ring,r,{und:r,ov:0.7};
        },'ift,D'],
        
        # and again to wake things generated
        ['Trip report',0.7,&acgtRYp,SC{
            $r = py&R;
            $s = rc&s;
            each ij sy&N {
                $j = jy&R;
                if (Rc&N.includes(j)) {
                    # awake - see the words
                    $g = me&stepbrack,j;
                }
            }
        },'ift,D'],
]};
  // stepwai
  # < ha that can think, stream news downstream (z gets read)
  # < sa that can log, selection replayable, dome input slep
  #   to check the conditions for a decision are still so,
  #    without having to conduce the decision again
  # so the guts become a bunch of fibre bundles,
  #  to define NervOS - traces of sense that arm sleepy processes
  #  limbs becoming available
  
        # < jy&da - differing wai of a node
        me.diffwaia = &j,loose,tight,c{
            c ||= {};
            # what you want/specifically
            isst(loose) and loose = G&peel,loose
            isst(tight) and tight = G&peel,tight
            $sa = me&stepwaia,j,ex({b:1},c);
            $za = me&stepwaia,j,ex({now:1},c);
            !(sa && za) and return
            $was = sa(loose);
            $now = za(loose);
            # gets zu grounding into j
            $C = js&C;
            me&zu,'da',{was,now,tight};
            $cha = {};
            each kv tight {
                # k - the column in either
                # v - change type/reaction
                #  ref, slep, in/decrease, growth...
            }
            return cha
        }
        # as r/** wake up & want nodesing
        me.inode = &acgtj{
            if (jy&R) {
                # < might be eg Ace to arrive into
                $meant = j;
                j = jy&R;
            }
            $z = jc&s;
            zy&path = me.cbyb(j,&r{ return rc&s.y.N },'ball')
                .map(r=>rc&s);
            !zy&path and throw "nonoder"
            $S = zy&path[0];
            $N = Sy&N;
            !N.includes(z) and N.push(z)
            zy&R = j;
            if (!jy&sa) {
                # pseudo Nodes o3:
                #  < Y:Nodes must cv each Yc&M as let here,
                #    solo the ones being elvised into life
                me&nodebrackio,j;
            }
            # Step's R that last o3'd, not sleeping
            !Sy&p and throw "Step !y&p"
            !Sy&R and throw "Step !y&R"
            #T.act and jy&ha({noded:T.act})
            return Sy&R
        };
        # base type, wough i and feedback
        #   experience -> notion, notion -> etc
        me.nodebrackio = &acgtj{
            jy&R and j = jy&R
            # sa latest commit (starts <7)
            # < commit phases... doming, like %%eto?
            jy&sa = me&bracko,j,{b:1};
            # za always >7
            jy&za ||= jy&sa;
            # ja always now
            jy&ja = me&bracko,j,{now:1};

            # wai:wou enterer
            # < be R&ha,{yada:voux}, < Babz way/ar params
            # is our chance to react in a Ring,r hang way,
            #  returning/jumping somewhere to think/reapproach
            jy&ha = me&bracki,j;

            # differ before <-> now
            # < caching sa/za, then:
            #   < versioned X, re-waigh if ha since da
            jy&da = &loose,tight,c{
                return 1; # too-caching wough
                me&diffwaia,j,loose,tight,c;
            };
        }
        me.stepbrackio = &acgtp{
            $r = py&R;
            me&nodebrackio,p
            ry&sa = me&bracko,p;
            ry&la = me&bracko,py&l;
            ry&na = me&bracko,py&n;
        }
        me.stepbrack = &acgtjc{
            $g = me&brackology,j,c;
            me&walls,g,'b:2.2';
            # attaching C to r without doming:
            ac(j,'M',g);
            return g
        };
  // brack io
    // bracki
        # steps and nodes wai %wou
        me.brackdef = &acgtc{
            isst(c) and c = G&peel,c
            c ||= {};
            c.k ||= 'wou';
            c.gh ||= 'gh';
            return c
        };
        # input to %wough
        me.bracki = &acgtjc{
            c = me&brackdef,c;
            # into %wou.bunch_of_arks.**
            #  non dup having
            #  have to know the entire path
            $Xi = aha(j,c.k);
            return &s,shade,mix{
                isst(s) and s = G&peel,s
                # we may be given an $n
                isC(s) and $os = s; s = ex({},s.sc)
                isar(s) and throw "many of these"
                
                # indexed by path
                Xi(s);
                
                # listed
                $z = j.sc[c.k+c.gh] ||= Cye([c.k,1,c]);
                $n = Cye(['stuff',1]);
                n.sc = s;
                ac(z,'z',n);
                
                # mix shade -> n.sc for a while
                shade || os and me&brackshade,n,shade,os;
                # row pipelined around
                os and ny&up = os
                ny&brack = z;
                # mix mix -> n.sc
                each kv mix {
                    n.sc[k] = v
                }
                
                # indexed by ns&* index
                $X = zs&X ||= {};
                me&brackX,[n],X;
                # < could know its siblings
                #  < joining to another X.* partition out there,
                #    so our queries can climb through their objects
                # < return bracki localised to s, defaults and more
            };
        }
        # index n by n%*
        #  X/k/ref(s) enumerate columns and their values
        # ongoingly to index N-news into X
        me.brackX = &acgtNX{
            X ||= {};
            X.k ||= {};
            each in N {
                each kv n.sc {
                    $x = X.k[k] ||= {};
                    # without ref(s):
                    x.z ||= [];
                    x.z.push(n);
                    # by id of the value
                    $fs = x.refs ||= [];
                    $vi = fs.indexOf(v);
                    vi < 0 and vi = fs.push(v)-1
                    $f = x.ref ||= {};
                    $fx = f[vi] ||= {};
                    fx.z ||= [];
                    # a row
                    fx.z.push(n);
                }
            }
        }
        # to get rows piped around, grown + washed
        me.brackshade = &acgtn,shade,os{
            # track non-essential k/v, still in n.sc
            #  don't inherit through ha(n)
            # < we could also put separate row linked to n
            #    {n,layer:'somesuch',...h}
            #   then bracko may include the somesuch layer
            #    of whatever it's asking about, if it wants to
            if (shade) {
                # add stuff that vanishes
                nc&shade = ex({},os && osc&shade || {});
                each kv shade {
                    nc&shade[k] = 1;
                    n.sc[k] = v;
                }
            }
            elsif (os) {
                # remove stuff that vanishes
                each kv osc&shade {
                    delete n.sc[k];
                }
            }
        };
    // bracko
        # ry&sa = accessor of wai now|before
        me.bracko = &acgtjc{
            c = me&brackdef,c;
            !j and return &{}
            jy&R and j = jy&R
            if (jy&R) {
                jy&cv < 0.7 && !c.now and c.b = 1
            }
            $r = c.b ? jc&b : j;
            return me&braq,r,c.k+c.gh;
        };
        # query wai, context for
        # < sorting by desire, OR if not AND,
        #    so to solver from the parts we may have
        me.braq = &acgtjk{
            return &co{
                $z = j && j.sc[k];
                !z and return 
                !isC(z) and throw "braq!z"
                !(c||o) and return zs&z
                isst(c) and c = G&peel,c
                $M = [];
                # AND
                $amongst;
                $X = zs&X;
                each tv c {
                    # might have indexing
                    if (X && !amongst) {
                        $x = ahsk(X,'k',t);
                        if (x && v != 1) {
                            $vi = x.refs.indexOf(v);
                            vi < 0 and return
                            x = x.ref[vi];
                        }
                        !x and return
                        each in x.z {
                            !M.includes(n) and M.push(n)
                        }
                    }
                    else {
                        $from = amongst || zs&z;
                        each in from {
                            $non = !(n.sc[t] && (v == 1 || v == n.sc[t]));
                            non && amongst and M = M.filter(out=>out!=n)
                            non || amongst and continue
                            !M.includes(n) and M.push(n)
                        }
                    }
                    amongst = M;
                }
                # one column mode
                if (o) {
                    o == 1 and o = haks(c)[0]
                    $N = M;
                    M = [];
                    each in N {
                        $v = n.sc[o];
                        v == null and continue
                        M.push(v);
                    }
                }
                M.length and return M
            };
        };
        
  // brackology takes a look
    # < rename scgk %
    # < rename this which?
    # will be very useful for situating crammed meanings
    #  at the very wildest edge of things, where wheres where
    # < opesizup->sizo: func the Km/Kn Kn/n edges
    #   so they may show up to a few C.t,
    #    then expand
    # < fill with hooks, combine with KnowC?
    
    me.brackology = &acgtjcz{
        $C = js&C;
        isC(c) and z = c; c = z.c
        else { c = me&brackdef,c }
        z and throw "layers"
        z ||= j.sc[c.k+c.gh];
        
        $g = me&opeology,c.k,{label:{walls:'bg',tsc:'l'}};
        me&walls,g,'b:2.2h6';
        $zuctnu = &gts{
            $nu = me&nu,t,s;
            me&zN,nu;
            me&zuct,g,nu;
        };
        # < renumerate by rows in common
        !z and return g;
        $X = zs&X ||= me&brackX,zs&z;
        
        !hak(X.k) and return g
        
        gy&brack = z;
        zy&brackology = g;
        gy&X = X;
        
        $allope = !Rc&brackuiet;
        if (gs&ope) {
            Rc&brackon = 1;
            $Km = me&opeKm,g,"ope";
            me&opelabel,Km;
            Kms&bg = 000;
            if (Kms&ope) {
                me&nu,'waigh',z;
                me&nu,"X",X;
            }
        }
        Rc&brackon and allope = 1
        
        if (!allope) {
            # < only changes pop up, fade out
            $op = me&opesizup,g,{len:hak(X.k)};
            !(op && ops&ope) and return g
        }
        
        each kx X.k {
            $Km = me&opeKm,g,k;
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)};
            !Kms&ope and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $tee = isC(v) ? v.t :
                    !isob(v) ? v : ki(k,2);
                $Kn = me&opeKn,Km,tee,{label:{tsc:'y'}};
                
                $lab = Kny&label;
                Knc&sortcv = 1;
                isC(v) &&
                    fio(Kn,['sym',112,{s:'C'},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                me&sizo,Kn,{len:fx.z.length};
                Kns&ma = 0.2;
                if (Kns&ope) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # for the value
                        zuctnu(wa,k,val);
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'ܤ',{label:{tsc:'y'}};
                        wans&ope and zuctnu(wa,'rowswith',n)
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    };
    

  
