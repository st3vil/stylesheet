# sentences of stuff
  // stepwai
  # < ha that can think, stream news downstream (z gets read)
  # < sa that can log, selection replayable, dome input slep
  #   to check the conditions for a decision are still so,
  #    without having to conduce the decision again
  # so the guts become a bunch of fibre bundles,
  #  to define NervOS - traces of sense that arm sleepy processes
  #  limbs becoming available
  
        # < jy&da - differing wai of a node
        me.diffwaia = &j,loose,tight,c{
            c ||= {};
            # what you want/specifically
            isst(loose) and loose = G&peel,loose
            isst(tight) and tight = G&peel,tight
            $sa = me&stepwaia,j,ex({b:1},c);
            $za = me&stepwaia,j,ex({now:1},c);
            !(sa && za) and return
            $was = sa(loose);
            $now = za(loose);
            # gets zu grounding into j
            $C = js&C;
            me&zu,'da',{was,now,tight};
            $cha = {};
            each kv tight {
                # k - the column in either
                # v - change type/reaction
                #  ref, slep, in/decrease, growth...
            }
            return cha
        }
        # as r/** wake up & want nodesing
        me.inode = &acgtj{
            if (jy&R) {
                # < might be eg Ace to arrive into
                $meant = j;
                j = jy&R;
            }
            $z = jc&s;
            zy&path = me.cbyb(j,&r{ return rc&s.y.N },'ball')
                .map(r=>rc&s);
            !zy&path and throw "nonoder"
            $S = zy&path[0];
            $N = Sy&N;
            !N.includes(z) and N.push(z)
            zy&R = j;
            if (!jy&sa) {
                # pseudo Nodes o3:
                #  < Y:Nodes must cv each Yc&M as let here,
                #    solo the ones being elvised into life
                me&nodebrackio,j;
            }
            # Step's R that last o3'd, not sleeping
            !Sy&p and throw "Step !y&p"
            !Sy&R and throw "Step !y&R"
            #T.act and jy&ha({noded:T.act})
            return Sy&R
        };
        # base type, wough i and feedback
        #   experience -> notion, notion -> etc
        me.nodebrackio = &acgtj{
            jy&R and j = jy&R
            # sa latest commit (starts <7)
            # < commit phases... doming, like %%eto?
            jy&sa = me&bracko,j,{b:1};
            # za always >7
            jy&za ||= jy&sa;
            # ja always now
            jy&ja = me&bracko,j,{now:1};

            # wai:wou enterer
            # < be R&ha,{yada:voux}, < Babz way/ar params
            # is our chance to react in a Ring,r hang way,
            #  returning/jumping somewhere to think/reapproach
            jy&ha = me&bracki,j;

            # differ before <-> now
            # < caching sa/za, then:
            #   < versioned X, re-waigh if ha since da
            jy&da = &loose,tight,c{
                return 1; # too-caching wough
                me&diffwaia,j,loose,tight,c;
            };
        }
        me.stepbrackio = &acgtp{
            $r = py&R;
            me&nodebrackio,p
            ry&sa = me&bracko,p;
            ry&la = me&bracko,py&l;
            ry&na = me&bracko,py&n;
        }
        me.stepbrack = &acgtjc{
            $g = me&brackology,j,c;
            me&walls,g,'b:2.2';
            # attaching C to r without doming:
            ac(j,'M',g);
            return g
        };
  // brack io
    // bracki
        # steps and nodes wai %wou
        me.brackdef = &acgtc{
            isst(c) and c = G&peel,c
            c ||= {};
            c.k ||= 'wou';
            c.gh ||= 'gh';
            return c
        };
        # input to %wough
        me.bracki = &acgtjc{
            c = me&brackdef,c;
            # into %wou.bunch_of_arks.**
            #  non dup having
            #  have to know the entire path
            $Xi = aha(j,c.k);
            return &s,shade,mix{
                isst(s) and s = G&peel,s
                # we may be given an $n
                isC(s) and $os = s; s = ex({},s.sc)
                isar(s) and throw "many of these"
                
                # indexed by path
                Xi(s);
                
                # listed
                $z = j.sc[c.k+c.gh] ||= Cye([c.k,1,c]);
                $n = Cye(['stuff',1]);
                n.sc = s;
                ac(z,'z',n);
                
                # mix shade -> n.sc for a while
                shade || os and me&brackshade,n,shade,os;
                # row pipelined around
                os and ny&up = os
                ny&brack = z;
                # mix mix -> n.sc
                each kv mix {
                    n.sc[k] = v
                }
                
                # indexed by ns&* index
                $X = zs&X ||= {};
                me&brackX,[n],X;
                # < could know its siblings
                #  < joining to another X.* partition out there,
                #    so our queries can climb through their objects
                # < return bracki localised to s, defaults and more
            };
        }
        # index n by n%*
        #  X/k/ref(s) enumerate columns and their values
        # ongoingly to index N-news into X
        me.brackX = &acgtNX{
            X ||= {};
            X.k ||= {};
            each in N {
                each kv n.sc {
                    $x = X.k[k] ||= {};
                    # without ref(s):
                    x.z ||= [];
                    x.z.push(n);
                    # by id of the value
                    $fs = x.refs ||= [];
                    $vi = fs.indexOf(v);
                    vi < 0 and vi = fs.push(v)-1
                    $f = x.ref ||= {};
                    $fx = f[vi] ||= {};
                    fx.z ||= [];
                    # a row
                    fx.z.push(n);
                }
            }
        }
        # to get rows piped around, grown + washed
        me.brackshade = &acgtn,shade,os{
            # track non-essential k/v, still in n.sc
            #  don't inherit through ha(n)
            # < we could also put separate row linked to n
            #    {n,layer:'somesuch',...h}
            #   then bracko may include the somesuch layer
            #    of whatever it's asking about, if it wants to
            if (shade) {
                # add stuff that vanishes
                nc&shade = ex({},os && osc&shade || {});
                each kv shade {
                    nc&shade[k] = 1;
                    n.sc[k] = v;
                }
            }
            elsif (os) {
                # remove stuff that vanishes
                each kv osc&shade {
                    delete n.sc[k];
                }
            }
        };
    // bracko
        # ry&sa = accessor of wai now|before
        me.bracko = &acgtjc{
            c = me&brackdef,c;
            !j and return &{}
            jy&R and j = jy&R
            if (jy&R) {
                jy&cv < 0.7 && !c.now and c.b = 1
            }
            $r = c.b ? jc&b : j;
            return me&braq,r,c.k+c.gh;
        };
        # query wai, context for
        # < sorting by desire, OR if not AND,
        #    so to solver from the parts we may have
        me.braq = &acgtjk{
            return &co{
                $z = j && j.sc[k];
                !z and return 
                !isC(z) and throw "braq!z"
                !(c||o) and return zs&z
                isst(c) and c = G&peel,c
                $M = [];
                # AND
                $amongst;
                $X = zs&X;
                each tv c {
                    # might have indexing
                    if (X && !amongst) {
                        $x = ahsk(X,'k',t);
                        if (x && v != 1) {
                            $vi = x.refs.indexOf(v);
                            vi < 0 and return
                            x = x.ref[vi];
                        }
                        !x and return
                        each in x.z {
                            !M.includes(n) and M.push(n)
                        }
                    }
                    else {
                        $from = amongst || zs&z;
                        each in from {
                            $non = !(n.sc[t] && (v == 1 || v == n.sc[t]));
                            non && amongst and M = M.filter(out=>out!=n)
                            non || amongst and continue
                            !M.includes(n) and M.push(n)
                        }
                    }
                    amongst = M;
                }
                # one column mode
                if (o) {
                    o == 1 and o = haks(c)[0]
                    $N = M;
                    M = [];
                    each in N {
                        $v = n.sc[o];
                        v == null and continue
                        M.push(v);
                    }
                }
                M.length and return M
            };
        };
        
  // brackology takes a look
    # < rename scgk %
    # < rename this which?
    # will be very useful for situating crammed meanings
    #  at the very wildest edge of things, where wheres where
    # < opesizup->sizo: func the Km/Kn Kn/n edges
    #   so they may show up to a few C.t,
    #    then expand
    # < fill with hooks, combine with KnowC?
    
    me.brackology = &acgtjcz{
        $C = js&C;
        isC(c) and z = c; c = z.c
        else { c = me&brackdef,c }
        z and throw "layers"
        z ||= j.sc[c.k+c.gh];
        
        $g = me&opeology,c.k,{label:{walls:'bg',tsc:'l'}};
        me&walls,g,'b:2.2h6';
        $zuctnu = &gts{
            $nu = me&nu,t,s;
            me&zN,nu;
            me&zuct,g,nu;
        };
        # < renumerate by rows in common
        !z and return g;
        $X = zs&X ||= me&brackX,zs&z;
        
        !hak(X.k) and return g
        
        gy&brack = z;
        zy&brackology = g;
        gy&X = X;
        
        $allope = !Rc&brackuiet;
        if (gs&ope) {
            Rc&brackon = 1;
            $Km = me&opeKm,g,"ope";
            me&opelabel,Km;
            Kms&bg = 000;
            if (Kms&ope) {
                me&nu,'waigh',z;
                me&nu,"X",X;
            }
        }
        Rc&brackon and allope = 1
        
        if (!allope) {
            # < only changes pop up, fade out
            $op = me&opesizup,g,{len:hak(X.k)};
            !(op && ops&ope) and return g
        }
        
        each kx X.k {
            $Km = me&opeKm,g,k;
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)};
            !Kms&ope and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $tee = isC(v) ? v.t :
                    !isob(v) ? v : ki(k,2);
                $Kn = me&opeKn,Km,tee,{label:{tsc:'y'}};
                
                $lab = Kny&label;
                Knc&sortcv = 1;
                isC(v) &&
                    fio(Kn,['sym',112,{s:'C'},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                me&sizo,Kn,{len:fx.z.length};
                Kns&ma = 0.2;
                if (Kns&ope) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # for the value
                        zuctnu(wa,k,val);
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'ܤ',{label:{tsc:'y'}};
                        wans&ope and zuctnu(wa,'rowswith',n)
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    };
    