# sentences of stuff
  // brackism
    # see %%acty, %%may, %%wants, %%waits
    #  not the usual row of stuff
   // may
    # posit edge of a work
    #  having a phase to interlock
    # q describes a possibility of an act
    # a what's needed to complete it
    # might solve immediately, bracking no %%may
    # < %%waits as me&waits (hault)
    me.may = &acgtRtaq,qe{
        isst(a) and a = G&peel,a
        isst(q) and q = G&peel,q
        a.may = t;
        # the question %%may,...
        q = ex({may:t},q);
        ex(q,qe);
        # the answer ..,%may
        $N = (Ry&ja(a)||[])
            .filter(n => haks(n.sc).slice(-1)[0] == 'may');
        if (N && N.length) {
            # a-found rows
            # < merged with q?
            # < ha with %%indeed, which noops the may+waits
            return N
        }
        Ry&ha(q);
        return []
    };
   // diff 
        # < jy&da - differing wai of a node
        me.diffwaia = &j,loose,tight,c{
            c ||= {};
            # what you want/specifically
            isst(loose) and loose = G&peel,loose
            isst(tight) and tight = G&peel,tight
            $sa = me&stepwaia,j,ex({b:1},c);
            $za = me&stepwaia,j,ex({now:1},c);
            !(sa && za) and return
            $was = sa(loose);
            $now = za(loose);
            # gets zu grounding into j
            $C = js&C;
            me&zu,'da',{was,now,tight};
            $cha = {};
            each kv tight {
                # k - the column in either
                # v - change type/reaction
                #  ref, slep, in/decrease, growth...
            }
            return cha
        }
  // stepbrack
  # < ha that can think, stream news downstream (z gets read)
  # < sa that can log, selection replayable, dome input slep
  #   to check the conditions for a decision are still so,
  #    without having to conduce the decision again
  # so the guts become a bunch of fibre bundles,
  #  to define NervOS - traces of sense that arm sleepy processes
  #  limbs becoming available
     // forestep
        # makes eg R&za,c,o -> &acgtco{ za(acgtRco) }
        # R.prototype.za? R = this? etc
        #  does every haks(R) out there get confused?
        # < Babz for each in me&thing { # call thing once
        me.Racgty = &y{
            return &acgt{
                $args = [...arguments].slice(4);
                return y (A,C,G,T,args)
            }
        };
        
        # io %wough, a feedback loop
        #   experience -> notion, notion -> etc
        me.sahazaja = &acgtj{
            jy&R and j = jy&R
            $k = 'wough';
            
            # resolve z, expanding args to bracko
            #  eg j&za,c,o -> me.bracko(acgtjzco)
            $brack = &ky{
                k = 'brack'+k;
                return me.Racgty(&acgt,args{
                    $z = y ();
                    !z and return
                    return me&$k,j,z,...args;
                });
            };
            
            # reading from what is beginning,
            #  what was mid-way,
            #  what got to the end
            #   < without &bready? or just !sleep?
            
            # ja always now
            j.ja = brack('o',&{ return j.sc[k] })
            
            # sa last time
            $saz = me&ollbs,j,k
            j.sa = brack('o',&{ return saz })
            
            # za always >7
            $zak = k+'_accepted';
            $zaz = me&rollbs,j,zak;
            me&reaw,j,zak;
            j.za = brack('o',&{ return zaz });
            
            # and they can always return arrays (to .map...)
            $thisj = j
            j.saa = &{ return thisj.sa(...arguments) || [] }
            j.zaa = &{ return thisj.za(...arguments) || [] }
            j.jaa = &{ return thisj.ja(...arguments) || [] }
            # wai:wou enterer
            # < be R&ha,{yada:voux}, < Babz way/ar params
            # is our chance to react in a Ring,r hang way,
            #  returning/jumping somewhere to think/reapproach
            j.ha = brack('i',&{
                $z = j.sc[k] ||= Cye([k,1,{}]);
                zy&R ||= j;
                return z
            })
            

            # GOING - call them with this ACGT until converted
            jy&za = &{ return j&za,...arguments }
            jy&sa = &{ return j&sa,...arguments }
            jy&ja = &{ return j&ja,...arguments }
            jy&ha = &{ return j&ha,...arguments }

            # differ before <-> now
            # < caching sa/za, then:
            #   < versioned X, re-waigh if ha since da
            jy&da = &loose,tight,c{
                return 1; # too-caching wough
                me&diffwaia,j,loose,tight,c;
            };
        }
     // bracknode
        # < everyone &bready?
        # < call &stail if !&bready but otherwise &settle
        # < catching that %Pave elvis async already @315
        #    coming back to complete bunches at a time
        # < avoiding any more Ring r**,
        #    winding them past mind they can't reach,
        #     recycling domes of stuff
        # < alterior sleeping - when %%waits stops Ring
        #   does it accept r as b? suppose, to display
        #    r/** want winding past their whole lives if strange
        #     winds to 9...Display while %sleeping?
        
        
        # < call multiple times as $p graduates
        me.aftstep = &acgtRprs{
            $stepsleeping = me&zamerge,R,r,s;
            # hoist the nodes!
            each iz sy&N {
                $j = zy&R;
                $nodesleeping = me&zamerge,R,j,z;
                if (!stepsleeping) {
                    # hoist to step, even if nodesleeping
                    
                    # %%eto from last good (za)
                    # eg %%tw, names throughout r**
                    #  other $p reads|wants them, to &settle,
                    #   and %acty++ etc per process
                    # kind of e-ish
                    # < keep N in order
                    j&zaa,'eto' .map(n => ry&ha(n,{node:z}))
                }
                if (!nodesleeping) {
                    me&stepbrack,j
                }
            }
            
            if (!stepsleeping) {
                # w:KnowThee: toplevel automation on &settle
                # < maybrack
                if (ry&za('ready')) {
                    # < bring back?
                    # j%wou..ready travel on
                    $n = py&n;
                    !n and me&mtsc,g,"nonext"; return
                    ny&R and n = ny&R
                    ~>5 ready: j.t, '->', n.t
                    rs&gently && !me&rolltog,j,{may:'leaves?',tsc:'y',once:1} and return
                    # builds j** into n/
                    me&suprise,r,n
                }
                $g = me&stepbrack,r;
                me&walls,g,'b:3.3h9';
            }
        }
        
        # node|step commits za
        #  returns true if r is not able to display
        me.zamerge = &acgtRrs{
            # displayable after sleepywind
            rs&sleepung and ~>3 node pung: r.t
            else
            # reawakened + tunneled through (Know)
            rs&sleeping and return ~>3 node sleeping: r.t
            else
            # not awakened
            !Rc&N.includes(r) and return ~>3 node avoid: r.t
            # ^ would all keep za same
            else {
                # awake - accept new za
                rs&wough_accepted = rs&wough
            }
        }
        
        me.stepbrack = &acgtjz{
            $g = me&brackology,j,z;
            me&walls,g,'b:2.2';
            # attaching C to r without doming:
            ac(j,'M',g);
            return g
        }
        
        
  // brack io
    // bracki
        # brack into j%($k||='wough') ||= C:stuff%z%X
        # < future ha: n %thing,etc
        me.bracki = &acgtjz,s,shade,mix{
            !z and throw "noz"
            
            isst(s) and s = G&peel,s
            shade && isst(shade) and shade = G&peel,shade
            mix && isst(mix) and mix = G&peel,mix
            # we may be given an $n
            isC(s) and $os = s; s = ex({},s.sc)
            isar(s) and throw "many of these"

            # listed
            $n = Cye(['stuff',1]);
            n.sc = s;
            ac(z,'z',n);

            # mix shade -> n.sc for a while
            shade || os and me&brackshade,n,shade,os;
            # row pipelined around
            os and ny&up = os
            ny&brack = z;
            T.act and ny&act = T.act;

            # mix mix -> n.sc
            each kv mix {
                n.sc[k] = v
            }

            # indexed by ns&* index
            $X = zs&X ||= {};
            me&brackX,[n],X;
            # < could know its siblings
            #  < joining to another X.* partition out there,
            #    so our queries can climb through their objects
            # < return bracki localised to s, defaults and more
            return n
        }
        # index n by n%*
        #  X/k/ref(s) enumerate columns and their values
        # ongoingly to index N-news into X
        me.brackX = &acgtNX{
            X ||= {};
            X.k ||= {};
            each in N {
                each kv n.sc {
                    $x = X.k[k] ||= {};
                    # without ref(s):
                    x.z ||= [];
                    x.z.push(n);
                    # by id of the value
                    $fs = x.refs ||= [];
                    $vi = fs.indexOf(v);
                    vi < 0 and vi = fs.push(v)-1
                    $f = x.ref ||= {};
                    $fx = f[vi] ||= {};
                    fx.z ||= [];
                    # a row
                    fx.z.push(n);
                }
            }
        }
        # to get rows piped around, grown + washed
        me.brackshade = &acgtn,shade,os{
            # track non-essential k/v, still in n.sc
            #  don't inherit through ha(n)
            # < we could also put separate row linked to n
            #    {n,layer:'somesuch',...h}
            #   then bracko may include the somesuch layer
            #    of whatever it's asking about, if it wants to
            if (shade) {
                # add stuff that vanishes
                nc&shade = ex({},os && osc&shade || {});
                each kv shade {
                    nc&shade[k] = 1;
                    n.sc[k] = v;
                }
            }
            elsif (os) {
                # remove stuff that vanishes
                each kv osc&shade {
                    delete n.sc[k];
                }
            }
        };
    // bracko
        # ry&sa = accessor of wai now|before
        # query wai, context for
        # < sorting by desire, OR if not AND,
        #    so to solver from the parts we may have
        me.bracko = &acgtjzco{
            !z and return
            !isC(z) and throw "braq!z"
            !(c||o) and return zs&z
            isst(c) and c = G&peel,c
            $M = [];
            # AND
            $amongst;
            $X = zs&X;
            each tv c {
                # might have indexing
                if (X && !amongst) {
                    $x = ahsk(X,'k',t);
                    if (x && v != 1) {
                        $vi = x.refs.indexOf(v);
                        vi < 0 and return
                        x = x.ref[vi];
                    }
                    !x and return
                    each in x.z {
                        !M.includes(n) and M.push(n)
                    }
                }
                else {
                    $from = amongst || zs&z;
                    each in from {
                        $non = !(n.sc[t] && (v == 1 || v == n.sc[t]));
                        non && amongst and M = M.filter(out=>out!=n)
                        non || amongst and continue
                        !M.includes(n) and M.push(n)
                    }
                }
                amongst = M;
            }
            # one column mode
            if (o) {
                o == 1 and o = haks(c)[0]
                $N = M;
                M = [];
                each in N {
                    $v = n.sc[o];
                    v == null and continue
                    M.push(v);
                }
            }
            M.length and return M
        };
        
  // brackology takes a look
    # < rename scgk %
    # < rename this which?
    # will be very useful for situating crammed meanings
    #  at the very wildest edge of things, where wheres where
    # < opesizup->sizo: func the Km/Kn Kn/n edges
    #   so they may show up to a few C.t,
    #    then expand
    # < fill with hooks, combine with KnowC?
    #   see CB, which also wants:
    # < brackology with styles
    # < similar columns grouping
    
    me.brackology = &acgtjz{
        $C = js&C;
        isst(z) and $k = z; z = null
        z and throw "layers"
        k ||= 'wough';
        z ||= j.sc[k];
        k = z && z.t || k;
        $g = me&opeology,k,{label:{walls:'bg',tsc:'l'}};
        me&walls,g,'b:2.2h6';
        !z and return g;
        
        $zuctnu = &gts{
            $nu = me&nu,t,s;
            nus&ope = 1;
            me&zN,nu;
            me&zuct,g,nu;
        };
        $X = zs&X ||= me&brackX,zs&z;
        
        !hak(X.k) and return g
        
        gy&brack = z;
        zy&brackology = g;
        gy&X = X;
        
        $allope = !Rc&brackuiet;
        if (gs&ope) {
            Rc&brackon = 1;
            $Km = me&opeKm,g,"ope";
            me&opelabel,Km;
            Kms&bg = 000;
            if (Kms&ope) {
                me&nu,'waigh',z;
                me&nu,"X",X;
            }
        }
        Rc&brackon and allope = 1
        
        if (!allope) {
            # < only changes pop up, fade out
            $op = me&opesizup,g,{len:hak(X.k)};
            !(op && ops&ope) and return g
        }
        
        each kx X.k {
            $Km = me&opeKm,g,k;
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)};
            !Kms&ope and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $tee = isC(v) ? v.t :
                    !isob(v) ? v : ki(k,2);
                $Kn = me&opeKn,Km,tee,{label:{tsc:'y'}};
                
                $lab = Kny&label;
                Knc&sortcv = 1;
                isC(v) &&
                    fio(Kn,['sym',112,{s:'C'},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                me&sizo,Kn,{len:fx.z.length};
                Kns&ma = 0.2;
                if (Kns&ope) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'Ü¤',{label:{tsc:'y'}};
                        if (wans&ope) {
                            # whole row
                            me&introqua,[R,'row'],{boost:1},'@1';
                            zuctnu(wa,'row',n)
                        }
                        else {
                            # for the value
                            zuctnu(wa,k,val);
                        }
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    };
    