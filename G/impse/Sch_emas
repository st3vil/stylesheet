# get from R to SCA
#  SCA needs to be above what's awaking,
#   but then can do many reactions in a single self
=pod
 for groups of language to find their completion
 Know->That was an I mixer,
  becomes one of many things we could do with W
  Place for generating to e
  
  < turn into
 Know $W used, versions in here
 Travel $W using: $W used, why
 That $W using
    #  early messing with awakeness
=cut
me.Sch_ema = &acgt{ return [
    ['Crun','7',&acgtRs{
        ah(R,'reawakens','Crun',{rollbs:'Crun'});
        s&height = '44%';
        me&tsc,"%Crun",0,'B' .sc.dis = 1;
        $Y = Rs&Ace;
        $f = Y.4[1];
        $SC = fs&Ying;
        me&nu,'SC',SC;
    },'ift,D'],
    
    ['KnowThee','304',&acgtRs{
        $h = me&Ying_Schema,R,'KnowThee',{};
        n Know 1  %bri:0.7,Pavings
        # Comal/Conal, Comste/Conste
        #n Compiling 3  %hue:70,supr:Conal
        #n Seq 5  %hue:110,supr:Conste,Omplateau
        # Know <-> Travel
        n Ghost 2
        n Travel 3 travelty:2 %trave
        n To 5
        
        n That 7  %Pavings

        hy&domed()
    },'ift,D'],
    
    &{
    # drink grounds into Ying/Schema
    me.Ying_Schema = &acgtRtc{
        $SC = me&rollbsc,R,'Ying';
        $s = me&Ying,R,SC,'Schema',{t:t},1;
        # steps adopted from recent: n ...
        sy&domed = &{
            $N = me&ydome;
            me&Ying,R,s,{N:N},2;
        };
        return s
    };
    },
// etc
    # %Ying and %SomeSchema+ 
    ['SCinto','292',&acgtRs{
        # look for R/r(%SC=ForThee
        #  becomes R%ForThee%SupplyChai
        $g = me&opeolo,'SCinto';
        me&ioty,s,'SC','' .map(&z{
            $t = zs&SC;
            $c = gy&can('m','SC-able');
            $n = cy&can('n',t,{label:1});

            ny&can('ope',&{
                R.sc[t] = 1;
                # need to pick an SC-able drops
                $ml = cy&label;
                mls&fs = 6;
            });
        });
    },'ift,D'], 
    
    # the %eph and its /** become %supr
    #  and %$sy&supr - suprise puts that
    ['ball+supr','291',&acgtRs{
        sy&R = R;
        # children get %supr in time to get here
        ac(R,'inheritsc','supr');
        # our %ball/%fix appear after @4
        Rs&fixatfour = 1;
        # %supr only becomes %$supr if a node:
        #  me&suprise mostly just transfers it
        #   to sy&supr on entering a node
        sy&supr and R.sc[sy&supr] = 1
        # see Y:Steps about %nextlifesc %nottilund
    },'ift,D'],

    # < awake inner than 4
    ['KnowThee','66',&acgtRs{
        #me&nu,'KnowThee',R;
        $SC = Rs&Ying;
        Rs&notun = 1;
        each in SCs&steps {
            $r = ny&R;
            # these happen to not tunnel good,
            # < SCA reaw the %projected
            r && rs&eph and rs&notun = 1;
        }
    },'ift,D'],
    
]};

me.Yingmind ||= {};


me.Yingmind.Schema = &acgt{ return [
    # %*T pronounces how it will be, arranging for SCing:
    # A:SC@1 %SupplyChai=C macro laterer
    #  A:Schema@1 %SCh/$t=C micro schema
    #   ...gets finished:
    #  A:Schema@2 can slep & tell macro
    #   @3 with each other, notice late joiners
    #   @4 patterns emerge
    #   @5 decide how to change the game in progress
    #   @6 Ret (via bal) the step
    # SCing:
    # A:SC@2 inits
    #  A:Schema@6 may be moved in here,
    #   to avoid it Ringing outside the SCing

    # %KnowThat forks SC/Schema/t=KnowThat
    ['forks',0.01,&acgtRYs,SC{
        # organise SC's Ys as of/t:
        $Sch = me&Yingio,SC,'Schema';
        $t = Ys&t;
        !t and throw "give t"
        # el:1 recreates, string t makes spacer
        #  and sets sy&Y = Y
        $s = me&Yingio,Sch,t,{el:1,Y:Y};
        Yc&M = [s];
        # drop cache # < wake Y:Schema if diff
        delete Schc&compiled;
    },'ift,D'],
    # day, display zone
    ['on',0.02,&acgtRYs,SC{
        sy&R = R;

        $g = sy&g = me&opeolo,s.t,{walls:'b:2.2h6',label:{walls:'bg'}};
        Rc&brackuiet = 1;
        gy&can('ope',&{ Rc&brackuiet = 0 });
    },'ift,D'],
    # i $s:schema/$step o T.nN/*:step
    # steps adopted from recent: n ...
    ['steps adopted',0.11,&acgtRYs,SC{
        $N = Ys&N;
        !N and throw "nosteps"
        each in N {
            $p = fio(s,[n.t,n.y.cv||1]);
            py&Schema_step and throw "multi schema step", n
            py&Schema_step = n;
        }
    },'ift,D'],
]};
