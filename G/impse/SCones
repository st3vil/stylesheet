# Flanges!!

me.SCones = &acgt{ return [
    # vast oldness, Peace
    ... me&ruv ,
    # W etc relatives
    ... me&Sch_Pavings ,
    ... me&Sch_Constel ,
    ... me&Sch_ema ,
    ... me&YingA ,
    
]};

=pod reintroduce MindInto
 GONE are %ting, %tracting, %Gracto, %folder
 
 Know/*%Pave gently, a %Zave that doesnt expect here
  and any o Know/**$u o Ghost/$n/$u o Run/**$n
  < io: optimise for Knowy&tw[u.t]
  < io: pipelines, listen for new Run/**
 %Pave finding species, set to Rc&s
  spreads implying ting configuration:
   > Cloadsc writes stuff up/down
    < able to deduce impliables at me&adhere?
  < That%directory=ForThe/That will be implied by That%J
  Know/**%directory=else/ward are else/ward/$t
  <   $t%director childrens implied %directory += $t
  
  %Search for %species (is in the $t)
   < local %Search host,
  < _ting c&ready -> Qup the first time !?
    < comeback to %waits etc
  
  me&bal fills %Ying/$step%ball%etc from the schema
    or %ball%eph for floating steps, not in Rc&s
    
  < s&J see 'resolve through JRom'
    which SCA would get some extra controls on,
     doing many tiny Rings etc.
     needs a self-awareness module,
      combined with slomo elvising
      see 'cant always trust whatever these might be'
  SCA:
   < logs/maps/rules elvising going in
   < so $r can be paused
  < adhere generally, %Pavings want attending into Travel
    defaulting to mixing the W I as per %J
  < elvis itself the steps wanting to wake up
    start that paused, lets travel loose
  < code folder, fix Zif diff squish
  Paving 5
  
=cut

me.Sch_Pavings = &acgt{ return [
    ['Abodo',0.7,&acgtRs{
        delete s&bgi;
    },'ift,D'],
     ['Peace',0.7,&acgtRs{
         s&hue ||= 30;
     },'ift,D'],
     ['twin',0.31,&acgtRs{
         me&tsc,'shtuckato',0,'B';
     },'ift,D'],
        
// Paving 5{
    ['Paving',0.5,&acgtRs{
        # waits for each Pave,
        #  draws clues together
        sy&R = R;
        sy&f = R;
        $con = me&rolltog,R,{may:'Pave',tsc:'l',acty:8};
       // draw from clues
        $Q;
        each ir Rs&Zaving {
            rs&waits and me&waits,'...'
            Q = rs&Q;
        }
        Rs&waits and return
        
        $notready = !Q || !Qs&ready;
        notready and me&waits,"!ready"
        $w = Qc&s;
        !w and me&waits,"!live"
        !w && !notready && Qc&el == '9' and Rs&creatine = 1
        
        Rs&Live = Qc&s;
        Rs&Q = Q;
        
        Rs&waits and return
        
        # send r%trouble as late as you want to open it
        me&ollbs,R,'trouble' and Rs&openey = 1
        
        # roll/sleepatch inner processes
        me&rolls,'grype',{s:Q.t+"@"+Qs&dige}
            && me&rollbs,'changey';
        

        # looking at the answer
        # < sleep by Q&dige
        $Thing = Rs&Glean = me&lookaQ,Q;
        # sync ss&dige and Thing's dige (however it appears)
        #  and whatever other Things project knowledge around

        # key behaviours, to stare at problems for longer:
        # hold changes to s that it has already
        # < we don't need to compile simple connections?
        #   trusted sources etc
        # ! if grype causes f%changey but applies the change
        #   (liesnotok=1 not to)
        #   grype rolled forgets it made the change
        #   f%changey can be forgot if R%tracting is interrupted
        # don't apply change from the Thing until Compiling wants to
        Rs&liesnotok = 1;
        me&rollbs,'commiting' and Rs&liesnotok = 0; Rs&commiting++
        # hold waking Thing changes are projected into:
        # < without hiding the change
        #Rs&noprojcha = 1;

        # %ting attr were auto upload/download by A:f
        # < configure it here sometimes
        me&grype,R,'ting';

        # %dige-ish group - change makes fs&changey
        me&grype,R,'W',{w:Thing};

        # < particularly if it changes when we game look->get,
        #    would mean a 4 is not pointing to the 1 proper

        # %el etc
        $inc = me&grype,R,'inc';
        if (inc) {
            if (ss&el == 9) {
                Ds&bri = 0.6;
                me&mtsc,inc,'ig',0,'B'
                # < also ignored by the compiler
                Rs&ignore = 1;
                return
            }
            ss&el == 7 and me&mtsc,inc,'hmm',0,'B'
        }
        # children selected per scheme
        # eg not %ignore
        Rs&zget = &Ry{
            me&ioty,R,'Paving' .map(&r{
                rs&ignore and return
                y(r)
            })
        };
        
        # we must now become changey if:
        #   any of our W-type data changes
        #   child dige projection wrong
        Things&Wind and me&gromps,R,'Wind','t,dige',Things&Wind
        # tally  grypes and gromps (from above)
        Rs&tracting = R;
        me&grimp,R;
        delete Rs&tracting;

        if (con) {
            me&zu,'Thingstract',Thing
            Rs&changey and me&zu,'changey',Rs&changey;
            Rs&trouble and me&zu,"Rtrub",Rs&trouble;
            #me&zu,'Loadism',load
        }
        
        # various leads to %changey, %openey, %trouble
        if (Rs&changey) {
            # dige here or inside solving
            me&tsc,"R%changey","cha",'G';
            s&bgh = 111;
            # 2 them
            me&ioty,R,'ball'
                .map(n => ns&openey ||= 1)
        }
        Rs&trouble and me&tsc,'trouble','trou','G'

        Rs&Paving_good = 1;

        return;
        # < applying the sort-out-code scheme
        # wanting a decision on each one
        # (1 keep, 7 transfiguration, 9 death)
        if (!ss&el) {
            me&tsc,'('
            me&rolltog,R,'9',0 and ss&el = 9
            me&rolltog,R,'7',0 and ss&el = 7
            me&tsc,')'
        }
    },'ift,D'],
    &{
    # know about the Thing independent of the species
    me.lookaQ = &acgtQ{
        $s = Qc&s;
        !s and throw "Q!s"
        $Thing = Cye([s.t,1]);
        if (Qc&species == 5) {
            Things&dige = ss&ha;
            o $s/W/*:s
            each in ays&s {
                ah(Thing,'Wind',n.t,ns&ha)
            }
            # < some piles reway, others remix
            #   some are way leading to many
            o $s/w/*:s
            each in ays&s {
                ah(Thing,'wind',n.t,ns&dige)
            }
        }
        elsif (Qc&species == 1 || !Qc&species) {
            # < can do similar for .4
            # < pointings that adjust for its compression
            each in sy&N {
                ns&W && !ns&z &&
                    ah(Thing,'Wind',n.t,ns&ha)
            }
            $dige = Qs&dige;
            !dige and throw "nodige"
            # W:spot/* %ha are 9 (see AWriter), %dige are 12
            if (Q.t.indexOf('spot/') == 0 &&
                dige.length == 12) {
                dige = dige.substr(0,9)
            }
            Things&dige = dige;
        }
        return Thing
    }
    },
    # R%Paving_good waits for R/*%tracting_good, etc
    #  when we can rely on our children to complain,
    #  know if they're changey/trouble
    ['ball+Paving_good','52',&acgtRs{
        T.Mw = 'trac';
        $p = Ry&up;
        Rs&zget(R,&r{
            # into this pool of what we're looking for from who
            # < display their stuff up against them
            #   dividing the ball in two

            # completed 51
            !rs&Paving_good &&
                ah(R,'waitz','tw_scgk_r',r.t,'Paving_good',r);

            # completed 52
            #  which they haven't this future
            #  it should know changzo/simply/awake+ready,
            #   which would unset in 61 if net change
            !me&ollbs,r,'Paving_goodin' &&
                ah(R,'waitz','tw_scgk_r',r.t,'Paving_goodin',r);

        });

        # autothink:
        # sending %trouble should lead to %Paving_good
        $wa = {solvent: [{
            dscif: {scgk:'Paving_good'},
            arkfor: {r: {cb:&dr{
                ac(r,'trouble',R.t+" wants %Paving_good")
            }}}
        }], beready:1};

        # weakly supposing no signal means ok
        !me&waitzo,R,wa and return

        # children at least here
        #  Ring usu. children almost here
        Rs&Paving_goodin = 1;

        # modulat from the grype of late only
        if (Rs&changey) {
            $out = [];
            each in Rs&changey {
                !ny&R || Rc&N.indexOf(ny&R) >= 0 and continue
                ny&timingout ||= 0;
                ny&timingout++ > 2 and out.push(n)
            }
            Rs&changey = Rs&changey
                .filter(n => out.indexOf(n) < 0);
            !Rs&changey.length and delete Rs&changey
        }

        # which means all we need to compile is connected!
        if (!ps&Paving) {
            aha(p,'wou')({ready:1,tw:R.t,r:R});
            aha(p,'wou')({reedy:1,tw:R.t});
        }
    },'ift,D'],

// Pavings 3{
    # < timing: after/inside ^%MindInto->%SupplyChai @305
    #    which should delay children while it sets up
    #   then Y:SupplyChai: Steps walk @6
    #     which Y:Steps: Gracto @3 Rings in
    ['Pavings',0.306,&acgtRs{
        me&reaw,R,'Pavings';
        # borrow %Paving params
        me&adherePaving,R,R;
        # to give on to %Paving
        me&inherePaving,R;
    },'ift,D'],
    &{
        # inhere
        me.inherePaving = &acgtR{
            me&ioty,R,'ball' .map(&r{
                rs&Paving = 1;
                me&adherePaving,R,r;
            })
        };
        # adhere eg r%dir = s%dir || R%dir
        me.adherePaving = &acgtRr{
            $s = Rc&s;
            $z = rc&s;
            zs&directory and zs&directory = zs&directory.replace(/\/$/,'')
            ['directory','Paving'].map(&k{
                # each of any params that matter
                #  on s when not as inherited from R
                $is = hak(z.sc,k) ? z.sc[k] : R.sc[k];
                # and eg. %directory='' leaves
                is and r.sc[k] = is
            })
        };
    },
    # %Paving splits into species
    ['Paving',0.36,&acgtRs{
        $of = Rs&Paving;
        of == 1 and of = 'W'
        me&reaw,R,'Paving,directory';
        me&rollbs,R,'fully';
        # see if there's a HEAD-type method for this Qc&of
        $M = [];
        if (of == 'W') {
            m W\.5 2  %species:5
            Rs&fully &&
                m W 1
        }
        else {
            m $of 1  
        }
        each in M {
            # Rs&* and rs&* -> Qc&*, Qc&of = %Pave
            ns&Pave ||= of;
            nc&R = 1;
            n $n
        }
        # to give on to *%Paving
        Rs&openey &&
        me&inherePaving,R;
    },'ift,D'],
    
    # %Paves collect a species
    ['Pave','291',&acgtRs{
        $p = Ry&up;
        $s = pc&s;
        # since Zaving@294, reuse foldy thing
        ah(p,'Zaving',R.t,R);
        # similar to %Zave,
        #  G&t,Q directly, no %Saveting
        #  no %Here
        #   until download+decode
        #   or a write is proposed
        #   or our cache (dige/versiona) could go there
        
        $Q = me&rollbsc,R,'Q';
        Q.t = s.t;
        Qc&of = Rs&Pave;
        Qc&async = &{};
        Qc&ready = &CP{};
        ['directory','species'].map(&k{
            $is = R.sc[k] || p.sc[k];
            is and Q.c[k] = is
            else { delete Q.c[k] }
        });
        # compile to $t for Search
        Qc&directory and Q.t = Qc&directory+'/'+Q.t
        Qc&species and Q.t = Q.t+'/'+Qc&species
        # and for humans
        n of 101 $s:Qc&of %hs:348,fs:9
        Qc&directory &&
        n directory 102 $s:Qc&directory %fs:8,hs:194
        n t 11 $s:s.t %hs:348
        Qc&species &&
        n species 112 $s:Qc&species %fs:8,hs:157
        
        
        # Q refinds P each G&t
        $w = me&t,R,Q;
        # per most of this besides s, el + hooks
        #me&nu,Q.t,Q.c;
        
        !Qs&ready and return me&waits,'!ready','...'
        # $w may wander off, usu clones into %Gens%self
        # < following P into the future (%Differ)
        
        n el 13 $s:Qc&el %hs:348,fs:9
        
        me&rolltog,R,{maydo:'Q'} &&
            me&zu,'Q',Q;
        
        Qc&s && me&rolltog,R,{maydo:'s'} &&
            n s  $s:Qc&s %R:ball
        
        # have the thing, readyonly, copied from Pc&s
        # < Q can Qs&Want_Decode for itself
        Qc&s and Rc&s = Qc&s
        
        # then something posits string to follow:
        Rs&commitstring = &s{
            # < require they know parent==Ps&dige
            Rs&Committing = Qs&string = s;
            me&t,R,Q;
        };
    },'ift,D'],
    
]};
# R%Conal waits for Know|That/...r%Pave+=%fully
# < set %creatine
me.RedialyPaving = &acgtRrk{
    k = 'Redialy'+(k?'-'+k:'');
    $sa = Ry&sa;
    $ha = Ry&ha;
    # is all there or 404
    $fok = r && (rs&Paving_goodin || rs&creatine);
    !fok and return me&waits,'!fok'
    if (sa(k)) {
        !rs&fully and throw "undialed"
        ha(k)
    }
    else {
        rs&fully = 1;
        ha(k)
        return 1
    }
};
me.Sch_Constel = &acgt{ return [
    # hierarchise, do batches of updates 
    # < more than W I mixes
    # < plots intention to travel
    
  // Conste 3{
        ['ball+Conste','31',&acgtRs{
            $l = sy&l;
            sy&f = ly&f;
            # if top, have + ignore src f
            #  see unifiers may have ground
            sy&top == s and sy&f = ly&inf
            else {
                # non-top, must use ouf if non-leaf
                sy&f = ly&leaf ? ly&inf : ly&ouf
            }
        },'ift,D'],
        ['ball+Conste','32',&acgtRs{
            T.Mw = 'Conste';
            $sa = Ry&sa; # last waigh
            $ha = Ry&ha; # wai-in aha()()
            $da = Ry&da; # differ last waigh <-> now waigh
            # from in or out?
            $f = sy&f;
            $Q = fs&Q;
            !Q || !Qs&ready and return me&waits,'!Q'
            me&RedialyPaving,R,f and return
            Qc&species == 5 and return me&waits,'Q5'
            
             
  // Conste-ing{
            # only top %Conste compiles
            sy&top != s and return
            
            # o **!%redialy
            #  very in future
            $N = sy&N.map(s => sy&R).filter(&j{
                return !jy&sa('Redialy')
            });
            N.length and return ha('waits:them-redialy')
            
            # check out n
            $cha = [];
            $Lives = [];
            each in sy&N {
                $j = ny&R;
                $f = ny&f;
                !f and return me&waits,n.t+"-!f"
                !fs&Live and return me&waits,n.t+"-!f%Live"
                # fs&Live stills
                $was = me&rollbs,j,'Live';
                fs&Live != was and cha.push(cha)
                js&Live = fs&Live;
                # < copy into This/$t/{origin,comp} meanwhile
                #   to externalise to perl to jsbabz it
                #   to apply hacks in waves to it, so differ
                #   to allow processing over many lives
                #    syncing Know/* to resume/complete
                
                # see how the things should mix before hacking?
                #   to reduce the load to:
                # hacking each W as per ...
                # draw attention to hacks on the inside
        
                # any fy&Gc&s.sc.* unknown may be instructions
                # fy&W may have access to:
                # < Search%Mix.W low level tv mixage
                #   should mix %ting=js|W
                #     Ws&I/$of/$C as $W/$of/$C
                #   would be where I needs bootstrapping
                #    from a dozen few-thousand line /js/
                #     to a few dozen thousand line /W/
                #      with some Babzing before it I's too
                #      so we have a bunch of ghost to show for it
                
                # < look in Hacks/$t for compile tricks
            }
            $Lives = me&ioty,R,'Conste'
                .map(j => js&Live);
            Lives.filter(L=>!L).length and return ha('waits:them-Live')
            
            me&rollbs,R,'Ready';
            cha.length and delete Rs&Ready
            
            # this mix in the source
            $D = Rs&Live;
            # < don't need it to be there
            !D and return me&waits,"!live"

            $g = me&opeology,"%Ready",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"redo?"
                res&ope and delete Rs&Ready
            }
            
            if (!Rs&Ready) {
                $Ready = Rs&Ready = me&unifydin,D,Lives;
                !Ready and return me&waits,"unifydin.."
                # we can/should attach s&W from Wind
                $Wi = Readyy&Wind || {};
                each kv Wi {
                    fio(Ready,[k,1,{},{W:k,ha:v}]);
                }
                # the osc that knows about this C
                Readyy&s = s;
            }
            $Ready = Rs&Ready;
            
            $c = {};
            c.closish = Rc&brackuiet && !Rc&brackope;
            me&opeuni,g,Ready,Lives,c;
            
            if (gs&ope) {
                me&nu,'Conste',{Ready,Lives}
            }
            
            # back to Conal
            $l = sy&l;
            $r = ly&R;
            $la = ry&ha;
            la({Ready})
        },'ift,D'],

  // Conal 31
        # the pile of codes moving towards That/**$t
        # before
        #  leaf nodes read Know/**$t, write That/**$t
        #  others (can only mix) from and to That/**$t
        ['ball+Conal','31',&acgtRs{
            $sa = Ry&sa; # last waigh
            $ha = Ry&ha; # wai-in aha()()
            $da = Ry&da; # differ last waigh <-> now waigh
            
            # < make these work a bit more varsier
            # Know/**$t
            # 
            $inf = me&supry,s,'yf','yl';
            inf and sy&inf = inf; ha({inf})
            
            # That/**$t, if found...
            # That, beyond steps of compilationisms from Comal
            $L = me.cbu(R,'Ying').sc.Lastly;
            L = Ly&R;
            # get sy&fin = That..s
            #  s's mirror in the final A
            # gets sy&ouf to where it will be wanted
            me&supwyth,R,s,'fin',{theys:'l',top:L};
            
            
            $ouf = me&supry,s,'yf','yfin';
            ouf and sy&ouf = ouf; ha({ouf})
            # which one...
            #  later tries to include non-leaf src W 
            #   to check it doesn't have grounds...
            #   < may not exist back there,
            #      since Comal grew it
            # < should be able to have grounds,
            #   yet doing this all with J/ping action
            #   rather than mixing compileds would be better
            $leaf = ! me&ioty,sy&l,[''] .length;
            leaf and sy&leaf = 1;
            sy&f = leaf && inf || ouf || inf;
            
            
            ss&coung ||= 0;
            $le = ss&coung++;
        },'ift,D'],

  // Conal 32
        ['ball+Conal','32',&acgtRs{
            T.Mw = 'Conal';
            $sa = Ry&sa;
            $ha = Ry&ha;
            $da = Ry&da;
            !sa and return me&waits,'no-sa'
            me&reaw,R,'Conal';
            
            # f ~ref is ok, Comal checks ~Live
            # < test:
            #  to redo work that may depend on it
            #  eg delete rows with dep:yf
            # < wrap ha() with row template
            #   to add such a dependency to each thence
            
            # L=That
            $L = me.cbu(R,'Ying').sc.Lastly;
            L = Ly&R;
            # non-leaf && non-existent That..G
            !sy&leaf && !sy&ouf and ha('mot:no-ouf')
            # fs&changey at either That/Know
            $yf = ['inf','ouf'];
            each ik yf {
                $f = s.y [k];
                !f and continue
                fs&changey and ha('mot:cha,yf:'+k+',f',f)
            }
            # any mot-ivation
            if (Rs&wou && haks(Rs&wou)
                .filter(t=>t.includes('mot'))
                .length) {
                # excites ups
                $mot = {mot:'char'};
                
                # defers ups until Updated
                #  may be not That/$t-changey by their turn
                !ss&Updated and mot.fro = s
                
                # aplup helps ha to a different node
                me.aplup(s,&ha,{ ha(mot) });
            }
            
            # ^ goes around, now fro would be:
            $ready = !sy&leaf && sa('mot') && !sa('fro');
            
            $g = me&opeology,"Conal",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"putready?"
                res&ope and ready = 1
                
                $zu = me&opeKm,g,"zu"
                if (zus&ope) {
                    me&zu,"Comal",s
                }
                
            }
            !sy&leaf && sy&f != sy&ouf and me&mtsc,g,'!oufyet'
            
            #return;
            if (ready) {
                # %SupplyChai finds this, makes into %Conste
                ha('ready');
                Rs&suprise_c = {dl:1};
            }
            
  // Conal-ing
            # %Comste returns Ready=[C9 with y&s]
            $Ready = sa('Ready',1);
            if (Ready) {
                # find it into That..G
                each in Ready {
                    # W:Something, s)%Comste:
                    $z = ny&s;
                    !isC(z) and throw "no ys"
                    # hop back to s)%Comal:
                    $lz = zy&l;
                    sy&top.y.N.indexOf(lz) < 0 and throw "Nofind zyl",z
                    lz != s and throw "lz nots"
                    
                    # make skinny tree to it, s)%Conal +
                    $stack = me.cby(lz,sy&top);
                    stack[0] != sy&top and throw "stack weird", stack
                    
                    # not suprise
                    $tr = L;
                    each im stack {
                        $r = me&input,tr,m.t;
                        $rs = rc&s;
                        rsy&R = r;
                        my&fin = rs;
                        rsy&l = m; # should persis/compete
                        rs&Thinting = 1;
                        ac(r,'trouble',"Conste-pushish");
                        tr = r;
                    }
                    rs.t != s.t and throw "not our name?",s,'->',r
                    
                    # send ourselves
                    ha('Wup',n);
                    #me&nu,"Readzy",r
                    #me&nu,"fropmtop",stack;
                }
                
  // Conal-oung - Wunifyst
                # meanwhile, generate the upload and await push:
                $Wup = sa('Wup',1);
                if (Wup) {
                Wup.length > 1 and me&tsc,"manyWups"
                each in Wup {
                    # having G/**s:
                    $ts = sy&fin;
                    $t = tsy&R;
                    $f = tsy&f;
                    me&RedialyPaving,R,t,'fin' and continue
                    
                    # %Comste %Ready -> encoding %Lines .1+5
                    # < cache it with all this sense
                    $st = me&Wunifyst,R,s,n,'clonn';
                    
                    # mark as being in That
                    fs&Wupular = 1
                    
                    # grapple each %Pave
                    $origin = sy&inf;
                    $dest = sy&f;
                    
                    $se = gy&can('m','Diffs');
                    ses&dis = 1;
                    $od = sey&can('m','origin/dest');
                    $vis = ody&ope ? origin : dest;
                    
                    $tw = {};
                    each t,Pave dests&Zaving {
                        $Q = Paves&Q;
                        $De = st;
                        t != 'W' and window.tee = t;
                        if (t == "W\.5") {
                            !sty&fivestring and throw "!5string"
                            De = Cye([Q.t,1,{},{string:sty&fivestring}]);
                        }
                        Dey&Pave = Pave;
                        tw[t] = De;
                    }
                    
                    each t,Pave viss&Zaving {
                        $Q = Paves&Q;
                        $De = st;
                        if (t == "W\.5") {
                            !sty&fivestring and throw "!5string"
                            De = Cye([Q.t,1,{},{string:sty&fivestring}]);
                        }
                        
                        # < attention upgrades to JRom
                        $pa = sey&can('m',t);
                        pas&dis = 1;
                        pas&mah = 30;
                        Qc&el == 9 and me&mtsc,pa,'New!'; continue
                        !pas&ope and continue
                        
                        $c = {t:t,Zif:1};
                        c.got = De;
                        c.exp = Q;
                        $di = me&Ret,R,c;
                        me&zN,di;
                        me&Ring,di,{und:di,ov:314};
                        me&zuct,pa,di;
                        each in dis&waits {
                            ac(R,'waits',n)
                        }
                        Rs&summary = dis&summary;
                    };
                    
                    # put it on disk
                    $go = me&rolltog,R,{maydo:'Push',once:1,tsc:'B'},0;
                    go ||= sa({Pushable:sts&dige});
                    if (go) {
                        if (!me&rollbs,R,'sent_string' ) {
                            # Q asks
                            each t,De tw {
                                $Pave = Dey&Pave;
                                ~>3 push: R.t
                                Paves&commitstring(Des&string);
                            }
                            Rs&sent_string = 1;
                        }
                        $Q = dests&Q;
                        if (Qs&string == sts&string) {
                            me&tsc,'pushed';
                            # it cancels the go
                            go = 0
                            # and the grypes
                            delete ges&grypes;
                            # and the changey
                            delete fs&changey;
                            ss&Updated = 1;
                            
                        }
                        else {
                            $pu = me&tsc,'pushing'
                            me.nto(R,pu,&{ 
                                ~>3 repush: R.t
                                delete Rs&sent_string })
                        }
                    }
                    go and ha({Pushable:sts&dige})
                    
  // Comalor or when found == + Know cha
                    if (ss&Updated) {
                        if (s == sy&top) {
                            # < all deleted when the top is Updated
                            me&mtsc,g,'Alldone!',0,'p';
                            me&SC_fcommit,R,s;
                        }
                        else {
                            $p = sy&up;
                            $pr = py&R;
                            $pa = pry&ha;
                            pa('mot:upd,supr',s);
                            ha('Updated')
                            
                            $re = me&opeKm,g,"Up?"
                            res&ope and fs&commiting = 1
                            
                            zu && zus&ope and me&nu,"p",pr
                            

                        }
                    }
                }
                }
            }
            
            ss&count ||= 0;
            $le = ss&count++;
        },'ift,D'],
        ['ball+Thinting','63',&acgtRs{
            sy&R = R;
            
        },'ift,D'],
    &{
    # commit sy&N's f, making Cupload in %ting
    # < me&waits into wai as well,
    #  < modopting into brackdown
    #    as a thumbnail, over the specifics
    #    which could go on joined by ark:waits
    me.SC_fcommit = &acgtRs{
        $fs = [];
        each in sy&N {
            ny&inf and fs.push(ny&inf)
            ny&ouf and fs.push(ny&ouf)
        }
        $waifs = [];
        each if fs {
            fs&commiting ||= 1
            fs&commiting <3 and waifs.push(f)
        }
        if (waifs.length) {
            if (fs.length > waifs.length)
                me&nu,'stillf-commiting',waifs
            return me&waits,"G-commits"
        }
        $c = {maydo:'MindSave',once:1,tsc:'B'};
        $go = me&rolltog,R,c,0;
        !go and return

        $mi = me.cbu(R,'SupplyChai');
        !mi and throw "No ^^%SupplyChai"
        $mg = me.cbu(R,'Gens');
        !mg and throw "No ^^%SupplyChai^^%Gens"

        each in sy&N {
            delete ns&Updated
        }
        # turn off %MindInto
        me&introqua,mi,{play:0};
        # push/diff
        me&introqua,mg,{boost:1};
        me&tsc,"leaving"
    };
    },
]};
