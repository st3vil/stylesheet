# Flanges!!

me.SCones = &acgt{ return [
    # vast oldness, Peace
    ... me&ruv ,
    # W etc relatives
    ... me&Sch_Comm ,
    ... me&Sch_Pavings ,
    ... me&Sch_Constel ,
    ... me&Sch_ema ,
]};

=pod reintroduce MindInto
 GONE are %ting, %tracting, %Gracto, %folder
 
 Know/*%Pave gently, a %Zave that doesnt expect here
 
  me&bal fills R%Ying/$step%ball%etc from the schema
    or %ball%eph for floating steps, not in Rc&s
 %Ying
  < s&J see 'resolve through JRom'
    Ying gets to Rom:$p many times,
      since %elvoids back into $p may happen now
      < depending on the attention span of A:planet
        which should only spend 1/3 of its time
        in ~200ms bursts, to keep interactive
      < not looping
    not different enough to Ying sleeping the non-elvised
    would be nice for slomo elvising,
     getting the controls on an A
 
 %KnowThee (the schema)
  is eventually a pin, full of S-teps
   which %Peace manages dispatch to
  s/$u/:u/, for highlighting
   
  S not
  # never got to, yet S may be defined:
  S o Know/**$u o Ghost/$n/$u o Run/**$n
  #  would create a %twin on a Ghost,
  #  where the u converts to of/t when $u comes along,
  #   all the way from $W:
  S i To/$W o Run/**$n
  #  $W are down/up from Run, push/pull:
  push may:input $W=C? maybe extra $u as well...
  pull:
    $u towards $n...Ghost...Know
    $W itself,
     may CB_load Lines dige, pass test
     it might have the rolling Wy&A:n situation
      of a $W in A.4
    $W.*,
     lv, code, etc.
   all that might be drawn out,
    dige checked for lazy downloading tests
  
  S 3
  S o Run/**$n%%acty:3
  # means any $n %%may,acty:3
  #  o ...%%acty known to auto %%may,acty
  
  # when n%%acty,may (engages):
  #  engage any %%may,acty<=3 on $n
  #   as in switching everything on
  #  engage $n's relations in Know, Ghost, To
  #   to acty:2?
  #   will upgrade if eg Know/** source needs reading
  #  the link to To, etc, producing %%may:input
  
  # all before iterating the $n here,
  #  before it transmits to To
  
  # maybe the step numbers auto %%acty clause
  S 6
  S i To/$W o Run/**$n
  me&Yong,$W,'To',...
  # clarifies how to input to To,
  #  makes it require %%acty=6,
  #  starts the simulation there,
  #  which should get init with some attention,
  #  and travelly situata
  # and we're near the terminal again...
  S 67
  while waiting for To, at regular intervals
  S 7
  accept, pull
  hoisting $u back to ...
  producing channels of matter from these points
  eg $u, $ch, 
  
  < %%acty row not ending in may$
    should engage the may,
    as long as its not ^may
  
  may,be,{},acty:3
    brack may click on,
     introducing %%acty:3,may to ja
  may,acty,acty:3,{}
   the may:acty method an open-pressure interpreter
    reading %%acty-ish from around,
    auto engaging up to 3 if any cause (inc click on)
  
  < io: optimise for Knowy&tw[u.t], %%tw
  < io: pipelines, listen for new Run/**
  
%Paving ############
  inheriting %Pave-ish sc, like %Pave
  < deduce impliables at &adhere or &CB_load
  receiving %Live-ish sc from %Pave
  them all,
  < gathers itself, finds j%trouble, makes %openey
    trouble got means ->Ghost->Travel->To and back
  < &settle
 %Pave net connect a thing
  inheriting %Pave-ish sc
    Know%directory=else/ward:
     Know/**$t are else/ward/$t
    < That%directory=ForThe/That implied by That%J
     < $t%director implies $t/**%directory += $t
  < producing %Live-ish sc (to %Paving)
 
  %Search for %species (is in the $t)
   < local %Search host,
  < _ting c&ready -> Qup the first time !?
    < comeback to %waits etc
  
 %Ying
   < logs/maps/rules elvising going in
    < so $r can be paused
  adhere generally
  < %Pavings want attending into Travel
    defaulting to mixing the W I as per %J
  < elvis itself the steps wanting to wake up
    start that paused, lets travel loose
  < code folder, fix Zif diff squish
 %twmt
   recycle tw ha
 %twin
  might be the pairing of musictime and imagespace,
   to get alignment and interactivity in the show
  < nodeo %%may and %%waits
  
  < To
   %Search
    who implements the index where of=* mix into definition
  < make .5 ghost from @Search, into .5/of/t%dige
    < dupish so two different %directory things etc,
    then %twin uses those .5/.../* sc being linked
      being linked because:
        .5 becomes known (el=1)
        have Run something (el=2)
     or the s.sc already in the link
     to figure which Know/** we want
      %twmt has compiled {tw,s,candidates for Qc}
      %Pavings ein helps to:
       creating a type folder if dup with conflicting Qc
  
  < get KnowThee doing something
   brackdowns and noDisplay ing:
   
  < %Crun mapping Peace:5 etcs,
    anything interesting on them (SCA, waits)
     similar gear might org travels
      expecting+introgressing
    fishfood, pause, savepoints?
    being an elvis queue <-> machines of load

=cut

me.Sch_Comm = &acgt{ return [
  // the room
    ['Abodo',0.7,&acgtRs{
        delete s&bgi;
    },'ift,D'],
    ['Peace',0.7,&acgtRs{
        s&hue ||= 30;
    },'ift,D'],
    ['noisemaking',0.6,&acgtRs{
         aha(R,'wou')({tw:'figaro',vipa:3});
         Ry&ha({waitel:2,p:py&l});
         Ry&ha({dwitty:'vael',flat:'others',vap:2})
         Ry&ha({dwitty:'val',until:'seemingly'})
         # sa (waighre) asks
         $lo = Ry&sa('vap','dwitty,flat,until');
         me&nu,"vap3",lo
         
         # loop:
         $lo = Ry&sa('cow',1)[0] || 2;
         lo++
         Ry&ha({cow:lo});
         
         Ry&ha({dwitty:'vael',until:'seemingly',vap:3})
    },'ift,D'],
  // Glimpes Textl
    ['Glimpes',0.32,&acgtRs{
        me&reaw,R,'Yinghost,cm';
        me&tsc,'%Glimpessssssss',0,'G'
        $w = me&t,R,'ghost','Yingmas-light';
        !w and return me&waits,'t...'
        me&rollbs,R,'Yinghost';
        me&rolltog,R,{maydo:'reset-w'} and delete Rs&Yinghost;
        $z = Rs&Yinghost ||= Cye(w);
        zs&dige != ws&dige and z = Rs&Yinghost = Cye(w);
        
        
        me&Tie,R,'sayeth',1;
        if (Rs&sayeth != null) {
            zc&s = Rs&sayeth;
        }
        
        if (1) {
        $cm =
        n ste 1 $s:zc&s %e:2
        $cmsc = cms&cm_sc = {hoistcm:R};
        $cm = me&rollbs,R,'cm';
        !cm and me&waits,'cm...'
        }
        $lines = zc&s.split("\n");
        !zs&chunks || 1 and me&chunksoflines,z,lines
        
  // Glimpes folds
            
            
            $M = [];
            if (cm) {
                $marks = cm.getAllMarks();
                marks.filter(n => n.__isreFold).map(&n{
                    n.clear();
                });
                M = marks.filter(n => n.__isFold).map(&n{
                    # TextMarker
                    $pos = n.find();
                    return Cye(['fold',1,{},{mark:n,
                        line: pos.from.line,
                        toline: pos.to.line}])
                });
            }
            # < open fold markers too, leave open
            #   when aging/inserting folds,
            #     open those the cursor/diff is mostly in
            $ope = {};
            each if M {
                ope[fs&line] = f
            }
            # our chunks match|make a fold !!!!
            each is zs&chunks {
                $f = ope[ss&line];
                f and fy&chunk = s 
                elsif (ss&proper) {
                    $folds = cmsc.foldCode ||= [];
                    folds.push(CodeMirror.Pos(ss&line,0));
                }
            }
            
            #return
            each if ope {
                $ch = fy&chunk;
                ch && chs&indent > 6 and continue
                $m = fs&mark;
                $pos = m.find();
                $loc = lines[fs&line];
                me&cm_mark_refoldable,m,cm;
                
                $g = me&tsc,"fold-on:"+fs&line,0,1
                !ch and me&mtsc,g,"surprise",0,'y'
                else {
                    me&mtsc,g,"loc",0,'y' .c.s = lines[fs&line]
                }
            }
        
        
        # splitting line objects into many overlapping chunk objects
        # folding until <100 lines
        # give cm foldmarkers
    },'ift,D'],
   
  // Travelty
    ['Travels',0.39,&acgtRs{
        # < wants to cautiously inode while adhere-ing,
        #   to see if we set up:
        Rs&twmt_only = &jz{
            return zs&W || 1
        };
        R&ha,"Travels,to:Morrocco";
        R&ha,"Travels,to:everywhere",{R};
        #!R&za,'fodder' ? R&ha,'fodder,lamp' : R&ha,'lamp'
        
        R&ha,"Travels,to:everywhere",{R};
        $le = R&zaa,"Travels",'to';
        
        $p = sy&p;
        me&nu,sy&N;
        $pat = ss&pat ||= 'ology';
        me&nodei,R,py&r,{pat};
        R&jaa,{efrom:py&r.y.s,raga:1} .map(&n{
            le.push(ns&raga)
        })
        
        each in le {
            n = me&tsc,"land",n,'G';
            ns&dis = 1;
            ns&fs = 33;
            
            ns&hue = i*40;
            ns&blr = 9;
        }
        # < switch on and off with %%may:
        #me&waits,"forMOre"
        #throw "as"
    },'ift,D'],
    
    ['Duolish',0.303,&acgtRs{
        R&jaa,"efrom,pat" .map(&n{
            $q = {};
            q.raga = ns&pat.split('').join('_');
            me&nodei,R,ns&efrom,q
        })
    },'ift,D'],
]};
  // Textl
   // cm side
    # an open fold having close buttons at each end
    me.cm_mark_refoldable = &acgtm,cm{
        $refoldable;
        refoldable = &m{
            m._handlers and delete m._handlers.clear;
            m.on('clear',&from,to{
                $N;
                $foldagain = &{
                    $pos = N[0].find();
                    N.map(n => n.clear())
                    !pos and return
                    ~>3 foldat: pos.line
                    $fo = cm.foldCode(pos);
                    !fo and return ~>5 lost fold:
                    refoldable(fo);
                };
                N = [from,to].map(&l{
                    $sym = l == from ? "\u21A6" : "\u21A4";
                    $widget = $('<n>'+sym+'</n>')
                        .on('click',foldagain)
                        .css('float','right')
                        # < clickable large floaty things...
                        #.css('font-size','280%')
                        .css('color','#7c9')[0];
                    $lop = cm.setBookmark(l,{widget});
                    lop.__isreFold = 1;
                    return lop;
                });
            })
        };
        refoldable(m);
    }
   // lines side
    # s/$c**, also s%chunks = [c in reverse (depth first)]
    me.chunksoflines = &acgts,lines{
        # starting from s = the whole document
        $chu = s; # Cye(['flod',1]);
        chus&line = 0;
        chus&toline = lines.length-1;
        # i $s/$c each divisible chunk
        $N = me&indo,chu,{dl:15} (&sd{
            ss&toline-ss&line < 20 and return s

            me&chunkchunksoflines,s,lines;
            !ss&z and throw "nochunks"

            s == chu && ss&z.length == 1 &&
                ss&z.map(z => me&fiu,s,z,9 )
            return s
        });
        # assign their substrings 
        N.map(&s{
            sc&s = lines.slice(ss&line,ss&toline+1).join("\n");
            ss&lines = 1+ss&toline-ss&line;
        });
        $rev = N.slice().reverse();
        # size supposing s/*%folded
        rev.filter(s => ss&proper).map(&s{
            ss&size = ss&lines;
            ss&z .filter(c => cs&proper).map(&c{
                ss&size -= cs&lines-1;
            });
        })
        ss&chunks = rev;

        if (1) {
            # a map, could ...
            $dive;
            me&indo,chu,{dl:15} (&sd{
                !d.dive and dive = d.dive = Cye(s); dive.t = 'dive'
                else {
                    d.dive = me&fiu,d.dive,Cye(s)
                }
            })

            #me&nu,"Dived",dive||"NOT";
            dive &&
            n zoap  $s:dive,R %ball,tightly,noDescribe,chunksia,reneg
        }
    }
    # i $s/$chunk+
    #  relating s%(to)lines -> lines
    me.chunkchunksoflines = &acgts,lines{
        $chunk = &sil{
            $c = Cye(['chunk@'+i,1]);
            cs&line = l;
            me&fiu,s,c;
            return c
        }
        $c = null;
        $i = 0;
        $li = ss&line || 0;
        $laindent = ss&indent || 0;
        $ltoindent = {};
        while (lines[li+i] != null) {
            $l = lines[li+i];
            $indent = ltoindent[li+i] ||= l.match(/^(\s*)(.*)$/);
            $stuff = indent[2];
            indent = indent[1].length;
            $p = c;

            # level this chunk is based at
            $cind = c && cs&indent || 0;
            # remaining at s's indent is not c-worthy
            !c && ss&line && indent == ss&indent and i++; continue
            else
            !c and c = chunk(s,i,li+i)
            else
            !i and throw "i=0"
            else
            !stuff || stuff[0] == '#' && indent == cind and 'grows'
            else
            # (1,2),(1) or (2,3),(1)
            if (cind == indent && indent < laindent
                || cind > indent) {
                c = chunk(s,i,li+i)
            }
            else
            # (1,1),(2) -> (1),(1,2)
            if (cind < indent && laindent <= cind
                && ps&toline - ps&line > 0) {
                c = chunk(s,i,li+i);
                cs&indent = laindent;
                ps&toline--; cs&line--
            }
            else
            # chunks with something further inside will cm.doFold
            #  unless they're /^#/, no prob
            # ie only the (1,2) of (1,1,1),(1,2)
            indent > cind and cs&proper = 1

            if (cs&indent == null) {
                cs&indent = indent
            }
            cs&toline = li+i;
            cs&toline >= ss&toline and break
            laindent = indent;
            i++;
        }
    }

me.Sch_Constel = &acgt{ return [
    # hierarchise, do batches of updates 
    # < more than W I mixes
    # < plots intention to travel
    # R%Conal waits for Know|That/...r%Pave+=%fully
    # < set %creatine
  &{
    # permanent act of setting some properties
    #  returns true if unlikely to have taken effect
    # < replace with send-receive ack
    me.Redialsc = &acgtRrc{
        $k = !c ? '' : haks(c).join(',');
        k = 'Redialy'+(k?'-'+k:'');
        $sa = Ry&sa;
        $ha = Ry&ha;
        # is all there or 404
        $fok = r && (rs&Paving_goodin || rs&creatine);
        !fok and return me&waits,'!fok'
        if (sa(k)) {
            haks(c).map(k=>r.sc[k] != c[k]) and throw "undialed"
            ha(k)
        }
        else {
            ex(r.sc,c)
            ha(k)
            return 1
        }
    };
  },
  // Conste 3{
      # code vectoring along C between G
        ['ball+Conste','31',&acgtRs{
            $l = sy&l;
            sy&f = ly&f;
            # if top, have + ignore src f
            #  see unifiers may have ground
            sy&top == s and sy&f = ly&inf
            else {
                # non-top, must use ouf if non-leaf
                sy&f = ly&leaf ? ly&inf : ly&ouf
            }
        },'ift,D'],
        ['ball+Conste','32',&acgtRs{
            T.Mw = 'Conste';
            $sa = Ry&sa; # last waigh
            $ha = Ry&ha; # wai-in aha()()
            $da = Ry&da; # differ last waigh <-> now waigh
            # from in or out?
            $f = sy&f;
            $Q = fs&Q;
            !Q || !Qs&ready and return me&waits,'!Q'
            me&Redialsc,R,f,{fully:1} and return
            Qc&species == 5 and return me&waits,'Q5'
            
             
  // Conste-ing{
            # only top %Conste compiles
            sy&top != s and return
            
            # o **!%redialy
            #  very in future
            $N = sy&N.map(s => sy&R).filter(&j{
                return !jy&sa('Redialy')
            });
            N.length and return ha('waits:them-redialy')
            
            # check out n
            $cha = [];
            $Lives = [];
            each in sy&N {
                $j = ny&R;
                $f = ny&f;
                !f and return me&waits,n.t+"-!f"
                !fs&Live and return me&waits,n.t+"-!f%Live"
                # fs&Live stills
                $was = me&rollbs,j,'Live';
                fs&Live != was and cha.push(cha)
                js&Live = fs&Live;
                # < copy into This/$t/{origin,comp} meanwhile
                #   to externalise to perl to jsbabz it
                #   to apply hacks in waves to it, so differ
                #   to allow processing over many lives
                #    syncing Know/* to resume/complete
                
                # see how the things should mix before hacking?
                #   to reduce the load to:
                # hacking each W as per ...
                # draw attention to hacks on the inside
        
                # any fy&Gc&s.sc.* unknown may be instructions
                # fy&W may have access to:
                # < Search%Mix.W low level tv mixage
                #   should mix %ting=js|W
                #     Ws&I/$of/$C as $W/$of/$C
                #   would be where I needs bootstrapping
                #    from a dozen few-thousand line /js/
                #     to a few dozen thousand line /W/
                #      with some Babzing before it I's too
                #      so we have a bunch of ghost to show for it
                
                # < look in Hacks/$t for compile tricks
            }
            $Lives = me&ioty,R,'Conste'
                .map(j => js&Live);
            Lives.filter(L=>!L).length and return ha('waits:them-Live')
            
            me&rollbs,R,'Ready';
            cha.length and delete Rs&Ready
            
            # this mix in the source
            $D = Rs&Live;
            # < don't need it to be there
            !D and return me&waits,"!live"

            $g = me&opeology,"%Ready",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"redo?"
                res&ope and delete Rs&Ready
            }
            
            if (!Rs&Ready) {
                $Ready = Rs&Ready = me&unifydin,D,Lives;
                !Ready and return me&waits,"unifydin.."
                # we can/should attach s&W from Wind
                $Wi = Readyy&Wind || {};
                each kv Wi {
                    fio(Ready,[k,1,{},{W:k,ha:v}]);
                }
                # the osc that knows about this C
                Readyy&s = s;
            }
            $Ready = Rs&Ready;
            
            $c = {};
            c.closish = Rc&brackuiet && !Rc&brackope;
            me&opeuni,g,Ready,Lives,c;
            
            if (gs&ope) {
                me&nu,'Conste',{Ready,Lives}
            }
            
            # back to Conal
            $l = sy&l;
            $r = ly&R;
            $la = ry&ha;
            la({Ready})
        },'ift,D'],

  // Conal 31
        # the pile of codes moving towards That/**$t
        # before
        #  leaf nodes read Know/**$t, write That/**$t
        #  others (can only mix) from and to That/**$t
        ['ball+Conal','31',&acgtRs{
            $sa = Ry&sa; # last waigh
            $ha = Ry&ha; # wai-in aha()()
            $da = Ry&da; # differ last waigh <-> now waigh
            
            # < make these work a bit more varsier
            # Know/**$t
            # 
            $inf = me&supry,s,'yf','yl';
            inf and sy&inf = inf; ha({inf})
            
            # That/**$t, if found...
            # That, beyond steps of compilationisms from Comal
            $L = me.cbu(R,'Ying').sc.Lastly;
            L = Ly&R;
            # get sy&fin = That..s
            #  s's mirror in the final A
            # gets sy&ouf to where it will be wanted
            me&supwyth,R,s,'fin',{theys:'l',top:L};
            
            
            $ouf = me&supry,s,'yf','yfin';
            ouf and sy&ouf = ouf; ha({ouf})
            # which one...
            #  later tries to include non-leaf src W 
            #   to check it doesn't have grounds...
            #   < may not exist back there,
            #      since Comal grew it
            # < should be able to have grounds,
            #   yet doing this all with J/ping action
            #   rather than mixing compileds would be better
            $leaf = ! me&ioty,sy&l,[''] .length;
            leaf and sy&leaf = 1;
            sy&f = leaf && inf || ouf || inf;
            
            
            ss&coung ||= 0;
            $le = ss&coung++;
        },'ift,D'],

  // Conal 32
        ['ball+Conal','32',&acgtRs{
            T.Mw = 'Conal';
            $sa = Ry&sa;
            $ha = Ry&ha;
            $da = Ry&da;
            !sa and return me&waits,'no-sa'
            me&reaw,R,'Conal';
            
            # f ~ref is ok, Comal checks ~Live
            # < test:
            #  to redo work that may depend on it
            #  eg delete rows with dep:yf
            # < wrap ha() with row template
            #   to add such a dependency to each thence
            
            # L=That
            $L = me.cbu(R,'Ying').sc.Lastly;
            L = Ly&R;
            # non-leaf && non-existent That..G
            !sy&leaf && !sy&ouf and ha('mot:no-ouf')
            # fs&changey at either That/Know
            $yf = ['inf','ouf'];
            each ik yf {
                $f = s.y [k];
                !f and continue
                fs&changey and ha('mot:cha,yf:'+k+',f',f)
            }
            # any mot-ivation
            if (Rs&wou && haks(Rs&wou)
                .filter(t=>t.includes('mot'))
                .length) {
                # excites ups
                $mot = {mot:'char'};
                
                # defers ups until Updated
                #  may be not That/$t-changey by their turn
                !ss&Updated and mot.fro = s
                
                # aplup helps ha to a different node
                me.aplup(s,&ha,{ ha(mot) });
            }
            
            # ^ goes around, now fro would be:
            $ready = !sy&leaf && sa('mot') && !sa('fro');
            
            $g = me&opeology,"Conal",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"putready?"
                res&ope and ready = 1
                
                $zu = me&opeKm,g,"zu"
                if (zus&ope) {
                    me&zu,"Comal",s
                }
                
            }
            !sy&leaf && sy&f != sy&ouf and me&mtsc,g,'!oufyet'
            
            #return;
            if (ready) {
                # %SupplyChai finds this, makes into %Conste
                ha('ready');
                Rs&suprise_c = {dl:1};
            }
            
  // Conal-ing
            # %Comste returns Ready=[C9 with y&s]
            $Ready = sa('Ready',1);
            if (Ready) {
                # find it into That..G
                each in Ready {
                    # W:Something, s)%Comste:
                    $z = ny&s;
                    !isC(z) and throw "no ys"
                    # hop back to s)%Comal:
                    $lz = zy&l;
                    sy&top.y.N.indexOf(lz) < 0 and throw "Nofind zyl",z
                    lz != s and throw "lz nots"
                    
                    # make skinny tree to it, s)%Conal +
                    $stack = me.cby(lz,sy&top);
                    stack[0] != sy&top and throw "stack weird", stack
                    
                    # not suprise
                    $tr = L;
                    each im stack {
                        $r = me&input,tr,m.t;
                        $rs = rc&s;
                        rsy&R = r;
                        my&fin = rs;
                        rsy&l = m; # should persis/compete
                        rs&Thinting = 1;
                        ac(r,'trouble',"Conste-pushish");
                        tr = r;
                    }
                    rs.t != s.t and throw "not our name?",s,'->',r
                    
                    # send ourselves
                    ha('Wup',n);
                    #me&nu,"Readzy",r
                    #me&nu,"fropmtop",stack;
                }
                
  // Conal-oung - Wunifyst
                # meanwhile, generate the upload and await push:
                $Wup = sa('Wup',1);
                if (Wup) {
                Wup.length > 1 and me&tsc,"manyWups"
                each in Wup {
                    # having G/**s:
                    $ts = sy&fin;
                    $t = tsy&R;
                    $f = tsy&f;
                    me&Redialsc,R,t,{fully:1} and continue
                    
                    # %Comste %Ready -> encoding %Lines .1+5
                    # < cache it with all this sense
                    $st = me&Wunifyst,R,s,n,'clonn';
                    
                    # mark as being in That
                    fs&Wupular = 1
                    
                    # grapple each %Pave
                    $origin = sy&inf;
                    $dest = sy&f;
                    
                    $se = gy&can('m','Diffs');
                    ses&dis = 1;
                    $od = sey&can('m','origin/dest');
                    $vis = ody&ope ? origin : dest;
                    
                    $tw = {};
                    each t,Pave dests&Zaving {
                        $Q = Paves&Q;
                        $De = st;
                        t != 'W' and window.tee = t;
                        if (t == "W\.5") {
                            !sty&fivestring and throw "!5string"
                            De = Cye([Q.t,1,{},{string:sty&fivestring}]);
                        }
                        Dey&Pave = Pave;
                        tw[t] = De;
                    }
                    
                    each t,Pave viss&Zaving {
                        $Q = Paves&Q;
                        $De = st;
                        if (t == "W\.5") {
                            !sty&fivestring and throw "!5string"
                            De = Cye([Q.t,1,{},{string:sty&fivestring}]);
                        }
                        
                        # < attention upgrades to JRom
                        $pa = sey&can('m',t);
                        pas&dis = 1;
                        pas&mah = 30;
                        Qc&el == 9 and me&mtsc,pa,'New!'; continue
                        !pas&ope and continue
                        
                        $c = {t:t,Zif:1};
                        c.got = De;
                        c.exp = Q;
                        $di = me&Ret,R,c;
                        me&zN,di;
                        me&Ring,di,{und:di,ov:314};
                        me&zuct,pa,di;
                        each in dis&waits {
                            ac(R,'waits',n)
                        }
                        Rs&summary = dis&summary;
                    };
                    
                    # put it on disk
                    $go = me&rolltog,R,{maydo:'Push',once:1,tsc:'B'},0;
                    go ||= sa({Pushable:sts&dige});
                    if (go) {
                        if (!me&rollbs,R,'sent_string' ) {
                            # Q asks
                            each t,De tw {
                                $Pave = Dey&Pave;
                                ~>3 push: R.t
                                Paves&commitstring(Des&string);
                            }
                            Rs&sent_string = 1;
                        }
                        $Q = dests&Q;
                        if (Qs&string == sts&string) {
                            me&tsc,'pushed';
                            # it cancels the go
                            go = 0
                            # and the grypes
                            delete ges&grypes;
                            # and the changey
                            delete fs&changey;
                            ss&Updated = 1;
                            
                        }
                        else {
                            $pu = me&tsc,'pushing'
                            me.nto(R,pu,&{ 
                                ~>3 repush: R.t
                                delete Rs&sent_string })
                        }
                    }
                    go and ha({Pushable:sts&dige})
                    
  // Comalor or when found == + Know cha
                    if (ss&Updated) {
                        if (s == sy&top) {
                            # < all deleted when the top is Updated
                            me&mtsc,g,'Alldone!',0,'p';
                            me&SC_fcommit,R,s;
                        }
                        else {
                            $p = sy&up;
                            $pr = py&R;
                            $pa = pry&ha;
                            pa('mot:upd,supr',s);
                            ha('Updated')
                            
                            $re = me&opeKm,g,"Up?"
                            res&ope and fs&commiting = 1
                            
                            zu && zus&ope and me&nu,"p",pr
                            

                        }
                    }
                }
                }
            }
            
            ss&count ||= 0;
            $le = ss&count++;
        },'ift,D'],
        ['ball+Thinting','63',&acgtRs{
            sy&R = R;
            
        },'ift,D'],
    &{
    # commit sy&N's f, making Cupload in %ting
    # < me&waits into wai as well,
    #  < modopting into brackdown
    #    as a thumbnail, over the specifics
    #    which could go on joined by ark:waits
    me.SC_fcommit = &acgtRs{
        $fs = [];
        each in sy&N {
            ny&inf and fs.push(ny&inf)
            ny&ouf and fs.push(ny&ouf)
        }
        $waifs = [];
        each if fs {
            fs&commiting ||= 1
            fs&commiting <3 and waifs.push(f)
        }
        if (waifs.length) {
            if (fs.length > waifs.length)
                me&nu,'stillf-commiting',waifs
            return me&waits,"G-commits"
        }
        $c = {maydo:'MindSave',once:1,tsc:'B'};
        $go = me&rolltog,R,c,0;
        !go and return

        $mi = me.cbu(R,'SupplyChai');
        !mi and throw "No ^^%SupplyChai"
        $mg = me.cbu(R,'Gens');
        !mg and throw "No ^^%SupplyChai^^%Gens"

        each in sy&N {
            delete ns&Updated
        }
        # turn off %MindInto
        me&introqua,mi,{play:0};
        # push/diff
        me&introqua,mg,{boost:1};
        me&tsc,"leaving"
    };
    },
]};
