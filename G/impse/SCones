# Flanges!

me.SConesing = &acgt{ return [
    ... me&SCones ,
    ... me&ruv ,
    
]};
me.SCnot = &acgt{ return [
    ['Abodo',0.7,&acgtRs{
        delete s&bgi;
    },'ift,D'],
  # Pavings 3:
    # < timing: after/inside ^%MindInto->%SupplyChai @305
    #    which should delay children while it sets up
    #   then Y:SupplyChai: Steps walk @6
    #     which Y:Steps: Gracto @3 Rings in
    ['Pavings',0.306,&acgtRs{
        me&tsc,'Pavings';
        return;
        # borrow %Paving params
        me&adherePaving,R,R;
        # to give on to %Paving
        me&inherePaving,R;
        
        $r = me&nu,'Pavings',R;
        me&Ring,R,{und:r,ov:0.58}
    },'ift,D'],
    &{
    # inhere
    me.inherePaving = &acgtR{
        me&ioty,R,'ball' .map(&r{
            rs&Paving = 1;
            me&adherePaving,R,r;
        })
    };
    # adhere eg r%dir = s%dir || R%dir
    me.adherePaving = &acgtRr{
        $s = Rc&s;
        $z = rc&s;
        ['directory'].map(&k{
            # each of any params that matter
            #  on s when not as inherited from R
            $is = hak(z.sc,k) ? z.sc[k] : R.sc[k];
            # and eg. %directory='' leaves
            is and r.sc[k] = is
        })
    };
    me.reaw = &acgtR,gks{
        $k = gks.split(',')[0];
        ah(R,'reawakens',k,{rollbs:gks});
    };
    },
    ['Paving',0.36,&acgtRs{
        $of = Rs&Paving;
        of == 1 and of = 'W'
        me&reaw,R,'Paving,directory';
        # see if there's a HEAD-type method for this Qc&of
        $M = [];
        if (of == 'W') {
            m W.5 2  %species:5
            Rs&fully &&
                m $of 1
        }
        else {
            m $of 1  
        }
        each in M {
            n.t = s.t+" Paves "+n.t;
            # Rs&* and rs&* -> Qc&*, Qc&of = %Pave
            ns&Pave ||= of;
            nc&R = 1;
            n $n
        }
    },'ift,D'],
    ['Pave','291',&acgtRs{
        $p = Ry&up;
        # %Paves collect
        # since Zaving@294, reuse foldy thing
        ah(p,'Zaving',Rs&Pave,R);
        # similar to %Zave,
        #  G&t,Q directly, no %Saveting
        #  no %Here
        #   until download+decode
        #   or a write is proposed
        #   or our cache (dige/versiona) could go there
        
        $Q = me&rollbsc,R,'Q';
        Q.t = s.t;
        Qc&of = 'W';
        Qc&async = &{};
        Qc&ready = &CP{};
        ['directory','species'].map(&k{
            $is = R.sc[k] || p.sc[k];
            is and Q.c[k] = is
            else { delete Q.c[k] }
        });
        
        # Q refinds P each G&t
        $w = me&t,R,Q;
        me&nu,Q.t,Q.c;
        
        # $w may wander off, usu clones into %Gens%self
        # < following P into the future (%Differ)
        !Qs&ready and return me&waits,'!ready','...'
        
        # then something posits string to follow:
        Rs&commitstring = &s{
            # < require they know parent==Ps&dige
            Rs&Committing = Qs&string = s;
            me&t,R,Q;
        };
        
        me&nu,"Q",Q
        #$r = me&nu,'Pavings',R;
        #me&Ring,R,{und:r,ov:0.58}
    },'ift,D'],
    
  # Paving 5
    ['Paving',0.5,&acgtRs{
        # waits for each Pave,
        #  draws clues together
    },'ift,D'],
    ['KnowThee','304',&acgtRs{
        $h = me&SChema,R,'KnowThee',{};
        n Know 1  %bri:0.7,Pavings
        n Compiling 3  %hue:70,supr:Comal
        n Seq 5  %hue:110,supr:Comste,Omplateau
        n That 7  %Pavings

        hy&domed()
    },'ift,D'],
]};