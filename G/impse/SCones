# Flanges!

me.SCones = &acgt{ return [
    # vast oldness, Peace
    ... me&ruv ,
    # W etc relatives
    ... me&Sch_Pavings ,
    ... me&Sch_ema ,
    
]};

=pod reintroduce MindInto
 GONE is %ting, %tracting
  That%Gracto makes:
   > That/tings%folder%eph for a W/G counterpartistry
   < That/**%Pave gently, a %Zave that doesnt expect here
     as if it was That/**%W
 < %Pave slow thing puller, spreads implying ting configuration:
  > Cloadsc writes stuff up/down
    < C able to deduce impliables
  < That%directory=ForThe/That will be implied by That%J
  Know/**%directory=else/ward are else/ward/$t
  <   $t%director childrens implied %directory += $t
  %Search for %species (is in the $t)
   < local %Search host
  
  me&bal fills in to/from the schema:
   steps adopt/make our R/*%balls
    or %ball%eph for floating steps, not in Rc&s
  < s&J see 'resolve through JRom'
    which SCA would get some extra controls on,
     doing many tiny Rings etc.
     needs a self-awareness module,
      combined with slomo elvising
      see 'cant always trust whatever these might be'


  < _ting c&ready -> Qup the first time !?
    < comeback to %waits etc
  SCA:
   < logs/maps/rules elvising going in
   < so $r can be paused
   < import
  < SCA

=cut

me.Sch_Pavings = &acgt{ return [
    ['Abodo',0.7,&acgtRs{
        delete s&bgi;
    },'ift,D'],
     ['Peace',0.7,&acgtRs{
         me&tsc,"PEace",0,'g'
         s&hue ||= 30;
     },'ift,D'],
    ['KnowThee','304',&acgtRs{
        $h = me&SChema,R,'KnowThee',{};
        n Know 1  %bri:0.7,Pavings
        n Compiling 3  %hue:70,supr:Comal
        n Seq 5  %hue:110,supr:Comste,Omplateau
        n That 7  %Pavings

        hy&domed()
    },'ift,D'],
// Paving 5{
    ['Paving',0.5,&acgtRs{
        # waits for each Pave,
        #  draws clues together
        $con = me&rolltog,R,{may:'Pave',tsc:'l',acty:8};
       // draw from clues
        $Q;
        each ir Rs&Zaving {
            rs&waits and me&waits,'...'
            Q = rs&Q;
        }
        Rs&waits and return
        
        # send r%trouble as late as you want to open it
        me&ollbs,R,'trouble' and Rs&openey = 1
        
        # roll/sleepatch inner processes
        me&rolls,'grype',{s:Q.t+"@"+Qs&dige}
            && me&rollbs,'changey';
        me&rollbs,'amCompiling';

        # looking at the answer
        # < sleep by Q&dige
        $Thing = Rs&Glean = me&lookaQ,Q;
        # sync ss&dige and Thing's dige (however it appears)
        #  and whatever other Things project knowledge around

        # key behaviours, to stare at problems for longer:
        # hold changes to s that it has already
        # < we don't need to compile simple connections?
        #   trusted sources etc
        # ! if grype causes f%changey but applies the change
        #   (liesnotok=1 not to)
        #   grype rolled forgets it made the change
        #   f%changey can be forgot if R%tracting is interrupted
        # don't apply change from the Thing until Compiling wants to
        Rs&liesnotok = 1;
        me&rollbs,'commiting' and Rs&liesnotok = 0; Rs&commiting++
        # hold waking Thing changes are projected into:
        # < without hiding the change
        #Rs&noprojcha = 1;

        # %ting attr were auto upload/download by A:f
        # < configure it here sometimes
        me&grype,R,'ting';

        # %dige-ish group - change makes fs&changey
        me&grype,R,'W',{w:Thing};

        # < particularly if it changes when we game look->get,
        #    would mean a 4 is not pointing to the 1 proper

        # %el etc
        $inc = me&grype,R,'inc';
        if (inc) {
            if (ss&el == 9) {
                Ds&bri = 0.6;
                me&mtsc,inc,'ig',0,'B'
                # < also ignored by the compiler
                Rs&ignore = 1;
                return
            }
            ss&el == 7 and me&mtsc,inc,'hmm',0,'B'
        }
        # children selected per scheme
        # eg not %ignore
        Rs&zget = &Ry{
            me&ioty,R,'Paving' .map(&r{
                rs&ignore and return
                y(r)
            })
        };
        
        # we must now become changey if:
        #   any of our W-type data changes
        #   child dige projection wrong
        Things&Wind and me&gromps,R,'Wind','t,dige',Things&Wind
        # tally  grypes and gromps (from above)
        Rs&tracting = R;
        me&grimp,R;
        delete Rs&tracting;

        if (con) {
            me&zu,'Thingstract',Thing
            Rs&changey and me&zu,'changey',Rs&changey;
            Rs&trouble and me&zu,"Rtrub",Rs&trouble;
            #me&zu,'Loadism',load
            Ds&fs = 15;
        }
        
        # various leads to %changey, %openey, %trouble
        if (Rs&changey) {
            # dige here or inside solving
            me&tsc,"R%changey","cha",'G';
            s&bgh = 111;
            # 2 them
            me&ioty,R,'ball'
                .map(n => ns&openey ||= 1)
        }
        Rs&trouble and me&tsc,'trouble','trou','G'

        Rs&Paving_good = 1;

        return;
        # < applying the sort-out-code scheme
        # wanting a decision on each one
        # (1 keep, 7 transfiguration, 9 death)
        if (!ss&el) {
            me&tsc,'('
            me&rolltog,R,'9',0 and ss&el = 9
            me&rolltog,R,'7',0 and ss&el = 7
            me&tsc,')'
        }
    },'ift,D'],
    &{
    # know about the Thing independent of the species
    me.lookaQ = &acgtQ{
        $s = Qc&s;
        !s and throw "Q!s"
        $Thing = Cye([s.t,1]);
        if (Qc&species == 5) {
            Things&dige = ss&ha;
            o $s/W/*:s
            each in ays&s {
                ah(Thing,'Wind',n.t,ns&ha)
            }
            # < some piles reway, others remix
            #   some are way leading to many
            o $s/w/*:s
            each in ays&s {
                ah(Thing,'wind',n.t,ns&dige)
            }
        }
        elsif (Qc&species == 1 || !Qc&species) {
            # < can do similar for .4
            # < pointings that adjust for its compression
            each in sy&N {
                ns&W && !ns&z &&
                    ah(Thing,'Wind',n.t,ns&ha)
            }
            $dige = Qs&dige;
            !dige and throw "nodige"
            # W:spot/* %ha are 9 (see AWriter), %dige are 12
            if (Q.t.indexOf('spot/') == 0 &&
                dige.length == 12) {
                dige = dige.substr(0,9)
            }
            Things&dige = dige;
        }
        return Thing
    }
    },
    # R%Paving_good waits for R/*%tracting_good, etc
    #  when we can rely on our children to complain,
    #  know if they're changey/trouble
    ['ball+Paving_good','52',&acgtRs{
        T.Mw = 'trac';
        $p = Ry&up;
        Rs&zget(R,&r{
            # into this pool of what we're looking for from who
            # < display their stuff up against them
            #   dividing the ball in two

            # completed 51
            !rs&Paving_good &&
                ah(R,'waitz','tw_scgk_r',r.t,'Paving_good',r);

            # completed 52
            #  which they haven't this future
            #  it should know changzo/simply/awake+ready,
            #   which would unset in 61 if net change
            !me&ollbs,r,'Paving_goodin' &&
                ah(R,'waitz','tw_scgk_r',r.t,'Paving_goodin',r);

        });

        # autothink:
        # sending %trouble should lead to %Paving_good
        $wa = {solvent: [{
            dscif: {scgk:'Paving_good'},
            arkfor: {r: {cb:&dr{
                ac(r,'trouble',R.t+" wants %Paving_good")
            }}}
        }], beready:1};

        # weakly supposing no signal means ok
        !me&waitzo,R,wa and return

        # children at least here
        #  Ring usu. children almost here
        Rs&Paving_goodin = 1;

        # modulat from the grype of late only
        if (Rs&changey) {
            $out = [];
            each in Rs&changey {
                !ny&R || Rc&N.indexOf(ny&R) >= 0 and continue
                ny&timingout ||= 0;
                ny&timingout++ > 2 and out.push(n)
            }
            Rs&changey = Rs&changey
                .filter(n => out.indexOf(n) < 0);
            !Rs&changey.length and delete Rs&changey
        }

        # which means all we need to compile is connected!
        if (!ps&Paving) {
            aha(p,'wou')({ready:1,tw:R.t,r:R});
        }
    },'ift,D'],

// Pavings 3{
    # < timing: after/inside ^%MindInto->%SupplyChai @305
    #    which should delay children while it sets up
    #   then Y:SupplyChai: Steps walk @6
    #     which Y:Steps: Gracto @3 Rings in
    ['Pavings',0.306,&acgtRs{
        me&tsc,'Pavings';
        me&reaw,R,'Pavings';
        #return;
        # borrow %Paving params
        me&adherePaving,R,R;
        # to give on to %Paving
        me&inherePaving,R;
        
        $r = me&nu,'Pavings',R;
        me&Ring,R,{und:r,ov:0.58}
    },'ift,D'],
    &{
        # inhere
        me.inherePaving = &acgtR{
            me&ioty,R,'ball' .map(&r{
                rs&Paving = 1;
                me&adherePaving,R,r;
            })
        };
        # adhere eg r%dir = s%dir || R%dir
        me.adherePaving = &acgtRr{
            $s = Rc&s;
            $z = rc&s;
            zs&directory and zs&directory = zs&directory.replace(/\/$/,'')
            ['directory'].map(&k{
                # each of any params that matter
                #  on s when not as inherited from R
                $is = hak(z.sc,k) ? z.sc[k] : R.sc[k];
                # and eg. %directory='' leaves
                is and r.sc[k] = is
            })
        };
    },
    # %Paving splits into species
    ['Paving',0.36,&acgtRs{
        $of = Rs&Paving;
        of == 1 and of = 'W'
        me&reaw,R,'Paving,directory';
        # see if there's a HEAD-type method for this Qc&of
        $M = [];
        if (of == 'W') {
            m W\.5 2  %species:5
            Rs&fully &&
                m $of 1
        }
        else {
            m $of 1  
        }
        each in M {
            n.t = s.t+" Paves "+n.t;
            # Rs&* and rs&* -> Qc&*, Qc&of = %Pave
            ns&Pave ||= of;
            nc&R = 1;
            n $n
        }
        # to give on to *%Paving
        me&inherePaving,R;
    },'ift,D'],
    
    # %Paves collect a species
    ['Pave','291',&acgtRs{
        $p = Ry&up;
        $s = pc&s;
        # since Zaving@294, reuse foldy thing
        ah(p,'Zaving',Rs&Pave,R);
        # similar to %Zave,
        #  G&t,Q directly, no %Saveting
        #  no %Here
        #   until download+decode
        #   or a write is proposed
        #   or our cache (dige/versiona) could go there
        
        $Q = me&rollbsc,R,'Q';
        Q.t = s.t;
        Qc&of = 'W';
        Qc&async = &{};
        Qc&ready = &CP{};
        ['directory','species'].map(&k{
            $is = R.sc[k] || p.sc[k];
            is and Q.c[k] = is
            else { delete Q.c[k] }
        });
        # compile to $t for Search
        Qc&directory and Q.t = Qc&directory+'/'+Q.t
        Qc&species and Q.t = Q.t+'/'+Qc&species
        # and for humans
        n of 101 $s:Qc&of %hs:348,fs:9
        Qc&directory &&
        n directory 102 $s:Qc&directory %fs:8,hs:194
        n t 11 $s:s.t %hs:348
        Qc&species &&
        n species 112 $s:Qc&species %fs:8,hs:157
        
        
        # Q refinds P each G&t
        $w = me&t,R,Q;
        # per most of this besides s, el + hooks
        #me&nu,Q.t,Q.c;
        
        !Qs&ready and return me&waits,'!ready','...'
        # $w may wander off, usu clones into %Gens%self
        # < following P into the future (%Differ)
        
        n el 13 $s:Qc&el %hs:348,fs:9
        
        me&rolltog,R,{maydo:'Q'} &&
            me&zu,'Q',Q;
        
        Qc&s && me&rolltog,R,{maydo:'s'} &&
            n s  $s:Qc&s %R:ball
        
        # have the thing, readyonly, copied from Pc&s
        # < Q can Qs&Want_Decode for itself
        Qc&s and Rc&s = Qc&s
        
        # then something posits string to follow:
        Rs&commitstring = &s{
            # < require they know parent==Ps&dige
            Rs&Committing = Qs&string = s;
            me&t,R,Q;
        };
        
    },'ift,D'],
    
]};
