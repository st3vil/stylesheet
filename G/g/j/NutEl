# be in
u j
n \'of:eye'
# process any event
#   into an A:n for the J/place as C:Wthing with c&e={act} A:n + A:e
#   quick respondo can be via ec&doi set from Y.b.eintro
gev: %acgt:ev J
    ev ||= event;
    ev.target.tagName == 'H2' and return
    # locate A:top of A:4
    if (!ev.target) {
        A&event_A and A = A&event_A;
    }
    else {
        $S = ev.target;
        while (S && !(S.A && S.A.4)) {
            S = S.parentNode;
        }
        # must be clicking <body>, <html>
        #   or something above .A element space
        !S and return
        $Four = S.A.4;
        A = Four.up;
        !A and throw "out of cone";
        A&event_A = A;
    }
    if (A&event_A) {
        A&event_A != A and ~innerA: A.4.t
        A = A&event_A;
    }
    G&Aye,'ev',9,{ev:ev}

# G&e: see j/23 NutJayTo

# G&E: see j/28 NutFactorEase
#   safe/autovivifying data grabs at c&e

u jc
n \'of:ev'

# event details gathered, finds Js
# build a C of elvis
ev 1: %any
    G&way,'EleVisAn',{},'noop';
    G&way,'EleMento';

# events handled real fast, OR plan for A:n made
ev 2: %any
    G&way,'EleVisAn';
    T.el and return T.not = 'satisfied ev@2'

# A:n to a found J to go make change happen in
ev 3: %any
    $n = a&wouldn;
    !n and return
    T.not = 'A:n ev@3'; # stop ev forever
    G&n,n;
    
#  < ev or e can get lost/pointless/broke and should be helped
# events may have to pile up to become meaningful?
# < G&vent for handling various uncertainties in various situations
ev 4: %any
    a&msg.set("state","no");


#c A:n c&e springs into consciousness
# A:e, tugged along with A:n/Jing every 0.1
#  may until after 6 for event handlers (1s&ein) to clarify,
#  or even after 7 for operations on tv

# if some retry-ish thing is happening?
n \'of:n'
e 2:
    $e = s;
    $E = e.y.A;
    E && E.t == 'ev' and E = null;
    if (!E) {
        # spawn A:e after A:n@13, inherits A.1 = s&J
        E = e.y.A = G&Aye,'e',2,{s:e};
        A.e = E;
        E.n = A;
        # wake us
        Es&N ||= [];
        Es&N.push(A);
    }
    E.n != A and throw "A:e.n not us", E, A
    A.e != E and throw "A:n.e not elvis", A, E
    # happens in steps in sync with n wakeness
    G&thro,A.e,2
0 &&
e 3:
    G&thro,A.e,3
e 4:
    G&thro,A.e,4
e 5:
    G&thro,A.e,5
0 &&
e 6:
    G&thro,A.e,6
0 &&
e 7:
    G&thro,A.e,7
e 8:
    G&thro,A.e,8;
    A.e.cv < 0.8 and ~>17 lost e: A.e.cv+'/'+A.cv+'@'+C.t, 4s&ki(c&e)

n \'of:e'
# look through handlers, or wait for clearer time...
# J usu define api/event handlers in the first section of the pin
#  then in the call that makes a section heading we have a chance to complete
#  may need to be oscillated fully to process the request
#  may want to wait for a quiet time, if it's a human
einlookup 1: %any
    T.once = 1;
    $Js = c&Jat ? c&Jat.slice() : [A.1];
    $anein = 0;
    Js.reverse();
    each iJ Js {
        # last resort/undelivered
        J == J.4 and break
        # if near attention should try to create the handler
        #J == J.3
        # A.1 will not be correct...
        # < isolate reaction down this Jath
        #J != J.3
        # otherwise, the usual...
        
    $ein = Js&ein;
    !ein and continue
    anein = 1
    #!ein and return T.not = 2;
    
    A&idea = ein[C.t];
    if (!A&idea) {
        $parts = C.t.split('+');
        each it parts {
            A&idea = ein[t];
        }
    }
    typeof A&idea == 'function' and A&idea = {i:A&idea}
    
    $id = A&idea ? 4s&ki(A&idea) : 'no ein';
    ~>86 elvis: ki(J,2), C.t, id
    # first/deepest one
    A&idea and break
    
    }
    !anein and return T.not = 2;
    !A&idea and return T.not = 1;
    

#c e/edo
# liable to throw, thro repeating D would be annoying?
# should only have one way to do,
#   posit doing this way as a dome, so it can be onced?
# J must be ready (or not)
edo 4: %any
    T.once = 1;
    T.el and return
    # some vars
    $ar = {};
    ar.M = 1s&M = 1s&M || [];
    $e = ar.e = C;
    ec&s and ar.s = ec&s;
    C = A.n.c.s;
    # two ways about it
    each way,pin A&idea {
        if (way == 'w') {
            G&way,pin,ar;
        }
        else
        if (way == 'i') {
            $l = G&arfgunc,pin;
            # s = e.c.s? good for NutText/typing which 'says'
            l == 'A,C,G,T,s' and pin(A,C,G,T,ar.s)
            elsif (l == 'A,C,G,T,s,c') {
                # < Ec is the most pointed to thing... see Ch
                $c = G&E:'hC -1';
                pin(A,C,G,T,ar.s,c)
            }
            else {
                throw "Buildargs: "+l, s
            }
        }
        else {
            throw "idea not i/w", A&idea
        }
    }
    # can repeat: e.t -> A&idea -> here ^
    T.seek and return delete T.once;
    T.el = 1;

# satisfaction?
# T.el == handled & want to awake
# T.ok == handled & no change/J6 can sleep
edone 5: %any
    if (T.ok) {
        A.cv = 0.9;
        if (A.n.cv <= 0.6) {
            ~Can avoid J6ing:
            T.not = 1;
            $oT = nA&T;
            oT.not = 1;
            # put a 5 block e doing id
            oT.leaves = 'elvis';
            return;
        }
        ~Could avoid J6 next time:
    }
    T.not = 2;

music 8: %any
    # yep
